<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-249">
    <a id="_idTextAnchor251">
    </a>
    
     13
    
   </h1>
   <h1 id="_idParaDest-250">
    <a id="_idTextAnchor252">
    </a>
    
     Implementing Data-Oriented Calculations with Mass
    
   </h1>
   <p>
    
     The
    
    <strong class="bold">
     
      Mass
     
    </strong>
    
     framework is a
    
    <a id="_idIndexMarker661">
    </a>
    
     relatively new system in Unreal Engine that allows developers to efficiently manage and manipulate large numbers of objects within a game environment together.
    
    
     It provides tools and functionalities to handle them effectively, optimize performance, and implement behaviors for AI and gameplay mechanics.
    
    
     The Mass framework is becoming an essential tool for creating game levels that require large numbers of NPCs while maintaining optimal performance levels in projects.
    
    
     Taking advantage of the Mass framework is essential for game developers to create immersive and engaging experiences while maintaining
    
    
     
      optimal performance.
     
    
   </p>
   <p>
    
     In this chapter, we will be presenting the basics of Mass and showing you how to create your own Mass systems.
    
    
     In particular, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing the
     
     
      
       Mass framework
      
     
    </li>
    <li>
     
      Setting
     
     
      
       up Mass
      
     
    </li>
    <li>
     
      
       Spawning Blueprints
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-251">
    <a id="_idTextAnchor253">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow the topics presented in this chapter, you should have completed the previous ones and understood
    
    
     
      their content.
     
    
   </p>
   <p>
    
     Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the
    
    <strong class="source-inline">
     
      .zip
     
    </strong>
    
     project files provided in the project
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5">
     
      
       https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5
      
     
    </a>
   </p>
   <p>
    
     To download the files from the end of the last chapter, click the
    
    <strong class="source-inline">
     
      Unreal Agility Arena –
     
    </strong>
    
     <strong class="source-inline">
      
       Chapter 12
      
     </strong>
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     <strong class="source-inline">
      
       End
      
     </strong>
    
    
     
      link.
     
    
   </p>
   <h1 id="_idParaDest-252">
    <a id="_idTextAnchor254">
    </a>
    
     Introducing the Mass framework
    
   </h1>
   <p>
    
     The Mass framework
    
    <a id="_idIndexMarker662">
    </a>
    
     is a data-oriented system created for managing high-performance computations on extensive collections of entities.
    
    
     As you already know, in Unreal Engine, the traditional approach involves using actors and components to create level objects.
    
    
     This approach offers great flexibility for combining logic within actors, but as the project grows larger, it often results in data inconsistencies that lead to performance issues.
    
    
     For example, consider a large online multiplayer game where different AI agents can perform various actions based on complex logic.
    
    
     Initially, this flexibility allows developers to easily implement features such as character interactions and item trading with minimal constraints.
    
    
     However, as more characters and interactions are added, inconsistencies with data updates across the network
    
    
     
      can arise.
     
    
   </p>
   <p>
    
     Mass, on the other hand, employs a data-oriented design framework that offers an alternative data storage method to separate data from processing logic.
    
    
     This allows for easy management of big – or even huge – numbers of entities in
    
    
     
      the level.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In this chapter, I will often use the
    
    <a id="_idIndexMarker663">
    </a>
    
     term
    
    <strong class="bold">
     
      level of detail
     
    </strong>
    
     (
    
    <strong class="bold">
     
      LOD
     
    </strong>
    
     ).
    
    
     In case you are unfamiliar with this term, it is a crucial concept in game development that refers to the technique of managing the complexity of 3D models based on their distance from the camera.
    
    
     The primary goal of LOD is to optimize rendering performance while maintaining visual fidelity.
    
    
     When a player is close to a static mesh, the engine uses a high-detail version of that mesh to ensure it looks sharp and detailed.
    
    
     However, as the player moves further away, the engine can switch to less detailed versions of the mesh, which require fewer resources
    
    
     
      to render.
     
    
   </p>
   <p>
    
     In the upcoming subsections, I will give you a quick introduction to the main definitions and elements that make up the
    
    
     
      Mass framework.
     
    
   </p>
   <h2 id="_idParaDest-253">
    <a id="_idTextAnchor255">
    </a>
    
     Mass framework plugins
    
   </h2>
   <p>
    
     Mass relies on
    
    <a id="_idIndexMarker664">
    </a>
    
     four
    
    
     
      main plugins:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       MassEntity
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker665">
     </a>
     
      framework core plugin that is required to make
     
     
      
       Mass work
      
     
    </li>
    <li>
     <strong class="bold">
      
       MassGameplay
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker666">
     </a>
     
      plugin manages situations such as interaction within the world, movement, object visualization, LOD, and
     
     
      
       so on
      
     
    </li>
    <li>
     <strong class="bold">
      
       MassAI
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker667">
     </a>
     
      plugin manages features such as state trees, world navigation,
     
     
      
       and avoidance
      
     
    </li>
    <li>
     <strong class="bold">
      
       MassCrowd
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker668">
     </a>
     
      plugin is specialized in handling crowds and has its own specialized visualization and
     
     
      
       navigation systems
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     At the time of writing this book,
    
    <strong class="source-inline">
     
      MassEntity
     
    </strong>
    
     is in beta and considered production-ready.
    
    
     On the other hand,
    
    <strong class="source-inline">
     
      MassGameplay
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      MassAI
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      MassCrowd
     
    </strong>
    
     are still experimental; this means you should handle them with care as things may change as time
    
    
     
      goes by.
     
    
   </p>
   <h2 id="_idParaDest-254">
    <a id="_idTextAnchor256">
    </a>
    
     Understanding Mass elements
    
   </h2>
   <p>
    
     The primary
    
    <a id="_idIndexMarker669">
    </a>
    
     data structure within
    
    <strong class="source-inline">
     
      MassEntity
     
    </strong>
    
     is the
    
    <strong class="bold">
     
      fragment
     
    </strong>
    
     – an
    
    <a id="_idIndexMarker670">
    </a>
    
     atomic unit of data used in computations – that can be represented for example by transform, velocity, or LOD index.
    
    
     Fragments can be organized into sets, with a specific set instance linked to an ID, forming
    
    
     
      an
     
    
    
     <strong class="bold">
      
       entity
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Creating an
    
    <a id="_idIndexMarker671">
    </a>
    
     entity resembles class instantiation in object-oriented programming.
    
    
     However, instead of rigidly defining a class and its functionalities, entities are constructed through fragment composition.
    
    
     These composition assemblies are modifiable
    
    
     
      at runtime.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Fragments and entities are data-only elements and do not contain
    
    
     
      any logic.
     
    
   </p>
   <p>
    
     A set of entities with the same composition is
    
    <a id="_idIndexMarker672">
    </a>
    
     called an
    
    <strong class="bold">
     
      archetype
     
    </strong>
    
     ; each archetype comprises various types of fragments arranged in a specific manner.
    
    
     For instance, an archetype might feature a fragment composition with transform and velocity, indicating that all entities linked to this archetype share the same
    
    
     
      fragment structure.
     
    
   </p>
   <p>
    
     Entities within an archetype are grouped
    
    <a id="_idIndexMarker673">
    </a>
    
     into memory
    
    <strong class="bold">
     
      chunks
     
    </strong>
    
     , optimizing the retrieval of fragments belonging to entities of the corresponding archetype from memory for
    
    
     
      enhanced performance.
     
    
   </p>
   <p>
    
     A
    
    <strong class="bold">
     
      ChunkFragment
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker674">
    </a>
    
     fragment connected to a chunk rather than an entity and is used to store chunk-specific data that is utilized in processing.
    
    
     ChunkFragments are an integral part of an
    
    
     
      entity’s composition.
     
    
   </p>
   <p>
    
     A
    
    <strong class="bold">
     
      tag
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker675">
    </a>
    
     simple fragment that does not contain any data; tags are included in an
    
    
     
      entity’s composition.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Processors
     
    </strong>
    
     are
    
    <a id="_idIndexMarker676">
    </a>
    
     stateless classes that provide the processing logic for fragments; by using
    
    <strong class="bold">
     
      EntityQueries
     
    </strong>
    
     , they
    
    <a id="_idIndexMarker677">
    </a>
    
     specify the types of fragments they require for their operations.
    
    
     Processors can add or remove an entity’s fragments or tags, effectively changing
    
    
     
      the composition.
     
    
   </p>
   <p>
    
     Fragments and processors delivering specific functionalities are
    
    <a id="_idIndexMarker678">
    </a>
    
     named
    
    <strong class="bold">
     
      traits
     
    </strong>
    
     ; multiple instances of traits can be incorporated into an entity.
    
    
     Each instance of a trait is tasked with integrating and setting up fragments to ensure that the entity displays the behavior associated with that trait.
    
    
     Typical traits include state tree management, avoidance, or
    
    
     
      debug visualization.
     
    
   </p>
   <p>
    
     As
    
    <strong class="source-inline">
     
      MassGameplay
     
    </strong>
    
     is probably the most important of the Mass plugins, we will focus on it.
    
    
     Let’s get into detail on its
    
    
     
      main features.
     
    
   </p>
   <h2 id="_idParaDest-255">
    <a id="_idTextAnchor257">
    </a>
    
     MassGameplay
    
   </h2>
   <p>
    
     As mentioned, one of
    
    <a id="_idIndexMarker679">
    </a>
    
     the plugins that compose the Mass framework is the
    
    <strong class="source-inline">
     
      MassGameplay
     
    </strong>
    
     plugin, which is derived directly from the
    
    <strong class="source-inline">
     
      MassEntity
     
    </strong>
    
     plugin.
    
    
     The
    
    <strong class="source-inline">
     
      MassGameplay
     
    </strong>
    
     plugin includes a list of powerful subsystems that are
    
    
     
      listed here:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Mass Representation
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker680">
     </a>
     
      subsystem is responsible for managing different visual aspects
     
     
      
       of entities
      
     
    </li>
    <li>
     <strong class="bold">
      
       Mass Spawner
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker681">
     </a>
     
      subsystem manages the entities’
     
     
      
       spawning process
      
     
    </li>
    <li>
     <strong class="bold">
      
       Mass LOD
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker682">
     </a>
     
      subsystem manages the LOD of each
     
     
      
       mass entity
      
     
    </li>
    <li>
     <strong class="bold">
      
       Mass State Tree
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker683">
     </a>
     
      subsystem will let you integrate state trees
     
     
      
       inside
      
     
     
      <strong class="source-inline">
       
        MassEntity
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       Mass Signals
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker684">
     </a>
     
      subsystem manages messages to entities in a similar way to
     
     
      
       event dispatching
      
     
    </li>
    <li>
     <strong class="bold">
      
       Mass Movement
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker685">
     </a>
     
      subsystem manages movement for
     
     
      
       Mass agents
      
     
    </li>
    <li>
     <strong class="bold">
      
       Mass SmartObject
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker686">
     </a>
     
      system is responsible for integrating smart objects – a feature I will be presenting in the next chapter –
     
     
      
       inside
      
     
     
      <strong class="source-inline">
       
        MassEntity
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Mass Replication
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker687">
     </a>
     
      subsystem is responsible for replicating Entities over the network in multiplayer games; at the time of writing this book, it is still in the
     
     
      
       experimental stages
      
     
    </li>
   </ul>
   <p>
    
     With the availability of all
    
    <a id="_idIndexMarker688">
    </a>
    
     these subsystems, Mass has become an incredibly powerful tool for efficiently managing a vast number
    
    
     
      of entities.
     
    
   </p>
   <p>
    
     In this section, we introduced the Mass framework and its main elements.
    
    
     In the next section, we will be creating our first level using Mass, leveraging some of its
    
    
     
      main features.
     
    
   </p>
   <h1 id="_idParaDest-256">
    <a id="_idTextAnchor258">
    </a>
    
     Setting up Mass
    
   </h1>
   <p>
    
     The story
    
    
     
      goes on…
     
    
   </p>
   <p>
    <em class="italic">
     
      As Dr.
     
     
      Markus and Professor Victoria delved deeper into their groundbreaking research on AI, they found themselves faced with a new challenge; the laboratory was now filled with a large number of AI dummy puppets, each designed to mimic human behavior and responses.
     
     
      However, managing and synchronizing these puppets proved to be a
     
    </em>
    
     <em class="italic">
      
       daunting task.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      In order to overcome this obstacle, Dr.
     
     
      Markus and Professor Victoria started by developing a sophisticated set of algorithms that would act as the core system for managing the puppets.
     
     
      This system would allow them to sync and coordinate the movements and actions of the AI puppets, making them work
     
    </em>
    
     <em class="italic">
      
       seamlessly together.
      
     </em>
    
   </p>
   <p>
    
     In this section, we
    
    <a id="_idIndexMarker689">
    </a>
    
     will show which plugins are needed to use Mass and how to enable them.
    
    
     Also, we will be working on a new level to get a first peek at the
    
    
     
      spawning system.
     
    
   </p>
   <h2 id="_idParaDest-257">
    <a id="_idTextAnchor259">
    </a>
    
     Enabling plugins
    
   </h2>
   <p>
    
     In
    
    <a id="_idIndexMarker690">
    </a>
    
     order to make Mass fully functional, you will need to enable the
    
    
     
      following plugins:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        MassEntity
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        MassGameplay
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        MassAI
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        MassCrowd
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        ZoneGraph
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        StateTree
       
      </strong>
     
    </li>
   </ul>
   <p>
    <strong class="source-inline">
     
      ZoneGraph
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      StateTree
     
    </strong>
    
     are not part of the Mass framework but need to be included because of some dependencies in
    
    
     
      the code.
     
    
   </p>
   <p>
    
     You are already familiar with the
    
    <strong class="bold">
     
      Plugin
     
    </strong>
    
     window, so open it up and enable the aforementioned plugins.
    
    
     You will get a warning about the experimental features you will be using and then you will be prompted to reload the Unreal Engine Editor in order to register
    
    
     
      the plugins.
     
    
   </p>
   <p>
    
     Once this process is finished, you will be ready to get on
    
    
     
      with Mass.
     
    
   </p>
   <h2 id="_idParaDest-258">
    <a id="_idTextAnchor260">
    </a>
    
     Creating a MassEntityConfigAsset
    
   </h2>
   <p>
    
     In
    
    <a id="_idIndexMarker691">
    </a>
    
     Mass, configuring entities is achieved through an Unreal Engine
    
    
     <strong class="bold">
      
       data asset
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In case you are unfamiliar with a data asset, it is a type of asset that stores data in a structured format.
    
    
     It is typically used to store various types of data, such as configuration settings, game parameters, localization text,
    
    
     
      and more.
     
    
   </p>
   <p>
    
     In Mass, you will be using a
    
    <strong class="source-inline">
     
      MassEntityConfigAsset
     
    </strong>
    
     data type, which will store trait information and fragments.
    
    
     As a starting point, we will be creating a config asset that will just let us debug information on where an object has been spawned in the level.
    
    
     This
    
    <a id="_idIndexMarker692">
    </a>
    
     will let us visualize the current state of the system we are developing and analyze it
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     To get started, in
    
    <strong class="bold">
     
      Content Drawer
     
    </strong>
    
     , create a new folder named
    
    <strong class="source-inline">
     
      DataAssets
     
    </strong>
    
     and open it up.
    
    
     Then, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Right-click on
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      and select
     
     <strong class="bold">
      
       Miscellaneous
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Data Asset
      
     </strong>
     
      ; name the newly created
     
     
      
       asset
      
     
     
      <strong class="source-inline">
       
        ME_DebugVisualizationConfig
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Config
      
     </strong>
     
      section, you should see a
     
     <strong class="bold">
      
       Traits
      
     </strong>
     
      array; hit the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to create a new item in
     
     
      
       the array.
      
     
    </li>
    <li>
     
      From the array item dropdown menu, select
     
     
      <strong class="bold">
       
        Debug Visualization
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Expand the array item by clicking on
     
     
      
       the arrow.
      
     
    </li>
    <li>
     
      Expand the
     
     <strong class="bold">
      
       Debug Shape
      
     </strong>
     
      
       attribute too.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Mesh
      
     </strong>
     
      attribute, search for
     
     <strong class="bold">
      
       Dummy_Base
      
     </strong>
     
      and select it, as shown in
     
     
      <em class="italic">
       
        Figure 13
       
      </em>
     
     
      <em class="italic">
       
        .1
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.1 – ME_DebugVisualizationConfig" src="img/Figure_13.1_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.1 – ME_DebugVisualizationConfig
    
   </p>
   <p>
    
     What we have done here is quite simple.
    
    
     We created a
    
    <strong class="source-inline">
     
      MassEntity
     
    </strong>
    
     configuration file with a single trait responsible for displaying a debug mesh at the location where an object has been
    
    <a id="_idIndexMarker693">
    </a>
    
     spawned in
    
    
     
      the level.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     If you need to check that everything is fine, you can click the
    
    <strong class="bold">
     
      Validate Entity Config
     
    </strong>
    
     button that is located inside the
    
    <strong class="bold">
     
      Data Asset
     
    </strong>
    
     window.
    
    
     You should get a message stating that there are no errors in
    
    
     
      this asset.
     
    
   </p>
   <p>
    
     We will now proceed with the object
    
    
     
      spawn implementation.
     
    
   </p>
   <h2 id="_idParaDest-259">
    <a id="_idTextAnchor261">
    </a>
    
     Creating a spawn EQS
    
   </h2>
   <p>
    
     To take
    
    <a id="_idIndexMarker694">
    </a>
    
     advantage of the Mass Spawner subsystem, we will need an EQS that will return a set of locations that will tell the subsystem where to spawn objects.
    
    
     If you need a refresher about EQS, my advice is to check
    
    <a href="B31016_11.xhtml#_idTextAnchor218">
     
      <em class="italic">
       
        Chapter 11
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Understanding the Environment Query System
     
    </em>
    
     , and then get back to this chapter when you are ready.
    
    
     We will be now creating an environment query that will just generate some points on a grid.
    
    
     In order to do so, open the
    
    <strong class="source-inline">
     
      AI
     
    </strong>
    
     folder and follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Right-click and select
     
     <strong class="bold">
      
       Artificial Intelligence
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Environment Query
      
     </strong>
     
      .
     
     
      Name the newly created asset
     
     <strong class="source-inline">
      
       EQS_SpawnEntitiesOnGrid
      
     </strong>
     
      .
     
     
      Double-click on the asset to
     
     
      
       open it.
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       ROOT
      
     </strong>
     
      node, click and drag to create a
     
     <strong class="bold">
      
       Points: Grid
      
     </strong>
     
      node from the
     
     
      <strong class="bold">
       
        Generators
       
      </strong>
     
     
      
       category.
      
     
    </li>
    <li>
     
      Click on the node and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         GridHalfSize
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          1500.0
         
        </strong>
       
      </li>
      <li>
       
        In the
       
       <strong class="bold">
        
         Projection Data
        
       </strong>
       
        section, set the
       
       <strong class="bold">
        
         Trace Mode
        
       </strong>
       
        attribute to
       
       <strong class="bold">
        
         Geometry
        
       </strong>
       
        <strong class="bold">
         
          by Channel
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 13.2 – Environment query" src="img/Figure_13.2_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.2 – Environment query
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker695">
    </a>
    
     environment query we have just implemented will create a grid sized 3,000 by 3,000 – as we have set the
    
    <strong class="bold">
     
      GridHalfSize
     
    </strong>
    
     property with a value of
    
    <strong class="source-inline">
     
      1500.0
     
    </strong>
    
     units – and will use a
    
    <strong class="bold">
     
      Geometry by Channel
     
    </strong>
    
     trace method to set the location of
    
    
     
      each item.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     If you are unfamiliar with what traces are and how Unreal Engine uses them, my advice is to take a peek at the official documentation by visiting this page from the official documentation
    
    
     
      at
     
    
    <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview">
     
      
       https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     We are now ready to use the Mass Spawner subsystem inside
    
    
     
      a level.
     
    
   </p>
   <h2 id="_idParaDest-260">
    <a id="_idTextAnchor262">
    </a>
    
     Creating the gym
    
   </h2>
   <p>
    
     To test the
    
    <a id="_idIndexMarker696">
    </a>
    
     spawning feature, we are going to create a simple gym.
    
    
     To get started, create a level of your choice, starting from the Level Instances and Packed Level Actors I provided in the project template.
    
    
     If you wish, add some obstacles; my level is shown in
    
    
     <em class="italic">
      
       Figure 13
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 13.3 – Gym" src="img/Figure_13.3_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.3 – Gym
    
   </p>
   <p>
    
     Now, follow
    
    <a id="_idIndexMarker697">
    </a>
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      On the
     
     <strong class="bold">
      
       Editor
      
     </strong>
     
      toolbar, click on the
     
     <strong class="bold">
      
       Quickly add to the project
      
     </strong>
     
      button and search for
     
     <strong class="bold">
      
       Mass Spawner
      
     </strong>
     
      .
     
     
      Select it to add an instance of it in
     
     
      
       the level.
      
     
    </li>
    <li>
     
      Place the
     
     <strong class="bold">
      
       MassSpawner
      
     </strong>
     
      object at the center of
     
     
      
       your level.
      
     
    </li>
    <li>
     
      Now that you have placed the
     
     <strong class="bold">
      
       MassSpawner
      
     </strong>
     
      object in the level, select it.
     
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Count
        
       </strong>
       
        property
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          20
         
        </strong>
       
      </li>
      <li>
       
        Click the
       
       <strong class="bold">
        
         +
        
       </strong>
       
        button on the
       
       <strong class="bold">
        
         Entity Types
        
       </strong>
       
        attribute to add an item to
       
       
        
         the array
        
       
      </li>
      <li>
       
        Expand the item marked as
       
       <strong class="bold">
        
         Index[0]
        
       </strong>
       
        and set the
       
       <strong class="bold">
        
         Entity Config
        
       </strong>
       
        property
       
       
        
         to
        
       
       
        <strong class="bold">
         
          ME_DebugVisualizationConfig
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 13.4 – Entry types" src="img/Figure_13.4_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.4 – Entry types
    
   </p>
   <p>
    
     We just set the
    
    <strong class="bold">
     
      MassSpawner
     
    </strong>
    
     property so that it spawns 20 entities that will use the data asset we previously created as the configuration asset.
    
    
     We now need to tell the
    
    <strong class="bold">
     
      MassSpawner
     
    </strong>
    
     property
    
    <a id="_idIndexMarker698">
    </a>
    
     where to spawn them.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, add an element to the
     
     <strong class="bold">
      
       Spawn Data Generator
      
     </strong>
     
      array and expand the
     
     
      <strong class="bold">
       
        Index[0]
       
      </strong>
     
     
      
       element.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Generator Instance
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       EQS
      
     </strong>
     
      <strong class="bold">
       
        SpawnPoints Generator
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Expand
     
     <strong class="bold">
      
       Generator Instance
      
     </strong>
     
      and its
     
     
      <strong class="bold">
       
        Query
       
      </strong>
     
     
      
       child.
      
     
    </li>
    <li>
     
      Set
     
     <strong class="bold">
      
       Query Template
      
     </strong>
     
      
       to
      
     
     
      <strong class="bold">
       
        EQS_SpawnEntitiesOnGrid
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.5 – Spawn point generator" src="img/Figure_13.5_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.5 – Spawn point generator
    
   </p>
   <p>
    
     In the previous steps, we have set the generator logic to the entity query we had previously created.
    
    
     It’s now time to test
    
    
     
      the gym.
     
    
   </p>
   <h2 id="_idParaDest-261">
    <a id="_idTextAnchor263">
    </a>
    
     Testing the gym
    
   </h2>
   <p>
    
     To test
    
    <a id="_idIndexMarker699">
    </a>
    
     the gym, all you need to do is to simulate – or play – the level; you will see 20 debug models spawned on a grid, as shown in
    
    
     <em class="italic">
      
       Figure 13
      
     </em>
    
    
     <em class="italic">
      
       .6
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 13.6 – Gym" src="img/Figure_13.6_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.6 – Gym
    
   </p>
   <p>
    
     Please
    
    <a id="_idIndexMarker700">
    </a>
    
     note that models will be correctly placed on objects; this is happening because we used the
    
    <strong class="bold">
     
      Geometry by Channel
     
    </strong>
    
     trace mode inside our
    
    
     
      environment query.
     
    
   </p>
   <p>
    
     By enabling the debugging tools, you will have some insightful information about what’s happening inside the level along with a plethora of options, as depicted in
    
    
     <em class="italic">
      
       Figure 13
      
     </em>
    
    
     <em class="italic">
      
       .7
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 13.7 – Debugging tools" src="img/Figure_13.7_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.7 – Debugging tools
    
   </p>
   <p>
    
     I highly encourage you to explore the various debugging tool options, as they can greatly enhance your efficiency in identifying and resolving your game issues.
    
    
     As an example,
    
    
     <em class="italic">
      
       Figure 13
      
     </em>
    
    <em class="italic">
     
      .8
     
    </em>
    
     shows the archetype information that was enabled by using the
    
    <em class="italic">
     
      Shift
     
    </em>
    
     +
    
    <em class="italic">
     
      A
     
    </em>
    
     
      key combination:
     
    
   </p>
   <div><div><img alt="Figure 13.8 – Archetype information" src="img/Figure_13.8_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.8 – Archetype information
    
   </p>
   <p>
    
     In this section, we
    
    <a id="_idIndexMarker701">
    </a>
    
     got a glimpse of what’s possible to create with Mass; in particular, we saw how to create a spawn area through the
    
    <strong class="bold">
     
      MassSpawner
     
    </strong>
    
     subsystem.
    
    
     In the next section, we will go into more detail by spawning a set of Blueprints instead of some
    
    
     
      debugging models.
     
    
   </p>
   <h1 id="_idParaDest-262">
    <a id="_idTextAnchor264">
    </a>
    
     Spawning Blueprints
    
   </h1>
   <p>
    
     In this
    
    <a id="_idIndexMarker702">
    </a>
    
     section, we will be taking a step further with the
    
    <strong class="bold">
     
      MassSpawner
     
    </strong>
    
     subsystem as we will be generating a set of Blueprint instances instead of simply showing debug meshes; this will let us transition from a simple debugging gym to a real case environment.
    
    
     Additionally, we will learn how to handle the LOD for
    
    
     
      spawned entities.
     
    
   </p>
   <p>
    
     Let’s imagine that we want to create a concert where the audience is automatically generated, and it is managed as a whole by Mass.
    
    
     We will be creating such a scenario using the
    
    
     
      Mass framework.
     
    
   </p>
   <h2 id="_idParaDest-263">
    <a id="_idTextAnchor265">
    </a>
    
     Creating the audience Blueprints
    
   </h2>
   <p>
    
     As a first step, we will be
    
    <a id="_idIndexMarker703">
    </a>
    
     creating a Blueprint that will serve us as the audience for an imaginary concert; entities will be
    
    <a id="_idIndexMarker704">
    </a>
    
     cheering, sitting, or simply staying still.
    
    
     Additionally, we will be using the Mass LOD management system.
    
    
     Instead of creating just one Blueprint, we will be creating two: one that will be activated by the management system when near the camera and the other that will be activated when far away.
    
    
     This will let us manage and show more complex entities only when near the camera and fall back to less complex entities when far away.
    
    
     For the sake of demonstration, we will be using a Blueprint that will just stay still and won’t be animated – the one that will be visualized when far away – and one that will show
    
    
     
      random animations.
     
    
   </p>
   <p>
    
     Let’s start with the
    
    <a id="_idIndexMarker705">
    </a>
    
     first Blueprint
    
    <a id="_idIndexMarker706">
    </a>
    
     by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new Blueprint class inheriting from
     
     <strong class="bold">
      
       BaseDummyCharacter
      
     </strong>
     
      and call
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        BP_AudienceLow
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open the Blueprint, and in the
     
     <strong class="bold">
      
       Animation Mode
      
     </strong>
     
      property, select
     
     <strong class="bold">
      
       Use
      
     </strong>
     
      <strong class="bold">
       
        Animation Asset
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Uncheck the
     
     <strong class="bold">
      
       Looping
      
     </strong>
     
      and
     
     
      <strong class="bold">
       
        Playing
       
      </strong>
     
     
      
       checkboxes.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Initial Position
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        0.4
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Once visualized in the level, this character will just stand still and show a
    
    
     
      cheering position.
     
    
   </p>
   <p>
    
     The second Blueprint is going to be slightly more complex.
    
    
     To implement it, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new Blueprint class inheriting from
     
     <strong class="bold">
      
       BaseDummyCharacter
      
     </strong>
     
      and call
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        BP_AudienceHigh
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Create a new variable of the
     
     <strong class="bold">
      
       Anim Montage Object Reference
      
     </strong>
     
      type, call it
     
     <strong class="source-inline">
      
       MontageList
      
     </strong>
     
      , and make it
     
     
      
       an array.
      
     
    </li>
    <li>
     
      Create two variables of the
     
     <strong class="bold">
      
       float
      
     </strong>
     
      type and name them
     
     <strong class="source-inline">
      
       MinInterval
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        MaxInterval
       
      </strong>
     
     
      
       , respectively.
      
     
    </li>
    <li>
     
      Compile the Blueprint to expose the
     
     <strong class="bold">
      
       Default Value
      
     </strong>
     
      properties and set the
     
     <strong class="bold">
      
       MinInterval
      
     </strong>
     
      value to
     
     <strong class="source-inline">
      
       3.0
      
     </strong>
     
      and
     
     <strong class="bold">
      
       MaxInterval
      
     </strong>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        6.0
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add three items in
     
     <strong class="bold">
      
       MontageList
      
     </strong>
     <strong class="bold">
      
       Default Value
      
     </strong>
     
      and set them, respectively, to
     
     <strong class="source-inline">
      
       AM_Cheer
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       AM_Interact
      
     </strong>
     
      ,
     
     
      
       and
      
     
     
      <strong class="source-inline">
       
        AM_Sit
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the Event Graph, connect the
     
     <strong class="bold">
      
       Event Begin Play
      
     </strong>
     
      execution pin to a
     
     
      <strong class="bold">
       
        Delay
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       Duration
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Delay
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Random Float in
      
     </strong>
     
      <strong class="bold">
       
        Range
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Variables
      
     </strong>
     
      section, drag a
     
     <strong class="bold">
      
       MinInterval
      
     </strong>
     
      getter node and connect it to the
     
     <strong class="bold">
      
       Min
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Random Float in
      
     </strong>
     
      <strong class="bold">
       
        Range
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      From
     
     <a id="_idIndexMarker707">
     </a>
     
      the
     
     <strong class="bold">
      
       Variables
      
     </strong>
     
      section, drag a
     
     <strong class="bold">
      
       MaxInterval
      
     </strong>
     
      getter
     
     <a id="_idIndexMarker708">
     </a>
     
      node and connect it to the
     
     <strong class="bold">
      
       Max
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Random Float in Range
      
     </strong>
     
      node.
     
     
      This portion of the graph is depicted in
     
     
      <em class="italic">
       
        Figure 13
       
      </em>
     
     
      <em class="italic">
       
        .8
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt=" Figure 13.9 – Delay logic" src="img/Figure_13.9_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.9 – Delay logic
    
   </p>
   <p class="list-inset">
    
     This portion of the graph is nothing fancy and is just adding a random delay to the code logic.
    
    
     Let’s get on with the code by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="10">
     
      Connect the outgoing execution pin of the
     
     <strong class="bold">
      
       Delay
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Play
      
     </strong>
     
      <strong class="bold">
       
        Montage
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Components
      
     </strong>
     
      panel, drag a
     
     <strong class="bold">
      
       Mesh
      
     </strong>
     
      reference in the Event Graph and connect it to the
     
     <strong class="bold">
      
       In Skeletal Mesh Component
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Play
      
     </strong>
     
      <strong class="bold">
       
        Montage
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Drag a
     
     <strong class="bold">
      
       MontageList
      
     </strong>
     
      getter in the Event Graph and connect its pin to a
     
     <strong class="bold">
      
       Random Array
      
     </strong>
     
      <strong class="bold">
       
        Item
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       Out Item
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Random
      
     </strong>
     
      node to the
     
     <strong class="bold">
      
       Montage to Play
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Play Montage
      
     </strong>
     
      node.
     
     
      This part of the graph is shown in
     
     
      <em class="italic">
       
        Figure 13
       
      </em>
     
     
      <em class="italic">
       
        .10
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.10 – Play Montage logic" src="img/Figure_13.10_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.10 – Play Montage logic
    
   </p>
   <p class="list-inset">
    
     Here we are
    
    <a id="_idIndexMarker709">
    </a>
    
     doing something
    
    <a id="_idIndexMarker710">
    </a>
    
     pretty straightforward; we are getting a random animation montage from the array and then we
    
    
     
      play it.
     
    
   </p>
   <p class="list-inset">
    
     The last thing to do is to create an infinite loop that will keep on playing an animation montage after a delay.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li value="14">
     
      Connect the
     
     <strong class="bold">
      
       On Completed
      
     </strong>
     
      outgoing execution pin of the
     
     <strong class="bold">
      
       Play Montage
      
     </strong>
     
      node to the incoming execution pin of the
     
     
      <strong class="bold">
       
        Delay
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Add a couple of reroute nodes, in order to make the graph clearer.
     
     
      The code is shown in
     
     
      <em class="italic">
       
        Figure 13
       
      </em>
     
     
      <em class="italic">
       
        .11
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.11 – Loop" src="img/Figure_13.11_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.11 – Loop
    
   </p>
   <p>
    
     Our character is now ready and, once instantiated in a level, will keep on playing random animations.
    
    
     We will now create the
    
    <strong class="bold">
     
      MassEntityConfigAsset
     
    </strong>
    
     for the
    
    <strong class="bold">
     
      MassSpawner
     
    </strong>
    
     that will be placed in
    
    
     
      the gym.
     
    
   </p>
   <h2 id="_idParaDest-264">
    <a id="_idTextAnchor266">
    </a>
    
     Creating a MassEntityConfigAsset
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      MassEntityConfigAsset
     
    </strong>
    
     we will be creating is going to be more complex than the
    
    <a id="_idIndexMarker711">
    </a>
    
     previous one.
    
    
     In this case, we
    
    <a id="_idIndexMarker712">
    </a>
    
     will need to spawn characters in the level, and we will need to handle what is instantiated depending on the distance from
    
    
     
      the camera.
     
    
   </p>
   <p>
    
     To get started, open the
    
    <strong class="source-inline">
     
      DataAssets
     
    </strong>
    
     folder, create a new
    
    <strong class="bold">
     
      Data Asset
     
    </strong>
    
     of the
    
    <strong class="bold">
     
      Mass Entity Config Asset
     
    </strong>
    
     type, and name it
    
    <strong class="source-inline">
     
      ME_AudienceConfig
     
    </strong>
    
     .
    
    
     Then, open it and perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="bold">
      
       Traits
      
     </strong>
     
      section, add three array elements by clicking the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button
     
     
      
       three times.
      
     
    </li>
    <li>
     
      From each of the items’ dropdown menus, select
     
     <strong class="bold">
      
       Mass Stationary Distance Visualization Trait
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       Assorted Fragments
      
     </strong>
     
      , and
     
     
      <strong class="bold">
       
        LODCollector
       
      </strong>
     
     
      
       , respectively.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.12 – Audience Config data asset" src="img/Figure_13.12_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.12 – Audience Config data asset
    
   </p>
   <p>
    
     We will now be checking each of them to get some information on how
    
    
     
      they work.
     
    
   </p>
   <h3>
    
     Configuring Mass Stationary Distance Visualization Trait
    
   </h3>
   <p>
    
     This
    
    <a id="_idIndexMarker713">
    </a>
    
     trait is
    
    <a id="_idIndexMarker714">
    </a>
    
     responsible for the visualization of the entity in the world and will need to be properly set in order to correctly show the actor in the level.
    
    
     So, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Expand the
     
     <strong class="bold">
      
       Trait
      
     </strong>
     
      item to show
     
     
      
       all settings.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       High Res Template Actor
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        BP_AudienceHigh
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Low Res Template Actor
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        BP_AudienceLow
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Expand
     
     <a id="_idIndexMarker715">
     </a>
     
      the
     
     <strong class="bold">
      
       Params
      
     </strong>
     
      section
     
     <a id="_idIndexMarker716">
     </a>
     
      and set the
     
     <strong class="bold">
      
       High
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Medium
      
     </strong>
     
      properties to
     
     <strong class="bold">
      
       High Res Spawned Actor
      
     </strong>
     
      and the
     
     <strong class="bold">
      
       Low
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       Low Res
      
     </strong>
     
      <strong class="bold">
       
        Spawned Actor
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Check the
     
     <strong class="bold">
      
       Keep Actor Extra
      
     </strong>
     
      <strong class="bold">
       
        Frame
       
      </strong>
     
     
      
       property.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.13 – Mass Stationary Distance Visualization settings" src="img/Figure_13.13_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.13 – Mass Stationary Distance Visualization settings
    
   </p>
   <p>
    
     As you can see here, we defined a high- and low-resolution template from the previously created Blueprints.
    
    
     Then we used these definitions to set the LOD representation for the entity.
    
    
     Checking the
    
    <strong class="bold">
     
      Keep Actor Extra Frame
     
    </strong>
    
     flag will help with rendering when transitioning between
    
    
     
      different LODs.
     
    
   </p>
   <h3>
    
     Configuring Assorted Fragments
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Assorted Fragments
     
    </strong>
    
     trait enables you to define an array of fragments that may be
    
    <a id="_idIndexMarker717">
    </a>
    
     required
    
    <a id="_idIndexMarker718">
    </a>
    
     by other traits.
    
    
     To achieve this, open the
    
    <strong class="bold">
     
      Assorted Fragments
     
    </strong>
    
     trait section and then the
    
    <strong class="bold">
     
      Fragments
     
    </strong>
    
     section and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Add two fragments to the array by clicking the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      
       button twice.
      
     
    </li>
    <li>
     
      Set the first item of the list to
     
     <strong class="bold">
      
       Transform Fragment
      
     </strong>
     
      and the second one to
     
     <strong class="bold">
      
       Mass
      
     </strong>
     
      <strong class="bold">
       
        Actor Fragment
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.14 – Assorted Fragments settings" src="img/Figure_13.14_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.14 – Assorted Fragments settings
    
   </p>
   <p>
    <strong class="bold">
     <a id="_idIndexMarker719">
     </a>
    </strong>
    <strong class="bold">
     
      Transform
     
    </strong>
    <strong class="bold">
     <a id="_idIndexMarker720">
     </a>
    </strong>
    <strong class="bold">
     
      Fragment
     
    </strong>
    
     is responsible for storing the entity world transform, while
    
    <strong class="bold">
     
      Mass Actor Fragment
     
    </strong>
    
     will hold a pointer to the actor that will be used by the
    
    
     
      visualization trait.
     
    
   </p>
   <h3>
    
     Configuring LODCollector
    
   </h3>
   <p>
    
     The
    
    <a id="_idIndexMarker721">
    </a>
    
     entity
    
    <a id="_idIndexMarker722">
    </a>
    
     configuration will need the
    
    <strong class="bold">
     
      LODCollector
     
    </strong>
    
     trait to facilitate the adjustment between LOD levels.
    
    
     The
    
    <strong class="bold">
     
      LODCollector
     
    </strong>
    
     processor
    
    <a id="_idIndexMarker723">
    </a>
    
     assesses the appropriate LOD for each entity by considering its proximity to viewers and its relationship to the
    
    
     
      camera frustum.
     
    
   </p>
   <p>
    
     It does not require any configuration, so you can leave it as
    
    
     
      it is.
     
    
   </p>
   <p>
    
     With the data asset properly configured, we can go on with setting up
    
    
     
      our system.
     
    
   </p>
   <h2 id="_idParaDest-265">
    <a id="_idTextAnchor267">
    </a>
    
     Enabling the automatic processor registration
    
   </h2>
   <p>
    
     Before
    
    <a id="_idIndexMarker724">
    </a>
    
     creating and testing
    
    <a id="_idIndexMarker725">
    </a>
    
     the gym, we will need to take one more step.
    
    
     At the time of writing this book, the current version of Mass needs some properties to have the
    
    <strong class="bold">
     
      Auto Register with Processing Phases
     
    </strong>
    
     flag enabled in the Mass settings; this is due to Mass still being in beta status and not yet a final release.
    
    
     Not setting this flag will result in the Mass entities not being visible in the game.
    
    
     This is due to some conflicts with the
    
    <strong class="source-inline">
     
      MassCrowd
     
    </strong>
    
     plugin that will be addressed in
    
    
     
      the future.
     
    
   </p>
   <p>
    
     To fix this issue, from the main menu, select
    
    <strong class="bold">
     
      Edit
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Project Settings
     
    </strong>
    
     and open the
    
    <strong class="bold">
     
      Engine
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Mass
     
    </strong>
    
     section.
    
    
     After that, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Expand the
     
     <strong class="bold">
      
       Module
      
     </strong>
     
      <strong class="bold">
       
        Settings
       
      </strong>
     
     
      
       section.
      
     
    </li>
    <li>
     
      Expand the
     
     <strong class="bold">
      
       Mass
      
     </strong>
     
      <strong class="bold">
       
        Entity
       
      </strong>
     
     
      
       section.
      
     
    </li>
    <li>
     
      Expand the
     
     <strong class="bold">
      
       Processor
      
     </strong>
     
      <strong class="bold">
       
        CDOs
       
      </strong>
     
     
      
       section.
      
     
    </li>
    <li>
     
      Search
     
     <a id="_idIndexMarker726">
     </a>
     
      through the array of processors for
     
     <strong class="bold">
      
       MassLODCollectorProcessor
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       MassRepresentationProcessor
      
     </strong>
     
      , and
     
     <strong class="bold">
      
       MassVisualizationLODProcessor
      
     </strong>
     
      .
     
     
      Expand the processors and check the
     
     <strong class="bold">
      
       Auto Register with Processing Phases
      
     </strong>
     
      flag for each
     
     
      
       of them.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.15 – Auto Register with Processor Phases settings" src="img/Figure_13.15_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.15 – Auto Register with Processor Phases settings
    
   </p>
   <p>
    
     With these
    
    <a id="_idIndexMarker727">
    </a>
    
     settings enabled, we can go on and create a
    
    
     
      testing gym.
     
    
   </p>
   <h2 id="_idParaDest-266">
    <a id="_idTextAnchor268">
    </a>
    
     Creating the gym
    
   </h2>
   <p>
    
     Since we will be
    
    <a id="_idIndexMarker728">
    </a>
    
     working with a lot of actors, I think it would be fun to take our beloved dummy puppets outside for some fresh air!
    
    
     That’s why, instead of using the usual enclosed gym, we will be setting up an open-air environment.
    
    
     Let’s start by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new level by using the
     
     <strong class="bold">
      
       Open
      
     </strong>
     
      <strong class="bold">
       
        World
       
      </strong>
     
     
      
       template.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       MassSpawner
      
     </strong>
     
      actor in the level and
     
     
      
       select it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Settings
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Count
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        50
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Entity Types
      
     </strong>
     
      array, add a new item and
     
     
      
       expand it.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Entity Config
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        ME_AudienceConfig
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a new item in the
     
     <strong class="bold">
      
       Spawn Data Generators
      
     </strong>
     
      array and
     
     
      
       expand it.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Generator Instance
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       EQS SpawnPoints Generator
      
     </strong>
     
      and expand its
     
     
      <strong class="bold">
       
        Query
       
      </strong>
     
     
      
       section.
      
     
    </li>
    <li>
     
      Expand the
     
     <strong class="bold">
      
       EQSRequest
      
     </strong>
     
      section and set the
     
     <strong class="bold">
      
       Query Template
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        EQS_SpawnEntitiesOnGrid
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 13.16 – Mass Spawner Details panel" src="img/Figure_13.16_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.16 – Mass Spawner Details panel
    
   </p>
   <p>
    
     Simulate the
    
    <a id="_idIndexMarker729">
    </a>
    
     level and you should get...
    
    
     
      something weird!
     
    
   </p>
   <div><div><img alt="Figure 13.17 – Wrong position" src="img/Figure_13.17_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.17 – Wrong position
    
   </p>
   <p>
    
     It seems all the characters are positioned halfway under the floor.
    
    
     This occurs because the
    
    <strong class="bold">
     
      Capsule
     
    </strong>
    
     component of a character is computed to be centered around the local coordinates of
    
    <strong class="source-inline">
     
      (0.0, 0.0, 0.0)
     
    </strong>
    
     .
    
    
     Fixing this issue is trivial and you’ll need to adjust a single property of the
    
    
     
      environment query.
     
    
   </p>
   <p>
    
     Let’s start by duplicating
    
    <strong class="bold">
     
      EQS_SpawnEntitiesOnGrid
     
    </strong>
    
     and calling it
    
    <strong class="source-inline">
     
      EQS_SpawnEntitiesOnGrid_ZOffset
     
    </strong>
    
     .
    
    
     Then, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the newly created asset and select the
     
     
      <strong class="bold">
       
        SimpleGrid
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, expand the
     
     <strong class="bold">
      
       Projection Data
      
     </strong>
     
      section and set
     
     <strong class="bold">
      
       Post Projection Vertical Offset
      
     </strong>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        120.0
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In your level, select the
     
     <strong class="bold">
      
       MassSpawner
      
     </strong>
     
      actor and change
     
     <strong class="bold">
      
       Query Template
      
     </strong>
     
      
       to
      
     
     
      <strong class="bold">
       
        EQS_SpawnEntitiesOnGrid_ZOffset
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     If you test the level
    
    <a id="_idIndexMarker730">
    </a>
    
     right now, your characters should be correctly positioned, as shown in
    
    
     <em class="italic">
      
       Figure 13
      
     </em>
    
    
     <em class="italic">
      
       .18
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 13.18 – Right position" src="img/Figure_13.18_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.18 – Right position
    
   </p>
   <p>
    
     Additionally, you should notice that the characters near the camera will be animated, while the ones that are at a distance will be stuck in a cheering position, as shown in
    
    
     <em class="italic">
      
       Figure 13
      
     </em>
    
    
     <em class="italic">
      
       .19
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 13.19 – Non-animated characters" src="img/Figure_13.19_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 13.19 – Non-animated characters
    
   </p>
   <p>
    
     This is happening because of the configuration setting we defined in the
    
    <strong class="bold">
     
      Mass Stationary Distance Visualization
     
    </strong>
    
     trait.
    
    
     I highly encourage you to open the
    
    <strong class="bold">
     
      ME_AudienceConfig
     
    </strong>
    
     asset back up and tweak the
    
    <strong class="bold">
     
      LODDistance
     
    </strong>
    
     values –
    
    <strong class="bold">
     
      High
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Medium
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Low
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      Off
     
    </strong>
    
     – to see how your
    
    
     
      entities behave.
     
    
   </p>
   <p>
    
     In this
    
    <a id="_idIndexMarker731">
    </a>
    
     section, I showed you some more advanced traits that compose the Mass framework.
    
    
     We created a new configuration data asset whose task is to manage the LOD of the spawned entities.
    
    
     Then we created a dedicated Mass Spawner that creates high numbers of actors in the level leveraging an
    
    
     
      environment query.
     
    
   </p>
   <h1 id="_idParaDest-267">
    <a id="_idTextAnchor269">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we introduced you to the experimental yet highly powerful Mass framework.
    
    
     Starting from the basics, we presented the plugins that make up the whole system.
    
    
     After that, we created a couple of working examples that take advantage of Mass: a simple debug scenario for checking Mass Spawner and a more complex one to get a strong grip on how traits can be combined to handle high numbers
    
    
     
      of entities.
     
    
   </p>
   <p>
    
     Using this framework is particularly beneficial in scenarios that require the simulation of crowds, physics interactions, and dynamic entity management.
    
    
     So, if your game needs these types of features, you will highly benefit from
    
    
     
      using Mass.
     
    
   </p>
   <p>
    
     In the next – and last – chapter, we will show you another feature that will provide a way to handle and manage various activities and interactions for both AI characters and players.
    
    
     Get ready for an intriguing exploration as things are about to get even
    
    
     
      more interesting!
     
    
   </p>
  </div>
 </body></html>