- en: '*Chapter 10*: Procedural Content Generation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：程序内容生成'
- en: Game AI is not only used to tell NPCs where to go or what to do. We can also
    use game AI to create parts of our games, to generate assets or music, to adapt
    the game story to the player's actions as a movie director, and even to generate
    narrative arcs and character backstories entirely. In the general AI world, this
    is the topic of **Computational Creativity**, a branch of AI concerned with the
    design of algorithms to enhance human creativity or completely automate tasks
    requiring human-level creativity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏人工智能不仅用于告诉NPC去哪里或做什么。我们还可以使用游戏AI来创建我们游戏的部分，生成资产或音乐，像电影导演一样调整游戏故事以适应玩家的行动，甚至完全生成叙事弧和角色背景故事。在通用人工智能领域，这是**计算创造力**的主题，它是关注设计算法以增强人类创造力或完全自动化需要人类水平创造力的任务的AI的一个分支。
- en: The scope of computational creativity is broad and cutting edge. It started
    in 1952 with Alan Turing writing the first algorithm capable of generating love
    letters. Today, it continues with powerful machine-learning-powered algorithms
    attempting to write poetry, compose symphonies, or produce astounding visual art
    pieces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机创造力的范围广泛且处于前沿。它始于1952年，当时艾伦·图灵编写了第一个能够生成情书的算法。今天，它继续发展，强大的机器学习算法试图写诗、创作交响乐或制作惊人的视觉艺术作品。
- en: Luckily for us, in games, we are interested in a more limited subset of this
    discipline. We are not interested in producing algorithms with human-level creativity
    (with all the philosophical questions attached to this endeavor). Instead, we
    only want to write algorithms that can automatically expand the contents of our
    game, be it by generating thousands of random dungeons, hundreds of new weapons,
    models of alien flora and animals, or anything else. This is called **Procedural
    Content Generation** (**PCG**), and it is a prominent protagonist of videogame
    automation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于游戏来说，我们感兴趣的只是这个学科的一个更小的子集。我们并不感兴趣于产生具有人类水平创造力的算法（与此努力相关的所有哲学问题）。相反，我们只想编写能够自动扩展我们游戏内容的算法，无论是通过生成成千上万的随机地下城、数百种新武器、外星植物和动物的模型，还是其他任何内容。这被称为**程序内容生成**（**PCG**），它是视频游戏自动化的一个主要角色。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the basic concept of PCG in video games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解视频游戏中PCG的基本概念
- en: Dipping our toes into PCG by implementing a random generator for the names of
    Goblin NPCs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现Goblin NPC名称的随机生成器来尝试接触PCG
- en: Implementing a simple cave/dungeon generator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单的洞穴/地下城生成器
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 10` folder in the book''s repository:
    [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter10).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要Unity3D 2022。你可以在本书的仓库中的`第10章`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter10)。
- en: Understanding Procedural Content Generation in games
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解游戏中的程序内容生成
- en: As discussed in the introduction, we are refering to all the algorithms that
    can generate game content at runtime with PCG algorithms. A PCG algorithm may
    create the level design, weapons, graphical assets, musical themes, enemies, NPCs,
    characters' backstories, and whatever else you set your mind on. If you think
    about any element in a game, there is a chance that there is at least one game
    that attempted to generate it procedurally. But why should you?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，我们指的是所有可以使用PCG算法在运行时生成游戏内容的算法。一个PCG算法可以创建关卡设计、武器、图形资产、音乐主题、敌人、NPC、角色的背景故事，以及你所能想到的任何其他内容。如果你思考任何游戏中的元素，都有可能至少有一个游戏尝试过以程序化的方式生成它。但为什么你应该这样做呢？
- en: 'Nowadays, PCG has become a synonym of *random* for the general public. Many
    games advertise having *procedurally generated levels* as a way of saying that
    they offer thousands of different levels that change at every playthrough. While
    PCG *may* indicate some process of causality, it is worth noting that that''s
    just part of the PCG landscape (even if, probably, the most marketable). More
    properly, PCG is the opposite of randomness: it is an algorithm that very deterministically
    starts from a *seed* and produces some content (but, of course, if we use a random
    seed, we obtain random outputs).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于公众来说，PCG（过程式内容生成）已经成为了*随机*的同义词。许多游戏通过宣传拥有*过程式生成的关卡*来表明它们提供了数千种不同的关卡，每次游玩都会发生变化。虽然PCG*可能*表示某种因果关系的过程，但值得注意的是，这仅仅是PCG景观的一部分（即使，可能，最具市场价值的）。更确切地说，PCG是随机性的对立面：它是一种非常确定性地从一个*种子*开始并产生一些内容的算法（但，当然，如果我们使用一个随机的种子，我们就会得到随机的输出）。
- en: 'There are two principal use cases for PCG:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PCG有两个主要的使用场景：
- en: 'The first is to use PCG to generate *persistent content that is impossible
    to pre-generate during development*. If the content is too big to be stored in
    a file or manual generation requires too much effort, we may have this necessity.
    For instance, the original space simulation game *Elite* (1985) used PCG to store
    8 galaxies with a 256-star system each (in addition to the game code) in just
    32 KB. With the increase in available disk space, this use case is no longer the
    biggest. However, it is still possible to find uses. The new version of Elite,
    called *Elite: Dangerous*, released in 2014, used the same approach to represent
    a real-scale copy of the Milky Way with the astounding number of 400 billion fully
    explorable star systems. Note that there is no randomness involved: the galaxy
    is persistent, and all the players share it in the game. It would be simply impossible
    to store the individual data for each star system on disk.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个场景是使用PCG来生成*在开发期间无法预先生成的持久内容*。如果内容太大无法存储在文件中，或者手动生成需要太多的努力，我们可能会有这种需求。例如，原始的太空模拟游戏*精英*（1985年）使用PCG在仅32
    KB的空间中存储了8个包含256颗星星的星系（除了游戏代码）。随着可用磁盘空间的增加，这种用法不再是最大的。然而，仍然可能找到用途。2014年发布的精英新版本，称为*精英：危险*，使用了相同的方法来表示一个真实规模的银河系副本，拥有令人惊叹的4000亿个完全可探索的星系。请注意，这里没有随机性：星系是持久的，所有玩家在游戏中共享它。在磁盘上存储每个星系的单独数据将是不可能的。
- en: More Info
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'You can find an inspiring and exciting analysis of the generative algorithm
    of the original Elite game at this URL: [https://www.gamedeveloper.com/design/algorithms-for-an-infinite-universe](https://www.gamedeveloper.com/design/algorithms-for-an-infinite-universe).'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在以下URL找到对原始精英游戏生成算法的启发性和令人兴奋的分析：[https://www.gamedeveloper.com/design/algorithms-for-an-infinite-universe](https://www.gamedeveloper.com/design/algorithms-for-an-infinite-universe)。
- en: 'The second is the most common use case: *add variety and replayability to a
    game by casually generating content at every playthrough*. Rogue-like games popularized
    this PCG use, but the most successful videogame using PCG to forge a different
    random world at every new run is, without doubt, Minecraft. With PCG, you do not
    need to craft every level manually or to design hundreds of different levels:
    you just need to specify the *rules* and let the software automatically generate
    a wide variety of levels or weapons.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是最常见的使用场景：*通过在每次游玩时随意生成内容，为游戏增加多样性和可玩性*。类似Rogue的游戏普及了这种PCG用法，但无疑，使用PCG在每次新运行时创建不同随机世界的最成功的电子游戏是Minecraft。有了PCG，你不需要手动制作每个关卡，也不需要设计数百个不同的关卡：你只需要指定*规则*，然后让软件自动生成各种关卡或武器。
- en: Now that we understand *why*, let's explore some different types of PCG algorithms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了*为什么*，让我们探索一些不同的PCG算法类型。
- en: Kinds of Procedural Content Generation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程式内容生成的种类
- en: 'During the long history of game development, PCG has been used for a wide variety
    of tasks. As a result, we can identify six applications of PCG:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发漫长的历史中，PCG被用于各种各样的任务。因此，我们可以确定PCG的六个应用：
- en: '**Runtime Content Generation**: This is the type of PCG we instinctively think
    about when we hear PCG. It includes the generation at runtime of the game contents.
    The creation of random worlds in *Minecraft* or random maps and weapons in *Diablo*
    are typical examples of this category.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时内容生成**：这是我们听到PCG时本能想到的类型。它包括在运行时生成游戏内容。在*Minecraft*中创建随机世界或在*Diablo*中创建随机地图和武器的例子是这一类别的典型示例。'
- en: '**Offline Content Generation**: This is the type of PCG we use during development.
    Even if we do not plan to give the players the ability to explore a randomly generated
    world, PCG is still useful for designers and developers. For instance, if we create
    a forest, we can use PCG to create 3D models of trees with different shapes (**SpeedTree**
    is a standard tool used for this purpose). We can also use PCG to kickstart the
    manual design of levels. Suppose we want to design an island. We may start by
    generating a simple random PCG island, then choose the one that most inspires
    us, and finally apply manual editing and modeling to it to create the final island
    we will ship in the final game. There are many other applications of PCG for design
    tools, but they go way out of the scope of this chapter.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离线内容生成**：这是我们开发过程中使用的PCG类型。即使我们并不打算给玩家提供探索随机生成世界的功能，PCG对于设计师和开发者来说仍然很有用。例如，如果我们创建了一片森林，我们可以使用PCG来创建不同形状的3D树木模型（**SpeedTree**是用于此目的的标准工具）。我们还可以使用PCG来启动级别的手动设计。假设我们想要设计一个岛屿。我们可能从生成一个简单的随机PCG岛屿开始，然后选择最让我们有灵感的那个，最后对其进行手动编辑和建模，以创建最终将在游戏中发布的岛屿。PCG在设计工具中的其他应用很多，但这些都超出了本章的范围。'
- en: '**Player-Mediated Content Generation**: These types of PCG algorithms use the
    players'' input as a source of *randomness*.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家介导的内容生成**：这类PCG算法将玩家的输入作为随机性的来源。'
- en: '**Dynamic Systems**: This kind of PCG generates NPCs'' behavior and a narrative
    background by simulating dynamic systems. A notable example is the A-Life system
    of the game called *S.T.A.L.K.E.R.*. In the game, the A-Life system simulates
    the life cycle of thousands of inhabitants of the game world. Consequently, the
    system provides infinite non-scripted characters to interact with and unlimited
    side-quests.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态系统**：这种类型的PCG通过模拟动态系统来生成NPC的行为和叙事背景。一个显著的例子是游戏 *S.T.A.L.K.E.R.* 中的A-Life系统。在游戏中，A-Life系统模拟了游戏世界中数千名居民的生命周期。因此，该系统提供了无限的非脚本化角色供玩家互动，以及无限的支线任务。'
- en: But that is enough theory for now. Let's start coding.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在就足够理论了。让我们开始编码。
- en: Implementing a simple goblin name generator
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个简单的哥布林名字生成器
- en: In the previous section, we explained that the primary purpose of PCG is to
    provide variety while removing from the developer the burden of scripting such
    variety by hand. So, imagine that we are developing an old-school RPG, and we
    want the players to be able to interact with the NPC characters of a goblin encampment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解释了PCG的主要目的是在提供多样性的同时，从开发者手中移除手动编写这种多样性的负担。所以，想象一下我们正在开发一款老式RPG游戏，我们希望玩家能够与哥布林营地中的NPC角色互动。
- en: In the encampment, there are hundreds of goblins, and we really want to avoid
    coming up with the name and the occupation of every one of them. Not only because
    it's boring and time-consuming, but if we're going to have random encounters with
    goblins in the game world, we need to have the ability to create new goblins on
    the fly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在营地中，有成百上千的哥布林，我们真的不想为每一个哥布林想出一个名字和职业。这不仅因为无聊且耗时，而且如果我们打算在游戏世界中与哥布林进行随机遭遇，我们需要有能力即时创建新的哥布林。
- en: 'Fortunately, we have a more fun (for us) solution: to write an algorithm generating
    a huge number of random goblin characters.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一个更有趣（对我们来说）的解决方案：编写一个生成大量随机哥布林角色的算法。
- en: Generating goblin names
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成哥布林名字
- en: In order to generate something, we need to find some kind of *generative rule*.
    To find such a rule, the best thing is to look at different examples of what we
    want to generate and try to figure out if some pattern connects them. For example,
    for goblin names, we can look for insight in a bunch of goblin names from World
    of Warcraft.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成某些东西，我们需要找到某种类型的 *生成规则*。为了找到这样的规则，最好的办法是查看我们想要生成的不同示例，并试图找出是否有一些模式将它们联系起来。例如，对于哥布林名字，我们可以从《魔兽世界》中的一大堆哥布林名字中寻找灵感。
- en: 'Let''s look at some of them: *Grizzle Gearslip*, *Hobart Grapplehammer*, and
    *Helix Blackfuse*. Continuing with this list, we may identify a common pattern:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其中的一些：*Grizzle Gearslip*、*Hobart Grapplehammer*、*Helix Blackfuse*。继续这个列表，我们可能会发现一个共同的模式：
- en: The names are composed of two or three syllables.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字由两个或三个音节组成。
- en: The syllables have similar sounds, such as *Bax*, *Griz*, *Hel*, *Hob*, and
    so on.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些音节有相似的声音，例如 *Bax*、*Griz*、*Hel*、*Hob* 等等。
- en: The surname is always composed of the name of an object or an adjective (gear,
    grapple, black, bolt) followed by a verb.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓氏总是由一个物体或形容词（齿轮、钩爪、黑色、螺栓）加上一个动词组成。
- en: The theme of the surnames is usually related to mechanical engineering.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓氏的主题通常与机械工程相关。
- en: 'That''s enough to get started. We create a new scene, and we create a new script
    called `GoblinNameGenerator`, and we paste inside the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够开始了。我们创建一个新的场景，并创建一个名为 `GoblinNameGenerator` 的新脚本，并将以下代码粘贴进去：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code straightforwardly converts the rules of goblin names into a procedural
    algorithm. The `NameDatabase1`, `NameDatabase2`, and `NameDatabase3` arrays contain
    the first, middle, and last syllables of the first name. Similarly, `SurnameDatabase1`
    and `SurnameDatabase2` have the two parts of a goblin's surname. To generate the
    name, we chose a random piece from each list, and we put everything together.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码直接将哥布林名字的规则转换为程序算法。`NameDatabase1`、`NameDatabase2` 和 `NameDatabase3` 数组包含名字的第一个、中间和最后一个音节。同样，`SurnameDatabase1`
    和 `SurnameDatabase2` 包含哥布林姓氏的两个部分。为了生成名字，我们从每个列表中随机选择一个片段，并将所有内容组合在一起。
- en: Completing the goblin description
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成哥布林描述
- en: Now that we have a name, we need only other small details. So, let's create
    an empty object and attach to it a new `MonoBehavior` instance named `GoblinWriter`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了名字，我们只需要其他一些小细节。所以，让我们创建一个空对象，并将其一个名为 `GoblinWriter` 的新 `MonoBehavior`
    实例附加到它上。
- en: 'This new script contains the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新脚本包含以下代码：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The script has three exposed properties. The first, `textMesh`, is a reference
    to the TextMesh element that will show the text on screen (you can create one
    by going to `goblinJobs`, stores a list of jobs we want to give to the goblins.
    As you can see in *Figure 10.1*, I added four jobs: `goblinMaxAge`, represents
    the maximum age for my goblins.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本有三个公开属性。第一个，`textMesh`，是对将在屏幕上显示文本的 TextMesh 元素的引用（你可以通过访问 `goblinJobs` 创建一个，它存储了我们想要分配给哥布林的作业列表。正如你在
    *图 10.1* 中所看到的，我添加了四个作业：`goblinMaxAge`，代表我的哥布林的最高年龄。
- en: '![Figure 10.1 – The Goblin Writer script in the Inspector'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – 检查器中的哥布林作家脚本]'
- en: '](img/B17984_10_1.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_10_1.jpg](img/B17984_10_1.jpg)'
- en: Figure 10.1 – The Goblin Writer script in the Inspector
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 检查器中的哥布林作家脚本
- en: Whenever we call `UpdateString` (that is, at the start of the game and every
    time we press *Spacebar*), we simply extract a value from the set of possible
    values for the age, the job, and the name, and construct a string. Once we have
    everything set up, we can run the demo, and we should see a new goblin description
    every time we press *Spacebar* (*Figure 10.2*).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调用 `UpdateString`（即在游戏开始时以及每次我们按下 *空格键* 时），我们只需从年龄、职业和名字的可能值集中提取一个值，并构建一个字符串。一旦我们设置好了一切，我们就可以运行演示，每次我们按下
    *空格键* 时（*图 10.2*），我们都应该看到一个新哥布林的描述。
- en: '![Figure 10.2 – One of the many random goblins we can generate'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 我们可以生成的许多随机哥布林之一]'
- en: '](img/B17984_10_2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_10_2.jpg](img/B17984_10_2.jpg)'
- en: Figure 10.2 – One of the many random goblins we can generate
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 我们可以生成的许多随机哥布林之一
- en: The example is simple, but it is an effective way to add variety to any game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，但它是为任何游戏增加多样性的有效方法。
- en: Info
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The Dungeon Master manual of the fifth edition of Dungeon & Dragons contains
    several examples of this kind of *composition and randomness-driven* procedural
    generation. Inside it, you can find a lot of tables to generate treasures, weapons,
    side-quests, characters, and so on. Sure, it is designed to be used with pen and
    dice, but nothing stops you from translating paper algorithms into computer algorithms!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 《地下城与龙》第五版的地下城主手册包含了许多这类 *组合和随机驱动的程序生成* 的例子。在里面，你可以找到许多用于生成宝藏、武器、支线任务、角色等等的表格。当然，它是为了与笔和骰子一起使用而设计的，但没有什么阻止你将纸面算法转换为计算机算法！
- en: 'Now that we have a taste for procedural generation, let''s step up the game.
    Let''s introduce another handy tool for the PCG developer: Perlin noise.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对程序生成有了品味，让我们提高游戏水平。让我们介绍另一个对 PCG 开发者很有用的工具：Perlin 噪声。
- en: Learning how to use Perlin noise
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用 Perlin 噪声
- en: '**Perlin noise** is an algorithm to define digital noise developed by Ken Perlin
    in 1983\. It quickly became the de facto algorithm to generate natural-looking
    patterns in a considerable number of procedural content generation algorithms.
    For example, Perlin noise is used to create 3D landscapes, 2D textures, procedural
    animations, and much more.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Perlin 噪声** 是由 Ken Perlin 在 1983 年开发的一种用于定义数字噪声的算法。它很快成为在大量程序内容生成算法中生成自然外观图案的事实上的算法。例如，Perlin
    噪声用于创建 3D 地形、2D 纹理、程序动画等等。'
- en: '![Figure 10.3 – The difference between Perlin noise (left) and white noise
    (right)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – Perlin 噪声（左）与白噪声（右）之间的区别]'
- en: '](img/B17984_10_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_10_3.jpg](img/B17984_10_3.jpg)'
- en: Figure 10.3 – The difference between Perlin noise (left) and white noise (right)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Perlin 噪声（左）与白噪声（右）之间的区别
- en: But what makes Perlin noise different from other noises? The short answer is
    that it looks more *natural*. This answer, however, just changes the question
    into *what does it mean to be more natural?* Let's imagine standard non-Perlin
    noise, for instance, a sequence of random numbers between 0 and 1\. The sequence
    may be something like 0, 0.9, 0.2, 0.3, 0.95, and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么让 Perlin 噪声与其他噪声不同？简短的答案是它看起来更 *自然*。然而，这个答案只是将问题转化为 *更自然是什么意思？* 让我们想象标准的非
    Perlin 噪声，例如，0 到 1 之间的随机数字序列。序列可能如下所示：0、0.9、0.2、0.3、0.95 等。
- en: As you can see, the numbers can jump up and down without any criteria. If these
    numbers represent the position of a character in the game, the character will
    appear to teleport itself left and right frantically. That is not how things move
    in real life.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些数字可以毫无标准地上下跳跃。如果这些数字代表游戏中的角色位置，角色看起来会疯狂地左右传送。这不是现实生活中物体的移动方式。
- en: 'Perlin noise is different because, in the sequence of numbers, two consecutive
    numbers will always be close together. For example, after 0.9 we may have 0.91,
    0.92, or 0.88 but never 0.1\. The effect is like a buoy floating on the sea: it
    can move unpredictably left and right, up and down, but with a certain smoothness
    – a certain naturalness.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Perlin 噪声不同之处在于，在数字序列中，两个连续的数字总是彼此靠近。例如，在 0.9 之后，我们可能会有 0.91、0.92 或 0.88，但绝不会是
    0.1。这种效果就像一个浮标在海面上漂浮：它可以不可预测地左右移动，上下移动，但具有一定的平滑性——一定的自然性。
- en: This looks perfect. However, how can we use Perlin noise in Unity? Luckily,
    Unity offers the Perlin noise algorithm as a built-in tool.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很完美。然而，我们如何在 Unity 中使用 Perlin 噪声？幸运的是，Unity 将 Perlin 噪声算法作为内置工具提供。
- en: Built-in Unity Perlin noise
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置的 Unity Perlin 噪声
- en: 'Unity offers a simple function to access Perlin noise:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一个简单的函数来访问 Perlin 噪声：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unity implements Perlin noise as an infinite 2D plane that you can randomly
    sample in code using the `Mathf.PerlinNoise` function. You can simply sample a
    random coordinate to get a *random* value on the Perlin noise plane.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 将 Perlin 噪声实现为一个无限的 2D 平面，您可以使用 `Mathf.PerlinNoise` 函数在代码中随机采样。您可以简单地采样一个随机坐标，以获取
    Perlin 噪声平面上 *随机* 的值。
- en: Info
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note that Unity only offers you 2D Perlin noise. However, Perlin noise can be
    easily extended to 3D (for instance, to create volumetric smoke) or even four
    and more dimensions. If you need 3D Perlin noise, you need to develop the algorithm
    yourself or look for the many open source implementations you can find online
    (for instance, [https://gist.github.com/tntmeijs/6a3b4587ff7d38a6fa63e13f9d0ac46d](https://gist.github.com/tntmeijs/6a3b4587ff7d38a6fa63e13f9d0ac46d)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Unity 只提供了 2D Perlin 噪声。然而，Perlin 噪声可以轻松扩展到 3D（例如，用于创建体积烟雾）或甚至更多维度。如果您需要
    3D Perlin 噪声，您需要自己开发算法或在网上寻找许多开源实现（例如，[https://gist.github.com/tntmeijs/6a3b4587ff7d38a6fa63e13f9d0ac46d](https://gist.github.com/tntmeijs/6a3b4587ff7d38a6fa63e13f9d0ac46d))。
- en: 'Imagine you want to create a random 2D texture using Unity''s built-in Perlin
    noise. You can do that by starting at an arbitrary point (`xStart` and `yStart`)
    and then copying every surrounding point''s value into the texture as you can
    see in the following example (the full `PerlinTexture.cs` file is included in
    the GitHub repository):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想使用 Unity 内置的 Perlin 噪声创建一个随机的 2D 纹理。您可以通过从任意点（`xStart` 和 `yStart`）开始，然后将周围每个点的值复制到纹理中来实现这一点，如下面的示例所示（完整的
    `PerlinTexture.cs` 文件包含在 GitHub 仓库中）：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, we can also use 2D Perlin noise to generate 1D Perlin noise. In that
    case, we fix one coordinate (`x` or `y`) and we move the other in a straight line.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以使用 2D Perlin 噪声来生成 1D Perlin 噪声。在这种情况下，我们固定一个坐标（`x` 或 `y`），然后让另一个坐标沿直线移动。
- en: 'Suppose we want to animate a bobbing sphere, floating gently up and down like
    a balloon. We can do that by setting its *y* coordinate (canonically representing
    the up and down direction) to the value of the Perlin noise:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要动画化一个上下摆动的球体，像气球一样轻轻上下浮动。我们可以通过将其 *y* 坐标（经典地表示上下方向）设置为 Perlin 噪声的值来实现这一点：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you attach this small script to any object, you will see the object randomly
    moving up and down.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将这个小脚本附加到任何对象上，您将看到对象随机上下移动。
- en: That's just the tip of the iceberg of Perlin noise application, but I hope that
    it will get you started. However, it is time for us to continue our journey into
    PCG. In the next section, we will generate a random cave using a new technique
    called **Cellular Automata**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是Perlin噪声应用的冰山一角，但我希望它能帮助你入门。然而，是时候我们继续我们的PCG之旅了。在下一节中，我们将使用一种称为**细胞自动机**的新技术来生成一个随机洞穴。
- en: Generating random maps and caves
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机地图和洞穴
- en: Another widespread application of PCG is the generation of maps and dungeons.
    For example, in the *roguelike* genre (a type of game that takes its name from
    the 1980s game *Rogue*), players face a randomly generated dungeon every time
    they start a game. Likewise, in *Minecraft*, players begin the game by generating
    a random world to explore and in which they need to survive. The examples are
    numerous – too many to be listed here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PCG的另一个广泛应用是地图和地牢的生成。例如，在**roguelike**类型（一种从20世纪80年代的游戏*Rogue*中取名的游戏类型）中，玩家每次开始游戏时都会面对一个随机生成的地牢。同样，在*Minecraft*中，玩家通过生成一个随机世界来开始游戏，并在其中探索和生存。例子很多——多到无法在此列出。
- en: There are significant numbers of algorithms to create game worlds. Some use
    fractal noise to generate random heightmaps. Some others create dungeon-like structures
    by creating random rooms and connecting them with corridors. Others build maps
    by randomly arranging manually premade rooms into a myriad of different combinations
    like in a puzzle (if you have ever played the tabletop game *Carcassonne*, you
    know what I am talking about).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法可以创建游戏世界。一些使用分形噪声来生成随机的地形图。另一些通过创建随机房间并将它们通过走廊连接起来来创建类似地牢的结构。还有一些通过将预先制作好的房间随机排列成无数不同的组合来构建地图，就像拼图一样（如果你玩过20世纪80年代的桌面游戏*Carcassonne*，你就知道我在说什么了）。
- en: This demo will explore a simple technique well suited for the generation of
    caves or natural-looking scenes, called **Cellular Automata**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本演示将探索一种非常适合生成洞穴或自然外观场景的简单技术，称为**细胞自动机**。
- en: Cellular automata
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细胞自动机
- en: '**Cellular Automata** (**CA**) is not only a PCG algorithm. CA have been studied
    since 1950 as an abstract computational model. However, their popularity exploded
    only after the release of *Conway''s Game of Life* in the 70s.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**细胞自动机**（**CA**）不仅是一个PCG算法。自1950年以来，CA作为一种抽象的计算模型被研究。然而，它们的普及直到20世纪70年代康威的**生命游戏**发布后才爆发。'
- en: 'The basic idea of CA is to simulate the behavior of *cells* in a 2D grid. Each
    cell in the grid has two states: dead or alive. Each *cell* will die or live depending
    on rules that depend only on their neighbors.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 细胞自动机（CA）的基本思想是模拟二维网格中细胞的**行为**。网格中的每个细胞有两种状态：死亡或存活。每个细胞将根据仅取决于其邻居的规则死亡或存活。
- en: '![Figure 10.4 – A configuration of cells in the Game of Life'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 生命游戏中的细胞配置'
- en: '](img/B17984_10_4.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_10_4.jpg)'
- en: Figure 10.4 – A configuration of cells in the Game of Life
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 生命游戏中的细胞配置
- en: 'The behavior of a CA algorithm depends only on these evolution rules. So, we
    start from an initial configuration of alive and dead cells and then let the system
    evolve independently. In *Game of Life*, for example, we have four simple rules:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 细胞自动机算法的行为仅取决于这些进化规则。因此，我们从初始的存活和死亡细胞配置开始，然后让系统独立进化。例如，在**生命游戏**中，我们有四个简单的规则：
- en: Live cells with fewer than two live neighbors are underpopulated, and therefore
    they die.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有少于两个存活邻居的存活细胞人口不足，因此它们会死亡。
- en: Live cells with two or three live neighbors keep living in the next generation.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有两个或三个存活邻居的存活细胞将在下一代中继续存活。
- en: Live cells with more than three live neighbors are overpopulated, and therefore
    they die.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有超过三个存活邻居的存活细胞人口过多，因此它们会死亡。
- en: Dead cells with exactly three live neighbors become alive again due to *reproduction*.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有恰好三个存活邻居的死亡细胞会因**繁殖**而复活。
- en: It turns out that these four simple rules are powerful enough to make the algorithm
    itself Turing complete. This means that it is possible to write a configuration
    of live and dead cells that, after applying the above four rules, is able to do
    any computation like a normal computer, for instance, multiplying numbers or playing
    chess. If you are interested in this, Paul Rendell has a detailed description
    of the pattern on his web page ([http://rendell-attic.org/gol/tm.htm](http://rendell-attic.org/gol/tm.htm)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这四条简单的规则足以使算法本身成为图灵完备的。这意味着可以编写一个活细胞和死细胞的配置，在应用上述四条规则之后，能够像普通计算机一样进行任何计算，例如乘法或下棋。如果你对此感兴趣，保罗·伦德尔在他的网页上对这种模式有详细的描述（[http://rendell-attic.org/gol/tm.htm](http://rendell-attic.org/gol/tm.htm)）。
- en: But let's come back to our goal. Luckily for us, we need to do something much
    more simple than implementing a CPU with our CA. In PCG, CA are an excellent choice
    because they are easy to implement and generate maps that look like natural environments
    such as deserts, caves, island archipelagos, and so on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们回到我们的目标。幸运的是，我们不需要做比用我们的CA实现CPU更复杂的事情。在PCG中，CA是一个很好的选择，因为它们易于实现，并且生成的地图看起来像自然环境，如沙漠、洞穴、群岛等。
- en: Implementing a cave generator
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现洞穴生成器
- en: 'To implement our cave generator, we need two components:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的洞穴生成器，我们需要两个组件：
- en: A component that generates and stores the map abstractly (for example, as an
    array of integers)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个抽象地生成和存储地图的组件（例如，作为一个整数的数组）
- en: A component that will render the abstract map in a visible 3D object in the
    game
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将抽象地图渲染成游戏中的可见3D对象的组件
- en: 'So, let''s start by implementing the first component. We''ll call it `CaveGenerator`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先实现第一个组件。我们将称之为`CaveGenerator`：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The component exposes four attributes to the Inspector. The first two are simply
    the `weight` and `height` of the map expressed as *number of cells*. Then we have
    the `seed` of the random generator in case we want to create specific maps (this
    is especially useful for debugging purposes). In general, though, we want a random
    map every time we start the game; that''s why we have a `useRandomSeed` property:
    if it is `true`, we initialize a random seed. Finally, we have a private bidimensional
    array to store the `map` representation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件向检查器公开了四个属性。前两个属性简单地是地图的`weight`和`height`，以*单元格数量*表示。然后我们有随机生成器的`seed`，以防我们想要创建特定的地图（这在调试目的上特别有用）。然而，通常情况下，我们希望在每次开始游戏时都有一个随机的地图；这就是为什么我们有`useRandomSeed`属性：如果它是`true`，我们初始化一个随机种子。最后，我们有一个私有的二维数组来存储`map`表示。
- en: 'After the properties specification, we need to initialize the `Start` and `Update`
    callbacks. These functions will simply call the other functions that we will define
    next. In `Update`, we can also see the keys we use to control the demo: every
    time we press *Spacebar*, we run another step of the CA simulation; when we press
    the *N* key, we initialize a new map.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性指定之后，我们需要初始化`Start`和`Update`回调函数。这些函数将简单地调用我们接下来定义的其他函数。在`Update`中，我们还可以看到我们用来控制演示的键：每次我们按下*空格键*，我们就会运行CA模拟的另一个步骤；当我们按下*N*键时，我们初始化一个新的地图。
- en: When we press the *G* key, we run a different rule for the CA (more on this
    when we set up the CA rules).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下*G*键时，我们为CA运行不同的规则（我们将在设置CA规则时详细介绍这一点）。
- en: 'We''ll now implement the `InitializeRandomGrid` function. This function initializes
    the map with random dead and alive cells. However, there are two additional tips.
    First, the function creates a border of walls (alive cells) around the map. This
    is because maps are usually bounded, and we do not want the players to jump off
    the map. This border of walls will ensure that the final map will not have caves
    leading out of the map edges:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现`InitializeRandomGrid`函数。这个函数使用随机的死细胞和活细胞初始化地图。然而，还有两个额外的提示。首先，该函数在地图周围创建了一个墙的边界（活细胞）。这是因为地图通常是有限的，我们不希望玩家跳出地图。这个墙的边界将确保最终地图不会有通向地图边缘的洞穴：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second trick is to keep a vertical line of empty spaces (dead cells). That''s
    the purpose of the check on the `mapMiddle` variable. The motivation for this
    blank line is simple: it empirically gives better results by generating a main
    connected cave extending over the entire map. You can remove it to get multiple
    isolated smaller caves or find a different starting pattern that offers a better
    outcome according to your tastes and use cases. The `InitializeRandomGrid` function
    initializes something like the image in *Figure 10.5*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个技巧是保持一列空的空间（死细胞）。这就是检查`mapMiddle`变量的目的。留出这行空白的原因很简单：它通过生成贯穿整个地图的主连接洞穴，经验上给出了更好的结果。你可以移除它以获得多个孤立的小洞穴，或者找到一个不同的起始模式，根据你的口味和用例提供更好的结果。`InitializeRandomGrid`函数初始化类似于*图10.5*中的图像。
- en: '![Figure 10.5 – The initial state of the map'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 – 地图的初始状态'
- en: '](img/B17984_10_5.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_10_5.jpg](img/B17984_10_5.jpg)'
- en: Figure 10.5 – The initial state of the map
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 地图的初始状态
- en: 'Now, we''ll look at a small utility function that we use to count the walls
    around a specific map cell:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看一个小的实用函数，我们用它来计算特定地图单元格周围的墙壁数量：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first function is straightforward. It looks at the cells around the target
    coordinates and counts the number of walls. It also takes a `size` parameter indicating
    the *radius* around the target coordinate. If `size` is equal to `1`, we check
    the eight cells around the target coordinates (imagine a 3x3 square). If `size`
    is equal to `2`, we also check the neighbors' neighbors (imagine a 5x5 square).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数很简单。它查看目标坐标周围的单元格，并计算墙壁的数量。它还接受一个`size`参数，表示目标坐标周围的*半径*。如果`size`等于`1`，我们检查目标坐标周围的八个单元格（想象一个3x3的正方形）。如果`size`等于`2`，我们还会检查邻居的邻居（想象一个5x5的正方形）。
- en: 'The `isWall` function is used to check if a specific coordinate represents
    a wall. You may ask: why don''t we just check the value of `map` at `(c,r)`? Because
    we may enter coordinates outside the array (for instance, `(-1,-1)`). In that
    case, we assume that every cell outside the map is a wall (and it will remain
    a wall). This simplifies the logic for `GetSurroundingWallCount`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`isWall`函数用于检查特定坐标是否代表墙壁。你可能会问：我们为什么不直接检查`(c,r)`处的`map`值？因为我们可能进入数组外的坐标（例如，`(-1,-1)`）。在这种情况下，我们假设地图外的每个单元格都是墙壁（并且它将保持为墙壁）。这简化了`GetSurroundingWallCount`的逻辑。'
- en: 'Now it is time to get to the meat – the CA rules:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入重点 – CA规则：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the cave generator, we use two sets of rules. The first set (obtained when
    `clean` is equal to `true`) is described as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于洞穴生成器，我们使用两组规则。第一组（当`clean`等于`true`时获得）描述如下：
- en: If a cell is a wall, it remains a wall as long as it has more than three neighboring
    walls. Otherwise, it becomes an empty space.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个单元格是墙壁，只要它周围有超过三个墙壁，它就会保持为墙壁。否则，它变成空空间。
- en: If a cell is empty, it remains empty as long as it has fewer than five neighboring
    walls. Otherwise, it becomes a wall.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个单元格为空，只要它周围有少于五个墙壁，它就会保持为空。否则，它变成墙壁。
- en: The second set of rules is identical to the first, but it also checks the neighbors
    of radius `2`. If too many empty spaces surround an empty cell, then it becomes
    a wall. This optional behavior removes large empty spaces, promoting more narrow
    passages. However, this can also leave isolated 1x1 walls that look like noise
    (which is why this set of rules is enabled with the `clean` parameter equal to
    `false`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组规则与第一组相同，但它还检查半径为`2`的邻居。如果围绕一个空单元格的空空间太多，那么它就会变成墙壁。这种可选行为可以消除大空隙，促进更狭窄的通道。然而，这也可能留下像噪声一样的孤立1x1墙壁（这就是为什么这组规则使用`clean`参数等于`false`来启用）。
- en: By running these rules, we get maps such as the one in *Figure 10.6*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这些规则，我们得到如图10.6所示的地图。
- en: '![Figure 10.6 – A random cave generated by our algorithm'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 – 由我们的算法生成的随机洞穴'
- en: '](img/B17984_10_6.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_10_6.jpg](img/B17984_10_6.jpg)'
- en: Figure 10.6 – A random cave generated by our algorithm
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 由我们的算法生成的随机洞穴
- en: 'We now have a perfectly working algorithm but no way to show it in the game.
    For this, we have the `DrawCaveMesh` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个完全工作的算法，但没有方法在游戏中展示它。为此，我们有`DrawCaveMesh`函数：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function simply invokes a mesh generator. We will implement `MeshGenerator`
    in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地调用一个网格生成器。我们将在下一节实现`MeshGenerator`。
- en: Rendering the generated cave
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染生成的洞穴
- en: 'Given the abstract map representation (the bidimensional array stored in `map`),
    we need something that converts it into a mesh rendered on screen. We can do this
    in multiple ways. To allow flexibility, we start by defining an abstract component:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 给定抽象地图表示（存储在`map`中的二维数组），我们需要将其转换为屏幕上渲染的网格。我们可以通过多种方式实现。为了提供灵活性，我们首先定义一个抽象组件：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This simple abstract class tells Unity that every valid `MeshGenerator` should
    contain a `GenerateMesh` function. This function takes as input the array map
    and the size of each cell expressed in Unity units.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的抽象类告诉Unity，每个有效的`MeshGenerator`都应该包含一个`GenerateMesh`函数。这个函数接受数组地图和每个单元格的大小作为输入，大小以Unity单位表示。
- en: That's cool, but obviously not very useful right now. We still cannot render
    anything. Do not worry; we will now implement a simple mesh renderer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但显然现在并不太有用。我们仍然无法渲染任何东西。不要担心；我们现在将实现一个简单的网格渲染器。
- en: Basic mesh renderer
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本网格渲染器
- en: 'The idea of this renderer is to spawn a 1x1 cube for each wall cell. We''ll
    call this renderer `WallGenerator`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渲染器的想法是为每个墙壁单元生成一个1x1的立方体。我们将这个渲染器称为`WallGenerator`：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First of all, note that this class extends our abstract `MeshGenerator` class.
    Second, this component exposes a single parameter called `wallCube`. This parameter
    contains a reference to a wall prefab (basically a colored 3D cube).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，这个类扩展了我们的抽象`MeshGenerator`类。其次，这个组件公开了一个名为`wallCube`的单个参数。这个参数包含一个墙壁预制体的引用（基本上是一个彩色的3D立方体）。
- en: 'Then, we implement the `GenerateMesh` function. The implementation is once
    again straightforward:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现`GenerateMesh`函数。实现方法再次简单直接：
- en: We destroy all the existing walls (stored as children).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们销毁所有现有的墙壁（存储为子元素）。
- en: Then, we iterate over every cell in the abstract map and spawn a `wallCube`
    object in the proper location.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历抽象地图中的每个单元格，并在适当的位置生成一个`wallCube`对象。
- en: We shift the map by half the size (for visualization purposes).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将地图平移一半的大小（用于可视化目的）。
- en: There is a problem, though. Unity is not suitable for spawning thousands of
    GameObjects. So, if our map is 200x200, this function will potentially spawn 40,000
    GameObjects just for rendering the map. The result will be a pretty slow game
    (and we are not even spawning characters yet).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在问题。Unity不适合生成成千上万的GameObject。所以，如果我们的地图是200x200，这个函数将可能生成40,000个GameObject仅用于渲染地图。结果将是一个相当慢的游戏（我们甚至还没有生成角色）。
- en: 'Fortunately, there is a quick solution:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个快速解决方案：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `MergeCubes` function takes all the cubic children we just spawned and combines
    them in a single game object with a single mesh. We do that by leveraging the
    built-in `CombineMeshes` tool.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`MergeCubes`函数接受我们刚刚生成的所有立方体子元素，并将它们组合成一个具有单个网格的单个游戏对象。我们通过利用内置的`CombineMeshes`工具来实现这一点。'
- en: As you can see in the preceding code, we first get all the children (all the
    individual walls). Then, for each one of them, we create `CombineInstance`. The
    only tricky thing to remember is to store the coordinates of the mesh in world
    coordinates (Unity does that by calling `.transform.localToWorldMatrix`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中看到的，我们首先获取所有子元素（所有单独的墙壁）。然后，对于它们中的每一个，我们创建`CombineInstance`。唯一需要记住的棘手之处是存储网格的坐标为世界坐标（Unity通过调用`.transform.localToWorldMatrix`来实现这一点）。
- en: Once we have all the `CombineInstance` objects, we replace the map's mesh with
    the mesh obtained by combining all the walls.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有的`CombineInstance`对象，我们就用组合所有墙壁得到的网格替换地图的网格。
- en: Info
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Depending on the size of the map, the default mesh `IndexFormat` may be unable
    to contain all the vertices of the combined mesh. We can solve this by using 32-bit
    indexing with `transform.GetComponent<MeshFilter>().mesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据地图的大小，默认的`IndexFormat`可能无法容纳组合网格的所有顶点。我们可以通过使用32位索引来解决这个问题，即`transform.GetComponent<MeshFilter>().mesh.indexFormat
    = UnityEngine.Rendering.IndexFormat.UInt32;`。
- en: Finally, we destroy all the children.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们销毁所有子元素。
- en: Now we can set up the scene. The final outcome is shown in the following screenshot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置场景。最终结果在下面的屏幕截图中显示。
- en: '![Figure 10.7 – The CaveGen Hierarchy'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 – CaveGen 层级结构'
- en: '](img/B17984_10_7.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_10_7.jpg)'
- en: Figure 10.7 – The CaveGen Hierarchy
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – CaveGen 层级结构
- en: First, let's create a big plane to use for the ground level, and then an object
    called `CaveGen`. The `CaveGen` object contains a `MeshRenderer` and a `MeshFilter`
    component (but no mesh).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个大的平面用于地面层，然后创建一个名为`CaveGen`的对象。`CaveGen`对象包含一个`MeshRenderer`和一个`MeshFilter`组件（但没有网格）。
- en: Now attach the `CaveGenerator` and `WallRenderer` components to this object
    and configure them as in the following screenshot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`CaveGenerator`和`WallRenderer`组件附加到这个对象上，并按照以下截图进行配置。
- en: '![Figure 10.8 – The CaveGenerator and WallGenerator components'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8 – CaveGenerator 和 WallGenerator 组件'
- en: '](img/B17984_10_8.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_10_8.jpg]'
- en: Figure 10.8 – The CaveGenerator and WallGenerator components
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – CaveGenerator 和 WallGenerator 组件
- en: The final touch is adding a **Wall** prefab to **Wall Cube**. Then, finally,
    we can click **Play**, and we should see something similar to *Figure 10.9*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将**Wall**预制体添加到**Wall Cube**中。然后，最终我们可以点击**Play**，应该会看到类似于*图 10.9*的类似效果。
- en: '![Figure 10.9 – The initial random configuration'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – 初始随机配置'
- en: '](img/B17984_10_9.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_10_9.jpg]'
- en: Figure 10.9 – The initial random configuration
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 初始随机配置
- en: We can now continue the map generation by pressing *Spacebar* (or *G* if we
    want to apply the second set of CA rules). After some time, you may note that
    the map stabilizes into a map like the one in *Figure 10.10*. At that point, your
    map is ready (but you can start over by pressing *N*).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过按*Spacebar*（或如果我们想应用第二套CA规则，则按*G*）继续地图生成。经过一段时间，您可能会注意到地图稳定到一个类似于*图
    10.10*的地图。到那时，您的地图就准备好了（但您可以通过按*N*重新开始）。
- en: '![Figure 10.10 – The completely evolved map'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.10 – 完全演化的地图'
- en: '](img/B17984_10_10.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_10_10.jpg]'
- en: Figure 10.10 – The completely evolved map
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 完全演化的地图
- en: Not bad for a PCG algorithm that we wrote in less than 130 lines of code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们用不到130行代码编写的PCG算法来说，这已经很不错了。
- en: Advanced mesh renderer
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级网格渲染器
- en: '`WallGenerator` is quick and effective; however, it is not optimal. The final
    mesh contains a lot of redundant vertices, and we still have this pixelated look.
    There are many other different algorithms that we can use to generate a mesh.
    A standard solution is to use the **Marching Squares** algorithm (also called
    **Marching Cubes** if applied to 3D).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`WallGenerator`快速且有效；然而，它并不最优。最终的网格包含大量冗余顶点，我们仍然有这种像素化的外观。我们可以使用许多其他不同的算法来生成网格。一个标准的解决方案是使用**Marching
    Squares**算法（如果应用于3D，也称为**Marching Cubes**）。'
- en: This algorithm is a bit complex, and a detailed discussion would go way beyond
    the scope of this book. However, in the code of this demo, I've included a `MarchingCubesGenerator`
    component for you to use and explore. The algorithm is taken from an official
    Unity tutorial ([https://www.youtube.com/watch?v=yOgIncKp0BE](https://www.youtube.com/watch?v=yOgIncKp0BE))
    and I have adapted it for this demo.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法有点复杂，详细的讨论会远远超出本书的范围。然而，在这个演示的代码中，我包含了一个`MarchingCubesGenerator`组件供您使用和探索。该算法来自官方Unity教程([https://www.youtube.com/watch?v=yOgIncKp0BE](https://www.youtube.com/watch?v=yOgIncKp0BE))，我已经为这个演示进行了适配。
- en: To use it, you just need to replace the `WallGenerator` component with `MarchingCubesGenerator`.
    If you now run the game and run the CA for a couple of generations, you should
    see something like *Figure 10.11*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，您只需将`WallGenerator`组件替换为`MarchingCubesGenerator`。如果您现在运行游戏并运行几代CA，您应该会看到类似于*图
    10.11*的效果。
- en: '![Figure 10.11 – The map rendered using MarchingCubesGenerator'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.11 – 使用 MarchingCubesGenerator 渲染的地图'
- en: '](img/B17984_10_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_10_11.jpg]'
- en: Figure 10.11 – The map rendered using MarchingCubesGenerator
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 使用 MarchingCubesGenerator 渲染的地图
- en: As you can see, we get smoother walls and much fewer vertices (with improved
    performance). If you like this cave generator and want to explore it in depth,
    I encourage you to go to the official tutorial by navigating to [https://learn.unity.com/tutorial/generating-content](https://learn.unity.com/tutorial/generating-content).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们得到了更平滑的墙壁和更少的顶点（性能得到提升）。如果您喜欢这个洞穴生成器并想深入了解，我鼓励您通过访问[https://learn.unity.com/tutorial/generating-content](https://learn.unity.com/tutorial/generating-content)的官方教程。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we barely scratched the surface of PCG. First, we started with
    a simple algorithm to create randomized goblin biographies. Then, we unleashed
    the power of CA to develop an intricate cave system and discovered two techniques
    to render abstract grids in 3D maps.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅仅触及了PCG（程序生成内容）的表面。首先，我们从一个简单的算法开始，用于创建随机的哥布林传记。然后，我们利用CA（细胞自动机）的力量开发了一个复杂的洞穴系统，并发现了两种在3D地图中渲染抽象网格的技术。
- en: However, as I said, this is just the beginning. PCG represents a massive class
    of algorithms blending the boundary between programming and art. PCG alone is
    a programming field worth exploring, and this short chapter's goal was to give
    you just a tiny taste of it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我所说的，这只是一个开始。PCG代表了一类庞大的算法，它融合了编程与艺术的边界。PCG本身就是一个值得探索的编程领域，本章的目的是给你一个微小的尝试。
- en: Now, though, we have no more time for PCG. It is time to move on to machine
    learning in the next chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已没有更多时间来探讨PCG了。是时候进入下一章，学习机器学习了。
- en: Further reading
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you are interested in a deeper exploration of PCG in Unity, Ryan Watkins
    wrote an entire book on the topic titled *Procedural Content Generation for Unity
    Game Development* for *Packt*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要对Unity中的PCG进行更深入的探索，Ryan Watkins为此主题撰写了一整本书，书名为*《Unity游戏开发中的程序内容生成》*，由*Packt*出版。
