<html><head></head><body><div><div><p>&#13;
    <h1 class="chapterNumber"><a id="_idTextAnchor057"/>7</h1>&#13;
    <h1 id="_idParaDest-112" class="chapterTitle">Introducing the Neo4j Spring AI and LangChain4j Frameworks for Building Recommendation Systems </h1>&#13;
    <p class="normal">We looked at Haystack and Python-based intelligent applications in the previous chapters. While Python is the favored language framework of data scientists, there are scenarios where we might need other frameworks to build solutions. One other popular language framework that comes to mind is Java. Java is faster than Python, provides integration to various data sources in a seamless manner, and is the most used language to build web-based applications along with the Spring Framework. For this purpose, we will look at how we can build intelligent applications based on <strong class="keyWord">Large Language Models</strong> (<strong class="keyWord">LLMs</strong>) and <a id="_idIndexMarker308"/>Neo4j in the next few chapters. </p>&#13;
    <p class="normal">Also, we have been concentrating on leveraging LLM capabilities to build intelligent search applications. This is just one aspect, though; LLMs can also be great tools in building and using knowledge graphs to power better recommendation systems. In this chapter, we will understand recommendation systems and why personalized recommendations are important. We will briefly touch upon the traditional rule-based approach for recommendation systems and also talk about some of their shortcomings. We will then introduce you to the LangChain4j and Spring AI frameworks and how they can support you in building intelligent recommendation systems.</p>&#13;
    <p class="normal"> In this chapter, we are going to cover the following main topics:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Understanding extended Neo4j capabilities to build intelligent applications</li>&#13;
      <li class="bulletList">Personalizing recommendations</li>&#13;
      <li class="bulletList">Introducing Neo4j’s LangChain4j and Spring AI frameworks</li>&#13;
      <li class="bulletList">Overview of an intelligent recommendation system in Neo4j GenAI ecosystem</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-113" class="heading-1">Technical requirements</h1>&#13;
    <p class="normal">While this chapter focuses on personalized recommendations and introduces the LangChain4j and Spring AI frameworks, there are no specific technical requirements for this section.</p>&#13;
    <p class="normal">However, if you are new to Spring applications, you can follow the documentation available at <a href="https://spring.io/guides/gs/spring-boot">https://spring.io/guides/gs/spring-boot</a> to get yourself warmed up with Spring Boot. We will be using a Spring Boot application with a built-in web framework in the upcoming chapters. You also need Java installed on your system. Java 17 or 19 is recommended for the coming chapters. </p>&#13;
    <h1 id="_idParaDest-114" class="heading-1">Understanding extended Neo4j capabilities to build intelligent applications</h1>&#13;
    <p class="normal">In earlier chapters, we looked at using LLMs and Neo4j to build good search applications. While knowledge graphs provide great <a id="_idIndexMarker309"/>context for building intelligent search applications, they can also be a great foundation for building personalized recommendation applications. </p>&#13;
    <p class="normal">To extract intelligence from the data and build better, more intelligent applications that go beyond basic flow-based analytics, we<a id="_idIndexMarker310"/> would need more than graph database capabilities. This is where Neo4j’s capabilities as a database can help with building better applications. </p>&#13;
    <p class="normal">Some of these capabilities are listed here:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Scalability</strong>: Neo4j enables us to build large graphs, using sharding to build federated graphs to handle large datasets. It can scale to meet data growth and business needs while minimizing costs. You can read more about these capabilities at <a href="https://neo4j.com/docs/operations-manual/current/database-administration/composite-databases/concepts/">https://neo4j.com/docs/operations-manual/current/database-administration/composite-databases/concepts/</a>.</li>&#13;
      <li class="bulletList"><strong class="screenText">Security</strong>: Neo4j, by leveraging roles, enables data security. There are roles that enable security at a high level, such as who can read or write to the database. It also provides more granular security controls defining what data can be read based on the roles. Using this approach, one user might be looking at one part of the graph and another user looking at a different part of the graph based on the roles they are assigned. You can read more about these capabilities at <a href="https://neo4j.com/docs/operations-manual/current/authentication-authorization/">https://neo4j.com/docs/operations-manual/current/authentication-authorization/</a>. </li>&#13;
      <li class="bulletList"><strong class="screenText">Flexible deployment architecture</strong>: Neo4j’s clustering architecture provides multiple options that can be deployed to scale horizontally to handle a higher volume of reads and localize reads to different servers, to minimize the cost of ownership even as data grows. You can read more about Neo4j’s clustering capabilities at <a href="https://neo4j.com/docs/operations-manual/current/clustering/introduction/">https://neo4j.com/docs/operations-manual/current/clustering/introduction/</a>. </li>&#13;
      <li class="bulletList"><strong class="screenText">Graph Data Science algorithms</strong>: Neo4j Graph Data Science algorithms unlock hidden insights from the connected data. These algorithms range from pathfinding, node similarity, centrality, and community detection to machine learning aspects such as link prediction <a id="_idIndexMarker311"/>and node classifications. You can read more about Neo4j Graph Data Science’s capabilities at <a href="https://neo4j.com/docs/graph-data-science/current/">https://neo4j.com/docs/graph-data-science/current/</a>. </li>&#13;
      <li class="bulletList"><strong class="screenText">Vector indexes</strong>: Neo4j provides vector index capabilities, to index embeddings to be able to look <a id="_idIndexMarker312"/>up similar nodes and then leverage graph traversal to provide more accurate results. You can read more about its vector index capabilities at <a href="https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/">https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/</a>. </li>&#13;
    </ul>&#13;
    <p class="normal">Neo4j as a graph database makes it easy to work with connected data easily, and the preceding capabilities go beyond connected data to help us build intelligent applications that are scalable and complex.</p>&#13;
    <div>&#13;
      <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">If you want to<a id="_idIndexMarker313"/> read more about how search and recommendation systems <br/>differ, these articles may be helpful:</p>&#13;
      <p class="normal">What’s the difference between search and recommendation: <a href="https://medium.com/understanding-recommenders/whats-the-difference-between-search-and-recommendation-c32937506a29">https://medium.com/understanding-recommenders/whats-the-difference-between-search-and-recommendation-c32937506a29</a> </p>&#13;
      <p class="normal">How are search and recommendations the same, and how are they different?:<strong class="screenText"> </strong><a href="https://gist.github.com/veekaybee/2cf54ebcbd72aa73bfe482f20866c6ef">https://gist.github.com/veekaybee/2cf54ebcbd72aa73bfe482f20866c6ef</a></p>&#13;
    </p>&#13;
    <p class="normal">We will utilize Neo4j capabilities to build an intelligent recommendation system in upcoming chapters. Before that, let’s discuss what a recommendation engine is and how personalization can help create intelligent recommendation systems.</p>&#13;
    <h1 id="_idParaDest-115" class="heading-1">Personalizing recommendations </h1>&#13;
    <p class="normal">A <strong class="keyWord">recommendation system</strong> is an <a id="_idIndexMarker314"/>application that recommends products to users based on their buying and search preferences. This aspect is not limited to just product placement but is also used in medical diagnostics and treatment. For example, recommendations may help with understanding how patients respond to medication and what kind of treatment sequence is more effective.</p>&#13;
    <p class="normal">As the data grows and the number of products available increases, the ability to understand user behavior and provide the most personal recommendations becomes more and more important. </p>&#13;
    <p class="normal">These strategies can be used to build personalized experiences. Some of these strategies are mentioned here:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Building user profiles</strong>: We can build custom user profiles by understanding user behavior. Behavior patterns can include the order of transactions made by users for a given time period or outcomes of<a id="_idIndexMarker315"/> events that occurred, along with other attributes such as age, race, and gender. We can use these aspects to segment users into various groups and create profiles for each of the groups.</li>&#13;
      <li class="bulletList"><strong class="screenText">Provide contextual support</strong>: Once the user profiles are available, we should be able to provide more meaningful and contextual support to users. This can be a recommendation to buy a product based on the last product bought or the next medication based on the current treatment level and current symptoms being experienced. These recommendations not only consider the last event that occurred but can also take other user attributes into account to provide more direct support.</li>&#13;
      <li class="bulletList"><strong class="screenText">Provide self-service experiences</strong>: Along with contextual support as needed, it is also possible to use the recommendations to provide more satisfactory self-service experiences. Users should be able to change the characteristics to be considered for recommendations, thus providing a system that adjusts how it responds to events for the user. </li>&#13;
      <li class="bulletList"><strong class="screenText">Incorporating feedback</strong>: Using all the preceding strategies, it is possible to incorporate both positive and negative feedback so that the system can adapt to individual users’ requirements as needed. </li>&#13;
    </ul>&#13;
    <p class="normal">Personalized recommendations offer numerous advantages, including suggesting the next products based on current views, providing incentives based on user behavior, enhancing brand reputation, optimizing treatment regimens for patients, marketing new drugs more efficiently, improving supply chain processes, and determining optimal delivery routes. These tailored suggestions enable businesses to deliver more relevant and impactful experiences to their customers.</p>&#13;
    <p class="normal">These are some of the <a id="_idIndexMarker316"/>ways the recommendations can be used. Some other interesting use cases of recommendation systems could be to boost sales (<a href="https://neo4j.com/developer-blog/graphs-acceleration-frameworks-recommendations/">https://neo4j.com/developer-blog/graphs-acceleration-frameworks-recommendations/</a>), manage the supply chain (<a href="https://neo4j.com/developer-blog/supply-chain-neo4j-gds-bloom/">https://neo4j.com/developer-blog/supply-chain-neo4j-gds-bloom/</a>), and carry out patient journey mapping (<a href="https://www.graphable.ai/blog/patient-journey-mapping/">https://www.graphable.ai/blog/patient-journey-mapping/</a>).</p>&#13;
    <p class="normal">Let’s take a look at the traditional rule-based approach for recommendation systems and why this approach is not sufficient for building intelligent and personalized recommendation systems. </p>&#13;
    <h2 id="_idParaDest-116" class="heading-2">Limitations of traditional approaches</h2>&#13;
    <p class="normal">Traditionally, recommendation systems used <strong class="keyWord">rule-based systems</strong>. A rule-based system is one where the decision is made by executing a set of rules based <a id="_idIndexMarker317"/>on the data input provided. The logic can be simple, or it can be very complex based on the need. For example, any credit card transaction that is more than $1,000 in certain regions will be denied automatically. A slightly more complex rule can be to deny a transaction when a small transaction is successfully carried out and then a bigger transaction is attempted. </p>&#13;
    <p class="normal">Rule-based systems usually apply two kinds of rules:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="keyWord">Static rules</strong>: Here, rules are configured manually. Once these rules are in place, they work very efficiently and the <a id="_idIndexMarker318"/>system can execute them faithfully. They are good when you require fast responses with the least number of resources consumed. They can be as simple as case statements returning a value based on input.</li>&#13;
      <li class="bulletList"><strong class="keyWord">Dynamic rules</strong>: These are<a id="_idIndexMarker319"/> sophisticated rule engines. In these scenarios, the next decision made can be dependent on in which state the current decision tree lies and the next data input.</li>&#13;
    </ul>&#13;
    <p class="normal"> Some of the benefits of using rule-based systems are as follows:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Consistency</strong>: They <a id="_idIndexMarker320"/>are consistent in their behavior and guarantee that for a given input or set of inputs, the output is the same.</li>&#13;
      <li class="bulletList"><strong class="screenText">Scaling</strong>: These systems can scale very well to handle data and complexity with ease. </li>&#13;
      <li class="bulletList"><strong class="screenText">Efficient</strong>: These are very efficient in terms of resources consumed and the cost of the system. </li>&#13;
      <li class="bulletList"><strong class="screenText">Maintenance and management</strong>: These are easier to build and maintain. This in turn makes it easy to manage these systems.</li>&#13;
    </ul>&#13;
    <p class="normal">Typically, use cases of these systems are fraud prevention and cybersecurity. While these systems are simple and <a id="_idIndexMarker321"/>easy to build, there are limitations to them. Some are listed here:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Complexity</strong>: They can grow to be pretty complex as the business needs increase, if not handled correctly. With the added complexity, most of the benefits will slowly start to vanish. </li>&#13;
      <li class="bulletList"><strong class="screenText">Rigidness</strong>: The system is too rigid to adapt to new types of data and scenarios. Even when we identify new scenarios, coding and configuring them might take too long for them to be effective. </li>&#13;
      <li class="bulletList"><strong class="screenText">Business needs adaptability</strong>: It might take too much effort to adapt these systems to the growing business needs and requirements.</li>&#13;
    </ul>&#13;
    <p class="normal">As we can see, as business needs evolve, we are stuck with limited options when relying on rule-based systems. It becomes more important to build an intelligent application that can adapt to the new data points as well as data complexity to provide better context to give good recommendations. These systems should be more adaptable to changing environments, data, as well as new requirements in a quick fashion. </p>&#13;
    <p class="normal">This is where Neo4j as a graph database and the surrounding technology stack help us to build intelligent recommendation systems. Let’s find out how.</p>&#13;
    <h1 id="_idParaDest-117" class="heading-1">Introducing Neo4j’s LangChain4j and Spring AI frameworks</h1>&#13;
    <p class="normal">To build intelligent applications, we can utilize multiple frameworks available around Neo4j. For the specific use case of intelligent recommendation systems, we will take a look at the Java frameworks Spring AI and LangChain4j. </p>&#13;
    <h2 id="_idParaDest-118" class="heading-2">LangChain4j </h2>&#13;
    <p class="normal"><strong class="keyWord">LangChain4j</strong> (<a href="https://github.com/langchain4j/">https://github.com/langchain4j/</a>) is a<a id="_idIndexMarker322"/> Java framework inspired by the popular Python LangChain framework to build LLM applications in Java. Its goal is to simplify integrating LLM APIs into Java applications. Toward that, it builds an API that is a blend of LangChain, Haystack, LlamaIndex, and <a id="_idIndexMarker323"/>other concepts and adds its own flavor to build complex applications. This is how it achieves these objectives.</p>&#13;
    <p class="normal">The following list helps us understand how it achieves these objectives:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Unified APIs</strong>: All the<a id="_idIndexMarker324"/> LLM providers, such as Open AI and Google Gemini, have their own proprietary APIs to build applications. Vector stores such as Neo4j, Pinecone, and Milvus also provide their own APIs to store and retrieve the embeddings. LangChain4j provides a unified API to hide the complexity of all these APIs to make development easier. </li>&#13;
      <li class="bulletList"><strong class="screenText">Comprehensive toolbox</strong>: The <a id="_idIndexMarker325"/>LangChain community has identified various patterns, abstractions, and techniques to build numerous LLM applications and examples in ready-to-use packages to jumpstart development. Its toolbox includes examples of low-level prompt templates, chat memory management, AI services, and RAG. Most of these examples are ready for easy integration into other applications.</li>&#13;
    </ul>&#13;
    <p class="normal">LangChain4j provides the following <a id="_idIndexMarker326"/>features that help us in building intelligent applications: </p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">More than 15 LLM providers</strong>: LangChain4j provides a simple API to integrate the LLM providers into an application and use <a id="_idIndexMarker327"/>them easily. You can read more about the language model integrations at <a href="https://docs.langchain4j.dev/category/language-models">https://docs.langchain4j.dev/category/language-models</a>. </li>&#13;
      <li class="bulletList"><strong class="screenText">More than 20 vector stores</strong>: The vector store<a id="_idIndexMarker328"/> API allows storing the embeddings generated and querying them. Here is the vector store API for you to look at: <a href="https://docs.langchain4j.dev/tutorials/embedding-stores">https://docs.langchain4j.dev/tutorials/embedding-stores</a>. </li>&#13;
      <li class="bulletList"><strong class="screenText">AI services</strong>: LangChain4j has low-level APIs, such as those that directly interact with LLM providers and vector stores. But that might be too low level for some scenarios. To make things simple, it also provides more high-level API flows to integrate LLMs, vector stores, embedding<a id="_idIndexMarker329"/> models, and RAG as a pipeline. These are called AI services (<a href="https://docs.langchain4j.dev/tutorials/ai-services">https://docs.langchain4j.dev/tutorials/ai-services</a>). We will use AI Services in the upcoming chapters.</li>&#13;
      <li class="bulletList"><strong class="screenText">RAG</strong>: LangChain4j provides support for the RAG indexing, as well as RAG retrieval, stage. It has a simple <strong class="screenText">Easy RAG</strong> feature<a id="_idIndexMarker330"/> that makes it easy to get started with RAG features. You<a id="_idIndexMarker331"/> can read more <a id="_idIndexMarker332"/>about the RAG capabilities provided by LangChain4j at <a href="https://docs.langchain4j.dev/tutorials/rag">https://docs.langchain4j.dev/tutorials/rag</a>.</li>&#13;
    </ul>&#13;
    <p class="normal">LangChain4j has good integration <a id="_idIndexMarker333"/>with the Spring Framework. But the Apache Spring framework has also built a separate AI integration framework similar to<a id="_idIndexMarker334"/> LangChain4j, called Spring AI. We will take a look at this framework next.</p>&#13;
    <h2 id="_idParaDest-119" class="heading-2">Spring AI</h2>&#13;
    <p class="normal"><strong class="keyWord">Spring AI</strong> is inspired by LangChain4j and LlamaIndex. While LangChain4j supports simple Java applications as well as Spring <a id="_idIndexMarker335"/>applications, Spring AI is optimized to work with Spring Framework. This means those who are well versed in the Spring Framework can develop LLM applications faster and easier. </p>&#13;
    <p class="normal">Since the Spring Framework provides multiple modules to connect to various databases and coding patterns that are well defined and used by a lot of developers, this new feature makes it very easy for developers to adopt and build AI applications quickly. Some of the Spring AI capabilities that can help us in building intelligent applications are as follows: </p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">LLM prompt templates</strong>: LLM prompt templates provide a simple API to integrate LLMs easily. </li>&#13;
      <li class="bulletList"><strong class="screenText">Embedding models</strong>: Spring AI can integrate various embedding model engines using configuration to <a id="_idIndexMarker336"/>generate vector embeddings. </li>&#13;
      <li class="bulletList"><strong class="screenText">Vector stores</strong>: Spring AI also provides simple APIs to store and query vector stores. It provides easy, configuration-based integration to connect to various vector stores, such as Neo4j, Pinecone, and Milvus. </li>&#13;
      <li class="bulletList"><strong class="screenText">RAG</strong>: You can also chain LLM prompt templates, embedding models, and vector stores to build effective RAG applications with Spring AI. </li>&#13;
    </ul>&#13;
    <p class="normal">Both the LangChain4j and Spring AI frameworks provide core APIs to integrate with LLM chat models, prompt templates, embedding models, and vector stores. Along with providing the low-level APIs to talk with those systems, they also make it easy to build more sophisticated applications using higher-level APIs, such as RAG framework APIs.</p>&#13;
    <h2 id="_idParaDest-120" class="heading-2">Why Java-based frameworks?</h2>&#13;
    <p class="normal">There are a lot of frameworks in Python that can work with Neo4j. But there are a lot of applications that use<a id="_idIndexMarker337"/> Java frameworks. These frameworks provide a means to connect to various data sources, leveraging various packages available to build complex applications. </p>&#13;
    <p class="normal">These frameworks <a id="_idIndexMarker338"/>support various vector stores, such as Neo4j, and multiple LLM providers, such as Amazon Bedrock, Azure OpenAI, Google Gemini, Hugging Face, and OpenAI. They offer high-level AI capabilities, from simple tasks such as formatting inputs and parsing outputs for LLMs to more complex features such as chat memory, tools, and RAG.</p>&#13;
    <p class="normal">By combining these capabilities with Neo4j, these frameworks make it easier to build more complex applications, such as generating embeddings for graph features (paths, etc.) using LLMs, which can form the basis for enhancing the graph using similarity and community detection algorithms to group nodes into segments. This segmentation can provide the basis for next-level recommendations and other aspects. You can read more<a id="_idIndexMarker339"/> about Neo4j’s GenAI ecosystem at <a href="https://neo4j.com/labs/genai-ecosystem/">https://neo4j.com/labs/genai-ecosystem/</a>.</p>&#13;
    <h1 id="_idParaDest-121" class="heading-1">Overview of an intelligent recommendation system in Neo4j GenAI ecosystem</h1>&#13;
    <p class="normal">Let us look at how recommendation systems that are built on LLM/RAG principles would function in the Neo4j GenAI ecosystem (<em class="italic">Figure 7.1</em>).</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_07_1.png" alt="Figure 7.1 — Neo4j RAG recommendation architecture" width="1650" height="1078"/></figure>&#13;
    <p class="packt_figref">Figure 7.1 — Neo4j RAG recommendation architecture</p>&#13;
    <p class="normal">We can leverage the features of these frameworks to build RAG applications backed by knowledge graphs. In<a id="_idIndexMarker340"/> this architecture, we are leveraging the Spring AI app to augment the graph to be able to provide more personal recommendations. </p>&#13;
    <p class="normal">Also, for RAG, this architecture can leverage the vector indices as well as graph traversal to augment the response, to get the best of both worlds to get more accurate responses. This concept is called <strong class="keyWord">G</strong><strong class="keyWord">raph RAG</strong>. Knowledge <a id="_idIndexMarker341"/>graphs can bring more accurate responses, rich context, and explainability for AI model interactions. Neo4j can integrate into LangChain4j and Spring AI to act as a vector store as well as a graph database to augment the LLM responses.</p>&#13;
    <h1 id="_idParaDest-122" class="heading-1">Summary</h1>&#13;
    <p class="normal">In this chapter, we looked at the capabilities of Neo4j that help us build intelligent applications, why the personalization that these applications can provide is useful, and how they are different from the existing rule-based applications. We looked at what Spring AI and LangChain4j are and their capabilities to build intelligent applications. </p>&#13;
    <p class="normal">In the next chapter, <a href="Chapter_08.xhtml#_idTextAnchor058"><em class="italic">Chapter 8</em></a>, we will build a graph data model to support intelligent and personalized recommendations with the H&amp;M dataset and see how this data can be loaded into a graph data model with the aim of providing recommendations. <a href="Chapter_09.xhtml#_idTextAnchor059"><em class="italic">Chapter 9</em></a> of this book will enable you to integrate this intelligent recommendation system with the Spring AI and LangChain4j frameworks. </p>&#13;
  </div>&#13;
</div></div></body></html>