- en: Awareness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our last chapter, we will be looking at how we can develop AI characters
    that use **tactics** and awareness to accomplish their goals. Here we will be
    using everything that we have explored before, understanding how we can combine
    everything together to create artificial intelligent characters that can be used
    in stealth games or games that also rely on tactics or awareness.
  prefs: []
  type: TYPE_NORMAL
- en: Stealth sub-genre
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stealth games are a very popular sub-genre where the main objective of the player
    is to use stealth elements, being undetected by the opponents in order to complete
    the main goals. Even being a genre that is widely popular in military games it
    is possible to see this sub-genre being applied in almost any game. If we take
    a deep look, any game where the enemy character is triggered by noise or vision
    of the player, is using stealth elements. This means that at some point or another,
    having awareness or even tactics implemented on our AI characters can be very
    useful regardless of the game genre that we are working on.
  prefs: []
  type: TYPE_NORMAL
- en: About tactics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tactics is the process that the character or a group of characters take
    in order to achieve certain objectives. It usually means that the characters can
    use all of their abilities, choosing the best ones depending on the situations,
    to defeat the opponent. The concept of tactics in video games is to give to the
    AI the power of decision, making him behave smartly while trying to reach the
    main goal. We can compare this to the tactics that are used by the soldiers or
    police officers in order to catch the bad guys of the real world.
  prefs: []
  type: TYPE_NORMAL
- en: They have a wide array of technology and human resources to catch a bandit,
    but in order to accomplish that task with success they need to choose wisely what
    they are going to do, step by step. The same principles can be applied to our
    AI characters; we can make them choose the best options available in order to
    accomplish their objective.
  prefs: []
  type: TYPE_NORMAL
- en: To create this, we can use every topic that was covered before in this book
    and with that, we are able to develop an AI character capable of choosing the
    best tactic that takes down the player or achieving his goal.
  prefs: []
  type: TYPE_NORMAL
- en: About awareness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very important aspect that correlates with the tactics is the awareness
    of the character. Some common factors can make part of the awareness of an AI
    character such as audio, vision, and perception, for example. These factors are
    inspired on the human features that we all have, vision, audio, touch, and perception
    of what is happening around us.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, what we are looking for is to create artificial intelligent characters
    that can process all of that information at the same time that they are doing
    other things making them aware of the surroundings, making better judgment of
    what decisions should be taken on that given moment.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing vision awareness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting out with the tactics, we will take a look at how we can implement
    an awareness system into our characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a vision awareness into our game character. The
    idea is to simulate the human vision, where we can see very good at close range
    and not so good when something is really far away. Many games have adopted this
    system and they all have differences, some have a more complex system while others
    have a basic one. The basic example can be found especially on a more juvenile
    adventure game such as *Zelda - Ocarina of Time* for example, where the enemies
    will only appear or react when you reach a certain trigger zone as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e634c2a-2595-451a-b6cc-c9e2a4445eac.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, in this situation if the player goes back and exits the enemy trigger
    zone, the enemy will stay in an idle position, even if he is clearly able to see
    the player. This is a basic system of awareness and we can include it in the vision
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, other games have developed their entire gameplay around this subject
    (vision awareness), where the vision range has an extremely important aspect on
    the gameplay itself. One of the several examples can be the Ubisoft title, Splinter
    Cell.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c0e34f2-de5e-46c0-9652-709813e5cfc2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this game all types of awareness systems are used, sound, vision, touch,
    and perception. If the player stays quiet in a shadowy area, it has less chance
    of being discovered than being quiet in a well-illuminated area and the same for
    the sound. So, for the example in the preceding screenshot, the player has approached
    very close to the enemy that is looking in another direction.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the player to get this near, it was necessary to move very quietly
    and in the shadows. If the player was making noise or walking straight into illuminated
    areas, the enemy would have spotted him. This is a much more complex system than
    the *Zelda* game, but once again, it all depends on the game that we are creating
    and which system fits better on the gameplay that we are looking for. We will
    be demonstrating basic examples and then moving on to more advanced ones.
  prefs: []
  type: TYPE_NORMAL
- en: Basic vision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we start by creating and adding a scene into our game, and then we add
    the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43d47bd0-21c0-4543-9e03-e731913062e0.png)'
  prefs: []
  type: TYPE_IMG
- en: We assign all the necessary codes into the player so it is possible for us to
    move and test the game. For this example, we have quickly assigned some basic
    movement information into our player, because that is the only interaction that
    will occur between the player and the AI character.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b737f4f7-884b-4436-9704-aeb9e6d8e543.png)'
  prefs: []
  type: TYPE_IMG
- en: So now, we have our character moving freely on the scene and we are ready to
    start working on the enemy character. We want to replicate that specific moment
    on the *Zelda* game, where the enemy comes from the ground when the player gets
    near from his position and once the player gets far away, the enemy goes back
    into the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c1e20d6-31c5-4d0d-9afc-677e27a5c4cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The rabbit that we can see in the screenshot is the AI character that we have
    just imported into the game and now we need to define the area around him that
    will serve as awareness. Therefore, if the player gets near the rabbit he will
    detect the player and will eventually get out of his hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d504395-bf16-4b46-ac42-99bac8e2e8ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's say that we want the rabbit to be able to see from his hole the area that
    is represented by the dashed line. How can we proceed from now? We can do two
    things here, one is adding the trigger `Collider` into the hole object, where
    it will detect the player and instantiate the rabbit from the hole position, two
    is adding the trigger `Collider` directly to the rabbit that will be invisible
    (hypothetically inside the hole) and in the code we have a state for when the
    rabbit is inside the hole and another state for the moment when he is outside.
  prefs: []
  type: TYPE_NORMAL
- en: We decided for this example to use the hole as the main object for that moment
    where the rabbit is hiding and at the moment that the player enters the trigger
    area, the hole object instantiates the AI character.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e3beb94-d755-4f89-be6e-9e9d28596418.png)'
  prefs: []
  type: TYPE_IMG
- en: We transformed the rabbit into a prefab, so we can instantiate it later and
    then we removed him from the scene. Then we have created a cube inside the game
    and we positioned it on the hole position. Because we don't need the hole to be
    visible for this example, we will be turning off the mesh from this object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cube instead of an empty object allow us to better visualize the
    object inside the game editor in case we need to change something or simply have
    a notion of where we have those objects.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to make this object detect the player and so we will
    be adding a trigger with the dimension that we previously planned to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa95e62c-686b-4076-8ba6-48180128656f.png)'
  prefs: []
  type: TYPE_IMG
- en: We deleted the default cube trigger that appears automatically when you create
    the cube and then we assigned a new sphere trigger. Why are we not using the cube
    trigger? We could be using the cube trigger and technically it would work too,
    but the covered area would be completely different from the circular area that
    we planned and for that reason we deleted the default trigger and assigned a new
    one that fits our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the sphere trigger covering the area that we want, we need
    to make it detect the player. For this, we need to create the script that will
    be assigned to the cube/hole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Inside the script, we add this line of code. It is a simple trigger check for
    when the object gets inside the trigger area (we have used this to demonstrate
    previous examples). For now we simply have the trigger to check if the player
    gets detected using `Debug.Log("Player Detected");`. We assign this script to
    the cube/hole object and then we can test it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e357aff-bca8-4c18-9d77-528c9011aafc.png)'
  prefs: []
  type: TYPE_IMG
- en: If we move the player into the trigger area that we created, we can see the
    message Player Detected.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cb7af3a-3a51-4556-8ab7-17e5b6f1a714.png)'
  prefs: []
  type: TYPE_IMG
- en: Well this is the first part of the basic example; we have the player moving
    around the map and the hole that is capable of detecting the player when he is
    near.
  prefs: []
  type: TYPE_NORMAL
- en: This method where we use the trigger Collider to detect something isn't directly
    associated with any kind of awareness because this is just the technical part,
    the way we use it is what will determine if this is meant to be the vision of
    our AI character or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can work on the rabbit, our AI character. We already have him created
    and set as a prefab, ready to appear in the game. So the next step is for the
    hole object to instantiate the rabbit, transmitting the sensation to the player
    that the rabbit saw him and for that reason he decided to get out of the hole.
    On the hole object code we update the `Player Detected` message to the `instantiate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So what we have done is define what would be the instantiated object, which
    in this case is the character AI `rabbit`. Then we added the `startPosition` variable
    that will set the position where we want the character to appear, in alternative
    we could also use the hole object position that would work just fine for this
    example. Finally, we added a simple Boolean `isOut` to prevent the hole creating
    more than one rabbit at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: When the player gets inside the trigger zone, the rabbit gets instantiated and
    jumps out of the hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdd9bccc-80e9-4448-8a58-6951a968870e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have a rabbit that jumps out of the hole when he sees the player. Our
    next step is to also add the same vision to the rabbit itself, but this time we
    want the rabbit to constantly check if the player is inside the trigger zone,
    this would represent that it can see the player and if the player gets away from
    his vision, the rabbit cannot see him anymore and returns to the hole.
  prefs: []
  type: TYPE_NORMAL
- en: For the AI character, we can use a wider area than the hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/064e7d41-56cf-4232-9338-69760341c0df.png)'
  prefs: []
  type: TYPE_IMG
- en: So as we can see, that would be the area where the rabbit can see the player,
    if the player gets out of that area, the rabbit can't see the player no more.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8e0c30a-b820-40c6-a666-037c85207eda.png)'
  prefs: []
  type: TYPE_IMG
- en: Once again, let's add a sphere `Collider`, but this time to the rabbit.
  prefs: []
  type: TYPE_NORMAL
- en: Enable the Is Trigger option in order to turn the Collider into activation zones.
    Otherwise it won't work.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/078db524-bf56-4d32-ae1c-8e00a5579b24.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what we have so far, the sphere `Collider` with the dimensions that
    we planned and ready to receive the player position information that will serve
    as the vision to our AI character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what we need to do is add to the rabbit script the portion of the code
    that is responsible for the trigger zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What we have here is a trigger check to see if the player continues inside the
    trigger zone, to do this we simply use the `OnTriggerStay`, which works perfectly
    to this example that we are creating.
  prefs: []
  type: TYPE_NORMAL
- en: We use `Debug.Log("I can see the player");` simply to test if this is working
    as intended.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef9de8f0-baef-4eb6-a81a-150b6e9d72e5.png)'
  prefs: []
  type: TYPE_IMG
- en: We test the game and we can notice that when the player gets inside the rabbit
    area, we receive the console message that we wrote and this means that it is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the second part of the rabbit vision, where the player gets
    out of the trigger zone and the rabbit can''t see him no more. To do this we need
    to add another trigger check, which will serve to check if the player already
    left the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `OnTriggerStay` that we added into the AI character code,
    we add some new lines of code that checks if the player has left the trigger zone.
    To do this we use the `OnTriggerExit` that does what the name says, checks the
    exit of the object that has entered the trigger zone. But to make this work we
    need to first set an `OnTriggerEnter`, otherwise it won''t count if the player
    entered the zone or not, it only knows if he is there or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the trigger counting when the player gets inside the area, when
    he keeps inside the area, and also the moment that he exits that same area. This
    represents the moment that the rabbit starts seeing the player, when he keeps
    seeing him, and when he loses eye contact with the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/634c1045-8a71-4703-b133-88a9ce03ee0b.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we can test the game and see if what we have done is working
    correctly or not. When we start the game, we can confirm that by looking at the
    console messages that we wrote to see if everything is working as intended.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8e5353b-0612-489b-b423-d3df3180d983.png)'
  prefs: []
  type: TYPE_IMG
- en: It is normal to see a higher number on the `OnTriggerStay` function because
    it is constantly checking every frame for the player, so as we can see in the
    preceding screenshot, our AI character now has the basic vision check working.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced vision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how a basic vision detection that we can find in many
    action/adventure games works, we can move on and take a look at the advanced vision
    detection that can be found in stealth games. Let's take a deep look into the
    *Metal Gear* game and see how the AI characters have their vision developed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21de399f-a13e-485a-a98f-0bda9bc35904.png)'
  prefs: []
  type: TYPE_IMG
- en: If we take a look at this screenshot, we notice that the enemy AI cannot see
    the player, but the player is inside of the area where the enemy is well capable
    of seeing. So why doesn't the AI character turn to the player and start attacking
    him? Simply because the trigger area is set only to be in front of the enemy eyes.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, if the player is behind the enemy, he won't notice the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9376beea-2a4f-46a5-8bda-eb95074f9b10.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the second screenshot, everything that is in the darker area,
    the enemy doesn't have any way of getting information regarding the players presence,
    while the light area represents the vision of the character and there he can see
    everything that is happening. Now we will be taking a look at how we can develop
    a similar system into our AI characters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a test scenario. It can be simple cube meshes for now
    and later on we can change them into a better looking object.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a51a55a1-eaeb-486d-8ca0-677bbd014fe7.png)'
  prefs: []
  type: TYPE_IMG
- en: We have created a few cube meshes and placed them randomly on top of a plane
    (that will be the ground). The next step will be creating the character, we'll
    be using a capsule to represent the character.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/376b44cb-3496-49c9-8d3b-d03b7687e10e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can place the newly created capsule anywhere on the map. Now, we need to
    create some targets that will be spotted by our AI character.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce7aec7e-ad9f-42ab-b59a-d7a765a111c9.png)'
  prefs: []
  type: TYPE_IMG
- en: We can distribute the target objects anywhere on the map as well. Now, we need
    to define two different layers, one for the obstacles and another one for the
    targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2333f05-eb2a-4e4e-969a-243af5bf1a31.png)'
  prefs: []
  type: TYPE_IMG
- en: In Unity we click under the Layers button to expand more options, and then we
    click where it says Edit Layers....
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/159cbdd1-f4c1-4cb5-9364-ef0d3cede3f6.png)'
  prefs: []
  type: TYPE_IMG
- en: This column will open and here we can write the layers we need to create. As
    we can see, there's already the two layers that we need, one called Obstacles
    and the other called Targets. After this, we need to assign them to the objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1e4d60e-6596-4a80-8e2f-6f4514afc08c.png)'
  prefs: []
  type: TYPE_IMG
- en: To do this we simply need to select the Obstacles objects and then click on
    the Layers button and choose the Obstacles layer. We also do the same for the
    Target objects, choosing the Targets layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is start adding the necessary code into our character.
    We will also need to add to the character a rigid body and freeze all the rotation
    axis demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdc08b62-156b-4eb1-acc4-c700048a4268.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we can create a new script for the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we have here is the basic movement of our character, so we can test it
    ourselves by controlling the character to move anywhere we want to. With this
    done, we are able to move around the map with the character and with the mouse
    we can simulate the direction in which the character is looking at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s work on the script that simulates the vision of our character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start out with two public floats, one for the `viewRadius` and another one
    for `viewAngle`. Then we create a public `Vector3` called `DirFromAngle` and we
    want the results to be in degrees and so we will be using trigonometry to solve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1097ca5f-880c-4d4d-a98e-da65a7ebaba1.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram represents the default trigonometry values in degrees,
    where it starts from the right side with the number zero and the values will increase
    in a counter-clockwise way.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55cfbbda-2541-4ae9-b953-ca465958f95a.png)'
  prefs: []
  type: TYPE_IMG
- en: Because we are developing this example in Unity, we need to keep in mind that
    the trigonometry values are in a different order, as we can see in the preceding
    diagram. Here, the zero number starts on the top and the value increase in a clockwise
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information in mind, we can now proceed with the direction angle
    in which our character will be looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the basic foundation of our exercise done, but in order to visually
    see it on the game editor we need to create a new script that will show the radius
    of the character vision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e38b974d-71ae-487a-be08-dda6e03d466e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To do this, we go ahead and create a new folder in the project section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4716b447-8e41-479b-9411-6737f25dbcfd.png)'
  prefs: []
  type: TYPE_IMG
- en: In order for the game engine to use this content that will appear in the game
    editor we need to name the folder as `Editor`. Everything inside this folder can
    be used/seen in the game editor, without clicking the play button, which can be
    very handy in many situations just like the one we are creating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then inside of the `Editor` folder that we just created, we create a new script
    that will be responsible for the visualization of the character field of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because we want to use this script in editor mode, we need to specify that on
    the top of our script. To do that, we start by adding `using UnityEditor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then after that we add one more line in which we will be connecting with the
    previous script we created to be able to use that in editor mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s work on what is going to appear on the screen to represent the
    field of view that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a `void OnSceneGUI()` and this will contain all the information
    that we want to be visible on our game editor. We start by adding the target of
    the field of view; this will get the field of view object reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define the color that we want to represent the vision of our character,
    to do this we added the `Handles.color` and we have chosen the color to be white.
    This won''t be visible on the export version of our game, so we can choose the
    color that is easier for us to see in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done now is give a form to the visualization that we are creating.
    The form is set to be in an arch and that is why we use `DrawWireArc`. Now, let''s
    take a look at what we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79738248-3fd4-45f8-9be7-5515b8cc397c.png)'
  prefs: []
  type: TYPE_IMG
- en: On the script that we created and assigned to the character, we need to change
    the value of View Radius to any desired value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e536add-dc73-498c-932c-f7d311bc6915.png)'
  prefs: []
  type: TYPE_IMG
- en: When increasing that value, we will notice a circle growing around the character,
    this means that our script is working well so far. The circle is representing
    the vision of our character and now let's change a few things to make it look
    like the *Metal Gear Solid* image that we used as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the character `FieldOfView` script again to add new modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We added a range for the `viewRadius` so that way we can make sure that the
    circle does not surpass the `360` degrees mark. Then we added a Boolean parameter
    to `public Vector3 DirFromAngle` to check if the angle value is set to global,
    so that way we can control the direction that our character is facing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we are going to open the `FieldOfViewEditor` script once again to add
    the `viewAngle` information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test it again to see the new modifications that we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78418ef8-559d-443d-9dff-48b02acdd1ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the `View Angle` option we are going to change the value from zero to any
    other to see what it is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7d5a8ad-8d76-4bbe-82fd-4b53cfe05133.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if we look at the circle that is around the character, we will notice a
    triangular shape inside. The size of that shape can be controlled precisely with
    the `View Angle` option, and the triangle shape represents the vision of our character,
    so at this moment we can notice that the character is looking slightly to the
    bottom right.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30a6878a-9e4a-40ad-9348-f841e9c96efb.png)'
  prefs: []
  type: TYPE_IMG
- en: Because we have set the angle value to be at a global angle, we can rotate the
    character and the view angle will follow the character rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s work on the vision raycast, this part is responsible for detecting
    what exists in the direction that our character is looking at. Once again, we
    are going to edit our `FieldOfView` script that we created for our character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done here, is add the `Physics` information into our script, detecting
    only the objects that can be found inside of the character `View Angle`. To check
    if something is in sight of our character, we use a `Raycast` to check if any
    object with the layer `obstacleMask` is detected. Now let''s create an `IEnumerator`
    function to implement a small delay for our character detecting new obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that, we have created an `IEnumerator`, the character has a small reaction
    time that in this case is set to `.2f` to find targets inside of his vision zone.
    In order to test this we need to make some new modifications inside of our `FieldOfViewEditor`
    script. So let''s open it and add a few new lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the new modifications on the code, we should be able to see when the character
    has detected an obstacle and when that obstacle get out of his vision zone.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4398190c-ffd9-48e9-b252-338b396fc9ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To test this out we first need to select all the obstacles that we have inside
    of our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dff5f35-6ed4-41f5-a130-5060fd93419d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then assign them the Obstacles layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9415dad8-b0fc-4f0f-867a-0341fd843eba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to select all of the Targets inside of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5845b7ee-386c-4923-a4fe-d6afca4fd8b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then assign them the Targets layer. This step is very important so that
    our Raycast can identify what is inside of the character field of view. Now, let''s
    click on the character object and define which layer represents the Targets and
    which layer represents the Obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7df547b-b1e7-401b-a477-1f85a1881182.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We go to the Layer Mask option that can be found in the Field Of View script
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37a177a9-443e-4d69-bb69-ced606aa47fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And we choose the Targets layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0ba92b9-9c58-466b-899e-4b6b23d5108e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we go to the Obstacles option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1289f14d-ed96-4f32-9b76-8335278b63af.png)'
  prefs: []
  type: TYPE_IMG
- en: And we choose the Obstacles layer.
  prefs: []
  type: TYPE_NORMAL
- en: With this part done we can finally test the exercise to see what happens when
    the character finds a target.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac684402-40d5-4e88-b964-3beede2eaa5a.png)'
  prefs: []
  type: TYPE_IMG
- en: When playing the exercise, we can see that a red line appears connecting the
    character and the target, when a target gets inside of the vision zone. This represents
    that our character has spotted an enemy for example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b681cc3a-af97-4dda-817b-a3e19420e60e.png)'
  prefs: []
  type: TYPE_IMG
- en: But, when we move our character and we have an obstacle in front of a target,
    even if the target is inside the vision zone, the character cannot detect him
    because there is an object in front of him blocking his view. This is why we need
    to assign the Obstacle layer to every object that might block the character vision,
    that way he won't have any X-Ray vision.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46329859-33d4-4704-8634-40ebc544b164.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also point our character to two targets that both of them will connect
    to, this means that our character is also able to detect more than one target
    at the same time, which is very useful to define better strategies and tactics.
  prefs: []
  type: TYPE_NORMAL
- en: Realistic field of view effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the vision detection working, we can move on to the next step
    and add a realistic field of view effect. This will allow the character to have
    peripheral vision, making what is seen on the sides less detailed and what is
    seen in the front more detailed. It is a simulation of our real human vision,
    where we tend to focus more on what is in front of us and if we need to check
    something that is on the sides, we need to turn into that direction in order to
    have a better look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by opening our `FieldOfView` script. Then we add a new float variable
    called `meshResolution`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a new method and we are going to call it `DrawFieldOfView`.
    Inside of this method, we will define the amount of `Raycast` lines that our field
    of view will have. Also we will define the angle of each line that will be drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating this new method, we simply need to call it from the update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can open the game editor and test it to visualize what we
    have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f630c4ad-fc30-417f-a05e-2f1eccffc35e.png)'
  prefs: []
  type: TYPE_IMG
- en: Right away when we press play to test our script, we won't see any difference
    between the old version and the new one. This is normal because we need to increase
    the Mesh Resolution of our character.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbeb3b37-d971-4b52-aec0-de7e0f2652bb.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we need to add a value in the Mesh
    Resolution variable in order to see the desirable results.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9f5c71a-1b2d-4b44-b89a-38acc21c00d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding 0.08 into the Mesh Resolution variable, we can notice already that on
    the game editor window, a few red lines appear and that's exactly what we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we keep increasing the value, more lines will be added, meaning that more
    detailed the vision will be, which is exemplified in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b826825-f63f-4f31-a0cd-afcf2658e88c.png)'
  prefs: []
  type: TYPE_IMG
- en: But, we need to remember that increasing this value also increases the device
    CPU usage and we need to take this into consideration, especially if we are going
    to have multiple characters at once on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get back to our script and add a collision detection for each line,
    allowing our character to receive information from multiple lines at once. We
    start by creating a new method in which we will store all the information regarding
    the raycasts that will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this new method is created we can go back to our `DrawFieldOfView()` method
    and start adding the raycasts that will detect the collisions for each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the next steps, let''s see how a mesh is generated from a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e577532-6cde-4c04-a4bc-f0b619d54ea6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see one dark circle that represents the character
    and four with circles, representing the raycast finish position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd643b69-4fe1-405d-8f2b-bc3af4098046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each vertices has a value assigned to them, the first vertex that starts from
    the character, is the number zero, then it goes on a clockwise sense with the
    next vertex starting on the left and continuing counting to the right side.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d80f535-0054-421d-ac84-5a3c7a2fa642.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The vertex zero connects to the vertex **1**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b28398f-7ccc-4f4a-89b9-85a9088a81eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then vertex one connects to vertex **2**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c1ce432-df92-4de6-aa0b-3ea4eb7ad587.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And then vertex two connects back to vertex **0**, creating a triangle mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd33acfe-727d-4d67-9b79-e5912f4fb855.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the first triangle mesh is created, it continues to the next one, starting
    from *0 > 2 > 3 > 0* and the second triangle is also created. And finally the
    last one, *0 > 3 > 4 > 0*. Now, we want to transcribe this information into our
    code, so in this case the array of the field of view is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[0,1,2,0,2,3,0,3,4]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The total number of vertices on this example is five:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v = 5`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The total number of triangles created is three:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t = 3`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the number of triangles is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t = v-2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'That means that the length of our array will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(v-2)*3`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get back to our script and add the information that we have solved
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go to the top of our script and add two new variables, `public
    MeshFilter viewMeshFilter` and `Mesh viewMesh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to call those variables into our start method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/95763e1f-765a-4c97-aa1b-254e556b4080.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to select our Character object inside the game editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a9b1fb9-0d47-4921-8bdf-3fd1e66b0eb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the GameObejct section and select Create Empty Child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c1a9279-a634-46f5-9c9f-e509234a12a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Rename the object to View Visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c219883-29ed-4ef9-a3b0-106a78f48dc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the same object selected, we go to: Component | Mesh | Mesh Filter, to
    add a mesh filter to our object.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/123ea51a-f0c6-4ebf-81ed-cdccaca7b551.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we need to do the same for the Mesh Renderer, Component | Mesh | Mesh Renderer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d592e1a7-f96e-45d3-a88a-53c5a9d43da9.png)'
  prefs: []
  type: TYPE_IMG
- en: We can turn off the Cast Shadows and Receive Shadows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ce28d17-f2cb-4d11-9753-e19552e3c95e.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we add the object that we just created into our script variable View
    Mesh Filter and change the Mesh Resolution to any desirable value, in this case
    we have chosen 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can return to our script and add edit once again the `DrawFieldOfView`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test the game, to see what we have done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66995580-5e1c-475e-8e8e-a6093f2f6952.png)'
  prefs: []
  type: TYPE_IMG
- en: When we play the game, we will notice the mesh being rendered on the game and
    that's our objective so far.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to remove the `Debug.DrawLine` line of code, otherwise the mesh won't
    show on the game editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to optimize the visualization, we need to change the `viewPoints`
    from global to local space points. To do this we are going to use `InverseTransformPoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we test it again it will be more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b85c7e6-45b2-4d6d-8112-5dbd61cf1c9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks good already, but we can still improve it by changing from `Update`
    to `LateUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Doing this the movement of our mesh will be smoother.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c05259b-0101-4e75-83f9-93d968b1c1da.png)'
  prefs: []
  type: TYPE_IMG
- en: With this part of the script updated, we conclude our example, completing a
    realistic field of view system into our character.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06eb7e13-eeb5-4708-9ec3-db14387c3f68.png)'
  prefs: []
  type: TYPE_IMG
- en: All we need is to change the values in order to fit the results that we are
    looking for, making our character more or less aware of his surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5b0af90-f822-48c7-acc6-fde42381d24c.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, if we set the `View Angle` value to `360`, that makes our character
    completely aware of what is happening around and if we decrease the value, we
    will reach a more realistic vision, just like it's used in a *Metal Gear Solid*
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33e412a2-e599-4054-a96f-d385b03c160a.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point we are able to pick a stealth game and copy their most iconic
    features such as realistic vision and audio awareness. We have learned the foundations
    and now we can start from there and develop our own game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we unveiled how stealth games work and how we can recreate
    that same system so we can use it in our games. We went from a simple approach
    to a complex one, allowing us to decide what fits better in the game that we are
    creating, if it relies heavily on stealth or if we simply need a basic system
    to make our character detect the player by vision or audio awareness. The features
    that we have learned in this chapter can also be expanded and used in practically
    any example that we have created before, amplifying the collision detection, the
    pathfinding, the decisions, animations, and many more features, turning them from
    functional to realistic.
  prefs: []
  type: TYPE_NORMAL
- en: The way we create games is constantly updating, every game published brings
    a new or different method to create something, which is only possible if we are
    willing to experiment and blend everything we know, adjusting our knowledge to
    achieve the results we want to even if they look extremely complicated. Sometimes
    it is just a matter of exploring basic concepts and expanding them, turning a
    simple idea into a complex system.
  prefs: []
  type: TYPE_NORMAL
