- en: Designing Behavior Trees - Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter (and the two that follow) will take you through a more practical
    approach of what we have learned so far. In particular, we will be focusing on
    how to implement a *Behavior Tree* so that we can chase our character in the game.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we will use all the content from [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml),
    *Behavior Trees and Blackboards*, along with a *blackboard*, to execute these
    actions, a *NavMesh* to move around the environment, and the *Perception System*
    to sense the Player.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to design a **Behavior Tree**, starting from the **Expected Behavior**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the nodes that we might need on a **Behavior Tree**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a **Custom Decorator** (both in Blueprint and C++) to check boolean
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a **Custom Task** (both in Blueprint and C++) to find a random
    location around the character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Navigation System** to query the **NavMesh** to find the random
    location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a **Custom AI Controller** (both in Blueprint and C++) to use the
    **Perception System**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Perception System** to sense the Player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover more in the two chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: We will be implementing everything in both Blueprint and C++ to give you a broader
    idea of what you can use. Alternatively, if you already know what you want to
    use, you can just follow one of the two implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to follow along, I''m creating this example by starting a clean
    project (in my case, I''m doing this in C++, but if you want to follow just the
    Blueprint part of this chapter, you can use the Blueprint Template), as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9913e998-403a-4d77-b1d4-e4193bd36503.png)'
  prefs: []
  type: TYPE_IMG
- en: Unreal Project Browser
  prefs: []
  type: TYPE_NORMAL
- en: The project is called `BehaviorTreeDesign` and I am using the `Third Person`
    template.
  prefs: []
  type: TYPE_NORMAL
- en: With all this said and done, let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: The Expected Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in **Designing a Behavior Tree** is to pin down the **Expected
    Behavior** we would like to see in our character. This seems like a simple phase,
    but trying to take all the cases into consideration isn't trivial. However, it
    will avoid many headaches later on.
  prefs: []
  type: TYPE_NORMAL
- en: While writing down the **Expected Behavior**, try to be as specific as possible.
    If something is unclear, try to rephrase it. The sentences that you use should
    be short and always add information. Don't be scared if you have sentences starting
    with "In this case…" or "If…", because it will just mean that you are taking all
    the different possibilities into consideration. Once you have written it, read
    it out loud, maybe to a friend, and ask him/her if he/she clearly understands
    its meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is my attempt of describing the behavior we are going to implement in
    this chapter: "*The agent checks whether it has the player in sight. If it is
    true, then it chases the player until he/she is no longer in sight. If the player
    is not in sight, then the agent goes to the last location where it saw the player
    (if the location is known). Otherwise, the agent chooses a random location around
    it and goes to that location*"'
  prefs: []
  type: TYPE_NORMAL
- en: Building the Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you've written the **Expected Behavior**, the next step is to analyze
    it so that you understand which kind of Behavior Tree nodes we will need. Of course,
    we can always add them at a later stage, but it is better to try and anticipate
    as much as possible so that you can proceed smoothly during the creation of the
    **Behavior Tree**. Let's break down the expected behavior so that we can try and
    understand which node we need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes that already exist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to check which part of our behavior already exists in our project, and
    whether it is either a built-in functionality or whether we have already created the
    node for that functionality (maybe for another *AI Behavior Tree*).
  prefs: []
  type: TYPE_NORMAL
- en: '"The agent checks whether it has the player in sight. If it is true, **then
    it chases the player** until he/she is no longer in sight. If the player is not
    in sight, **then the agent goes** to the last location where it saw the player
    (if the location is known). Otherwise, the agent chooses a random location around
    it **and goes to that location**."'
  prefs: []
  type: TYPE_NORMAL
- en: In particular, it's worth noting that we already have a *Behavior Tree Task* already
    built in that allows the agent to chase after an object or reach a location. Therefore,
    all the highlighted parts of the **Expected Behavior** are covered.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator – check variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"***The agent checks whether it has the player in sight.** If it is true, then
    it chases the player until he/she is no longer in sight. If the player is not
    in sight, then the agent goes to the last location where it saw the player (if
    the location is known). Otherwise, the agent chooses a random location around
    it and goes to that location.*"'
  prefs: []
  type: TYPE_NORMAL
- en: To perform this check, we need to decide how the agent is going to "*perceive*" the
    player. In chapter 5, we saw how the built-in perception system works, and for
    such a trivial task, the system is more than perfect. Therefore, it is worth using
    it. However, we need to transfer this information into the *Behavior Tree*. Therefore,
    we need to start making assumptions on how we will implement the whole AI Behavior.
    For now, let's assume that this information regarding whether the player is in
    sight or not is stored within a boolean *Blackboard* variable. As a result, we
    need to implement a decorator that it is able to check this boolean variable.
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the ***Blackboard*** decorator (which is displayed for "*Blackboard
    Based Conditions*") to check whether a variable is assigned or not and use that
    to determine whether the player is on-sight or not. However, since the main goal
    of this chapter is to learn how to build a *Behavior Tree* from scratch from a
    practical point of view, it is more useful for you to create an extra Decorator
    node so that you are more familiar with the process of creating Decorators as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Also, while designing nodes, we need to try and be as general as possible, so
    that if we have a similar need in another *Behavior Tree*, we can reuse the node
    we have created. Therefore, we can create a check, by using a *Decorator* node,
    for boolean variables in general, and we will use this to check if a variable
    in our Blackboard tells us whether the player is in sight.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have established this, we need to think about how we are going to implement
    the node. In this specific case, it is quite straightforward, but to keep things
    as general as possible, let's think of other possible use of this node.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, what if we want to check if the variable is false instead? Actually,
    we will need this functionality (you will understand why later in this chapter).
    Thankfully, Unreal has us covered. In fact, there is a handy checkbox in the details
    panel of a decorator named Inverse Condition, which (as the name suggests) inverts
    the result of the condition, allowing us somehow check for the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31dbc4e1-05da-4da0-b4b2-d6d922fc889f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As an exercise, ignore this checkbox and try to implement your own version
    of inverting the condition. Even though it has no practical application, and *it
    is actually bad practice* doing something like that, it is still a useful exercise
    so that you can understand how inputs are given to a Decorator. In this exercise,
    there are two inputs for this node: the Blackboard key value (which is assumed
    to be a boolean type) to check, and another boolean variable to establish if the
    check is on the "true" or "false" value of the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let's move on to the actual implementation of this node.
    As usual, I will do this both in Blueprint and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Check Variable Blueprint implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, let's create a new *Decorator* (recall that you can either create
    it from the Behavior Tree editor or from the content browser; the first one is
    easier, but you need to have a Behavior Tree open). Either way, name it `BTDecorator_CheckBooleanVariableBP` (the
    ending "BP" is only used to distinguish it from the C++ version of it, since you
    might be doing both. In a real project, you usually have only one version).
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you close the Editor without adding anything to your Decorator (for
    instance, to rename it), when you open it, you might see a screen like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/316baf07-e302-48ce-a75e-1e41272142f5.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, just click on Open Full Blueprint Editor to go to the Blueprint
    Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we stated previously, we just need a single variable of type *Blackboard
    Key Selector* as input, which we will name `BoolVariableToCheckKey`. This holds
    a reference to the blackboard boolean variable we would like to check. Moreover,
    it needs to be public (open the eye next to the variable name) so that it can
    be seen within the Behavior Tree Editor. This is what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f519881-0e2a-4c95-bcbf-970d46852696.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to implement/override the Perform Condition Check AI function,
    which can be found in the override dropdown menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdda5624-65be-4d03-82cb-6a4535584d5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the function has been created, this is what it looks like by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3219c375-c950-417b-8bdd-2bb9aabbd08d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we need to retrieve the boolean value of our Blackboard Key, which can
    be done by using the Get Blackboard Value as Bool node. Then, we can plug the
    Return Value pin of this node into the Return Value pin of the Return Node. This
    is what the final graph should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f992d09e-7b7d-4380-a276-9921f6ae99b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the Blueprint, and the Decorator will be ready. If you wish, you can place
    it somewhere in a Behavior Tree to see if the inputs show up properly. In particular,
    this is what it looks like when placed in a Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da35b790-3f7a-4120-9b33-6aec5b2b2a82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the *Details Panel* of the *Decorator* (within the Behavior Tree Editor)
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44f5ba63-ae9c-4620-932b-5436d5043dcd.png)'
  prefs: []
  type: TYPE_IMG
- en: Check Variable C++ implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For details on how to extend a Decorator, you can have a look at Chapter 6,
    *Extending Behavior Trees*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a new C++ class that inherits from **UBTDecorator**.
    You need to search for all the classes and select BTDecorator, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/388abf62-0800-45bd-bc08-c3a388b07634.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you can rename your class `BTDecorator_CheckBoolVariable`. Also, if you
    wish, you can place the file in a sub-folder, such as `AI`. As example of this
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10f67242-1c45-49b8-b87d-c862005b9df6.png)'
  prefs: []
  type: TYPE_IMG
- en: Press Create Class, and your *Decorator* class will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have created the Class, Unreal will try to compile your code. If
    you haven''t set up your Public Dependencies in your project properly (as we learned
    back in Chapter 1 and Chapter 2; and especially in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml),
    *Extending Behavior Trees*), you should have a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46a5e21d-866f-460a-98c0-a5ab82df2271.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, when you try to compile from Visual Studio, this is what the error
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79958f18-57ed-4757-869c-14b6efa97c40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, you need to change your `.cs` file (in our case, ***BehaviorTreeDesign.cs***),
    and add "**GameplayTasks**" and "**AIModule**" as public dependencies, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able compile without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header file, we need to add an input variable, the *Blackboard Key Selector*
    that references a Boolean, named `BoolVariableToCheck`. We also need to expose
    this variable to the Behavior Tree editor by using the `UPROPERTY()` macro, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to override the `CalculateRawConditionValue()` method, which
    is public, and so its override needs to be public as well. Insert (always in the
    header file) the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to implement this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to retrieve `BlackboardComponent`, which allows us to resolve
    and get the values from the Blackboard Key Selectors. Thankfully, we can retrieve
    it from `BeheviorTreeComponent` (on which this decorator is running), which is
    passed to the node as a variable named `OwnerComp`. However, to use `BlackboardComponent`,
    we need to include its definition in our `.cpp` file, with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If, for some reason, this `BlackboardComponen**t**` is invalid (this might
    happen if you create a Behavior Tree in your Project but you have no Blackboards;
    otherwise this is difficult to do, since the Behavior Tree editor automatically
    picks a Blackboard), we can just `return false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to retrieve and return the value, as a Boolean, from our *Blackboard
    Key Selector* variable. This is how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the whole function should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your code and the *Decorator* will be ready. If you wish, you can place
    it somewhere in a Behavior Tree to see if the inputs show up properly. This is
    how it appears on the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/422eb950-b1dd-4b45-9463-869ff7ef2fc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The *Details Panel* of the *Decorator* (within the *Behavior Tree Editor*)
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8de3bb38-097b-4ba6-acfe-048188582fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: As you may have noticed, the description of our Decorator doesn't change based
    on which variable we put into it, nor does it have an icon. If you are working
    on a large project, paying attention to these details might help you and your
    team greatly. In this small example, I will leave this as an exercise. You can
    consult [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml), *Agent Awareness*,
    for more information on how to do it. You can also consult the source code, in
    particular, `BTDecorator_TimeLimit`, which implements functions such as `GetStaticDescription()`,
    `DescribeRuntimeValues()`, and `GetNodeIconName()`. In this section, we are going
    to implement the `**GetStaticDescription()**` function so that you can get used
    to implementing these kinds of functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't read the preceding tip box, do so. Now, we are going to implement
    the `GetStaticDescription()` function for our Decorator so that we can see which
    Blackboard key has been selected for the `BoolVariableToCheck` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to add the following override to the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can implement it by returning an `FString` that has been formatted
    with the `Printf()` function. By using a `***?***` statement, we can determine
    whether the Key has been set or not and show the right string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and add the decorator to the *Behavior Tree*, this is what it
    should look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fa4cbce-e87b-414b-8b45-283ee4a83644.png)'
  prefs: []
  type: TYPE_IMG
- en: Much better! Now, it's time to implement a *Behavior Tree Task*.
  prefs: []
  type: TYPE_NORMAL
- en: Task – Find Random Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"*The agent checks whether it has the player in sight. If it is true, then
    it chases the player until he/she is no longer in sight. If the player is not
    in sight, then the agent goes to the last location where it saw the player (if
    the location is known). Otherwise, **the agent chooses a random location around
    it** and goes to that location.*"'
  prefs: []
  type: TYPE_NORMAL
- en: During our Behavior, the agent selects a random location around it. This means
    that we need to create a Task that, starting from the current location of the
    agent, picks a random location that it will go to. Moreover, we should add that
    this location needs to be reachable by the agent. Thankfully, we have some pre-made
    functions to query the *Navigation Mesh* and select a *Random Location* for us.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that we need to assume that we have a *Navigation Mesh* available
    for our agent. Since this is the case, we can use this node. However, we still
    need to create a Task that can be executed in the Behavior Tree, and that stores
    this value properly somewhere in the *Blackboard*.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking like a general node, we would like to add some additional options so
    that we can customize the behavior. For instance, how far away would we like this
    Random Location could be?
  prefs: []
  type: TYPE_NORMAL
- en: We have two input variables. The first is a Blackboard Key Selector that holds
    the Random Location we want to go to (since we need to save it in the Blackboard).
    The second will be just a float indicating the maximum Radius of where this Random
    Location can be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we will do this process both in Blueprint and C++ (so you can choose
    the implementation you are the most comfortable with).
  prefs: []
  type: TYPE_NORMAL
- en: Find Random Location Blueprint implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a *Blueprint Behavior Tree Task* (read the previous chapter to learn
    how to do this) and name it `BTT_FindRandomLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the two variables we need, one of the Blackboard Key Selector type named
    "**RandomDestination**" and the other one of the *float* type named "**Radius**".
    For the float, set a *default value different from zero*, for example, **3,000**.
    Finally, make them both *public*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a468655a-fa71-456f-889c-251fbc347ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s implement/override the Receive Execute AI event, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/213ae0da-f314-4ce1-8ec8-a6798e9bf7ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the event, we can retrieve the ***Controller Pawn*** actor (the agent)
    from which we can get its location, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c186e44a-50d1-4ead-9fba-8f9c044a075f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can use the GetRandomReachablePointInRadius node to generate a random
    reachable location within the *NavMesh*. We need to use as *Location* as the *Origin*
    from the Controlled Pawn (the agent), and ***Radius*** as our ***Radius** variable*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed4b6c2d-d15c-4e60-b65c-2c183b5d1c06.png)'
  prefs: []
  type: TYPE_IMG
- en: Find Random Location Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'From the return value of the GetRandomReachablePointInRadius node, we create
    a Branch node. However, the call to generate the random location can fail. If
    it does, we need to terminate the task with an *insuccess (not Success)*. From
    the **Branch True** pin, we can set the **Random Location** in our **Destination
    Key** variable, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36d272b2-4c18-4306-a5ec-eb1a34081192.png)'
  prefs: []
  type: TYPE_IMG
- en: Find Random Location Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, regardless of the **Branch** (from both the end of the **Set Blackboard
    Value as Vector** node and from the **False** pin of the **Branch**), we need
    to **Finish Execute** the task. To do this, we can plug the return value of the
    ***GetRandomReachablePointInRadius*** node into the **Success** pin of the **Finish
    Execute**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9895ca1-6178-4528-b5a6-dfc26b666c29.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes our task, which we can now save.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we place this node in a *Behavior Tree*, this is what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f18433ed-d3ef-404c-b4a6-b47f94fa3ce1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The *Details Panel* will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7e5ce98-e3df-4d62-bac7-c5f57941f576.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want, you can read the next section to learn how to implement this task
    in C++, otherwise, you are free to skip the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Find Random Location C++ implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the Find Random Location task in C++ will be a bit more complicated
    than creating the Decorator, since we need to retrieve many components and check
    if they are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a C++ **Behavior Tree Task** that inherits from **UBTTaskNode** by
    selecting BTTaskNode as the class you want to extend, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/839a566c-bd87-4113-8832-6fc2e2886660.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can name it `BTTaskNode_FindRandomLocation` and place it (as we did
    for the Decorator) inside a folder, such as `AI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02f6f9e1-cdc7-4e23-bb65-49e540d8c474.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First of all, in the header file, we need to add our two variables. The first
    one is the *Blackboard Key Selector* named `DestinationVector`, which will hold
    the reference to the newly calculated Destination. The second is a *float* containing
    a parametrization of the ***Radius*** (in which we will select a Random Reachable
    Point). Moreover, both of them need to be accessible to the *Behavior Tree Editor*;
    hence we need to expose them by using the `UPROPERTY()` macro. We need to use
    the following lines of code for these two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, in the header file, we need to override the `ExecuteTask()` method,
    which will be called when this task needs to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the whole header file should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, that we are getting to our `.cpp` file, we need to do some preparation,
    especially in the `include` statements. In fact, we are going to use the **Blackboard
    Component** (like we did for the Decorator), the **Navigation System**, and the
    **AI Controller **classes. Thus, we need to include all of them, which we can
    do by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s define the `ExecuteTask()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to start filling up the `ExecuteTask()` function. The first thing
    we need to do is get the **Blackboard Component**. In case this component is not
    available (as explained in the *D**ecorator* section, this seldom happens, but
    it still might), we need to return that the Task has failed, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From the Blackboard Component, we can retrieve the ***Controlled Pawn*** of
    the AI Controller that is running this instance of the *Behavior Tree*. This can
    be done by using a couple of GET functions. However, once again, the *Pawn* needs
    to be checked for its validity, and in case it isn''t valid, then the tasks need
    to return a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to get our Navigation System. As per Unreal 4.21, we will use
    the `UNavigationSystemV1` class to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Unreal 4.20, the Navigation System has been refactored. Therefore,
    many functions and classes became deprecated. If the version of your Engine is
    below 4.20, this code will not work. In this case, you will need to use the `UNavigationSystem`
    class. This isn't covered in this book since it may only be of interest to a few
    readers with specific needs of using an old version of the engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the **Current Navigation System**, we need to specify the **World**
    from which we want to retrieve this data by using a specific function named `GetCurrent()`
    (referring to the Navigation System). Once we have obtained the Navigation System,
    we want to check its validity, and in case it isn''t valid, then we make the Task
    fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one more step to go before we can perform the query on the Navigation
    System. We need to create a variable of the `FNavLocation` type named `Result`,
    which is a structure that our **Navigation System** will fill with the result
    of our query. In our case, we are only interested in the Location. As a result,
    the **Navigation System** is able to perform the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The request to the Query can be done by using the `GetRandomReachablePointInRadius()`
    function. It has three mandatory parameters, which are the ***Origin*** from where
    this query needs to be performed, the **Radius**, and the Structure to return
    the result. In fact, its pure return value is a *boolean* that indicates if the
    query has succeeded or not, which we can use to check whether the task has failed
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In case we were able to get a random point, we need to assign it within the
    blackboard and return that the task has succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you try to compile this right now, you will get an error. The reason for
    this is that we have been using the **Navigation System**, but it was not included
    in the public dependencies of our module. Also, if you didn't include `AIModule`
    and `GameplayTasks`, this is the right moment to add them so that you can compile
    the code without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `BehaviourTreeDesign.Build.cs` file and add the `NavigationSystem`
    module to the public dependencies, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can compile without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add this *Task* node to our *Behavior Tree*, this is what it will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f133e894-985e-4ac6-a049-b7d18ac6e2cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The *Details Panel* looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e75a182b-6372-4420-98a0-e7fa37f5398c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we discussed earlier for the Decorator, it is always good practice to implement
    the functions that describe the node so that we can use it easier. I understand
    that we might not have an icon ready, but at least we can change the description
    to show which variables we have assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to implement/override the `GetStaticDescription()` function.
    Declare it in the header file by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `.cpp` file, we need to return a `FString` that has been formatted
    to show the variables of the Task. In particular, we want to show the `DestinationKey`
    and how big the ***Radius*** is. We can easily format the string with the `Printf()`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and add this *Task* again to a *Behavior Tree*, this is how it
    should appear now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed04c8ee-fde0-494c-83e3-195571c7af7c.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes the implementation of our Task in C++.
  prefs: []
  type: TYPE_NORMAL
- en: AI Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the *Expected Behavior*, we have concluded that we need a *Perception System*
    to check whether the agent is able to see the *Player*.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we can create our AI Controller both in Blueprint or C++.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the AI Controller in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, create a new AI Controller and name it `BP_ChasingAIController` by
    selecting the `AIController` *Class*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab550be6-e01b-42e0-980d-12cdc944bffb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the editor, we need to add two variables (so that the Service we build in
    the next chapter will be able to retrieve the values within them). The first variable
    is `LastKnownPlayerPosition` of type *Vector*, and the second is `CanSeePlayer`
    of type *boolean*, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c66c5402-6d59-46b8-9a7f-faad17982be6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to add the perception component. So, from the Components tab,
    add the AIPerception system, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4432dd0-12ca-44cc-ae92-89fd853c7858.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the Details panel, we need to select the options for it. In particular,
    we need to set the ***Sense of Sight***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a347cbce-dbf7-443a-88f3-71123ec866ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in the **Sense Of Sight Config** settings, check all the detection flags
    (as we explained in [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml), *Agent
    Awareness*, we need to detect the player, which by default is neutral). In the
    end, this is what the settings should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30a5a1fd-dfe5-4759-9a1e-e0a1d210da94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Details panel, we need to generate the On Target Perception Updated
    event by clicking on the + symbol next to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e405f13-77bc-4be9-afe6-fbd220440243.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we cast the **Actor** pin from the event into our player (for example, `FirstPersonCharacter`
    or `ThirdPersonCharacter`, depending which template you choose, or your *Player
    class* if you are using this in your project), to check if the object of the perception
    is actually the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb1ce399-58af-4be4-9762-64fc8b6b3a5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we break the **Stimulus** pin to get the **Stimulus Location**, which
    we store inside the **LastKnownPlayerPosition** variable, and **Successfully Sensed**,
    which we store inside the ***CanSeePlayer*** variable. Of course, these Set functions
    need to be placed after the cast. This is the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1764676-a86c-4155-9f82-3be7b25e148d.png)'
  prefs: []
  type: TYPE_IMG
- en: The ***AI Controller*** is now ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the AI Controller in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, create a new class that inherits from `AIController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4597ce4-e182-428c-83b9-3b6d54550a0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, name it `ChasingAIController` and place it in our `AI` folder, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9513b1a-fed0-46f3-a42e-90ad4c67cfdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we explained in the Chapter about the *Perception*, we first need to include
    the classes that concern the perception to be able to use them. Add the following
    `#include` statements in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the declaration of our ***Class Constructor***, since
    we will be using one to set up our controller. Just below the `GENERATE_BODY()`
    macro, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to keep track of the `PerceptionComponent` that we will add to the
    controller. However, the AI Controller base class, has already a reference to
    a Perception Component, so we don''t need to declare it. You will find this very
    signature in the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we need to have a reference to the *Sight Configuration* that we will
    create, so we need this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since in the next chapter we will create a service that will gather some variables
    from this controller, we need to make two public variables. The first variable
    is the `LastKnownPlayerPosition` of type Vector, and the second is `CanSeePlayer`
    of type boolean. You can add them in the header with the following snippet of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our header file, we need to **add a delegate** for our Perception
    System that will update our variables. We can call this delegate `OnTargetPerceptionUpdated()`
    and make it protected. It has `AActor*` and `FAIStimuli` as inputs, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create the **Perception Component** in the **Constructor**
    of the class. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create the *Sight Sense*, and configure it to set all the
    `DetectionByAffiliation` to true, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have `PerceptionComponent` and `SightConfig`, we need to assign
    the latter to the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to ***bind our delegate*** function to the **Perception System**,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to implement our `OnTargetPerceptionUpdate()` Delegate. First
    of all, we need to include the header file of our Player class. In this example
    case, we have a C++ class named `BehaviorTreeDesignCharacter` (the Blueprint `ThirdPersonCharacter`
    inherits from this class). In my case, I added the following #`include` statement
    (you can include the one of your Player class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, we need to check if the Actor (passed as input) is really the
    *Player* class, which we can do with a cast (to the Player class we have included):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is the case, we can use the ***Stimulus*** input to retrieve the `StimulusLocation` if
    it `WasSuccessfullySensed` and assign it to our `LastKnownPlayerPosition` and
    `CanSeePlayer` variables, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The AI Controller is now ready to be used!
  prefs: []
  type: TYPE_NORMAL
- en: Using the AI Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of whether you used a Blueprint or C++ implementation, you need to
    assign the controller to your Chasing Agent. Whether you do so directly in the
    blueprint, or directly in the instanced version of the game, under the Pawn settings,
    you need to change the AI Controller so that it's the one we just created. We
    also need to ensure that the AI is able to auto-posses this pawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/517ef3f9-0354-4e9b-b043-728261e5817c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have (almost) all the pieces to build our Chasing agent.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to look at our in-depth example of how to create
    a ***Behavior Tree***, and have used all of the systems we have encountered so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we have seen how we can write down the ***Expected Behavior***
    and work from there to gather all the different pieces that we need to build our
    AI. We have seen how we can do this in both C++ and Blueprint. The pieces we have
    created were a ***Custom Decorator***, to check *boolean* variables in our **Behavior
    Tree**,a**Custom Task**, to find a random location by using the **Navigation System**,
    and a **Custom AI Controller** so that we can use the **Perception System** to
    sense the **Player**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with this example and build the last piece
    we need so that we can update the variables for the Chasing Behavior. At the end
    of the next chapter, you will be ready to build the Behavior Tree. So, let's move
    on!
  prefs: []
  type: TYPE_NORMAL
