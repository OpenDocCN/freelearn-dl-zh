<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Environment Querying System</h1>
                </header>
            
            <article>
                
<p><em>A good leader knows which place is good, and EQS knows better!</em></p>
<p>Welcome to <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>,<em> Environment Querying System</em>. In this chapter, we are going to use a specific, yet very powerful, system within the Unreal AI Framework. I'm talking about the <strong>Environment Querying System</strong> (<strong>EQS)</strong>. We will explore the system and will understand not only how it works, but how to use it effectively in our games.</p>
<p>Once again, <strong>EQS</strong> falls into the realm of <em>Decision-Making</em>, and, in particular, evaluating which is the best place (or actor, in the context of Unreal) to satisfy certain conditions. We will see how it works in detail through this chapter, but as an anticipation of what we will cover, know that the system filters offer different possibilities, and the remaining ones assign a score. The choice that has the highest score is selected.</p>
<p>In particular, we will cover the following topics:</p>
<ul>
<li>How to enable the <strong><em>Environment Querying System (EQS)</em></strong></li>
<li>Understanding <strong><em>how EQS works</em></strong></li>
<li>Learning about <strong><em>Generators</em></strong>, <strong><em>Tests</em></strong>, and <strong><em>Contexts</em></strong></li>
<li>Exploring the <strong><em>built-in</em></strong> <span><strong><em>Generators</em></strong>, <strong><em>Tests</em></strong>, and <strong><em>Contexts</em></strong> </span>of <em>EQS</em></li>
<li><strong><em>Extending EQS</em></strong> with custom <span><strong><em>Generators</em></strong>, <strong><em>Tests</em></strong>, and <strong><em>Contexts</em></strong></span></li>
</ul>
<p>So, let's dive in!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling the Environment Querying System</h1>
                </header>
            
            <article>
                
<p>EQS is a feature that was introduced way back to Unreal 4.7, and improved a lot in 4.9. However, in version 4.22, EQS is listed as an experimental feature, despite it being successfully used in many games, thus revealing that EQS is robust.</p>
<p>As a result, we need to enable it from the <strong><em>Experimental</em></strong> features settings. From the top menu, go to <strong>Edit | Editor Preferences…</strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d334f93a-4611-4928-a184-4d699ff1980e.png"/></p>
<div class="packt_infobox">Be careful that you don't get confused with the <strong><em>Project Settings</em></strong>. From the top menu, above the <em>Viewport</em>, you only have access to the <strong><em>Project Settings</em></strong>. However, from the top menu of the whole editor, you will be able to find <strong><em>Editor Preferences</em></strong>. The preceding screenshot should help you locate the right menu (that is, the <strong><em>Edit</em></strong> drop-down menu).</div>
<p>From the lateral menu, you will be able to see a section named <strong>Experimental</strong> (under the <strong>General</strong> category), as highlighted in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b61d381-c4a3-4774-8cee-36df15cc7742.png"/></p>
<p>If you scroll down through the settings, you will find the AI category, in which you are able to enable the <strong>Environment Querying System</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9fb7d9b6-2cbe-4fed-936b-16a679f72e08.png"/></p>
<p>Check the box next to this option and, as a result, the <strong><em>Environment <span>Querying </span>System</em></strong> will be activated in the whole project. Now, you will be able to create assets for it (as well as extend it) and call it from a <em>Behavior Tree</em>.</p>
<div class="packt_infobox">In case you are unable to see the <strong><em>Environment Querying System</em></strong> checkbox within the <strong><em>AI category</em></strong>, it's likely you are using a recent version of the engine in which (finally) <strong><em>EQS</em></strong> is not experimental anymore, and so it is always enabled within your project. If this is your situation, then skip this section and move on to the next one. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the Environment Querying System</h1>
                </header>
            
            <article>
                
<div>
<p>When people face EQS for the first time, it might seem <span><span>overwhelming</span></span>, especially because it is unclear how the different parts of the system work and why. The aim of this section is to improve your understanding of the system by getting you familiar with the underlying workflow of EQS, which will help you with the actual workflow when you create a query.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The general mechanism of EQS</h1>
                </header>
            
            <article>
                
<div>
<p>Imagine that, at a certain point, our AI agent is under fire, and it needs to evaluate different places for cover. One place might be far but well protected, whereas another one might be very close but not well protected. What should we do?</p>
<p>One way to solve this problem is by using <strong><em>Utility Functions</em></strong> and solving equations in time (we will discuss them in more detail in <a href="d9a581ce-adca-46fe-8f95-a78b762ebc46.xhtml">Chapter 14</a>, <em>Going Beyond</em>). Actually, this produces very good results, and it is successfully implemented in many games. However, Unreal offers another possibility: EQS. This being said, it's not mandatory to use EQS instead of utility functions, but EQS as part of the AI framework makes it easy to evaluate such decisions since it is a built-in system.</p>
<p>So, coming back to our agent in need of a cover, a <em>Behavior Tree</em> will run an EQS query, which will give the final result of the place where the agent should get cover. Now, how does an Environment Query work?</p>
<p>First of all, a component (called a Generator, which we will look at in a moment) will generate a series of locations (or agents, which we will look at later in this chapter) according to some criteria specified in the Tests (we will get to them in a moment). For instance, we can take different positions on a uniform grid, which is very handy when we don't know which kind of locations we are searching for in advance (before evaluation).</p>
<p>Then, there is a filtering process for possible locations (or actors), in which it eliminates all that do not satisfy a certain criteria. In our cover example, any place that is still exposed to direct fire should be discarded.</p>
<p>The remaining places are evaluated (the system assigns them a score), based on other criteria. Again, in our cover example, this might be the distance from the agent, how much cover they offer, or how close to the enemy the place is. The system assigns a score by taking into consideration all of these factors (and, of course, some will be weighted more than others; e.g. protection from fire might be more important than the distance from the enemy's location).</p>
<p>Finally, the location (or actor) with the highest score is given from the query to the <em>Behavior Tree</em>, which will decide what to do with it (e.g. flee quickly to that place to take cover).</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The components of an Environment Query</h1>
                </header>
            
            <article>
                
<p>Based on the mechanism we described in the previous section, let's dig deeper into how the actual implementation of the EQS in Unreal works.</p>
<p>At a high level, we have <em>Environment Queries</em>, <em>Contexts</em>, <em>Generators</em>, and <em>Tests</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environment Queries</h1>
                </header>
            
            <article>
                
<p>As the name suggests, an <em><strong>Environment Query</strong></em> is a data structure (similar to a <em>Behavior Tree</em>) that holds information regarding how the query should be performed. In fact, it is an asset that you can create and find within your <em>Content Browser</em>.</p>
<p>You can create a new <strong>Environment Query</strong> by right-clicking on your <em>Content Browser</em> and then <strong>Artificial Intelligence</strong> | <strong>Environment Queries</strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d7e443b8-9e49-4002-8511-5102cdc30e9f.png" style="width:26.67em;height:45.17em;"/></p>
<div class="packt_infobox">Keep in mind that this option will not appear if EQS is not enabled. </div>
<p>This is what it looks like in the <em>Content Browser</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a6a37b70-daed-4aab-9fe2-3267aad501f9.png" style="width:38.17em;height:16.33em;"/></p>
<p>If we double-click on it to open it, Unreal opens a specific and <strong>dedicated editor</strong> for <strong><em>Environmental Queries</em></strong>. This is what the Editor looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2cbf0931-5fd1-43c4-bc34-f1dc9329ae7a.png" style="width:56.08em;height:30.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Editor view</div>
<p>As you can see, it is very similar to a <em>Behavior Tree</em>, but you can only attach a Generator node to the <strong><em>Root</em></strong> node (only one), which results to be a leaf as well. Therefore, the whole "<em>tree</em>" will be just the <strong><em>Root</em></strong> node with a <strong><em>Generator</em></strong>. In fact, by using a <em>Behavior Tree</em>-like editor, you can easily set up an <strong><em>Environmental Query</em></strong>. On the (unique) <em>Generator</em> node, you can attach one or more <strong><em>Tests</em></strong><em>—</em>either the Generator itself, or Contexts. Here is an example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3d258634-8313-4eec-862d-2092550e4dfb.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Editor view</div>
<p>We will understand what this means in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Contexts</h1>
                </header>
            
            <article>
                
<p>Contexts are children of a particular and handy class that retrieves information. You can create/extend a <strong><em>Context</em></strong> either through Blueprint or by using C++.</p>
<p>The reason why they are called contexts is because they provide a context to either a Generator or to a Test. By having a context, the Generator (or the Test) is able to perform all the calculations, starting from that point. If you prefer, a context can be thought of as a special (and very articulated) variable that is able to procedurally pass a set of interesting Actors and/or locations.</p>
<p>Let's look at an example so that we're clear about what <strong><em>Contexts</em></strong> are. While performing a <em>Test</em>, you usually know where the <strong><em>Querier</em></strong> (e.g. the agent who needs the cover) is located (under the hood, even if the <em>Querier</em> is a default context). However, our test might need the location of our enemies (e.g. to check whether a cover spot is under fire or not, since it depends on the position of the enemies of our agent). <strong><em>Contexts</em></strong> can provide all of this information, and can do so in a procedural way: for instance, the agent might not be aware of every enemy of the map, so the <strong><em>Context</em></strong> might return only the enemies that the agent is currently aware of, so it only finds cover from those. Therefore, if there is a hidden enemy where it's chose to take cover, then it's tough luck for our agent!</p>
<p>Understanding <strong><em>Contexts</em></strong> is not easy, so stick through this chapter, and maybe re-read the previous paragraph at the end, when you have a better idea of what Generators and Tests are, as well as how to build an <strong><em>EQS</em></strong> in our project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generators</h1>
                </header>
            
            <article>
                
<p><strong><em>Generators</em></strong>, as the name suggests, generate an initial set (or array) of locations (or actors). This set will be filtered and evaluated by Tests.</p>
<p>The way to generate the initial set is completely free. If you have some important information regarding the place you are looking for before the evaluation stage, then you can create a custom <strong><em>Generator</em></strong> (for example, don't check places with water if the agent is unable to swim, or don't consider flying enemies if the only available attack is melee).</p>
<p>Like <em>Contexts</em>, <strong><em>Generators</em></strong> are children of a specific class. You can create Generators in Blueprint as well as in C++. </p>
<div class="packt_infobox">Usually, the most used generator is the grid one, which will generate a uniform grid around a context (e.g. around the agent). By doing this, the agent will check more or less all of its surroundings.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tests</h1>
                </header>
            
            <article>
                
<p><strong><em>Tests</em></strong> are responsible to both <strong><em>Filtering</em></strong> and <em><strong>Assigning a Score</strong> (Evaluating)</em> to the different locations (or actors) that are generated by the <em>Generator</em>. A single <strong><em>Test</em></strong> can filter and score on the same criteria, as well as just one of the two.</p>
<p>In the case of <em>Tests</em> that use <strong><em>Filtering</em></strong>, they try to identify which locations (or Actors) are not suitable for our criteria. EQS is optimized, so it performs the <em>Tests</em> in a specific order to try and detect unsuitable places early on. It does this so that it doesn't assign a score that won't be used.</p>
<p>Once all of the locations (or Actors) have been filtered out, the remaining ones are evaluated. Thus, <strong><em>each Test</em></strong> that <strong><em>is able to assign a score</em></strong> is called (<em>executed</em>) on the location (or Actor) to report the evaluation in the form of a score (which can be positive or negative).</p>
<p>As a side note, <em>Tests</em> need (at least) a <em>Context</em> to properly <em>filter</em> and <em>evaluate</em>.</p>
<p>Let's look at an easy example of a Test to understand how they work. One of the most common Tests is <strong><em>Distance</em></strong>, that is, how far is this place (the generated we are evaluating) from a <strong><em>Context</em></strong>? The <em>Context</em> can be the <em>Querier</em>, or the enemy that it is attacking, or anything else. Thus, we can (for instance) filter places above or below a certain distance threshold (e.g. we might not want perfect cover places if they are too far from the Player). The <strong>same</strong> <em><strong>Distance Test</strong></em> can assign a score, depending on the distance, which can be positive (or negative) if the context is far (or close).</p>
<p>Moreover, a <strong>Test</strong> has a <strong>Scoring Factor</strong> that represents <strong>the weight</strong> of the <strong><em>Test</em></strong>: how important the Test is, and much influence this <strong><em>Test</em></strong> needs to have when calculating the final score of the currently evaluated location (or actor). In fact, you will run many different <strong><em>Tests</em></strong> on the locations that are generated by the <em>Generator</em>. The <strong><em>Scoring Factor</em></strong> allows you to easily weigh them to determine which Test has a higher impact on the final score of the location (or actor).</p>
<p>Each <em>Test</em> has the following structure for its options in the <em>Details</em> panel:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e599ab6f-505a-4846-9744-bf41714e4613.png" style="width:37.33em;height:44.17em;"/></p>
<ul>
<li><strong><em>Test</em></strong>: Here, you can select whether the<span> </span><strong><em>Test Purpose</em></strong><span> </span>is to<span> </span><strong><em>Filter and Score</em></strong>, or just one of the two, and add a description (has no impact on the Test, but you can see it as a comment to recall what this test was about). Additionally, there might be other options, such as<span> </span><em>Projection Data</em><span> </span>that you can use with the<span> </span><em>Navigation System</em><span> </span>(for those tests that rely on the<span> </span><em>Navigation System</em>).</li>
<li><strong><em>Specific Test</em></strong>: This is the place where the specific options for the Test are held. This varies from test to test.</li>
<li><strong><em>Filter</em></strong>: Here, you can select how the<span> </span><em>Filter</em><span> </span>behaves. This varies from test to test, but usually you are able to select a<span> </span><strong><em>Filter Type</em></strong>, which can be a<span> </span><em>range</em><span> </span>(or<span> </span><em>minimum</em><span> </span>or<span> </span><em>maximum</em>) in case the tests valuate a float as a return value; otherwise, it can be a <em>boolean</em><span> </span>in the case of conditional<span> </span><em>Tests</em>. This tab doesn't appear if the<span> </span><strong><em>Test Purpose</em></strong><span> </span>is set to<span> </span><strong><em>Score Only</em></strong>.</li>
<li><strong><em>Score</em></strong>: Here, you can select how the<span> </span><em>Scoring</em><span> </span>behaves. This varies from test to test. For float return types from tests, you can select an equation for scoring, along with a normalization. Moreover, there is<span> </span><strong><em>Scoring Factor</em></strong>, which is the weight of this test compared to the others. For boolean return values, there is just the Scoring Factor. <span>This tab doesn't appear if the </span><strong><em>Test Purpose</em></strong><span> is set to </span><strong><em>Filter Only</em></strong><span>.</span></li>
<li><strong><em>Preview</em></strong>: This gives you a preview of what the filter and scoring function look like.</li>
</ul>
<p>As you can see, these options are very easy to grasp, and you will understand them even better if you practice with EQS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual representation of the components</h1>
                </header>
            
            <article>
                
<p>These components might not be super intuitive at the beginning, but once you get used to EQS, you will realize how they make sense, and why the system has been designed in this way.</p>
<p>To summarize the components and their importance, as well as to give you a visual representation, here is a diagram that you can reference:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc428801-f5bd-46f6-9137-56b3409f4f24.png" style="width:59.25em;height:36.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running an Environmental Query within a Behavior Tree</h1>
                </header>
            
            <article>
                
<p>Finally, the last step to fully understanding how an <strong><em>Environmental Query</em></strong> works is to see how it can be run within a <em>Behavior Tree</em>.</p>
<p>Thankfully, we have a node named run EQS, which is a built-in Behavior Tree Task. In looks as follows in a hypothetical <em>Behavior Tree Editor</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ce511ffd-e992-4020-b55c-c093cd4f23d0.png" style="width:10.67em;height:7.00em;"/></p>
<p>The possible settings, which can be found in the <span class="packt_screen">Details</span> panel, are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d46b7e4-59f3-44cb-9ffa-a194307f9806.png" style="width:35.75em;height:49.83em;"/></p>
<p>As you can see, many are deprecated (so just ignore them), but I have highlighted the ones that are the most important. Here's an explanation of them:</p>
<ul>
<li><strong><em>Blackboard Key</em></strong>: This is the Blackboard Key Selector that references a <em>Blackboard Variable</em>, in which the result of the EQS will be stored.</li>
<li><strong><em>Query Template</em></strong>: A specific reference to the EQS we want to run. Otherwise, we can deactivate this option to activate an <em>EQSQuery Blackboard Key</em>.</li>
<li><strong><em>Query Config</em></strong>: These are optional parameters for the query (unfortunately, we won't be looking at them in detail in this book).</li>
<li><strong><em>EQSQuery Blackboard Key</em></strong>: A <em>Blackboard Key Selector</em> that references a <em>Blackboard Variable</em> containing an <em>EQS</em>. If activated, the <em>EQSQuery</em> contained in the <em>Blackboard Variable</em> will be executed, and not the <em>Query Template</em> one.</li>
<li><strong><em>Run Mode</em></strong>: This shows results of the query we are going to retrieve. The possible options are as follows:
<ul>
<li><strong><em>Single Best Item</em></strong>: This retrieves the point (or actor) that scored the best</li>
<li><strong><em>Single Random Item from Best 5%</em></strong>: This retrieves a random point among the best 5% scoring locations (or actors)</li>
<li><span><strong><em>Single Random Item from Best 25%</em></strong>: This retrieves a random point among the best 25% scoring locations (or actors)</span></li>
<li><strong><em>All Matching</em></strong>: This retrieves all the locations (or actors) that match the query (they haven't been filtered out)</li>
</ul>
</li>
</ul>
<p>This concludes how we can run an EQS and retrieve its result so that it can be used within a <em>Behavior Tree</em>.</p>
<div class="packt_infobox">Of course, there are other ways to trigger an EQSQuery, which are not necessarily done within a <em>Behavior Tree</em>, even though this is the most common use of the EQS. Unfortunately, we will not cover other methods to run an EQSQuery in this book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Not only Locations, but also Actors!</h1>
                </header>
            
            <article>
                
<p>I emphasised a lot when I said "…evaluating a location <strong>(or Actor)…</strong> ".</p>
<p>In fact, one of the coolest features of EQS is the possibility to evaluate not only locations, but actors as well!</p>
<p>Once again, you can use EQS as a decision-making process. Imagine that you need to choose an enemy to attack first. You might want to take into consideration various parameters, such as the remaining life of that enemy, how strong it is, and how much it is considered a threat in the immediate future.</p>
<p>By carefully setting an EQS, you are able to assign a score to each of the enemies, depending on which one is the most convenient to attack. Of course, in this situation, you might need to put in a little bit of work to create the proper Generator, along with Contexts and the proper Tests, but in the long run, it makes EQS a very good choice when the agent needs to make these kinds of decisions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the built-in nodes</h1>
                </header>
            
            <article>
                
<p>Before we create our own Generators, Contexts, and Tests, let's talk about built-in nodes. Unreal comes with a handful of useful built-in, general-purpose nodes. We are going to explore them in this section.</p>
<div class="packt_infobox">Keep in mind that this section is going to analytically explain how each of the built-in nodes of EQS works, like documentation would. So, please use this section as a reference manual if you wish, and skip sections if you are not interested in them.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Built-in Contexts</h1>
                </header>
            
            <article>
                
<p>Since we started explaining EQS by looking at <strong><em>Contexts</em></strong>, let's start from <strong><em>built-in Contexts</em></strong>. Of course, making general-purpose <strong><em>Contexts</em></strong> is almost a paradox, since a Context is very specific to the "<em>context</em>" (situation).</p>
<p>However, Unreal comes with two built-in Contexts:</p>
<ul>
<li><strong><em>EnvQueryContext_Querier</em></strong>: This represents the Pawn that is asking the query (to be precise, it isn't the Pawn asking the Query, but the Controller that is running the <em>Behavior Tree</em> that is asking the query, and this context returns the controlled Pawn). Therefore, by using this <em>Context</em>, everything will be relative to the <strong><em><span>Querier</span></em></strong>.</li>
</ul>
<div class="packt_infobox">As I mentioned previously, under the hood, the <em>Querier</em> is indeed a <em>Context</em>.</div>
<ul>
<li><strong><em>EnvQueryContext_Item</em></strong>: This returns all the locations that are generated by the <em>Generator</em>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Built-in Generators</h1>
                </header>
            
            <article>
                
<p>There are many built-in <strong><em>Generators</em></strong>, and most of the time, these will be more than enough so that you can do most of the EQS you want. You would use <em>custom Generators</em> only when you have a specific need, or when you want to optimize the EQS.</p>
<p>Most of these Generators are intuitive, so I'm going to explain them in brief, and provide (when necessary) a screenshot showing the kinds of points they are generating.</p>
<div class="packt_infobox"><span>The following screenshots use a special Pawn that is able to visualize an Environment Query. We will learn how to use it later in this chapter.</span></div>
<p>This is the list of available built-in <em>Generators</em>, as you find them in the <em>Environmental Query Editor:</em></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/edb9da7a-0421-4960-8348-5aa622a5ad9a.png" style="width:11.83em;height:15.08em;"/></p>
<p>To organize this information, I'm going to split each Generator into a subsection, and I'm going to order them as they are listed in the preceding screenshot (alphabetically).</p>
<div class="packt_infobox">When I refer to the Settings of a Generator, I mean, once a specific Generator has been selected, the available options for it in the <em>Details Panel</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actors Of Class</h1>
                </header>
            
            <article>
                
<p>This Generator takes all of the actors of a specific class and returns all their locations as generated points (if these actors are within a certain radius from the Context).</p>
<p>This is what it looks like in the <em>Environmental Query Editor</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5f859a7-56cb-4651-96ff-1a040c6f90c9.png" style="width:32.67em;height:15.75em;"/></p>
<p>The possible options are the <strong><em>Searched Actor Class</em></strong> (obviously) and the <strong><em>Search Radius</em></strong> from the <strong><em>Search Center</em></strong> (which is expressed as a <em>Context</em>). Optionally, we can retrieve all the actors of a certain class and ignore whether they are within the <em>Searched Radius</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/faecc901-8ef1-44bb-91c9-5692d6029691.png" style="width:39.17em;height:21.08em;"/></p>
<p><span>In the preceding screenshot, I used the <strong><em>Querier</em></strong> as the <strong><em>Search Center</em></strong>, a <strong><em>Search Radius</em></strong> of <strong><em>50000</em></strong>, and the <strong><em>ThirdPersonCharacter</em></strong> as the <strong><em>Searched Actor Class</em></strong>, since it is already available in the project.</span></p>
<p>By using these settings (and placing a couple of <strong><em>ThirdPersonCharacter</em></strong> actors), we have the following situation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/155643e4-46c9-446e-b401-da15ae3a69b0.png"/></p>
<p>Note the (blue) sphere around the three <strong><em>ThirdPersonCharacter</em></strong> actors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Current Location</h1>
                </header>
            
            <article>
                
<p>The <strong><em>Current Location Generator</em></strong> simply retrieve the location(s) from the <em>Context</em> and uses it (or them) to generate the points.</p>
<p>This is what it looks like in the <em>Environmental Query Editor</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c9cdc1ae-401f-4d74-8e9e-e90d526f9702.png" style="width:19.50em;height:19.83em;"/></p>
<p>The only setting that's available for this <em>Generator</em> is <em><strong>Query Context</strong></em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c4794baa-73a6-4354-96b1-b98a86200d66.png" style="width:35.67em;height:14.08em;"/></p>
<p>Thus, if we use the <strong><em>Querier</em></strong> as the <strong><em>Query Context</em></strong>, then we just have the location of the <strong><em>Querier</em></strong> itself, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c4c4a73f-e0e4-43fa-abf4-d89b7c99e9cd.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite</h1>
                </header>
            
            <article>
                
<p>The <strong><em>Composite Generator</em></strong> allows you to mix multiple Generators so that you have a vaster selection of points.</p>
<p><span>This is what it looks like in the </span><em>Environmental Query Editor</em><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/73623a4d-508f-463a-929a-732047b0bd0a.png" style="width:13.33em;height:19.42em;"/></p>
<p>In the <em>Settings</em>, you can set an array of <strong><em>Generators</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b8bf8b82-c8d0-41b7-b04a-2400395aa65f.png" style="width:36.33em;height:18.42em;"/></p>
<p>Since we don't have the time to go through everything in detail, I won't cover this Generator further.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Points: Circle</h1>
                </header>
            
            <article>
                
<p>As the name suggests, the <strong><em>Circle Generator</em></strong> generates the points around a circle of a specified radius. Moreover, options for interacting with the <em>Navmesh</em> are available (so that you don't generate points outside the <em>Navmesh</em>).</p>
<p><span>This is what it looks like in the </span><em>Environmental Query Editor</em><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/084d82ed-9cae-4b91-9422-395d41ed1065.png" style="width:33.58em;height:19.75em;"/></p>
<p>This is a very complex generator, and so there are various settings for this generator. Let's check them out:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c4924b3-3dbc-4821-84c4-b3dccc5964bf.png"/></p>
<div class="packt_infobox">Ideally, it would be great to have a screenshot for each setting so that we can get a better feeling of how each setting affects the generation of the points. Unfortunately, this book already has many screenshots, and dedicating a chapter just to the different settings of these complex generators would take a lot of time and a lot of "<em>book space</em>". However, there is a better way for you to get the same feeling: <strong><em>Experiment yourself!</em></strong> Yes <span>–</span> once you know how to set up the <strong><em>EQSTestingPawn</em></strong>, you can try them out yourself and see how each setting affects the generation process. This is the best way you can learn and really understand all of these settings.</div>
<ul>
<li><strong><em>Circ</em></strong><strong><em>le Radius</em></strong>: As the name suggests, it is the radius of the Circle.</li>
<li><strong><em>Space Between</em></strong>: How much space there should be between each point; if<span> the </span><em>Point On Circle Spacing Method</em><span> is set to </span><em>By Space Between</em><span>.</span></li>
<li><strong><em>Number of Points</em></strong>: How many points should be generated; if the <em>Point On Circle Spacing Method</em> is set to <em>By Number of Points</em>.</li>
<li><strong><em>Point On Circle Spacing Method</em></strong>: Determines if the number of points to be generated should be calculated based on a constant number of points (<strong><em>By Number of Points</em></strong>), or by how many points fits the current circle if the space between the points is fixed (<strong><em>By Space Between</em></strong>).</li>
<li><strong><em>Arc Direction</em></strong>: If we are generating only an arc of the circle, this setting determines the direction this should be in. The method to calculate the direction can be either <strong><em>Two Points</em></strong> (it takes two <em>Contexts</em> and calculate the direction between the two) or <strong><em>Rotation</em></strong> (which takes a <em>Context</em> and retrieve its rotation, and based on that rotation, decides the direction of the Arc).</li>
<li><strong><em>Arc Angle</em></strong>: If this is different from <em>360</em>, it defines the angle of cut where the points stop being generated, thus creating an <em>Arc</em> instead of a circle. The direction (or rotation) of such an <em>Arc</em> is controlled by the <em>Arc Direction</em> parameter. </li>
<li><strong><em>Circle Center</em></strong>: As the name suggests, it is the center of the circle, expressed as a <em>Context</em>.</li>
<li><strong><em>Ignore Any Context Actor when Generating Circle</em></strong>: If checked, it will not consider the actors that are used as Contexts for the circle, thus skipping to generate points in those locations.</li>
<li><strong><em>Circle Center Z Offset</em></strong>: As the name suggests, it is an offset along the z-axis for the <em>Circle Center</em>.</li>
<li><strong><em>Trace Data</em></strong>: When generating the circle, if there is an obstacle, often, we don't want to generate the points behind the obstacle. This parameter determines the rules for doing "<em>horizontal</em>" tracing. These options are as follows:
<ul>
<li><strong><em>None</em></strong>: There will be no trace, and all the generated points will be on the circle (or arc).</li>
<li><strong><em>Navigation</em></strong>: This is the default option. Where the <em>NavMesh</em> ends is where the point is generated, even if the distance from the center is less then the Radius (in some way, the circle assumes the shape of the <em>NavMesh</em> if its boarder is encountered).</li>
<li><strong><em>Geometry</em></strong>: The same as Navigation, but instead of using the <em>NavMesh</em> as a boarder, the tracing will use the Geometry of the level (this might be really useful if you don't have a <em>NavMesh</em>).</li>
<li><strong><em>Navigation Over Ledges</em></strong>: The same as Navigation, but now the trace is "<em>over ledges</em>".</li>
</ul>
</li>
<li><strong><em>Projection Data</em></strong>: This works similarly to Trace Data, but does a "<em>vertical</em>" trace by projecting the points from above. For the rest, the concept is exactly the same as <em>Trace Data</em>. The options are <strong><em>None</em></strong>, <strong><em>Navigation</em></strong>, and <strong><em>Geometry</em></strong>, with the same meaning these assume in <em>Trace Data</em>. "<em>Navigation Over Ledges</em>" isn't present because it wouldn't make any sense.</li>
</ul>
<p>By using the same settings that are shown in the preceding screenshot (I'm using <em>Trace Data</em> with <em>Navigation</em>, and I have a <em>NavMesh</em> in the Level), this is what it looks like (I activated the NavMesh with the <em>P</em> key so you can see that as well):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe7378b5-f5e7-4d35-a7fa-4436dcbb8882.png"/></p>
<p>By using <em>Geometry</em> for <em>Trace Data</em> instead, we obtain a very similar, but slightly different, shape:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/55aa2a78-a5ad-4d86-96c2-b4d818e63cdd.png"/></p>
<div class="packt_infobox">If you have a NavMesh that ends, but not the Geometry of the level, the effect is even clearer.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Points: Cone</h1>
                </header>
            
            <article>
                
<p><span>As the name suggests, the </span><strong><em>Cone Generator</em></strong><span> generates the points in a cone of a specific Context (like a spotlight). Moreover, options to interact with the </span><em>Navmesh</em><span> are available (so that you can project points onto the <em>Navmesh</em></span><span>).</span></p>
<p>It is important to understand that its shape is generated from many circles, from which we always take the same arc. So, if we take the whole circle, we are basically generating the points in the area of a single slice.</p>
<div class="packt_infobox"><span><br/>
This Generator can also be used to generate points to cover the area of an entire circle.</span></div>
<p><span>This is what it looks like in the </span><em>Environmental Query Editor</em><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cf81d358-66fc-410e-9bbd-898cf0a4240f.png" style="width:25.75em;height:20.83em;"/></p>
<p>Its settings are mostly related to the shape of the cone, so let's explore them all:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f25a26ed-5022-43df-96f6-2b70981a2948.png" style="width:36.42em;height:26.58em;"/></p>
<div class="packt_infobox"><span>Once again, it would be ideal to have a screenshot for each combination of settings so that you have a feeling of how each setting affects the generation of points. Because we don't have the space to do so in this book, I encourage you to experiment with an <strong><em>EQSTestingPawn</em></strong> so that you get a clearer understanding.</span></div>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong><em>Aligned Points Distance</em></strong>: This is the distance between each arc of the generated points (the distance between points of the same angle from the center). A smaller value generates more points, and the area that's taken into consideration will be more dense.</li>
<li><strong><em>Cone Degrees</em></strong>: This dictates how big the arc of each circle is (we are taking into consideration how wide the slice is). A value of 360 takes the whole area of the circle into account.</li>
<li><strong><em>Angle Step</em></strong>: This is the distance, expressed in degrees, between the points of the same arc. Smaller values mean <span>more points, and the area taken into consideration will be more dense.</span></li>
<li><strong><em>Range</em></strong>: This determines how far away the cone can be (by using a spotlight as an example, how far it can illuminate).</li>
<li><strong><em>Center Actor</em></strong>: This is the center of the generated circles and is used to determine the cone. It is the center, and is expressed as a <em>Context</em>.</li>
<li><strong><em>Include Context Location</em></strong>: As the name suggests, if checked, a point will also be generated in the center of the cone/circles.</li>
<li><strong><em>Projection Data</em></strong>: This performs <span>a "</span><em>vertical</em><span>" trace, by projecting the points from above by taking into consideration either the Geometry or the <em>Navigation Mesh</em>. In fact, the possible options are </span><strong><em>None</em></strong><span>, </span><strong><em>Navigation</em></strong><span>, and </span><strong><em>Geometry</em></strong><span>.</span></li>
</ul>
</li>
</ul>
<p>By using the default settings, this is what the cone might look in the level:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/95f7be1a-6cd2-46dd-bb31-cded301870c7.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Points: Donut</h1>
                </header>
            
            <article>
                
<p><span>As the name suggests, the </span><strong><em>Donut Generator</em></strong><span> generates the points in a donut shape (or "<em>Annulus</em>", for those of you who are Math lovers), starting from a specific center that's given as a Context. Moreover, various options so that you can interact with the </span><em>Navmesh</em><span> are available (so that you can project points onto the </span><em>Navmesh</em><span>).</span></p>
<div class="packt_infobox">This generator can be used to generate spiral shapes as well. Just like the cone shape, this generator can be used to generate points to cover the area of a whole circle. You can do this by setting its <em>Inner Radius</em> to zero.</div>
<p><span>This is what it looks like in the </span><em>Environmental Query Editor</em><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c1f37474-a43d-4211-abf8-3b52efcd0244.png" style="width:26.50em;height:21.17em;"/></p>
<p>The following settings are available:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/71132786-3332-4f02-a2c5-a6dc68a0c654.png" style="width:35.00em;height:31.33em;"/></p>
<ul>
<li><strong><em>Inner Radius</em></strong>: This is the radius of the "<em>hole</em>" of the donuts; no points will be generated within this radius (thus it's no closer to this value from the <em>Center</em>).</li>
<li><strong><em>Outer Radius</em></strong>: This is the radius of the whole donut; points will be generated in rings between the <em>Inner Radius</em> and the <em>Outer Radius</em>. This also means that no points will be generated beyond this radius (thus, it's further to this value from the <em>Center</em>).</li>
<li><strong><em>Number of Rings</em></strong>: How many rings of points should be generated in-between the <em>Inner Radius</em> and the <em>Outer Radius</em>. These rings are always evenly spaced, which means that their distance is controlled by this variable, along with the <em>Inner Radius</em> and the <em>Outer Radius</em>.</li>
<li><strong><em>Points per Ring</em></strong>: This dictates how many points each generated ring should have. The points are evenly spaced along the ring.</li>
<li><strong><em>Arc Direction</em></strong>: I<span>f we are generating only an arc of the donut (to be precise, only an arc of the circles that will generate the donut), this setting determines the direction this should be in. The method to calculate the direction can be either </span><strong><em>Two Points</em></strong><span> (it takes two </span><em>Contexts</em><span> and calculates the direction between the two) or </span><strong><em>Rotation</em></strong><span> (which takes a </span><em>Context</em><span> and retrieves its rotation, and based on that rotation, decides on the direction of the Arc).</span></li>
<li><strong><em>Arc Angle</em></strong>: If<span> this isn't </span><em>360</em><span>, it defines the angle of cut where the points stop being generated, thus creating an </span><em>Arc</em><span> instead of a circle. The direction (or rotation) of such an </span><em>Arc</em><span> is controlled by the </span><em>Arc Direction</em><span> parameter. </span></li>
<li><strong><em>Use Spiral Pattern</em></strong>: If checked, the points in each ring are slightly offset to generate a spiral pattern.</li>
<li><strong><em>Center</em></strong>: This <span>is the center of the generated rings (as well as the minimum and maximum extensions of the donut specified with <em>Inner Radius</em> and <em>Outer Radius</em>, respectively). It is expressed as a <em>Context</em>.</span></li>
<li><strong><em>Projection Data</em></strong>: This <span>performs </span><span>a "</span><em>vertical</em><span>" trace by projecting the points from above by taking into consideration either the Geometry or the <em>Navigation Mesh</em>. The possible options are </span><strong><em>None</em></strong><span>, </span><strong><em>Navigation</em></strong><span>, and </span><strong><em>Geometry</em></strong><span>.</span></li>
</ul>
<p>To understand these settings, take a look at the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe4cd6af-ed12-474d-9dd0-c3d53ec0f964.png" style="width:40.75em;height:27.75em;"/></p>
<p>By using these slightly modified settings (please note how I increased the <em>Inner Radius</em>, bumped up the <em>Number of Rings</em> and <em>Points per Ring</em>, and also used <em>Navigation</em> for the Projection Data), it is possible to easily visualize the donut. Here are the settings I used:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f3ceb081-525b-4431-a8e5-e8f9b3657b25.png" style="width:37.00em;height:37.92em;"/></p>
<p>This is the result they produced:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/137cd92e-b644-428a-b134-d3dfa19e6202.png"/></p>
<p>By using the same settings, and checking <strong><em>Use Spiral Pattern</em></strong>, you can see how the points in the different rings are slightly offset, creating a spiral pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe410a5b-80a1-4188-8afb-358a1b8b2d48.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Points: Grid</h1>
                </header>
            
            <article>
                
<p><span>As the name suggests, the </span><strong><em>Grid Generator</em></strong><span> generates the points within a Grid. Moreover, options to interact with the </span><em>Navmesh</em><span> are available (so that you don't generate points outside the </span><em>Navmesh</em><span>).</span></p>
<p><span>This is what it looks like in the </span><em>Environmental Query Editor</em><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99e82896-89ce-411a-aece-bbc0a5ccb177.png" style="width:21.92em;height:18.25em;"/></p>
<p>The settings for this generator are quite straightforward:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27e2040f-c1e2-4e34-a45f-b54c2b50808f.png" style="width:31.58em;height:19.17em;"/></p>
<ul>
<li><strong><em>GridHalfSize</em></strong>: How much the grid should extend from its center (which means it is half the size of the full grid). <span>The dimensions of the grid are fully determined by this parameter, along with</span><em>Space Between</em><span>.</span></li>
<li><strong><em>Space Between</em></strong>: How much space there is between each row and column of the grid. The dimensions of the grid are fully determined by this parameter, along with<em>GridHalfSize</em>.</li>
</ul>
<ul>
<li><strong><em>Generate Around</em></strong>: This is the center of the grid (where it starts being generated), and it is expressed as a <em>Context</em>.</li>
<li><strong><em>Projection Data</em></strong>: This <span>performs </span><span>a "</span><em>vertical</em><span>" trace by projecting the points from above. It does this by taking into consideration either the Geometry or the <em>Navigation Mesh</em>. The possible options are </span><strong><em>None</em></strong><span>, </span><strong><em>Navigation</em></strong><span>, and </span><strong><em>Geometry</em></strong><span>.</span></li>
</ul>
<p>By looking at the settings, you can see that this generator is quite simple, yet powerful and very commonly used. With the default settings, this is what it looks like in the level (the projection is enabled at Navmesh, and is present in the map):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4f4cdf46-d051-403a-9ecf-94b8e3486fc3.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Points: Pathing Grid</h1>
                </header>
            
            <article>
                
<p><span>As the name suggests, the <strong><em>Pathing </em></strong></span><strong><em>Grid Generator</em></strong><span> generates the points within a Grid, just like the <em>Grid Generator</em>. However, the difference in this generator lies in the fact that the <strong><em>Pathing Grid Generator</em></strong> check whether the points are reachable by the context specified in the <em><strong>Generate Around</strong></em> setting (usually the Querier), within a specified distance.</span></p>
<p><span>This is what it looks like in the </span><em>Environmental Query Editor</em><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8ebb49ae-79ed-4f02-887f-758274929a5b.png"/></p>
<p>The settings for this generator are almost identical to the <em>Points: Grid</em> Generator:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23039003-01ac-4b91-a8ad-10153d183b5c.png"/></p>
<ul>
<li><strong><em>Path to Item</em></strong>: If checked, this excludes all the points that are not reachable from the Context, in the settings of the Querier.</li>
<li><strong><em>Navigation Filter</em></strong>: As the name suggests, it is the navigation filter that's used to perform pathfinding.</li>
</ul>
<ul>
<li><strong><em>GridHalfSize</em></strong>: This indicates how much the grid should extend from its center (which means it is half of the size of the full grid). <span>The dimensions of the grid are fully determined by this parameter, along with</span><em>Space Between</em><span>.</span></li>
<li><strong><em>Space Between</em></strong>: This indicates how much space there is between each row and column of the grid. The dimensions of the grid are fully determined by this parameter, along with<em>GridHalfSize</em>.</li>
<li><strong><em>Generate Around</em></strong>: This is the center of the grid (where it starts being generated), and is expressed as a<span> </span><em>Context</em>.</li>
<li><strong><em>Projection Data</em></strong>: This <span>performs </span><span>a "</span><em>vertical</em><span>" trace by projecting the points from above. It does this by taking into consideration either the Geometry or the <em>Navigation Mesh</em>. The possible options are </span><strong><em>None</em></strong><span>, </span><strong><em>Navigation</em></strong><span>, and </span><strong><em>Geometry</em></strong><span>.</span></li>
</ul>
<p>This is what it looks like in the environment (I changed the level slightly to block the path upstairs. This makes it clear that those points after the stairs that aren't reachable aren't even generated by this Generator):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0242db3e-035d-498e-880a-7f9ba85910f3.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Built-in Tests</h1>
                </header>
            
            <article>
                
<p>Now that we have explored all the generators, it's time to explore the different <em>Tests</em> that are available within the engine. Usually, the return can be either a boolean or a float value.</p>
<p><span>The Tests that return a float value are most commonly used for <em>Scoring</em>, whereas the ones that return a boolean are more commonly used for <em>Filtering</em>. However, each Test might have different return values, depending on whether the Test is being used for filtering or scoring.</span></p>
<p>This is the list of the possible <em>Built-In Tests</em>; let's explore them:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc324308-87be-4f52-a13d-e0583977208f.png"/></p>
<ul>
<li><strong><em>Distance</em></strong>: Calculates the distance between the item (the point generated) and a specific <em>Context</em> (e.g. the <em>Querier</em>). It can be calculated in <strong><em>3D</em></strong>, <strong><em>2D</em></strong>, <strong><em>along z-axis</em></strong>, or <strong><em>along</em></strong> <strong><em>z-axis (absolute)</em></strong>. The return value is a float.</li>
<li><strong><em>Dot</em></strong>: Calculates the dot product between <strong><em>Line A</em></strong> and <strong><em>Line B</em></strong>. Both lines can be expressed as either the <strong><em>line between two Contexts</em></strong> or as the <strong><em>rotation of a specific Context</em></strong> (by taking the forward direction of the rotation). The calculation can be done both in <strong><em>3D</em></strong> or <strong><em>2D</em></strong>.</li>
<li><strong><em>Gameplay Tags</em></strong>: Performs a <em>Query</em> on the <em>Gameplay Tags</em>.</li>
<li><strong><em>Overlap</em></strong>: Performs an overlapping test with a Box; it is possible to specify some options, such as the offset or the extend, or the overlapping channel. </li>
</ul>
<ul>
<li><strong><em>Pathfinding</em></strong>: Performs a<span> </span><em>Pathfind</em><span> </span>between the generated point that is being evaluated and a Context. In particular, we can specify whether the return value is a boolean (if the<span> </span><em>Path exists</em>) or a float (<em>Path Cost</em><span> </span>or even<span> </span><em>Path Length</em>). Moreover, it is possible to specify whether the path<span> </span>goes from the<span> </span><em>Context</em><span> </span>to the<span> </span><em>Point</em><span> </span>or vice-versa, and it is possible to use a<span> </span><em>Navigation Filter</em>.</li>
<li><strong><em>Pathfinding Batch</em></strong>: Same as <strong><em>Pathfinding</em></strong>, but in a batch.</li>
<li><strong><em>Project</em></strong>: Performs a <em>projection</em>, which is customizable through the different parameters.</li>
<li><strong><em>Trace</em></strong>: Performs a <em>Trace Test</em>, with all the possible options available to perform a Trace elsewhere in the engine. This means that it can trace a <em>Line</em>, a <em>Box</em>, a <em>Sphere</em>, or a <em>Capsule</em>; either on the <em>Visibility</em> or <em>Camera</em> <em>Trace Channel</em>; either complex or simple; either from the Context to the point, or vice-versa.</li>
</ul>
<p class="mce-root"/>
<p>This concludes our exploration of the built-in nodes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing Environment Queries</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, there is a simple built-in way to visualize <strong><em>Environment Queries</em></strong> within the Game World, directly from the Viewport; the game doesn't even have to be running. In fact, there is a special Pawn that it is able to do this. However, this Pawn cannot be brought directly into the level, because to ensure that it is not misused, it has been declared virtual within the code base. This means that to use it, we need to create our own <em>Blueprint Pawn</em> that inherits directly from this special Pawn.</p>
<p>Thankfully, after this step, the Pawn is fully featured, and it doesn't need any more code, just the parameters to work with (i.e. the <em>Environmental Query</em> you want to visualize).</p>
<p>To start, create a new Blueprint. The class to inherit from is <strong><em>EQSTestingPawn</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/06e89c58-aefe-42f2-a80c-9fc4d9bb9fd3.png"/></p>
<p>Then, you can rename it <strong><em>MyEQSTestingPawn</em></strong>.</p>
<p>If you drag it into the map, from the <em>Details Panel</em>, you can change the <strong><em>EQS</em></strong> settings, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca33dccd-a3ba-4881-924e-34def53a0ac1.png"/></p>
<p>The most important parameter is the <strong><em>Query Template</em></strong>, in which you specify the query you want to visualize. If you want an in-depth break down of the parameter, check out <a href="a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml">Chapter 12</a><em>, Debugging methods for AI <span>–</span> Navigation, EQS, and Profiling</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating components for the Environment Querying System</h1>
                </header>
            
            <article>
                
<p>In this section, we will learn which class we need to expand to create our custom components within the <em>Environment Querying System</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Contexts</h1>
                </header>
            
            <article>
                
<p>Creating custom <em>Contexts</em> is key in order to have the right references when you need them during an Environmental Query. In particular, we will create a simple Context to retrieve a single reference to the Player.</p>
<p>Let's explore how to create this <strong><em>Context</em></strong>, both in <em>C++ and Blueprint</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Player Context in Blueprint</h1>
                </header>
            
            <article>
                
<p>To create a context, we need to inherit from the <strong><em>EnvQueryContext_BlueprintBase</em></strong> class. In the case of Blueprint, at its creation, just select the highlighted class, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/83d991a2-7719-4ad8-bf86-7d9242c6bd4b.png" style="width:34.42em;height:32.92em;"/></p>
<p>As for the name, the convention is to keep the prefix "<em>EnvQueryContext_</em>". We can call our Context something like "<strong><em>EnvQueryContext_BPPlayer</em></strong>".</p>
<p class="mce-root">For a Blueprint Context, you can choose to implement one of the following functions:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1fcad80b-d9ef-40dd-a524-39c9a366f895.png" style="width:22.33em;height:20.00em;"/></p>
<p>Each will provide a <em>Context</em> for the <em>Environmental Query.</em></p>
<p>We can override the <strong><em>Provide Single Actor</em></strong> function and then return the Player Pawn, simple as that:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8f49673-9c1d-4277-bc9f-422675387e6e.png" style="width:48.17em;height:14.50em;"/></p>
<p>As a result, we now have a Context that is able to get a Player reference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Player Context in C++</h1>
                </header>
            
            <article>
                
<p>In the case of creating a C++ Context, inherit from the <strong><em>EnvQueryContext</em></strong> class, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/37440b05-6538-4586-8aa1-cffb60df8743.png" style="width:41.75em;height:23.17em;"/></p>
<p>The convention is the same, that is, to prefix the Context with "<em>EnvQueryContext_</em>". We will call our class "<strong><em>EnvQueryContext_Player</em></strong>":</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4783c2af-4ece-4cc4-9989-1d043158c85f.png" style="width:46.00em;height:19.00em;"/></p>
<p>In C++, there is only one function to override: <kbd>ProvideContext()</kbd>. Hence, we just need to override it in the <kbd>.h</kbd> file, as follows:</p>
<pre>#include "CoreMinimal.h"<br/>#include "EnvironmentQuery/EnvQueryContext.h"<br/>#include "EnvQueryContext_Player.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class UNREALAIBOOK_API UEnvQueryContext_Player : public UEnvQueryContext<br/>{<br/>  GENERATED_BODY()<br/>  <br/>  virtual void ProvideContext(FEnvQueryInstance&amp; QueryInstance, FEnvQueryContextData&amp; ContextData) const override;<br/>};</pre>
<p>In the implementation file, we can provide the Context. I'm not going to go into the details of how <span>– </span>you can read the code of the other Contexts to help you understand this. In any case, we can have something like the following for our <kbd>.cpp</kbd> file (I could have implemented this differently, but I chose this way because I thought it was easy to understand):</p>
<pre>#include "EnvQueryContext_Player.h"<br/>#include "EnvironmentQuery/EnvQueryTypes.h"<br/>#include "EnvironmentQuery/Items/EnvQueryItemType_Actor.h"<br/>#include "Runtime/Engine/Classes/Kismet/GameplayStatics.h"<br/>#include "Runtime/Engine/Classes/Engine/World.h"<br/><br/>void UEnvQueryContext_Player::ProvideContext(FEnvQueryInstance&amp; QueryInstance, FEnvQueryContextData&amp; ContextData) const<br/>{<br/>  if (GetWorld()) {<br/>    if (GetWorld()-&gt;GetFirstPlayerController()) {<br/>      if (GetWorld()-&gt;GetFirstPlayerController()-&gt;GetPawn()) {<br/>        UEnvQueryItemType_Actor::SetContextHelper(ContextData, GetWorld()-&gt;GetFirstPlayerController()-&gt;GetPawn());<br/>      }<br/>    }<br/>  }<br/>  <br/>}</pre>
<p>As a result, we are able to retrieve the Player Context in C++.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Generators</h1>
                </header>
            
            <article>
                
<p>Similar to how we created Contexts, we can create custom Generators. However, we will not go through this in detail, since they are outside the scope of this book.</p>
<p>In the case of Blueprint, inherit from the <strong><em>EnvQueryGenerator_BlueprintBase</em></strong> class, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/36f2d84f-1e92-4920-aa97-02ace5030020.png" style="width:34.33em;height:34.25em;"/></p>
<p>In C++, you need to inherit from <strong><em>EnvQueryGenerator</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dc06c5f4-cba3-4396-b020-dc61879d71ee.png" style="width:56.17em;height:37.58em;"/></p>
<div class="packt_infobox">You may want to start directly from <strong><em>EnvQueryGenerator_ProjectedPoints</em></strong> since you already have all the projections in place. By doing this, you only need to focus on its generation.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Tests</h1>
                </header>
            
            <article>
                
<p>In the current version of Unreal Engine, it isn't possible to create a Test in Blueprint <span>– we can only do so </span>with C++. You can do this by extending the <em><strong>EnvQueryTest</strong></em> class:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a76bd630-21c2-4463-8588-aacabe3309e2.png"/></p>
<p>Unfortunately, this is also outside the scope of this book. Exploring the Unreal Engine Source code, however, will give you a great amount of information and an almost infinite source of learning.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored how the <strong><em>Environment Querying System</em></strong> can make spatial reasoning in the Decision-Making domain.</p>
<p>In particular, we have understood how the whole system works in general, and then we went through the built-in nodes of the system. We also saw how it is possible to visualize a Query by using a special Pawn. Finally, we explored how it is possible to extend the system.</p>
<p>In the next chapter, we will explore Agent Awareness, and the built-in Sensing system.</p>


            </article>

            
        </section>
    </body></html>