<html><head></head><body>
<div id="_idContainer025">
<h1 class="chapter-number" id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.2.1">Setting Up Your Robot</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter begins with some background on my thoughts on what a robot is, and what robots are made of – a fairly standard list of parts and components. </span><span class="koboSpan" id="kobo.3.2">This chapter aims to allow you to duplicate the exercises and use the source code that is found throughout the book. </span><span class="koboSpan" id="kobo.3.3">I will describe how I set up my environments for development, what tools I used to </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.4.1">create my code, and how to install the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Robotic Operating System version 2</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">ROS 2</span></strong><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">The assembly of Albert, the robot I use for all the examples, is covered in the GitHub repository for this book. </span><span class="koboSpan" id="kobo.8.3">There are many other types and configurations of robots that can work with the code in this book with some changes. </span><span class="koboSpan" id="kobo.8.4">I’ll try to provide all the shortcuts I can, including a full image of my robot’s SD card, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Git repo.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Understanding the anatomy of </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">a robot</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">subsumption architecture</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">A brief introduction </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">to ROS</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Software setup: Linux, ROS 2, Jetson Nano, </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">and Arduino</span></span></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">To complete the practical exercises in this chapter, you will need the requirements specified in the </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Preface</span></em><span class="koboSpan" id="kobo.23.1"> at the beginning of this book. </span><span class="koboSpan" id="kobo.23.2">The code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">at </span></span><a href="https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/"><span class="No-Break"><span class="koboSpan" id="kobo.25.1">https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.26.1">.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.27.1">Understanding the anatomy of a robot</span></h1>
<p><span class="koboSpan" id="kobo.28.1">A robot is a machine that is capable of carrying out complex actions and behaviors by itself. </span><span class="koboSpan" id="kobo.28.2">Most robots </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.29.1">are controlled by a computer or digital programmable device. </span><span class="koboSpan" id="kobo.29.2">Some key characteristics of robots are </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Automation</span></strong><span class="koboSpan" id="kobo.32.1">: Robots can operate automatically without direct human input, based on </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.33.1">their programming. </span><span class="koboSpan" id="kobo.33.2">This allows them to do repetitive or dangerous </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">tasks consistently.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.35.1">Sensors</span></strong><span class="koboSpan" id="kobo.36.1">: Robots use sensors such as cameras, optics, lidar, and pressure sensors to </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.37.1">gather information about their environment so they can navigate and interact. </span><span class="koboSpan" id="kobo.37.2">This sensory information is processed to determine what actions the robot </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">should take.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">Programming</span></strong><span class="koboSpan" id="kobo.40.1">: A robot’s </span><em class="italic"><span class="koboSpan" id="kobo.41.1">brain</span></em><span class="koboSpan" id="kobo.42.1"> consists of an onboard computer or device that runs code </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.43.1">and algorithms that define how it will behave. </span><span class="koboSpan" id="kobo.43.2">Robots are programmed by humans to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">desired behaviors.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Movement</span></strong><span class="koboSpan" id="kobo.46.1">: Most </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.47.1">robots are able to move around to some degree through wheels, legs, propellers, or other locomotion systems. </span><span class="koboSpan" id="kobo.47.2">This allows them to travel through environments to </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">perform tasks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Interaction</span></strong><span class="koboSpan" id="kobo.50.1">: Advanced </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.51.1">robots can communicate with humans through voice, visual displays, lights, sounds, physical gestures, and more. </span><span class="koboSpan" id="kobo.51.2">This allows useful human-robot interaction </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">and work.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Autonomy</span></strong><span class="koboSpan" id="kobo.54.1">: While </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.55.1">robots are programmed by humans, they have a degree of self-governance and independence in how they meet their objectives. </span><span class="koboSpan" id="kobo.55.2">The ability to take action and make decisions without human oversight is </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">their autonomy.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">In summary, a robot integrates automation, sensing, movement, programming, and autonomy to reliably carry out jobs that may be complex, repetitive, unsafe, or otherwise unsuitable for humans. </span><span class="koboSpan" id="kobo.57.2">They come in many shapes and sizes, from industrial robotic arms to social companion robots to autonomous </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">self-driving cars.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">There is a fairly standard collection of components and parts that make up the vast majority of robots. </span><span class="koboSpan" id="kobo.59.2">Even robots as outwardly different as a self-driving car, the welding robot that built the car, and a Roomba vacuum cleaner have a lot of the same components </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.60.1">or parts. </span><span class="koboSpan" id="kobo.60.2">Some will have more, and some will have less, but most mobile robots will have the following categories </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">of parts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.62.1"><img alt="Figure 2.1 – Block diagram of a typical mobile robot" src="image/B19846_02_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.63.1">Figure 2.1 – Block diagram of a typical mobile robot</span></p>
<p><span class="koboSpan" id="kobo.64.1">Let’s look at these components in </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">greater detail:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">Computer</span></strong><span class="koboSpan" id="kobo.67.1">: A unit that runs the programming that controls the robot. </span><span class="koboSpan" id="kobo.67.2">This can be a </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.68.1">traditional computer, a microcontroller, a </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">single board computer</span></strong><span class="koboSpan" id="kobo.70.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.71.1">SBC</span></strong><span class="koboSpan" id="kobo.72.1">) like we have, or some other sort of </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.73.1">processor that sends and receives commands. </span><span class="koboSpan" id="kobo.73.2">Robot </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.74.1">arms and some types of industrial robots will use a </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">Programmable Logic Controller</span></strong><span class="koboSpan" id="kobo.76.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.77.1">PLC</span></strong><span class="koboSpan" id="kobo.78.1">), which is a special type of controller that applies logic (</span><em class="italic"><span class="koboSpan" id="kobo.79.1">AND</span></em><span class="koboSpan" id="kobo.80.1">, </span><em class="italic"><span class="koboSpan" id="kobo.81.1">OR</span></em><span class="koboSpan" id="kobo.82.1">, </span><em class="italic"><span class="koboSpan" id="kobo.83.1">NOT</span></em><span class="koboSpan" id="kobo.84.1">) to various inputs to produce an output. </span><span class="koboSpan" id="kobo.84.2">For a computer to send commands to the robot and receive telemetry, we’ll need some sort of sensor interface, such as a USB port, serial </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.85.1">port, </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">General Purpose Input/Output</span></strong><span class="koboSpan" id="kobo.87.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.88.1">GPIO</span></strong><span class="koboSpan" id="kobo.89.1">) port, or a network interface such as Ethernet </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">or Wi-Fi.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">Control Station</span></strong><span class="koboSpan" id="kobo.92.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Human/Robot Interface</span></strong><span class="koboSpan" id="kobo.94.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.95.1">HRI</span></strong><span class="koboSpan" id="kobo.96.1">): Robots are designed to perform tasks, which requires that the operator must have some means to send and receive </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.97.1">data from the robot and to supervise that the robot is behaving correctly. </span><span class="koboSpan" id="kobo.97.2">We will be using a laptop </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.98.1">or desktop computer for this function, and we will talk to the robot via a wireless network. </span><span class="koboSpan" id="kobo.98.2">Our control station sends commands to the robot and receives </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">telemetry</span></strong><span class="koboSpan" id="kobo.100.1"> from the robot in the form of </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">data</span></strong><span class="koboSpan" id="kobo.102.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">video</span></strong><span class="koboSpan" id="kobo.104.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.106.1">audio</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.108.1">Radio</span></strong><span class="koboSpan" id="kobo.109.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">Data Link</span></strong><span class="koboSpan" id="kobo.111.1">: Mobile robots such as the one we are designing in this book are </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.112.1">capable of moving and exploring their environment. </span><span class="koboSpan" id="kobo.112.2">While it is possible to send commands to a robot over a tether or wire, the preferred way is to use a radio link. </span><span class="koboSpan" id="kobo.112.3">The ubiquitous availability </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.113.1">of wireless networks such as Wi-Fi and cellular data services has made creating data links a lot easier. </span><span class="koboSpan" id="kobo.113.2">I have had a lot of robot projects where a network link was unavailable or impractical, and a custom radio solution needed to be devised. </span><span class="koboSpan" id="kobo.113.3">Other types of radio used in robots include Bluetooth, Zigbee, and various mesh network systems, such </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">as Flutter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Motors</span></strong><span class="koboSpan" id="kobo.116.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">Effectors</span></strong><span class="koboSpan" id="kobo.118.1">: Our definition of a robot includes the ability for </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">self-propulsion</span></strong><span class="koboSpan" id="kobo.120.1">; that is, the robot is able to move. </span><span class="koboSpan" id="kobo.120.2">In order to move, the robot needs a motor </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.121.1">or set of motors. </span><span class="koboSpan" id="kobo.121.2">Our robot, Albert, has ten motors, four for driving and six to control the robot arm and hand. </span><span class="koboSpan" id="kobo.121.3">Motors </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.122.1">convert electricity into motion. </span><span class="koboSpan" id="kobo.122.2">There are many different types, and picking the right motor is a challenge. </span><span class="koboSpan" id="kobo.122.3">You must match the torque (how hard the motor can pull), the speed of the motor shaft in revolutions per minute, and voltage. </span><span class="koboSpan" id="kobo.122.4">Here are some key factors to consider when selecting a motor for a robot </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">drive system:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Torque</span></strong><span class="koboSpan" id="kobo.125.1">: Consider </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.126.1">the torque required for your robot’s movements and payload handling. </span><span class="koboSpan" id="kobo.126.2">More torque allows faster acceleration and the ability to handle heavier loads. </span><span class="koboSpan" id="kobo.126.3">If there is insufficient torque, the robot will “bog down” or stall the motor. </span><span class="koboSpan" id="kobo.126.4">An electric motor pulls the most current when it is stalled (it is energized but not moving). </span><span class="koboSpan" id="kobo.126.5">All that power going nowhere gets turned into heat, which will eventually melt the wires or cause </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">a fire.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.128.1">Speed</span></strong><span class="koboSpan" id="kobo.129.1">: Determine </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.130.1">the speeds your robot needs to operate at. </span><span class="koboSpan" id="kobo.130.2">Higher speeds require motors with higher RPM ratings. </span><span class="koboSpan" id="kobo.130.3">We only want our robot to go at a modest rate. </span><span class="koboSpan" id="kobo.130.4">The toys can’t </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">get away.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.132.1">Duty cycle</span></strong><span class="koboSpan" id="kobo.133.1">: Choose </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.134.1">a motor that can run continuously for the robot’s required duty cycle without overheating. </span><span class="koboSpan" id="kobo.134.2">Intermittent duty cycles allow smaller, lighter motors. </span><span class="koboSpan" id="kobo.134.3">We will be driving or moving quite a bit – about 50% of the time, but not </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">too fast.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.136.1">Size and weight</span></strong><span class="koboSpan" id="kobo.137.1">: Large, heavy-duty motors provide a lot of power but may </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.138.1">constrain robot design. </span><span class="koboSpan" id="kobo.138.2">Consider the full drive system size and weight. </span><span class="koboSpan" id="kobo.138.3">Remember the motor also has to </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">move itself.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.140.1">Control</span></strong><span class="koboSpan" id="kobo.141.1">: Brushless DC motors require electronic speed controllers. </span><span class="koboSpan" id="kobo.141.2">Stepper motors </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.142.1">allow open-loop position control. </span><span class="koboSpan" id="kobo.142.2">Servomotors, such as the ones in the robot’s arm, have integrated encoders and are controlled by a serial interface. </span><span class="koboSpan" id="kobo.142.3">The drive motors I used are </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.143.1">brushed motors, which are controlled by varying the voltage, which we control with </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">Pulse Width </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.145.1">Modulation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.147.1">PWM</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">).</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.149.1">Voltage</span></strong><span class="koboSpan" id="kobo.150.1">: High </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.151.1">voltages allow more power in small motors. </span><span class="koboSpan" id="kobo.151.2">Select a voltage that is compatible with other electronics. </span><span class="koboSpan" id="kobo.151.3">My battery is 7.2 volts, which matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">motors selected.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.153.1">Noise</span></strong><span class="koboSpan" id="kobo.154.1">: Quiet motors may be required for home/office robots. </span><span class="koboSpan" id="kobo.154.2">Brushless, gear-reduced </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.155.1">motors are quiet but expensive. </span><span class="koboSpan" id="kobo.155.2">Geared drivetrains are </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">also noisy.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Cost</span></strong><span class="koboSpan" id="kobo.158.1">: More </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.159.1">powerful motors cost more. </span><span class="koboSpan" id="kobo.159.2">Balance performance needs with budget constraints. </span><span class="koboSpan" id="kobo.159.3">Albert’s brushed motors are </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">very inexpensive.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.161.1">Some robot motors also feature gearboxes to reduce the motor speed, basically exchanging speed for torque. </span><span class="koboSpan" id="kobo.161.2">Albert’s electric motors have reduction gearboxes that let the motor run at a faster speed than </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">the wheels.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.163.1">There are many ways to provide motion to a robot. </span><span class="koboSpan" id="kobo.163.2">We call these </span><em class="italic"><span class="koboSpan" id="kobo.164.1">things that make the robot move</span></em> <strong class="bold"><span class="koboSpan" id="kobo.165.1">effectors</span></strong><span class="koboSpan" id="kobo.166.1">. </span><span class="koboSpan" id="kobo.166.2">Effectors are only limited by your imagination, and </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.167.1">include </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">pneumatics</span></strong><span class="koboSpan" id="kobo.169.1"> (things actuated by compressed air), </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">hydraulics</span></strong><span class="koboSpan" id="kobo.171.1"> (things actuated </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.172.1">by incompressible fluid), </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">linear actuators</span></strong><span class="koboSpan" id="kobo.174.1"> (things that convert rotary motion into linear </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.175.1">motion), </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">revolving joints</span></strong><span class="koboSpan" id="kobo.177.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">revolute joints</span></strong><span class="koboSpan" id="kobo.179.1"> (angular </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.180.1">joints like an elbow) and </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.181.1">even exotic </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.182.1">effectors such as </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">shape-memory alloy</span></strong><span class="koboSpan" id="kobo.184.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">piezoelectric crystals</span></strong><span class="koboSpan" id="kobo.186.1">, which </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.187.1">change shape when electricity </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">is applied.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.189.1">Servos</span></strong><span class="koboSpan" id="kobo.190.1">: Some of </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.191.1">the motors in our robot are a </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.192.1">special category of motors called </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">servos</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">Servo motors feature a feedback mechanism and a control loop, either to maintain a position or a speed. </span><span class="koboSpan" id="kobo.194.3">The feedback is provided by some sort of </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">sensor</span></strong><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">The servos we are using consist of a small electric motor that drives a gearbox made up of a series of gears that reduce the speed and consequently increase the torque of the motor. </span><span class="koboSpan" id="kobo.196.3">The sensor used in our case is a potentiometer (variable resistor) that can measure the angle of the output gear shaft. </span><span class="koboSpan" id="kobo.196.4">When we send a command to the servo, it tells the motor to be set to a particular angle. </span><span class="koboSpan" id="kobo.196.5">The angle is measured by the sensor, and any difference between the motor’s position and the sensor creates an error signal that moves the motor in the correct direction. </span><span class="koboSpan" id="kobo.196.6">You can hear the motor making a lot of noise because the motor turns many times through seven reduction gears to make the arm move. </span><span class="koboSpan" id="kobo.196.7">The gearbox lets us get a lot of torque without drawing a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">of current.</span></span><p class="list-inset"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.198.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.199.1">.2</span></em><span class="koboSpan" id="kobo.200.1"> shows how </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.201.1">a servo motor is controlled using </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Pulse Position Modulation</span></strong><span class="koboSpan" id="kobo.203.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.204.1">PPM</span></strong><span class="koboSpan" id="kobo.205.1">). </span><span class="koboSpan" id="kobo.205.2">To control a servo, you must generate a pulse of a </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">specific width:</span></span></p></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.207.1"><img alt="Figure 2.2 – Servo motor control is via PPM signals" src="image/B19846_02_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">Figure 2.2 – Servo motor control is via PPM signals</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.209.1">A short </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.210.1">pulse moves the servo to the beginning of its range. </span><span class="koboSpan" id="kobo.210.2">A medium pulse (1,500 microseconds) is the center of the servo’s position. </span><span class="koboSpan" id="kobo.210.3">A late pulse causes </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.211.1">the servo motor to go to the end of its range. </span><span class="koboSpan" id="kobo.211.2">The robot arm I use in this version of my robot has a servo controller that comes with the arm hardware. </span><span class="koboSpan" id="kobo.211.3">We will be controlling the robot arm via serial commands to this controller in </span><a href="B19846_05.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.212.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.213.1">.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.214.1">Motor Controller or Electronic Speed Control</span></strong><span class="koboSpan" id="kobo.215.1">: Motors are not very useful by </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.216.1">themselves – you need the ability </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.217.1">to convert commands from the control computer into motion from the motors. </span><span class="koboSpan" id="kobo.217.2">Since motors need more voltage and more current than the control computer (our Jetson Nano) can provide, we need a device to turn small digital signals into large analog voltage and current. </span><span class="koboSpan" id="kobo.217.3">This device is called a motor controller. </span><span class="koboSpan" id="kobo.217.4">This controller I had </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.218.1">to purchase separately, and is composed of two parts – an Arduino Uno and a motor controller </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.219.1">shield that </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">is attached:</span></span></li>
</ul>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.221.1"><img alt="Figure 2.3 – Motor ﻿controller shield I used for Albert" src="image/B19846_02_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.222.1">Figure 2.3 – Motor controller shield I used for Albert</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.223.1">As shown in the image, the four motor wires are attached to the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">lettered connections.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.225.1">Since we </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.226.1">have a tank-drive robot (we steer by running the motors at different speeds, also called </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">differential drive</span></strong><span class="koboSpan" id="kobo.228.1">), we also need the motors to be able to run forward or backward. </span><span class="koboSpan" id="kobo.228.2">The motor controller takes a special input </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.229.1">signal called a </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">Pulse Width Modulation</span></strong><span class="koboSpan" id="kobo.231.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.232.1">PWM</span></strong><span class="koboSpan" id="kobo.233.1">). </span><span class="koboSpan" id="kobo.233.2">PWM is a repeating signal where the voltage turns on and off. </span><span class="koboSpan" id="kobo.233.3">The motor throttle (how fast the motor turns) is proportional to the amount the PWM signal stays in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.234.1">ON</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1"> position.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.236.1">The motor </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.237.1">controller has several</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.238.1"> kinds of connections, and has to be wired carefully due to the high voltages and currents provided. </span><span class="koboSpan" id="kobo.238.2">This can be done by performing the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">following steps:</span></span></p><ul><li><span class="koboSpan" id="kobo.240.1">There are two </span><strong class="bold"><span class="koboSpan" id="kobo.241.1">control wire inputs</span></strong><span class="koboSpan" id="kobo.242.1"> – one for speed (the PWM signal) and the other is a direction signal. </span><span class="koboSpan" id="kobo.242.2">We put the motor in reverse by changing the </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">direction signal</span></strong><span class="koboSpan" id="kobo.244.1"> – 1 is forward, and 0 </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">is backward.</span></span></li><li><span class="koboSpan" id="kobo.246.1">The next thing we need is a </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">ground</span></strong><span class="koboSpan" id="kobo.248.1"> – it is very important that the controller sending the PWM signal (in our case, it is the Ardunio Mega) and the motor control have their ground </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">lines connected.</span></span></li><li><span class="koboSpan" id="kobo.250.1">Next, the motor controller needs the </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">motor voltage</span></strong><span class="koboSpan" id="kobo.252.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">current</span></strong><span class="koboSpan" id="kobo.254.1">, which we get directly from </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">our battery.</span></span></li><li><span class="koboSpan" id="kobo.256.1">Finally, we connect two wires from each motor to the controller. </span><span class="koboSpan" id="kobo.256.2">It is interesting that we don’t care which wire goes to which side of the motor, since we can run both forward and backward. </span><span class="koboSpan" id="kobo.256.3">If the motor is turning the wrong way, just switch the two wires. </span><span class="koboSpan" id="kobo.256.4">This is the only time you get to say </span><em class="italic"><span class="koboSpan" id="kobo.257.1">just reverse the polarity</span></em><span class="koboSpan" id="kobo.258.1"> outside of a science </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">fiction movie.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.260.1">We will be covering the specific wiring for the example robot – Albert – in the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">online appendix.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.262.1">Sensors</span></strong><span class="koboSpan" id="kobo.263.1">: In order </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.264.1">for the robot, which is a machine that can move and react to its environment, to be able to see its surroundings, it needs sensors. </span><span class="koboSpan" id="kobo.264.2">Sensors take information from the outside or inside of the robot and convert it into a digital form. </span><span class="koboSpan" id="kobo.264.3">If we use a digital </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">camera sensor</span></strong><span class="koboSpan" id="kobo.266.1">, it takes </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.267.1">light and turns it into digital pixels (picture elements), recorded as an array of numbers. </span><span class="koboSpan" id="kobo.267.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.268.1">sonar sensor</span></strong><span class="koboSpan" id="kobo.269.1"> measures the </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.270.1">distance to an object, such as a wall, by sending a pulse of energy (sound waves) and listening for the time delay before hearing an echo. </span><span class="koboSpan" id="kobo.270.2">Measuring the time delay gives us the distance to an object, since the speed of sound is fairly constant. </span><span class="koboSpan" id="kobo.270.3">For our Albert project, the robot has several types </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">of sensors:</span></span><ul><li><span class="koboSpan" id="kobo.272.1">Our </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">primary sensor</span></strong><span class="koboSpan" id="kobo.274.1"> is a wide-angle </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.275.1">video camera, which we will use for avoiding </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.276.1">obstacles and </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">detecting objects.</span></span></li><li><span class="koboSpan" id="kobo.278.1">We will </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.279.1">also use a </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">microphone</span></strong><span class="koboSpan" id="kobo.281.1"> to listen for sounds </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.282.1">and perform </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">speech recognition.</span></span></li><li><span class="koboSpan" id="kobo.284.1">We mentioned </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.285.1">servo motors earlier in this list – each servo </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.286.1">motor contains an </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">angle sensor</span></strong><span class="koboSpan" id="kobo.288.1"> that detects the amount of rotation and allows us to direct the robot arm </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">and hand.</span></span></li><li><span class="koboSpan" id="kobo.290.1">We have our </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">Emergency Stop button</span></strong><span class="koboSpan" id="kobo.292.1">, which is wired to the Arduino, and is a </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.293.1">type of tactile (touch) sensor. </span><span class="koboSpan" id="kobo.293.2">When the </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.294.1">button is pressed, a signal is sent that the robot can interpret as a </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">stop command.</span></span></li><li><span class="koboSpan" id="kobo.296.1">The robot </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.297.1">arm I chose has a handy </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">voltage monitor</span></strong><span class="koboSpan" id="kobo.299.1"> that we </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.300.1">will use to keep track of the battery life (</span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">charge) remaining.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.302.1">In the next section, we will discuss robot software architectures, which act as a framework for the autonomy behaviors we will </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">be creating.</span></span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.304.1">Introducing subsumption architecture</span></h1>
<p><span class="koboSpan" id="kobo.305.1">At this point, I want </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.306.1">to spend a bit of time on the idea behind the </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">subsumption architecture</span></strong><span class="koboSpan" id="kobo.308.1">, and point out some specifics of how we will be using this concept in the design of our robot project. </span><span class="koboSpan" id="kobo.308.2">Many of you will be familiar with the concept from school or from study, so you can look at my diagram and then move on. </span><span class="koboSpan" id="kobo.308.3">For the rest of us, let’s talk a bit about this biologically inspired </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">robot concept.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Subsumption architecture was originally described by Dr. </span><span class="koboSpan" id="kobo.310.2">Rodney Brooks, a professor at MIT, who would later help found iRobot Corporation and invent the Baxter robot. </span><span class="koboSpan" id="kobo.310.3">Rodney was trying to develop analogs of insect brains in order to understand how to program intelligent robots. </span><span class="koboSpan" id="kobo.310.4">Robots before this time (1986) were very much single-threaded machines that pretty much only did one thing at a time. </span><span class="koboSpan" id="kobo.310.5">They read sensors, made decisions, and then acted – and only had one goal at any one time. </span><span class="koboSpan" id="kobo.310.6">Creatures such as flies or ants have very simple brains but still manage to function in the real world. </span><span class="koboSpan" id="kobo.310.7">Brooks reasoned that there were several layers of closed-loop feedback processes </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">going simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">The basic concept </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.313.1">of subsumption has been around for some time, and it has been adapted, reused, refined, and simplified in the years since it was first introduced. </span><span class="koboSpan" id="kobo.313.2">What I am presenting here is my interpretation of how to apply the concept of subsumption to a robot in the context of what we are trying </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">to accomplish.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">The first aspect to understand is that we want our robot to act on a series of goals. </span><span class="koboSpan" id="kobo.315.2">The robot is not simply reacting to each stimulus in total isolation, but is rather carrying out some sort of goal-oriented behavior. </span><span class="koboSpan" id="kobo.315.3">The goal may be to pick up a toy or navigate the room, avoiding obstacles. </span><span class="koboSpan" id="kobo.315.4">The paradigm we are creating has the user set goals for the robot and the robot determines how to carry those goals out, even if the goal is simply to move one </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">meter forward.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">The problem begins when the robot has to keep more than one goal in mind at a time. </span><span class="koboSpan" id="kobo.317.2">The robot is not just driving around, but driving around avoiding obstacles and looking for toys to pick up. </span><span class="koboSpan" id="kobo.317.3">How do we arbitrate between different goals, to determine which one has precedence? </span><span class="koboSpan" id="kobo.317.4">The answer is found in the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.319.1"><img alt="Figure 2.4 – An example subsumption architecture" src="image/B19846_02_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">Figure 2.4 – An example subsumption architecture</span></p>
<p><span class="koboSpan" id="kobo.321.1">We will divide the robot’s decision-making systems into three layers, each of which has a different level of responsibility and operates on a different </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">time scale.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">At the lowest </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.324.1">levels are what we might call the robot’s autonomic nervous system – it contains the robot’s internal health-keeping and monitoring functions. </span><span class="koboSpan" id="kobo.324.2">These processes run very fast – 20 times a second or so, or 20 hertz (Hz), and only deal with what is inside the robot. </span><span class="koboSpan" id="kobo.324.3">This includes reading internal sensors, checking battery levels, and reading and responding to heartbeat messages. </span><span class="koboSpan" id="kobo.324.4">I’ve labeled this level </span><em class="italic"><span class="koboSpan" id="kobo.325.1">Take Care </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.326.1">of Myself</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.328.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.329.1">What is a </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">heartbeat message</span></strong><span class="koboSpan" id="kobo.331.1">? </span><span class="koboSpan" id="kobo.331.2">Once a </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.332.1">second, I have the control station send a special heartbeat message to the robot, which has a time tag down to the millisecond, which is the clock time of the host computer. </span><span class="koboSpan" id="kobo.332.2">This goes to the control computer and repeats the heartbeat message back to the host. </span><span class="koboSpan" id="kobo.332.3">We can see the delay in our message – our command latency – by comparing the time tags. </span><span class="koboSpan" id="kobo.332.4">We want to see a less than 25 milliseconds round trip for the heartbeat. </span><span class="koboSpan" id="kobo.332.5">If the onboard computer is not working or is locked up, then the time tag won’t come back and we know the robot is </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">having problems.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">The next level handles individual tasks, such as driving around or looking for toys. </span><span class="koboSpan" id="kobo.334.2">These tasks are short-term and deal with what the sensors can see. </span><span class="koboSpan" id="kobo.334.3">The time period for decisions is </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.335.1">in the second range, so these tasks might have 1 or 2 Hz update rates, but slower than the internal checks. </span><span class="koboSpan" id="kobo.335.2">I call this level </span><em class="italic"><span class="koboSpan" id="kobo.336.1">Complete the Task</span></em><span class="koboSpan" id="kobo.337.1"> – you might call it </span><em class="italic"><span class="koboSpan" id="kobo.338.1">Drive the Vehicle</span></em><span class="koboSpan" id="kobo.339.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.340.1">Operate </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">the Payload</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">The final and top level is the section devoted to </span><em class="italic"><span class="koboSpan" id="kobo.344.1">completing the mission</span></em><span class="koboSpan" id="kobo.345.1">, and it deals with the overall purpose of the robot. </span><span class="koboSpan" id="kobo.345.2">This level has the overall state machine for finding toys, picking them up, and then putting them away, which is the mission of this robot. </span><span class="koboSpan" id="kobo.345.3">This level also deals with interacting with humans and responding to commands. </span><span class="koboSpan" id="kobo.345.4">The top level works on tasks that take minutes, or even hours, </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">to complete.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">The rules of the subsumption architecture – and even where it gets its name – have to do with the priority and interaction of the processes in these layers. </span><span class="koboSpan" id="kobo.347.2">The rules are as follows (and this is </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">my version):</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.349.1">Each layer can only talk to the layers next to it. </span><span class="koboSpan" id="kobo.349.2">The top layer talks only to the middle layer, and the bottom layer also talks only to the middle layer. </span><span class="koboSpan" id="kobo.349.3">The middle layer can communicate with both the top and the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">bottom layer.</span></span></li>
<li><span class="koboSpan" id="kobo.351.1">The layer with the lower level has the highest priority. </span><span class="koboSpan" id="kobo.351.2">The lower level has the ability to interrupt or override the commands from </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">higher layers.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.353.1">Think about this for a minute. </span><span class="koboSpan" id="kobo.353.2">I’ve given you an example of driving our robot in a room. </span><span class="koboSpan" id="kobo.353.3">The lowest level detects obstacles. </span><span class="koboSpan" id="kobo.353.4">The middle level is driving the robot in a particular direction, and the top layer is directing the mission. </span><span class="koboSpan" id="kobo.353.5">From the top down, the uppermost layer is commanded to </span><em class="italic"><span class="koboSpan" id="kobo.354.1">clean up the room</span></em><span class="koboSpan" id="kobo.355.1">, the middle layer is commanded to </span><em class="italic"><span class="koboSpan" id="kobo.356.1">drive around</span></em><span class="koboSpan" id="kobo.357.1">, and the bottom layer gets the command </span><em class="italic"><span class="koboSpan" id="kobo.358.1">left motor and right motor forward 60% throttle</span></em><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">Now, the bottom level detects an obstacle. </span><span class="koboSpan" id="kobo.359.3">It interrupts the </span><em class="italic"><span class="koboSpan" id="kobo.360.1">drive around</span></em><span class="koboSpan" id="kobo.361.1"> function and overrides the command from the top layer to turn the robot away from the obstacle. </span><span class="koboSpan" id="kobo.361.2">Once the obstacle is cleared, the lowest layer returns control to the middle layer for the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">driving direction.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Another example could be if the lowest layer loses the heartbeat signal, which indicates that something has gone wrong with the software or hardware. </span><span class="koboSpan" id="kobo.363.2">The lowest layer causes the motors to halt, overriding any commands from the upper layers. </span><span class="koboSpan" id="kobo.363.3">It does not matter what they want; the robot </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.364.1">has a fault and needs to stop. </span><span class="koboSpan" id="kobo.364.2">This </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">priority inversion</span></strong><span class="koboSpan" id="kobo.366.1"> of the lowest layers having the highest priority is the reason we call this a subsumption architecture, since the higher layers subsume – incorporate – the functions of the lower layers to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">their tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">The major </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.369.1">benefit of this type of organization is that it keeps procedures clear as to which events, faults, or commands take precedence over others, and prevents the robot from getting stuck in an </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">indecision loop.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Each type of </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.372.1">robot may have different numbers of layers in their architecture. </span><span class="koboSpan" id="kobo.372.2">You could even have a </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">supervisory layer</span></strong><span class="koboSpan" id="kobo.374.1"> that controls a number of other robots and has goals for the robots as a team. </span><span class="koboSpan" id="kobo.374.2">The most I have had so far has been five, used in one of my self-driving </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">car projects.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">Now let’s take a look at one of the most important concepts you’ll need in this book – </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">ROS.</span></span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.378.1">A brief introduction to ROS</span></h1>
<p><span class="koboSpan" id="kobo.379.1">OK, before we do all of the work described in the following section to be able to use ROS 2 – the second </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.380.1">version of the Robotic Operating System – let’s answer your questions. </span><span class="koboSpan" id="kobo.380.2">What is ROS, and what are </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">its advantages?</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">The first thing to know is that ROS is not an actual operating system, such as Linux or Windows. </span><span class="koboSpan" id="kobo.382.2">Rather it is a middleware layer that serves as a means of connecting different programs to work together to control a robot. </span><span class="koboSpan" id="kobo.382.3">It was originally designed to run Willow Garage’s PR2 robot, which was complex indeed. </span><span class="koboSpan" id="kobo.382.4">ROS is supported by a very large open source community and is </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">constantly updated.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">I used to be a ROS skeptic, and frankly, reading the documentation did not help my first impression that it was cumbersome at best and difficult to use. </span><span class="koboSpan" id="kobo.384.2">However, at the insistence of one of my business partners, we started using ROS for a very complex self-guided security guard robot called RAMSEE, designed for Gamma </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">2 Robotics:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.386.1"><img alt="Figure 2.5 – RAMSEE, the security guard robot, designed by the author" src="image/B19846_02_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.387.1">Figure 2.5 – RAMSEE, the security guard robot, designed by the author</span></p>
<p><span class="koboSpan" id="kobo.388.1">I quickly realized that while the initial learning curve with ROS was steep, the payoff was the ability to </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.389.1">create and implement modular, easily portable services that could be developed independently. </span><span class="koboSpan" id="kobo.389.2">I did not need to combine everything into one program, or even in one CPU. </span><span class="koboSpan" id="kobo.389.3">I could take advantage of my multi-core computers to run independent processes, or even have more than one computer and move things freely from one to the other. </span><span class="koboSpan" id="kobo.389.4">RAMSEE has one computer with eight cores and another </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">with four.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.391.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.392.1">ROS can </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.393.1">be described as a </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Modular Open System Software</span></strong><span class="koboSpan" id="kobo.395.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.396.1">MOSA</span></strong><span class="koboSpan" id="kobo.397.1">). </span><span class="koboSpan" id="kobo.397.2">It provides a standard interface to allow programs to talk to one another through a </span><em class="italic"><span class="koboSpan" id="kobo.398.1">Publish-Subscribe</span></em><span class="koboSpan" id="kobo.399.1"> paradigm. </span><span class="koboSpan" id="kobo.399.2">This means that one program publishes data, making it available to other programs. </span><span class="koboSpan" id="kobo.399.3">The programs that need this subscribe to that data and are sent a message whenever new data is available. </span><span class="koboSpan" id="kobo.399.4">This lets us develop programs independently and create standardized interfaces between programs. </span><span class="koboSpan" id="kobo.399.5">It really makes creating robots much easier and far </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">more flexible.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">The other major advantage, and worth all the bother, is that ROS has a very large library of ready-to-go interfaces for sensors, motors, drivers, and effectors, as well as every imaginable type of robot navigation and control tool. </span><span class="koboSpan" id="kobo.401.2">For example, we will be using the OAK-D 3D </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.402.1">depth camera, which has a ROS 2 driver available </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">at </span></span><a href="https://github.com/luxonis/depthai-ros"><span class="No-Break"><span class="koboSpan" id="kobo.404.1">https://github.com/luxonis/depthai-ros</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.405.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">The RViz2 tool provides visualization of all of your sensor data, as well as showing the localization </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.407.1">and navigation process. </span><span class="koboSpan" id="kobo.407.2">I greatly appreciated the logging and debugging tools included in ROS. </span><span class="koboSpan" id="kobo.407.3">You can log data – anything that </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.408.1">crosses the publish/subscribe interface – to a </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">ROSBag</span></strong><span class="koboSpan" id="kobo.410.1"> and play it back later to test your code without the robot being attached, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">very useful.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">The following illustration below shows the output given by RViz2, showing a map being drawn by one of </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">my robots:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.414.1"><img alt="Figure 2.6 – ROS RViz allows you to see what the robot sees, in this case, a map of a warehouse" src="image/B19846_02_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.415.1">Figure 2.6 – ROS RViz allows you to see what the robot sees, in this case, a map of a warehouse</span></p>
<p><span class="koboSpan" id="kobo.416.1">Since this is the second edition of the book, we will be using ROS 2, the new and improved version of ROS. </span><span class="koboSpan" id="kobo.416.2">One of the most frustrating things about the old ROS was the use of </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">ROSCORE</span></strong><span class="koboSpan" id="kobo.418.1">, a traffic cop that connected all of the parts of the robot via the network. </span><span class="koboSpan" id="kobo.418.2">That is now gone, and the various components can find each other via a different sort </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.419.1">of service, called </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Distributed Data Services</span></strong><span class="koboSpan" id="kobo.421.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.422.1">DDS</span></strong><span class="koboSpan" id="kobo.423.1">). </span><span class="koboSpan" id="kobo.423.2">We will also need to use Python 3 instead of Python 2 for our code since Python 2 has been discontinued and is no </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">longer supported.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.425.1">Hardware and software setup</span></h1>
<p><span class="koboSpan" id="kobo.426.1">To match the </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.427.1">examples in this book, and to have access to the same tools that are used in the code samples, you will have to set up </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">three environments:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.429.1">A laptop or desktop computer</span></strong><span class="koboSpan" id="kobo.430.1">: This will run our control panel, and also be used to </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.431.1">train neural networks. </span><span class="koboSpan" id="kobo.431.2">I used a Windows 10 computer with Oracle VirtualBox supporting a virtual machine running Ubuntu 20.04. </span><span class="koboSpan" id="kobo.431.3">You may run a computer running Ubuntu or another Linux operating system by itself (without Windows) if you want. </span><span class="koboSpan" id="kobo.431.4">Several of the AI packages we will use in the tutorial sections of the book will require Ubuntu to run. </span><span class="koboSpan" id="kobo.431.5">We will load ROS 2 on this computer. </span><span class="koboSpan" id="kobo.431.6">I will also be using a PlayStation game controller on this computer for teleoperation (remote control) of the robot when we teach the robot how to navigate. </span><span class="koboSpan" id="kobo.431.7">I also have ROS 2 for Windows installed, which may obviate running the virtual machine. </span><span class="koboSpan" id="kobo.431.8">Either approach will work, since the Python programs we will use for control run in </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">either mode.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.433.1">Nvidia Jetson Nano 8GB</span></strong><span class="koboSpan" id="kobo.434.1">: This also runs Ubuntu Linux 20.04 (you can also run </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.435.1">other Linux versions, but you will have to make any adjustments between those versions yourself). </span><span class="koboSpan" id="kobo.435.2">The Nano also runs ROS 2. </span><span class="koboSpan" id="kobo.435.3">We will cover the additional libraries we need in the </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">following sub-sections.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.437.1">Arduino Mega 256</span></strong><span class="koboSpan" id="kobo.438.1">: We need to be able to create code for the Arduino. </span><span class="koboSpan" id="kobo.438.2">I’m using the </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.439.1">regular Arduino IDE from the Arduino website. </span><span class="koboSpan" id="kobo.439.2">It can be run on Windows or Linux. </span><span class="koboSpan" id="kobo.439.3">We will be using the Arduino to control the motors on the robot base and drive it around. </span><span class="koboSpan" id="kobo.439.4">It also gives us a lot of expansion to add additional controls, such as an emergency </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">stop button.</span></span></li>
</ul>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.441.1">Preparing the laptop</span></h2>
<p><span class="koboSpan" id="kobo.442.1">You will </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.443.1">need to install ROS 2 for Windows </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.444.1">for the robot control software to work. </span><span class="koboSpan" id="kobo.444.2">To do this, you can follow the instructions provided </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">at </span></span><a href="https://docs.ros.org/en/foxy/Installation/Windows-Install-Binary.html"><span class="No-Break"><span class="koboSpan" id="kobo.446.1">https://docs.ros.org/en/foxy/Installation/Windows-Install-Binary.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.447.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">I also used </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">Virtual Network Computing</span></strong><span class="koboSpan" id="kobo.450.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.451.1">VNC</span></strong><span class="koboSpan" id="kobo.452.1">) to talk to my Nano from the laptop, which </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.453.1">saves a lot of time and fiddling with cables and keyboards. </span><span class="koboSpan" id="kobo.453.2">Otherwise, you would need to connect the Nano to a monitor, keyboard, and mouse to be able to work on your code that is on the robot. </span><span class="koboSpan" id="kobo.453.3">I used </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">RealVNC</span></strong><span class="koboSpan" id="kobo.455.1">, which can </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.456.1">be found at </span><a href="https://www.realvnc.com/en/"><span class="koboSpan" id="kobo.457.1">https://www.realvnc.com/en/</span></a><span class="koboSpan" id="kobo.458.1">. </span><span class="koboSpan" id="kobo.458.2">You can </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.459.1">also use </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">UltraVNC</span></strong><span class="koboSpan" id="kobo.461.1">, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">free software.</span></span></p>
<h3><span class="koboSpan" id="kobo.463.1">Installing Python</span></h3>
<p><span class="koboSpan" id="kobo.464.1">The Linux Ubuntu system will come with a default version of Python. </span><span class="koboSpan" id="kobo.464.2">I am going to assume that </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.465.1">you are familiar with Python, as we will be using it throughout the book. </span><span class="koboSpan" id="kobo.465.2">If you need help with Python, Packt has several fine books on </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">the subject.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">Once you log </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.468.1">on to your virtual machine, check which version of Python you have by opening a terminal window and typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">python</span></strong><span class="koboSpan" id="kobo.470.1"> in the command prompt. </span><span class="koboSpan" id="kobo.470.2">You should see the Python version, </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.472.1">
&gt;python
Python 3.8.16 (default, Jan 17 2023, 22:25:28) [MSC v.1916 64 bit (AMD64)]</span></pre> <p><span class="koboSpan" id="kobo.473.1">You can see that I have version 3.8.16 in </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">this case.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">We are going to need several add-on libraries that add on to Python and extend its capabilities. </span><span class="koboSpan" id="kobo.475.2">The first </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.476.1">thing to check is to see if you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">pip</span></strong><span class="koboSpan" id="kobo.478.1"> installed. </span><span class="koboSpan" id="kobo.478.2">This is the </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">Python Installation Package</span></strong><span class="koboSpan" id="kobo.480.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.481.1">PIP</span></strong><span class="koboSpan" id="kobo.482.1">) that loads other packages from the internet to extend Python. </span><span class="koboSpan" id="kobo.482.2">Check to see if you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">pip</span></strong><span class="koboSpan" id="kobo.484.1"> by typing in </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.486.1">
pip</span></pre> <p><span class="koboSpan" id="kobo.487.1">If you get the output </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">No command 'pip' found</span></strong><span class="koboSpan" id="kobo.489.1">, then you need to install Pip. </span><span class="koboSpan" id="kobo.489.2">Enter </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.491.1">
sudo apt-get install python-pip python-dev build-essential
sudo pip install --upgrade pip</span></pre> <p><span class="koboSpan" id="kobo.492.1">Now we </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.493.1">can install the rest of the packages we need. </span><span class="koboSpan" id="kobo.493.2">As a </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.494.1">start, we need the Python math packages </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">numpy</span></strong><span class="koboSpan" id="kobo.496.1">, the scientific Python library </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">scipy</span></strong><span class="koboSpan" id="kobo.498.1">, and the math plotting library </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">matplotlib</span></strong><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">install them:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.502.1">
sudo apt-get install python-numpy python-scipy python-matplotlib python-sympy</span></pre> <p><span class="koboSpan" id="kobo.503.1">I’ll cover the other Python libraries we will use later (OpenCV, scikit-learn, Keras, etc.) as we need them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">appropriate chapters.</span></span></p>
<h3><span class="koboSpan" id="kobo.505.1">Setting up Nvidia Jetson Nano</span></h3>
<p><span class="koboSpan" id="kobo.506.1">For this setup, we will use an image to run Ubuntu 20.04 on our Jetson Nano, which is required </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.507.1">for ROS 2. </span><span class="koboSpan" id="kobo.507.2">One </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.508.1">source for this version </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">is </span></span><a href="https://github.com/Qengineering/Jetson-Nano-Ubuntu-20-image"><span class="No-Break"><span class="koboSpan" id="kobo.510.1">https://github.com/Qengineering/Jetson-Nano-Ubuntu-20-image</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.511.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">The basic steps, which you can follow in the Git repo, are </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.514.1">The first step is to prepare an SD card with the operating system image on it. </span><span class="koboSpan" id="kobo.514.2">I used </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">Imager</span></strong><span class="koboSpan" id="kobo.516.1">, but there are several programs available that will do the job. </span><span class="koboSpan" id="kobo.516.2">You need an SD card with at least 32 GB of space – and keep in mind you are erasing the SD card in this process. </span><span class="koboSpan" id="kobo.516.3">This means that you need a card greater than 32 GB to start with – I used a 64 GB SD card as a 32 GB SD card did not work, contrary to the instructions provided on </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">the website.</span></span></li>
<li><span class="koboSpan" id="kobo.518.1">Follow the directions with your SD card – the Jetson Nano Ubuntu website (</span><a href="https://github.com/jetsonhacks/installROS2"><span class="koboSpan" id="kobo.519.1">https://github.com/jetsonhacks/installROS2</span></a><span class="koboSpan" id="kobo.520.1">) advises us to use a Class 10 memory card with 64 GB of space. </span><span class="koboSpan" id="kobo.520.2">Put the SD card in your reader and start up your disk </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.521.1">imager program. </span><span class="koboSpan" id="kobo.521.2">Double (and triple) check that you pick the right drive letter – you are erasing the disk in that drive. </span><span class="koboSpan" id="kobo.521.3">Select </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.522.1">the disk image you downloaded. </span><span class="koboSpan" id="kobo.522.2">Hit the </span><strong class="bold"><span class="koboSpan" id="kobo.523.1">Write</span></strong><span class="koboSpan" id="kobo.524.1"> button and let the formatter create your disk image on the </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">SD card:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.526.1"><img alt="Figure 2.7 – Imager program to write out disk images on SD cards" src="image/B19846_02_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.527.1">Figure 2.7 – Imager program to write out disk images on SD cards</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.528.1">You can follow the usual setup for setting up your language and keyboard, as well as setting up the network. </span><span class="koboSpan" id="kobo.528.2">I like to use a static IP address for the robot since we will be using it </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">a lot.</span></span></li>
<li><span class="koboSpan" id="kobo.530.1">It is always a good idea to set a new user ID and change the </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">default passwords.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.532.1">Now let’s look at how we can install </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">ROS 2.</span></span></p>
<h3><span class="koboSpan" id="kobo.534.1">Installing ROS 2</span></h3>
<p><span class="koboSpan" id="kobo.535.1">We need </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.536.1">to install ROS 2 on the Jetson Nano. </span><span class="koboSpan" id="kobo.536.2">I used the </span><em class="italic"><span class="koboSpan" id="kobo.537.1">Foxy</span></em><span class="koboSpan" id="kobo.538.1"> version </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.539.1">on my machine. </span><span class="koboSpan" id="kobo.539.2">You can follow the instructions at this </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">link: </span></span><a href="https://github.com/Razany98/ROS-2-installation-on-Jetson-Nano"><span class="No-Break"><span class="koboSpan" id="kobo.541.1">https://github.com/Razany98/ROS-2-installation-on-Jetson-Nano</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.542.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">You will have to set up the sources and point your computer at the ROS 2 repository. </span><span class="koboSpan" id="kobo.543.2">To do this, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.545.1">Set </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">locale</span></strong><span class="koboSpan" id="kobo.547.1"> using </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.548.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">following code:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.550.1">locale</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.551.1">sudo apt update &amp;&amp; sudo apt install locales</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.552.1">sudo locale-gen en_US en_US.UTF-8</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.553.1">sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.554.1">export LANG=en_US.UTF-8</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.555.1">locale</span></strong></pre></li> <li><span class="koboSpan" id="kobo.556.1">Set up </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.557.1">the source repository </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">to use:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.559.1">apt-cache policy | grep universe or</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.560.1">sudo apt install software-properties-common</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.561.1">sudo add-apt-repository universe</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.562.1">sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-release</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.563.1">sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.564.1">echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null</span></strong></pre></li> <li><span class="koboSpan" id="kobo.565.1">Install the </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">ROS packages:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.567.1">sudo apt update</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.568.1">sudo apt upgrade</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.569.1">sudo apt install ros-foxy-desktop</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.570.1">sudo apt install ros-foxy-ros-base</span></strong></pre></li> <li><span class="koboSpan" id="kobo.571.1">Set up </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">the environment:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.573.1">source /opt/ros/foxy/setup.bash</span></strong></pre></li> <li><span class="koboSpan" id="kobo.574.1">Once you </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.575.1">are done, you can check that your </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.576.1">installation comepleted correctly by typing in </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">the following:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.578.1">ros2 topic list</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.579.1">ros2 node list</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.580.1">Before we proceed, let’s take a look at how exactly </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">ROS works.</span></span></p>
<h4><span class="koboSpan" id="kobo.582.1">Understanding how ROS works</span></h4>
<p><span class="koboSpan" id="kobo.583.1">You can </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.584.1">think of ROS as a type of </span><em class="italic"><span class="koboSpan" id="kobo.585.1">middleware</span></em><span class="koboSpan" id="kobo.586.1"> that works to connect different programs together. </span><span class="koboSpan" id="kobo.586.2">It provides </span><strong class="bold"><span class="koboSpan" id="kobo.587.1">Interprocess Communications</span></strong><span class="koboSpan" id="kobo.588.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.589.1">IPC</span></strong><span class="koboSpan" id="kobo.590.1">) between programs so we don’t have to put all of our </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.591.1">functions in one big block of code – we can distribute our robot’s capabilities and develop </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">them independently.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">Each individual </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.594.1">part of a ROS robot control system is called a </span><strong class="bold"><span class="koboSpan" id="kobo.595.1">node</span></strong><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">A node is a single-purpose programming module. </span><span class="koboSpan" id="kobo.596.3">We will have nodes that collect camera images, perform object recognition, or control the robot arm. </span><span class="koboSpan" id="kobo.596.4">With ROS, we can isolate these functions and develop and test </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">them independently.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">The various </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.599.1">nodes (programs) talk to one another via </span><strong class="bold"><span class="koboSpan" id="kobo.600.1">topics</span></strong><span class="koboSpan" id="kobo.601.1">. </span><span class="koboSpan" id="kobo.601.2">A topic is generally used to publish data for other nodes to use. </span><span class="koboSpan" id="kobo.601.3">ROS 2 uses a publish/subscribe mode to move information around the robot. </span><span class="koboSpan" id="kobo.601.4">For example, our camera software node takes images and then publishes that information on a topic called </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">/image_raw</span></strong><span class="koboSpan" id="kobo.603.1">. </span><span class="koboSpan" id="kobo.603.2">This standard message type includes data about the image format, as well as the image itself. </span><span class="koboSpan" id="kobo.603.3">We also publish camera data on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">/camera_info</span></strong><span class="koboSpan" id="kobo.605.1"> topic, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">sensor_msgs/CameraInfo</span></strong><span class="koboSpan" id="kobo.607.1"> format, which is described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">following image:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.609.1"><img alt="Figure 2.8 – ROS 2 nodes, topics, and message types" src="image/B19846_02_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.610.1">Figure 2.8 – ROS 2 nodes, topics, and message types</span></p>
<p><span class="koboSpan" id="kobo.611.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">/camera_info</span></strong><span class="koboSpan" id="kobo.613.1"> topic has a lot of valuable information about the image, or frame, including the timestamp the data was collected and the frame number. </span><span class="koboSpan" id="kobo.613.2">It also provides calibration information to help us understand the geometry of the captured image, which we can use to map pixels to the 3D space around </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">There is </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.616.1">generally an existing or ROS standard message format for whatever you need to convey between components. </span><span class="koboSpan" id="kobo.616.2">I like to use the generic </span><strong class="bold"><span class="koboSpan" id="kobo.617.1">string</span></strong><span class="koboSpan" id="kobo.618.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">std_msgs/String</span></strong><span class="koboSpan" id="kobo.620.1">) on a topic called </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">RobotCmd</span></strong><span class="koboSpan" id="kobo.622.1"> to send general commands, such as mode changes, to the robot from a </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">control application.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">ROS 2 allows us to set </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">parameters</span></strong><span class="koboSpan" id="kobo.626.1"> externally to the node (program). </span><span class="koboSpan" id="kobo.626.2">Each node can have its own list of parameters, and we can set parameters at any time. </span><span class="koboSpan" id="kobo.626.3">These are generally configuration commands that we set once and make our programs more generic and modular. </span><span class="koboSpan" id="kobo.626.4">For example, we may have a parameter for the robot arm that locks the rotation base, so that the arm can only be in front of the camera. </span><span class="koboSpan" id="kobo.626.5">We can create a parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">arm_base_lock</span></strong><span class="koboSpan" id="kobo.628.1">, define it as a Boolean, and use the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.630.1">
ros2 param set /robot_arm arm_base_lock true</span></pre> <p><span class="koboSpan" id="kobo.631.1">This will turn the rotation lock on. </span><span class="koboSpan" id="kobo.631.2">Then we can check this setting </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">with this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.633.1">
ros2 param get /robot_arm arm_base_lock</span></pre> <p><span class="koboSpan" id="kobo.634.1">We get the </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">following reply:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.636.1">
Boolean value is true</span></pre> <p><span class="koboSpan" id="kobo.637.1">Since our robot will be composed of a number of nodes (programs) that all have to be started together, ROS 2 provides the concept of a </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">launch file</span></strong><span class="koboSpan" id="kobo.639.1"> that lets us start all of our programs with </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.640.1">one command. </span><span class="koboSpan" id="kobo.640.2">In ROS 1, launch files were built in </span><strong class="bold"><span class="koboSpan" id="kobo.641.1">YAML</span></strong><span class="koboSpan" id="kobo.642.1"> format. </span><span class="koboSpan" id="kobo.642.2">YAML stands for </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">Yet Another Markup Language</span></strong><span class="koboSpan" id="kobo.644.1">. </span><span class="koboSpan" id="kobo.644.2">In ROS 2 we can use YAML, Python, or </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">eXtensible Markup Language</span></strong><span class="koboSpan" id="kobo.646.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.647.1">XML</span></strong><span class="koboSpan" id="kobo.648.1">) to define </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.649.1">a launch file. </span><span class="koboSpan" id="kobo.649.2">I’m used to creating files in YAML </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.650.1">format, so we will stick to that. </span><span class="koboSpan" id="kobo.650.2">In our launch file, we can start nodes, change parameters, and create namespaces if we need to launch multiple copies of a node (for instance, if we had </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">three cameras).</span></span></p>
<h3><span class="koboSpan" id="kobo.652.1">Virtual Network Computing</span></h3>
<p><span class="koboSpan" id="kobo.653.1">One tool </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.654.1">that I have added to my Jetson Nano is </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">Virtual Network Computing</span></strong><span class="koboSpan" id="kobo.656.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.657.1">VNC</span></strong><span class="koboSpan" id="kobo.658.1">). </span><span class="koboSpan" id="kobo.658.2">This utility, if you are not familiar with it, allows you to see and work with the Nano desktop as if you were connected to it using a keyboard, a mouse, and a monitor. </span><span class="koboSpan" id="kobo.658.3">Since the Nano is physically installed inside the robot that travels </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.659.1">by itself, attaching a keyboard, mouse, and monitor is not often convenient (or possible). </span><span class="koboSpan" id="kobo.659.2">There are many different versions of VNC, which is a standard protocol used amongst many Unix – and non-Unix – operating systems. </span><span class="koboSpan" id="kobo.659.3">The one I used is called </span><strong class="bold"><span class="koboSpan" id="kobo.660.1">Vino</span></strong><span class="koboSpan" id="kobo.661.1">. </span><span class="koboSpan" id="kobo.661.2">You need </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.662.1">two parts: the </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">server</span></strong><span class="koboSpan" id="kobo.664.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">client</span></strong><span class="koboSpan" id="kobo.666.1">. </span><span class="koboSpan" id="kobo.666.2">The server runs on the Nano and basically copies all of the pixels appearing on the screen and sends them out to the Ethernet port. </span><span class="koboSpan" id="kobo.666.3">The client catches all of this data and displays it to you on another computer. </span><span class="koboSpan" id="kobo.666.4">Let’s install the VNC server using the steps on this </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">webpage: </span></span><a href="https://developer.nvidia.com/embedded/learn/tutorials/vnc-setup"><span class="No-Break"><span class="koboSpan" id="kobo.668.1">https://developer.nvidia.com/embedded/learn/tutorials/vnc-setup</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.669.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Load the viewer on your Windows PC, or Linux virtual machine, or do like I did, and load VNC on your Apple iPad. </span><span class="koboSpan" id="kobo.670.2">You will find the ability to log directly into the robot and use the desktop tools to be </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">very helpful.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.672.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.673.1">In order to get VNC to run on the Nano without a monitor attached, you must set the Nano to automatically log itself on. </span><span class="koboSpan" id="kobo.673.2">You can edit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">/etc/gdm3/custom.conf</span></strong><span class="koboSpan" id="kobo.675.1"> file to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">automatic login:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1"># Enabling </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">automatic login</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">AutomaticLoginEnable=true</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">AutomaticLogin=[your username]</span></strong></span></p>
<h3><span class="koboSpan" id="kobo.681.1">Setting up the colcon workspace</span></h3>
<p><span class="koboSpan" id="kobo.682.1">We will </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.683.1">need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">colcon</span></strong><span class="koboSpan" id="kobo.685.1"> workspace </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.686.1">on your development machine—laptop or desktop—as well as on the Jetson Nano. </span><span class="koboSpan" id="kobo.686.2">Follow the instructions </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">at </span></span><a href="https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Colcon-Tutorial.html"><span class="No-Break"><span class="koboSpan" id="kobo.688.1">https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Colcon-Tutorial.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.689.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">If you are already a user of ROS, then you know what a workspace is, and how it is used to create packages that can be used and deployed as a unit. </span><span class="koboSpan" id="kobo.690.2">We are going to keep all of our programs in a package we will </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">albert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.694.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.695.1">This chapter covered several important topics. </span><span class="koboSpan" id="kobo.695.2">It started with some of the basics of robotics, for readers who needed a bit more background. </span><span class="koboSpan" id="kobo.695.3">We talked about common robot parts, such as sensors, computers, and motors/actuators. </span><span class="koboSpan" id="kobo.695.4">We discussed the subsumption architecture in more depth and showed how it helps the robot arbitrate between responding to different events and commands. </span><span class="koboSpan" id="kobo.695.5">The next section covered the software setup for running the robot, including the offboard development environment and the onboard Jetson Nano computer environments. </span><span class="koboSpan" id="kobo.695.6">We set up the ROS and installed the </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">Python tools.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">The final section covered ROS 2 and explained what it is and what it does for us. </span><span class="koboSpan" id="kobo.697.2">ROS 2 is a middleware layer that lets us build modular components and multiple single-use programs, rather than having to lump everything into one executable. </span><span class="koboSpan" id="kobo.697.3">ROS also has logging, visualization, and debugging tools that help our task of designing a complex robot. </span><span class="koboSpan" id="kobo.697.4">ROS 2 is also a wonderful repository of additional capabilities that we can add, including sensor drivers, navigation functions, </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">and controls.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">In the next chapter, we will discuss how to go from a concept to a working plan for developing complex robot AI-based software using systems engineering practices such as use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">and storyboards.</span></span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.701.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.702.1">Name three types of </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">robot sensors.</span></span></li>
<li><span class="koboSpan" id="kobo.704.1">What does the acronym PWM </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">stand for?</span></span></li>
<li><span class="koboSpan" id="kobo.706.1">What is analog-to-digital conversion? </span><span class="koboSpan" id="kobo.706.2">What goes in and what </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">comes out?</span></span></li>
<li><span class="koboSpan" id="kobo.708.1">Who invented the </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">subsumption architecture?</span></span></li>
<li><span class="koboSpan" id="kobo.710.1">Compare my diagram of the three-layer subsumption architecture to the Three Laws of Robotics postulated by Isaac Asimov. </span><span class="koboSpan" id="kobo.710.2">Is there a correlation? </span><span class="koboSpan" id="kobo.710.3">Why is there one, or </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">why not?</span></span><p class="list-inset"><strong class="bold"><span class="koboSpan" id="kobo.712.1">Hint</span></strong><span class="koboSpan" id="kobo.713.1">: Think about how the laws change the behavior of the robot. </span><span class="koboSpan" id="kobo.713.2">Which is the lowest level law (from a subsumption perspective)? </span><span class="koboSpan" id="kobo.713.3">Which is </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">the highest?</span></span></p></li>
<li><span class="koboSpan" id="kobo.715.1">Do you think I should have given our robot project – </span><em class="italic"><span class="koboSpan" id="kobo.716.1">Albert</span></em><span class="koboSpan" id="kobo.717.1"> – a name? </span><span class="koboSpan" id="kobo.717.2">Do you name your robots? </span><span class="koboSpan" id="kobo.717.3">What about your washing machine? </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">Why not?</span></span></li>
<li><span class="koboSpan" id="kobo.719.1">What is the importance of the environment </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">variable </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">ROS_ROOT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">?</span></span></li>
</ol>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.723.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.724.1">Scripts to install ROS 2 on Jetson </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">Nano: </span></span><a href="https://github.com/jetsonhacks/installROS2"><span class="No-Break"><span class="koboSpan" id="kobo.726.1">https://github.com/jetsonhacks/installROS2</span></span></a></li>
<li><span class="koboSpan" id="kobo.727.1">Helpful troubleshooting in case you have problems with your ROS 2 installation can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">at </span></span><a href="https://docs.ros.org/en/rolling/How-To-Guides/Installation-Troubleshooting.html"><span class="No-Break"><span class="koboSpan" id="kobo.729.1">https://docs.ros.org/en/rolling/How-To-Guides/Installation-Troubleshooting.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.730.1">ROS 2 </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">documentation: </span></span><a href="https://docs.ros.org/en/foxy/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.732.1">https://docs.ros.org/en/foxy/index.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.733.1">Dr. </span><span class="koboSpan" id="kobo.733.2">Rodney Brooks’s paper on the subsumption </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">architecture: </span></span><a href="https://people.csail.mit.edu/brooks/papers/AIM-864.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.735.1">https://people.csail.mit.edu/brooks/papers/AIM-864.pdf</span></span></a></li>
</ul>
</div>
</body></html>