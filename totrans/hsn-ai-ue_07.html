<html><head></head><body>
        

                            
                    <h1 class="header-title">Extending Behavior Trees</h1>
                
            
            
                
<p><em>Empowering a tree with more leaves and branches will make it unstoppable.</em></p>
<p> </p>
<p>In this chapter, we will understand how to extend <em>Behavior Trees</em> by implementing our custom <strong>Tasks</strong>, <strong>Decorators</strong>, and <strong>Services</strong>.</p>
<p>Since in chapters 8, 9, and 10 we are going to create a concrete example of a <em>Behavior Tree</em> from scratch and create custom <em>Tasks</em>, <em>Decorators</em>, and <em>Services</em>, you can look at this chapter as a quick theoretical introduction to those chapters in order to give you a ground base for extending <em>Behavior Trees</em>. Thus, this chapter might be super fluid and repetitive, but it will teach you about a great tool, which we will refine later in this book in a more playful way.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to create a <strong><em>Task</em></strong>, both in <em>Blueprint and C++</em>, to make our AI agent capable of executing custom actions.</li>
<li>How to create a <strong><em>Decorator</em></strong>, both in <em>Blueprint and C++</em>, to create specific conditions that we can enter in certain sub-branches of the <em>Behavior Tree</em></li>
<li>How to create a <strong><em>Service</em></strong>, both in <em>Blueprint and C++</em>, to continuously update the data in our <em>Blackboard</em> for the <em>Behavior Tree</em></li>
<li>How to create <em>Composite nodes</em>, <em>new types of nodes</em>, or even <em>new trees</em></li>
</ul>
<p>So, let's dive in!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A quick recap on Behavior Trees</h1>
                
            
            
                
<p>Here is a quick recap on <strong>Behaviors Trees</strong> to refresh you.</p>
<p>A <strong>Behavior Tree</strong> is a structure for decision-making which uses a <em>Blackboard</em> as its memory. In particular, the flow starts from a special node called the <strong>Root</strong>, all the way down to the leaves, which are called Tasks. A <strong>Task</strong> is a single action that the AI can take/perform.</p>
<p>Then, all the nodes that are non-leaves (or the root) are <strong>Composite</strong>. A composite node chooses which one of the children to execute. The two main <strong>Composite</strong> nodes are <em><strong>Sequence</strong></em> (which tries to execute all the sequences of its children in order, and if they succeed, it reports a success back, otherwise it reports a fail) and <em><strong>Selector</strong></em> (which tries each child until it finds one that succeeds and reports a success or all of them fail and it reports a fail).</p>
<p>Both <strong>Composite</strong> and <strong>Tasks</strong> nodes can use <strong>Decorators</strong> (which impose conditions that must be true so that you can choose that node) or <strong>Services</strong> on top (a continuously running piece of code, e.g. what's used to set Blackboard values).</p>
<p>If you still have some doubts, please revise <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a>, <em>Behavior Trees and Blackboards</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Task</h1>
                
            
            
                
<p>Deep diving into the concepts we looked at earlier, back in <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml"/><a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a>, <em>Behavior Trees and Blackboards</em>, a <strong><em>Task</em></strong> is a single action that our AI Agent can perform. Some examples include walking to a specific location, performing/running an EQS, locating something, chasing the players, etc. All of these actions can either fail or succeed. The final result of a task is then carried back on the <em>Behavior Tree</em>, with rules we have seen for Selectors and Sequences.</p>
<p>A task doesn't necessarily have to be executed in a frame, but it can be extended indefinitely. In fact, a Task is not finished until it reports with either a <em>Failure</em> or a <em>Success</em>. However, they can be interrupted/aborted by external nodes, such as a <em>Decorator</em>.</p>
<p>When you create a Task, regardless of whether this is done in Blueprint or C++, you will need to override some functions. Since Blueprint is easier, and share the same concepts that we use in C++, we will first look at how the system works in Blueprint.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Blueprint Task</h1>
                
            
            
                
<p>To create a <strong><em>Blueprint Task</em></strong>, we have a few options available to us. The easiest one is in the <em>Behavior Tree Editor</em>, in which we press the "<strong><em>New Task</em></strong>" button in the top bar, as shown in the following screenshot: </p>
<p class="CDPAlignCenter CDPAlign"><br/>
<img src="img/da0c1058-4cb4-4104-bba6-7b559850a1ff.png" style="width:29.58em;height:5.75em;"/></p>
<p>However, you will need to manually rename the file and place it in the folder that you wish it to be in.</p>
<p>Another way to create a Task is to create a new Blueprint that inherits from <strong><em>BTTask_BlueprintBase</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4aceb3ad-af67-4eb2-8b2b-209c41de92d1.png" style="width:32.92em;height:32.75em;"/></p>
<p>The convention is to prefix the Tasks with "<em>BBTask_</em>" (which stands for <em>Behavior Tree Task</em>). For instance, we could call our Task something like <em>BTTask_BPMyFirstTask</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1bb229e7-b40e-49e8-ad4a-fab724aaf32f.png" style="width:6.42em;height:9.50em;"/></p>
<p>Once a <em>Blueprint Task</em> has been created, there are three type functions that we can override:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7f1ba58f-6c0f-40c9-86d1-087b3541d714.png" style="width:18.75em;height:18.67em;"/></p>
<ul>
<li><strong>Receive Execute</strong>: This is called when the <em>Task</em> starts, and here you should implement all the initialization for your task.</li>
<li><strong>Receive Tick</strong>: This is called every time the Task ticks, and so you can use it to continuously do something. However, since there might be many agents executing many <em>Behaviors Trees</em>, it would be advisable to keep this Tick function as short as possible or not implement it at all (for performance reasons), and use either timers or delegates to handle the task.</li>
<li><strong>Receive Abort</strong>: This is called every time that the Task is executing, but the <em>Behavior Tree</em> requested to abort it. You need to use this function to clean up your tasks (e.g. restore some Blackboard values).</li>
</ul>
<p>In Blueprint, these three functions exist in two forms, <strong><em>AI</em></strong> and <strong><em>non-AI</em></strong>, and are also known as being <em>generic</em> (e.g. <em>Receive Execute</em> and <em>Receive Execute AI</em>). There is not much difference between them. If only one is implemented (as a suggestion, implement the AI version to keep your project consistent), that is the function that is called. Otherwise, the most convenient will be called, which means that the AI version is called when the Pawn is possessed by an <em>AI Controller</em>, and the <em>non-AI</em> version is called in all the other cases. Of course, most of your cases would be that the <em>Behavior Tree</em> is running on top of an <em>AI Controller</em>, so the <em>non-AI</em> version is for very specific and rarer cases.</p>
<p>So far, the system has no way of understanding when a <em>Task</em> has finished its execution or has finished to clean up after an abort. For this reason, there are two functions you will need to call:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3343947a-a17c-4fb1-b240-9f88833757df.png" style="width:17.33em;height:20.42em;"/></p>
<ul>
<li><strong>Finish Execute</strong>: This will indicate that the <em>Task</em> has finished its execution. It has a Boolean parameter to indicate whether the <em>Task</em> has <strong><em>succeeded</em></strong> (<strong><em>true</em></strong> value) or <strong><em>failed</em></strong> (<strong><em>false</em></strong> value).</li>
<li><strong>Finish Abort</strong>: This will indicate that the <em>Task</em> has finished to abort. It has no parameters.</li>
</ul>
<p class="mce-root">Please note that if you don't call these two functions, the task will hang there forever, which is not a desired behavior. Although it would be advisable to call the Finish Abort function at the end of the <em>Receive Abort</em> event, there are cases in which you will need more than one frame to clean up. In this case, you can call the <em>Finish Abort</em> somewhere else (e.g. in a delegate).</p>
<p>There are also other ways to finish executing a Task, for example, by using AI Messages, but we will not cover them in this book.</p>
<p>This is all you need to know to create a <em>Task</em>. You just create the graph that you want, and remember to call the <em>Finish Execute</em> node when you are done (either with a <em>Success</em> or a <em>Fail</em>). We will look at a concrete example of creating a new Task in the following three chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Task in C++</h1>
                
            
            
                
<p>The concept of creating a <strong><em>Task in C++</em></strong> share the same concepts as its Blueprint counterpart.</p>
<p>First all of, to create a new C++ Task, we need to create a C++ class that inherits from <strong><em>BTTaskNode</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3e6ad68c-8037-42f2-b501-8840f3db93e6.png" style="width:44.17em;height:33.67em;"/></p>
<p>Just like for a Blueprint Task, the convention is to prefix the <em>Task</em> with "<strong><em>BTTask_</em></strong>" (<em>Behavior Tree Task</em>). Therefore, we could name our Task something like "<em>BTTask_MyFirstTask</em>":</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/98a53e83-5688-461c-8c6c-c6654cf30a38.png"/></p>
<p>Once you have created the <em>Task</em>, you need to override some functions, which have very similar functionalities to the ones in Blueprint. However, there are some differences.</p>
<p>One of the main differences is how to report that the Task has finished its execution (or has finished to abort). For these cases, there is a special enum structure called <kbd>EBTNodeResult</kbd>. It needs to be returned by a function so that the <em>Behavior Tree</em> "<em>knows</em>" if it needs to keep calling the Task or not. This structure can have four values:</p>
<ul>
<li><strong>Succeeded</strong>: The Tasks finishes with a success</li>
<li><strong>Failed</strong>: The Tasks finishes with a failure</li>
<li><strong>Aborted</strong>: The Task has aborted</li>
<li><strong>InProgress</strong>: The Task hasn't finished yet</li>
</ul>
<p>Another difference lies in the fact that the twin of the Blueprint <em>Receive Execute</em> has to finish and thus it needs to return a <kbd>EBTNodeResult</kbd> structure to communicate and state whether the task has finished or whether it needs more than one frame. If so, other functions are then called, as we will see.</p>
<p>Moreover, in C++, there are other special concepts and structures that you can use that in Blueprint you cannot. For example, you have access to <kbd>NodeMemory</kbd>, which holds a specific memory for the Task that has been executed. For the correct use of this structure, watch the engine source code, and in particular, the file that's suggested at the end of this section.</p>
<p>The last difference is that there are not the <em>AI</em> and the <em>non-AI</em> (G<em>eneric</em>) versions of the functions. You will have to determine by yourself if you have an AI controller and what to do (if you do anything).</p>
<p>The functions to are as follows (this has been taken directly from the source code of the engine, with the two most important functions in bold):</p>
<pre><br/>   /** starts this task, should return Succeeded, Failed or InProgress<br/>   * (use FinishLatentTask() when returning InProgress)<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/><strong>  virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory);</strong><br/><br/>protected:<br/>  /** aborts this task, should return Aborted or InProgress<br/>   * (use FinishLatentAbort() when returning InProgress)<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/><strong>  virtual EBTNodeResult::Type AbortTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory);</strong><br/><br/>public:<br/>#if WITH_EDITOR<br/>  virtual FName GetNodeIconName() const override;<br/>#endif // WITH_EDITOR<br/>  virtual void OnGameplayTaskDeactivated(UGameplayTask&amp; Task) override;<br/><br/>  /** message observer's hook */<br/>  void ReceivedMessage(UBrainComponent* BrainComp, const FAIMessage&amp; Message);<br/><br/>  /** wrapper for node instancing: ExecuteTask */<br/>  EBTNodeResult::Type WrappedExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) const;<br/><br/>  /** wrapper for node instancing: AbortTask */<br/>  EBTNodeResult::Type WrappedAbortTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) const;<br/><br/>  /** wrapper for node instancing: TickTask */<br/>  void WrappedTickTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds) const;<br/><br/>  /** wrapper for node instancing: OnTaskFinished */<br/>  void WrappedOnTaskFinished(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, EBTNodeResult::Type TaskResult) const;<br/><br/>  /** helper function: finish latent executing */<br/>  void FinishLatentTask(UBehaviorTreeComponent&amp; OwnerComp, EBTNodeResult::Type TaskResult) const;<br/><br/>  /** helper function: finishes latent aborting */<br/>  void FinishLatentAbort(UBehaviorTreeComponent&amp; OwnerComp) const;<br/><br/>  /** @return true if task search should be discarded when this task is selected to execute but is already running */<br/>  bool ShouldIgnoreRestartSelf() const;<br/><br/>  /** service nodes */<br/>  UPROPERTY()<br/>  TArray&lt;UBTService*&gt; Services;<br/><br/>protected:<br/><br/>  /** if set, task search will be discarded when this task is selected to execute but is already running */<br/>  UPROPERTY(EditAnywhere, Category=Task)<br/>  uint32 bIgnoreRestartSelf : 1;<br/><br/>  /** if set, TickTask will be called */<br/>  uint32 bNotifyTick : 1;<br/><br/>  /** if set, OnTaskFinished will be called */<br/>  uint32 bNotifyTaskFinished : 1;<br/>  <br/>  /** ticks this task <br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void TickTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds);<br/><br/>  /** message handler, default implementation will finish latent execution/abortion<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void OnMessage(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, FName Message, int32 RequestID, bool bSuccess);<br/><br/>  /** called when task execution is finished<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void OnTaskFinished(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, EBTNodeResult::Type TaskResult);<br/><br/>  /** register message observer */<br/>  void WaitForMessage(UBehaviorTreeComponent&amp; OwnerComp, FName MessageType) const;<br/>  void WaitForMessage(UBehaviorTreeComponent&amp; OwnerComp, FName MessageType, int32 RequestID) const;<br/>  <br/>  /** unregister message observers */<br/>  void StopWaitingForMessages(UBehaviorTreeComponent&amp; OwnerComp) const;</pre>
<p>As you can see, there's quite a lot of code, and it might be a bit confusing at first. However, if you have understood Blueprint well, making the jump to understand the C++ functions should be much easier. For instance, the <kbd>ExecuteTask()</kbd> function starts the execution of the task, but it doesn't complete it if it returns that the Task is still in progress.</p>
<p>Here is a comment from the Engine Source code, which might help clarify this a bit:</p>
<pre>/** <br/> * Task are leaf nodes of behavior tree, which perform actual actions<br/> *<br/> * Because some of them can be instanced for specific AI, following virtual functions are not marked as const:<br/> * - ExecuteTask<br/> * - AbortTask<br/> * - TickTask<br/> * - OnMessage<br/> *<br/> * If your node is not being instanced (default behavior), DO NOT change any properties of object within those functions!<br/> * Template nodes are shared across all behavior tree components using the same tree asset and must store<br/> * their runtime properties in provided NodeMemory block (allocation size determined by GetInstanceMemorySize() )<br/> *<br/> */</pre>
<p>The two best ways that I know of to get a better feeling of how to create a C++ Task is to either create one yourself, or read the source code of other Tasks. For instance, you can read the code in the <kbd>BTTask_MoveTo.cpp</kbd> file within the engine source for a complete example on how to create a C++ Task. Don't be discouraged, because using C++ is awesome!</p>
<p>In any case, we will go through the process of creating a C++ Task from scratch in the following three chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Decorator</h1>
                
            
            
                
<p>Recalling from <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a><em>, Behavior Trees and Blackboards</em>, a <strong><em>Decorator</em></strong> is a conditional node (which can also be seen as a gate) that controls the execution flow of the sub-branch that it is attached to (if the execution would enter in the sub-branch in the first place).</p>
<p>In a similar fashion on how we <em>extended/created</em> a <em>Task</em>, we can <em>extend/create</em> a <strong><em>Decorator</em></strong>. Once again, we will first dive into how to do it in Blueprint, and then move on to how to extend it in C++.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Decorator in Blueprint</h1>
                
            
            
                
<p>To create a <strong><em>Blueprint </em></strong><strong><em>Decorator</em></strong>, like we did for <em>Tasks</em>, you can press the "<strong><em>New Decorator</em></strong>" button in the top bar of the <em>Behavior Tree Editor</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/95acded1-f9f6-4e78-bf7e-a1091c192aab.png" style="width:31.25em;height:6.17em;"/></p>
<p>Alternatively, you can generate the <em>Blueprint</em> class that inherits from <strong><em>BTDecorator_BlueprintBase</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3224587e-daa9-4311-ae3b-4200c68086e5.png" style="width:38.08em;height:39.25em;"/></p>
<p>In any case, the naming convention is to prefix the <em>Decorator</em> with "<strong><em>BTDecorator_</em></strong>" (which stands for <em>Behavior Tree Decorator</em>). For instance, we can call our class something like <em>BTDecorator_BPMyFirstDecorator</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fbc9a933-225f-40c2-96f5-6631c0540466.png" style="width:6.08em;height:9.17em;"/></p>
<p>As for Tasks, all the <em>overridable</em> functions come in two flavors: <em>AI</em> and <em>non-AI</em>. The concept is exactly the same. If only one of them is implemented (to keep your project consistent, it is advisable to override the AI version), then that function is called. If both are implemented, the <em>AI</em> is called when the Pawn is possessed by the AI Controller, and the <em>non-AI</em> function instead in all the other cases.</p>
<p>Here are the six functions that a <em>Decorator</em> can extend:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7f8880f6-c133-447a-9c0e-bd6b2a55df49.png" style="width:24.75em;height:29.08em;"/></p>
<ul>
<li><strong>Perform Condition Check</strong>: This is the most important function and the only one you might need to override (if you don't have dynamic things to handle). It has a return value of a bool, which indicates whether the conditional check has succeeded or not.</li>
<li><strong>Receive Execution Start</strong>: This is called when the execution of the underlying node (either a Composite or a Task) starts. Use this to initialize the decorator.</li>
<li><strong>Receive Execution Finish</strong>: This is called when the execution of the underlying node (either a Composite or a Task) is finished. Use this to clean up the decorator.</li>
<li><strong>Receive Tick</strong>: This is the Tick function, in case you need to continuously update something. Performance-wise, is not advisable to use it for heavy operation, but it's even better if it's not used at all (e.g. use timers or delegates).</li>
<li><strong>Receive Observer Activated</strong>: As the name suggests, it is called when the Observer is activated.</li>
<li><strong>Receive Observer Deactivated</strong>: As the name suggests, it is called when the Observer is deactivated.</li>
</ul>
<p>As you can see, <em>Decorators</em> are pretty easy (at least in Blueprint); mainly, you only need to <em>override/implement</em> the <em>Perform Condition Check</em> function, which returns a boolean value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/568ad0bc-c704-447c-a3d8-2e978eac9f11.png" style="width:31.08em;height:10.42em;"/></p>
<p>In any case, we will look at a concrete example of creating a <em>Blueprint Decorator</em> from scratch in the following three chapters.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Decorator in C++</h1>
                
            
            
                
<p>In a very similar fashion to how we extended a <em>Task</em> in C++, you can extend a <strong><em>Decorator in C++</em></strong> as well. The base class to inherit from is <strong><em>BTDecorator</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3effa149-b0b5-4253-8507-dcacdcae57a0.png" style="width:55.92em;height:42.00em;"/></p>
<p>The convention, as usual, is to prefix the <em>Decorator</em> with "<strong><em>BTDecorator_</em></strong>" (<em>Behavior Tree Decorator</em>). A possible name for our <em>Decorator</em> could be "<em>BTDecorator_MyFirstDecorator</em>":</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0d68be21-df09-4423-83c8-889b37ec5a3b.png"/></p>
<p>Diving directly into C++, these are the overridable functions, as taken from the Engine Source code (there are quite a lot):</p>
<pre><br/>   /** wrapper for node instancing: CalculateRawConditionValue */<br/>  bool WrappedCanExecute(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) const;<br/><br/>  /** wrapper for node instancing: OnNodeActivation */<br/>  void WrappedOnNodeActivation(FBehaviorTreeSearchData&amp; SearchData) const;<br/>  <br/>  /** wrapper for node instancing: OnNodeDeactivation */<br/>  void WrappedOnNodeDeactivation(FBehaviorTreeSearchData&amp; SearchData, EBTNodeResult::Type NodeResult) const;<br/><br/>  /** wrapper for node instancing: OnNodeProcessed */<br/>  void WrappedOnNodeProcessed(FBehaviorTreeSearchData&amp; SearchData, EBTNodeResult::Type&amp; NodeResult) const;<br/><br/>  /** @return flow controller's abort mode */<br/>  EBTFlowAbortMode::Type GetFlowAbortMode() const;<br/><br/>  /** @return true if condition should be inversed */<br/>  bool IsInversed() const;<br/><br/>  virtual FString GetStaticDescription() const override;<br/><br/>  /** modify current flow abort mode, so it can be used with parent composite */<br/>  void UpdateFlowAbortMode();<br/><br/>  /** @return true if current abort mode can be used with parent composite */<br/>  bool IsFlowAbortModeValid() const;<br/><br/>protected:<br/><br/>  /** if set, FlowAbortMode can be set to None */<br/>  uint32 bAllowAbortNone : 1;<br/><br/>  /** if set, FlowAbortMode can be set to LowerPriority and Both */<br/>  uint32 bAllowAbortLowerPri : 1;<br/><br/>  /** if set, FlowAbortMode can be set to Self and Both */<br/>  uint32 bAllowAbortChildNodes : 1;<br/><br/>  /** if set, OnNodeActivation will be used */<br/>  uint32 bNotifyActivation : 1;<br/><br/>  /** if set, OnNodeDeactivation will be used */<br/>  uint32 bNotifyDeactivation : 1;<br/><br/>  /** if set, OnNodeProcessed will be used */<br/>  uint32 bNotifyProcessed : 1;<br/><br/>  /** if set, static description will include default description of inversed condition */<br/>  uint32 bShowInverseConditionDesc : 1;<br/><br/>private:<br/>  /** if set, condition check result will be inversed */<br/>  UPROPERTY(Category = Condition, EditAnywhere)<br/>  uint32 bInverseCondition : 1;<br/><br/>protected:<br/>  /** flow controller settings */<br/>  UPROPERTY(Category=FlowControl, EditAnywhere)<br/>  TEnumAsByte&lt;EBTFlowAbortMode::Type&gt; FlowAbortMode;<br/><br/>  void SetIsInversed(bool bShouldBeInversed);<br/><br/>  /** called when underlying node is activated<br/>    * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void OnNodeActivation(FBehaviorTreeSearchData&amp; SearchData);<br/><br/>  /** called when underlying node has finished<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void OnNodeDeactivation(FBehaviorTreeSearchData&amp; SearchData, EBTNodeResult::Type NodeResult);<br/><br/>  /** called when underlying node was processed (deactivated or failed to activate)<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void OnNodeProcessed(FBehaviorTreeSearchData&amp; SearchData, EBTNodeResult::Type&amp; NodeResult);<br/><br/>  /** calculates raw, core value of decorator's condition. Should not include calling IsInversed */<br/>  virtual bool CalculateRawConditionValue(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) const;<br/><br/>  /** more "flow aware" version of calling RequestExecution(this) on owning behavior tree component<br/>   * should be used in external events that may change result of CalculateRawConditionValue */<br/>  void ConditionalFlowAbort(UBehaviorTreeComponent&amp; OwnerComp, EBTDecoratorAbortRequest RequestMode) const;</pre>
<p>Moreover, in the Engine Source code, we can find the following comment, which explains a couple of implementation choices:</p>
<pre>/** <br/> * Decorators are supporting nodes placed on parent-child connection, that receive notification about execution flow and can be ticked<br/> *<br/> * Because some of them can be instanced for specific AI, following virtual functions are not marked as const:<br/> *  - OnNodeActivation<br/> *  - OnNodeDeactivation<br/> *  - OnNodeProcessed<br/> *  - OnBecomeRelevant (from UBTAuxiliaryNode)<br/> *  - OnCeaseRelevant (from UBTAuxiliaryNode)<br/> *  - TickNode (from UBTAuxiliaryNode)<br/> *<br/> * If your node is not being instanced (default behavior), DO NOT change any properties of object within those functions!<br/> * Template nodes are shared across all behavior tree components using the same tree asset and must store<br/> * their runtime properties in provided NodeMemory block (allocation size determined by GetInstanceMemorySize() )<br/> *<br/> */</pre>
<p>Unfortunately, we don't have the time to go through all of them in detail, but most of them are very intuitive, and so it shouldn't be hard for you to understand their meaning. In any case, we will look at a concrete example of how to create a <strong><em>C++ Decorator</em></strong> from scratch (and we will be using many of these functions) in the next three chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Service</h1>
                
            
            
                
<p>Recalling from <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a><em>, Behavior Trees and Blackboards</em>, a <strong><em>Service</em></strong> is a node that runs constantly if attached to one of the parents of the sub-branch. The main use of this node is to update the data in the <em>Blackboard</em> for the <em>Behavior Tree</em>, and it is among the nodes that you will need to create since they are very specific to your Gameplay.</p>
<p>In a similar fashion to how we extended both Tasks and <em>Decorators</em>, we can also <em>extend/create</em> <strong><em>Services</em></strong> as well. We will go through how to implement the extension in Blueprint first, and then understand how to do it in C++ as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Service in Blueprint</h1>
                
            
            
                
<p>Just like you did for <em>Tasks</em> and <em>Decorators</em>, you can create a new <strong><em>Blueprint Service</em></strong> by pressing the <strong><em>New Service</em></strong> button on the top bar of the <em>Behavior Tree Editor</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/177b1552-524f-4249-98d7-bf5679bb6163.png"/></p>
<p>Alternatively, you can generate the <em>Blueprint</em> class that inherits from <strong><em>BTService_BlueprintBase</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/88357201-1e22-4ac7-9f2c-a8093f501756.png" style="width:35.92em;height:37.67em;"/></p>
<p>In any case, the naming convention is to prefix the <em>Service</em> with "<strong><em>BTService_</em></strong>" (which stands for <em>Behavior Tree Service</em>). For instance, we can call our class something like <em>BTService_BPMyFirstService</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7169615a-8396-4d62-b6ac-5cc016dd706e.png"/></p>
<p>Just like the <em>Tasks</em> and <em>Decorators</em>, all the <em>overridable</em> functions come in two different versions: AI and <em>non-AI</em> (<em>Generic</em>). The concept is exactly the same: if only one of them is implemented (to keep your project consistent, it is advisable to override the AI version), then that function is called. If both are implemented, the AI is called when the Pawn is possessed by the AI Controller, otherwise the generic function is called instead.</p>
<p>Here there are the four <em>overridable</em> functions:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/18ec6bbb-d361-4378-b833-e77d6f20ab76.png" style="width:25.67em;height:26.33em;"/></p>
<ul>
<li><strong>Receive Activation</strong>: This is called when the <em>Service</em> becomes active. Use it to initialize the <em>Service</em>.</li>
<li><strong>Receive Tick</strong>: This is called when the Service ticks. Mainly, a <em>Service</em> does something continuously (e.g. update a <em>Blackboard</em> variables), and so this is the most important function for the service. Performance-wise, it would be advisable to keep it as short as possible. Moreover, back to the <em>Behavior Tree</em>, it is possible to adjust how often a Service ticks (with a random value between min and max). However, the implementation, in theory, should not be aware of how often the Service ticks; it just needs to offer a "<em>service"</em>. Then, the user of the service, the <em>Behavior Tree</em>, will decide how often it wants this service.</li>
<li><strong>Receive Search Start</strong>: This is a special case in which the service is active (so you should have initialized the service, but in theory, the service should not have performed anything yet). This function is called before a <em>Task/Node</em> is searched. In fact, a <em>Behavior Tree</em> needs to evaluate which <em>Task</em> or <em>Node</em> to pick next to execute. In doing so, the <em>Behavior Tree</em> checks the conditions of the decorators on top of the possible <em>Tasks</em> or <em>Nodes</em>. As a result, in this function, you can adjust values before the next <em>Task</em> or <em>Node</em> is searched, and therefore choose something that influences the choice into being the correct one.</li>
<li><strong>Receive Deactivation</strong>: This is called when the service becomes inactive. Use it to clean up the Service.</li>
</ul>
<p>Mainly, you will need to implement your logic in the <strong><em>Receive Tick</em></strong> function, so that you can constantly update the information in the Blackboard. A <em>Service</em> is a layer between the Behavior Tree and the game world.</p>
<p>We will implement a <em>Blueprint Service</em> during the course of the next three chapters, in which we will face a much more practical and concrete example.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Service in C++</h1>
                
            
            
                
<p>In a very similar fashion to how we extended <em>Tasks</em> and <em>Decorators</em> in C++, you can extend <strong><em>Services in C++</em></strong> as well. The base class to inherit from is <strong><em>BTService</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b210ca98-7182-45b1-894c-d22f8aa78633.png"/></p>
<p>The convention is to prefix the Service class name with "<strong><em>BTService_</em></strong>" (<em>Behavior Tree Service</em>).  A possible name for our class could be <em>BTService_MyFirstService</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/063bee02-8793-4140-95eb-0c5d152e5cef.png"/></p>
<p>Once we have created the <strong><em>Service in C++</em></strong>, the rest is done in a really similar fashion to e<em>xtending/creating</em> a <em>Decorator</em> in C++. Here there are the functions to override (taken from the Engine Source Code):</p>
<pre>virtual FString GetStaticDescription() const override;<br/><br/>  void NotifyParentActivation(FBehaviorTreeSearchData&amp; SearchData);<br/><br/>protected:<br/><br/>  // Gets the description of our tick interval<br/>  FString GetStaticTickIntervalDescription() const;<br/><br/>  // Gets the description for our service<br/>  virtual FString GetStaticServiceDescription() const;<br/><br/>  /** defines time span between subsequent ticks of the service */<br/>  UPROPERTY(Category=Service, EditAnywhere, meta=(ClampMin="0.001"))<br/>  float Interval;<br/><br/>  /** adds random range to service's Interval */<br/>  UPROPERTY(Category=Service, EditAnywhere, meta=(ClampMin="0.0"))<br/>  float RandomDeviation;<br/><br/>  /** call Tick event when task search enters this node (SearchStart will be called as well) */<br/>  UPROPERTY(Category = Service, EditAnywhere, AdvancedDisplay)<br/>  uint32 bCallTickOnSearchStart : 1;<br/><br/>  /** if set, next tick time will be always reset to service's interval when node is activated */<br/>  UPROPERTY(Category = Service, EditAnywhere, AdvancedDisplay)<br/>  uint32 bRestartTimerOnEachActivation : 1;<br/><br/>  /** if set, service will be notified about search entering underlying branch */<br/>  uint32 bNotifyOnSearch : 1;<br/><br/>  /** update next tick interval<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;<br/><br/>  /** called when search enters underlying branch<br/>   * this function should be considered as const (don't modify state of object) if node is not instanced! */<br/>  virtual void OnSearchStart(FBehaviorTreeSearchData&amp; SearchData);<br/><br/>#if WITH_EDITOR<br/>  virtual FName GetNodeIconName() const override;<br/>#endif // WITH_EDITOR<br/><br/>  /** set next tick time */<br/>  void ScheduleNextTick(uint8* NodeMemory);</pre>
<p class="mce-root">Here there is a comment at the beginning (always taken from the Engine Source Code) that explains some implementation choices:</p>
<pre class="mce-root">/** <br/> * Behavior Tree service nodes is designed to perform "background" tasks that update AI's knowledge.<br/> *<br/> * Services are being executed when underlying branch of behavior tree becomes active,<br/> * but unlike tasks they don't return any results and can't directly affect execution flow.<br/> *<br/> * Usually they perform periodical checks (see TickNode) and often store results in blackboard.<br/> * If any decorator node below requires results of check beforehand, use OnSearchStart function.<br/> * Keep in mind that any checks performed there have to be instantaneous!<br/> * <br/> * Other typical use case is creating a marker when specific branch is being executed<br/> * (see OnBecomeRelevant, OnCeaseRelevant), by setting a flag in blackboard.<br/> *<br/> * Because some of them can be instanced for specific AI, following virtual functions are not marked as const:<br/> * - OnBecomeRelevant (from UBTAuxiliaryNode)<br/> * - OnCeaseRelevant (from UBTAuxiliaryNode)<br/> * - TickNode (from UBTAuxiliaryNode)<br/> * - OnSearchStart<br/> *<br/> * If your node is not being instanced (default behavior), DO NOT change any properties of object within those functions!<br/> * Template nodes are shared across all behavior tree components using the same tree asset and must store<br/> * their runtime properties in provided NodeMemory block (allocation size determined by GetInstanceMemorySize() )<br/> */</pre>
<p>Unfortunately, we cannot go into detail about each function, but they are all quite easy to understand. In any case, we will explore further <strong><em>Services</em> </strong>in the following three chapters, when we build a <em>Behavior Tree</em> from scratch, as well as when we implement a <strong><em>C++ Service</em></strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Composite Node</h1>
                
            
            
                
<p>In most of these cases, you <strong><em>will not need to extend a Composite Node</em></strong>. By "<em>most of these cases"</em>, I mean that you can create very complex <em>AI Behavior Trees</em> that can perform very complicated tasks, and that you really shouldn't extend or create a Composite Node unless you really need to.</p>
<p>In fact, a Composite Node influences the flow of the <em>Behavior Tree</em>, including which node to execute, which <em>Decorators</em> to check, and which <em>Service</em> to activate. By default, there are only three: <em>Selector</em>, <em>Sequence</em>, and <em>Simple Parallel</em>. These will be more than enough for covering most of our cases.</p>
<p>However, if you really have specific needs, then Unreal Engine is so flexible that it allows you to extend a <em>Composite Node</em> as well.</p>
<p>First of all, this is impossible to do in Blueprint, so the only way you can extend a (or create a new) <em>Composite Node</em> is through C++.</p>
<p>Let's look at an example of why you would like to create a new <em>Composite Node</em>.</p>
<p><strong>Why</strong>: Because you can implement a flow in the Behavior Tree that might be hard to achieve (or impossible) with the current composite nodes.</p>
<p><strong>An Example</strong>: You could potentially simulate a Behavior Tree with Simple Parallel nodes, with another one that does not use them. But this would be really complicated and not very clean. Thus, using Simple Parallel nodes simplifies a lot the workflow (originally, in the first versions of the engine, there were no Simple Parallel nodes).</p>
<p><strong>A Concrete Example</strong>: You want to pick which tasks should execute at random, below this custom Composite node, based on some weights. For instance, the weights can be evaluated by a special type of <em>Decorators</em>. Thus, extending a <em>Composite</em> might require additional work on other type of nodes.</p>
<p><strong>Another Concrete example</strong>: You can create a composite node that keeps picking a random child so that it succeeds until either a threshold is reached, or one of the children reports a fail.</p>
<p class="mce-root">Despite this being a very interesting topic, unfortunately, it is outside the scope of this book. Therefore, we will limit our selves to creating new <em>Tasks</em>, <em>Decorators</em>, and <em>Services</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating new type of nodes or new types of Trees</h1>
                
            
            
                
<p>In theory, you can create new types of nodes (for <em>Behavior Trees</em>, it's not really needed, because you would create a different kind of structure). Actually, you can create different tree structures that are not <em>Behavior Trees</em> anymore (e.g. a <em>Dialogue Tree</em>), which are far more useful than creating another node for a Behavior Tree. <em>Dialogue Trees</em> are really interesting, because they use a very similar structure to a <em>Behavior Tree</em>, and you can use the same <em>Editor</em> (or better, a slightly modified version of it) to edit the tree.</p>
<p>As much as I would like to dive into these topics, the main focus of this book is on AI, and so talking about <em>Dialogue Trees</em> is outside the scope of this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have explored how it is possible to <em>extend/create</em> <strong><em>Tasks</em></strong>, <strong><em>Decorators</em></strong>, and <strong><em>Services</em></strong> both in <em>Blueprint and in C++</em>. As a result, this gives us the ability to create complex behaviors for our AI agents, especially if combined with what we learned in the previous chapters, such as <em>navigation</em>, <em>EQS</em>, and <em>perception</em>.</p>
<p>In the next chapter, we will deal with <em>Crowds</em>, before jumping into creating a concrete example in <a href="6995bf12-0f10-47a9-a48c-cec31696df87.xhtml">Chapter 8</a>, <em>Designing Behavior Trees – Part I</em>, <a href="063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml">Chapter 9</a>, <em>Designing Behavior Trees – Part II</em>, and <a href="039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml">Chapter 10</a>, <em>Designing Behavior Trees – Part III</em>.</p>


            

            
        
    </body></html>