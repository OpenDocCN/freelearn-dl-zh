<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer025">
			<h1 id="_idParaDest-72" class="chapter-number"><a id="_idTextAnchor071"/>3</h1>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Extending Semantic Kernel</h1>
			<p><strong class="bold">Plugins</strong> encapsulate AI capabilities into a single unit of functionality. Plugins are the building blocks <a id="_idIndexMarker202"/>of AI applications. We will learn about the different types of functions (native functions and semantic functions) and how to expose these functions as a plugin, so that they can be used by <span class="No-Break">Semantic Kernel.</span></p>
			<p>In previous chapters, we created and used very simple plugins. In this chapter, we will start by describing the pre-existing tools that you already have available just by installing Semantic Kernel. Then, we will explore the best practices for developing your own <strong class="bold">native plugins</strong>, which are <a id="_idIndexMarker203"/>collections of native functions. These functions perform tasks that AI cannot do well, such as querying a database or doing complex math. Lastly, you will <a id="_idIndexMarker204"/>learn how to create <strong class="bold">semantic plugins</strong>, which are collections of semantic functions. These functions are executed by an AI service such as OpenAI’s GPT. We will explore the different parameters and how they work together. Throughout this chapter, we will use an application that evaluates grant requests for a nonprofit as our <span class="No-Break">use case.</span></p>
			<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>The <span class="No-Break">out-of-the-box plugins</span></li>
				<li>Creating <span class="No-Break">native functions</span></li>
				<li>Creating <span class="No-Break">semantic functions</span></li>
			</ul>
			<p>By the end of the chapter, you will have the tools required to build a kernel that can perform many coordinated functions, and that will be easier to use as a copilot or to be integrated into other tools such as the planner. In the next chapter, we will use this kernel to process a pipeline <span class="No-Break">of documents.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have a recent, supported version of your preferred Python or C# <span class="No-Break">development environment:</span></p>
			<ul>
				<li>For Python, the minimum supported version is Python 3.10, and the recommended version is <span class="No-Break">Python 3.11</span></li>
				<li>For C#, the minimum supported version is .<span class="No-Break">NET 8</span></li>
			</ul>
			<p>In this chapter, we will call OpenAI services. Given the amount that companies spend on training these LLMs, it’s no surprise that using these services is not free. You will need an <strong class="bold">OpenAI API</strong> key, obtained either directly through <strong class="bold">OpenAI</strong> or <strong class="bold">Microsoft</strong>, via the <strong class="bold">Azure </strong><span class="No-Break"><strong class="bold">OpenAI</strong></span><span class="No-Break"> service.</span></p>
			<p>If you are using .NET, the code for this chapter is <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch3"><span class="No-Break">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch3</span></a><span class="No-Break">.</span></p>
			<p>If you are using Python, the code for this chapter is <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch3"><span class="No-Break">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch3</span></a><span class="No-Break">.</span></p>
			<p>You can install the required packages by going to the GitHub repository and using the following: <strong class="source-inline">pip install -</strong><span class="No-Break"><strong class="source-inline">r requirements.txt</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Getting to know the core plugins</h1>
			<p>Large language models are great at generating text and images, but they are currently unreliable for <a id="_idIndexMarker205"/>several other tasks, <span class="No-Break">for example:</span></p>
			<ul>
				<li>Retrieving data from external data sources, such as the filesystem and <span class="No-Break">the web</span></li>
				<li>Interacting with the <span class="No-Break">system’s clock</span></li>
				<li>Performing math, even simple <span class="No-Break">arithmetic functions</span></li>
			</ul>
			<p>The Semantic Kernel installation includes several plugins for tasks that are very frequently used. The core plugins are native plugins that provide functionality that LLMs <span class="No-Break">struggle with.</span></p>
			<p>To use the plugins in C#, you need to import the <strong class="source-inline">Microsoft.SemanticKernelCoreSkills</strong> library, and to use the plugins in Python, you need to import the plugins from the <span class="No-Break"><strong class="source-inline">semantic_kernel.core_skills</strong></span><span class="No-Break"> library.</span></p>
			<p class="callout-heading">Skills or plugins?</p>
			<p class="callout">When the <a id="_idIndexMarker206"/>Microsoft Semantic Kernel was first released, plugins were called <em class="italic">skills</em>. This changed when OpenAI allowed developers to build extensions to ChatGPT and called these <a id="_idIndexMarker207"/>extensions <em class="italic">plugins</em>. Since the purpose is the same, the Semantic Kernel team decided to change the name from <em class="italic">skills</em> to <em class="italic">plugins</em>, but the old name lives on in the existing code in some places. This is likely to change in <span class="No-Break">the future.</span></p>
			<p>The following list shows the plugins that are currently available in <span class="No-Break">Semantic Kernel:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Plugin Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">What </strong><span class="No-Break"><strong class="bold">it does</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Available </strong><span class="No-Break"><strong class="bold">in Python?</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Available </strong><span class="No-Break"><strong class="bold">in C#?</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">TimePlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Acquires the time of day and any other <span class="No-Break">temporal information</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ConversationSummaryPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Summarizes <span class="No-Break">a conversation</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">FileIOPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Reads and writes to the <span class="No-Break">filesystem</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">HttpPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Calls APIs</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">MathPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Performs mathematical <span class="No-Break">operations</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">TextMemoryPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Stores and retrieves text <span class="No-Break">in memory</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">TextPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Manipulates text strings <span class="No-Break">deterministically</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">WaitPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Pauses execution for a specified amount <span class="No-Break">of time</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">WebSearchPlugin</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Performs Bing web searches and <span class="No-Break">returns results</span></p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>❌</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – Core plugins and their functions</p>
			<p>At the time of writing , the core <a id="_idIndexMarker208"/>plugins don’t have documentation. To see their parameters, you must read their code on the GitHub repository. For example, to find the <a id="_idIndexMarker209"/>parameters for the <strong class="source-inline">TimePlugin</strong>, you have to go directly to <span class="No-Break">the repository:</span></p>
			<ul>
				<li><span class="No-Break">C#: </span><a href="https://github.com/microsoft/semantic-kernel/blob/main/dotnet/src/Plugins/Plugins.Core/TimePlugin.cs"><span class="No-Break">https://github.com/microsoft/semantic-kernel/blob/main/dotnet/src/Plugins/Plugins.Core/TimePlugin.cs</span></a></li>
				<li><span class="No-Break">Python: </span><a href="https://github.com/microsoft/semantic-kernel/blob/main/python/semantic_kernel/core_plugins/time_plugin.py"><span class="No-Break">https://github.com/microsoft/semantic-kernel/blob/main/python/semantic_kernel/core_plugins/time_plugin.py</span></a></li>
			</ul>
			<p>Here are the parameters available <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">TimePlugin</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
{{time.date}}          =&gt; Sunday, 12 January, 2031
{{time.today}}         =&gt; Sunday, 12 January, 2031
{{time.iso_date}}      =&gt; 2031-01-12
{{time.now}}           =&gt; Sunday, January 12, 2031 9:15 PM
{{time.utcNow}}        =&gt; Sunday, January 13, 2031 5:15 AM
{{time.time}}          =&gt; 09:15:07 PM
{{time.year}}          =&gt; 2031
{{time.month}}         =&gt; January
{{time.monthNumber}}   =&gt; 01
{{time.day}}           =&gt; 12
{{time.dayOfWeek}}     =&gt; Sunday
{{time.hour}}          =&gt; 9 PM
{{time.hourNumber}}    =&gt; 21
{{time.days_ago $days}} =&gt; Sunday, 7 May, 2023
{{time.last_matching_day $dayName}} =&gt; Sunday, 7 May, 2023
{{time.minute}}        =&gt; 15
{{time.minutes}}       =&gt; 15
{{time.second}}        =&gt; 7
{{time.seconds}}       =&gt; 7
{{time.timeZoneOffset}}=&gt; -0800
{{time.timeZoneName}}  =&gt; PST</pre>			<p>Now that <a id="_idIndexMarker210"/>we know the available parameters, let’s see a quick sample of what the plugin <span class="No-Break">can do.</span></p>
			<p>To use the out-of-the-box plugins in C#, you first need to install the <strong class="source-inline">Plugins.Core</strong> package. To install it, use the following command (change the version to match your Semantic <span class="No-Break">Kernel version):</span></p>
			<pre class="console">
dotnet add package Microsoft.SemanticKernel.Plugins.Core --version 1.7.1-alpha</pre>			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>An example – Using the TimePlugin</h2>
			<p>We’re <a id="_idIndexMarker211"/>going to use the <strong class="source-inline">TimePlugin</strong> as part of the prompt of a semantic function. First, we create an instance of the <strong class="source-inline">TimePlugin</strong> and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break">.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating the TimePlugin in C#</p>
			<p>The core plugins for C# are still in pre-release. To use them, you need to add a <strong class="source-inline">#pragma</strong> directive (<strong class="source-inline">SKEXP0050</strong>) to disable the pre-release warning. You also need to import the <span class="No-Break"><strong class="source-inline">Microsoft.SemanticKernel.Plugins.Core</strong></span><span class="No-Break"> package.</span></p>
			<p>We are going to add the plugin using the <strong class="source-inline">AddFromType</strong> method of the Semantic <span class="No-Break"><strong class="source-inline">KernelBuilder</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
# pragma warning disable SKEXP0050
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.Core;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder()
                        .AddOpenAIChatCompletion("gpt-3.5-turbo", apiKey, orgId, serviceId: "gpt35");
builder.Plugins.AddFromType&lt;TimePlugin&gt;(pluginName: "time");
Kernel kernel = builder.Build();</pre>			<p>Let’s see <a id="_idIndexMarker212"/>how to do it in <span class="No-Break">Python next.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating the TimePlugin in Python</p>
			<p>In Python, the core plugins are in the <strong class="source-inline">semantic_kernel.core_plugins</strong> package. Once you import the plugin you want to use from that package, you can load it into the kernel with the <span class="No-Break"><strong class="source-inline">add_plugin</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
from semantic_kernel.utils.settings import openai_settings_from_dot_env
import semantic_kernel as sk
from semantic_kernel.core_plugins.time_plugin import TimePlugin
async def main():
    kernel = sk.Kernel()
    api_key, org_id = openai_settings_from_dot_env()
    gpt35 = OpenAIChatCompletion("gpt-3.5-turbo", api_key, org_id, "gpt35")
    kernel.add_service(gpt35)
    kernel.add_plugin(TimePlugin(), "time")</pre>			<p>Then, we create <a id="_idIndexMarker213"/>a semantic function and invoke it, as we did in both <span class="No-Break">previous chapters:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Invoking the TimePlugin in C#</p>
			<pre class="source-code">
const string promptTemplate = @"
Today is: {{time.date}}
Current time is: {{time.time}}
Answer to the following questions using JSON syntax, including the data used.
Is it morning, afternoon, evening, or night (morning/afternoon/evening/night)?
Is it weekend time (weekend/not weekend)?";
var results = await kernel.InvokePromptAsync(promptTemplate);
Console.WriteLine(results);</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Invoking the TimePlugin in Python</p>
			<pre class="source-code">
    prompt  = """
    Today is: {{time.date}}
    Current time is: {{time.time}}
    Answer to the following questions using JSON syntax, including the data used.
    Is it morning, afternoon, evening, or night (morning/afternoon/evening/night)?
    Is it weekend time (weekend/not weekend)?
    """
    prompt_function = kernel.add_function(function_name="ex03", plugin_name="sample", prompt=prompt)
    response = await kernel.invoke(prompt_function, request=prompt)</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Results</p>
			<p>For both languages, you should expect to get a JSON file that gives you information about the <a id="_idIndexMarker214"/>current time. Since we did not specify the exact JSON format in our prompt, the fields chosen by your invocation may <span class="No-Break">be different:</span></p>
			<pre class="console">
{
  "date": "Wednesday, 21 June, 2023",
  "time": "12:17:02 AM",
  "period": "night",
  "weekend": "not weekend"
}</pre>			<p>While there’s a lot that you can do with the core plugins, in most cases you’ll have to develop your own plugins. In the remainder of this chapter, we will explore the details of developing <a id="_idIndexMarker215"/>native and <span class="No-Break">semantic functions.</span></p>
			<p>But first, let’s look at our sample application that we’ll be employing to study the development of native and <span class="No-Break">semantic plugins.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Introducing the application – Validating grants</h1>
			<p>For this chapter and the next, imagine you are working for an organization that gives monetary grants to projects. For example, this could be the Department of Education giving away $100,000 to projects that will teach AI in high schools, or a non-profit organization <a id="_idIndexMarker216"/>such as the Gates Foundation giving $1,000,000 away to the three best proposals to eradicate malaria. The same concept also applies to several processes in corporations: for example, before sending a quote to a customer, a corporation may require that it fulfills some requirements, such as having a price, an expiration date, and some legal language. Another example is submitting visa applications in the United States. Lawyers must send several documents documenting the candidate’s academic and professional skills, in addition to several forms. If they miss one form or document, the whole application is rejected and they have to submit it again, including having to pay all the <span class="No-Break">fees again.</span></p>
			<p>In these next two chapters, we are going to write a simple application that evaluates a Word document that contains a grant request for a vaccination project and an Excel file with a budget. Our program will evaluate whether it fulfills the requirements of our grant program. If it doesn’t, it will tell the submitter what’s missing. To achieve that, we will write a native plugin to evaluate the Excel file, another native plugin to break the Word document into parts, and a semantic plugin to evaluate the contents of the Word document that describes <span class="No-Break">project proposal.</span></p>
			<p class="callout-heading">The second random selection for H-1B visas in 2021</p>
			<p class="callout">In July of 2021, the <strong class="bold">U.S. Citizenship and Immigration Services</strong> (<strong class="bold">USCIS</strong>) determined <a id="_idIndexMarker217"/>that they needed to conduct a second round of H-1B applications for their employment-based visa. The H-1B visa is used mostly by tech companies, and some large tech companies such as Amazon, Alphabet, Meta, and Microsoft had to file tens of thousands of applications in a short period of time. The applications needed to be manually reviewed by lawyers, an expensive <a id="_idIndexMarker218"/>and time-consuming project. Any error in the application would cause it to be automatically rejected, which could result in people having to leave the United States. The techniques we show in these two chapters can be used to build an application that reviews thousands of documents in minutes. Manual reviews are still required, but at least the most egregious errors will be automatically detected, saving the time <span class="No-Break">of lawyers.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Directory structure of our application</h2>
			<p>In our example in this and the following chapter, we will create an application that evaluates <a id="_idIndexMarker219"/>grant requests for a vaccination program by checking the content of two documents: a Word document and an <span class="No-Break">Excel spreadsheet.</span></p>
			<p>Each grant request will be in a directory containing the Excel spreadsheet that has the budget requested for the vaccination campaign and the Word document that describes the team that will be executing the vaccination program and <span class="No-Break">their experience.</span></p>
			<p>The data is available in the <strong class="source-inline">data</strong> directory of the book’s GitHub repository, and its directory structure is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
data
├───correct
│       correct.docx
│       correct.xlsx
├───incorrect01
│       incorrect_template.xlsx
│       missing_experience.docx
├───incorrect02
│       missing_qualifications.docx
│       over_budget.xlsx
├───incorrect03
│       correct.docx
│       fast_increase.xlsx
├───incorrect04
│       correct.docx
│       incorrect_cells.xlsx
├───incorrect05
│       incorrect_cells.xlsx
├───incorrect06
│       correct.docx
├───incorrect07
│       correct.xlsx
│       missing_experience.docx
├───incorrect08
│       correct.xlsx
│       missing_qualifications.docx
├───incorrect09
│       correct.xlsx
│       wrong_dates.docx
└───incorrect10
        correct.docx
        correct.xlsx
        missing_experience.docx</pre>			<p>For this chapter, we will use the first four grant requests. One set of documents is valid, which is stored in the directory named <strong class="source-inline">correct</strong>, while the other three, which are stored in <strong class="source-inline">incorrect1</strong>, <strong class="source-inline">incorrect2</strong> and <strong class="source-inline">incorrect3</strong>, respectively, have problems, which will be described later in <span class="No-Break">this chapter.</span></p>
			<p>Evaluating the <em class="italic">structure</em> of documents is something that is easier and more reliable with regular <a id="_idIndexMarker220"/>programming than with LLMs. On the other hand, evaluating the <em class="italic">content</em> of documents is something that is easier with LLMs than with <span class="No-Break">regular programming.</span></p>
			<p>We are going to do the first part using <span class="No-Break">native functions.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Developing native plugins</h1>
			<p>Let’s start with native functions. Native functions are regular code in your language of choice (Python or C#) and do not necessarily require a specific directory structure, unlike semantic <a id="_idIndexMarker221"/>functions. However, it is easier to put the native functions together with the main code of your program. This will make it easier to import <span class="No-Break">the classes.</span></p>
			<p class="callout-heading">Avoid duplicate names</p>
			<p class="callout">Since semantic functions are directories and native functions are source code files, it’s possible to have a semantic function and a native function with the same name inside a plugin, for example a directory named <strong class="source-inline">my_function</strong> and a source code file named <strong class="source-inline">my_function.py</strong>. If you do that, the last function loaded (the source code file) will overwrite the first, leading to unexpected problems. Therefore, avoid duplicate names. At the time of writing, Semantic Kernel does not provide a warning when <span class="No-Break">this happens.</span></p>
			<p>Let’s look at the directory structure of <span class="No-Break">our plugins.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>The directory structure of our plugins</h2>
			<p>Semantic <a id="_idIndexMarker222"/>Kernel offers a function to add plugins from a directory. While you can always load plugins one at a time, setting up the plugins in the <a id="_idIndexMarker223"/>following directory structure makes it easier to load them into the kernel with fewer <span class="No-Break">function calls:</span></p>
			<pre class="source-code">
└───ch3
    └───proposals
    └───plugins
    |    └───ProposalChecker
    |         ├───CheckQualifications
    |         |     ├───skprompt.txt
    |         |     └───config.json
    |         ├───CheckExperience
    |         |     ├───skprompt.txt
    |         |     └───config.json
    |         └───CheckImplementationDescription
    |               ├───skprompt.txt
    |               └───config.json
    └───code
          ├───python
          |    ├───program.py
          |    ├───<strong class="bold">ParseWordDocument.py</strong>
          |    └───<strong class="bold">CheckSpreadsheet.py</strong>
          └───dotnet
               ├───Program.cs
               ├───<strong class="bold">ParseWordDocument.cs</strong>
               └───<strong class="bold">CheckSpreadsheet.cs</strong></pre>			<p>The first three directories, <strong class="source-inline">CheckQualifications</strong>, <strong class="source-inline">CheckExperience</strong>, and <strong class="source-inline">CheckImplementationDescription</strong>, are semantic functions and will be addressed in the <em class="italic">Developing semantic plugins </em>section. The <strong class="source-inline">CheckSpreadsheet</strong> and <strong class="source-inline">ParseWordDocument</strong> files contain native functions that perform <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">CheckSpreadsheet</strong>: Validates the spreadsheet to make sure it contains all <span class="No-Break">required fields</span></li>
				<li><strong class="source-inline">ParseWordDocument</strong>: Validates the Word document and makes sure it contains all the <span class="No-Break">required headings</span></li>
			</ul>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Checking the structure of our Excel spreadsheet</h2>
			<p>The <a id="_idIndexMarker224"/>desired structure of the Excel <a id="_idIndexMarker225"/>spreadsheet for our application is <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The Excel file needs to have exactly two sheets, one named <strong class="source-inline">2024</strong> and another <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">2025</strong></span></li>
				<li>Each sheet needs to follow the <span class="No-Break">following template:</span></li>
			</ul>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Quarter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Budget</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Q1</span></p>
						</td>
						<td class="No-Table-Style">
							<p>$<span class="No-Break">99,999</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Q2</span></p>
						</td>
						<td class="No-Table-Style">
							<p>$<span class="No-Break">99,999</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Q3</span></p>
						</td>
						<td class="No-Table-Style">
							<p>$<span class="No-Break">99,999</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Q4</span></p>
						</td>
						<td class="No-Table-Style">
							<p>$<span class="No-Break">99,999</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>It needs to follow <span class="No-Break">these rules:</span></p>
			<ul>
				<li>The total budget to implement the vaccination campaign for each year needs to be <span class="No-Break">below $1,000,000</span></li>
				<li>No more than a 10% increase quarter <span class="No-Break">over quarter</span></li>
			</ul>
			<p>To test the function, we created the following <span class="No-Break">Excel workbooks:</span></p>
			<ul>
				<li><strong class="source-inline">correct.xslx</strong>: A workbook that follows all the rules and should pass <span class="No-Break">the test</span></li>
				<li><strong class="source-inline">incorrect_template.xlsx</strong>: A workbook that doesn’t have the sheets named <strong class="source-inline">2024</strong> and <strong class="source-inline">2025</strong> and should fail <span class="No-Break">the test</span></li>
				<li><strong class="source-inline">over_budget.xlsx</strong>: A spreadsheet that follows the format but requests more than a million dollars per year and should fail <span class="No-Break">the test</span></li>
				<li><strong class="source-inline">fast_increase.xlsx</strong>: A spreadsheet that follows the format and is under budget, but has expenses increasing by more than 10% quarter over quarter, and should therefore fail <span class="No-Break">the test</span></li>
			</ul>
			<p>We will <a id="_idIndexMarker226"/>implement the code to check <a id="_idIndexMarker227"/>these spreadsheets in the <span class="No-Break">following section.</span></p>
			<h3>Using native functions to check the Excel spreadsheet</h3>
			<p>For both <a id="_idIndexMarker228"/>languages, native functions must be defined as public methods in a class that represents your plugin. The functions will return text because that will be easier to integrate with semantic <span class="No-Break">functions later.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>In Python, we’re <a id="_idIndexMarker229"/>going to use the <strong class="bold">OpenPyXL</strong> package (<a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a>), which makes it easy to open an Excel file, ensure it has the required number of tabs, ensure that it has the required tables, and load the tables <span class="No-Break">into variables:</span></p>
			<pre class="source-code">
import openpyxl
from typing_extensions import Annotated
from semantic_kernel.functions.kernel_function_decorator import kernel_function
class CheckSpreadsheet:</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using System.ComponentModel;
using Microsoft.SemanticKernel;
using OfficeOpenXml;
namespace Plugins.ProposalChecker;
public class CheckSpreadsheet
{
}</pre>			<p>Now that <a id="_idIndexMarker230"/>we have the class templates created, we will need to add the functions that implement the functionality that checks <span class="No-Break">the spreadsheet.</span></p>
			<p>To add functions to your class, you need to use the <strong class="source-inline">KernelFunction</strong> (C#) or <strong class="source-inline">kernel_function</strong> (Python) decorator. This will enable Semantic Kernel to recognize the function. When using the decorator, you need to add the <strong class="source-inline">Description</strong> attribute for the function and its parameters. This description can be used by planners to decide which functions to use when the user sends a request, as we saw in <a href="B21826_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>Our first function, <strong class="source-inline">CheckTabs</strong>, checks that the spreadsheet has the two required tabs named <strong class="source-inline">2024</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">2025</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
    @kernel_function(
        description="Checks that the spreadsheet contains the correct tabs, 2024 and 2025",
        name="CheckTabs",
    )
    def CheckTabs(self,
                  path: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        try:
            workbook = openpyxl.load_workbook(path)
            sheet_names = workbook.sheetnames
            if sheet_names == ['2024', '2025']:
                return "Pass"
            else:
                return "Fail: the spreadsheet does not contain the correct tabs"
        except Exception as e:
            return f"Fail: an exception {e} occurred when trying to open the spreadsheet"</pre>			<p>The function <a id="_idIndexMarker231"/>opens the workbook with the <strong class="source-inline">load_workbook</strong> method of <strong class="source-inline">openpyxl</strong> and checks that it has exactly two tabs named <strong class="source-inline">2024</strong> and <strong class="source-inline">2025</strong>. If it succeeds, it returns <strong class="source-inline">"Pass"</strong>. Otherwise, it returns <strong class="source-inline">"Fail"</strong> and provides an <span class="No-Break">error description.</span></p>
			<p>In Python, you can tell the name you want Semantic Kernel to use with the function by using the <strong class="source-inline">name</strong> attribute of the <strong class="source-inline">kernel_function</strong> decorator. You can also describe your input parameters using the <strong class="source-inline">Annotated</strong> decorators. The first parameter of the <strong class="source-inline">Annotated</strong> decorator is the type of the input parameter and the second is <span class="No-Break">its description.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
    [KernelFunction, Description("Checks that the spreadsheet contains the correct tabs, 2024 and 2025")]
    public string CheckTabs([Description("The file path to the spreadsheet")] string filePath)
    {
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Fail: File does not exist.";
            }
            using (var package = new ExcelPackage(fileInfo))
            {
                ExcelPackage.LicenseContext = OfficeOpenXml.LicenseContext.NonCommercial;
                var workbook = package.Workbook;
                if (workbook.Worksheets.Count != 2)
                {
                    return "Fail: Spreadsheet does not contain 2 tabs.";
                }
                if (workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2024") &amp;&amp; workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2025"))
                {
                    return "Pass";
                }
                else
                {
                    return "Fail: Spreadsheet does not contain 2024 and 2025 tabs.";
                }
            }
        }
        catch (Exception ex)
        {
            return $"Fail: An error occurred: {ex.Message}";
        }
    }</pre>			<p>The function opens the workbook with the <strong class="source-inline">ExcelPackage</strong> class of <strong class="source-inline">OfficeOpenXml</strong> and checks that it has exactly two tabs named <strong class="source-inline">2024</strong> and <strong class="source-inline">2025</strong>. If it succeeds, it returns <strong class="source-inline">"Pass"</strong>. Otherwise, it returns <strong class="source-inline">"Fail"</strong> and provides an <span class="No-Break">error description.</span></p>
			<p>In C#, we use parameter decorators to add a <strong class="source-inline">Description</strong> attribute to parameters when <a id="_idIndexMarker232"/>declaring a function, and a <strong class="source-inline">KernelFunction</strong> function decorator that makes the function accessible to <strong class="source-inline">SemanticKernel</strong> and describes its purpose with the <span class="No-Break"><strong class="source-inline">Description</strong></span><span class="No-Break"> attribute.</span></p>
			<p>Now that we have the plugin and the test data set up, let’s write a simple program that will perform just the first two tests: checking that the spreadsheet exists and checking whether it contains the tabs we expect. We will add more <span class="No-Break">tests later.</span></p>
			<h3>Checking the contents of the worksheets</h3>
			<p>In the <a id="_idIndexMarker233"/>following code, we are going to check the contents of <span class="No-Break">each sheet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using System.IO;
var (apiKey, orgId) = Settings.LoadFromFile();
Kernel kernel = Kernel.CreateBuilder()
                        .AddOpenAIChatCompletion("gpt-3.5-turbo", apiKey, orgId, serviceId: "gpt35")
                        .Build();
var checkerPlugin = kernel.ImportPluginFromObject(new Plugins.ProposalChecker.CheckSpreadsheet());</pre>			<p>Using the familiar template, we use the <strong class="source-inline">Settings.LoadFromFile</strong> method to load the API key, use <strong class="source-inline">KernelBuilder</strong> and <strong class="source-inline">AddOpenAIChatCompletion</strong> to connect to the OpenAI <a id="_idIndexMarker234"/>service for later, and then use the <strong class="source-inline">ImportPluginFromObject</strong> method of the kernel to import the <span class="No-Break"><strong class="source-inline">CheckSpreadsheet</strong></span><span class="No-Break"> class.</span></p>
			<p>Now we can check the spreadsheets by using <strong class="source-inline">InvokeAsync</strong> and passing the <strong class="source-inline">CheckTabs</strong> function as its function parameter, and each file as its <span class="No-Break"><strong class="source-inline">filePath</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
 // Check for tabs
var result1 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/correct/correct.xlsx"});
var result2 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/incorrect01/incorrect_template.xlsx"});
var result3 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/incorrect02/over_budget.xlsx"});
var result4 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/incorrect03/fast_increase.xlsx"});
Console.WriteLine("Checking whether the correct tabs are present in the spreadsheet:");
Console.WriteLine(result1);
Console.WriteLine(result2);
Console.WriteLine(result3);
Console.WriteLine(result4);</pre>			<p>Let’s see <a id="_idIndexMarker235"/>how to perform the checks <span class="No-Break">with Python:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from semantic_kernel.utils.settings import openai_settings_from_dot_env
from CheckSpreadsheet import CheckSpreadsheet
from ParseWordDocument import ParseWordDocument
from semantic_kernel.functions.kernel_arguments import KernelArguments
async def run_spreadsheet_check(path, function):
    kernel = sk.Kernel()
    check_spreadsheet = kernel.add_plugin(CheckSpreadsheet(), "CheckSpreadsheet")
    result = await kernel.invoke(
        check_spreadsheet[function], KernelArguments(path = path)
    )
    print(result)
async def main():
    data_path = "../../data/proposals"
    await run_spreadsheet_check(f"{data_path}/correct/correct.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect01/incorrect_template.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect02/over_budget.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect03/fast_increase.xlsx", "CheckTabs")
# Run the main function
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>In Python, we <a id="_idIndexMarker236"/>use the <strong class="source-inline">add_plugin</strong> method to import the native function class and the <strong class="source-inline">kernel.invoke</strong> method to invoke it. In the preceding code, I put the functionality in a function <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">run_spreadsheet_check</strong></span><span class="No-Break">.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Results</p>
			<p>We are running the test on four files, one that we expect to pass and three that we expect to fail. The results come out <span class="No-Break">as expected:</span></p>
			<pre class="console">
Pass
Fail: the spreadsheet does not contain the correct tabs
Fail: Sum of values in year 2025 exceeds 1,000,000.
Fail: More than 10% growth found from B2 to B3 in sheet 2024.</pre>			<p>Now that <a id="_idIndexMarker237"/>we have our initial template done, we need to add the other functions to the plugin to perform all the checks <span class="No-Break">we need.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Additional checks</h2>
			<p>We still <a id="_idIndexMarker238"/>need to check <span class="No-Break">the following:</span></p>
			<ul>
				<li>Whether there are exactly 10 cells filled in <span class="No-Break">each tab</span></li>
				<li>Whether the budget adds up to less <span class="No-Break">than $1,000,000</span></li>
				<li>Whether the budget grows by 10% or less <span class="No-Break">each quarter</span></li>
			</ul>
			<p>Let’s start by checking whether the spreadsheet has all the cells <span class="No-Break">we expect:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>In Python, we create a dictionary with the list of expected cells and make sure that they are filled. Don’t forget to use the <strong class="source-inline">@kernel_function</strong> decorator, otherwise Semantic Kernel won’t be able to find <span class="No-Break">the function:</span></p>
			<pre class="source-code">
    @kernel_function(
        description="Checks that the spreadsheet contains the correct cells A1-B5",
        name="CheckCells",
    )
    def CheckCells(self,
                 path: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        workbook = openpyxl.load_workbook(path)
        required_cells = {
            'A1': 'Quarter', 'B1': 'Budget',
            'A2': 'Q1', 'A3': 'Q2', 'A4': 'Q3', 'A5': 'Q4'
        }
        for year in ['2024', '2025']:
            sheet = workbook[year]
            for cell, value in required_cells.items():
                if sheet[cell].value != value:
                    return "Fail: missing quarters"
            for row in range(2, 6):
                if not isinstance(sheet[f'B{row}'].value, (int, float)):
                    return "Fail: non-numeric inputs"
        return "Pass"</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>In C#, we will <a id="_idIndexMarker239"/>check the cells one by one. It is still a very straightforward function, where we simply look at each cell and check to see whether it has the expected value. Remember to add the <strong class="source-inline">KernelFunction</strong> decorator before the declaration of the function or Semantic Kernel will not <span class="No-Break">recognize it:</span></p>
			<pre class="source-code">
    [KernelFunction, Description("Checks that each tab contains the cells A1-A5 and B1-B5 with the correct values")]
    public static string CheckCells([Description("The file path to the spreadsheet")] string filePath)
    {
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Fail: File does not exist.";
            }
            using (var package = new ExcelPackage(fileInfo))
            {
                foreach (var year in new[] { "2024", "2025" })
                {
                    var sheet = package.Workbook.Worksheets[year];
                    if (sheet.Cells["A1"].Text != "Quarter" || sheet.Cells["B1"].Text != "Budget" ||
                        sheet.Cells["A2"].Text != "Q1" || sheet.Cells["A3"].Text != "Q2" ||
                        sheet.Cells["A4"].Text != "Q3" || sheet.Cells["A5"].Text != "Q4")
                    {
                        return "Fail: missing quarters";
                    }
                    for (int row = 2; row &lt;= 5; row++)
                    {
                        if (sheet.Cells[$"B{row}"].Value is not double)
                        {
                            return "Fail: non-numeric values";
                        }
                    }
                }
                return "Pass";
            }
        }
        catch (Exception ex)
        {
            return $"Fail: An error occurred: {ex.Message}";
        }
    }</pre>			<p>The final <a id="_idIndexMarker240"/>step is to check whether the content of the numeric cells follows the two rules we defined: a budget of no more than $1M per year, and no more than a 10% increase <span class="No-Break">per quarter.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>Again, don’t forget to add the <strong class="source-inline">@kernel_function</strong> decorator so that Semantic Kernel can find your function. The function is straightforward, going from cell B2 to B5 and checking <a id="_idIndexMarker241"/>whether they increase by more than 10%, and then also checking the sum to make sure it’s <span class="No-Break">under $1M:</span></p>
			<pre class="source-code">
    @kernel_function(
        description="Checks that the spreadsheet contains the correct values, less than 1m per year and growth less than 10%",
        name="CheckValues",
    )
    def CheckValues(self,
                    path: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        workbook = openpyxl.load_workbook(path)
        years = ['2024', '2025']
        for year in years:
            if year not in workbook.sheetnames:
                return f"Fail: Sheet for year {year} not found."
            sheet = workbook[year]
            values = [sheet[f'B{row}'].value for row in range(2, 6)]
            if not all(isinstance(value, (int, float)) for value in values):
                return f"Fail: Non-numeric value found in sheet {year}."
            if sum(values) &gt;= 1000000:
                return f"Fail: Sum of values in year {year} exceeds 1,000,000."
            for i in range(len(values) - 1):
                if values[i + 1] &gt; values[i] * 1.10:
                    return f"Fail: More than 10% growth found from B{i+2} to B{i+3} in sheet {year}."
        return "Pass"</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>We are <a id="_idIndexMarker242"/>going to do our checks in two steps. First, we load the file and iterate through the numeric cells, adding them to <span class="No-Break">an array:</span></p>
			<pre class="source-code">
    [KernelFunction, Description("Check that the cells B2-B5 add to less than 1 million and don't increase over 10% each quarter")]
    public static string CheckValues([Description("The file path to the spreadsheet")] string filePath)
    {
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Fail: file does not exist.";
            }
            using (var package = new ExcelPackage(fileInfo))
            {
                foreach (var year in new[] { "2024", "2025" })
                {
                    var sheet = package.Workbook.Worksheets[year];
                    if (sheet == null)
                    {
                        return "Fail: Sheet for year {year} not found.";
                    }
                    double[] values = new double[4];
                    for (int i = 0; i &lt; 4; i++)
                    {
                        if (sheet.Cells[i + 2, 2].Value is not double)
                        {
                            return $"Non-numeric value found in sheet {year}.";
                        }
                        else values[i] = (double)sheet.Cells[i + 2, 2].Value;
                    }</pre>			<p>Then we <a id="_idIndexMarker243"/>check whether the sum of the values of the array is over $1M and whether there’s growth of <span class="No-Break">over 10%:</span></p>
			<pre class="source-code">
                    if (sum(values) &gt;= 1000000)
                    {
                        return $"Sum of values in year {year} exceeds 1,000,000.";
                    }
                    for (int i = 0; i &lt; values.Length - 1; i++)
                    {
                        if (values[i + 1] &gt; values[i] * 1.10)
                        {
                            return $"More than 10% growth found from B{i+2} to B{i+3} in sheet {year}.";
                        }
                    }
                }
                return "Pass";
            }
        }
        catch (Exception ex)
        {
            return $"An error occurred: {ex.Message}";
        }
    }</pre>			<p>To make <a id="_idIndexMarker244"/>the check of the sum of values simpler, create a simple helper function called <strong class="source-inline">sum</strong> that returns the sum of an array <span class="No-Break">of doubles:</span></p>
			<pre class="source-code">
    static double sum(double[] values)
    {
        double total = 0;
        foreach (var value in values)
        {
            total += value;
        }
        return total;
    }</pre>			<p>By combining <a id="_idIndexMarker245"/>all the functions above in <strong class="source-inline">CheckSpreadsheet.py</strong> (Python) and <strong class="source-inline">CheckSpreadsheet.cs</strong> (C#), we can verify all the Excel files in the <strong class="source-inline">data/proposals</strong> folder. The entire code is in the GitHub repository for <span class="No-Break">this chapter.</span></p>
			<p>Besides having an Excel file, each proposal also has a Word document, of which we want to check a <span class="No-Break">few aspects.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Evaluating the Word document</h2>
			<p>The proposal document will have three sections describing the team that is proposing a vaccination <a id="_idIndexMarker246"/>campaign, their experience, and the implementation details of their proposal. We want to check three aspects of the <span class="No-Break">proposal document:</span></p>
			<ul>
				<li>Whether the team has people with experience in the medical sciences with at least one having a Ph.D. This information should be under a <em class="italic">Heading 1</em> section <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Team</strong></span><span class="No-Break">.</span></li>
				<li>Whether the team has successfully deployed a vaccination campaign before. This information should be under a <em class="italic">Heading 1</em> section <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Experience</strong></span><span class="No-Break">.</span></li>
				<li>Whether the project proposal has an implementation detail describing when the vaccination campaign starts and when it ends. This information should be under a <em class="italic">Heading 1</em> section named <span class="No-Break"><strong class="source-inline">Implementation Plan</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>To verify that the proposals fulfill the requirements, we are going to send the text from the Word document to a semantic function later that will tell us whether it fulfills the requirements, but first we are going to write a native function that extracts the contents of the relevant sections of each of the <span class="No-Break">Word documents:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>To open the Python document, we need to use the <strong class="source-inline">python-docx</strong> package. You can install this with the <span class="No-Break">following command:</span></p>
			<pre class="console">
pip install python-docx</pre>			<p>Note that even though we import the <strong class="source-inline">docx</strong> package in the Python code, we need to install <strong class="source-inline">python-docx</strong>. If you install a package named <strong class="source-inline">docx</strong>, it will not work — that’s an old, <span class="No-Break">deprecated package.</span></p>
			<p>We define <a id="_idIndexMarker247"/>our native function and make sure that it will be available to Semantic Kernel by decorating it with the <strong class="source-inline">kernel_function</strong> decorator, and its parameters and return value with the <span class="No-Break"><strong class="source-inline">Annotated</strong></span><span class="No-Break"> decorator:</span></p>
			<pre class="source-code">
from docx import Document
from typing_extensions import Annotated
from semantic_kernel.functions.kernel_function_decorator import kernel_function
class ParseWordDocument:
    @kernel_function(
        description="Extract the text under the given heading",
        name="ExtractTextUnderHeading",
    )</pre>			<p>We create a <strong class="source-inline">ParseWordDocument</strong> class to hold our native plugin, and inside that class we create a function <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">ExtractTextUnderHeading</strong></span><span class="No-Break">.</span></p>
			<p>The <a id="_idIndexMarker248"/>remainder of the code looks for a <em class="italic">Heading 1</em> with the text <strong class="source-inline">target_heading</strong> and then reads all <span class="No-Break">its paragraphs:</span></p>
			<pre class="source-code">
     async def ExtractTextUnderHeading(self,
            doc_path: Annotated[str, "The path for the file we want to evaluate"],
            target_heading: Annotated[str, "The heading we want to extract the text from"]
            ) -&gt; Annotated[str, "The extracted text"]:
        doc = Document(str(doc_path))
        extract = False
        extracted_text = ''
        for paragraph in doc.paragraphs:
            if paragraph.style.name == 'Heading 1':
                if extract:
                    break  # Stop if next heading is found
                extract = paragraph.text.strip().lower() == str(target_heading).lower()
            elif extract:
                extracted_text += paragraph.text + '\n'
        return extracted_text.strip()</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using System.ComponentModel;
using Microsoft.SemanticKernel;
namespace Plugins.ProposalChecker;
public class ParseWordDocument
{
    [KernelFunction, Description("Extracts the text under the heading in the Word document")]
    public static string ExtractTextUnderHeading(string filePath, string heading)</pre>			<p>In the C# version of our plugin, we declare a <strong class="source-inline">ParseWordDocument</strong> class and a <strong class="source-inline">ExtractTextUnderHeading</strong> function. Don’t forget to add the <strong class="source-inline">KernelFunction</strong> decorator, otherwise Semantic Kernel will not find <span class="No-Break">your function.</span></p>
			<p>The <a id="_idIndexMarker249"/>function reads all the body of the document first, and then reads all the paragraphs. Then it finds all paragraphs after a <em class="italic">Heading 1</em> that matches the <strong class="source-inline">heading</strong> parameter and <span class="No-Break">returns them:</span></p>
			<pre class="source-code">
       using (WordprocessingDocument doc = WordprocessingDocument.Open(filePath, false))
        {
            var body = doc.MainDocumentPart?.Document.Body;
            var paras = body?.Elements&lt;Paragraph&gt;();
            bool isExtracting = false;
            string extractedText = "";
            // if paras is null, return empty string
            if (paras == null)
            {
                return extractedText;
            }
            foreach (var para in paras)
            {
                if (para.ParagraphProperties != null &amp;&amp;
                    para.ParagraphProperties.ParagraphStyleId != null &amp;&amp;
                    para.ParagraphProperties.ParagraphStyleId.Val != null &amp;&amp;
                    para.ParagraphProperties.ParagraphStyleId.Val.Value == "Heading1" &amp;&amp;
                    para.InnerText.Trim().Equals(heading, StringComparison.OrdinalIgnoreCase))
                {
                    isExtracting = true;
                    continue;
                }
                if (isExtracting)
                {
                    if (para.ParagraphProperties != null &amp;&amp;
                        para.ParagraphProperties.ParagraphStyleId != null &amp;&amp;
                        para.ParagraphProperties.ParagraphStyleId.Val != null &amp;&amp;
                        para.ParagraphProperties.ParagraphStyleId.Val.Value == "Heading1")
                    {
                        break;
                    }
                    extractedText += para.InnerText + "\n";
                }
            }
            return extractedText.Trim();
        }
    }
}</pre>			<p>We will <a id="_idIndexMarker250"/>not invoke this function yet. First, we will create a semantic plugin that we will use to parse the results of the function we created above. Once we do that, we will call both functions one <span class="No-Break">after another.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Developing semantic plugins</h1>
			<p>A semantic <a id="_idIndexMarker251"/>plugin is just a collection of semantic functions. Semantic functions are functions that use AI services, such as the OpenAI service or the Azure OpenAI service, to <span class="No-Break">perform tasks.</span></p>
			<p class="callout-heading">Important – using the OpenAI services is not free</p>
			<p class="callout">The semantic functions will call the OpenAI API. These calls require a paid subscription, and each call will incur a cost. The costs are usually small per request. GPT 3.5 costs $0.0002 per thousand tokens, but this can add up if you make a large number of calls. Note also that the prices change frequently, so make sure to check the latest prices on the <span class="No-Break">following websites.</span></p>
			<p class="callout">OpenAI <span class="No-Break">pricing: </span><a href="https://openai.com/pricing"><span class="No-Break">https://openai.com/pricing</span></a></p>
			<p class="callout">Azure OpenAI <span class="No-Break">pricing: </span><a href="https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/"><span class="No-Break">https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/</span></a></p>
			<p>Each plugin <a id="_idIndexMarker252"/>must have its own directory, and the name of the directory is the plugin name. The directory should contain one subdirectory per function. The name of each subdirectory is the name of <span class="No-Break">the function.</span></p>
			<p>Each subdirectory must contain two files: <strong class="source-inline">skprompt.txt</strong> and <strong class="source-inline">config.json</strong>. The <strong class="source-inline">skprompt.txt</strong> file contains the prompt for the semantic function that will be submitted to the <span class="No-Break">AI service:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">A sample skprompt.txt</p>
			<p>The <strong class="source-inline">skprompt.txt</strong> file contains a <strong class="bold">metaprompt</strong>. A metaprompt is defined as a template for a <a id="_idIndexMarker253"/>prompt that will be submitted to the AI service once its variables are replaced by their values. Variables are inside double curly brackets and named with a dollar sign; for example, the <strong class="source-inline">var</strong> variable would appear as <strong class="source-inline">{{$var}}</strong> <span class="No-Break">inside</span><span class="No-Break"><strong class="source-inline"> skprompt.txt</strong></span><span class="No-Break">.</span></p>
			<p>The following example <strong class="source-inline">skprompt.txt</strong> contains three variables: <strong class="source-inline">history</strong>, <strong class="source-inline">input</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">options</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[History]
{{$history}}
User: {{$input}}
---------------------------------------------
Provide the intent of the user. The intent should be one of the following: {{$options}}
INTENT:</pre>			<p>The preceding <strong class="source-inline">history</strong>, <strong class="source-inline">input,</strong> and <strong class="source-inline">options</strong> variables are just an example to show a metaprompt with multiple <a id="_idIndexMarker254"/>variables. For our grant verification use case, we will start with just one variable, called <strong class="source-inline">input</strong>, and the <strong class="source-inline">skprompt.txt</strong> file will be described in the following <em class="italic">Evaluating the grant proposal with a semantic </em><span class="No-Break"><em class="italic">plugin</em></span><span class="No-Break"> section.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">A sample config.json</p>
			<p>The <strong class="source-inline">config.json</strong> file contains the parameters that control the output of the <span class="No-Break">AI service.</span></p>
			<p>When <a id="_idIndexMarker255"/>creating a <strong class="source-inline">config.json</strong> file, you need to specify the <span class="No-Break">following parameters:</span></p>
			<ul>
				<li><strong class="source-inline">schema</strong>: Reserved for future use, and should currently be set to <strong class="source-inline">1</strong>. In the future, this will be used <span class="No-Break">for versioning.</span></li>
				<li><strong class="source-inline">type</strong>: Reserved for future use, and should currently be set to <strong class="source-inline">completion</strong>. In the future, this will be used for different types of LLMs, but this has not been implemented in Semantic <span class="No-Break">Kernel yet.</span></li>
				<li><strong class="source-inline">description</strong>: An important parameter that describes what the function does. It’s used by <strong class="source-inline">planner</strong> to figure out what the function can help the <span class="No-Break">user accomplish.</span></li>
				<li><strong class="source-inline">execution_settings</strong>: This is an object that contains multiple objects. You should always add an object called <strong class="source-inline">"default"</strong> inside of it. If the semantic function is called by a service with a <strong class="source-inline">service_id</strong> of <strong class="source-inline">"gpt4"</strong>, it will look for an object called <strong class="source-inline">"gpt4"</strong> inside the <strong class="source-inline">execution_settings</strong> to find which settings to use. If it doesn’t find it, it will use the <strong class="source-inline">execution_settings</strong> defined under <strong class="source-inline">"default"</strong>. This allows you to configure different parameters <span class="No-Break">per service.</span></li>
				<li>An OpenAI service should contain the <span class="No-Break">following parameters:</span><ul><li><strong class="source-inline">max_tokens</strong>: This parameter specifies the maximum length of the response from the model. It’s measured in tokens, which can be words or parts of words. For example, the word “<em class="italic">OpenAI</em>” is one token, but “<em class="italic">OpenAI’s</em>” might be two tokens (“<em class="italic">OpenAI</em>” and “<em class="italic">’s</em>”). Setting a higher number of <strong class="source-inline">max_tokens</strong> allows for longer responses, but also consumes more computational resources. A good rule of thumb is to assume that tokens add 33% to the number of words, so a text with 75 words will need approximately <span class="No-Break">100 tokens.</span></li><li><strong class="source-inline">temperature</strong>: The temperature controls the randomness of the model’s output. A lower temperature (close to <strong class="source-inline">0</strong>) makes the model’s responses more predictable and deterministic, while a higher temperature (closer to <strong class="source-inline">1</strong>) increases <a id="_idIndexMarker256"/>randomness and creativity in the responses. A temperature of <strong class="source-inline">0</strong> means the model will always choose the most likely next token, whereas at <strong class="source-inline">1</strong>, it chooses <span class="No-Break">more freely.</span></li><li><strong class="source-inline">top_p</strong> (also known as nucleus sampling): Helps in controlling the diversity of the generated text. It works by only considering the most likely next tokens that cumulatively make up the probability <em class="italic">p</em>. For instance, if <strong class="source-inline">top_p</strong> is set to <strong class="source-inline">0.9</strong>, the model will choose the next token from the top 90% of the probability distribution. Lower values of <strong class="source-inline">top_p</strong> make the model more conservative in its choices, while higher values allow for more diversity and <span class="No-Break">less predictability.</span></li><li><strong class="source-inline">presence_penalty</strong>: Encourages the model to mention new topics and introduce variety. A higher <strong class="source-inline">presence_penalty</strong> value will make the model less likely to repeat the same topics or entities that have already been discussed, leading to a wider range of subjects in <span class="No-Break">the output.</span></li><li><strong class="source-inline">frequency_penalty</strong>: Similar to <strong class="source-inline">presence_penalty</strong>, <strong class="source-inline">frequency_penalty</strong> discourages the model from repeating the same lines or information. A higher <strong class="source-inline">frequency_penalty</strong> value makes the model less likely to use the same words or phrases frequently, promoting more varied and less <span class="No-Break">repetitive language.</span></li></ul></li>
			</ul>
			<p class="callout-heading">Differences between presence penalty and frequency penalty</p>
			<p class="callout">Although the <strong class="source-inline">presence_penalty</strong> and <strong class="source-inline">frequency_penalty</strong> parameters look similar, they <a id="_idIndexMarker257"/>work in slightly different ways. The <strong class="source-inline">presence_penalty</strong> parameter is about topics, and when it’s high, it promotes <a id="_idIndexMarker258"/>topic diversity. For example, if the answer is about technology and it contains the topic “<em class="italic">artificial intelligence</em>,” a high <strong class="source-inline">presence_penalty</strong> value would try to prevent that topic from appearing again. The <strong class="source-inline">frequency_penalty</strong> is about words and linguistic variety. For example, if the answer already contains “<em class="italic">cutting-edge technology</em>,” a high <strong class="source-inline">frequency_penalty</strong> value would encourage the model to find other words to express the same idea, such as “<em class="italic">new techniques</em>,” instead of repeating “<em class="italic">cutting-edge </em><span class="No-Break"><em class="italic">technology</em></span><span class="No-Break">” again.</span></p>
			<ul>
				<li><strong class="source-inline">input_variables</strong>: This attribute contains a single array called <strong class="source-inline">parameters</strong>. Each parameter has <span class="No-Break">three components:</span><ul><li><strong class="source-inline">name</strong>: The name <a id="_idIndexMarker259"/>of the parameter. For the following <strong class="source-inline">config.json</strong> file, the names would be <strong class="source-inline">input</strong>, <strong class="source-inline">history</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">options</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">description</strong>: An important parameter that describes what the parameter is. It’s used by the planner to figure out which functions to use and which parameters to pass <span class="No-Break">to them.</span></li><li><strong class="source-inline">required</strong>: This specifies whether the value is required <span class="No-Break">or not.</span></li></ul></li>
			</ul>
			<p>The following is a completed example of a <span class="No-Break"><strong class="source-inline">config.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
{
     "schema": 1,
     "type": "completion",
     "description": "Gets the intent of the user.",
    "execution_settings": {
        "default": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        },
        "gpt4": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        }
    },
     "input_variables":[
               {
                    "name": "input",
                    "description": "The user's request.",
                    "required": true
               },
               {
                    "name": "history",
                    "description": "The user's previous requests.",
                    "required": true
               },
               {
                    "name": "options",
                    "description": "Any options the user has already told us about.",
                    "required": false
               }
]
     }
}</pre>			<p>Now that we <a id="_idIndexMarker260"/>know the details of creating <strong class="source-inline">config.json</strong> files, let’s create a semantic plugin to <span class="No-Break">evaluate proposals.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Evaluating the grant proposal with a semantic plugin</h2>
			<p>Our semantic <a id="_idIndexMarker261"/>plugin will use the following <span class="No-Break">directory structure:</span></p>
			<pre class="source-code">
└───ch3
    └───plugins
        └───ProposalChecker
             ├───CheckQualifications
             |     ├───skprompt.txt
             |     └───config.json
             ├───CheckExperience
             |     ├───skprompt.txt
             |     └───config.json
             ├───CheckImplementationDescription
             |     ├───skprompt.txt
             |     └───config.json</pre>			<p>As explained <a id="_idIndexMarker262"/>at the beginning of the chapter, the three semantic functions we will implement are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">CheckQualifications</strong>: Determines whether the team requesting the grant has the required academic qualifications to perform the <span class="No-Break">vaccination campaign</span></li>
				<li><strong class="source-inline">CheckExperience</strong>: Determines whether the team requesting the grant has performed a successful <span class="No-Break">campaign before</span></li>
				<li><strong class="source-inline">CheckImplementationDescription</strong>: Determines whether the proposal contains reasonable deadlines by which to implement <span class="No-Break">the campaign</span></li>
			</ul>
			<p>The following are the <strong class="source-inline">config.json</strong> and the <strong class="source-inline">skprompt.txt</strong> files for all these functions. For simplicity, we will use the same configuration for the <strong class="source-inline">config.json</strong> file for all <span class="No-Break">three functions.</span></p>
			<h3>Implementing the semantic functions</h3>
			<p>We’re going to implement a semantic function that checks whether the project team fulfills the <a id="_idIndexMarker263"/>required qualifications for the project. The qualifications are that one of the members has to have training in the medical sciences, and at least one other should have <span class="No-Break">a Ph.D.</span></p>
			<p>First, we have the <strong class="source-inline">config.json</strong> file for the first semantic <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">CheckQualifications</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json for CheckQualifications</p>
			<pre class="source-code">
{
    "schema": 1,
    "type": "completion",
    "description": "Check whether project managers fulfill the required qualifications",
    "execution_settings": {
        "default": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        }
    },
    "input_variables": [
        {
            "name": "input",
            "description": "Biographies of the project managers including their qualifications",
            "defaultValue": ""
        }
    ]
}</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt for CheckQualifications</p>
			<p>The metaprompt receives the biographies of the project team as an input and checks whether they have the required qualifications, returning <strong class="source-inline">"No"</strong> if they don’t and <strong class="source-inline">"Yes"</strong> if <span class="No-Break">they do:</span></p>
			<pre class="source-code">
These are the biographies of the project team:
{{$input}}
We require at least one of the project team members to have a Ph.D. and at least one to have experience in the medical sciences.
If the project team does not meet these requirements, say "No".
If the project team meets these requirements, say "Yes"</pre>			<p>Next, we will show the <strong class="source-inline">config.json</strong> file for the second semantic <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">CheckExperience</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json for CheckExperience</p>
			<p>We’re just going <a id="_idIndexMarker264"/>to change the description of the function and the parameters. To save space, we show just the changes in the following code. All remaining attributes are the same as the ones for <strong class="source-inline">CheckQualifications</strong>. You can check the GitHub repository for the <span class="No-Break">complete file:</span></p>
			<pre class="source-code">
"description": "Check whether the project team has the required experience deploying a project of this size and complexity",
    "input_variables": [
        {
            "name": "input",
            "description": "Description of an earlier project",
            "defaultValue": ""
        }
    ]</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt for CheckExperience</p>
			<p>The metaprompt receives the experience of the project team as an input and checks whether they <a id="_idIndexMarker265"/>have the required experience, returning <strong class="source-inline">"No"</strong> if they don’t and <strong class="source-inline">"</strong><strong class="source-inline">Yes"</strong> if <span class="No-Break">they do:</span></p>
			<pre class="source-code">
The project team provided this experience:
{{$input}}
Do they have enough experience to conduct a massive vaccination campaign in a new country?
If they have had a successful experience in Atlantis or another large country, respond "Yes", otherwise respond "No".</pre>			<p>Finally, we show the <strong class="source-inline">config.json</strong> file for the second semantic <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">CheckImplementationDescription</strong></span><span class="No-Break">.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json for CheckImplementationDescription</p>
			<p>For the configuration of this function, we are just going to change the description of the function and the parameters. To save space, we show just the changes in the following code. All remaining attributes are the same as the ones for <strong class="source-inline">CheckQualifications</strong>. </p>
			<p>You can check the GitHub repository for the <span class="No-Break">complete file:</span></p>
			<pre class="source-code">
"description": "Check whether the project description includes reasonable dates in their project implementation",
    "input_variables": [
        {
            "name": "input",
            "description": "Description of the implementation of the project",
            "required": true
        }
    ]</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt for CheckImplementationDescription</p>
			<p>The metaprompt for <strong class="source-inline">CheckImplementationDescription</strong> checks whether the project has <a id="_idIndexMarker266"/>reasonable dates between <strong class="source-inline">2024</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">2025</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
The project team provided this implementation description:
{{$input}}
Can they fulfill the vaccination campaign in two years, starting in 2024 and ending in 2025?
If there are no dates listed, say No.
If the dates are outside of the 2024-2025 range, say No.
If there are dates between 2024 and 2025, say Yes.</pre>			<h3>Loading and testing the semantic functions</h3>
			<p>Now that <a id="_idIndexMarker267"/>we have created both a native function that extracts <a id="_idIndexMarker268"/>text from a Word document and a set of semantic functions to analyze its contents, we just need to call them in sequence to check whether the proposal fulfills <span class="No-Break">the requirements.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>We start by <a id="_idIndexMarker269"/>creating a helper function that given a Kernel, a document, a header, and a function name, returns the result of checking the header <a id="_idIndexMarker270"/>with <span class="No-Break">the function:</span></p>
			<pre class="source-code">
async Task&lt;string&gt; CheckDocumentPart(Kernel kernel, string path, string part, string function)
{
    KernelPlugin documentPlugin = kernel.Plugins["ParseWordDocument"];
    KernelFunction documentParser = documentPlugin["ExtractTextUnderHeading"];
    KernelPlugin documentReader = kernel.Plugins["ProposalChecker"];
    var contextVariables = new KernelArguments
    {
        ["filePath"] = path,
        ["heading"] = part
    };
    // Check for text
    var text = await kernel.InvokeAsync(documentParser, contextVariables);
    var contextVariables2 = new KernelArguments
    {
        ["input"] = text.ToString(),
    };
    var result = await kernel.InvokeAsync(documentReader[function], contextVariables2);
    return result.ToString();
}</pre>			<p>We then <a id="_idIndexMarker271"/>call that function with each of the example documents <a id="_idIndexMarker272"/>we want to test. For brevity, the following code includes just one call, but you can see the tests for all documents in the <span class="No-Break">GitHub repository:</span></p>
			<pre class="source-code">
var docPath1 = $"{data_directory}/correct/correct.docx";
string result_experience = CheckDocumentPart(kernel, docPath1, "Experience", "CheckExperience").Result;
string result_qualifications = CheckDocumentPart(kernel, docPath1, "Team", "CheckQualifications").Result;
string result_implementation = CheckDocumentPart(kernel, docPath1, "Implementation", "CheckImplementationDescription").Result;
Console.WriteLine($"Checking {docPath1}");
Console.WriteLine($"Experience: {result_experience}");
Console.WriteLine($"Qualifications: {result_qualifications}");
Console.WriteLine($"Implementation: {result_implementation}");</pre>			<p>The results are <span class="No-Break">as follows:</span></p>
			<pre class="console">
Experience: Yes
Qualifications: Yes
Implementation: Yes</pre>			<p>The following code shows how to run both the Excel checks and the Word checks <span class="No-Break">in Python:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>In Python, we import <a id="_idIndexMarker273"/>the <strong class="source-inline">semantic_kernel</strong> libraries and <a id="_idIndexMarker274"/>the modules that contain our native functions: <strong class="source-inline">CheckSpreadsheet</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ParseWordDocument</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from semantic_kernel.utils.settings import openai_settings_from_dot_env
from CheckSpreadsheet import CheckSpreadsheet
from ParseWordDocument import ParseWordDocument
from semantic_kernel.functions.kernel_arguments import KernelArguments</pre>			<p>To make things simpler, we create two helper functions. The first helper function, <strong class="source-inline">run_spreadsheet_check</strong>, will check whether a spreadsheet is correct. To do so, it imports the <strong class="source-inline">CheckSpreadsheet</strong> native plugin, and given a <strong class="source-inline">path</strong> variable representing the path of a spreadsheet file and the name of a native <strong class="source-inline">function</strong>, runs the native function on the file that <strong class="source-inline">path</strong> <span class="No-Break">points to:</span></p>
			<pre class="source-code">
async def run_spreadsheet_check(path, function):
    kernel = sk.Kernel()
    check_spreadsheet = kernel.add_plugin(CheckSpreadsheet(), "CheckSpreadsheet")
    result = await kernel.invoke(
        check_spreadsheet[function], KernelArguments(path = path)
    )
    print(result)</pre>			<p>The second <a id="_idIndexMarker275"/>helper function, <strong class="source-inline">run_document_check</strong>, is used to check Word documents. It creates a semantic kernel and <a id="_idIndexMarker276"/>adds the GPT-3.5 service to it. Then, it attaches the <strong class="source-inline">ParseWordDocument</strong> native plugin and the Proposal Checker <span class="No-Break">semantic plugin.</span></p>
			<p>The function <a id="_idIndexMarker277"/>receives <span class="No-Break">four parameters:</span></p>
			<ul>
				<li><strong class="source-inline">path</strong>: The path of the document we want <span class="No-Break">to check</span></li>
				<li><strong class="source-inline">function</strong>: The native function that we are going to use to parse <span class="No-Break">the document</span></li>
				<li><strong class="source-inline">target_heading</strong>: The heading we want to extract from <span class="No-Break">the document</span></li>
				<li><strong class="source-inline">semantic_function</strong>: The semantic function that we want to use to evaluate the text extracted from <span class="No-Break">the document</span></li>
				<li>Later, we will run this function once per header we want to parse. For example, if we call the function with the following parameters, we would open the <strong class="source-inline">correct.docx</strong> document, use the <strong class="source-inline">ExtractTextUnderHeading</strong> native function to extract the text under the heading <strong class="source-inline">"Experience"</strong>, and then run the <strong class="source-inline">CheckExperience</strong> semantic function on the <span class="No-Break">extracted text:</span><pre class="source-code">
run_document_check("correct.docx", "ExtractTextUnderHeading", "Experience", "CheckExperience")</pre></li>			</ul>
			<p>Let’s see <a id="_idIndexMarker278"/>how to define a function that does all that. We first <a id="_idIndexMarker279"/>create the kernel and add <span class="No-Break">the plugins:</span></p>
			<pre class="source-code">
async def run_document_check(path, function, target_heading, semantic_function):
    kernel = sk.Kernel()
    api_key, org_id = openai_settings_from_dot_env()
    gpt35 = OpenAIChatCompletion("gpt-3.5-turbo", api_key, org_id, service_id = "gpt35")
    kernel.add_service(gpt35)
    parse_word_document = kernel.add_plugin(ParseWordDocument(), "ParseWordDocument")
    text = await kernel.invoke(
        parse_word_document[function],
        KernelArguments(doc_path = path, target_heading = target_heading)
    )
    check_docs = kernel.add_plugin(None, "ProposalChecker", "../../plugins")
    result = await kernel.invoke(check_docs[semantic_function], KernelArguments(input = text))
    print(f"{target_heading}: {result}")</pre>			<p>Still inside the <strong class="source-inline">run_document_check</strong> helper function, we use the native function we defined <a id="_idIndexMarker280"/>in the <em class="italic">Evaluating the Word document</em> section <a id="_idIndexMarker281"/>of this chapter to extract the whole text of <span class="No-Break">the document:</span></p>
			<pre class="source-code">
    text = await kernel.run_async(
        parse_word_document[function],
        input_vars=variables
    )</pre>			<p>Now that we have the text, we run the function passed as a parameter of <strong class="source-inline">run_document_check</strong> to check it has the contents <span class="No-Break">we want:</span></p>
			<pre class="source-code">
    check_docs = kernel.import_semantic_skill_from_directory("../plugins", "ProposalChecker")
    result = check_docs[semantic_function](str(text))
    print(f"{target_heading}: {result}")</pre>			<p>Now back to the main program, the following code uses the two helper functions defined previously to check several documents. For brevity, we show just a few calls here, but the source code in the GitHub repository does all <span class="No-Break">the checks:</span></p>
			<pre class="source-code">
async def main():
    data_path = "../data/proposals/"
    await run_spreadsheet_check(f"{data_path}/correct/correct.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect2/over_budget.xlsx", "CheckCells")
    await run_spreadsheet_check(f"{data_path}/incorrect3/fast_increase.xlsx", "CheckValues")
    print("Word document checks:")
    await run_document_check(f"{data_path}/correct/correct.docx", "ExtractTextUnderHeading", "Experience", "CheckExperience")
    await run_document_check(f"{data_path}/correct/correct.docx", "ExtractTextUnderHeading", "Team", "CheckQualifications")
    await run_document_check(f"{data_path}/correct/correct.docx", "ExtractTextUnderHeading", "Implementation", "CheckImplementationDescription")
# Run the main function
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>The <a id="_idIndexMarker282"/>results <a id="_idIndexMarker283"/>are <span class="No-Break">as follows:</span></p>
			<pre class="console">
Experience: Yes
Qualifications: Yes
Implementation: Yes</pre>			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Summary</h1>
			<p>In this chapter, you learned how to create native functions and combine them into plugins. You also learned how to create semantic functions and all the details of their parameters, and how to combine them <span class="No-Break">into plugins.</span></p>
			<p>In the next chapter, we will learn how to generate images from Semantic Kernel, and we will also learn how to use the functions covered here with slight modifications to create a pipeline that can process <span class="No-Break">many documents.</span></p>
		</div>
	</div>
</div>
</body></html>