<html><head></head><body>
<div><div><div><h1 id="_idParaDest-72" class="chapter-number"><a id="_idTextAnchor071"/>3</h1>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Extending Semantic Kernel</h1>
			<p><strong class="bold">Plugins</strong> encapsulate AI capabilities into a single unit of functionality. Plugins are the building blocks <a id="_idIndexMarker202"/>of AI applications. We will learn about the different types of functions (native functions and semantic functions) and how to expose these functions as a plugin, so that they can be used by Semantic Kernel.</p>
			<p>In previous chapters, we created and used very simple plugins. In this chapter, we will start by describing the pre-existing tools that you already have available just by installing Semantic Kernel. Then, we will explore the best practices for developing your own <strong class="bold">native plugins</strong>, which are <a id="_idIndexMarker203"/>collections of native functions. These functions perform tasks that AI cannot do well, such as querying a database or doing complex math. Lastly, you will <a id="_idIndexMarker204"/>learn how to create <strong class="bold">semantic plugins</strong>, which are collections of semantic functions. These functions are executed by an AI service such as OpenAI’s GPT. We will explore the different parameters and how they work together. Throughout this chapter, we will use an application that evaluates grant requests for a nonprofit as our use case.</p>
			<p>In this chapter, we’ll be covering the following topics:</p>
			<ul>
				<li>The out-of-the-box plugins</li>
				<li>Creating native functions</li>
				<li>Creating semantic functions</li>
			</ul>
			<p>By the end of the chapter, you will have the tools required to build a kernel that can perform many coordinated functions, and that will be easier to use as a copilot or to be integrated into other tools such as the planner. In the next chapter, we will use this kernel to process a pipeline of documents.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have a recent, supported version of your preferred Python or C# development environment:</p>
			<ul>
				<li>For Python, the minimum supported version is Python 3.10, and the recommended version is Python 3.11</li>
				<li>For C#, the minimum supported version is .NET 8</li>
			</ul>
			<p>In this chapter, we will call OpenAI services. Given the amount that companies spend on training these LLMs, it’s no surprise that using these services is not free. You will need an <strong class="bold">OpenAI API</strong> key, obtained either directly through <strong class="bold">OpenAI</strong> or <strong class="bold">Microsoft</strong>, via the <strong class="bold">Azure </strong><strong class="bold">OpenAI</strong> service.</p>
			<p>If you are using .NET, the code for this chapter is at <a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch3">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch3</a>.</p>
			<p>If you are using Python, the code for this chapter is at <a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch3">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch3</a>.</p>
			<p>You can install the required packages by going to the GitHub repository and using the following: <code>pip install -</code><code>r requirements.txt</code>.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Getting to know the core plugins</h1>
			<p>Large language models are great at generating text and images, but they are currently unreliable for <a id="_idIndexMarker205"/>several other tasks, for example:</p>
			<ul>
				<li>Retrieving data from external data sources, such as the filesystem and the web</li>
				<li>Interacting with the system’s clock</li>
				<li>Performing math, even simple arithmetic functions</li>
			</ul>
			<p>The Semantic Kernel installation includes several plugins for tasks that are very frequently used. The core plugins are native plugins that provide functionality that LLMs struggle with.</p>
			<p>To use the plugins in C#, you need to import the <code>Microsoft.SemanticKernelCoreSkills</code> library, and to use the plugins in Python, you need to import the plugins from the <code>semantic_kernel.core_skills</code> library.</p>
			<p class="callout-heading">Skills or plugins?</p>
			<p class="callout">When the <a id="_idIndexMarker206"/>Microsoft Semantic Kernel was first released, plugins were called <em class="italic">skills</em>. This changed when OpenAI allowed developers to build extensions to ChatGPT and called these <a id="_idIndexMarker207"/>extensions <em class="italic">plugins</em>. Since the purpose is the same, the Semantic Kernel team decided to change the name from <em class="italic">skills</em> to <em class="italic">plugins</em>, but the old name lives on in the existing code in some places. This is likely to change in the future.</p>
			<p>The following list shows the plugins that are currently available in Semantic Kernel:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Plugin Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">What </strong><strong class="bold">it does</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Available </strong><strong class="bold">in Python?</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Available </strong><strong class="bold">in C#?</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>TimePlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Acquires the time of day and any other temporal information</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ConversationSummaryPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Summarizes a conversation</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>FileIOPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Reads and writes to the filesystem</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>HttpPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Calls APIs</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>MathPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Performs mathematical operations</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>TextMemoryPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Stores and retrieves text in memory</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>TextPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Manipulates text strings deterministically</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>WaitPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Pauses execution for a specified amount of time</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>WebSearchPlugin</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Performs Bing web searches and returns results</p>
						</td>
						<td class="No-Table-Style">
							<p>✅</p>
						</td>
						<td class="No-Table-Style">
							<p>❌</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – Core plugins and their functions</p>
			<p>At the time of writing , the core <a id="_idIndexMarker208"/>plugins don’t have documentation. To see their parameters, you must read their code on the GitHub repository. For example, to find the <a id="_idIndexMarker209"/>parameters for the <code>TimePlugin</code>, you have to go directly to the repository:</p>
			<ul>
				<li>C#: <a href="https://github.com/microsoft/semantic-kernel/blob/main/dotnet/src/Plugins/Plugins.Core/TimePlugin.cs">https://github.com/microsoft/semantic-kernel/blob/main/dotnet/src/Plugins/Plugins.Core/TimePlugin.cs</a></li>
				<li>Python: <a href="https://github.com/microsoft/semantic-kernel/blob/main/python/semantic_kernel/core_plugins/time_plugin.py">https://github.com/microsoft/semantic-kernel/blob/main/python/semantic_kernel/core_plugins/time_plugin.py</a></li>
			</ul>
			<p>Here are the parameters available for <code>TimePlugin</code>:</p>
			<pre class="source-code">
{{time.date}}          =&gt; Sunday, 12 January, 2031
{{time.today}}         =&gt; Sunday, 12 January, 2031
{{time.iso_date}}      =&gt; 2031-01-12
{{time.now}}           =&gt; Sunday, January 12, 2031 9:15 PM
{{time.utcNow}}        =&gt; Sunday, January 13, 2031 5:15 AM
{{time.time}}          =&gt; 09:15:07 PM
{{time.year}}          =&gt; 2031
{{time.month}}         =&gt; January
{{time.monthNumber}}   =&gt; 01
{{time.day}}           =&gt; 12
{{time.dayOfWeek}}     =&gt; Sunday
{{time.hour}}          =&gt; 9 PM
{{time.hourNumber}}    =&gt; 21
{{time.days_ago $days}} =&gt; Sunday, 7 May, 2023
{{time.last_matching_day $dayName}} =&gt; Sunday, 7 May, 2023
{{time.minute}}        =&gt; 15
{{time.minutes}}       =&gt; 15
{{time.second}}        =&gt; 7
{{time.seconds}}       =&gt; 7
{{time.timeZoneOffset}}=&gt; -0800
{{time.timeZoneName}}  =&gt; PST</pre>			<p>Now that <a id="_idIndexMarker210"/>we know the available parameters, let’s see a quick sample of what the plugin can do.</p>
			<p>To use the out-of-the-box plugins in C#, you first need to install the <code>Plugins.Core</code> package. To install it, use the following command (change the version to match your Semantic Kernel version):</p>
			<pre class="console">
dotnet add package Microsoft.SemanticKernel.Plugins.Core --version 1.7.1-alpha</pre>			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>An example – Using the TimePlugin</h2>
			<p>We’re <a id="_idIndexMarker211"/>going to use the <code>TimePlugin</code> as part of the prompt of a semantic function. First, we create an instance of the <code>TimePlugin</code> and name it <code>time</code>.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating the TimePlugin in C#</p>
			<p>The core plugins for C# are still in pre-release. To use them, you need to add a <code>#pragma</code> directive (<code>SKEXP0050</code>) to disable the pre-release warning. You also need to import the <code>Microsoft.SemanticKernel.Plugins.Core</code> package.</p>
			<p>We are going to add the plugin using the <code>AddFromType</code> method of the Semantic <code>KernelBuilder</code> object:</p>
			<pre class="source-code">
# pragma warning disable SKEXP0050
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Plugins.Core;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder()
                        .AddOpenAIChatCompletion("gpt-3.5-turbo", apiKey, orgId, serviceId: "gpt35");
builder.Plugins.AddFromType&lt;TimePlugin&gt;(pluginName: "time");
Kernel kernel = builder.Build();</pre>			<p>Let’s see <a id="_idIndexMarker212"/>how to do it in Python next.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating the TimePlugin in Python</p>
			<p>In Python, the core plugins are in the <code>semantic_kernel.core_plugins</code> package. Once you import the plugin you want to use from that package, you can load it into the kernel with the <code>add_plugin</code> method:</p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
from semantic_kernel.utils.settings import openai_settings_from_dot_env
import semantic_kernel as sk
from semantic_kernel.core_plugins.time_plugin import TimePlugin
async def main():
    kernel = sk.Kernel()
    api_key, org_id = openai_settings_from_dot_env()
    gpt35 = OpenAIChatCompletion("gpt-3.5-turbo", api_key, org_id, "gpt35")
    kernel.add_service(gpt35)
    kernel.add_plugin(TimePlugin(), "time")</pre>			<p>Then, we create <a id="_idIndexMarker213"/>a semantic function and invoke it, as we did in both previous chapters:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Invoking the TimePlugin in C#</p>
			<pre class="source-code">
const string promptTemplate = @"
Today is: {{time.date}}
Current time is: {{time.time}}
Answer to the following questions using JSON syntax, including the data used.
Is it morning, afternoon, evening, or night (morning/afternoon/evening/night)?
Is it weekend time (weekend/not weekend)?";
var results = await kernel.InvokePromptAsync(promptTemplate);
Console.WriteLine(results);</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Invoking the TimePlugin in Python</p>
			<pre class="source-code">
    prompt  = """
    Today is: {{time.date}}
    Current time is: {{time.time}}
    Answer to the following questions using JSON syntax, including the data used.
    Is it morning, afternoon, evening, or night (morning/afternoon/evening/night)?
    Is it weekend time (weekend/not weekend)?
    """
    prompt_function = kernel.add_function(function_name="ex03", plugin_name="sample", prompt=prompt)
    response = await kernel.invoke(prompt_function, request=prompt)</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Results</p>
			<p>For both languages, you should expect to get a JSON file that gives you information about the <a id="_idIndexMarker214"/>current time. Since we did not specify the exact JSON format in our prompt, the fields chosen by your invocation may be different:</p>
			<pre class="console">
{
  "date": "Wednesday, 21 June, 2023",
  "time": "12:17:02 AM",
  "period": "night",
  "weekend": "not weekend"
}</pre>			<p>While there’s a lot that you can do with the core plugins, in most cases you’ll have to develop your own plugins. In the remainder of this chapter, we will explore the details of developing <a id="_idIndexMarker215"/>native and semantic functions.</p>
			<p>But first, let’s look at our sample application that we’ll be employing to study the development of native and semantic plugins.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Introducing the application – Validating grants</h1>
			<p>For this chapter and the next, imagine you are working for an organization that gives monetary grants to projects. For example, this could be the Department of Education giving away $100,000 to projects that will teach AI in high schools, or a non-profit organization <a id="_idIndexMarker216"/>such as the Gates Foundation giving $1,000,000 away to the three best proposals to eradicate malaria. The same concept also applies to several processes in corporations: for example, before sending a quote to a customer, a corporation may require that it fulfills some requirements, such as having a price, an expiration date, and some legal language. Another example is submitting visa applications in the United States. Lawyers must send several documents documenting the candidate’s academic and professional skills, in addition to several forms. If they miss one form or document, the whole application is rejected and they have to submit it again, including having to pay all the fees again.</p>
			<p>In these next two chapters, we are going to write a simple application that evaluates a Word document that contains a grant request for a vaccination project and an Excel file with a budget. Our program will evaluate whether it fulfills the requirements of our grant program. If it doesn’t, it will tell the submitter what’s missing. To achieve that, we will write a native plugin to evaluate the Excel file, another native plugin to break the Word document into parts, and a semantic plugin to evaluate the contents of the Word document that describes project proposal.</p>
			<p class="callout-heading">The second random selection for H-1B visas in 2021</p>
			<p class="callout">In July of 2021, the <strong class="bold">U.S. Citizenship and Immigration Services</strong> (<strong class="bold">USCIS</strong>) determined <a id="_idIndexMarker217"/>that they needed to conduct a second round of H-1B applications for their employment-based visa. The H-1B visa is used mostly by tech companies, and some large tech companies such as Amazon, Alphabet, Meta, and Microsoft had to file tens of thousands of applications in a short period of time. The applications needed to be manually reviewed by lawyers, an expensive <a id="_idIndexMarker218"/>and time-consuming project. Any error in the application would cause it to be automatically rejected, which could result in people having to leave the United States. The techniques we show in these two chapters can be used to build an application that reviews thousands of documents in minutes. Manual reviews are still required, but at least the most egregious errors will be automatically detected, saving the time of lawyers.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Directory structure of our application</h2>
			<p>In our example in this and the following chapter, we will create an application that evaluates <a id="_idIndexMarker219"/>grant requests for a vaccination program by checking the content of two documents: a Word document and an Excel spreadsheet.</p>
			<p>Each grant request will be in a directory containing the Excel spreadsheet that has the budget requested for the vaccination campaign and the Word document that describes the team that will be executing the vaccination program and their experience.</p>
			<p>The data is available in the <code>data</code> directory of the book’s GitHub repository, and its directory structure is as follows:</p>
			<pre class="source-code">
data
├───correct
│       correct.docx
│       correct.xlsx
├───incorrect01
│       incorrect_template.xlsx
│       missing_experience.docx
├───incorrect02
│       missing_qualifications.docx
│       over_budget.xlsx
├───incorrect03
│       correct.docx
│       fast_increase.xlsx
├───incorrect04
│       correct.docx
│       incorrect_cells.xlsx
├───incorrect05
│       incorrect_cells.xlsx
├───incorrect06
│       correct.docx
├───incorrect07
│       correct.xlsx
│       missing_experience.docx
├───incorrect08
│       correct.xlsx
│       missing_qualifications.docx
├───incorrect09
│       correct.xlsx
│       wrong_dates.docx
└───incorrect10
        correct.docx
        correct.xlsx
        missing_experience.docx</pre>			<p>For this chapter, we will use the first four grant requests. One set of documents is valid, which is stored in the directory named <code>correct</code>, while the other three, which are stored in <code>incorrect1</code>, <code>incorrect2</code> and <code>incorrect3</code>, respectively, have problems, which will be described later in this chapter.</p>
			<p>Evaluating the <em class="italic">structure</em> of documents is something that is easier and more reliable with regular <a id="_idIndexMarker220"/>programming than with LLMs. On the other hand, evaluating the <em class="italic">content</em> of documents is something that is easier with LLMs than with regular programming.</p>
			<p>We are going to do the first part using native functions.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Developing native plugins</h1>
			<p>Let’s start with native functions. Native functions are regular code in your language of choice (Python or C#) and do not necessarily require a specific directory structure, unlike semantic <a id="_idIndexMarker221"/>functions. However, it is easier to put the native functions together with the main code of your program. This will make it easier to import the classes.</p>
			<p class="callout-heading">Avoid duplicate names</p>
			<p class="callout">Since semantic functions are directories and native functions are source code files, it’s possible to have a semantic function and a native function with the same name inside a plugin, for example a directory named <code>my_function</code> and a source code file named <code>my_function.py</code>. If you do that, the last function loaded (the source code file) will overwrite the first, leading to unexpected problems. Therefore, avoid duplicate names. At the time of writing, Semantic Kernel does not provide a warning when this happens.</p>
			<p>Let’s look at the directory structure of our plugins.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>The directory structure of our plugins</h2>
			<p>Semantic <a id="_idIndexMarker222"/>Kernel offers a function to add plugins from a directory. While you can always load plugins one at a time, setting up the plugins in the <a id="_idIndexMarker223"/>following directory structure makes it easier to load them into the kernel with fewer function calls:</p>
			<pre class="source-code">
└───ch3
    └───proposals
    └───plugins
    |    └───ProposalChecker
    |         ├───CheckQualifications
    |         |     ├───skprompt.txt
    |         |     └───config.json
    |         ├───CheckExperience
    |         |     ├───skprompt.txt
    |         |     └───config.json
    |         └───CheckImplementationDescription
    |               ├───skprompt.txt
    |               └───config.json
    └───code
          ├───python
          |    ├───program.py
          |    ├───<strong class="bold">ParseWordDocument.py</strong>
          |    └───<strong class="bold">CheckSpreadsheet.py</strong>
          └───dotnet
               ├───Program.cs
               ├───<strong class="bold">ParseWordDocument.cs</strong>
               └───<code>CheckQualifications</code>, <code>CheckExperience</code>, and <code>CheckImplementationDescription</code>, are semantic functions and will be addressed in the <em class="italic">Developing semantic plugins </em>section. The <code>CheckSpreadsheet</code> and <code>ParseWordDocument</code> files contain native functions that perform the following:</p>
			<ul>
				<li><code>CheckSpreadsheet</code>: Validates the spreadsheet to make sure it contains all required fields</li>
				<li><code>ParseWordDocument</code>: Validates the Word document and makes sure it contains all the required headings</li>
			</ul>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Checking the structure of our Excel spreadsheet</h2>
			<p>The <a id="_idIndexMarker224"/>desired structure of the Excel <a id="_idIndexMarker225"/>spreadsheet for our application is as follows:</p>
			<ul>
				<li>The Excel file needs to have exactly two sheets, one named <code>2024</code> and another named <code>2025</code></li>
				<li>Each sheet needs to follow the following template:</li>
			</ul>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Quarter</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Budget</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Q1</p>
						</td>
						<td class="No-Table-Style">
							<p>$99,999</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Q2</p>
						</td>
						<td class="No-Table-Style">
							<p>$99,999</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Q3</p>
						</td>
						<td class="No-Table-Style">
							<p>$99,999</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Q4</p>
						</td>
						<td class="No-Table-Style">
							<p>$99,999</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>It needs to follow these rules:</p>
			<ul>
				<li>The total budget to implement the vaccination campaign for each year needs to be below $1,000,000</li>
				<li>No more than a 10% increase quarter over quarter</li>
			</ul>
			<p>To test the function, we created the following Excel workbooks:</p>
			<ul>
				<li><code>correct.xslx</code>: A workbook that follows all the rules and should pass the test</li>
				<li><code>incorrect_template.xlsx</code>: A workbook that doesn’t have the sheets named <code>2024</code> and <code>2025</code> and should fail the test</li>
				<li><code>over_budget.xlsx</code>: A spreadsheet that follows the format but requests more than a million dollars per year and should fail the test</li>
				<li><code>fast_increase.xlsx</code>: A spreadsheet that follows the format and is under budget, but has expenses increasing by more than 10% quarter over quarter, and should therefore fail the test</li>
			</ul>
			<p>We will <a id="_idIndexMarker226"/>implement the code to check <a id="_idIndexMarker227"/>these spreadsheets in the following section.</p>
			<h3>Using native functions to check the Excel spreadsheet</h3>
			<p>For both <a id="_idIndexMarker228"/>languages, native functions must be defined as public methods in a class that represents your plugin. The functions will return text because that will be easier to integrate with semantic functions later.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>In Python, we’re <a id="_idIndexMarker229"/>going to use the <strong class="bold">OpenPyXL</strong> package (<a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a>), which makes it easy to open an Excel file, ensure it has the required number of tabs, ensure that it has the required tables, and load the tables into variables:</p>
			<pre class="source-code">
import openpyxl
from typing_extensions import Annotated
from semantic_kernel.functions.kernel_function_decorator import kernel_function
class CheckSpreadsheet:</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using System.ComponentModel;
using Microsoft.SemanticKernel;
using OfficeOpenXml;
namespace Plugins.ProposalChecker;
public class CheckSpreadsheet
{
}</pre>			<p>Now that <a id="_idIndexMarker230"/>we have the class templates created, we will need to add the functions that implement the functionality that checks the spreadsheet.</p>
			<p>To add functions to your class, you need to use the <code>KernelFunction</code> (C#) or <code>kernel_function</code> (Python) decorator. This will enable Semantic Kernel to recognize the function. When using the decorator, you need to add the <code>Description</code> attribute for the function and its parameters. This description can be used by planners to decide which functions to use when the user sends a request, as we saw in <a href="B21826_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</p>
			<p>Our first function, <code>CheckTabs</code>, checks that the spreadsheet has the two required tabs named <code>2024</code> and <code>2025</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
    @kernel_function(
        description="Checks that the spreadsheet contains the correct tabs, 2024 and 2025",
        name="CheckTabs",
    )
    def CheckTabs(self,
                  path: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        try:
            workbook = openpyxl.load_workbook(path)
            sheet_names = workbook.sheetnames
            if sheet_names == ['2024', '2025']:
                return "Pass"
            else:
                return "Fail: the spreadsheet does not contain the correct tabs"
        except Exception as e:
            return f"Fail: an exception {e} occurred when trying to open the spreadsheet"</pre>			<p>The function <a id="_idIndexMarker231"/>opens the workbook with the <code>load_workbook</code> method of <code>openpyxl</code> and checks that it has exactly two tabs named <code>2024</code> and <code>2025</code>. If it succeeds, it returns <code>"Pass"</code>. Otherwise, it returns <code>"Fail"</code> and provides an error description.</p>
			<p>In Python, you can tell the name you want Semantic Kernel to use with the function by using the <code>name</code> attribute of the <code>kernel_function</code> decorator. You can also describe your input parameters using the <code>Annotated</code> decorators. The first parameter of the <code>Annotated</code> decorator is the type of the input parameter and the second is its description.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
    [KernelFunction, Description("Checks that the spreadsheet contains the correct tabs, 2024 and 2025")]
    public string CheckTabs([Description("The file path to the spreadsheet")] string filePath)
    {
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Fail: File does not exist.";
            }
            using (var package = new ExcelPackage(fileInfo))
            {
                ExcelPackage.LicenseContext = OfficeOpenXml.LicenseContext.NonCommercial;
                var workbook = package.Workbook;
                if (workbook.Worksheets.Count != 2)
                {
                    return "Fail: Spreadsheet does not contain 2 tabs.";
                }
                if (workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2024") &amp;&amp; workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2025"))
                {
                    return "Pass";
                }
                else
                {
                    return "Fail: Spreadsheet does not contain 2024 and 2025 tabs.";
                }
            }
        }
        catch (Exception ex)
        {
            return $"Fail: An error occurred: {ex.Message}";
        }
    }</pre>			<p>The function opens the workbook with the <code>ExcelPackage</code> class of <code>OfficeOpenXml</code> and checks that it has exactly two tabs named <code>2024</code> and <code>2025</code>. If it succeeds, it returns <code>"Pass"</code>. Otherwise, it returns <code>"Fail"</code> and provides an error description.</p>
			<p>In C#, we use parameter decorators to add a <code>Description</code> attribute to parameters when <a id="_idIndexMarker232"/>declaring a function, and a <code>KernelFunction</code> function decorator that makes the function accessible to <code>SemanticKernel</code> and describes its purpose with the <code>Description</code> attribute.</p>
			<p>Now that we have the plugin and the test data set up, let’s write a simple program that will perform just the first two tests: checking that the spreadsheet exists and checking whether it contains the tabs we expect. We will add more tests later.</p>
			<h3>Checking the contents of the worksheets</h3>
			<p>In the <a id="_idIndexMarker233"/>following code, we are going to check the contents of each sheet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using System.IO;
var (apiKey, orgId) = Settings.LoadFromFile();
Kernel kernel = Kernel.CreateBuilder()
                        .AddOpenAIChatCompletion("gpt-3.5-turbo", apiKey, orgId, serviceId: "gpt35")
                        .Build();
var checkerPlugin = kernel.ImportPluginFromObject(new Plugins.ProposalChecker.CheckSpreadsheet());</pre>			<p>Using the familiar template, we use the <code>Settings.LoadFromFile</code> method to load the API key, use <code>KernelBuilder</code> and <code>AddOpenAIChatCompletion</code> to connect to the OpenAI <a id="_idIndexMarker234"/>service for later, and then use the <code>ImportPluginFromObject</code> method of the kernel to import the <code>CheckSpreadsheet</code> class.</p>
			<p>Now we can check the spreadsheets by using <code>InvokeAsync</code> and passing the <code>CheckTabs</code> function as its function parameter, and each file as its <code>filePath</code> parameter:</p>
			<pre class="source-code">
 // Check for tabs
var result1 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/correct/correct.xlsx"});
var result2 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/incorrect01/incorrect_template.xlsx"});
var result3 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/incorrect02/over_budget.xlsx"});
var result4 = await kernel.InvokeAsync(checkerPlugin["CheckTabs"], new() {["filePath"] = $"{data_directory}/incorrect03/fast_increase.xlsx"});
Console.WriteLine("Checking whether the correct tabs are present in the spreadsheet:");
Console.WriteLine(result1);
Console.WriteLine(result2);
Console.WriteLine(result3);
Console.WriteLine(result4);</pre>			<p>Let’s see <a id="_idIndexMarker235"/>how to perform the checks with Python:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from semantic_kernel.utils.settings import openai_settings_from_dot_env
from CheckSpreadsheet import CheckSpreadsheet
from ParseWordDocument import ParseWordDocument
from semantic_kernel.functions.kernel_arguments import KernelArguments
async def run_spreadsheet_check(path, function):
    kernel = sk.Kernel()
    check_spreadsheet = kernel.add_plugin(CheckSpreadsheet(), "CheckSpreadsheet")
    result = await kernel.invoke(
        check_spreadsheet[function], KernelArguments(path = path)
    )
    print(result)
async def main():
    data_path = "../../data/proposals"
    await run_spreadsheet_check(f"{data_path}/correct/correct.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect01/incorrect_template.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect02/over_budget.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect03/fast_increase.xlsx", "CheckTabs")
# Run the main function
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>In Python, we <a id="_idIndexMarker236"/>use the <code>add_plugin</code> method to import the native function class and the <code>kernel.invoke</code> method to invoke it. In the preceding code, I put the functionality in a function called <code>run_spreadsheet_check</code>.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Results</p>
			<p>We are running the test on four files, one that we expect to pass and three that we expect to fail. The results come out as expected:</p>
			<pre class="console">
Pass
Fail: the spreadsheet does not contain the correct tabs
Fail: Sum of values in year 2025 exceeds 1,000,000.
Fail: More than 10% growth found from B2 to B3 in sheet 2024.</pre>			<p>Now that <a id="_idIndexMarker237"/>we have our initial template done, we need to add the other functions to the plugin to perform all the checks we need.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Additional checks</h2>
			<p>We still <a id="_idIndexMarker238"/>need to check the following:</p>
			<ul>
				<li>Whether there are exactly 10 cells filled in each tab</li>
				<li>Whether the budget adds up to less than $1,000,000</li>
				<li>Whether the budget grows by 10% or less each quarter</li>
			</ul>
			<p>Let’s start by checking whether the spreadsheet has all the cells we expect:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>In Python, we create a dictionary with the list of expected cells and make sure that they are filled. Don’t forget to use the <code>@kernel_function</code> decorator, otherwise Semantic Kernel won’t be able to find the function:</p>
			<pre class="source-code">
    @kernel_function(
        description="Checks that the spreadsheet contains the correct cells A1-B5",
        name="CheckCells",
    )
    def CheckCells(self,
                 path: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        workbook = openpyxl.load_workbook(path)
        required_cells = {
            'A1': 'Quarter', 'B1': 'Budget',
            'A2': 'Q1', 'A3': 'Q2', 'A4': 'Q3', 'A5': 'Q4'
        }
        for year in ['2024', '2025']:
            sheet = workbook[year]
            for cell, value in required_cells.items():
                if sheet[cell].value != value:
                    return "Fail: missing quarters"
            for row in range(2, 6):
                if not isinstance(sheet[f'B{row}'].value, (int, float)):
                    return "Fail: non-numeric inputs"
        return "Pass"</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>In C#, we will <a id="_idIndexMarker239"/>check the cells one by one. It is still a very straightforward function, where we simply look at each cell and check to see whether it has the expected value. Remember to add the <code>KernelFunction</code> decorator before the declaration of the function or Semantic Kernel will not recognize it:</p>
			<pre class="source-code">
    [KernelFunction, Description("Checks that each tab contains the cells A1-A5 and B1-B5 with the correct values")]
    public static string CheckCells([Description("The file path to the spreadsheet")] string filePath)
    {
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Fail: File does not exist.";
            }
            using (var package = new ExcelPackage(fileInfo))
            {
                foreach (var year in new[] { "2024", "2025" })
                {
                    var sheet = package.Workbook.Worksheets[year];
                    if (sheet.Cells["A1"].Text != "Quarter" || sheet.Cells["B1"].Text != "Budget" ||
                        sheet.Cells["A2"].Text != "Q1" || sheet.Cells["A3"].Text != "Q2" ||
                        sheet.Cells["A4"].Text != "Q3" || sheet.Cells["A5"].Text != "Q4")
                    {
                        return "Fail: missing quarters";
                    }
                    for (int row = 2; row &lt;= 5; row++)
                    {
                        if (sheet.Cells[$"B{row}"].Value is not double)
                        {
                            return "Fail: non-numeric values";
                        }
                    }
                }
                return "Pass";
            }
        }
        catch (Exception ex)
        {
            return $"Fail: An error occurred: {ex.Message}";
        }
    }</pre>			<p>The final <a id="_idIndexMarker240"/>step is to check whether the content of the numeric cells follows the two rules we defined: a budget of no more than $1M per year, and no more than a 10% increase per quarter.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>Again, don’t forget to add the <code>@kernel_function</code> decorator so that Semantic Kernel can find your function. The function is straightforward, going from cell B2 to B5 and checking <a id="_idIndexMarker241"/>whether they increase by more than 10%, and then also checking the sum to make sure it’s under $1M:</p>
			<pre class="source-code">
    @kernel_function(
        description="Checks that the spreadsheet contains the correct values, less than 1m per year and growth less than 10%",
        name="CheckValues",
    )
    def CheckValues(self,
                    path: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        workbook = openpyxl.load_workbook(path)
        years = ['2024', '2025']
        for year in years:
            if year not in workbook.sheetnames:
                return f"Fail: Sheet for year {year} not found."
            sheet = workbook[year]
            values = [sheet[f'B{row}'].value for row in range(2, 6)]
            if not all(isinstance(value, (int, float)) for value in values):
                return f"Fail: Non-numeric value found in sheet {year}."
            if sum(values) &gt;= 1000000:
                return f"Fail: Sum of values in year {year} exceeds 1,000,000."
            for i in range(len(values) - 1):
                if values[i + 1] &gt; values[i] * 1.10:
                    return f"Fail: More than 10% growth found from B{i+2} to B{i+3} in sheet {year}."
        return "Pass"</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>We are <a id="_idIndexMarker242"/>going to do our checks in two steps. First, we load the file and iterate through the numeric cells, adding them to an array:</p>
			<pre class="source-code">
    [KernelFunction, Description("Check that the cells B2-B5 add to less than 1 million and don't increase over 10% each quarter")]
    public static string CheckValues([Description("The file path to the spreadsheet")] string filePath)
    {
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Fail: file does not exist.";
            }
            using (var package = new ExcelPackage(fileInfo))
            {
                foreach (var year in new[] { "2024", "2025" })
                {
                    var sheet = package.Workbook.Worksheets[year];
                    if (sheet == null)
                    {
                        return "Fail: Sheet for year {year} not found.";
                    }
                    double[] values = new double[4];
                    for (int i = 0; i &lt; 4; i++)
                    {
                        if (sheet.Cells[i + 2, 2].Value is not double)
                        {
                            return $"Non-numeric value found in sheet {year}.";
                        }
                        else values[i] = (double)sheet.Cells[i + 2, 2].Value;
                    }</pre>			<p>Then we <a id="_idIndexMarker243"/>check whether the sum of the values of the array is over $1M and whether there’s growth of over 10%:</p>
			<pre class="source-code">
                    if (sum(values) &gt;= 1000000)
                    {
                        return $"Sum of values in year {year} exceeds 1,000,000.";
                    }
                    for (int i = 0; i &lt; values.Length - 1; i++)
                    {
                        if (values[i + 1] &gt; values[i] * 1.10)
                        {
                            return $"More than 10% growth found from B{i+2} to B{i+3} in sheet {year}.";
                        }
                    }
                }
                return "Pass";
            }
        }
        catch (Exception ex)
        {
            return $"An error occurred: {ex.Message}";
        }
    }</pre>			<p>To make <a id="_idIndexMarker244"/>the check of the sum of values simpler, create a simple helper function called <code>sum</code> that returns the sum of an array of doubles:</p>
			<pre class="source-code">
    static double sum(double[] values)
    {
        double total = 0;
        foreach (var value in values)
        {
            total += value;
        }
        return total;
    }</pre>			<p>By combining <a id="_idIndexMarker245"/>all the functions above in <code>CheckSpreadsheet.py</code> (Python) and <code>CheckSpreadsheet.cs</code> (C#), we can verify all the Excel files in the <code>data/proposals</code> folder. The entire code is in the GitHub repository for this chapter.</p>
			<p>Besides having an Excel file, each proposal also has a Word document, of which we want to check a few aspects.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Evaluating the Word document</h2>
			<p>The proposal document will have three sections describing the team that is proposing a vaccination <a id="_idIndexMarker246"/>campaign, their experience, and the implementation details of their proposal. We want to check three aspects of the proposal document:</p>
			<ul>
				<li>Whether the team has people with experience in the medical sciences with at least one having a Ph.D. This information should be under a <em class="italic">Heading 1</em> section named <code>Team</code>.</li>
				<li>Whether the team has successfully deployed a vaccination campaign before. This information should be under a <em class="italic">Heading 1</em> section named <code>Experience</code>.</li>
				<li>Whether the project proposal has an implementation detail describing when the vaccination campaign starts and when it ends. This information should be under a <em class="italic">Heading 1</em> section named <code>Implementation Plan</code>.</li>
			</ul>
			<p>To verify that the proposals fulfill the requirements, we are going to send the text from the Word document to a semantic function later that will tell us whether it fulfills the requirements, but first we are going to write a native function that extracts the contents of the relevant sections of each of the Word documents:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>To open the Python document, we need to use the <code>python-docx</code> package. You can install this with the following command:</p>
			<pre class="console">
pip install python-docx</pre>			<p>Note that even though we import the <code>docx</code> package in the Python code, we need to install <code>python-docx</code>. If you install a package named <code>docx</code>, it will not work — that’s an old, deprecated package.</p>
			<p>We define <a id="_idIndexMarker247"/>our native function and make sure that it will be available to Semantic Kernel by decorating it with the <code>kernel_function</code> decorator, and its parameters and return value with the <code>Annotated</code> decorator:</p>
			<pre class="source-code">
from docx import Document
from typing_extensions import Annotated
from semantic_kernel.functions.kernel_function_decorator import kernel_function
class ParseWordDocument:
    @kernel_function(
        description="Extract the text under the given heading",
        name="ExtractTextUnderHeading",
    )</pre>			<p>We create a <code>ParseWordDocument</code> class to hold our native plugin, and inside that class we create a function called <code>ExtractTextUnderHeading</code>.</p>
			<p>The <a id="_idIndexMarker248"/>remainder of the code looks for a <em class="italic">Heading 1</em> with the text <code>target_heading</code> and then reads all its paragraphs:</p>
			<pre class="source-code">
     async def ExtractTextUnderHeading(self,
            doc_path: Annotated[str, "The path for the file we want to evaluate"],
            target_heading: Annotated[str, "The heading we want to extract the text from"]
            ) -&gt; Annotated[str, "The extracted text"]:
        doc = Document(str(doc_path))
        extract = False
        extracted_text = ''
        for paragraph in doc.paragraphs:
            if paragraph.style.name == 'Heading 1':
                if extract:
                    break  # Stop if next heading is found
                extract = paragraph.text.strip().lower() == str(target_heading).lower()
            elif extract:
                extracted_text += paragraph.text + '\n'
        return extracted_text.strip()</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using System.ComponentModel;
using Microsoft.SemanticKernel;
namespace Plugins.ProposalChecker;
public class ParseWordDocument
{
    [KernelFunction, Description("Extracts the text under the heading in the Word document")]
    public static string ExtractTextUnderHeading(string filePath, string heading)</pre>			<p>In the C# version of our plugin, we declare a <code>ParseWordDocument</code> class and a <code>ExtractTextUnderHeading</code> function. Don’t forget to add the <code>KernelFunction</code> decorator, otherwise Semantic Kernel will not find your function.</p>
			<p>The <a id="_idIndexMarker249"/>function reads all the body of the document first, and then reads all the paragraphs. Then it finds all paragraphs after a <em class="italic">Heading 1</em> that matches the <code>heading</code> parameter and returns them:</p>
			<pre class="source-code">
       using (WordprocessingDocument doc = WordprocessingDocument.Open(filePath, false))
        {
            var body = doc.MainDocumentPart?.Document.Body;
            var paras = body?.Elements&lt;Paragraph&gt;();
            bool isExtracting = false;
            string extractedText = "";
            // if paras is null, return empty string
            if (paras == null)
            {
                return extractedText;
            }
            foreach (var para in paras)
            {
                if (para.ParagraphProperties != null &amp;&amp;
                    para.ParagraphProperties.ParagraphStyleId != null &amp;&amp;
                    para.ParagraphProperties.ParagraphStyleId.Val != null &amp;&amp;
                    para.ParagraphProperties.ParagraphStyleId.Val.Value == "Heading1" &amp;&amp;
                    para.InnerText.Trim().Equals(heading, StringComparison.OrdinalIgnoreCase))
                {
                    isExtracting = true;
                    continue;
                }
                if (isExtracting)
                {
                    if (para.ParagraphProperties != null &amp;&amp;
                        para.ParagraphProperties.ParagraphStyleId != null &amp;&amp;
                        para.ParagraphProperties.ParagraphStyleId.Val != null &amp;&amp;
                        para.ParagraphProperties.ParagraphStyleId.Val.Value == "Heading1")
                    {
                        break;
                    }
                    extractedText += para.InnerText + "\n";
                }
            }
            return extractedText.Trim();
        }
    }
}</pre>			<p>We will <a id="_idIndexMarker250"/>not invoke this function yet. First, we will create a semantic plugin that we will use to parse the results of the function we created above. Once we do that, we will call both functions one after another.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Developing semantic plugins</h1>
			<p>A semantic <a id="_idIndexMarker251"/>plugin is just a collection of semantic functions. Semantic functions are functions that use AI services, such as the OpenAI service or the Azure OpenAI service, to perform tasks.</p>
			<p class="callout-heading">Important – using the OpenAI services is not free</p>
			<p class="callout">The semantic functions will call the OpenAI API. These calls require a paid subscription, and each call will incur a cost. The costs are usually small per request. GPT 3.5 costs $0.0002 per thousand tokens, but this can add up if you make a large number of calls. Note also that the prices change frequently, so make sure to check the latest prices on the following websites.</p>
			<p class="callout">OpenAI pricing: <a href="https://openai.com/pricing">https://openai.com/pricing</a></p>
			<p class="callout">Azure OpenAI pricing: <a href="https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/">https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/</a></p>
			<p>Each plugin <a id="_idIndexMarker252"/>must have its own directory, and the name of the directory is the plugin name. The directory should contain one subdirectory per function. The name of each subdirectory is the name of the function.</p>
			<p>Each subdirectory must contain two files: <code>skprompt.txt</code> and <code>config.json</code>. The <code>skprompt.txt</code> file contains the prompt for the semantic function that will be submitted to the AI service:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">A sample skprompt.txt</p>
			<p>The <code>skprompt.txt</code> file contains a <code>var</code> variable would appear as <code>{{$var}}</code> inside<code> skprompt.txt</code>.</p>
			<p>The following example <code>skprompt.txt</code> contains three variables: <code>history</code>, <code>input</code>, and <code>options</code>:</p>
			<pre class="source-code">
[History]
{{$history}}
User: {{$input}}
---------------------------------------------
Provide the intent of the user. The intent should be one of the following: {{$options}}
INTENT:</pre>			<p>The preceding <code>history</code>, <code>input,</code> and <code>options</code> variables are just an example to show a metaprompt with multiple <a id="_idIndexMarker254"/>variables. For our grant verification use case, we will start with just one variable, called <code>input</code>, and the <code>skprompt.txt</code> file will be described in the following <em class="italic">Evaluating the grant proposal with a semantic </em><em class="italic">plugin</em> section.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">A sample config.json</p>
			<p>The <code>config.json</code> file contains the parameters that control the output of the AI service.</p>
			<p>When <a id="_idIndexMarker255"/>creating a <code>config.json</code> file, you need to specify the following parameters:</p>
			<ul>
				<li><code>schema</code>: Reserved for future use, and should currently be set to <code>1</code>. In the future, this will be used for versioning.</li>
				<li><code>type</code>: Reserved for future use, and should currently be set to <code>completion</code>. In the future, this will be used for different types of LLMs, but this has not been implemented in Semantic Kernel yet.</li>
				<li><code>description</code>: An important parameter that describes what the function does. It’s used by <code>planner</code> to figure out what the function can help the user accomplish.</li>
				<li><code>execution_settings</code>: This is an object that contains multiple objects. You should always add an object called <code>"default"</code> inside of it. If the semantic function is called by a service with a <code>service_id</code> of <code>"gpt4"</code>, it will look for an object called <code>"gpt4"</code> inside the <code>execution_settings</code> to find which settings to use. If it doesn’t find it, it will use the <code>execution_settings</code> defined under <code>"default"</code>. This allows you to configure different parameters per service.</li>
				<li>An OpenAI service should contain the following parameters:<ul><li><code>max_tokens</code>: This parameter specifies the maximum length of the response from the model. It’s measured in tokens, which can be words or parts of words. For example, the word “<em class="italic">OpenAI</em>” is one token, but “<em class="italic">OpenAI’s</em>” might be two tokens (“<em class="italic">OpenAI</em>” and “<em class="italic">’s</em>”). Setting a higher number of <code>max_tokens</code> allows for longer responses, but also consumes more computational resources. A good rule of thumb is to assume that tokens add 33% to the number of words, so a text with 75 words will need approximately 100 tokens.</li><li><code>temperature</code>: The temperature controls the randomness of the model’s output. A lower temperature (close to <code>0</code>) makes the model’s responses more predictable and deterministic, while a higher temperature (closer to <code>1</code>) increases <a id="_idIndexMarker256"/>randomness and creativity in the responses. A temperature of <code>0</code> means the model will always choose the most likely next token, whereas at <code>1</code>, it chooses more freely.</li><li><code>top_p</code> (also known as nucleus sampling): Helps in controlling the diversity of the generated text. It works by only considering the most likely next tokens that cumulatively make up the probability <em class="italic">p</em>. For instance, if <code>top_p</code> is set to <code>0.9</code>, the model will choose the next token from the top 90% of the probability distribution. Lower values of <code>top_p</code> make the model more conservative in its choices, while higher values allow for more diversity and less predictability.</li><li><code>presence_penalty</code>: Encourages the model to mention new topics and introduce variety. A higher <code>presence_penalty</code> value will make the model less likely to repeat the same topics or entities that have already been discussed, leading to a wider range of subjects in the output.</li><li><code>frequency_penalty</code>: Similar to <code>presence_penalty</code>, <code>frequency_penalty</code> discourages the model from repeating the same lines or information. A higher <code>frequency_penalty</code> value makes the model less likely to use the same words or phrases frequently, promoting more varied and less repetitive language.</li></ul></li>
			</ul>
			<p class="callout-heading">Differences between presence penalty and frequency penalty</p>
			<p class="callout">Although the <code>presence_penalty</code> and <code>frequency_penalty</code> parameters look similar, they <a id="_idIndexMarker257"/>work in slightly different ways. The <code>presence_penalty</code> parameter is about topics, and when it’s high, it promotes <a id="_idIndexMarker258"/>topic diversity. For example, if the answer is about technology and it contains the topic “<em class="italic">artificial intelligence</em>,” a high <code>presence_penalty</code> value would try to prevent that topic from appearing again. The <code>frequency_penalty</code> is about words and linguistic variety. For example, if the answer already contains “<em class="italic">cutting-edge technology</em>,” a high <code>frequency_penalty</code> value would encourage the model to find other words to express the same idea, such as “<em class="italic">new techniques</em>,” instead of repeating “<em class="italic">cutting-edge </em><em class="italic">technology</em>” again.</p>
			<ul>
				<li><code>input_variables</code>: This attribute contains a single array called <code>parameters</code>. Each parameter has three components:<ul><li><code>name</code>: The name <a id="_idIndexMarker259"/>of the parameter. For the following <code>config.json</code> file, the names would be <code>input</code>, <code>history</code>, and <code>options</code>.</li><li><code>description</code>: An important parameter that describes what the parameter is. It’s used by the planner to figure out which functions to use and which parameters to pass to them.</li><li><code>required</code>: This specifies whether the value is required or not.</li></ul></li>
			</ul>
			<p>The following is a completed example of a <code>config.json</code> file:</p>
			<pre class="source-code">
{
     "schema": 1,
     "type": "completion",
     "description": "Gets the intent of the user.",
    "execution_settings": {
        "default": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        },
        "gpt4": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        }
    },
     "input_variables":[
               {
                    "name": "input",
                    "description": "The user's request.",
                    "required": true
               },
               {
                    "name": "history",
                    "description": "The user's previous requests.",
                    "required": true
               },
               {
                    "name": "options",
                    "description": "Any options the user has already told us about.",
                    "required": false
               }
]
     }
}</pre>			<p>Now that we <a id="_idIndexMarker260"/>know the details of creating <code>config.json</code> files, let’s create a semantic plugin to evaluate proposals.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Evaluating the grant proposal with a semantic plugin</h2>
			<p>Our semantic <a id="_idIndexMarker261"/>plugin will use the following directory structure:</p>
			<pre class="source-code">
└───ch3
    └───plugins
        └───ProposalChecker
             ├───CheckQualifications
             |     ├───skprompt.txt
             |     └───config.json
             ├───CheckExperience
             |     ├───skprompt.txt
             |     └───config.json
             ├───CheckImplementationDescription
             |     ├───skprompt.txt
             |     └───config.json</pre>			<p>As explained <a id="_idIndexMarker262"/>at the beginning of the chapter, the three semantic functions we will implement are as follows:</p>
			<ul>
				<li><code>CheckQualifications</code>: Determines whether the team requesting the grant has the required academic qualifications to perform the vaccination campaign</li>
				<li><code>CheckExperience</code>: Determines whether the team requesting the grant has performed a successful campaign before</li>
				<li><code>CheckImplementationDescription</code>: Determines whether the proposal contains reasonable deadlines by which to implement the campaign</li>
			</ul>
			<p>The following are the <code>config.json</code> and the <code>skprompt.txt</code> files for all these functions. For simplicity, we will use the same configuration for the <code>config.json</code> file for all three functions.</p>
			<h3>Implementing the semantic functions</h3>
			<p>We’re going to implement a semantic function that checks whether the project team fulfills the <a id="_idIndexMarker263"/>required qualifications for the project. The qualifications are that one of the members has to have training in the medical sciences, and at least one other should have a Ph.D.</p>
			<p>First, we have the <code>config.json</code> file for the first semantic function, <code>CheckQualifications</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json for CheckQualifications</p>
			<pre class="source-code">
{
    "schema": 1,
    "type": "completion",
    "description": "Check whether project managers fulfill the required qualifications",
    "execution_settings": {
        "default": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        }
    },
    "input_variables": [
        {
            "name": "input",
            "description": "Biographies of the project managers including their qualifications",
            "defaultValue": ""
        }
    ]
}</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt for CheckQualifications</p>
			<p>The metaprompt receives the biographies of the project team as an input and checks whether they have the required qualifications, returning <code>"No"</code> if they don’t and <code>"Yes"</code> if they do:</p>
			<pre class="source-code">
These are the biographies of the project team:
{{$input}}
We require at least one of the project team members to have a Ph.D. and at least one to have experience in the medical sciences.
If the project team does not meet these requirements, say "No".
If the project team meets these requirements, say "Yes"</pre>			<p>Next, we will show the <code>config.json</code> file for the second semantic function, <code>CheckExperience</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json for CheckExperience</p>
			<p>We’re just going <a id="_idIndexMarker264"/>to change the description of the function and the parameters. To save space, we show just the changes in the following code. All remaining attributes are the same as the ones for <code>CheckQualifications</code>. You can check the GitHub repository for the complete file:</p>
			<pre class="source-code">
"description": "Check whether the project team has the required experience deploying a project of this size and complexity",
    "input_variables": [
        {
            "name": "input",
            "description": "Description of an earlier project",
            "defaultValue": ""
        }
    ]</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt for CheckExperience</p>
			<p>The metaprompt receives the experience of the project team as an input and checks whether they <a id="_idIndexMarker265"/>have the required experience, returning <code>"No"</code> if they don’t and <code>"</code><code>Yes"</code> if they do:</p>
			<pre class="source-code">
The project team provided this experience:
{{$input}}
Do they have enough experience to conduct a massive vaccination campaign in a new country?
If they have had a successful experience in Atlantis or another large country, respond "Yes", otherwise respond "No".</pre>			<p>Finally, we show the <code>config.json</code> file for the second semantic function, <code>CheckImplementationDescription</code>.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json for CheckImplementationDescription</p>
			<p>For the configuration of this function, we are just going to change the description of the function and the parameters. To save space, we show just the changes in the following code. All remaining attributes are the same as the ones for <code>CheckQualifications</code>. </p>
			<p>You can check the GitHub repository for the complete file:</p>
			<pre class="source-code">
"description": "Check whether the project description includes reasonable dates in their project implementation",
    "input_variables": [
        {
            "name": "input",
            "description": "Description of the implementation of the project",
            "required": true
        }
    ]</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt for CheckImplementationDescription</p>
			<p>The metaprompt for <code>CheckImplementationDescription</code> checks whether the project has <a id="_idIndexMarker266"/>reasonable dates between <code>2024</code> and <code>2025</code>:</p>
			<pre class="source-code">
The project team provided this implementation description:
{{$input}}
Can they fulfill the vaccination campaign in two years, starting in 2024 and ending in 2025?
If there are no dates listed, say No.
If the dates are outside of the 2024-2025 range, say No.
If there are dates between 2024 and 2025, say Yes.</pre>			<h3>Loading and testing the semantic functions</h3>
			<p>Now that <a id="_idIndexMarker267"/>we have created both a native function that extracts <a id="_idIndexMarker268"/>text from a Word document and a set of semantic functions to analyze its contents, we just need to call them in sequence to check whether the proposal fulfills the requirements.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>We start by <a id="_idIndexMarker269"/>creating a helper function that given a Kernel, a document, a header, and a function name, returns the result of checking the header <a id="_idIndexMarker270"/>with the function:</p>
			<pre class="source-code">
async Task&lt;string&gt; CheckDocumentPart(Kernel kernel, string path, string part, string function)
{
    KernelPlugin documentPlugin = kernel.Plugins["ParseWordDocument"];
    KernelFunction documentParser = documentPlugin["ExtractTextUnderHeading"];
    KernelPlugin documentReader = kernel.Plugins["ProposalChecker"];
    var contextVariables = new KernelArguments
    {
        ["filePath"] = path,
        ["heading"] = part
    };
    // Check for text
    var text = await kernel.InvokeAsync(documentParser, contextVariables);
    var contextVariables2 = new KernelArguments
    {
        ["input"] = text.ToString(),
    };
    var result = await kernel.InvokeAsync(documentReader[function], contextVariables2);
    return result.ToString();
}</pre>			<p>We then <a id="_idIndexMarker271"/>call that function with each of the example documents <a id="_idIndexMarker272"/>we want to test. For brevity, the following code includes just one call, but you can see the tests for all documents in the GitHub repository:</p>
			<pre class="source-code">
var docPath1 = $"{data_directory}/correct/correct.docx";
string result_experience = CheckDocumentPart(kernel, docPath1, "Experience", "CheckExperience").Result;
string result_qualifications = CheckDocumentPart(kernel, docPath1, "Team", "CheckQualifications").Result;
string result_implementation = CheckDocumentPart(kernel, docPath1, "Implementation", "CheckImplementationDescription").Result;
Console.WriteLine($"Checking {docPath1}");
Console.WriteLine($"Experience: {result_experience}");
Console.WriteLine($"Qualifications: {result_qualifications}");
Console.WriteLine($"Implementation: {result_implementation}");</pre>			<p>The results are as follows:</p>
			<pre class="console">
Experience: Yes
Qualifications: Yes
Implementation: Yes</pre>			<p>The following code shows how to run both the Excel checks and the Word checks in Python:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>In Python, we import <a id="_idIndexMarker273"/>the <code>semantic_kernel</code> libraries and <a id="_idIndexMarker274"/>the modules that contain our native functions: <code>CheckSpreadsheet</code> and <code>ParseWordDocument</code>:</p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from semantic_kernel.utils.settings import openai_settings_from_dot_env
from CheckSpreadsheet import CheckSpreadsheet
from ParseWordDocument import ParseWordDocument
from semantic_kernel.functions.kernel_arguments import KernelArguments</pre>			<p>To make things simpler, we create two helper functions. The first helper function, <code>run_spreadsheet_check</code>, will check whether a spreadsheet is correct. To do so, it imports the <code>CheckSpreadsheet</code> native plugin, and given a <code>path</code> variable representing the path of a spreadsheet file and the name of a native <code>function</code>, runs the native function on the file that <code>path</code> points to:</p>
			<pre class="source-code">
async def run_spreadsheet_check(path, function):
    kernel = sk.Kernel()
    check_spreadsheet = kernel.add_plugin(CheckSpreadsheet(), "CheckSpreadsheet")
    result = await kernel.invoke(
        check_spreadsheet[function], KernelArguments(path = path)
    )
    print(result)</pre>			<p>The second <a id="_idIndexMarker275"/>helper function, <code>run_document_check</code>, is used to check Word documents. It creates a semantic kernel and <a id="_idIndexMarker276"/>adds the GPT-3.5 service to it. Then, it attaches the <code>ParseWordDocument</code> native plugin and the Proposal Checker semantic plugin.</p>
			<p>The function <a id="_idIndexMarker277"/>receives four parameters:</p>
			<ul>
				<li><code>path</code>: The path of the document we want to check</li>
				<li><code>function</code>: The native function that we are going to use to parse the document</li>
				<li><code>target_heading</code>: The heading we want to extract from the document</li>
				<li><code>semantic_function</code>: The semantic function that we want to use to evaluate the text extracted from the document</li>
				<li>Later, we will run this function once per header we want to parse. For example, if we call the function with the following parameters, we would open the <code>correct.docx</code> document, use the <code>ExtractTextUnderHeading</code> native function to extract the text under the heading <code>"Experience"</code>, and then run the <code>CheckExperience</code> semantic function on the extracted text:<pre class="source-code">
run_document_check("correct.docx", "ExtractTextUnderHeading", "Experience", "CheckExperience")</pre></li>			</ul>
			<p>Let’s see <a id="_idIndexMarker278"/>how to define a function that does all that. We first <a id="_idIndexMarker279"/>create the kernel and add the plugins:</p>
			<pre class="source-code">
async def run_document_check(path, function, target_heading, semantic_function):
    kernel = sk.Kernel()
    api_key, org_id = openai_settings_from_dot_env()
    gpt35 = OpenAIChatCompletion("gpt-3.5-turbo", api_key, org_id, service_id = "gpt35")
    kernel.add_service(gpt35)
    parse_word_document = kernel.add_plugin(ParseWordDocument(), "ParseWordDocument")
    text = await kernel.invoke(
        parse_word_document[function],
        KernelArguments(doc_path = path, target_heading = target_heading)
    )
    check_docs = kernel.add_plugin(None, "ProposalChecker", "../../plugins")
    result = await kernel.invoke(check_docs[semantic_function], KernelArguments(input = text))
    print(f"{target_heading}: {result}")</pre>			<p>Still inside the <code>run_document_check</code> helper function, we use the native function we defined <a id="_idIndexMarker280"/>in the <em class="italic">Evaluating the Word document</em> section <a id="_idIndexMarker281"/>of this chapter to extract the whole text of the document:</p>
			<pre class="source-code">
    text = await kernel.run_async(
        parse_word_document[function],
        input_vars=variables
    )</pre>			<p>Now that we have the text, we run the function passed as a parameter of <code>run_document_check</code> to check it has the contents we want:</p>
			<pre class="source-code">
    check_docs = kernel.import_semantic_skill_from_directory("../plugins", "ProposalChecker")
    result = check_docs[semantic_function](str(text))
    print(f"{target_heading}: {result}")</pre>			<p>Now back to the main program, the following code uses the two helper functions defined previously to check several documents. For brevity, we show just a few calls here, but the source code in the GitHub repository does all the checks:</p>
			<pre class="source-code">
async def main():
    data_path = "../data/proposals/"
    await run_spreadsheet_check(f"{data_path}/correct/correct.xlsx", "CheckTabs")
    await run_spreadsheet_check(f"{data_path}/incorrect2/over_budget.xlsx", "CheckCells")
    await run_spreadsheet_check(f"{data_path}/incorrect3/fast_increase.xlsx", "CheckValues")
    print("Word document checks:")
    await run_document_check(f"{data_path}/correct/correct.docx", "ExtractTextUnderHeading", "Experience", "CheckExperience")
    await run_document_check(f"{data_path}/correct/correct.docx", "ExtractTextUnderHeading", "Team", "CheckQualifications")
    await run_document_check(f"{data_path}/correct/correct.docx", "ExtractTextUnderHeading", "Implementation", "CheckImplementationDescription")
# Run the main function
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>The <a id="_idIndexMarker282"/>results <a id="_idIndexMarker283"/>are as follows:</p>
			<pre class="console">
Experience: Yes
Qualifications: Yes
Implementation: Yes</pre>			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Summary</h1>
			<p>In this chapter, you learned how to create native functions and combine them into plugins. You also learned how to create semantic functions and all the details of their parameters, and how to combine them into plugins.</p>
			<p>In the next chapter, we will learn how to generate images from Semantic Kernel, and we will also learn how to use the functions covered here with slight modifications to create a pipeline that can process many documents.</p>
		</div>
	</div>
</div>
</body></html>