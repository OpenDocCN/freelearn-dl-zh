- en: '*Chapter 4*: Implementing Sensors'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：实现传感器'
- en: 'As we discussed in the previous chapter, a character AI system needs to be
    aware of its surrounding environment. For example, **Non-Player Characters** (**NPCs**)
    need to know where the obstacles are, the direction the player is looking, whether
    they are in the player''s sight, and a lot more. The quality of the AI of our
    NPCs depends, for the most part, on the information they can get from the environment.
    Sensor mistakes are apparent to the player: we''ve all experienced playing a video
    game and laughing at an NPC that clearly should have seen us, or, on the other
    hand, been frustrated because an NPC spotted us from behind a wall.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，角色AI系统需要对其周围环境有所了解。例如，**非玩家角色**（**NPCs**）需要知道障碍物的位置，玩家的视线方向，他们是否在玩家的视线中，以及更多。我们NPC的AI质量在很大程度上取决于他们从环境中获取的信息。传感器错误对玩家来说是显而易见的：我们都有过在玩电子游戏时笑一个显然应该看到我们的NPC，或者另一方面，因为NPC从墙后发现了我们而感到沮丧的经历。
- en: Video game characters usually get the input information required by their underlying
    AI decision-making algorithms from sensory information. For simplicity, in this
    chapter, we will consider *sensory information* as any kind of data coming from
    the game world. If there's not enough information, characters might show unusual
    behaviors, such as choosing the wrong places to take cover, idling, or looping
    in strange actions without knowing how to proceed. A quick search for AI glitches
    on YouTube opens the door to a vast collection of common funny behaviors of AI,
    even in AAA games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 电子游戏角色通常从其底层AI决策算法所需的感觉信息中获取输入信息。为了简单起见，在本章中，我们将考虑*感觉信息*为来自游戏世界的任何类型的数据。如果信息不足，角色可能会表现出异常行为，例如选择错误的地方躲避，无所事事，或者在不了解如何进行的情况下重复奇怪的动作。在YouTube上快速搜索AI故障，就会打开通往大量常见有趣的AI行为的宝库，即使在AAA游戏中也是如此。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Introducing sensory systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍感觉系统
- en: Discovering what a sensory system is and how to implement two senses—sight and
    touch—in Unity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现什么是感觉系统以及如何在Unity中实现两种感觉——视觉和触觉
- en: Building a demo where we can see our sensory system in action
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个演示，我们可以看到我们的感觉系统在行动
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 4` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter04).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您只需要Unity3D 2022。您可以在本书仓库中的`第4章`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter04)。
- en: Basic sensory systems
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本感觉系统
- en: An AI sensory system emulates senses such as sight, hearing, and even smell
    to get information from other GameObjects. In such a system, the NPCs need to
    examine the environment and check for such senses periodically based on their
    particular interest.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个AI感觉系统模拟视觉、听觉甚至嗅觉，从其他GameObject中获取信息。在这样的系统中，NPC需要根据他们的特定兴趣定期检查环境和检查这些感觉。
- en: 'In a minimal sensory system, we have two principal elements: **aspect** (also
    called **event emitters**) and **sense** (also called **event senses**). Every
    sense can perceive only a specific aspect; for instance, an NPC with just the
    sense of hearing can only perceive the sound (one of the aspects) emitted by another
    GameObject, or a zombie NPC can use its sense of smell to prey on the player''s
    brain. As in real life, we do not need a single sense for every NPC; they can
    have sight, smell, and touch all at once.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个最小化的感觉系统中，我们有两个主要元素：**方面**（也称为**事件发射器**）和**感觉**（也称为**事件感觉**）。每个感觉只能感知特定的方面；例如，只有听觉感觉的NPC只能感知另一个GameObject发出的声音（其中一个方面），或者僵尸NPC可以使用其嗅觉捕食玩家的脑部。就像现实生活中一样，我们不需要每个NPC都有一个单一的感觉；他们可以同时拥有视觉、嗅觉和触觉。
- en: In our demo, we'll implement a base interface, called `Sense`, that we'll use
    to implement custom senses. In this chapter, we'll implement sight and touch senses.
    Sight is what we use to see the world around them; if our AI character sees an
    enemy, we receive an event in our code, and we act accordingly by doing some action
    in response. Likewise, with touch, when an enemy gets too close, we want to be
    able to sense that. Finally, we'll implement a minimal `Aspect` class that our
    senses can perceive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中，我们将实现一个基础接口，称为`Sense`，我们将用它来实现自定义感官。在本章中，我们将实现视觉和触觉感官。视觉是我们用来观察周围世界的；如果我们的AI角色看到敌人，我们的代码中会收到一个事件，然后我们会相应地执行一些动作。同样，对于触觉，当敌人太靠近时，我们希望能够感知到。最后，我们将实现一个最小的`Aspect`类，我们的感官可以感知到。
- en: Setting up our scene
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的场景
- en: 'Let''s get started by setting up our scene:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置我们的场景开始：
- en: First, we add a plane as a floor.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个平面作为地板。
- en: Let's create a few walls to block the line of sight from our AI character to
    the enemy. We make these out of short—but wide—cubes that we group under an empty
    GameObject called **Obstacles**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些墙壁来阻挡AI角色到敌人的视线。我们用短而宽的立方体制作这些墙壁，并将它们组合在一个名为**障碍物**的空GameObject下。
- en: Finally, we add a directional light to see what is going on in our scene.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个方向性光源来查看场景中的情况。
- en: 'We represent the player with a tank, similar to what we used earlier, and we
    represent the NPCs with simple cubes. We also have a **Target** object to show
    us where the tank is moving in our scene. Our Scene hierarchy should look similar
    to the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用坦克来代表玩家，类似于我们之前使用的，用简单的立方体来代表NPC。我们还有一个**目标**对象来显示坦克在我们的场景中的移动位置。我们的场景层次结构应该类似于以下截图：
- en: '![Figure 4.1 – The setup of the example''s Hierarchy'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 示例的层次结构设置'
- en: '](img/B17984_04_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_04_1.jpg)'
- en: Figure 4.1 – The setup of the example's Hierarchy
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 示例的层次结构设置
- en: 'Now, let''s position the tank, AI character, and walls randomly in our scene.
    First, make sure to increase the size of the plane to something that looks good.
    Fortunately, in this demo, all the objects are locked on the plane, and there
    is no simulated gravity so that nothing can fall off the plane. Also, be sure
    to adjust the camera so that we can have a clear view of the following scene:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的场景中随机放置坦克、AI角色和墙壁。首先，确保将平面的尺寸增加到看起来不错的大小。幸运的是，在这个演示中，所有物体都锁定在平面上，并且没有模拟重力，所以没有任何东西会从平面上掉落。此外，务必调整相机，以便我们可以清楚地看到以下场景：
- en: '![Figure 4.2 – The space that our tank and player wander in'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 我们坦克和玩家游荡的空间'
- en: '](img/B17984_04_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_04_2.jpg)'
- en: Figure 4.2 – The space that our tank and player wander in
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 我们坦克和玩家游荡的空间
- en: Now that we have the basics set up, let's look at how to implement the tank,
    AI character, and aspects for our player character.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了基本内容，让我们看看如何实现坦克、AI角色和玩家角色的方面。
- en: The player's tank and the aspect class
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家的坦克和方面类
- en: The **Target** object is a simple sphere object with the mesh render disabled.
    We have also created a point light and made it a child of our Target object. Make
    sure that the light is centered, or it will not be very helpful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**对象是一个简单的球体对象，网格渲染已禁用。我们还创建了一个点光源，并将其设置为我们的目标对象的子对象。确保灯光居中，否则它将不会很有帮助。'
- en: 'Look at the following code in the `Target.cs` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下`Target.cs`文件中的代码：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Attach this script to the Target object. The script detects the mouse-click
    event and then, using the raycasting technique, detects the mouse-click location
    on the plane in the 3D space, and updates the Target object's position in our
    scene. We will have a look at the player's tank in the following section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本附加到目标对象上。该脚本检测鼠标点击事件，然后使用射线投射技术检测3D空间中平面上鼠标点击的位置，并更新场景中目标对象的位置。我们将在下一节中查看玩家的坦克。
- en: The player's tank
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家的坦克
- en: The player's tank is the simple model we used in [*Chapter 2*](B17984_02_Epub.xhtml#_idTextAnchor100),
    *Finite State Machines*, with a non-kinematic `Rigidbody` component. We need the
    `Rigidbody` component to generate trigger events whenever we do collision detection
    with AI characters and environment objects. Finally, we need to assign the **Player**
    tag to our tank.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的坦克是我们用于[*第2章*](B17984_02_Epub.xhtml#_idTextAnchor100)，“有限状态机”中使用的简单模型，具有非运动学`Rigidbody`组件。我们需要`Rigidbody`组件来生成与AI角色和环境对象进行碰撞检测时的触发事件。最后，我们需要将**玩家**标签分配给我们的坦克。
- en: 'As we can easily see from its name, the `PlayerTank` script controls the player''s
    tank. The following is the code for the `PlayerTank.cs` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从其名称中我们可以轻易看出，`PlayerTank`脚本控制玩家的坦克。以下是`PlayerTank.cs`文件的代码：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This script retrieves the Target position on the map and updates the tank''s
    destination point and direction accordingly. The result of the preceding code
    is shown in the following panel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本检索地图上的目标位置，并相应地更新坦克的目的地点和方向。前面代码的结果如下所示：
- en: '![Figure 4.3 – The properties of our Tank object'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 我们坦克对象的属性'
- en: '](img/B17984_04_3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_04_3.jpg)'
- en: Figure 4.3 – The properties of our Tank object
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 我们坦克对象的属性
- en: After we assign the preceding script to the tank, be sure to assign the Target
    object to the `targetTransform` variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在将前面的脚本分配给坦克后，请务必将目标对象分配给`targetTransform`变量。
- en: Aspect
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aspect
- en: Next, let's take a look at the `Aspect` class. `Aspect` is an elementary class
    with just one public property, called `aspectName`. That's all the variables we
    need in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`Aspect`类。`Aspect`是一个具有单个公共属性的基本类，称为`aspectName`。这就是我们在本章需要的所有变量。
- en: 'Whenever our AI character senses something, we''ll check this against `aspectName`
    to see whether it''s the aspect that the AI has been looking for:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的AI角色感知到某物时，我们将检查它是否是AI一直在寻找的属性：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Attach this aspect script to our player's tank and set the `aspectName` property
    as `Player`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性脚本附加到我们的玩家坦克上，并将`aspectName`属性设置为`Player`。
- en: AI characters
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI角色
- en: 'In this example, the AI characters roam around the scene in a random direction.
    They have two senses: sight and touch. The sight sense checks whether the enemy
    aspect is within a set visible range and distance. Touch detects whether the enemy
    aspect has collided with the `Box Collider` around the character. As we have seen
    previously, our player''s tank has the `Player` aspect. Consequently, these senses
    are triggered when they detect the player''s tank.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，AI角色以随机方向在场景中游荡。它们有两种感官：视觉和触觉。视觉感官检查敌人是否在设定的可见范围和距离内。触觉检测敌人是否与角色周围的`Box
    Collider`发生碰撞。正如我们之前所看到的，我们的玩家坦克具有`Player`属性。因此，当它们检测到玩家的坦克时，这些感官会被触发。
- en: 'For now, let''s look at the script we use to move the NPCs around:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们用来移动NPC的脚本：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Wander` script generates a new random position in a specified range whenever
    an AI character reaches its current destination point. Then, the `Update` method
    rotates the NPCs and moves them toward their new destination. Attach this script
    to our AI character so that it can move around in the scene.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当AI角色达到其当前目的地点时，`Wander`脚本会在指定范围内生成一个新的随机位置。然后，`Update`方法旋转NPC并将它们移动到新的目的地。将此脚本附加到我们的AI角色上，以便它在场景中移动。
- en: Sense
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感官
- en: 'The `Sense` class is the interface of our sensory system that the other custom
    senses can implement. It defines two virtual methods, `Initialize` and `UpdateSense`,
    executed from the `Start` and `Update` methods, respectively, and that we can
    override when implementing custom senses as shown in the following code block:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sense`类是我们感官系统的接口，其他自定义感官可以在此接口上实现。它定义了两个虚拟方法，`Initialize`和`UpdateSense`，分别从`Start`和`Update`方法中执行，并且我们可以在实现自定义感官时重写，如下面的代码块所示：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The basic properties of this script are the intervals between two consecutive
    sensing operations and the name of the aspect it should look for. This script
    is not attached to any objects; instead, we use it as a base for specific senses,
    such as `Sight` and `Touch`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的基本属性是两次连续感官操作之间的间隔以及它应该查找的属性名称。此脚本未附加到任何对象上；相反，我们将其用作特定感官（如`Sight`和`Touch`）的基础。
- en: Sight
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉
- en: 'The `Sight` sense detects whether a specific aspect is within the perception
    field of the character. If it perceives anything, it takes the specified action
    as shown in the following code block:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sight`感官检测特定属性是否在角色的感知范围内。如果它感知到任何东西，它将执行以下代码块中指定的操作：'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to implement the `Initialize` and `UpdateSense` methods of the parent
    `Sense` class, respectively. Then, in the `DetectAspect` method, we first check
    the angle between the player and the AI's current direction. Then, if it's in
    the field-of-view range, we shoot a ray in the direction of the player's tank.
    The length of the ray is the value in the visible distance property.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现父类 `Sense` 的 `Initialize` 和 `UpdateSense` 方法。然后，在 `DetectAspect` 方法中，我们首先检查玩家和
    AI 当前方向之间的角度。然后，如果它在视野范围内，我们就向玩家坦克的方向发射一条射线。射线的长度是可见距离属性中的值。
- en: The `Raycast` method returns when it first hits another object. Then, we check
    this against the aspect component and the aspect name. In this way, even if the
    player is in the visible range, the AI character will not see the player if they
    hide behind a wall.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Raycast` 方法在第一次击中另一个对象时返回。然后，我们将其与事务组件和事务名称进行比较。这样，即使玩家在可见范围内，如果他们躲在墙壁后面，AI
    角色也不会看到玩家。'
- en: The `OnDrawGizmos` method draws lines based on the perspective field (determined
    by the view angle and viewing distance) to see the AI character's line of sight
    in the editor window during playtesting. Attach this script to the AI character,
    and ensure to set the aspect name to `Enemy`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDrawGizmos` 方法根据视角场（由视角角度和观看距离确定）绘制线条，以便在游戏测试期间在编辑器窗口中看到 AI 角色的视线。将此脚本附加到
    AI 角色上，并确保将事务名称设置为 `Enemy`。'
- en: 'This method can be illustrated as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以表示如下：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`OnDrawGizmos` is an event function that we can use when we want to draw gizmos
    in the scene. `DrawLine`, `DrawIcon`, and `DrawSphere`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDrawGizmos` 是一个事件函数，当我们想在场景中绘制 gizmos 时可以使用。`DrawLine`、`DrawIcon` 和 `DrawSphere`。'
- en: 'They are a handy way to quickly provide some visual feedback to our algorithms.
    You can learn more about the gizmo functions by following this link: [https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是快速为我们算法提供一些视觉反馈的便捷方式。你可以通过以下链接了解更多关于 gizmo 函数的信息：[https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html)。
- en: Touch
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸
- en: 'Another sense we''re going to implement is `Touch`, which is triggered when
    the player entity is within a specific range of the AI entity as shown in the
    following code block. Our AI character has a box collider component, and its `Is
    Trigger` flag is on:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的另一个感官是 `Touch`，当玩家实体在 AI 实体特定范围内时触发，如下面的代码块所示。我们的 AI 角色有一个盒子碰撞体组件，并且它的
    `Is Trigger` 标志是开启的：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to implement the `OnTriggerEnter` event fired whenever the collider
    component collides with another collider component. Since our tank entity also
    has collider and `Rigidbody` components, a collision event occurs as soon as the
    colliders of the AI character and the player's tank coincide.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现每次碰撞组件与另一个碰撞组件发生碰撞时触发的 `OnTriggerEnter` 事件。由于我们的坦克实体也有碰撞体和 `Rigidbody`
    组件，因此当 AI 角色和玩家坦克的碰撞体重合时，就会发生碰撞事件。
- en: 'The following screenshot shows the box collider of our enemy AI that we are
    using to implement the `Touch` sense:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了我们的敌人 AI 的盒子碰撞体，我们正在使用它来实现 `Touch` 感官：
- en: '![Figure 4.4 – The collider component around our player'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 我们玩家周围的碰撞组件'
- en: '](img/B17984_04_4.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_04_4.jpg)'
- en: Figure 4.4 – The collider component around our player
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 我们玩家周围的碰撞组件
- en: 'In the following screenshot, we can see how our AI character is set up:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到我们的 AI 角色是如何设置的：
- en: '![Figure 4.5 – Properties of our player'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 我们玩家的属性'
- en: '](img/B17984_04_5.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_04_5.jpg)'
- en: Figure 4.5 – Properties of our player
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 我们玩家的属性
- en: Inside the `OnTriggerEnter` method, we access the aspect component of the other
    collider entity and check whether the name of the aspect is the same aspect that
    this AI character is looking for. For demonstration purposes, we print out in
    the console that the character detects the enemy aspect by the `Touch` sense.
    In a real game, we would not print the event but rather trigger other actions,
    such as turning to face an enemy and then chasing, attacking, and so on. Let's
    move on to testing our game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnTriggerEnter` 方法中，我们访问另一个碰撞实体的事务组件，并检查事务的名称是否与我们这个 AI 角色正在寻找的事务名称相同。为了演示目的，我们在控制台中打印出角色通过
    `Touch` 感官检测到敌人事务。在实际游戏中，我们不会打印事件，而是触发其他动作，例如转向面对敌人，然后追逐、攻击等等。让我们继续测试我们的游戏。
- en: Testing the game
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Now, play the game in Unity3D and move the player's tank near the wandering
    AI character by clicking on the ground. You should see the **Enemy touch detected**
    message in the console log window whenever our AI character gets close to our
    player's tank.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Unity3D中玩游戏，通过点击地面将玩家的坦克移动到游荡的AI角色附近。每当我们的AI角色接近玩家的坦克时，你应在控制台日志窗口中看到**敌人触摸检测**的消息。
- en: '![Figure 4.6 – Our player and tank in action'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 我们的角色和坦克在行动中'
- en: '](img/B17984_04_6.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_04_6.jpg]'
- en: Figure 4.6 – Our player and tank in action
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 我们的角色和坦克在行动中
- en: The previous screenshot shows an AI agent with touch and perspective senses
    looking for an enemy aspect. Move the player's tank in front of the AI character,
    and you'll get the *Enemy detected* message. If you go into the editor view while
    running the game, you should see the rendered debug drawings thanks to the `OnDrawGizmos`
    method implemented in the `Sight sense` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个具有触摸和视角感官的AI代理正在寻找敌人特征。将玩家的坦克移到AI角色前方，你将收到**敌人检测**的消息。如果在运行游戏的同时进入编辑器视图，你应该会看到由于在`视觉感官`类中实现了`OnDrawGizmos`方法而渲染的调试图形。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the concept of using sensors in implementing game AI,
    and we implemented two senses, `Sight` and `Touch`, for our AI character. The
    sensory system is just the first element of the decision-making system of a whole
    AI system. For example, we can use the sensory system to control the execution
    of a behavior system or change the state of a Finite State Machine once we have
    detected an enemy within the AI's line of sight.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在实现游戏AI中使用传感器的概念，并为我们的AI角色实现了两种感官，即`视觉`和`触摸`。感官系统是整个AI系统决策系统的第一个元素。例如，一旦我们在AI的视线范围内检测到敌人，我们可以使用感官系统来控制行为系统的执行或改变有限状态机的状态。
- en: We will cover how to apply behavior tree systems in [*Chapter 9*](B17984_09_Epub.xhtml#_idTextAnchor487),
    *Behavior Trees*. In the meantime, in the next chapter, we'll look at how to implement
    flocking behaviors in Unity3D, as well as how to implement Craig Reynold's flocking
    algorithm.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B17984_09_Epub.xhtml#_idTextAnchor487)“行为树”中介绍如何应用行为树系统。同时，在下一章中，我们将探讨如何在Unity3D中实现群聚行为，以及如何实现克雷格·雷诺的群聚算法。
