- en: Environment and AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating AI for video games, one of the most important aspects is its placement.
    As we discovered previously, the position of the AI character can completely change
    his behavior and future decisions. In this chapter, we'll be exploring how the
    environment of the game can influence our AI and how he should be using it properly,
    in-depth. This will cover a wide range of game genres with different map structures
    such as open world, arcade, and racing.
  prefs: []
  type: TYPE_NORMAL
- en: As a player, we like to have a vivid world to explore, with many things to do,
    and interact with. As a game developer or game designer, that generally means
    a lot of work because everything that the player is able to interact with has
    to be carefully planned and executed the right way, to avoid bugs or any other
    unfortunate distractions from the gameplay. The same goes for the AI characters
    that we are creating. If we allow the character to interact with the environment,
    that requires a lot of work, thought, planning, and coding to make it work properly.
    The number of options available for the player or AI usually equals the number
    of issues that can occur, so we need to give special attention to the environment
    while creating our games.
  prefs: []
  type: TYPE_NORMAL
- en: Not every game necessarily has a map or terrain, but perhaps the position where
    the action is happening at the time still has importance for the gameplay, and
    the AI should have that in mind. Also, sometimes, the environment or positioning
    has a subtle impact on the characters of the game that we don't notice while playing
    the game but, most of the time, those subtle changes contribute to a good and
    enjoyable experience. That is why the interaction with the environment is an important
    aspect while creating a video game because it is responsible for giving life to
    the characters and, without it, they would remain simple 3D or 2D models.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we can't forget the opposite, interaction with the environment
    by the characters of the game. If our life could be represented in a video game,
    the impact that we have on the environment should be one of the aspects involved
    in the game. For example, if we throw a cigarette into a forest, it has a high
    probability of burning some leaves and causing a fire, leaving all the animals
    that inhabit that forest with ailments, and the consequences just keep growing.
    So, it's also interesting to look at how the environment should react according
    to what is happening in the game. During the game design process, we have the
    opportunity to choose if that interaction is relevant to the gameplay or if it's
    only there for visual purposes, but, either way, it certainly contributes to a
    rich environment that everybody loves. In this chapter, we'll have the opportunity
    to explore all of the options above in depth and we'll start exploring the basic
    interactions that don't change the gameplay. We'll finish the chapter with advanced
    interactions that have a deep impact on the game experience.
  prefs: []
  type: TYPE_NORMAL
- en: Visual interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual interactions are the basic ones that don't influence the gameplay directly
    but help to polish our video game and characters, making them part of the environment
    that we are creating, contributing significantly to the immersion of the player
    in the game. There are many examples of this subject and we can find them in almost
    any type of game. This shows us the importance of the environment being part of
    the game and not merely existing to help fill the screen. It's getting more usual
    to see these types of interaction in games and players expect them. If there's
    an object in the game, it should do something, important or not. This makes the
    environment that we are creating more vibrant and alive, which is definitely a
    good thing.
  prefs: []
  type: TYPE_NORMAL
- en: We can find one of the first examples of environment interaction in the original
    *Castlevania*, released in 1986 for the Nintendo Entertainment System. Right from
    the start, the player can use the whip to destroy the candles and fire pits that
    originally made up part of the background.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8497f937-9654-450f-8627-bd6e834e93b3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This game and a few others released at the time, opened many doors and possibilities
    in terms of the perception that we have in relation to the background or environment
    that surround the characters of the game. Obviously, because of the hardware limitations
    of this generation of consoles, it was much harder to create simple things that
    we see as common by today's standards. But every generation of consoles kept bringing
    more capabilities and creators like us kept using that in our favor to create
    amazing games.
  prefs: []
  type: TYPE_NORMAL
- en: So, our first example of a visual interaction is the object in the background
    that can be destroyed without interfering directly with the gameplay. This type
    of interaction can be seen in multiple games and is as simple as coding an object
    to animate when it's attacked. Then, we can decide if the object drops some points
    or collectibles just to reward the player for exploring the game. We'll now move
    on to our next example, the assets in the game that are animated or which move
    when the characters pass through them. It's the same principle as the destroyable
    object but this time, a subtler interaction that requires the character to move
    near the position where the asset is positioned. This can be applied to different
    things inside the game, from the grass moving, to dust or water, birds that fly
    away, or people that perform a funny gesture; there are endless possibilities.
    When we analyze these interactions, we can easily determine that they don't necessarily
    have an artificial intelligence behind them, where most of the time, it is just
    a Boolean function that activates according to some predetermined action. But
    they make up part of the environment and, for that reason, they needs to be taken
    into consideration when we want a good integration between environment and AI.
  prefs: []
  type: TYPE_NORMAL
- en: Basic environment interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw previously, the environment became part of the video game experience
    and that sparked many new concepts and ideas for future game titles. The next
    step was to integrate those slight changes into the gameplay and use them to shape
    the way characters behave inside the game. This definitely had a positive contribution
    to video game history, where everything inside the scene started to gain life
    and the player became aware of those rich surroundings. Using the environment
    to achieve goals inside the game started to be part of the gameplay experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a9f20a1-cf94-46b6-acb5-7cf2c036c12c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To demonstrate one example of an environment object that directly influences
    the gameplay, we have the Tomb Raider franchise that showcases this perfectly.
    In this example, our character, Lara Croft, needs to push the cube until it is
    positioned on top of the marked area. This will change the environment and unlock
    a new path that allows the player to move forward in the level. We can find this
    type of challenge in a number of games where it''s necessary to trigger a specific
    position in the map in order to make something happen in another part, and this
    can be used to accomplish a specific objective in the game. Usually we need to
    change the environment as it is, in order to progress on that level. So, when
    we plan the map or stage, we take those interactions into consideration and then
    we create all the rules that belong to each interaction. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now let's imagine for a minute that Lara Croft had an allied character whose
    main task was to help her put that box in place? And that's exactly one type of
    interaction that we will be looking at in this chapter, where the AI character
    understands how the environment works and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving environment objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump right into that scenario and try to recreate the situation where
    we have an AI character that is able to help our player achieve his goal. For
    this example, let's assume that our player is trapped in a position where he cannot
    access the interactive object that releases him from that situation. The character
    that we'll be creating needs to be able to find the cube and push it toward the
    desired position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/314c7afa-d832-4c63-b7bd-cb8dac9fac4d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So now that we have all the characters and objects set in our environment example,
    let's plan how the AI character should behave in this situation. First, he needs
    to see that the player is near so he can start searching and move the cube to
    the right position. Let's assume that if the cube is on that mark, a new block
    will rise from the sand allowing the player to proceed in the level. The AI character
    can push the cube in four different directions, left, right, front, and back,
    making sure it aligns perfectly with the position mark.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4f26438-7bd6-4cf1-be26-c91a8ce44f1d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The AI character needs to question and validate every action demonstrated in
    the behavior tree previously. The first and most important thing in order to proceed
    with the objective is the character needs to be sure that the player is positioned
    on his mark. If the player has not arrived yet, our character needs to wait and
    hold position. If the player has arrived already, the AI character proceeds and
    asks himself if he is near the cube object or not. If not, our character needs
    to go toward the cube, and once that action is validated, he will ask the same
    question again. Once the answer is yes and the character is near the cube, he
    needs to calculate in which direction the cube needs to be pushed first. Then
    he will be pushing towards the **Y** **AXIS** or **X** **AXIS** until the cube
    is aligned with the MARK POSITION and the objective gets completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start adding the information into our code that allows the character to validate
    if the player is near his marked position. For this, we create all the variables
    necessary to calculate the distances of the player and the position that he needs
    to be in. `playerMesh` refers to the 3D model of the player where we'll extract
    his position and use it as `currentPlayerPosition`. To know if he is near his
    mark, we need a variable that represents the MARK POSITION and in this example,
    we created the `playerMark` variable where we can write down the position in which
    we want our player to be. Then we added three variables that allow us to know
    if the player is near. `proximityValueX` will calculate the distance between the
    player and the mark on the X axis. `proximityValueY` will calculate the distance
    between the player and the mark on the Y axis. Then we have the `nearValue` where
    we can define how far the player can be from the MARK POSITION so that our AI
    character can start working on the objective. Once the player is near his mark,
    the `playerOnMark` Boolean changes to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the distance between the player and his mark, we used this: Distance
    between the player and his mark is the same as (mark.position - player.position).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to discover if the AI character is near the cube, we will be doing the
    same equation, calculating the distance between the AI and the cube. Also, we
    completed the code, as follows, with the positions of both marks (player and cube
    mark):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our AI character knows if he is near the cube or not, this will answer
    the question and determine if he can proceed to the next branch that we have planned.
    But what happens when our character is not near the cube? He will need to walk
    toward the cube. So, we''ll add that into our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So far, our AI character is able to calculate the distance between himself and
    the cube; if they are too far apart, he will go toward the cube. Once this quest
    is completed, he can move on to the next phase and start pushing the cube. The
    last thing that he needs to calculate is how far the cube is from the mark position
    and he then decides which side needs to be pushed first by taking into consideration
    how far it is from each side.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66f26ccc-3afc-474d-b013-e5085aae87de.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The cube can only be pushed on the **X** axis or **Z** axis and the rotation
    isn''t relevant for now as the button is activated once the cube is on top of
    it. Taking that into consideration, our character AI needs to calculate how far
    the cube is from the **X MARK POSITION** and **Z MARK POSITION**. Then he will
    compare the two different axis values and choose which one is farther away from
    the desired position and start pushing from that one. The character will push
    in that direction until the cube is aligned with the marked position and then
    switch to the other side, and push it until it''s completely on top of the **MARK
    POSITION**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the final actions added to our code, our AI character should be able to
    conclude its objective and find and push the cube to the desired position, so
    the player can proceed and finish the level. In this example, we focused on how
    to calculate distances between objects of the scene and characters. This will
    help create similar types of interactions where it's necessary to put an object
    in the game in a certain position.
  prefs: []
  type: TYPE_NORMAL
- en: The example demonstrates an allied AI character that helps the player, but the
    same principles could be applied if we wanted the opposite effect (being an enemy)
    where the character would need to find the cube as fast as possible to stop the
    player.
  prefs: []
  type: TYPE_NORMAL
- en: Obstructive environment objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw previously, we can use or move objects in the game to fulfill an objective,
    but what happens if the character has an object obstructing his way? The object
    could be placed by the player or simply designed to be in that position of the
    map and either way, the AI character should be able to determine what to do in
    that situation.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe this behavior, for example, in a strategy game called *Age of
    Empires II* developed by Ensemble Studios. Every time the characters of the game
    can't access the enemy territory because of their surrounded fortified walls,
    the AI characters focus and start destroying a portion of the wall so they can
    get in. This type of interaction is very smart and important as well, because
    otherwise they would just be going around the wall searching for an entry and
    that wouldn't look intelligent. Because the fortified wall is created by the player,
    it can be placed anywhere, with any shape or form and for that reason, it is necessary
    to think about that when developing an AI opponent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c103d0-b23d-4624-83af-bc3a93573f1e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example is also relevant because, in the planning phase, when we are creating
    behavior trees, we need to think about what happens if something gets in the way
    of the character and he can't accomplish his objectives. That will be explored
    in depth in a future chapter of the book, but for now, we'll simplify this situation
    and analyze how the AI character should behave if an environment object is interfering
    with his objective.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2904501-8a41-4ad0-8e5a-f555b3716f44.png)'
  prefs: []
  type: TYPE_IMG
- en: In our example, the AI character needs to enter the house but when he arrives
    near, realizes that it is surrounded by wooden fences and he can't pass through.
    At that point, we want the character to choose a target and start attacking until
    that portion of the fence is destroyed so he can find a way to enter the house.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, weÂ´ll need to calculate which fence our character needs to
    attack, taking into consideration the distance and the current health state of
    the fence. The fence with low HP should have a higher priority to be attacked
    first compared to a fence that is at full HP, so we'll be including that in our
    calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45359cb2-6da9-48b0-be07-75ff01592691.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to define a circumference around the character where the closest fences
    give their information to the AI so he can decide which one is the easiest to
    destroy. This can be done with different methods, either by using collision detection
    on the fences that get triggered by the player, or having them calculate the distance
    between fences/objects and the player; we define a distance value where the player
    perceives the condition of the fence. For this example, we'll be calculating the
    distance and use it to alert the character about the HP of the fences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the code that will be implemented on the `fence` object;
    all of them will have the same script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we added the basic information about the HP and distances that
    we'll be using to connect with the AI character. This time, we are adding the
    script that calculates the distances into the `environment` object instead of
    the character; this gives more dynamism to the object and allows us to create
    more things with it. As an example, if the characters of the game are the ones
    responsible for creating the fences, they will have different states, such as
    currently building, completed, and damaged; then the character will receive that
    information and use it to his advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward and define our AI character to interact with the `environment`
    object. His primary objective is to access the house, but when he arrives near,
    he realizes that he cannot get inside because it's surrounded by the wood fences.
    After analyzing the situation, we want our character to destroy a fence so he
    can finally accomplish his objective and get into the house.
  prefs: []
  type: TYPE_NORMAL
- en: In the character script, we'll be adding a `static` function, where the fences
    can input their information about their current health; this will help the AI
    character choose a better fence to destroy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/05bf51f5-f295-41a5-9b34-239542d532bd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We already added the basic information into our character. `fenceHP` will be
    the static variable where every fence triggered by the character gives their information
    about the current HP. Then the AI character analyzes the collected information
    and compares it with the lowest HP fence that is represented as `lowerFenceHP`.
    The character has a `timeWasted` variable that represents the number of seconds
    that he has already spent looking for a good fence to attack. `fencesAnalyzed`
    will be used to know if there's already a fence in the code, and if not, it will
    have added the first fence that he finds; in the case of the fences having the
    same HP value, the character will attack them first. Now let's update our fence
    code, so they can access the character script and input some useful information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We finally conclude this example, where the fence compares their current HP
    with the data that the character has (`lowerFenceHP`) and if their HP is lower
    than the lowest value that the character has, that fence will be considered the
    `bestFence`.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates how to adapt the AI character to different dynamic
    objects of the game; the same principle can be expanded and used to interact with
    almost any object. It's also relevant and useful to use the objects to interact
    with the character as well, linking information between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the environment by area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a map, often we have two or more different areas that could be
    used to change the gameplay, areas that could contain water, quicksand, flying
    zones, caves, and much more. If we wish to create an AI character that can be
    used in any level of our game, and anywhere, we need to take this into consideration
    and make the AI aware of the different zones of the map. Usually that means that
    we need to input more information into the character's behavior, including how
    to react according to the position in which he is currently placed, or a situation
    where he can choose where to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should he avoid some areas? Should he prefer others? This type of information
    is relevant because it makes the character aware of the surroundings, choosing
    or adapting and taking into consideration his position. Not planning this correctly
    can lead to some unnatural decisions; for example, in *Elder Scrolls V: Skyrim*
    developed by Bethesda Softworks studio, we can watch some AI characters of the
    game simply turning back when they do not have information about how they should
    behave in some parts of the map, especially on mountains or rivers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/585a7be3-5542-4fa4-ac7d-ac0fbf1c10f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Depending on the zones that our character finds, he might react differently
    or update his behavior tree to adapt to his environment. We have previously created
    a soldier that changed the way he would react according to his health, aim success,
    and player health, and now we are exploring the environment so the character can
    use it to better define what to do. We could also use this to update one of our
    previous examples, the real-life simulation. If the Sofie character goes to one
    specific section of the house, she could use that information to update her priorities
    and replenish all the necessities that are attached to that portion of the house.
    Let's say that she was in the kitchen; once she is there, after preparing the
    breakfast, she takes the opportunity to take out the garbage. As we see, the environment
    that surrounds our characters can redefine their priorities or completely change
    their behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a little similar to what Jean-Jacques Rousseau said about humanity:
    "*We are good by nature, but corrupted by society.*" As humans, we are a representation
    of the environment that surrounds us, and for that reason, artificial intelligence
    should follow the same principle.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's pick a previous character that we have already created and update his
    code to work on a different scenario. The chosen one for this example is the soldier
    and we want to change his behavior according to three different zones, beach,
    river, and forest. So, we'll create three public static Boolean functions with
    the names `Beach`, `Forest` and `River`; then we define the zones on the map that
    will turn them on or off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because in this example, just one of them can be true at a time, we'll add a
    simple line of code that disables the other options once one of them gets activated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once we have that done, we can start defining the different behaviors for each
    zone. For example, in the beach zone, the characters don't have a place to get
    cover, so that option needs to be taken away and updated with a new one. The river
    zone can be used to get across to the other side, so the character can hide from
    the player and attack from that position. To conclude, we can define the character
    to be more careful and use the trees to get cover. Depending on the zones, we
    can change the values to better adapt to the environment, or create new functions
    that would allow us to use some specific characteristics of that zone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This segment will be explored in depth later on when talking about AI Planning
    and Decision Making, as well as Tactics and Awareness.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced environment interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the video game industry and the technology associated with it kept evolving,
    new gameplay ideas appeared, and rapidly, interaction between the characters of
    the game and the environment became even more interesting, especially when using
    physics. This means that the outcome of the environment could be completely random,
    where it was required for the AI characters to constantly adapt to different situations.
    One honorable mention on this subject is the video game *Worms* developed by Team17,
    where the map can be fully destroyed and the AI characters of the game are able
    to adapt and maintain smart decisions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/610f8e86-282b-44fd-b160-515714811ec2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The objective of this game is to destroy the opponent team by killing all their
    worms, the last man standing wins. From the start, the characters can find some
    extra health points or ammunition on the map and from time to time, it drops more
    points from the sky. So, there are two main objectives for the character, namely
    survive and kill. To survive, he needs to keep a decent amount of HP and away
    from the enemy, the other part is to choose the best character to shoot and take
    as much health as possible from him. Meanwhile, the map gets destroyed by the
    bombs and all of the fire power used by the characters, making it a challenge
    for artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting to unstable terrain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's decompose this example and create a character that could be used in this
    game. We'll start by looking at the map. At the bottom, there's water that automatically
    kills the worms. Then, we have the terrain where the worms can walk, or destroy
    if needed. Finally, there's the absence of terrain, specifically, the empty space
    that cannot be walked on. Then we have the characters (worms) they are placed
    in random positions at the beginning of the game and they can walk, jump, and
    shoot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3be1a9b4-50c8-45c5-9f68-6bfe0e1fd24d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The characters of the game should be able to constantly adapt to the instability
    of the terrain, so we need to use that and make it part of the behavior tree.
    As demonstrated in the diagram above, the character will need to understand the
    position where he is currently placed, as well as the opponent's position, health,
    and items.
  prefs: []
  type: TYPE_NORMAL
- en: Because the terrain can be blocking them, the AI character has a chance of being
    in a situation where he cannot attack or obtain an item. So, we give him options
    on what to do in those situations and many others that he might find, but the
    most important is to define what happens if he cannot successfully accomplish
    any of them. Because the terrain can be shaped into different forms, during gameplay
    there will be times that it is near impossible to do anything, and that is why
    we need to provide options on what to do in those situations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddf44f51-de44-44f0-bf4d-9e1c409396fb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, in this situation where the worm doesn't have enough free space
    to move, a close item to pick up, or an enemy that can be properly attacked, what
    should he do? It's necessary to make information about the surroundings available
    to our character so he can make a good judgment for that situation. In this scenario,
    we have defined our character to shoot anyway, against the closest enemy, or to
    stay close to a wall. Because he is too close to the explosion that would occur
    from attacking the closest enemy, he should decide to stay in a corner and wait
    there until the next turn.
  prefs: []
  type: TYPE_NORMAL
- en: Using raycast to evaluate decisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/89057d8e-dabd-4fab-90c6-727a155fc6aa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ideally, at the start of the turn, the character has two raycasts, one for his
    left side and another for the right side. This will check if there's a wall obstructing
    one of those directions. This can be used to determine what side the character
    should be moving toward if he wants to protect himself from being attacked. Then,
    we would use another raycast in the aim direction, to see if there's something
    blocking the way when the character is preparing to shoot. If there's something
    in the middle, the character should be calculating the distance between the two
    to determine if it's still safe to shoot.
  prefs: []
  type: TYPE_NORMAL
- en: So, each character should have a shared list of all of the worms that are currently
    in the game; that way they can compare the distance between them all and choose
    which of them are closest and shoot them. Additionally, we add the two raycasts
    to check if there's something blocking the sides, and we have the basic information
    to make the character adapt to the constant modifications of the terrain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored different ways to interact with the environment.
    The techniques demonstrated in this chapter can be expanded to a wide range of
    game genres and used to accomplish basic to advanced interactions between the
    AI characters and the environment. Now we understand how to create interactive
    and dynamic objects that can be used by the AI characters, it will make the game
    a new and different experience every time we play. In addition, have lightly touched
    on some related topics that will be covered in depth in the next chapters, such
    as the interaction with other AI characters of the game and decision making.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll be talking about animation behavior. Animations make
    up part of the visual perception that the player has of the artificially intelligent
    characters that we create, and it's very important to use that to demonstrate
    how realistic our AI behaves. We will be discussing animation graphs, gameplay
    and animation, animation behaviors, and animation architecture.
  prefs: []
  type: TYPE_NORMAL
