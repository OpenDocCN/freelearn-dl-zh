- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up a Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding how to properly set up a behavior tree is crucial for developing
    effective AI systems in your games. As you have seen from the previous chapter,
    behavior trees serve as a powerful tool to define the logic and decision-making
    processes of AI characters, allowing developers to create complex behaviors in
    a structured and manageable manner. This chapter will provide valuable insights
    into the fundamentals of behavior trees’ implementation and their inner workings
    in Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Unreal Agility Arena
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a behavior tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing behavior tree tasks and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a behavior tree on an agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this chapter, you’ll need to use the starter content available
    in this book’s companion repository, located at [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    . Through this link, locate the section for this chapter and download the **Unreal
    Agility Arena – Starter Content** ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: If you somehow get lost during the progress of this chapter, in the repository,
    you will also find the up-to-date project files at **Unreal Agility Arena –**
    **Chapter** **08** **End** .
  prefs: []
  type: TYPE_NORMAL
- en: Also, to fully understand this chapter, it is necessary to have some basic knowledge
    about Blueprint visual scripting and C++; as an extra piece of advice, you may
    want to take a peek at *Appendix A* , *Understanding C++ in Unreal Engine* , for
    a gentle introduction (or a refresher) on the C++ syntax in Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Unreal Agility Arena
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, let’s continue exploring the short novel we introduced in [*Chapter
    4*](B31016_04.xhtml#_idTextAnchor073) , *Setting Up a* *Navigation Mesh* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*As Dr. Markus and his trusty assistant Professor Viktoria continued to refine
    their AI dummy puppets, they stumbled upon an intriguing challenge: the limited
    power supply of the puppets’ batteries. It seemed that the advanced AI technology
    consumed energy at an alarming rate, causing the puppets to shut* *down unexpectedly.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Undeterred by this setback, Dr. Markus saw an opportunity to turn this limitation
    into a unique aspect of the puppets’ behavior. He theorized that the puppets’
    interactions, when powered by dwindling battery life, would mimic human fatigue
    and exhaustion. With great excitement, Dr. Markus and Professor Viktoria devised
    a plan to create a new series of experiments centered around the puppets’ limited*
    *power supply.*'
  prefs: []
  type: TYPE_NORMAL
- en: After learning all that information in the last chapter, it’s time to dive in
    and begin crafting your own AI agents, equipped with fully functional behavior
    trees. To keep things simple and clean, I will start with a brand-new project,
    but you are free to continue developing the work you started in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: To start, I will give you some short information on what will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the project brief
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a starting point, you will need to create a new dummy character (the one
    from previous chapters is too limited) that will need to implement some base logic.
    This will let you extend its basic functionality once we start creating more advanced
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main requisites are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The AI agent will be implemented in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have the ability to move at two different speeds – walking and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be provided with a battery system that will consume energy when walking
    and recharge when standing still
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will need to be controlled by a custom **AIController** class that will use
    behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the character has been created, we will be able to start creating new gym
    levels to create and test new AI agent behaviors. So, let’s start by creating
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project creation process is basically the same as the one we covered in
    [*Chapter 4*](B31016_04.xhtml#_idTextAnchor073) , *Setting Up a Navigation Mesh*
    , so I won’t go much into detail about it; the distinction we will make (which
    is certainly not trivial) is the inclusion of C++ classes.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, this is going to be a seamless transition, as when you create a new
    C++ class for the first time, Unreal Engine sets up the whole system for you.
    Once the C++ project files have been generated, you should see the **C++ Classes**
    folder in your **Content Browser** window, along with the **Content** folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The C++ folder](img/B31016_figure_08.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The C++ folder
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the **C++ Classes** folder does not appear in your **Content Browser** window,
    you will probably need to open the **Settings** window and tick the **Show C++
    Classes** option, as shown in *Figure 8* *.2* .
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31016_figure_08.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8 .2 – Enabling the C++ folder
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start creating the character class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is to create the base character class for
    our prospective AI dummies. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu of the Unreal Engine Editor, select **Tools** | **New** **C++
    Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Creating a C++ class](img/B31016_figure_08.03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Creating a C++ class
  prefs: []
  type: TYPE_NORMAL
- en: From the **Add C++ Class** pop-up window, select the **Character** option and
    click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Class selection](img/B31016_figure_08.04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Class selection
  prefs: []
  type: TYPE_NORMAL
- en: In the following window, insert **BaseDummyCharacter** into the **Name** field
    and leave the rest as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Class creation](img/B31016_figure_08.05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Class creation
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create Class** button to start the class creation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is the very first class you have created, Unreal will start generating
    the C++ project; after that, your IDE – most probably Visual Studio or Rider –
    will open, and you will be able to start developing your class.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the battery status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing the character, we need to define how its battery status
    will be tracked; that’s why we are going to create a simple enumeration class
    that will list how much the battery is charged. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside your IDE, locate the **UnrealAgilityArena/Source/UnrealAgilityArena**
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this folder, create a new text file and call it **BatteryStatus.h** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file to edit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the file, add this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I guess you are already familiar with what an enumeration does, but a short
    explanation here is mandatory; we are defining an **enum** class, which in Unreal
    Engine needs to be of type **uint8** , and we are listing four levels of battery
    charging – **Empty** , **Low** , **Medium** and **Full** . The **UENUM()** macro
    defines an **enum** class for the Unreal Engine framework, and the **BlueprintType**
    specifier will expose it to the Blueprint system, making it usable for variables.
    The **DisplayName** metadata defines how the value will be shown in the Blueprint
    system; you can use your own convention here if you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, pay attention to the *E* prefix in the name definition; this is the
    Unreal Engine naming convention for **enum** types, and it is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: With the battery status defined, we are ready to start implementing the dummy
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start implementing the AI agent, open the **BaseDummyCharacter.h** file –
    that is, the header for the agent class – and start adding the class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, add the battery status definition at the top of the file,
    where all the **#include** definitions are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the **#include** declarations you’ll be adding always need to be put before
    the **.generated.h** definition – in this case, **BaseDummyCharacter.generated.h**
    . The **.generated.h** definition always needs to be the last in the declaration
    list; this convention ensures that all the necessary dependencies are properly
    set at compilation time.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second step is to add all the properties that will be exposed in the extending
    Blueprint classes. To do so, under the **public** section of the file, add the
    following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have declared a list of variables to handle the agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MaxBatteryLevel** : Represents the maximum value reachable by the agent battery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BatteryCostPerTick** : Represents how much battery power is spent by the
    agent while it is moving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BatteryRechargePerTick** : Represents how much battery power is recovered
    when the agent is resting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RunSpeed** : Represents the maximum speed reachable when running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WalkSpeed** : Represents the maximum speed reachable when walking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MovementRandomDeviation** : A value that will be randomly added or subtracted
    to the agent speed in order to make the movement pace less predictable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **UPROPERTY()** macro is used to declare class properties with additional
    functionality and metadata. It allows for easy integration with the Unreal Engine
    Editor, providing a visual interface to modify and configure these properties.
    The **EditAnywhere** property specifier indicates that the property can be edited
    in property windows from the Unreal Engine Editor, while **BlueprintReadWrite**
    specifies that the property will be accessible from the extending Blueprint classes
    in read and write mode. Finally, we want all the properties to be in the same
    category – that is, **Dummy Character** – and that’s why we have set the **Category**
    property specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need just one more variable, but this need not be public because it will
    be used for the actor’s inner logic. In the **protected** section, let’s add the
    following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This self-explanatory attribute will be used to keep track of the actual battery
    level of the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Adding delegates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now need to create an event dispatcher for battery status change notification;
    the best method in C++ is to use a **delegate** .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with delegates, my advice is to take a peek at *Appendix
    A* , *Understanding C++ in Unreal Engine* , at the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the **public** section and add the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have declared a dynamic multicast delegate with a single parameter – the
    battery new status – that will be dispatched every time the battery changes its
    charge level.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to add to the header is the function declarations. As
    a first step, delete the following line of code that is found at the end of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This character will be controlled by AI, so we don’t need to set up the player
    input. Next, just after the **Tick()** declaration, add the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have just declared two functions – **SetWalkSpeed()** and **SetRunSpeed()**
    – that will let us change the character speed at runtime. Additionally, we have
    added a getter function for the agent battery status.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, the **UFUNCTION()** macro is used to declare functions that
    are recognized by the Unreal Engine reflection system; this means the function
    becomes accessible and usable within the Unreal Engine framework. All three functions
    have the **BlueprintCallable** specifier added, meaning that these functions will
    be accessible in a Blueprint graph. Additionally, the **GetBatteryStatus()** function
    has the **const** keyword added; this will remove the execution pin in the corresponding
    Blueprint node, as we need this function to just be a getter and not change any
    data during execution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that all the class declarations have been done, we can start implementing
    the functions. To do so, the first thing you need to do is to open the **BaseDummyCharacter.cpp**
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you’ll need to do is to remove the **SetPlayerInputComponent()**
    function, as the corresponding declaration in the header file was previously removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the **#include** declarations at the very beginning of
    the file. Simply add these three lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As always, remember to add these **#include** declarations before the **.**
    **generated.h** declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, locate the **ABaseDummyCharacter()** constructor function, as we will
    need to set up some character attributes and components. This function should
    have already a line of code that sets the **bCanEverTick** property to **true**
    . Add the following line of code just after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we will use the **Tick()** event just for updating the battery status, we
    don’t need it to be executed every frame; we have set a time interval of a quarter
    of a second – this will be more than enough to suit our own needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following lines of code that set up the yaw, pitch, and roll
    behavior of the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to initialize the skeletal mesh component in order to show the
    dummy puppet model. Add these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the mesh location and rotation in order to suit the dummy puppet
    model. After that, we assign the dummy puppet skeletal mesh asset by hardcoding
    the asset path; we will use just this asset, so there is no need to assign it
    from the extending Blueprint classes. We will do the same with the animation Blueprint
    asset; I have provided one such asset for you in the project files in the declared
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to set the capsule component size in order to match the dummy
    puppet model. To do this, add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, set up the movement component by adding the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of **bUseRVOAvoidance** , set to **true** ; we will use several
    agents at the same time, so a basic avoidance system is almost mandatory to make
    things work properly.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor method is complete, so we can now start implementing all the
    other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the **BeginPlay()** method, and just after the **Super::BeginPlay()**
    declaration, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the game starts, we set the AI agent to have a random battery level to
    make things a bit more interesting, and next, we broadcast this status to all
    registered listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, just after the closing bracket of the **BeginPlay()** function,
    add the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing fancy here; we just implement the two functions to change the
    movement speed of the agent, making it walk or run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to implement the battery status getter function, so add the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we simply check the battery level and return the corresponding
    status enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to implement is the **Tick()** function, where we will
    constantly check how much battery power is consumed, depending on the character
    movement speed. Locate the **Tick()** function, and just after **Super::Tick(DeltaTime);**
    , add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we compute the current battery status using the **GetBatteryStatus()**
    function. Then, if the velocity of the character’s movement is greater than a
    tiny number – that is, **0.1** – it means the agent is moving, so we decrease
    the battery level by the **BatteryCostPerTick** value. Otherwise, the agent is
    standing still – therefore, recharging – so we increase the battery level by **BatteryRechargePerTick**
    . After that, we clamp the battery level between a value of zero and **MaxBatteryLevel**
    . Finally, we check whether the starting battery status is different from the
    new battery status, and we eventually broadcast the new battery status using the
    **OnBatteryStatusChanged** delegate.
  prefs: []
  type: TYPE_NORMAL
- en: The **BaseDummyCharacter** class has been completed. It is evident that we have
    not yet incorporated any AI agent behavior; this is intentional, as we plan to
    manage everything through an **AIController** class, a task we will undertake
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a behavior tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a fully functional behavior tree for the agent
    we previously created. The steps we will follow are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AI controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Blackboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the behavior tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by creating a subclass of the **AIController** class to control
    our dummy puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AI controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be now creating a class extending **AIController** that will be used
    as a starting point for the behavior tree. To get started, open the Unreal Engine
    Editor and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select **Tools** | **New** **C++ Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **All Classes** tab section and look for **AIController** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – AI controller class creation](img/B31016_figure_08.06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – AI controller class creation
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the class **BaseDummyAIController** and click the **Create** **Class**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the class files have been created and your IDE has been opened, look for
    the **BaseDummyAIController.h** header file and open it.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the header file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a first step, add a forward declaration for the **BehaviorTree** class,
    just after the **#** **include** declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the **protected** section of the header file, add these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This property declares a pointer to the behavior tree, so that it will be assignable
    from the **Class Defaults** Blueprints panel – using the **EditAnywhere** specifier
    – and it will be readable from any extending Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just after these lines of code, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The **OnPossess()** function is called when the controller possesses a **Pawn**
    instance – and our dummy character extends it – and it is a good place to run
    behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The controller is quite easy to implement; we just need to run the behavior
    tree when the AI agent is possessed. To do so, open the **BaseDummyAIController.cpp**
    file and add these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the **Super::OnPossess()** base class is called first. Then,
    we use the **ensureMsgf()** macro to ensure that the **BehaviorTree** variable
    is not a null pointer. If a behavior tree has been set, we run it using the **RunBehaviorTree()**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: With the AI controller set, we can start implementing the actual AI behaviors,
    starting from the Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blackboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a Blackboard asset is a straightforward task once you know what keys
    you will be tracking. In our case, we want to make the following values available
    to the behavior tree:'
  prefs: []
  type: TYPE_NORMAL
- en: A target location vector that will be used by the agent to walk around the level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean flag that will warn the agent once the battery charge is dangerously
    low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean flag that will indicate that the battery has been depleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, we need to create a Blackboard asset. To do so, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Content Drawer** and create a new folder, naming it **AI** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the folder and right-click on **Content Drawer** , selecting **Artificial
    Intelligence** | **Blackboard** to create a Blackboard asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the asset **BB_Dummy** and double-click on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The Blackboard panel](img/B31016_figure_08.07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – The Blackboard panel
  prefs: []
  type: TYPE_NORMAL
- en: Once the Blackboard is opened, you will see that there’s already a key named
    **SelfActor** ; we won’t be using it during this chapter, but we will leave it
    as it is, since it is usually used to store a reference to the owning actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create three keys, as stated at the beginning of this subsection,
    so we’ll start by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **New Key** button, and from the dropdown list, select the **Vector**
    type, as shown in *Figure 8* *.8* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Key creation](img/B31016_figure_08.08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Key creation
  prefs: []
  type: TYPE_NORMAL
- en: Name the new key **TargetLocation** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **New Key** button again, select the **Bool** type, and name the new
    key **IsLowOnBattery** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **New Key** button once more, select the **Bool** type, and name the
    new key **IsBatteryDepleted** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once these steps are finished, your Blackboard should be pretty similar to
    the one depicted in *Figure 8* *.9* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The finished Blackboard](img/B31016_figure_08.09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – The finished Blackboard
  prefs: []
  type: TYPE_NORMAL
- en: The Blackboard is finished, and we can now start working on the behavior tree
    for our AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the behavior tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the Blackboard, a behavior tree is created as a project asset. Let’s start
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Content Drawer** , open the **AI** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **Content Drawer** and select **Artificial Intelligence** | **Behavior
    Tree** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset **BT_RoamerDummy** and double-click on it to open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once opened, you should see a graph pretty similar to the one shown in *Figure
    8* *.10* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Behavior tree creation](img/B31016_figure_08.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Behavior tree creation
  prefs: []
  type: TYPE_NORMAL
- en: Note that the **Root** node is already included in the graph. As mentioned in
    the previous chapter, there can only be one such node in the graph. Furthermore,
    in the **Details** panel, you should see that the **BB_Dummy** Blackboard asset
    has already been assigned to the Blackboard asset. If you don’t see it assigned,
    simply click the **Blackboard** property dropdown and select the **BB_Dummy**
    asset; it should be the only asset of that type present in your project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through a step-by-step guide on creating a character
    that will utilize a behavior tree to implement AI logic. We have also successfully
    created a Blackboard asset and a behavior tree asset, which serve as the foundation
    to implement our character’s AI behaviors. As the process of implementing all
    the AI logic for our character is quite extensive, we will tackle it in the upcoming
    section. Stay tuned for a detailed walk-through on how to effectively implement
    AI behaviors for our character.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing behavior tree tasks and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before creating the behavior tree, it is crucial to have a clear understanding
    of the intended implementation. The AI agent will need to manage the following
    behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: Wander around the level looking for target locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default movement speed is running, but if the battery level is low, the
    movement speed should switch to walking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the battery is depleted, it should stop moving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the battery is fully charged, it should return to the movement pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth noting that the battery depletion and recharging logic has already
    been implemented in the **BaseDummyCharacter** class, so we won’t need to worry
    about it – we will just need to listen to the events dispatched by the character
    and behave accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned in the previous chapter, the Unreal Engine AI system provides
    a comprehensive collection of tasks, services, and decorators for our AIs. However,
    it’s worth noting that these built-in components may not cover all the specific
    requirements of your game. After all, as developers, we enjoy the creative process
    of building new things that suit our unique needs and add to the overall fun of
    game development!
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why, before adding nodes to our graph, we will need to implement a set
    of tasks and services that will make our dummy puppet life easier. In particular,
    we will create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A task that will find a random reachable location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service that will control the agent speed, depending on the battery level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service that will listen for battery status changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Behavior tree nodes can be implemented both in C++ and in Blueprint; for the
    purpose of this book, I will be sticking to the C++ option, but in [*Chapter 9*](B31016_09.xhtml#_idTextAnchor170)
    , *Extending Behavior Trees* , I will give you some useful hints on how to work
    also with Blueprint classes.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s start implementing new features for our dummy puppets!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the FindRandomLocation task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin by implementing the first node, which will enable the AI agent
    to search for a random actor in the level that has a specific tag. This functionality
    will allow the agent to have a specific point to navigate toward, enhancing its
    precision in reaching its destination.
  prefs: []
  type: TYPE_NORMAL
- en: To start implementing this node, from the Unreal Engine Editor, create a new
    C++ class that extends **BTTaskNode** , and name it **BTTask_FindRandomLocation**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **BTTask_FindRandomLocation.h** header file and add the following
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The **BlackboardKey** property will be used to declare which key should be used
    to store the random location once it has been found, while the **TargetTag** property
    will be used to find all available actors in the level in order to randomize a
    selection. Finally, the **ExecuteTask()** function will be called when the task
    node needs to be executed and will contain all the logic to randomize a target
    location. This function will need to return whether the task was successful or
    failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **BTTask_FindRandomLocation.cpp** file, and as a first step,
    add the needed **#include** declarations at the top of the file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the **ExecuteTask()** function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code gets the **Blackboard** component from **OwnerComp** and checks its
    validity. Then, it retrieves a list of actors with a specific tag, selecting a
    random element from that list. Then, it updates the Blackboard with the selected
    target’s location by using the **SetValueAsVector()** method. Note the use of
    **EBTNodeResult::Succeeded** and **EBTNodeResult::Failed** to return the result
    of all these operations; this is a requirement in order to indicate to the behavior
    tree whether a task was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed this task node, we can move on to the next step,
    which involves creating a service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SpeedControl service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now prepared to create our first custom service, which will monitor the
    character’s speed based on the battery charge. As you may remember from the previous
    chapter, a service is usually run at fixed intervals, and that’s exactly what
    we will do for the speed control service class – we will check the battery status
    and change the character speed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: To start implementing this class, from the Unreal Engine Editor, create a new
    C++ class that extends **BTService** , and name it **BTService_SpeedControl**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **BTTask_SpeedControl.h** header file, and in the **public** section,
    add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The **TickNode()** function that we are overriding will be executed on every
    node tick interval that this service is attached to. In order to call this function,
    the **bNotifyTick** needs to be set to **true** ; this value is already set by
    default, but it’s good to know if you need to disable it – something we’ll implement
    in the next service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to implement the service, so open the **BT_Service_SpeedControl.cpp**
    file and add the following **#include** declarations at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the **TickNode()** implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function is quite straightforward; all it does is update the speed of the
    controlled character based on the character’s battery status.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you might be wondering why we retrieve the AI controller and
    character reference at every tick instead of storing them. It may seem inefficient
    in terms of computational power, but it’s important to remember that the behavior
    tree is a shared asset. This means that a single instance of the behavior tree
    – and its nodes – will be executed for all AI agents that use it. Hence, storing
    a class reference would not yield any advantages and could result in unpredictable
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a genuine need to store a reference, you would need to create a
    node instance, which is precisely what we will do with the upcoming service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the BatteryCheck service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second service we are about to create is going to be a bit more challenging
    than the previous one. We need to continuously monitor any changes in the battery
    status; the most straightforward approach would be to use the node tick to constantly
    check the character’s battery status, similar to how the **UBTService_SpeedControl**
    class operates. However, as we learned earlier in this chapter, the dummy character
    dispatches battery status events. So, why not leverage this feature and make use
    of it?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start implementing this service; from the Unreal Engine Editor, create
    a new C++ class that extends **BTService** and name it **BTService_BetteryCheck**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the files have been created, open the **BTService_BatteryCheck.h** file,
    and just after the **#include** section, add the following forward declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the **public** section and the constructor declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after that, declare the **protected** section, along with all the necessary
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are doing something slightly different from the previous
    service; we are declaring a reference to the **Blackboard** component and the
    character. In this case, we will work with node instances, so each AI agent will
    have its own separate instance of the node decorated by this service. We also
    declare two Blackboard keys to assign the proper values to the Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after that, add the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The **OnBecomeRelevant()** function will be called when the decorated node becomes
    active, while the **OnCeaseRelevant()** function is no longer active. We will
    use these two functions to register the battery status events and react accordingly
    by using the **OnBatteryStatusChange()** function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now open the **BTService_BatteryCheck.cpp** file to start implementing
    the functions. As a first step, add the needed **#include** declarations at the
    top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after that, add the constructor implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although it may appear that we are simply setting some flags, we are actually
    making a significant change to the behavior of this service. First, we create
    a node instance; each AI agent will have its own instance of this service. Next,
    we disable the service tick, as we won’t be needing it, and we activate the relevancy
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s implement the **OnBatteryStatusChange()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing fancy here; we just set the Blackboard keys based on the new
    battery status. After that, we implement the two remaining functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These two functions register and unregister the **OnBatteryStatusChanged** delegate;
    additionally, **OnBecomeRelevantFunction()** saves a reference to the Blackboard
    component and the AI controller – something we can do because we use an instanced
    node for this service.
  prefs: []
  type: TYPE_NORMAL
- en: In this extensive section, you acquired the knowledge to create custom tasks
    and services in C++. Often, the pre-built classes provided by Unreal Engine may
    not suffice to create engaging AI behaviors. Hence, it becomes essential to develop
    your own distinctive nodes. In the forthcoming section, we will create such new
    classes to construct a fully operational AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a behavior tree on an agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin delving into the AI agent behavior tree, the first step is to compile
    the entire project. Once the process is finished, your custom tasks and services
    will be available as an option in the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with the Unreal Engine compilation process, my advice
    is to take a peek at *Appendix A* , *Understanding C++ in Unreal Engine* , and
    then return to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once the compilation phase is finished, we can start editing the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the behavior tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the **BT_RoamerDummy** asset we previously created and locate the only
    element – the **ROOT** node – present in the graph; you will see that it has a
    darker area at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The ROOT node](img/B31016_figure_08.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – The ROOT node
  prefs: []
  type: TYPE_NORMAL
- en: Clicking and dragging from this area will make all the nodes that can be connected
    to the **ROOT** node available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, whenever I mention the task of adding a node, I will be requesting
    that you perform the aforementioned action. One such case is depicted in *Figure
    8* *.12* .
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31016_figure_08.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8 .12 – Adding a node
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Composites** | **Sequence** node to the **Root** node, and in the **Details**
    panel, rename it **Root Sequence** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Root Sequence** node, add a **Tasks** | **FindRandomLocation** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the newly created node selected, in the **Details** panel, set the **Blackboard
    Key** dropdown value to **TargetLocation** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Root Sequence** node, add a **Composites** | **Selector** node at
    the right of the **FindRandomLocation** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your graph should now be similar to the one depicted in *Figure 8* *.13* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13 – The initial behavior tree](img/B31016_figure_08.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – The initial behavior tree
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to decorate the **Selector** node to give it extra abilities. To
    do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **Selector** node and select **Add Decorator** | **Conditional
    Loop** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click one more time and select **Add Service** | **Battery Check** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Conditional Loop** decorator, and in the **Details** panel, set
    the **Blackboard Key** attribute dropdown to **TargetLocation** . The **Key Query**
    attribute should be left to **Is Set** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **BatteryCheck** service, and in the **Details** panel, do the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Is Low on Battery Key** dropdown value to **IsLowOnBattery** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Is Battery Depleted Key** dropdown value to **IsBatteryDepleted**
    .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Selector** node should now look similar to *Figure 8* *.14* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.14 – The decorated Selector node](img/B31016_figure_08.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – The decorated Selector node
  prefs: []
  type: TYPE_NORMAL
- en: Note that the **BatteryCheck** service should show a **never ticks** comment;
    this is what we set when we implemented the C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: What we have done so far is basically the main loop of the AI agent behavior;
    we start by finding a target location for the AI agent, and then we execute a
    **Selector** node that will be waiting for battery status notifications. The **Conditional
    Loop** decorator will keep on repeating the child nodes (still to be added) while
    the **TargetLocation** key is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will focus on the **Selector** node and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Composite** | **Sequence** child node and rename it **Roam Sequence**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Task** | **Wait** child node, and in its **Details** panel, do the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Wait Time** value to **8.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Random Deviation** value to **2.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Node Name** as **Recharge Battery**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to decorate the **Roam Sequence** node with extra capabilities, so
    we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the **Roam Sequence** node and select **Add Decorator** | **Blackboard**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the decorator selected, do the following in the **Details** panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Notify Observers** dropdown value to **On** **Value Change**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Observer aborts** dropdown value to **Self**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Key Query** dropdown value to **Is** **Not Set**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Blackboard Key** dropdown value to **IsBatteryDepleted**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This portion of the graph should now look like *Figure 8* *.15* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.15 – The roam loop](img/B31016_figure_08.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – The roam loop
  prefs: []
  type: TYPE_NORMAL
- en: This portion of the graph will constantly loop between two phases – a roam sequence
    and a **Wait** node. The AI agent will stay in the roam sequence until the battery
    has been depleted. After that, it will stay still for between 6 and 10 seconds
    (so that the battery will recharge) and then revert to roaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step we need to take is to implement the roaming nodes. To do this,
    from the **Roam Sequence** node, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Tasks** | **Move To** node, and in the **Details** panel, set the **Blackboard
    Key** dropdown value to **TargetLocation** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Tasks** | **FindRandomLocation** node and, in the **Details** panel,
    set the **Target Tag** value to **TargetPoint** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Tasks** | **Wait** node, leaving its properties to their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add extra functionality to the **Move To** node, so right-click
    on it and select **Add Service** | **Speed Control** . This portion of the graph
    should look like *Figure 8* *.16* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16 – The roam sequence](img/B31016_figure_08.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – The roam sequence
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing here is pretty straightforward; we try to reach the target
    point and, once reached, search for another one, and then get some well-deserved
    rest by waiting a random time interval. While moving, we constantly check the
    battery status, changing the speed of the AI agent accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Great news! The behavior tree graph has been completed. Now, we can attach it
    to our dummy puppet and witness its behavior. However, before we proceed, we need
    to create some suitable Blueprints to ensure that everything functions smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AI agent Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with Unreal Engine, it is considered good practice to create a
    Blueprint from a C++ class. This approach offers several advantages, such as flexibility
    and extensibility, that contribute to a more efficient development process. That’s
    why we are going to create some Blueprints from our previously created classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controller Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by extending the **BaseDummyAIController** class into a Blueprint.
    To do so, in your **Content Browser** , create a new folder, name it **Blueprints**
    , and then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint class deriving from **BaseDummyAIController** , and name
    it **AIRoamerDummyController** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it, and in the **Class Defaults** panel, look for the **Dummy AI Controller**
    category and set the **Behavior Tree** attribute to **BT_RoamerDummy** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Assigning the behavior tree](img/B31016_figure_08.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Assigning the behavior tree
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to do to set up the AI controller for the roamer dummy
    character; we will now create the dedicated character.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the character Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a character Blueprint, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Blueprints** folder of your **Content Browser** create a new Blueprint
    class deriving from **BaseDummyCharacter** , and name it **BP_RoamerDummyCharacter**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it, and in the **Class Defaults** panel, look for the **AI Controller Class**
    attribute located in the **Pawn** category. From the dropdown menu, select **AIRoamerDummyController**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations on creating your very own roamer agent! Now, we just need to
    add one final touch to make it even better – a battery indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Adding cosmetics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide visual feedback on the AI agent’s status, we will create a component
    that displays the battery charge level through a light. This visual indicator
    will adjust the intensity of the light based on the current charge level. The
    higher the charge, the more intense the light will be. This will allow users to
    easily gauge the agent’s battery status at a glance, enhancing the overall user
    experience and ensuring they are aware of the agent’s power level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new C++ class that inherits from the **StaticMeshComponent**
    class, calling it **BatteryInjdicatorComponent** . Once the class has been created,
    open the **BatteryIndicatorComponent.h** file and replace the **UCLASS()** line
    with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the component accessible to Blueprints. Then, after the **GENERATED_BODY()**
    line of code, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The only things that need an explanation here are the **DynamicMaterialInstance**
    property, which will be used to change the material intensity property to make
    it more or less bright, and the **OnBatteryStatusChange()** function, which will
    be used to handle battery status change events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to start implementing the component, open the **BatteryIndicatorComponent.cpp**
    file, and add the following declaration at the top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor just needs to set the static mesh asset, so add this piece
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the **BeginPlay()** function by adding this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we check whether the owner of this component is an instance
    of the **BaseDummyCharacter** class. Next, we attach this component to the owner’s
    mesh component on a socket named **helmet** – a socket I already provided for
    you in the dummy skeletal mesh, as you can see in *Figure 8* *.18* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – The helmet socket](img/B31016_figure_08.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – The helmet socket
  prefs: []
  type: TYPE_NORMAL
- en: After that, we create a dynamic material instance for this component – this
    will let us modify the material properties at runtime. Finally, we add an event
    handler to the **OnBatteryStatusChanged** event of the owner character, which
    calls the **OnBatteryStatusChange** function of this component whenever the battery
    status of the owner character changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function complete, we just need to add the event handler to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we convert the **NewBatteryStatus** enum to a **float** value, calculate
    the light intensity, and then set a scalar parameter, **Intensity** , in the dynamic
    material instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can finally compile the project to make this component available to the
    character. Once the compilation process is finished, open the **BP_RoamerDummy**
    Blueprint and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Components** panel, click the **+** **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UnrealAgilityArena** | **Battery Indicator** to add this component
    to the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Adding a component](img/B31016_figure_08.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – Adding a component
  prefs: []
  type: TYPE_NORMAL
- en: Your dummy character is all set and eagerly awaiting to be tested at a suitable
    gym level.
  prefs: []
  type: TYPE_NORMAL
- en: Testing an agent in a gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to create a gym for our AI agent and see how it behaves. As
    you already know from [*Chapter 4*](B31016_04.xhtml#_idTextAnchor073) , *Setting
    Up a Navigation Mesh* , how to properly set up a gym with a nav mesh, I won’t
    dive into the creation details. Instead, I will give you some generic info about
    the level creation. Here is what you should do:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a level of your choice, starting from the Level Instances and Packed
    Level Actors I provided in the project template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **NavMeshBoundsVolume** actor so that it will cover all the walkable areas
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some obstacles to make things more interesting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or more **BP_RoamerDummyCharacter** instances
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some **NS_Target** Niagara actors that will work as target points
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only thing worth noting is that your AI agent will look for target points
    with the **TargetPoint** tag. If you are unfamiliar with the tag system, here’s
    how to tag your actors:'
  prefs: []
  type: TYPE_NORMAL
- en: For each **NS_Target** Niagara system, search for the **Tags** attribute located
    in the **Details** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **+** button to add a new tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Index [0]** field that will be created, insert **TargetPoint** , as
    shown in *Figure 8* *.20* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.20 – The actor tag](img/B31016_figure_08.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – The actor tag
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your level is finished, you are ready to start testing it; mine is shown
    in *Figure 8* *.21* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – The finished level](img/B31016_figure_08.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – The finished level
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon starting the simulation, you should see the following things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the starting battery charge (which is randomized), your AI agents
    will start to run, walk, or stand still
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They will try to reach a target point, and once reached, they will rest for
    about a second and then look for another one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the battery charge is low, they will start walking instead of running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the battery charge is depleted, they will stop, start recharging, and then
    start running again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The headlight should be brighter when the AI agent is fully charged and turn
    off when the battery is low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That ends this section, where you have learned how to build a fully working
    behavior tree, including creating your customized tasks and services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this quite lengthy chapter, you were introduced to the basics of creating
    a behavior tree in Unreal Engine. As you have learned, creating a fully working
    AI agent is a mixture of out-of-the-box features, custom classes, and a bit of
    ingenuity.
  prefs: []
  type: TYPE_NORMAL
- en: We’re just getting started on a fascinating journey that will unfold in the
    upcoming chapters, starting with the next one, where we’ll dive into the intricate
    workings of tasks, services, and decorators. Get ready for a significant overhaul
    to your beloved dummy puppets!
  prefs: []
  type: TYPE_NORMAL
