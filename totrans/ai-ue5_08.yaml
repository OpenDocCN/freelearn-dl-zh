- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Setting Up a Behavior Tree
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置行为树
- en: Understanding how to properly set up a behavior tree is crucial for developing
    effective AI systems in your games. As you have seen from the previous chapter,
    behavior trees serve as a powerful tool to define the logic and decision-making
    processes of AI characters, allowing developers to create complex behaviors in
    a structured and manageable manner. This chapter will provide valuable insights
    into the fundamentals of behavior trees’ implementation and their inner workings
    in Unreal Engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置行为树对于在您的游戏中开发有效的AI系统至关重要。正如您在前一章所看到的，行为树作为定义AI角色逻辑和决策过程的有力工具，允许开发者以结构化和可管理的方式创建复杂的行为。本章将提供关于行为树实现的基本原理及其在虚幻引擎中内部工作的宝贵见解。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Extending the Unreal Agility Arena
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Unreal Agility Arena
- en: Creating a behavior tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建行为树
- en: Implementing behavior tree tasks and services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现行为树任务和服务
- en: Setting up a behavior tree on an agent
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代理上设置行为树
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with this chapter, you’ll need to use the starter content available
    in this book’s companion repository, located at [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    . Through this link, locate the section for this chapter and download the **Unreal
    Agility Arena – Starter Content** ZIP file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要使用本书配套仓库中提供的起始内容，该仓库位于[https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    。通过此链接，找到本章的相应部分并下载**Unreal Agility Arena – 起始内容**ZIP文件。
- en: If you somehow get lost during the progress of this chapter, in the repository,
    you will also find the up-to-date project files at **Unreal Agility Arena –**
    **Chapter** **08** **End** .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在阅读本章的过程中迷路了，在仓库中，您还可以找到最新的项目文件，位于**Unreal Agility Arena –** **第** **08**
    **章** **结束**。
- en: Also, to fully understand this chapter, it is necessary to have some basic knowledge
    about Blueprint visual scripting and C++; as an extra piece of advice, you may
    want to take a peek at *Appendix A* , *Understanding C++ in Unreal Engine* , for
    a gentle introduction (or a refresher) on the C++ syntax in Unreal Engine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了完全理解本章内容，您需要具备一些关于蓝图视觉脚本和C++的基本知识；作为额外建议，您可能想浏览一下*附录A*，*在虚幻引擎中理解C++*，以获得对虚幻引擎中C++语法的温和介绍（或复习）。
- en: Extending the Unreal Agility Arena
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Unreal Agility Arena
- en: 'To get started, let’s continue exploring the short novel we introduced in [*Chapter
    4*](B31016_04.xhtml#_idTextAnchor073) , *Setting Up a* *Navigation Mesh* :'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们继续探索我们在[*第4章*](B31016_04.xhtml#_idTextAnchor073)中介绍的短篇小说，*设置导航网格*：
- en: '*As Dr. Markus and his trusty assistant Professor Viktoria continued to refine
    their AI dummy puppets, they stumbled upon an intriguing challenge: the limited
    power supply of the puppets’ batteries. It seemed that the advanced AI technology
    consumed energy at an alarming rate, causing the puppets to shut* *down unexpectedly.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*随着马克斯博士和他的忠实助手维多利亚教授继续完善他们的AI木偶，他们遇到了一个有趣的挑战：木偶电池的有限电源供应。似乎先进的AI技术以惊人的速度消耗能量，导致木偶意外地关闭了电源。*'
- en: '*Undeterred by this setback, Dr. Markus saw an opportunity to turn this limitation
    into a unique aspect of the puppets’ behavior. He theorized that the puppets’
    interactions, when powered by dwindling battery life, would mimic human fatigue
    and exhaustion. With great excitement, Dr. Markus and Professor Viktoria devised
    a plan to create a new series of experiments centered around the puppets’ limited*
    *power supply.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管遭遇了这次挫折，马克斯博士看到了将这一限制转化为木偶行为独特方面的机会。他提出理论，认为当木偶的互动由日益减少的电池寿命提供动力时，将模仿人类的疲劳和疲惫。马克斯博士和维多利亚教授充满热情地制定了一个计划，围绕木偶有限的*电源供应*开展一系列新的实验。*'
- en: After learning all that information in the last chapter, it’s time to dive in
    and begin crafting your own AI agents, equipped with fully functional behavior
    trees. To keep things simple and clean, I will start with a brand-new project,
    but you are free to continue developing the work you started in the previous chapters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章学习了所有这些信息之后，现在是时候深入其中，开始制作您自己的AI代理，配备完整功能的行为树。为了保持简单和整洁，我将从一个全新的项目开始，但您也可以自由地继续开发之前章节中开始的工作。
- en: To start, I will give you some short information on what will be created.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将给你一些简要信息，告诉你将要创建的内容。
- en: Updating the project brief
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新项目摘要
- en: As a starting point, you will need to create a new dummy character (the one
    from previous chapters is too limited) that will need to implement some base logic.
    This will let you extend its basic functionality once we start creating more advanced
    characters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，你需要创建一个新的傀儡角色（前几章的傀儡功能过于有限），它需要实现一些基本逻辑。这将使我们能够在创建更高级的角色时扩展其基本功能。
- en: 'The main requisites are listed as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 主要要求如下：
- en: The AI agent will be implemented in C++
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI代理将使用C++实现
- en: It will have the ability to move at two different speeds – walking and running
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将具有两种不同的移动速度——步行和跑步
- en: It will be provided with a battery system that will consume energy when walking
    and recharge when standing still
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将配备一个电池系统，在行走时会消耗能量，在静止时充电
- en: It will need to be controlled by a custom **AIController** class that will use
    behavior trees
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要由一个自定义的**AIController**类来控制，该类将使用行为树
- en: Once the character has been created, we will be able to start creating new gym
    levels to create and test new AI agent behaviors. So, let’s start by creating
    the project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦角色创建完成，我们就可以开始创建新的健身房级别，以创建和测试新的AI代理行为。所以，让我们先创建项目。
- en: Creating the project
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: The project creation process is basically the same as the one we covered in
    [*Chapter 4*](B31016_04.xhtml#_idTextAnchor073) , *Setting Up a Navigation Mesh*
    , so I won’t go much into detail about it; the distinction we will make (which
    is certainly not trivial) is the inclusion of C++ classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建过程基本上与我们之前在[*第4章*](B31016_04.xhtml#_idTextAnchor073)中介绍的过程相同，*设置导航网格*，所以我就不多详细介绍了；我们将做出的区别（这当然不是微不足道的）是包含C++类。
- en: Luckily, this is going to be a seamless transition, as when you create a new
    C++ class for the first time, Unreal Engine sets up the whole system for you.
    Once the C++ project files have been generated, you should see the **C++ Classes**
    folder in your **Content Browser** window, along with the **Content** folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这将是一个无缝的过渡，因为当你第一次创建新的C++类时，虚幻引擎会为你设置整个系统。一旦生成了C++项目文件，你应该能在你的**内容浏览器**窗口中看到**C++类**文件夹，以及**内容**文件夹。
- en: '![Figure 8.1 – The C++ folder](img/B31016_figure_08.01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.1 – The C++ folder](img/B31016_figure_08.01.jpg)'
- en: Figure 8.1 – The C++ folder
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – C++文件夹
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the **C++ Classes** folder does not appear in your **Content Browser** window,
    you will probably need to open the **Settings** window and tick the **Show C++
    Classes** option, as shown in *Figure 8* *.2* .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的**内容浏览器**窗口中没有出现**C++类**文件夹，你可能需要打开**设置**窗口并勾选**显示C++类**选项，如图*图8* *.2* 所示。
- en: '![img](img/B31016_figure_08.02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31016_figure_08.02.jpg)'
- en: Figure 8 .2 – Enabling the C++ folder
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 启用C++文件夹
- en: Let’s start creating the character class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建角色类。
- en: Creating the character
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建角色
- en: 'The first thing we are going to do is to create the base character class for
    our prospective AI dummies. To do so, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是为我们预期的AI傀儡创建基础角色类。为此，请按照以下步骤操作：
- en: From the main menu of the Unreal Engine Editor, select **Tools** | **New** **C++
    Class** .
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从虚幻引擎编辑器的主菜单中，选择**工具** | **新建** **C++类** 。
- en: '![Figure 8.3 – Creating a C++ class](img/B31016_figure_08.03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.3 – Creating a C++ class](img/B31016_figure_08.03.jpg)'
- en: Figure 8.3 – Creating a C++ class
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 创建C++类
- en: From the **Add C++ Class** pop-up window, select the **Character** option and
    click **Next** .
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**添加C++类**弹出窗口，选择**角色**选项并点击**下一步** 。
- en: '![Figure 8.4 – Class selection](img/B31016_figure_08.04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.4 – Class selection](img/B31016_figure_08.04.jpg)'
- en: Figure 8.4 – Class selection
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 类选择
- en: In the following window, insert **BaseDummyCharacter** into the **Name** field
    and leave the rest as it is.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下窗口中，将**BaseDummyCharacter**输入到**名称**字段，其余保持不变。
- en: '![Figure 8.5 – Class creation](img/B31016_figure_08.05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.5 – Class creation](img/B31016_figure_08.05.jpg)'
- en: Figure 8.5 – Class creation
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 类创建
- en: Click the **Create Class** button to start the class creation process.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建类**按钮开始类创建过程。
- en: As this is the very first class you have created, Unreal will start generating
    the C++ project; after that, your IDE – most probably Visual Studio or Rider –
    will open, and you will be able to start developing your class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是你创建的第一个类，虚幻引擎将开始生成C++项目；之后，你的IDE——很可能是Visual Studio或Rider——将打开，你将能够开始开发你的类。
- en: Handling the battery status
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理电池状态
- en: 'Before implementing the character, we need to define how its battery status
    will be tracked; that’s why we are going to create a simple enumeration class
    that will list how much the battery is charged. To do this, follow these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现角色之前，我们需要定义如何跟踪其电池状态；这就是为什么我们将创建一个简单的枚举类来列出电池的充电量。为此，请按照以下步骤操作：
- en: Inside your IDE, locate the **UnrealAgilityArena/Source/UnrealAgilityArena**
    folder.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的IDE中，定位到**UnrealAgilityArena/Source/UnrealAgilityArena**文件夹。
- en: Inside this folder, create a new text file and call it **BatteryStatus.h** .
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中，创建一个新的文本文件，并将其命名为**BatteryStatus.h**。
- en: Open the file to edit it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件进行编辑。
- en: 'Inside the file, add this piece of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I guess you are already familiar with what an enumeration does, but a short
    explanation here is mandatory; we are defining an **enum** class, which in Unreal
    Engine needs to be of type **uint8** , and we are listing four levels of battery
    charging – **Empty** , **Low** , **Medium** and **Full** . The **UENUM()** macro
    defines an **enum** class for the Unreal Engine framework, and the **BlueprintType**
    specifier will expose it to the Blueprint system, making it usable for variables.
    The **DisplayName** metadata defines how the value will be shown in the Blueprint
    system; you can use your own convention here if you so desire.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你已经熟悉枚举的作用，但在这里简要解释是必要的；我们正在定义一个**enum**类，在虚幻引擎中需要是**uint8**类型，并列出四个电池充电级别——**Empty**（空）、**Low**（低）、**Medium**（中）和**Full**（满）。**UENUM()**宏为虚幻引擎框架定义了一个**enum**类，**BlueprintType**指定器将使其对蓝图系统可用，使其可用于变量。**DisplayName**元数据定义了在蓝图系统中如何显示值；如果你愿意，可以在这里使用自己的约定。
- en: Finally, pay attention to the *E* prefix in the name definition; this is the
    Unreal Engine naming convention for **enum** types, and it is mandatory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意名称定义中的*E*前缀；这是虚幻引擎中**枚举**类型的命名约定，是强制性的。
- en: With the battery status defined, we are ready to start implementing the dummy
    character.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了电池状态后，我们就可以开始实现虚拟角色了。
- en: Implementing the character
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现角色
- en: To start implementing the AI agent, open the **BaseDummyCharacter.h** file –
    that is, the header for the agent class – and start adding the class definitions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现AI代理，打开**BaseDummyCharacter.h**文件——即代理类的头文件——并开始添加类定义。
- en: 'As a first step, add the battery status definition at the top of the file,
    where all the **#include** definitions are set:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，在文件顶部添加电池状态定义，那里设置了所有的**#include**定义：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the **#include** declarations you’ll be adding always need to be put before
    the **.generated.h** definition – in this case, **BaseDummyCharacter.generated.h**
    . The **.generated.h** definition always needs to be the last in the declaration
    list; this convention ensures that all the necessary dependencies are properly
    set at compilation time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要添加的所有**#include**声明都需要放在**.generated.h**定义之前——在本例中是**BaseDummyCharacter.generated.h**。**.generated.h**定义始终需要在声明列表的末尾；这个约定确保所有必要的依赖项在编译时都得到正确设置。
- en: Declaring properties
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明属性
- en: 'The second step is to add all the properties that will be exposed in the extending
    Blueprint classes. To do so, under the **public** section of the file, add the
    following declarations:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是添加所有将在扩展蓝图类中公开的属性。要做到这一点，在文件的**public**部分添加以下声明：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we have declared a list of variables to handle the agent:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一系列变量来处理代理：
- en: '**MaxBatteryLevel** : Represents the maximum value reachable by the agent battery'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MaxBatteryLevel**：表示代理电池可以达到的最大值'
- en: '**BatteryCostPerTick** : Represents how much battery power is spent by the
    agent while it is moving'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BatteryCostPerTick**：表示代理在移动时消耗的电池电量'
- en: '**BatteryRechargePerTick** : Represents how much battery power is recovered
    when the agent is resting'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BatteryRechargePerTick**：表示当代理休息时恢复的电池电量'
- en: '**RunSpeed** : Represents the maximum speed reachable when running'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RunSpeed**：表示跑步时可以达到的最大速度'
- en: '**WalkSpeed** : Represents the maximum speed reachable when walking'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WalkSpeed**：表示行走时可以达到的最大速度'
- en: '**MovementRandomDeviation** : A value that will be randomly added or subtracted
    to the agent speed in order to make the movement pace less predictable'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MovementRandomDeviation**：一个将被随机添加或减去以使移动节奏更不可预测的值'
- en: The **UPROPERTY()** macro is used to declare class properties with additional
    functionality and metadata. It allows for easy integration with the Unreal Engine
    Editor, providing a visual interface to modify and configure these properties.
    The **EditAnywhere** property specifier indicates that the property can be edited
    in property windows from the Unreal Engine Editor, while **BlueprintReadWrite**
    specifies that the property will be accessible from the extending Blueprint classes
    in read and write mode. Finally, we want all the properties to be in the same
    category – that is, **Dummy Character** – and that’s why we have set the **Category**
    property specifier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**UPROPERTY()**宏用于声明具有附加功能和元数据的类属性。它允许轻松集成到虚幻引擎编辑器中，提供了一个可视化界面来修改和配置这些属性。**EditAnywhere**属性指定符表示可以从虚幻引擎编辑器的属性窗口中编辑该属性，而**BlueprintReadWrite**指定符表示该属性将以读/写模式从扩展的蓝图类中访问。最后，我们希望所有属性都在同一个类别中——即**Dummy
    Character**——这就是为什么我们设置了**Category**属性指定符。'
- en: 'We need just one more variable, but this need not be public because it will
    be used for the actor’s inner logic. In the **protected** section, let’s add the
    following declaration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个额外的变量，但这个变量不需要是公共的，因为它将用于角色的内部逻辑。在**受保护**部分，让我们添加以下声明：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This self-explanatory attribute will be used to keep track of the actual battery
    level of the agent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一目了然的属性将用于跟踪代理的实际电池级别。
- en: Adding delegates
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加委托
- en: We now need to create an event dispatcher for battery status change notification;
    the best method in C++ is to use a **delegate** .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个用于电池状态更改通知的事件分发器；在C++中，最好的方法是使用**委托**。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with delegates, my advice is to take a peek at *Appendix
    A* , *Understanding C++ in Unreal Engine* , at the end of this book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉委托，我的建议是查看本书末尾的附录A，*Understanding C++ in Unreal Engine*。
- en: 'Locate the **public** section and add the following piece of code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到**公共**部分，并添加以下代码片段：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have declared a dynamic multicast delegate with a single parameter – the
    battery new status – that will be dispatched every time the battery changes its
    charge level.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个带有单个参数的动态多播委托——电池的新状态——每次电池改变充电级别时都会分发。
- en: Declaring functions
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明函数
- en: 'The last thing we need to add to the header is the function declarations. As
    a first step, delete the following line of code that is found at the end of the
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在头文件中添加的最后一件事情是函数声明。作为第一步，删除文件末尾的以下代码行：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This character will be controlled by AI, so we don’t need to set up the player
    input. Next, just after the **Tick()** declaration, add the following lines of
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色将由AI控制，所以我们不需要设置玩家输入。接下来，在**Tick()**声明之后，添加以下代码行：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have just declared two functions – **SetWalkSpeed()** and **SetRunSpeed()**
    – that will let us change the character speed at runtime. Additionally, we have
    added a getter function for the agent battery status.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚声明了两个函数——**SetWalkSpeed()**和**SetRunSpeed()**——这将允许我们在运行时更改角色速度。此外，我们还添加了一个用于代理电池状态的获取器函数。
- en: In Unreal Engine, the **UFUNCTION()** macro is used to declare functions that
    are recognized by the Unreal Engine reflection system; this means the function
    becomes accessible and usable within the Unreal Engine framework. All three functions
    have the **BlueprintCallable** specifier added, meaning that these functions will
    be accessible in a Blueprint graph. Additionally, the **GetBatteryStatus()** function
    has the **const** keyword added; this will remove the execution pin in the corresponding
    Blueprint node, as we need this function to just be a getter and not change any
    data during execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**UFUNCTION()**宏用于声明由虚幻引擎反射系统识别的函数；这意味着函数在虚幻引擎框架内变得可访问和可用。所有三个函数都添加了**BlueprintCallable**指定符，这意味着这些函数将在蓝图图中可访问。此外，**GetBatteryStatus()**函数添加了**const**关键字；这将移除相应的蓝图节点中的执行引脚，因为我们只需要这个函数作为一个获取器，在执行过程中不改变任何数据。
- en: Implementing functions
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现函数
- en: Now that all the class declarations have been done, we can start implementing
    the functions. To do so, the first thing you need to do is to open the **BaseDummyCharacter.cpp**
    file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有类声明都已经完成，我们可以开始实现函数。要做到这一点，你需要做的第一件事是打开**BaseDummyCharacter.cpp**文件。
- en: The first thing you’ll need to do is to remove the **SetPlayerInputComponent()**
    function, as the corresponding declaration in the header file was previously removed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要做的是移除**SetPlayerInputComponent()**函数，因为头文件中的相应声明之前已被移除。
- en: 'Next, we need to add the **#include** declarations at the very beginning of
    the file. Simply add these three lines of code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在文件的非常开始处添加**#include**声明。只需添加以下三行代码：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As always, remember to add these **#include** declarations before the **.**
    **generated.h** declaration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，记得在**.generated.h**声明之前添加这些**#include**声明。
- en: 'Next, locate the **ABaseDummyCharacter()** constructor function, as we will
    need to set up some character attributes and components. This function should
    have already a line of code that sets the **bCanEverTick** property to **true**
    . Add the following line of code just after it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定位到**ABaseDummyCharacter()**构造函数，因为我们需要设置一些角色属性和组件。这个函数应该已经有一行代码将**bCanEverTick**属性设置为**true**。在其后添加以下代码行：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we will use the **Tick()** event just for updating the battery status, we
    don’t need it to be executed every frame; we have set a time interval of a quarter
    of a second – this will be more than enough to suit our own needs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用**Tick()**事件仅用于更新电池状态，我们不需要它在每一帧都执行；我们已设置了一个四分之一的秒的时间间隔——这应该足够满足我们的需求。
- en: 'Next, add the following lines of code that set up the yaw, pitch, and roll
    behavior of the character:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码行来设置角色的偏航、俯仰和翻滚行为：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we need to initialize the skeletal mesh component in order to show the
    dummy puppet model. Add these lines of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化骨骼网格组件以显示虚拟木偶模型。添加以下代码行：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we set the mesh location and rotation in order to suit the dummy puppet
    model. After that, we assign the dummy puppet skeletal mesh asset by hardcoding
    the asset path; we will use just this asset, so there is no need to assign it
    from the extending Blueprint classes. We will do the same with the animation Blueprint
    asset; I have provided one such asset for you in the project files in the declared
    path.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置网格位置和旋转以适应虚拟木偶模型。之后，我们通过硬编码资产路径来分配虚拟木偶骨骼网格资产；我们只使用这个资产，因此没有必要从扩展蓝图类中分配它。我们也会以相同的方式处理动画蓝图资产；我在项目文件中提供了这样一个资产，路径已在声明中给出。
- en: 'Now, we are going to set the capsule component size in order to match the dummy
    puppet model. To do this, add this line of code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置胶囊组件的大小以匹配虚拟木偶模型。为此，添加以下代码行：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, set up the movement component by adding the following lines of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过添加以下代码行来设置运动组件：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the use of **bUseRVOAvoidance** , set to **true** ; we will use several
    agents at the same time, so a basic avoidance system is almost mandatory to make
    things work properly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到**bUseRVOAvoidance**的使用，设置为**true**；我们将同时使用几个代理，因此一个基本的避障系统几乎是强制性的，以确保事情能够正常工作。
- en: The constructor method is complete, so we can now start implementing all the
    other functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数方法已完成，因此我们现在可以开始实现所有其他函数。
- en: 'Locate the **BeginPlay()** method, and just after the **Super::BeginPlay()**
    declaration, add the following lines of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到**BeginPlay()**方法，并在**Super::BeginPlay()**声明之后，添加以下代码行：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the game starts, we set the AI agent to have a random battery level to
    make things a bit more interesting, and next, we broadcast this status to all
    registered listeners.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，我们将AI代理的电池电设为随机值以使事情更有趣，然后，我们将此状态广播给所有已注册的监听器。
- en: 'After that, just after the closing bracket of the **BeginPlay()** function,
    add the following piece of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在**BeginPlay()**函数的括号关闭后，添加以下代码段：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There’s nothing fancy here; we just implement the two functions to change the
    movement speed of the agent, making it walk or run.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的地方；我们只是实现了两个函数来改变代理的运动速度，使其行走或奔跑。
- en: 'We now need to implement the battery status getter function, so add the following
    lines of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现电池状态获取函数，因此添加以下代码行：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we simply check the battery level and return the corresponding
    status enumeration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是简单地检查电池电量并返回相应的状态枚举。
- en: 'The last thing we need to implement is the **Tick()** function, where we will
    constantly check how much battery power is consumed, depending on the character
    movement speed. Locate the **Tick()** function, and just after **Super::Tick(DeltaTime);**
    , add the following lines of code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的是最后的 **Tick()** 函数，其中我们将不断检查根据角色移动速度消耗了多少电池电量。定位到 **Tick()** 函数，并在 **Super::Tick(DeltaTime);**
    之后添加以下代码行：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this piece of code, we compute the current battery status using the **GetBatteryStatus()**
    function. Then, if the velocity of the character’s movement is greater than a
    tiny number – that is, **0.1** – it means the agent is moving, so we decrease
    the battery level by the **BatteryCostPerTick** value. Otherwise, the agent is
    standing still – therefore, recharging – so we increase the battery level by **BatteryRechargePerTick**
    . After that, we clamp the battery level between a value of zero and **MaxBatteryLevel**
    . Finally, we check whether the starting battery status is different from the
    new battery status, and we eventually broadcast the new battery status using the
    **OnBatteryStatusChanged** delegate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用 **GetBatteryStatus()** 函数计算当前电池状态。然后，如果角色的移动速度大于一个非常小的数值 – 即 **0.1**
    – 这意味着代理正在移动，因此我们将电池电量减少 **BatteryCostPerTick** 的值。否则，代理处于静止状态 – 因此正在充电 – 所以我们将电池电量增加
    **BatteryRechargePerTick**。之后，我们将电池电量限制在零和 **MaxBatteryLevel** 之间。最后，我们检查起始电池状态是否与新的电池状态不同，并最终使用
    **OnBatteryStatusChanged** 代理广播新的电池状态。
- en: The **BaseDummyCharacter** class has been completed. It is evident that we have
    not yet incorporated any AI agent behavior; this is intentional, as we plan to
    manage everything through an **AIController** class, a task we will undertake
    in the following section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**BaseDummyCharacter** 类已经完成。很明显，我们还没有将任何 AI 代理行为集成进去；这是故意的，因为我们计划通过 **AIController**
    类来管理一切，这项任务我们将在下一节中完成。'
- en: Creating a behavior tree
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建行为树
- en: 'In this section, we will create a fully functional behavior tree for the agent
    we previously created. The steps we will follow are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为之前创建的代理创建一个完整功能的行为树。我们将遵循以下步骤：
- en: Creating the AI controller
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 AI 控制器
- en: Creating the Blackboard
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建黑板
- en: Creating the behavior tree
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建行为树
- en: Let’s start by creating a subclass of the **AIController** class to control
    our dummy puppet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个 **AIController** 类的子类来控制我们的虚拟木偶。
- en: Creating the AI controller
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AI 控制器
- en: 'We will be now creating a class extending **AIController** that will be used
    as a starting point for the behavior tree. To get started, open the Unreal Engine
    Editor and do the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个扩展 **AIController** 的类，它将作为行为树的起点。要开始，打开 Unreal Engine 编辑器并执行以下步骤：
- en: From the main menu, select **Tools** | **New** **C++ Class** .
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单选择 **工具** | **新建** **C++ 类**。
- en: Click on the **All Classes** tab section and look for **AIController** .
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **所有类** 选项卡部分，查找 **AIController**。
- en: '![Figure 8.6 – AI controller class creation](img/B31016_figure_08.06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 创建 AI 控制器类](img/B31016_figure_08.06.jpg)'
- en: Figure 8.6 – AI controller class creation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 创建 AI 控制器类
- en: Click the **Next** button.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮。
- en: Name the class **BaseDummyAIController** and click the **Create** **Class**
    button.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为 **BaseDummyAIController** 并点击 **创建** **类** 按钮。
- en: Once the class files have been created and your IDE has been opened, look for
    the **BaseDummyAIController.h** header file and open it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了类文件并且你的 IDE 已经打开，查找 **BaseDummyAIController.h** 头文件并打开它。
- en: Editing the header file
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑头文件
- en: 'As a first step, add a forward declaration for the **BehaviorTree** class,
    just after the **#** **include** declarations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，在 **#** **include** 声明之后添加对 **BehaviorTree** 类的前向声明：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in the **protected** section of the header file, add these lines of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在头文件的保护部分添加以下代码行：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This property declares a pointer to the behavior tree, so that it will be assignable
    from the **Class Defaults** Blueprints panel – using the **EditAnywhere** specifier
    – and it will be readable from any extending Blueprints.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性声明了一个指向行为树的指针，因此它可以从 **类默认** 蓝图面板 – 使用 **EditAnywhere** 指定符 – 进行赋值，并且可以从任何扩展蓝图中进行读取。
- en: 'Now, just after these lines of code, add this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就在这些代码行之后，添加以下内容：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The **OnPossess()** function is called when the controller possesses a **Pawn**
    instance – and our dummy character extends it – and it is a good place to run
    behavior trees.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制器拥有一个 **Pawn** 实例 – 以及我们的虚拟角色扩展了它 – 时，会调用 **OnPossess()** 函数，这是一个运行行为树的好地方。
- en: Implementing the controller
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现控制器
- en: 'The controller is quite easy to implement; we just need to run the behavior
    tree when the AI agent is possessed. To do so, open the **BaseDummyAIController.cpp**
    file and add these lines of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的实现相当简单；我们只需要在 AI 智能体被控制时运行行为树。要做到这一点，打开 **内容抽屉** 文件，并添加以下代码行：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this function, the **Super::OnPossess()** base class is called first. Then,
    we use the **ensureMsgf()** macro to ensure that the **BehaviorTree** variable
    is not a null pointer. If a behavior tree has been set, we run it using the **RunBehaviorTree()**
    function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，首先调用基类 **Super::OnPossess()**。然后，我们使用 **ensureMsgf()** 宏确保 **BehaviorTree**
    变量不是一个空指针。如果已经设置了行为树，我们使用 **RunBehaviorTree()** 函数运行它。
- en: With the AI controller set, we can start implementing the actual AI behaviors,
    starting from the Blackboard.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 AI 控制器后，我们可以开始实现实际的 AI 行为，从黑板开始。
- en: Creating the Blackboard
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建黑板
- en: 'Creating a Blackboard asset is a straightforward task once you know what keys
    you will be tracking. In our case, we want to make the following values available
    to the behavior tree:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建黑板资产是一个简单的任务，一旦你知道你将跟踪哪些键。在我们的例子中，我们希望以下值对行为树可用：
- en: A target location vector that will be used by the agent to walk around the level
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目标位置向量，智能体将用它来在关卡中行走
- en: A Boolean flag that will warn the agent once the battery charge is dangerously
    low
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔标志，当电池电量危险低时将警告智能体
- en: A Boolean flag that will indicate that the battery has been depleted
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔标志，将指示电池已耗尽
- en: 'To get started, we need to create a Blackboard asset. To do so, follow these
    steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要创建一个黑板资产。要做到这一点，请按照以下步骤进行：
- en: Open **Content Drawer** and create a new folder, naming it **AI** .
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **内容抽屉** 并创建一个新文件夹，命名为 **AI** 。
- en: Open the folder and right-click on **Content Drawer** , selecting **Artificial
    Intelligence** | **Blackboard** to create a Blackboard asset.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件夹，在 **内容抽屉** 上右键单击，选择 **人工智能** | **黑板** 以创建黑板资产。
- en: Name the asset **BB_Dummy** and double-click on it to open it.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资产命名为 **BB_Dummy** 并双击它以打开它。
- en: '![Figure 8.7 – The Blackboard panel](img/B31016_figure_08.07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 黑板面板](img/B31016_figure_08.07.jpg)'
- en: Figure 8.7 – The Blackboard panel
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 黑板面板
- en: Once the Blackboard is opened, you will see that there’s already a key named
    **SelfActor** ; we won’t be using it during this chapter, but we will leave it
    as it is, since it is usually used to store a reference to the owning actor.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开黑板，你会看到已经有一个名为 **SelfActor** 的键；在本章中我们不会使用它，但我们会保留它，因为它通常用于存储对拥有者的引用。
- en: 'We need to create three keys, as stated at the beginning of this subsection,
    so we’ll start by following these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本小节开头所述，我们需要创建三个键，因此我们将首先按照以下步骤进行：
- en: 'Click the **New Key** button, and from the dropdown list, select the **Vector**
    type, as shown in *Figure 8* *.8* :'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击 **新建键** 按钮，然后从下拉列表中选择 **Vector** 类型，如图 8.8 所示：
- en: '![Figure 8.8 – Key creation](img/B31016_figure_08.08.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 键创建](img/B31016_figure_08.08.jpg)'
- en: Figure 8.8 – Key creation
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 键创建
- en: Name the new key **TargetLocation** .
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新键命名为 **TargetLocation** 。
- en: Click the **New Key** button again, select the **Bool** type, and name the new
    key **IsLowOnBattery** .
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击 **新建键** 按钮，选择 **Bool** 类型，并将新键命名为 **IsLowOnBattery** 。
- en: Click the **New Key** button once more, select the **Bool** type, and name the
    new key **IsBatteryDepleted** .
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击 **新建键** 按钮，选择 **Bool** 类型，并将新键命名为 **IsBatteryDepleted** 。
- en: 'Once these steps are finished, your Blackboard should be pretty similar to
    the one depicted in *Figure 8* *.9* :'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你的黑板应该与图 8.9 中所示的黑板非常相似：
- en: '![Figure 8.9 – The finished Blackboard](img/B31016_figure_08.09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 完成的黑板](img/B31016_figure_08.09.jpg)'
- en: Figure 8.9 – The finished Blackboard
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 完成的黑板
- en: The Blackboard is finished, and we can now start working on the behavior tree
    for our AI agent.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板已完成，我们现在可以开始为我们的 AI 智能体创建行为树。
- en: Creating the behavior tree
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建行为树
- en: 'Like the Blackboard, a behavior tree is created as a project asset. Let’s start
    by performing the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与黑板一样，行为树作为项目资产创建。让我们首先执行以下步骤：
- en: In **Content Drawer** , open the **AI** folder.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容抽屉** 中打开 **AI** 文件夹。
- en: Right-click on **Content Drawer** and select **Artificial Intelligence** | **Behavior
    Tree** .
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **内容抽屉** 并选择 **人工智能** | **行为树** 。
- en: Name the newly created asset **BT_RoamerDummy** and double-click on it to open
    it.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产命名为 **BT_RoamerDummy** 并双击它以打开它。
- en: 'Once opened, you should see a graph pretty similar to the one shown in *Figure
    8* *.10* :'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开，你应该看到一个与*图8.10*非常相似的图：
- en: '![Figure 8.10 – Behavior tree creation](img/B31016_figure_08.10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 行为树创建](img/B31016_figure_08.10.jpg)'
- en: Figure 8.10 – Behavior tree creation
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 行为树创建
- en: Note that the **Root** node is already included in the graph. As mentioned in
    the previous chapter, there can only be one such node in the graph. Furthermore,
    in the **Details** panel, you should see that the **BB_Dummy** Blackboard asset
    has already been assigned to the Blackboard asset. If you don’t see it assigned,
    simply click the **Blackboard** property dropdown and select the **BB_Dummy**
    asset; it should be the only asset of that type present in your project.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**根**节点已经包含在图中。正如前一章所述，图中只能有一个这样的节点。此外，在**详细信息**面板中，你应该看到**BB_Dummy**黑板资产已经被分配给黑板资产。如果你没有看到分配，只需点击**黑板**属性下拉菜单并选择**BB_Dummy**资产；它应该是你项目中唯一的那种资产。
- en: In this section, we went through a step-by-step guide on creating a character
    that will utilize a behavior tree to implement AI logic. We have also successfully
    created a Blackboard asset and a behavior tree asset, which serve as the foundation
    to implement our character’s AI behaviors. As the process of implementing all
    the AI logic for our character is quite extensive, we will tackle it in the upcoming
    section. Stay tuned for a detailed walk-through on how to effectively implement
    AI behaviors for our character.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们逐步介绍了创建一个将利用行为树实现AI逻辑的角色。我们还成功创建了黑板资产和行为树资产，它们是我们角色AI行为的基础。由于实现我们角色所有AI逻辑的过程相当复杂，我们将在下一节中处理它。敬请期待如何有效地为我们的角色实现AI行为的详细说明。
- en: Implementing behavior tree tasks and services
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现行为树任务和服务
- en: 'Before creating the behavior tree, it is crucial to have a clear understanding
    of the intended implementation. The AI agent will need to manage the following
    behaviors:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建行为树之前，对预期的实现有一个清晰的理解至关重要。AI代理需要管理以下行为：
- en: Wander around the level looking for target locations
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关卡中四处游荡寻找目标位置
- en: The default movement speed is running, but if the battery level is low, the
    movement speed should switch to walking
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认移动速度是跑步，但如果电池电量低，移动速度应切换为步行
- en: Once the battery is depleted, it should stop moving
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦电池耗尽，它应该停止移动
- en: Once the battery is fully charged, it should return to the movement pattern
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦电池完全充电，它应该返回到移动模式
- en: It is worth noting that the battery depletion and recharging logic has already
    been implemented in the **BaseDummyCharacter** class, so we won’t need to worry
    about it – we will just need to listen to the events dispatched by the character
    and behave accordingly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，电池耗尽和充电逻辑已经在**BaseDummyCharacter**类中实现，所以我们不需要担心它——我们只需要监听角色发出的事件并相应地行事。
- en: As I mentioned in the previous chapter, the Unreal Engine AI system provides
    a comprehensive collection of tasks, services, and decorators for our AIs. However,
    it’s worth noting that these built-in components may not cover all the specific
    requirements of your game. After all, as developers, we enjoy the creative process
    of building new things that suit our unique needs and add to the overall fun of
    game development!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在前一章中提到的，虚幻引擎AI系统为我们的AI提供了一套全面的任务、服务和装饰器。然而，值得注意的是，这些内置组件可能无法满足你游戏中所有的特定需求。毕竟，作为开发者，我们享受着构建新事物以适应我们独特需求并增加游戏开发整体乐趣的创造性过程！
- en: 'That’s why, before adding nodes to our graph, we will need to implement a set
    of tasks and services that will make our dummy puppet life easier. In particular,
    we will create the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将节点添加到我们的图中之前，我们需要实现一系列任务和服务，这将使我们的虚拟木偶生活变得更简单。特别是，我们将创建以下内容：
- en: A task that will find a random reachable location
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将找到随机可达位置的任务
- en: A service that will control the agent speed, depending on the battery level
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个根据电池电量控制代理速度的服务
- en: A service that will listen for battery status changes
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将监听电池状态变化的服务
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Behavior tree nodes can be implemented both in C++ and in Blueprint; for the
    purpose of this book, I will be sticking to the C++ option, but in [*Chapter 9*](B31016_09.xhtml#_idTextAnchor170)
    , *Extending Behavior Trees* , I will give you some useful hints on how to work
    also with Blueprint classes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树节点既可以用C++实现，也可以用蓝图实现；为了这本书的目的，我将坚持使用C++选项，但在[*第9章*](B31016_09.xhtml#_idTextAnchor170)，“扩展行为树”中，我会给你一些有用的提示，告诉你如何与蓝图类一起工作。
- en: So, let’s start implementing new features for our dummy puppets!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始为我们的虚拟木偶实现新功能！
- en: Implementing the FindRandomLocation task
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现FindRandomLocation任务
- en: We will begin by implementing the first node, which will enable the AI agent
    to search for a random actor in the level that has a specific tag. This functionality
    will allow the agent to have a specific point to navigate toward, enhancing its
    precision in reaching its destination.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现第一个节点，它将使AI代理能够在具有特定标签的水平中搜索一个随机演员。这个功能将允许代理有一个特定的点去导航，从而提高其到达目的地的精确度。
- en: To start implementing this node, from the Unreal Engine Editor, create a new
    C++ class that extends **BTTaskNode** , and name it **BTTask_FindRandomLocation**
    .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现这个节点，从Unreal Engine编辑器中，创建一个新的C++类，扩展**BTTaskNode**，并将其命名为**BTTask_FindRandomLocation**。
- en: 'Open the **BTTask_FindRandomLocation.h** header file and add the following
    declarations:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**BTTask_FindRandomLocation.h**头文件并添加以下声明：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The **BlackboardKey** property will be used to declare which key should be used
    to store the random location once it has been found, while the **TargetTag** property
    will be used to find all available actors in the level in order to randomize a
    selection. Finally, the **ExecuteTask()** function will be called when the task
    node needs to be executed and will contain all the logic to randomize a target
    location. This function will need to return whether the task was successful or
    failed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**BlackboardKey**属性将用于声明找到随机位置后应该使用哪个键来存储，而**TargetTag**属性将用于在水平中查找所有可用的演员，以便随机选择。最后，当任务节点需要执行时，将调用**ExecuteTask()**函数，并将包含所有随机目标位置的逻辑。这个函数需要返回任务是否成功或失败。'
- en: 'Now, open the **BTTask_FindRandomLocation.cpp** file, and as a first step,
    add the needed **#include** declarations at the top of the file itself:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开**BTTask_FindRandomLocation.cpp**文件，作为第一步，在文件本身顶部添加所需的**#include**声明：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the **ExecuteTask()** function implementation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加**ExecuteTask()**函数的实现：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code gets the **Blackboard** component from **OwnerComp** and checks its
    validity. Then, it retrieves a list of actors with a specific tag, selecting a
    random element from that list. Then, it updates the Blackboard with the selected
    target’s location by using the **SetValueAsVector()** method. Note the use of
    **EBTNodeResult::Succeeded** and **EBTNodeResult::Failed** to return the result
    of all these operations; this is a requirement in order to indicate to the behavior
    tree whether a task was successful or not.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从**OwnerComp**获取**Blackboard**组件并检查其有效性。然后，它检索具有特定标签的演员列表，并从该列表中随机选择一个元素。然后，它使用**SetValueAsVector()**方法将选定的目标位置更新到Blackboard中。注意使用**EBTNodeResult::Succeeded**和**EBTNodeResult::Failed**来返回所有这些操作的结果；这是为了向行为树指示任务是否成功的一个要求。
- en: Now that we have completed this task node, we can move on to the next step,
    which involves creating a service.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个任务节点，我们可以继续下一步，这涉及到创建一个服务。
- en: Implementing the SpeedControl service
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现SpeedControl服务
- en: We are now prepared to create our first custom service, which will monitor the
    character’s speed based on the battery charge. As you may remember from the previous
    chapter, a service is usually run at fixed intervals, and that’s exactly what
    we will do for the speed control service class – we will check the battery status
    and change the character speed accordingly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建我们的第一个自定义服务，该服务将根据电池充电量监控角色的速度。如您从上一章所记得，服务通常以固定间隔运行，这正是我们将为速度控制服务类所做的一一我们将检查电池状态并根据需要更改角色速度。
- en: To start implementing this class, from the Unreal Engine Editor, create a new
    C++ class that extends **BTService** , and name it **BTService_SpeedControl**
    .
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现这个类，从Unreal Engine编辑器中，创建一个新的C++类，扩展**BTService**，并将其命名为**BTService_SpeedControl**。
- en: 'Open the **BTTask_SpeedControl.h** header file, and in the **public** section,
    add the following declarations:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**BTTask_SpeedControl.h**头文件，并在**public**部分添加以下声明：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The **TickNode()** function that we are overriding will be executed on every
    node tick interval that this service is attached to. In order to call this function,
    the **bNotifyTick** needs to be set to **true** ; this value is already set by
    default, but it’s good to know if you need to disable it – something we’ll implement
    in the next service.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要重写的 **TickNode()** 函数将在此服务附加到的每个节点计时器间隔上执行。为了调用此函数，**bNotifyTick** 需要设置为
    **true**；这个值默认已经设置，但如果你需要禁用它——我们将在下一个服务中实现这一点——了解这一点是好的。
- en: 'We are ready to implement the service, so open the **BT_Service_SpeedControl.cpp**
    file and add the following **#include** declarations at the top:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好实现服务，所以打开 **BT_Service_SpeedControl.cpp** 文件，并在顶部添加以下 **#include** 声明：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After that, add the **TickNode()** implementation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加 **TickNode()** 的实现：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function is quite straightforward; all it does is update the speed of the
    controlled character based on the character’s battery status.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当直接；它所做的只是根据角色的电池状态更新受控角色的速度。
- en: At this stage, you might be wondering why we retrieve the AI controller and
    character reference at every tick instead of storing them. It may seem inefficient
    in terms of computational power, but it’s important to remember that the behavior
    tree is a shared asset. This means that a single instance of the behavior tree
    – and its nodes – will be executed for all AI agents that use it. Hence, storing
    a class reference would not yield any advantages and could result in unpredictable
    behaviors.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能想知道为什么我们每次计时都检索 AI 控制器和角色引用，而不是将它们存储起来。从计算能力方面来看，这可能看起来效率不高，但重要的是要记住，行为树是一个共享资源。这意味着行为树的单个实例（及其节点）将为所有使用它的
    AI 代理执行。因此，存储类引用不会带来任何优势，并可能导致不可预测的行为。
- en: If there is a genuine need to store a reference, you would need to create a
    node instance, which is precisely what we will do with the upcoming service.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实需要存储一个引用，你需要创建一个节点实例，这正是我们将要在即将到来的服务中做的。
- en: Implementing the BatteryCheck service
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 BatteryCheck 服务
- en: The second service we are about to create is going to be a bit more challenging
    than the previous one. We need to continuously monitor any changes in the battery
    status; the most straightforward approach would be to use the node tick to constantly
    check the character’s battery status, similar to how the **UBTService_SpeedControl**
    class operates. However, as we learned earlier in this chapter, the dummy character
    dispatches battery status events. So, why not leverage this feature and make use
    of it?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将创建的第二个服务将比之前的一个更具挑战性。我们需要持续监控电池状态的变化；最直接的方法是使用节点计时器来不断检查角色的电池状态，类似于 **UBTService_SpeedControl**
    类的操作。然而，正如我们在本章早期所学的，虚拟角色会派发电池状态事件。那么，为什么不利用这个特性并加以利用呢？
- en: Let’s start implementing this service; from the Unreal Engine Editor, create
    a new C++ class that extends **BTService** and name it **BTService_BetteryCheck**
    .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现这个服务开始；从虚幻引擎编辑器中，创建一个新的 C++ 类，扩展 **BTService** 并将其命名为 **BTService_BetteryCheck**。
- en: 'Once the files have been created, open the **BTService_BatteryCheck.h** file,
    and just after the **#include** section, add the following forward declarations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了文件，打开 **BTService_BatteryCheck.h** 文件，并在 **#include** 部分之后，添加以下前置声明：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, add the **public** section and the constructor declaration:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，添加 **public** 部分 和 构造函数声明：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just after that, declare the **protected** section, along with all the necessary
    properties:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，声明 **protected** 部分，以及所有必要的属性：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we are doing something slightly different from the previous
    service; we are declaring a reference to the **Blackboard** component and the
    character. In this case, we will work with node instances, so each AI agent will
    have its own separate instance of the node decorated by this service. We also
    declare two Blackboard keys to assign the proper values to the Blackboard.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在做一些与之前服务略有不同的事情；我们声明了对 **Blackboard** 组件和角色的引用。在这种情况下，我们将与节点实例一起工作，因此每个
    AI 代理都将拥有由该服务装饰的独立节点实例。我们还声明了两个 Blackboard 键来分配适当的值到 Blackboard。
- en: 'Just after that, add the following functions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下函数：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The **OnBecomeRelevant()** function will be called when the decorated node becomes
    active, while the **OnCeaseRelevant()** function is no longer active. We will
    use these two functions to register the battery status events and react accordingly
    by using the **OnBatteryStatusChange()** function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当装饰节点变得活跃时，将调用**OnBecomeRelevant()**函数，而**OnCeaseRelevant()**函数则不再活跃。我们将使用这两个函数通过**OnBatteryStatusChange()**函数注册电池状态事件并相应地做出反应。
- en: 'You can now open the **BTService_BatteryCheck.cpp** file to start implementing
    the functions. As a first step, add the needed **#include** declarations at the
    top of the file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以打开**BTService_BatteryCheck.cpp**文件开始实现函数。作为第一步，在文件顶部添加所需的**#include**声明：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Immediately after that, add the constructor implementation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，添加构造函数实现：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although it may appear that we are simply setting some flags, we are actually
    making a significant change to the behavior of this service. First, we create
    a node instance; each AI agent will have its own instance of this service. Next,
    we disable the service tick, as we won’t be needing it, and we activate the relevancy
    behavior.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来我们只是在设置一些标志，但实际上我们正在对这个服务的功能进行重大更改。首先，我们创建一个节点实例；每个AI代理都将拥有这个服务的独立实例。接下来，我们禁用服务计时器，因为我们不需要它，然后激活相关性行为。
- en: 'Next, let’s implement the **OnBatteryStatusChange()** method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现**OnBatteryStatusChange()**方法：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is nothing fancy here; we just set the Blackboard keys based on the new
    battery status. After that, we implement the two remaining functions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西；我们只是根据新的电池状态设置Blackboard键。之后，我们实现剩下的两个函数：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These two functions register and unregister the **OnBatteryStatusChanged** delegate;
    additionally, **OnBecomeRelevantFunction()** saves a reference to the Blackboard
    component and the AI controller – something we can do because we use an instanced
    node for this service.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数注册和注销**OnBatteryStatusChanged**委托；此外，**OnBecomeRelevantFunction()**保存对Blackboard组件和AI控制器的引用——我们可以这样做，因为我们使用实例节点来处理这个服务。
- en: In this extensive section, you acquired the knowledge to create custom tasks
    and services in C++. Often, the pre-built classes provided by Unreal Engine may
    not suffice to create engaging AI behaviors. Hence, it becomes essential to develop
    your own distinctive nodes. In the forthcoming section, we will create such new
    classes to construct a fully operational AI agent.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个广泛的章节中，你获得了在C++中创建自定义任务和服务的知识。通常，Unreal Engine提供的预构建类可能不足以创建引人入胜的AI行为。因此，开发你自己的独特节点变得至关重要。在接下来的章节中，我们将创建这样的新类来构建一个完全运行的AI代理。
- en: Setting up a behavior tree on an agent
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代理上设置行为树
- en: To begin delving into the AI agent behavior tree, the first step is to compile
    the entire project. Once the process is finished, your custom tasks and services
    will be available as an option in the behavior tree.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解AI代理行为树，第一步是编译整个项目。一旦过程完成，你的自定义任务和服务将作为选项出现在行为树中。
- en: Note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with the Unreal Engine compilation process, my advice
    is to take a peek at *Appendix A* , *Understanding C++ in Unreal Engine* , and
    then return to this chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Unreal Engine的编译过程不熟悉，我的建议是先看看*附录A*，*在Unreal Engine中理解C++*，然后再回到这一章。
- en: Once the compilation phase is finished, we can start editing the behavior tree.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译阶段完成，我们就可以开始编辑行为树了。
- en: Editing the behavior tree
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑行为树
- en: Open the **BT_RoamerDummy** asset we previously created and locate the only
    element – the **ROOT** node – present in the graph; you will see that it has a
    darker area at the bottom.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们之前创建的**BT_RoamerDummy**资产，并定位图中唯一的元素——**根节点**；你会看到它在底部有一个较暗的区域。
- en: '![Figure 8.11 – The ROOT node](img/B31016_figure_08.11.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 根节点](img/B31016_figure_08.11.jpg)'
- en: Figure 8.11 – The ROOT node
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 根节点
- en: Clicking and dragging from this area will make all the nodes that can be connected
    to the **ROOT** node available.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个区域点击并拖动将使所有可以连接到**根节点**的节点变得可用。
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Moving forward, whenever I mention the task of adding a node, I will be requesting
    that you perform the aforementioned action. One such case is depicted in *Figure
    8* *.12* .
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，每当我提到添加节点的任务时，我都会要求你执行上述操作。*图8.12*就是一个这样的例子。
- en: '![img](img/B31016_figure_08.12.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31016_figure_08.12.jpg)'
- en: Figure 8 .12 – Adding a node
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 添加节点
- en: 'To get started, do the following steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请执行以下步骤：
- en: Add a **Composites** | **Sequence** node to the **Root** node, and in the **Details**
    panel, rename it **Root Sequence** .
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**复合** | **序列**节点添加到**根**节点，并在**详细信息**面板中将其重命名为**根序列**。
- en: From the **Root Sequence** node, add a **Tasks** | **FindRandomLocation** node.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**根序列**节点，添加一个**任务** | **FindRandomLocation**节点。
- en: With the newly created node selected, in the **Details** panel, set the **Blackboard
    Key** dropdown value to **TargetLocation** .
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选中新创建的节点后，在**详细信息**面板中，将**黑板键**下拉值设置为**TargetLocation**。
- en: From the **Root Sequence** node, add a **Composites** | **Selector** node at
    the right of the **FindRandomLocation** node.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**根序列**节点，在**FindRandomLocation**节点的右侧添加一个**复合** | **选择器**节点。
- en: 'Your graph should now be similar to the one depicted in *Figure 8* *.13* :'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的图表现在应该类似于*图8.13*所示：
- en: '![Figure 8.13 – The initial behavior tree](img/B31016_figure_08.13.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 初始行为树](img/B31016_figure_08.13.jpg)'
- en: Figure 8.13 – The initial behavior tree
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 初始行为树
- en: 'We now need to decorate the **Selector** node to give it extra abilities. To
    do so, follow these steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要装饰**选择器**节点以赋予它额外的能力。为此，请按照以下步骤操作：
- en: Right-click on the **Selector** node and select **Add Decorator** | **Conditional
    Loop** .
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**选择器**节点并选择**添加装饰器** | **条件循环**。
- en: Right-click one more time and select **Add Service** | **Battery Check** .
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键点击并选择**添加服务** | **电池检查**。
- en: Click on the **Conditional Loop** decorator, and in the **Details** panel, set
    the **Blackboard Key** attribute dropdown to **TargetLocation** . The **Key Query**
    attribute should be left to **Is Set** .
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**条件循环**装饰器，在**详细信息**面板中，将**黑板键**属性下拉设置为**TargetLocation**。**键查询**属性应保留为**已设置**。
- en: 'Click on the **BatteryCheck** service, and in the **Details** panel, do the
    following:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**电池检查**服务，在**详细信息**面板中执行以下操作：
- en: Set the **Is Low on Battery Key** dropdown value to **IsLowOnBattery** .
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**电池电量低键**下拉值设置为**IsLowOnBattery**。
- en: Set the **Is Battery Depleted Key** dropdown value to **IsBatteryDepleted**
    .
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**电池耗尽键**下拉值设置为**IsBatteryDepleted**。
- en: 'The **Selector** node should now look similar to *Figure 8* *.14* :'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**选择器**节点现在应该看起来类似于*图8.14*：'
- en: '![Figure 8.14 – The decorated Selector node](img/B31016_figure_08.14.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 装饰后的选择器节点](img/B31016_figure_08.14.jpg)'
- en: Figure 8.14 – The decorated Selector node
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 装饰后的选择器节点
- en: Note that the **BatteryCheck** service should show a **never ticks** comment;
    this is what we set when we implemented the C++ class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**BatteryCheck**服务应该显示一个**永不触发**注释；这是我们实现C++类时设置的。
- en: What we have done so far is basically the main loop of the AI agent behavior;
    we start by finding a target location for the AI agent, and then we execute a
    **Selector** node that will be waiting for battery status notifications. The **Conditional
    Loop** decorator will keep on repeating the child nodes (still to be added) while
    the **TargetLocation** key is set.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的是AI代理行为的主要循环的基本内容；我们首先为AI代理找到一个目标位置，然后执行一个等待电池状态通知的**选择器**节点。**条件循环**装饰器将一直重复子节点（尚未添加），直到**TargetLocation**键被设置。
- en: 'Now, we will focus on the **Selector** node and do the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将关注**选择器**节点，并执行以下操作：
- en: Add a **Composite** | **Sequence** child node and rename it **Roam Sequence**
    .
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**复合** | **序列**子节点，并将其重命名为**漫游序列**。
- en: 'Add a **Task** | **Wait** child node, and in its **Details** panel, do the
    following:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**任务** | **等待**子节点，并在其**详细信息**面板中执行以下操作：
- en: Set the **Wait Time** value to **8.0**
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**等待时间**值设置为**8.0**
- en: Set the **Random Deviation** value to **2.0**
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**随机偏差**值设置为**2.0**
- en: Set the **Node Name** as **Recharge Battery**
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**节点名称**设置为**充电电池**
- en: 'We need to decorate the **Roam Sequence** node with extra capabilities, so
    we do the following:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要为**漫游序列**节点添加额外的功能，所以我们执行以下操作：
- en: Right-click on the **Roam Sequence** node and select **Add Decorator** | **Blackboard**
    .
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**漫游序列**节点，选择**添加装饰器** | **黑板**
- en: 'With the decorator selected, do the following in the **Details** panel:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择装饰器后，在**详细信息**面板中执行以下操作：
- en: Set the **Notify Observers** dropdown value to **On** **Value Change**
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**通知观察者**下拉值设置为**值更改时开启**
- en: Set the **Observer aborts** dropdown value to **Self**
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**观察者中止**下拉值设置为**自身**
- en: Set the **Key Query** dropdown value to **Is** **Not Set**
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**键查询**下拉值设置为**未设置**
- en: Set the **Blackboard Key** dropdown value to **IsBatteryDepleted**
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**黑板键**下拉值设置为**IsBatteryDepleted**
- en: 'This portion of the graph should now look like *Figure 8* *.15* :'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图表的这部分现在应该看起来像*图8.15*：
- en: '![Figure 8.15 – The roam loop](img/B31016_figure_08.15.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.15 – 漫游循环](img/B31016_figure_08.15.jpg)'
- en: Figure 8.15 – The roam loop
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 漫游循环
- en: This portion of the graph will constantly loop between two phases – a roam sequence
    and a **Wait** node. The AI agent will stay in the roam sequence until the battery
    has been depleted. After that, it will stay still for between 6 and 10 seconds
    (so that the battery will recharge) and then revert to roaming.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分图表将在两个阶段之间不断循环 – 一个漫游序列和一个 **等待** 节点。AI 代理将保持在漫游序列中，直到电池耗尽。之后，它将静止 6 到 10
    秒（以便电池充电），然后返回漫游。
- en: 'The last step we need to take is to implement the roaming nodes. To do this,
    from the **Roam Sequence** node, do the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的最后一个步骤是实现漫游节点。为此，从 **Roam Sequence** 节点，执行以下操作：
- en: Add a **Tasks** | **Move To** node, and in the **Details** panel, set the **Blackboard
    Key** dropdown value to **TargetLocation** .
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **Tasks** | **Move To** 节点，并在 **详细信息** 面板中，将 **黑板键** 下拉值设置为 **TargetLocation**。
- en: Add a **Tasks** | **FindRandomLocation** node and, in the **Details** panel,
    set the **Target Tag** value to **TargetPoint** .
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **Tasks** | **FindRandomLocation** 节点，并在 **详细信息** 面板中，将 **目标标签** 值设置为 **TargetPoint**。
- en: Add a **Tasks** | **Wait** node, leaving its properties to their default values.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **Tasks** | **Wait** 节点，保留其属性为默认值。
- en: 'We need to add extra functionality to the **Move To** node, so right-click
    on it and select **Add Service** | **Speed Control** . This portion of the graph
    should look like *Figure 8* *.16* :'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向 **Move To** 节点添加额外的功能，因此右键单击它，选择 **添加服务** | **速度控制**。这部分图表应类似于 *图 8* *.16*：
- en: '![Figure 8.16 – The roam sequence](img/B31016_figure_08.16.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 漫游序列](img/B31016_figure_08.16.jpg)'
- en: Figure 8.16 – The roam sequence
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 漫游序列
- en: What we are doing here is pretty straightforward; we try to reach the target
    point and, once reached, search for another one, and then get some well-deserved
    rest by waiting a random time interval. While moving, we constantly check the
    battery status, changing the speed of the AI agent accordingly.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情相当简单；我们试图到达目标点，一旦到达，就寻找另一个点，然后通过等待一个随机的时间间隔来获得一些应得的休息。在移动过程中，我们不断检查电池状态，相应地改变
    AI 代理的速度。
- en: Great news! The behavior tree graph has been completed. Now, we can attach it
    to our dummy puppet and witness its behavior. However, before we proceed, we need
    to create some suitable Blueprints to ensure that everything functions smoothly.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！行为树图已经完成。现在，我们可以将其附加到我们的虚拟木偶上，并观察其行为。然而，在我们继续之前，我们需要创建一些合适的 Blueprint 来确保一切顺利运行。
- en: Creating the AI agent Blueprints
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AI 代理 Blueprint
- en: When working with Unreal Engine, it is considered good practice to create a
    Blueprint from a C++ class. This approach offers several advantages, such as flexibility
    and extensibility, that contribute to a more efficient development process. That’s
    why we are going to create some Blueprints from our previously created classes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Unreal Engine 时，从 C++ 类创建 Blueprint 被认为是良好的实践。这种方法提供了诸如灵活性和可扩展性等优势，有助于提高开发效率。这就是为什么我们将从之前创建的类中创建一些
    Blueprint 的原因。
- en: Creating the controller Blueprint
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建控制器 Blueprint
- en: 'Let’s start by extending the **BaseDummyAIController** class into a Blueprint.
    To do so, in your **Content Browser** , create a new folder, name it **Blueprints**
    , and then follow these steps:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将 **BaseDummyAIController** 类扩展到 Blueprint 开始。为此，在您的 **内容浏览器** 中创建一个新的文件夹，命名为
    **Blueprints**，然后按照以下步骤操作：
- en: Create a new Blueprint class deriving from **BaseDummyAIController** , and name
    it **AIRoamerDummyController** .
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的从 **BaseDummyAIController** 派生的 Blueprint 类，并将其命名为 **AIRoamerDummyController**。
- en: Open it, and in the **Class Defaults** panel, look for the **Dummy AI Controller**
    category and set the **Behavior Tree** attribute to **BT_RoamerDummy** .
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它，在 **类默认值** 面板中，查找 **Dummy AI Controller** 类别，并将 **行为树** 属性设置为 **BT_RoamerDummy**。
- en: '![Figure 8.17 – Assigning the behavior tree](img/B31016_figure_08.17.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – 分配行为树](img/B31016_figure_08.17.jpg)'
- en: Figure 8.17 – Assigning the behavior tree
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 分配行为树
- en: This is all you need to do to set up the AI controller for the roamer dummy
    character; we will now create the dedicated character.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设置漫游虚拟角色 AI 控制器的全部内容；我们现在将创建专门的角色。
- en: Creating the character Blueprint
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建角色 Blueprint
- en: 'To create a character Blueprint, follow these steps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个角色 Blueprint，请按照以下步骤操作：
- en: In the **Blueprints** folder of your **Content Browser** create a new Blueprint
    class deriving from **BaseDummyCharacter** , and name it **BP_RoamerDummyCharacter**
    .
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**内容浏览器**的**蓝图**文件夹中创建一个新的蓝图类，从**BaseDummyCharacter**派生，并将其命名为**BP_RoamerDummyCharacter**。
- en: Open it, and in the **Class Defaults** panel, look for the **AI Controller Class**
    attribute located in the **Pawn** category. From the dropdown menu, select **AIRoamerDummyController**
    .
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它，在**类默认值**面板中，查找位于**Pawn**类别的**AI控制器类**属性。从下拉菜单中选择**AIRoamerDummyController**。
- en: Congratulations on creating your very own roamer agent! Now, we just need to
    add one final touch to make it even better – a battery indicator.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你创建了自己的漫游代理！现在，我们只需添加一个最后的细节，使其更加完美 – 一个电池指示器。
- en: Adding cosmetics
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加外观
- en: To provide visual feedback on the AI agent’s status, we will create a component
    that displays the battery charge level through a light. This visual indicator
    will adjust the intensity of the light based on the current charge level. The
    higher the charge, the more intense the light will be. This will allow users to
    easily gauge the agent’s battery status at a glance, enhancing the overall user
    experience and ensuring they are aware of the agent’s power level.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供对AI代理状态的视觉反馈，我们将创建一个组件，通过灯光显示电池充电水平。这个视觉指示器将根据当前的充电水平调整灯光的强度。充电越高，灯光越亮。这将使用户能够轻松地一眼判断代理的电池状态，增强整体用户体验，并确保他们了解代理的电力水平。
- en: 'Let’s start by creating a new C++ class that inherits from the **StaticMeshComponent**
    class, calling it **BatteryInjdicatorComponent** . Once the class has been created,
    open the **BatteryIndicatorComponent.h** file and replace the **UCLASS()** line
    with the following one:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的C++类，从**StaticMeshComponent**类继承，命名为**BatteryInjdicatorComponent**。一旦创建了类，打开**BatteryIndicatorComponent.h**文件，并将**UCLASS()**行替换为以下内容：
- en: '[PRE35]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will make the component accessible to Blueprints. Then, after the **GENERATED_BODY()**
    line of code, add the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使组件对蓝图可用。然后，在**GENERATED_BODY()**代码行之后，添加以下代码：
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only things that need an explanation here are the **DynamicMaterialInstance**
    property, which will be used to change the material intensity property to make
    it more or less bright, and the **OnBatteryStatusChange()** function, which will
    be used to handle battery status change events.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要解释的只有**DynamicMaterialInstance**属性，它将被用来改变材质强度属性，使其更亮或更暗，以及**OnBatteryStatusChange()**函数，它将被用来处理电池状态改变事件。
- en: 'Now, to start implementing the component, open the **BatteryIndicatorComponent.cpp**
    file, and add the following declaration at the top of it:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要开始实现组件，打开**BatteryIndicatorComponent.cpp**文件，并在其顶部添加以下声明：
- en: '[PRE37]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The constructor just needs to set the static mesh asset, so add this piece
    of code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只需设置静态网格资产，因此添加以下代码：
- en: '[PRE38]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, implement the **BeginPlay()** function by adding this block of code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过添加以下代码块实现**BeginPlay()**函数：
- en: '[PRE39]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this function, we check whether the owner of this component is an instance
    of the **BaseDummyCharacter** class. Next, we attach this component to the owner’s
    mesh component on a socket named **helmet** – a socket I already provided for
    you in the dummy skeletal mesh, as you can see in *Figure 8* *.18* :'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们检查此组件的所有者是否是**BaseDummyCharacter**类的实例。接下来，我们将此组件附加到所有者的名为**helmet**的网格组件插座上
    – 这是我已经在虚拟骨骼网格中为你提供的插座，如*图8* *.18* 所示：
- en: '![Figure 8.18 – The helmet socket](img/B31016_figure_08.18.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图8.18 – 头盔插座](img/B31016_figure_08.18.jpg)'
- en: Figure 8.18 – The helmet socket
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 头盔插座
- en: After that, we create a dynamic material instance for this component – this
    will let us modify the material properties at runtime. Finally, we add an event
    handler to the **OnBatteryStatusChanged** event of the owner character, which
    calls the **OnBatteryStatusChange** function of this component whenever the battery
    status of the owner character changes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们为这个组件创建一个动态材质实例 – 这将允许我们在运行时修改材质属性。最后，我们向拥有者的**OnBatteryStatusChanged**事件添加一个事件处理器，每当拥有者的电池状态改变时，都会调用此组件的**OnBatteryStatusChange**函数。
- en: 'With this function complete, we just need to add the event handler to our code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 函数完成后，我们只需将事件处理器添加到我们的代码中：
- en: '[PRE40]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we convert the **NewBatteryStatus** enum to a **float** value, calculate
    the light intensity, and then set a scalar parameter, **Intensity** , in the dynamic
    material instance.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将**NewBatteryStatus**枚举转换为**float**值，计算光强度，然后在动态材质实例中设置一个标量参数，**Intensity**。
- en: 'We can finally compile the project to make this component available to the
    character. Once the compilation process is finished, open the **BP_RoamerDummy**
    Blueprint and do the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以编译项目，使这个组件对角色可用。一旦编译过程完成，打开**BP_RoamerDummy**蓝图并执行以下操作：
- en: In the **Components** panel, click the **+** **Add** button.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中，点击**+** **添加**按钮。
- en: Select **UnrealAgilityArena** | **Battery Indicator** to add this component
    to the character.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**UnrealAgilityArena** | **Battery Indicator**将此组件添加到角色中。
- en: '![Figure 8.19 – Adding a component](img/B31016_figure_08.19.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19 – 添加组件](img/B31016_figure_08.19.jpg)'
- en: Figure 8.19 – Adding a component
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 添加组件
- en: Your dummy character is all set and eagerly awaiting to be tested at a suitable
    gym level.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您的虚拟角色已经设置完毕，并急切地等待在合适的健身房级别进行测试。
- en: Testing an agent in a gym
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在健身房测试一个代理
- en: 'We are now ready to create a gym for our AI agent and see how it behaves. As
    you already know from [*Chapter 4*](B31016_04.xhtml#_idTextAnchor073) , *Setting
    Up a Navigation Mesh* , how to properly set up a gym with a nav mesh, I won’t
    dive into the creation details. Instead, I will give you some generic info about
    the level creation. Here is what you should do:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好为我们的AI代理创建一个健身房，并观察它的行为。如您在[*第4章*](B31016_04.xhtml#_idTextAnchor073)中已知的，*设置导航网格*，如何正确设置带有导航网格的健身房，我不会深入创建细节。相反，我将为您提供一些关于关卡创建的通用信息。以下是您应该做的事情：
- en: Create a level of your choice, starting from the Level Instances and Packed
    Level Actors I provided in the project template
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您选择的关卡，从项目模板中提供的关卡实例和打包关卡演员开始
- en: Add a **NavMeshBoundsVolume** actor so that it will cover all the walkable areas
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**NavMeshBoundsVolume**演员，使其覆盖所有可通行区域
- en: Add some obstacles to make things more interesting
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些障碍物使事情更有趣
- en: Add one or more **BP_RoamerDummyCharacter** instances
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个或多个**BP_RoamerDummyCharacter**实例
- en: Add some **NS_Target** Niagara actors that will work as target points
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些作为目标点的**NS_Target** Niagara演员
- en: 'The only thing worth noting is that your AI agent will look for target points
    with the **TargetPoint** tag. If you are unfamiliar with the tag system, here’s
    how to tag your actors:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您的AI代理将寻找带有**TargetPoint**标签的目标点。如果您不熟悉标签系统，以下是如何为您的演员添加标签的方法：
- en: For each **NS_Target** Niagara system, search for the **Tags** attribute located
    in the **Details** panel.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个**NS_Target** Niagara系统，在**详细信息**面板中搜索**标签**属性。
- en: Click the **+** button to add a new tag.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**按钮添加一个新的标签。
- en: In the **Index [0]** field that will be created, insert **TargetPoint** , as
    shown in *Figure 8* *.20* .
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将创建的**索引[0]**字段中，插入**TargetPoint**，如图*图8.20*所示。
- en: '![Figure 8.20 – The actor tag](img/B31016_figure_08.20.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图8.20 – 演员标签](img/B31016_figure_08.20.jpg)'
- en: Figure 8.20 – The actor tag
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 演员标签
- en: 'Once your level is finished, you are ready to start testing it; mine is shown
    in *Figure 8* *.21* :'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的关卡完成，您就可以开始测试它；我的在*图8.21*中显示：
- en: '![Figure 8.21 – The finished level](img/B31016_figure_08.21.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图8.21 – 完成的关卡](img/B31016_figure_08.21.jpg)'
- en: Figure 8.21 – The finished level
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 完成的关卡
- en: 'Upon starting the simulation, you should see the following things happen:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始模拟时，您应该看到以下事情发生：
- en: Depending on the starting battery charge (which is randomized), your AI agents
    will start to run, walk, or stand still
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据起始电池电量（这是随机的），您的AI代理将开始奔跑、行走或静止不动
- en: They will try to reach a target point, and once reached, they will rest for
    about a second and then look for another one
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将尝试到达一个目标点，一旦到达，它们将休息大约一秒钟，然后寻找另一个目标点
- en: If the battery charge is low, they will start walking instead of running
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果电池电量低，它们将开始步行而不是跑步
- en: If the battery charge is depleted, they will stop, start recharging, and then
    start running again
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果电池电量耗尽，它们将停止，开始充电，然后再次开始运行
- en: The headlight should be brighter when the AI agent is fully charged and turn
    off when the battery is low
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当AI代理电量充足时，前灯应该更亮，当电池电量低时关闭
- en: That ends this section, where you have learned how to build a fully working
    behavior tree, including creating your customized tasks and services.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束，您已经学习了如何构建一个完全工作的行为树，包括创建您定制的任务和服务。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this quite lengthy chapter, you were introduced to the basics of creating
    a behavior tree in Unreal Engine. As you have learned, creating a fully working
    AI agent is a mixture of out-of-the-box features, custom classes, and a bit of
    ingenuity.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当长的章节中，你被介绍了在虚幻引擎中创建行为树的基础知识。正如你所学的，创建一个完全工作的AI代理是现成功能、自定义类和一点独创性的混合体。
- en: We’re just getting started on a fascinating journey that will unfold in the
    upcoming chapters, starting with the next one, where we’ll dive into the intricate
    workings of tasks, services, and decorators. Get ready for a significant overhaul
    to your beloved dummy puppets!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚开始一段迷人的旅程，这个旅程将在接下来的章节中展开，从下一章开始，我们将深入探讨任务、服务和装饰器的复杂运作。准备好对你的心爱的小木偶进行一次重大的改造吧！
