<html><head></head><body>
        

                            
                    <h1 class="header-title">A Quick Refresher</h1>
                
            
            
                
<p>Welcome to <em>Hands-On Neural Network Development Using C#</em>. I want to thank you for purchasing this book and for taking this journey with us. It seems as if, everywhere you turn, everywhere you go, all you hear and read about is machine learning, artificial intelligence, deep learning, neuron this, artificial that, and on and on. And, to add to all that excitement, everyone you talk to has a slightly different idea about the meaning of each of those terms.</p>
<p>In this chapter, we are going to go over some very basic neural network terminology to set the stage for future chapters. We need to be speaking the same language, just to make sure that everything we do in later chapters is crystal clear.</p>
<p>I should also let you know that the goal of the book is to get you, a C# developer, up and running as fast as possible. To do this, we will use as many open source libraries as possible. We must do a few custom applications, but we've provided the source code for these as well. In all cases, we want you to be able to add this functionality to your applications with maximal speed and minimal effort.</p>
<p>OK, let's begin.</p>
<p>Neural networks have been around for very many years but have made a resurgence over the past few years and are now a hot topic. And that, my friends, is why this book is being written. The goal here is to help you get through the weeds and into the open so you can navigate your neural path to success. There is a specific focus in this book on C# .NET developers. I wanted to make sure that the C# developers out there had handy resources that could be of some help in their projects, rather than the Python, R, and MATLAB code we more commonly see. If you have Visual Studio installed and a strong desire to learn, you are ready to begin your journey.</p>
<p>First, let's make sure we're clear on a couple of things. In writing this book, the assumption was made that you, the reader, had limited exposure to neural networks. If you do have some exposure, that is great; you may feel free to jump to the sections that interest you the most. I also assumed that you are an experienced C# developer, and have built applications using C#, .NET, and Visual Studio, although I made no assumptions as to which versions of each you may have used. The goal is not about C# syntax, the .NET framework, or Visual Studio itself. Once again, the purpose is to get as many valuable resources into the hands of developers, so they can embellish their code and create world-class applications.</p>
<p>Now that we've gotten that out of the way, I know you're excited to jump right in and start coding, but to make you productive, we first must spend some time going over some basics. A little bit of theory, some fascinating insights into the whys and wherefores, and we're going to throw in a few visuals along the way to help with the rough-and-tough dry stuff. Don't worry; we won't go too deep on the theory, and, in a few pages from here, you'll be writing and going through source code!</p>
<p>Also, keep in mind that research in this area is rapidly evolving. What is the latest and greatest today is old news next month. Therefore, consider this book an overview of different research and opinions. It is not the be-all-and-end-all bible of everything neural network-related, nor should it be perceived to be. You are very likely to encounter someone else with different opinions from that of the writer. You're going to find people who will write apps and functions differently. That's great—gather all the information that you can, and make informed choices on your own. Only doing by that will you increase your knowledge base.</p>
<p>This chapter will include the following topics:</p>
<ul>
<li>Neural network overview</li>
<li>The role of neural networks in today's enterprises</li>
<li>Types of learning</li>
<li>Understanding perceptions</li>
<li>Understanding activation functions</li>
<li>Understanding back propagation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="mce-root">Basic knowledge of C# is a must to understand the applications that we will develop in this book. Also, Microsoft Visual Studio (Any version) is a preferred software to develop applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Neural network overview</h1>
                
            
            
                
<p>Let's start by defining exactly what we are going to call a neural network. Let me first note that you may also hear a neural network called an <strong>Artificial Neural Network</strong> (<strong>ANN</strong>). Although personally I do not like the term <em>artificial</em>, we'll use those terms interchangeably throughout this book.</p>
<p>"Let's state that a neural network, in its simplest form, is a system comprising several simple but highly interconnected elements; each processes information based upon their response to external inputs."</p>
<p>Did you know that neural networks are more commonly, but loosely, modeled after the cerebral cortex of a mammalian brain? Why didn't I say that they were modeled after humans? Because there are many instances where biological and computational studies are used from brains from rats, monkeys, and, yes, humans. A large neural network may have hundreds or maybe even thousands of processing units, where as a mammalian brain has billions. It's the neurons that do the magic, and we could in fact write an entire book on that topic alone.</p>
<p>Here's why I say they do all the magic: If I showed you a picture of Halle Berry, you would recognize her right away. You wouldn't have time to analyze things; you would know based upon a lifetime of collected knowledge. Similarly, if I said the word <em>pizza</em> to you, you would have an immediate mental image and possibly even start to get hungry. How did all that happen just like that? Neurons! Even though the neural networks of today continue to gain in power and speed, they pale in comparison to the ultimate neural network of all time, the human brain. There is so much we do not yet know or understand about this neural network; just wait and see what neural networks will become once we do!</p>
<p>Neural networks are organized into <em>layers</em> made up of what are called <strong>nodes</strong> or <strong>neurons</strong>. These nodes are the neurons themselves and are interconnected (throughout this book we use the terms <em>nodes</em> and <em>neurons</em> interchangeably). Information is presented to the input layer, processed by one or more <em>hidden</em> layers, then given to the <em>output</em> layer for final (or continued further) processing—lather, rinse, repeat!</p>
<p><em>But what is a neuron</em>, you ask? Using the following diagram, let's state this:</p>
<p>"A neuron is the basic unit of computation in a neural network"</p>
<p>As I mentioned earlier, a neuron is sometimes also referred to as a node or a unit. It receives input from other nodes or external sources and computes an output. Each input has an associated <strong>weight</strong> (<strong>w1 and w2 below</strong>), which is assigned based on its relative importance to the other inputs. The node applies a function <em>f</em><strong><em> </em></strong>(an activation function, which we will learn more about later on) to the weighted sum of its inputs. Although that is an extreme oversimplification of what a neuron is and what it can do, that's basically it.</p>
<p>Let's look visually at the progression from a single neuron into a very deep learning network. Here is what a single neuron looks like visually based on our description:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-955 image-border" src="img/17f2aad3-9c5c-4751-a9e4-f7316eb26fd9.png" style="width:45.50em;height:20.67em;"/></p>
<p>Next, the following diagram shows a very simple neural network comprised of several neurons:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1215 image-border" src="img/205853db-764e-4b05-8b8b-ef2441ae8e7e.png" style="width:19.75em;height:13.08em;"/></p>
<p>Here is a somewhat more complicated, or deeper, network:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-882 image-border" src="img/798ffc50-fffc-4712-b001-8483da96fd50.png" style="width:28.33em;height:30.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Neural network training</h1>
                
            
            
                
<p>Now that we know what a neural network and neurons are, we should talk about what they do and how they do it. How does a neural network learn? Those of you with children already know the answer to this one. If you want your child to learn what a cat is, what do you do? You show them cats (pictures or real). You want your child to learn what a dog is? Show them dogs. A neural network is conceptually no different. It has a form of <strong>learning rule</strong> that will modify the incoming weights from the input layer, process them through the hidden layers, put them through an activation function, and hopefully will be able to identify, in our case, cats and dogs. And, if done correctly, the cat does not become a dog!</p>
<p>One of the most common learning rules with neural networks is what is known as the <strong>delta rule</strong>. This is a <em>supervised</em> rule that is invoked each time the network is presented with another learning pattern. Each time this happens it is called a <strong>cycle</strong> or <strong>epoch</strong>. The invocation of the rule will happen each time that input pattern goes through one or more <em>forward</em> propagation layers, and then through one or more <em>backward</em> propagation layers.</p>
<p>More simply put, when a neural network is presented with an image it tries to determine what the answer might be. The difference between the correct answer and our guess is the <strong>error </strong>or <strong>error rate</strong>. Our objective is that the error rate gets either minimized or maximized. In the case of minimization, we need the error rate to be as close to 0 as possible for each guess. The closer we are to 0, the closer we are to success.</p>
<p>As we progress, we undertake what is termed a <strong>gradient descent</strong>, meaning we continue along toward what is called the <strong>global minimum</strong>, our lowest possible error, which hopefully is paramount to <em>success</em>. We descend toward the global minimum.</p>
<p>Once the network itself is trained, and you are happy, the training cycle can be put to bed and you can move on to the testing cycle. During the testing cycle, only the forward propagation layer is used. The output of this process results in the <em>model</em> that will be used for further analysis. Again, no back propagation occurs during testing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A visual guide to neural networks</h1>
                
            
            
                
<p>In this section, I could type thousands of words trying to describe all of the combinations of neural networks and what they look like. However, no amount of words would do any better than the diagram that follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-875 image-border" src="img/31b5e961-850a-4227-9931-72415a6f64a7.png" style="width:34.83em;height:52.58em;"/></p>
<p>Reprinted with permission, Copyright Asimov Institute <br/>
Source: http://www.asimovinstitute.org/neural-network-zoo/</p>
<p>Let's talk about a few of the more common networks from the previous diagram:</p>
<ul>
<li><strong>Perceptron: </strong>This is the simplest feed-forward neural network available, and, as you can see, it does not contain any hidden layers:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/02012cca-96c6-4433-9576-4ba50de40e1f.png" style="width:3.00em;height:3.17em;"/></p>
<ul>
<li><strong>Feed-forward network: </strong>This network is perhaps the simplest type of artificial neural network devised. It contains multiple neurons (nodes) arranged in <strong>layers</strong>. Nodes from adjacent layers have <strong>connections</strong> or <strong>edges</strong> between them. Each connection has <strong>weights</strong> associated with them:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/1e13ce5e-a990-4897-a3d5-bb01b4795996.png" style="width:4.08em;height:2.92em;"/></p>
<ul>
<li><strong>Recurrent neural network (RNN): </strong>RNNs are called <em>recurrent</em> because they perform the same task for every element of a sequence, with the output depending on the previous computations. They are also able to look back at previous steps, which form a sort of <strong>short-term memory</strong>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1216 image-border" src="img/82e76013-80f7-4d91-acb5-ffc8d981e4b1.png" style="width:11.08em;height:8.50em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">The role of neural networks in today's enterprises</h1>
                
            
            
                
<p>As developers, our main concern is how can we apply what we are learning to real world scenarios. More concretely, in an enterprise environment, what are the opportunities for using a neural network? Here are just a few ideas (out of many) for applications of a neural network:</p>
<ul>
<li>In a scenario where relationships between variables are not understood</li>
<li>In a scenario where relationships are difficult to describe</li>
<li>In a scenario where the goal is to discover irregular patterns in data</li>
<li>Classify data to recognize patterns such as animals, vehicles, and so on</li>
<li>Signal processing</li>
<li>Image recognition (emotion, sentiment, age, gender, and so on)</li>
<li>Text translation</li>
<li>Handwriting recognition</li>
<li>Autonomous vehicles</li>
<li>And tons more!</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of learning</h1>
                
            
            
                
<p>Since we talked about our neural network learning, let's briefly touch on the three different types of learning you should be aware of. They are <strong>supervised</strong>, <strong>unsupervised</strong>, and <strong>reinforcement</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Supervised learning</h1>
                
            
            
                
<p>If you have a large test dataset that matches up with known results, then supervised learning might be a good choice for you. The neural network will process a dataset; compare its output against the known result, adjust, and repeat. Pretty simple, huh?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unsupervised learning</h1>
                
            
            
                
<p>If you don't have any test data, and it is possible to somehow derive a cost function from the behavior of the data, then unsupervised learning might be a good choice for you. The neural network will process a dataset, use the <kbd>cost</kbd> function to tell how much the error rate is, adjust the parameters, then repeat. All this while working in real time!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reinforcement learning</h1>
                
            
            
                
<p>Our final type of learning is <strong>reinforcement</strong> learning, better known in some circles as <strong>carrot-and-stick</strong>. The neural network will process a dataset, learn from the data, and if our error rate decreases, we get the carrot. If the error rate increases, we get the stick. Enough said, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding perceptrons</h1>
                
            
            
                
<p>The most basic element that we will deal with is called the neuron. If we were to take the most basic form of an activation function that a neuron would use, we would have a function that has only two possible results, 1 and 0. Visually, such a function would be represented like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a35b5c41-1af3-4ea1-ade3-cb43d49df7a1.png"/></p>
<p>This function returns 1 if the input is positive or 0, otherwise it returns 0. A neuron whose activation function is like this is called a <strong>perceptron</strong>. It is the simplest form of neural network we could develop. Visually, it looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f3759083-7ca3-4d33-9172-6d07f3088c51.jpg" style="width:19.50em;height:19.25em;"/></p>
<p>The perceptron follows the feed-forward model, meaning inputs are sent into the neuron, processed, and then produce output. Inputs come in, and output goes out. Let's use an example.</p>
<p>Let's suppose that we have a single perceptron with two inputs as shown previously. For the purposes of this example, input 0 will be x1 and input 1 will be x2. If we assign those two variable values, they will look something like this:</p>
<p><em>Input 0: x1 = 12</em><br/>
<em>Input 1: x2 = 4</em></p>
<p>Each of those inputs must be <strong>weighted</strong>, that is, multiplied by some value, which is often a number between -1 and 1. When we create our perceptron, we begin by assigning them random weights. As an example, Input 0 (<strong>x1</strong>) will have a weight we'll label <strong>w1</strong>, and input 1, <strong>x2 </strong>will have a weight we'll label <strong>w2</strong>. Given this, here's how our weights look for this perceptron:</p>
<p><em>Weight 0: 0.5<br/></em><em>Weight 1: -1</em></p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6833c8ca-216c-493b-8c1f-d9e5433f18cb.png" style="width:33.08em;height:7.00em;"/></p>
<p>Once the inputs are <em>weighted</em>, they now need to be summed. Using the previous example, we would have this:</p>
<p><em>6 + -4 = 2</em></p>
<p>That sum would then be passed through an activation function, which we will cover in much more detail in a later chapter. This would generate the output of the perceptron. The activation function is what will ultimately tell the perceptron whether it is <em>OK to fire</em>, that is, to activate.</p>
<p>Now, for our activation function we will just use a very simple one. If the sum is positive, the output will be 1. If the sum is negative, the output will be -1. It can't get any simpler than that, right?</p>
<p>So, in pseudo code, our algorithm for our single perceptron looks like the following:</p>
<ul>
<li>For every input, multiply that input by its weight</li>
<li>Sum all the weighted inputs</li>
<li>Compute the output of the perceptron based on that sum passed through an activation function (the sign of the sum)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Is this useful?</h1>
                
            
            
                
<p>Yes, in fact it is, and let's show you how. Consider an input vector as the coordinates of a point. For a vector with <em>n</em> elements, the point would like it's in a n-dimensional space. Take a sheet of paper, and on this paper, draw a set of points. Now separate those two points by a single straight line. Your piece of paper should now look something like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8dc93930-0e18-421d-bf82-bcda82021568.png"/></p>
<p>As you can see, the points are now divided into two sets, one set on each side of the line. If we can take a single line and clearly separate all the points, then those two sets are what is known as linearly separable.</p>
<p>Our single perceptron, believe it or not, will be able to learn where this line is, and when your program is complete, the perceptron will also be able to tell whether a single point is above or below the line (or to the left or the right of it, depending upon how the line was drawn).</p>
<p>Let's quickly code a <kbd>Perceptron</kbd> class, just so it becomes clearer for those of you who love to read code more than words (like me!). The goal will be to create a simple perceptron that can determine which side of the line a point should be on, just like the previous diagram:</p>
<div><pre>class Perceptron {<br/><br/>float[] weights;</pre>
<p>The constructor could receive an argument indicating the number of inputs (in this case three: <em>x</em>, <em>y</em>, and a bias) and size the array accordingly:</p>
<pre>Perceptron(int n) {<br/>    weights = new float[n];<br/>    for (int i = 0; i&lt;weights.length; i++) {</pre></div>
<p>The <kbd>weights</kbd> are picked randomly to start with:</p>
<pre>      weights[i] = random(-1,1);<br/>    }<br/>}</pre>
<p>Next, we'll need a function for the perceptron to receive its information, which will be the same length as the array of weights, and then return the output value to us. We'll call this <kbd>feedforward</kbd>:</p>
<pre>int feedforward(float[] inputs) {<br/>    float sum = 0;<br/>    for (int i = 0; i&lt;weights.length; i++) {<br/>      sum += inputs[i]*weights[i];<br/>    }</pre>
<p>The result is the sign of the sum, which will be either -1 or +1. In this case, the perceptron is attempting to guess which side of the line the output should be on:</p>
<pre> return activate(sum);<br/> }</pre>
<p>Thus far, we have a minimally functional perceptron that should be able to make an educated guess as to where our point will lie.</p>
<p>Create the <kbd>Perceptron</kbd>:</p>
<pre>Perceptron p = new Perceptron(3);</pre>
<p>The input is 3 values: <em>x</em>, <em>y,</em> and bias:</p>
<pre>float[] point = {5,-2,19};</pre>
<p>Obtain the answer:</p>
<pre>int result = p.feedforward(point);</pre>
<p>The only thing left that will make our perceptron more valuable is the ability to train it rather than have it make educated guesses. We do that by creating a <kbd>train</kbd> function such as this:</p>
<ol>
<li>We will introduce a new variable to control the learning rate:</li>
</ol>
<pre style="padding-left: 60px">float c = 0.01;</pre>
<ol start="2">
<li>We will also provide the inputs and the known answer:</li>
</ol>
<div><pre style="padding-left: 60px">void train(float[] inputs, int desired) {</pre></div>
<ol start="3">
<li>And we will make an educated guess according to the inputs provided:</li>
</ol>
<pre style="padding-left: 60px">  int guess = feedforward(inputs);</pre>
<ol start="4">
<li>We will compute the <kbd>error</kbd>, which is the difference between the answer and our <kbd>guess</kbd>:</li>
</ol>
<pre style="padding-left: 60px">float error = desired - guess;</pre>
<ol start="5">
<li>And, finally, we will adjust all the weights according to the error and learning constant:</li>
</ol>
<pre style="padding-left: 60px">  for (int i = 0; i&lt;weights.length; i++) {<br/>    weights[i] += c * error * inputs[i];</pre>
<p>So, now that you know and see what a perceptron is, let's add <strong>activation functions</strong> into the mix and take it to the next level!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding activation functions</h1>
                
            
            
                
<p>An activation function is added to the output end of a neural network to determine the output. It usually will map the resultant values somewhere in the range of -1 to 1, depending upon the function. It is ultimately used to determine whether a neuron will <em>fire</em> or <em>activate</em>, as in a light bulb going on or off.</p>
<p>The activation function is the last piece of the network before the output and could be considered the supplier of the output value. There are many kinds of activation function that can be used, and this diagram highlights just a very small subset of these:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-883 image-border" src="img/85e2b8c7-018e-461c-86e0-c1af7841571a.png" style="width:37.33em;height:27.33em;"/></p>
<p>There are two types of activation function—linear and non-linear:</p>
<ul>
<li><strong>Linear</strong>: A linear function is that which is on, or nearly on, a straight line, as depicted here:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-884 image-border" src="img/60046c81-0304-41ac-bc10-5a676f67c74d.png" style="width:35.33em;height:22.00em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Non-linear</strong>: A non-linear function is that which is not on a straight line, as depicted here:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/1062fee4-b892-410a-935b-703e01f01fab.png" style="width:39.08em;height:22.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Visual activation function plotting</h1>
                
            
            
                
<p>When dealing with activation functions, it is important that you visually understand what an activation function looks like before you use it. We are going to plot, and then benchmark, several activation functions for you to see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/dc5b93de-a4c2-42b4-956a-dd8cf395b292.png" style="width:24.83em;height:30.50em;"/></p>
<p>This is what the logistic steep approximation and Swish activation function look like when they are plotted individually. As there are many types of activation function, the following shows what all our activation functions are going to look like when they are plotted together:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1217 image-border" src="img/7fea069a-7185-4cfb-89f5-e4e4c66ff234.png" style="width:50.08em;height:30.92em;"/></p>
<p>Note: You can download the program that produces the previous output from the SharpNeat project on GitHub <a href="https://github.com/colgreen/sharpneat">https://github.com/colgreen/sharpneat</a>.</p>
<p>At this point, you may be wondering why we even care what the plots look like—great point. We care because you are going to be using these quite a bit once you progress to hands-on experience, as you dive deeper into neural networks. It's very handy to be able to know whether your activation function will place the value of your neuron in the on or off state, and what range it will keep or need the values in. You will no doubt encounter and/or use activation functions in your career as a machine-learning developer, and knowing the difference between a Tanh and a LeakyRelu activation function is very important.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function plotting</h1>
                
            
            
                
<p>For this example, we are going to use the open source package <strong>SharpNeat</strong>. It is one of the most powerful machine- learning platforms anywhere, and it has a special activation function plotter included with it. You can find the latest version of SharpNeat at <a href="https://github.com/colgreen/sharpneat">https://github.com/colgreen/sharpneat</a>. For this example, we will use the <strong><em>ActivationFunctionViewer</em></strong> project included as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-885 image-border" src="img/085edbec-9d2a-4552-ace2-052114a39b80.png" style="width:51.25em;height:29.75em;"/></p>
<p>Once you have that project open, search for the <kbd>PlotAllFunctions</kbd> function. It is this function that handles the plotting of all the activation functions as previously shown. Let's go over this function in detail:</p>
<pre class="mce-root">private void PlotAllFunctions()<br/>{<br/>    Clear everything out.<br/>    MasterPane master = zed.MasterPane;<br/>    master.PaneList.Clear();<br/>    master.Title.IsVisible = true;<br/>    master.Margin.All = 10;<br/><br/>    Here is the section that will plot each individual function.<br/>    PlotOnMasterPane(Functions.LogisticApproximantSteep, "Logistic <br/>    Steep (Approximant)");<br/><br/>    PlotOnMasterPane(Functions.LogisticFunctionSteep, "Logistic Steep <br/>    (Function)");<br/><br/>    PlotOnMasterPane(Functions.SoftSign, "Soft Sign");<br/><br/>    PlotOnMasterPane(Functions.PolynomialApproximant, "Polynomial <br/>    Approximant");<br/><br/>    PlotOnMasterPane(Functions.QuadraticSigmoid, "Quadratic Sigmoid");<br/><br/>    PlotOnMasterPane(Functions.ReLU, "ReLU");<br/><br/>    PlotOnMasterPane(Functions.LeakyReLU, "Leaky ReLU");<br/><br/>    PlotOnMasterPane(Functions.LeakyReLUShifted, "Leaky ReLU <br/>    (Shifted)");<br/><br/>    PlotOnMasterPane(Functions.SReLU, "S-Shaped ReLU");<br/><br/>    PlotOnMasterPane(Functions.SReLUShifted, "S-Shaped ReLU <br/>    (Shifted)");<br/><br/>    PlotOnMasterPane(Functions.ArcTan, "ArcTan");<br/><br/>    PlotOnMasterPane(Functions.TanH, "TanH");<br/><br/>    PlotOnMasterPane(Functions.ArcSinH, "ArcSinH");<br/><br/>    PlotOnMasterPane(Functions.ScaledELU, "Scaled Exponential Linear <br/>    Unit");<br/><br/>    Reconfigure the Axis<br/>    zed.AxisChange();<br/><br/>    Layout the graph panes using a default layout<br/>    using (Graphics g = this.CreateGraphics()) <br/>    {<br/>        master.SetLayout(g, PaneLayout.SquareColPreferred);<br/>    }<br/><br/>    MainPlot Function<br/><br/>    Behind the scenes, the ‘Plot' function is what is responsible for <br/>    executing     and plotting each function.<br/><br/>    private void Plot(Func&lt;double, double&gt; fn, string fnName, Color <br/>    graphColor, GraphPane gpane = null)<br/>    {<br/>        const double xmin = -2.0;<br/>        const double xmax = 2.0;<br/>        const int resolution = 2000;<br/>        zed.IsShowPointValues = true;<br/>        zed.PointValueFormat = "e";<br/><br/>        var pane = gpane ?? zed.GraphPane;<br/>        pane.XAxis.MajorGrid.IsVisible = true;<br/>        pane.YAxis.MajorGrid.IsVisible = true;<br/>        pane.Title.Text = fnName;<br/>        pane.YAxis.Title.Text = string.Empty;<br/>        pane.XAxis.Title.Text = string.Empty;<br/>        <br/>        double[] xarr = new double[resolution];<br/>        double[] yarr = new double[resolution];<br/>        double incr = (xmax - xmin) / resolution;<br/>        doublex = xmin;<br/><br/>        for(int i=0; i&lt;resolution; i++, x += incr)<br/>        {<br/>            xarr[i] = x;<br/>            yarr[i] = fn(x);<br/>        }<br/><br/>        PointPairList list1 = new PointPairList(xarr, yarr);<br/>        LineItem li = pane.AddCurve(string.Empty, list1, graphColor, <br/>        SymbolType.None);<br/>        li.Symbol.Fill = new Fill(Color.White);<br/>        pane.Chart.Fill = new Fill(Color.White, <br/>        Color.LightGoldenrodYellow, 45.0F);<br/>}</pre>
<p>The main point of interest from the earlier code is highlighted in yellow. This is where the activation function that we passed in gets executed and its value used for the <em>y</em> axis plot value. The famous <strong>ZedGraph</strong> open source plotting package is used for all graph plotting. Once each function is executed, the respective plot will be made.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding back propagation</h1>
                
            
            
                
<p><strong>Back propagation</strong>, which is short for <strong>the backward propagation of errors</strong>, is an algorithm for supervised learning of neural networks using gradient descent. This calculates what is known as <strong>the gradient of the error</strong> function, with respect to the network's weights. It is a generalized form of the delta rule for perceptrons all the way to multi-layer feed-forward neural networks.</p>
<p>Unlike forward propagation, back-prop calculates the gradients by moving backwards through the network. The gradient of the final layer of weights is calculated first, and the gradient of the first layer is hence calculated last. With the recent popularity in deep learning for image and speech recognition, back-prop has once again taken the spotlight. It is, for all intents and purposes, an efficient algorithm, and today's version utilizes GPUs to further improve performance.</p>
<p>Lastly, because the computations for back-prop are dependent upon the activations and outputs from the forward phase (non-error term for all layers, including hidden), all of these values must be computed prior to the backwards phase beginning. It is therefore a requirement that the forward phase precede the backward phase for every iteration of gradient descent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Forward and back propagation differences</h1>
                
            
            
                
<p>Let's take a moment to clarify the difference between feed forward and back propagation. Once you understand this, you can visualize and understand much better how the entire neural network flows.</p>
<p>In neural networks, you forward-propagate data to get the output and then compare it with the real intended value to get the error, which is the difference between what the data is suppose to be versus what your machine-learning algorithm actually thinks it is. To minimize that error, you now must <em>propagate</em> backward by finding the derivative of error, with respect to each weight, and then subtract this value from the weight itself.</p>
<p>The basic learning that is being done in a neural network is training neurons <em>when</em> to get activated, when to fire, and when to be <em>on</em> or <em>off</em>. Each neuron should activate only for certain types of inputs, not all of them. Therefore, by propagating forward, you see how well your neural network is behaving and find the error(s). After you find out what your network error rate is, you back-propagate and use a form of gradient descent to update new values of the weights. Once again, you will forward-propagate your data to see how well those weights are performing, and then backward-propagate the data to update the weights. This will go on until you reach some minima for error value (hopefully the global minimum and not the local). Again, lather, rinse, repeat!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we took a brief overview of various neural network terminologies. We reviewed perceptrons, neurons, and back propagation, among other things. In our next chapter, we are going to dive right into coding a complete neural network!</p>
<p>We will cover such topics as neural network training, terminology, synapses, neurons, forward propagation, back propagation, sigmoid function, back propagation, and error calculations.</p>
<p>So, hold onto your hats; the code is coming!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">References</h1>
                
            
            
                
<ul>
<li> @EVOLVE deep-learning shared information neural network framework, copyright 2016 Matt R Cole, <a href="http://www.evolvedaisolutions.com">www.evolvedaisolutions.com</a>.</li>
<li>SharpNeat Activation Functions/Viewer: SharpNeat (<a href="https://github.com/colgreen/sharpneat">https://github.com/colgreen/sharpneat</a>).</li>
</ul>


            

            
        
    </body></html>