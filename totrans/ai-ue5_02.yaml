- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing the Unreal Engine AI System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the exciting world of AI programming with Unreal Engine! In this
    chapter, I’ll be introducing you to Unreal Engine’s powerful tools that will bring
    life and intelligence to your virtual worlds. By exploring various aspects of
    the Unreal Engine AI system, such as moving agents using the **Navigation System**
    , implementing semi-intelligent behaviors through **behavior trees** and **Blackboards**
    , and incorporating features such as smart objects and **mass entities** , you
    will gain a comprehensive understanding of the remarkable capabilities offered
    by this robust framework.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering these skills will elevate you to the ranks of elite game programmers
    – and who wouldn’t want to be one of those?
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a sharp vision of what can be accomplished
    using the Unreal Engine AI system, empowering you to create advanced AI pawns
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Unreal Engine Gameplay Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting the Unreal Engine AI system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding advanced AI features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no technical requirements to follow for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Unreal Engine Gameplay Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may already know, Unreal Engine provides an out-of-the-box system called
    **Gameplay Framework** ( **GF** ) that includes many features necessary for developing
    a game; this spans from having an advanced input system to common entry points
    that will allow you to easily access data or game state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points explaining why the GF is so important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure and organization** : The GF provides a structured and organized
    approach to developing games. It offers a collection of systems, classes, and
    interfaces that work together to create the core structure of a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game logic and progression** : This framework includes predefined concepts
    that help define the logic, progression, and organization of a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player and AI control** : The GF includes systems for handling player input
    and decision-making for characters within the game world. This encompasses player
    and AI control, which are essential for creating interactive and immersive gaming
    experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility functions** : The framework provides a library of utility functions
    that assist with common gameplay operations and interactions. These functions
    can streamline gameplay logic and enhance efficiency in implementing various functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility and integration** : The GF is highly flexible and integrates
    deeply with the Unreal Engine. It uses common game programming patterns and performs
    heavy lifting, allowing developers to focus on building their games rather than
    creating their own game framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a personal reflection, I have found that using and comprehending the GF over
    the years has significantly enhanced my overall understanding of game programming
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Quite obviously, managing an AI system is also part of the GF job, so, in the
    next subsections, I will provide you with a concise introduction to the key AI
    features available in the GF, enabling you to be prepared for their use.
  prefs: []
  type: TYPE_NORMAL
- en: Actors and components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m pretty sure you’re already familiar with **actors** and **components** in
    Unreal Engine, but just in case, let’s do a quick refresher on both of them.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, an **Actor** class refers to any entity that can be placed
    within a level, whether it’s a camera, a static mesh, or the player’s character.
    An actor can undergo transformations such as translation, rotation, and scaling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors serve as containers for specialized classes known as **components**
    that play various roles in controlling a movement, rendering, and more. There
    are three types of components that serve different purposes within an actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actor components** : These primarily contain code logic for an actor. They
    handle various functionalities and interactions without any visual representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scene components** : These are used to position and orient other components
    within the actor. They serve as reference points for transformations such as translation,
    rotation, and scaling but do not have any visible presence and are mainly used
    for organizational purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primitive components** : These are responsible for the visual representation
    of an actor within a level. They can be rendered and interacted with by players
    or other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining these components, a game developer can create complex and interactive
    actors with both functional and visual aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Main GF elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Unreal Engine GF is a comprehensive collection of classes that serves as
    a modular foundation for constructing gameplay experiences. Within this framework,
    game developers have the freedom to handpick specific elements that best suit
    the game, while being assured that these classes are intricately designed to seamlessly
    work together and enhance one another.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming subsections, we will present the main elements involved to have
    a clear view of how things work.
  prefs: []
  type: TYPE_NORMAL
- en: GameInstance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **GameInstance** class serves as a manager that operates behind the scenes
    (i.e., it is not an Unreal Engine actor); a single instance is created when the
    engine launches and the instance remains active until the engine shuts down. Its
    primary purpose is to track data and execute code as needed.
  prefs: []
  type: TYPE_NORMAL
- en: A game instance provides a handy central hub for managing persistent data, such
    as save game systems, and acts as a manager for other subsystems, offering convenient
    control over the flow of your game.
  prefs: []
  type: TYPE_NORMAL
- en: GameMode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different from the **GameInstance** class, the **GameModeBase** or its direct
    descendant, **GameMode** , instance only exists in a single level and is created
    right after the level itself has been loaded and the world has been constructed.
    This class serves as a manager to handle a gameplay session, and each level can
    have its own different game mode logic. Its main role is to create the remaining
    framework actors.
  prefs: []
  type: TYPE_NORMAL
- en: GameState and PlayerState
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**GameState** and **PlayerState** are specialized actors that play a key role
    in tracking the state of the game and the players involved. The game state is
    responsible for storing and handling data pertinent to all players in a game,
    while the player state focuses on a specific player. Given their inherent characteristics,
    these classes find their primary application in multiplayer games, regardless
    of whether they are played online or locally.'
  prefs: []
  type: TYPE_NORMAL
- en: Pawn and Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **pawn** refers to the base class of all actors that can be controlled by
    players or AI entities within the game world. It serves as the physical representation
    of an entity, handling its involvement within the game world, including collisions
    and other physical interactions. It is also usually used to determine the visual
    appearance of an entity.
  prefs: []
  type: TYPE_NORMAL
- en: The **Pawn** class gains additional functionality through the more advanced
    **Character** class. The character class is specifically designed to represent
    players in a vertically oriented manner, enabling them to perform a wide range
    of actions such as walking, running, jumping, and swimming within a level. As
    a side note, the character class incorporates essential features for multiplayer
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Controller** class is responsible for governing the logic that determines
    a player’s actions within the game world. Two widely used types of controller
    classes are **PlayerController** and **AIController** ; the second option is something
    we eagerly anticipate, for obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The player controller class acts as a managerial entity, capable of processing
    input from a human player, enabling interaction with the game environment and
    facilitating their overall gameplay experience. On the other hand, the AI controller
    governs the actions of an AI entity by using behavior trees, state trees, navigation,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: The player controller and the AI controller classes can manage a character or
    a pawn by possessing them at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: GameplayStatics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unreal Engine provides a really helpful function library called **GameplayStatics**
    , which provides various utility functions for gameplay-related tasks. These functions
    can be used to perform common gameplay operations and interactions within the
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of these functions are spawning and destroying actors, retrieving
    information about the game world, managing gameplay tags, manipulating game instances,
    and more. These functions can be accessed and used from both Blueprint visual
    scripting and C++ programming and can streamline gameplay logic and serve as a
    valuable tool for managing and manipulating game elements during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I have dished out some Unreal Engine GF knowledge, get ready for the
    juiciest part (at least in the context of this book): how AI dives into the intricate
    workings of the engine, equipping you with the knowledge to embark on the marvelous
    journey of crafting your own game logics!'
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the Unreal Engine AI system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the power of the previously described framework at your disposal, it should
    come as no surprise that Unreal Engine provides a comprehensive and robust AI
    system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will show the comprehensive array of tools available for
    Unreal Engine AI programmers along with a short description of their main features.
    To begin, let us examine the Navigation System and its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Unreal Engine **Navigation System** allows for AI entities, called **agents**
    , to move on a level by using pathfinding algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The Navigation System will create a **nav mesh** derived from the geometry present
    within the level by using collisions. This mesh is subsequently divided into tiles,
    which are further partitioned into polygons, thereby forming a graph. Agents within
    the system use this graph to navigate toward their intended destinations. Polygons
    have a designated cost, which helps agents determine the most optimal path based
    on the lowest overall cost. Also, the Navigation System includes a range of components
    and settings that can be adjusted to modify the nav mesh generation process. These
    modifications can include alterations to the costs of polygons, influencing the
    navigation behavior of agents within the level. Finally, the system allows for
    the connection of non-contiguous areas within the nav mesh, such as platforms
    and bridges, thereby facilitating seamless navigation across these spatial elements.
    *Figure 2* *.1* shows a level available in the **Content Examples** project freely
    available on the Epic Games Launcher; the green area is the nav mesh and the character
    on the left is the AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Navigation System](img/B31016_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Navigation System
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 2* of this book will be devoted to understanding the Unreal Navigation
    System and how to optimize and debug it.'
  prefs: []
  type: TYPE_NORMAL
- en: Behavior trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unreal Engine, behavior trees serve as a valuable tool for creating AI for
    NPCs in your games. The primary function of a behavior tree asset is to execute
    branches containing logical instructions. In Unreal Engine, behavior trees are
    created in a pretty similar way to Blueprints – this means you will be using some
    kind of visual scripting method – where a sequence of nodes with specific functionality
    attached to them is added and connected to form a behavior tree graph.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2* *.2* depicts a portion of a behavior tree from the **Lyra Starter
    Game** project available on the Epic Games Launcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Behavior tree example](img/B31016_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Behavior tree example
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine which branches should be executed, the behavior tree relies on
    another asset known as a Blackboard, which acts as the *brain* for the behavior
    tree itself. *Figure 2* *.3* shows the Blackboard corresponding to the previous
    behavior tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Blackboard example](img/B31016_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Blackboard example
  prefs: []
  type: TYPE_NORMAL
- en: Behavior trees and Blackboards are pretty important in AI game programming;
    that’s why I have dedicated *Part 3* of this book to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Mass Entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Mass Entity** system is a gameplay-focused framework for data-oriented
    calculations and provides a paradigm for staging elements with behavior in the
    game; it is designed to handle large numbers of **entities** and facilitate behavior
    controls for both skeletal and static meshes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2* *.4* shows a screenshot from the **City Sample** project – available
    on the Epic Games Launcher – that makes use of Mass Entity for both crowd and
    traffic control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Mass Entity in action](img/B31016_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Mass Entity in action
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Mass Entity is still marked as experimental;
    consequently, it should be used cautiously as things may break or change as time
    goes by.
  prefs: []
  type: TYPE_NORMAL
- en: Mass Entity will be presented in *Part 4* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: State tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **state tree** is a versatile hierarchical state machine that integrates
    some features from behavior trees with some others from state machines. With this
    system – organized in a tree structure – developers will be able to create highly
    performant logic that remains structured and adaptable. *Figure 2* *.5* shows
    a state tree from the aforementioned **City** **Sample** project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – State tree example](img/B31016_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – State tree example
  prefs: []
  type: TYPE_NORMAL
- en: I’ll be showing you how state trees work in *Part 4* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Smart objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Unreal Engine, **smart objects** represent a set of activities in the level
    that can be used through a reservation system that ensures that only one AI agent
    can use a smart object at a time, preventing other agents from using it until
    it becomes available again. These objects are placed on a level and can be interacted
    with by AI agents and players. Smart objects contain all the information needed
    for these interactions and can be queried at runtime using dedicated filters.
    *Figure 2* *.6* shows a smart object asset from the **City** **Sample** project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Smart object example](img/B31016_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Smart object example
  prefs: []
  type: TYPE_NORMAL
- en: Smart objects will be presented in *Part 4* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Environment Query System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Environment Query System** ( **EQS** ) collects data from the environment,
    enabling AIs to inquire about the data using various tests. This process results
    in selecting an item that best matches the question posed.
  prefs: []
  type: TYPE_NORMAL
- en: Queries can be called from a behavior tree and used to make decisions on how
    to proceed based on the results of the executed tests. *Figure 2* *.7* depicts
    an environment query from the **Lyra Starter** **Game** project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – An environment query example](img/B31016_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – An environment query example
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the EQS is still marked as experimental so
    you should use it cautiously as things may break or change as development goes
    on.
  prefs: []
  type: TYPE_NORMAL
- en: I will be presenting you EQS by the end of *Part 4* of this book, just after
    you have gained a solid understanding of how behavior trees work.
  prefs: []
  type: TYPE_NORMAL
- en: AI Perception System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **AI Perception System** provides another way for pawns to receive data
    from the environment, such as where noises are coming from or if the AI sees something.
    It allows for the generation of awareness for AI by providing sensory data for
    it. The system allows data sources to create stimuli so that data listeners can
    be periodically updated about them. This system is used to enable AI sensing within
    games and can react to an array of customizable sensors.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2* *.8* shows a character from the **Lyra Starter Game** with a stimuli
    source component attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – AI perception example](img/B31016_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – AI perception example
  prefs: []
  type: TYPE_NORMAL
- en: AI Perception will be presented along with behavior trees in *Part 4* of this
    book to make your AI characters aware of their surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: AI debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No serious framework would be complete without a debugging system. **Debugging**
    is an essential aspect of software development, allowing developers to identify
    and fix errors or bugs in their code. It plays a crucial role in ensuring the
    reliability and functionality of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why Unreal Engine offers a full arsenal of tools and features to assist
    developers in debugging AI, including visual debugging tools, behavior tree visualization,
    and AI simulation modes. These tools allow developers to inspect and modify AI
    behavior in real time, identify issues such as pathfinding errors or erratic decision-making,
    and make necessary adjustments to improve the overall AI performance within the
    game environment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2* *.9* shows the **City Sample** project in action with the AI debugging
    tools enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – The debugging tools enabled in a level](img/B31016_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – The debugging tools enabled in a level
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, I will be showing different techniques for debugging your
    game, depending on the tools you will be using. These techniques will empower
    you to efficiently track down and address bugs, errors, and other issues within
    your game’s code logic.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I showed you the main AI features available in the Unreal Engine
    GF; in the following section, I will present some of the latest technologies that
    have been implemented in the engine involving **machine learning** ( **ML** )
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding advanced AI features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of the main AI features available in
    Unreal Engine, I’d like to present to you some of the most experimental and, to
    some extent, non-gameplay-related features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that these features are still in experimental or beta release,
    so they need to be handled with care.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Learning Agents** is an experimental plugin designed specifically to enable
    you to train AI characters using ML. This plugin offers a unique opportunity to
    enhance or even replace traditional game AI systems, such as behavior trees or
    state machines. With learning agents, you can leverage reinforcement learning
    and imitation learning approaches to create intelligent and adaptive AI characters.'
  prefs: []
  type: TYPE_NORMAL
- en: The primary goal of this plugin is to provide a robust solution for character
    decision-making in Unreal Engine. However, its potential applications extend beyond
    game development. As an example, Learning Agents can be used to automate testing
    processes by creating AI characters that perform specific actions and scenarios
    repeatedly. This helps identify potential issues and ensures the robustness of
    your game.
  prefs: []
  type: TYPE_NORMAL
- en: Although still in development, this is an impressive plugin, and you should
    expect more and more improvements as time goes by.
  prefs: []
  type: TYPE_NORMAL
- en: Neural network engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **neural network engine** ( **NNE** ) plugin provides developers with an
    API that allows unified access to different neural network inference engines.
    This enables programmers to seamlessly switch between inference runtimes as needed,
    optimizing their use case and targeting specific platforms effectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with the Unreal Engine **Rendering Hardware Interface**
    ( **RHI** ), you can think about the NNE as similar; it is a tool whose main purpose
    is to abstract from different inference runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: ML Deformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **ML Deformer** is a plugin that provides an API for accessing different
    implementations of ML inference runtimes, allowing developers to approximate complex
    deformation models and improve the quality of characters’ mesh deformations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ML Deformer is specifically designed for creating accurate non-linear deformer
    systems for characters in real-time game engines. It leverages some inner Unreal
    Engine tools to perform computations on the GPU, optimizing performance. A sample
    project – called **ML Sample Project** – is available on the Unreal Engine marketplace
    and the results are pretty amazing; *Figure 2* *.10* shows a lighting test made
    by my fellow teacher, Giovanni Visai, starting from the aforementioned sample
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – The ML Deformer plugin in action](img/B31016_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – The ML Deformer plugin in action
  prefs: []
  type: TYPE_NORMAL
- en: ML cloth simulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **ML cloth simulation** system offers developers a high-fidelity and highly
    performant solution for real-time cloth simulation. This system excels in producing
    clothing meshes of comparable quality to pre-simulated data while maintaining
    fast and efficient performance with minimal memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the integration of ML capabilities in Unreal Engine opens up
    a world of possibilities for developers. By leveraging these technologies, developers
    will be able to create more immersive, intelligent, and dynamic experiences within
    their projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I introduced you to the key features available in the Unreal
    Engine GF. After that, I provided an overview of the main AI systems, beginning
    with the Navigation System and progressing to behavior trees. Additionally, I
    discussed more advanced systems such as Mass Entity and state trees. Finally,
    I introduced you to experimental features such as the Learning Agents and NNE
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve reached the end of *Part 1* of this book. In the upcoming
    chapter, get ready to take a deep dive into the Navigation System and how to create
    basic AI characters that will navigate through it. So, get ready to roll up your
    sleeves, and let’s start creating something amazing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Understanding the Navigation System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the second part of this book, you will delve into the essential features
    of Unreal Engine’s Navigation System. From there, you will create your own project
    and learn how to implement a fully working environment that is navigable by AI
    agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B31016_03.xhtml#_idTextAnchor058) , *Presenting the Unreal Engine
    Navigation System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B31016_04.xhtml#_idTextAnchor073) , *Setting Up a Navigation
    Mesh*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B31016_05.xhtml#_idTextAnchor099) , *Improving Agent Navigation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B31016_06.xhtml#_idTextAnchor116) , *Optimizing the Navigation
    System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
