["```py\n    pi@myrobot:~ $ python3\n    Python 3.7.3 (default, Dec 20 2019, 18:57:59) \n    [GCC 8.3.0] on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> \n    ```", "```py\n    >>> import robot\n    ```", "```py\n    >>> r = robot.Robot()\n    ```", "```py\n    >>> r.set_pan(0)\n    ```", "```py\n    >>> r.set_tilt(90)\n    ```", "```py\n    $ raspistill -o line1.jpg\n    ```", "```py\n    import cv2\n    import numpy as np\n    from matplotlib import pyplot as plt\n    ```", "```py\n    line1.jpg and is in the same directory that we will run this file from.\n    ```", "```py\n    resized = cv2.resize(image, (320, 240))\n    ```", "```py\n    gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)\n    ```", "```py\n    int32 with a sign (plus or minus) so that our differences can be negative.\n    ```", "```py\n    diff = np.diff(row)\n    ```", "```py\n    x = np.arange(len(diff))\n    ```", "```py\n    not_blurred. This is because we've not added the optional blurring step. With the graph, we'll be able to see the difference. \n    ```", "```py\n    gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)\n    blurred = cv2.blur(gray, (5, 5))\n    row = blurred[180].astype(np.int32)\n    diff = np.diff(row)\n    ```", "```py\n    plt.savefig(\"blurred.png\")\n    ```", "```py\n    diff = np.diff(row)\n    min_d and max_d, abbreviating the difference as d. Note that they cannot be called min and max as those names already belong to Python.\n    ```", "```py\n    where function returns an array of answers for each dimension – so, although diff is a one-dimensional array, we will still get a list of lists. The first [0] selects this first dimension's results list, and the second [0] selects the first item in the results. Multiple results mean it's found more than one peak, but we assume that there's only one for now.\n    ```", "```py\n    middle = (highest + lowest) // 2\n    ```", "```py\n    max_d and min_d for the Y coordinates, so the line draws from the highest peak to the lowest. The r- style specifier means to draw a solid red line.\n    ```", "```py\n    plt.plot([lowest, lowest], [max_d, min_d], \"g--\")\n    plt.plot([highest, highest], [max_d, min_d], \"g--\")\n    ```", "```py\n    plt.savefig(\"located_lines.png\")\n    ```", "```py\n        def handle_integral(self, error, delta_time):\n    ```", "```py\n                self.integral_sum += error * delta_time\n    ```", "```py\n        def get_value(self, error, delta_time=1):\n    ```", "```py\n            p = self.handle_proportional(error)\n            i = self.handle_integral(error, delta_time)\n            logger.debug(f\"P: {p}, I: {i:.2f}\")\n            return p + i\n    ```", "```py\n    import time\n    from image_app_core import start_server_process, get_control_instruction, put_output_image\n    import cv2\n    import numpy as np\n    import camera_stream\n    from pid_controller import PIController\n    from robot import Robot\n    ```", "```py\n    class LineFollowingBehavior:\n        def __init__(self, robot):\n            self.robot = robot\n    ```", "```py\n            self.check_row = 180\n            self.diff_threshold = 10\n    ```", "```py\n            self.center = 160\n            self.running = False\n            self.speed = 60\n    ```", "```py\n            self.crosshair_color = [0, 255, 0]\n            self.line_middle_color = [128, 128, 255]\n            self.graph_color = [255, 128, 128]\n    ```", "```py\n        def process_control(self):\n            instruction = get_control_instruction()\n            if instruction:\n                command = instruction['command']\n                if command == \"start\":\n                    self.running = True\n                elif command == \"stop\":\n                    self.running = False\n                if command == \"exit\":\n                    print(\"Stopping\")\n                    exit()\n    ```", "```py\n        def run(self):\n            self.robot.set_pan(0)\n            self.robot.set_tilt(90)\n            camera = camera_stream.setup_camera()\n    ```", "```py\n            direction_pid = PIController( proportional_constant=0.4, integral_constant=0.01, windup_limit=400)\n    ```", "```py\n            time.sleep(1)\n            self.robot.servos.stop_all()\n            print(\"Setup Complete\")\n    ```", "```py\n            last_time = time.time()\n    ```", "```py\n            for frame in camera_stream.start_stream(camera):\n                x, magnitude = self.process_frame(frame)\n                self.process_control()\n    ```", "```py\n                if self.running and magnitude > self.diff_threshold:\n    ```", "```py\n    dt. This error and time delta are fed to the PID, getting a new value. So, we are ready for the next calculation: last_time now gets the new_time value.\n    ```", "```py\n                    print(f\"Error: {direction_error}, Value:{direction_value:2f}, t: {new_time}\")\n                    self.robot.set_left(self.speed - direction_value)\n                    self.robot.set_right(self.speed + direction_value)\n    ```", "```py\n                else:\n                    self.robot.stop_motors()\n                    if not self.running:\n                        direction_pid.reset()\n                    last_time = time.time()\n    ```", "```py\n        def process_frame(self, frame):\n            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n            blur = cv2.blur(gray, (5, 5))\n            row = blur[self.check_row].astype(np.int32)\n            diff = np.diff(row)\n            max_d = np.amax(diff, 0)\n            min_d = np.amin(diff, 0)\n    ```", "```py\n            if max_d < 0 or min_d > 0:\n                return 0, 0\n    ```", "```py\n            highest = np.where(diff == max_d)[0][0]\n            lowest = np.where(diff == min_d)[0][0]\n            middle = (highest + lowest) // 2\n    ```", "```py\n            mag = max_d - min_d\n    ```", "```py\n            self.make_display(frame, middle, lowest, highest, diff)\n    ```", "```py\n            return middle, mag\n    ```", "```py\n    frame, the middle position for the line, the lowest difference position in the line, the highest difference position, and diff as the whole difference row.\n    ```", "```py\n            cv2.line(frame, (self.center - 4, self.check_row), (self.center + 4, self.check_row), self.crosshair_color)\n            cv2.line(frame, (self.center, self.check_row - 4), (self.center, self.check_row + 4), self.crosshair_color)\n    ```", "```py\n            cv2.line(frame, (middle, self.check_row - 8), (middle, self.check_row + 8), self.line_middle_color)\n    ```", "```py\n            cv2.line(frame, (lowest, self.check_row - 4), (lowest, self.check_row + 4), self.line_middle_color)\n            cv2.line(frame, (highest, self.check_row - 4), (highest, self.check_row + 4), self.line_middle_color)\n    ```", "```py\n            graph_frame = np.zeros((camera_stream.size[1], camera_stream.size[0], 3), np.uint8)\n    ```", "```py\n            self.make_cv2_simple_graph(graph_frame, diff)\n    ```", "```py\n            display_frame = np.concatenate((frame, graph_frame), axis=1)\n    ```", "```py\n            encoded_bytes = camera_stream.get_encoded_bytes_for_frame(display_frame)\n            put_output_image(encoded_bytes)\n    ```", "```py\n        def make_cv2_simple_graph(self, frame, data):\n    ```", "```py\n            last = data[0]\n            graph_middle = 100\n    ```", "```py\n            for x, item in enumerate(data):\n    ```", "```py\n                cv2.line(frame, (x, last + graph_middle), (x + 1, item + graph_middle), self.graph_color)\n    ```", "```py\n                last = item\n    ```", "```py\n    color_track_behavior.html template here.\n    ```", "```py\n                else:\n                    self.robot.stop_motors()\n    running is false, we now set running to False every time. We also reset the PID every time.\n    ```"]