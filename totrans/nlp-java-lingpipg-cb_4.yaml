- en: Chapter 4. Tagging Words and Tokens
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 标注单词和标记
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Interesting phrase detection
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有趣短语检测
- en: Foreground- or background-driven interesting phrase detection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前景或背景驱动的有趣短语检测
- en: Hidden Markov Models (HMM) – part-of-speech
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏马尔可夫模型 (HMM) – 词性标注
- en: N-best word tagging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: N-best 单词标注
- en: Confidence-based tagging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于置信度的标注
- en: Training word tagging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练单词标注
- en: Word-tagging evaluation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词标注评估
- en: Conditional random fields (CRF) for word/token tagging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件随机场 (CRF) 用于词/标记标注
- en: Modifying CRFs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 CRF
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Words and tokens are the focus of this chapter. The more common extraction technologies,
    such as named entity recognition, are actually encoded into the concepts presented
    here, but this will have to wait until [Chapter 5](part0061_split_000.html#page
    "Chapter 5. Finding Spans in Text – Chunking"), *Finding Spans in Text – Chunking*.
    We will start easy with finding interesting sets of tokens. Then, we will move
    on to HMM and finish with one of the most complex components of LingPipe—CRF.
    As usual, we show you how to evaluate tagging and train your own taggers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单词和标记是本章的重点。最常见的提取技术，如命名实体识别，实际上已经编码在本章介绍的概念中，但这一点将留待 [第五章](part0061_split_000.html#page
    "第五章. 在文本中查找跨度 – 分块")，*在文本中查找跨度 – 分块* 中讨论。我们将从查找有趣的标记集开始，然后转向 HMM，并以 LingPipe
    最复杂的组件之一结束。像往常一样，我们将向您展示如何评估标注并训练自己的标注器。
- en: Interesting phrase detection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有趣短语检测
- en: 'Imagine that a program can take a bunch of text data and automatically find
    the interesting parts, where "interesting" means that the word or phrase occurs
    more often than expected. It has a very nice property—no training data is needed,
    and it works for any language that we have tokens for. You have seen this most
    often in tag clouds such as the one in the following figure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个程序可以自动从大量文本数据中找到有趣的片段，其中“有趣”意味着单词或短语出现的频率高于预期。它有一个非常好的特性——不需要训练数据，并且适用于我们有标记的任何语言。您最常见到这种情况是在如下所示的标签云中：
- en: '![Interesting phrase detection](img/00010.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![有趣短语检测](img/00010.jpeg)'
- en: The preceding figure shows a tag cloud generated for the [lingpipe.com](http://lingpipe.com)
    home page. However, be aware that tag clouds are considered to be the "mullets
    of the Internet" as noted by Jeffery Zeldman in [http://www.zeldman.com/daily/0405d.shtml](http://www.zeldman.com/daily/0405d.shtml),
    so you will be on shaky ground if you deploy such a feature on a website.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了为 [lingpipe.com](http://lingpipe.com) 主页生成的标签云。然而，请注意，标签云被认为是杰弗里·泽尔达曼所说的互联网上的“莫霍克”，因此如果您在网站上部署此类功能，可能会处于不稳定的状态。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To get the interesting phrases from a small dataset with tweets about Disney,
    perform the following steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要从关于迪士尼的小数据集（推文）中提取有趣的短语，请执行以下步骤：
- en: 'Fire up the command line and type:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动命令行并输入：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The program should respond with something like:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序应响应如下：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also supply a `.csv` file in our standard format as an argument to see
    different data.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以提供一个 `.csv` 文件作为参数，以查看不同的数据。
- en: The output tends to be tantalizingly useless. Tantalizingly useless means that
    some useful phrases show up, but with a bunch of less interesting phrases that
    you will never want in your summary of what is interesting in the data. On the
    interesting side, we can see `Crayola Color`, `Lindsey Lohan`, `Episode VII`,
    and so on. On the junk side, we can see `ncipes azules`, `pictures releases`,
    and so on. There are lots of ways to address the junk output—the obvious first
    step will be to use a language ID classifier to throw out non-English.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输出往往令人难以置信地无用。令人难以置信地无用意味着一些有用的短语出现了，但伴随着大量您永远不会想在数据有趣总结中的不那么有趣的短语。在有趣的一侧，我们可以看到
    `Crayola Color`、`Lindsey Lohan`、`Episode VII` 等等。在垃圾的一侧，我们可以看到 `ncipes azules`、`pictures
    releases` 等等。有许多方法可以解决垃圾输出——显然的第一步将是使用语言 ID 分类器来丢弃非英语。
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here, we will go through the source in its entirety, broken by explanatory
    text:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从头到尾解释源代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we see the path, imports, and the `main()` method. Our ternary operator
    that supplies a default file name or reads from the command line is the last line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到路径、导入和 `main()` 方法。我们提供默认文件名或从命令行读取的三元运算符是最后一行：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After collecting the input data, the first interesting code constructs a tokenized
    language model which differs in significant ways from the character language models
    used in [Chapter 1](part0014_split_000.html#page "Chapter 1. Simple Classifiers"),
    *Simple Classifiers*. A tokenized language model operates over tokens created
    by `TokenizerFactory`, and the `ngram` parameter dictates the number of tokens
    used instead of the number of characters. A subtlety of `TokenizedLM` is that
    it can also use character language models to make predictions for tokens it has
    not seen before. See the *Foreground- or background-driven interesting phrase
    detection* recipe to understand how this works in practice; don''t use the preceding
    constructor unless there are no unknown tokens when estimating. Also, the relevant
    Javadoc provides more details on this. In the following code snippet, the language
    model is trained:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集输入数据后，第一个有趣的代码构建了一个标记化语言模型，它与[第1章](part0014_split_000.html#page "第1章。简单分类器")中使用的字符语言模型有显著的不同。标记化语言模型在`TokenizerFactory`创建的标记上操作，`ngram`参数指定了使用的标记数而不是字符数。`TokenizedLM`的一个细微之处在于，它还可以使用字符语言模型对它之前未看到的标记进行预测。请参阅*前景或背景驱动的有趣短语检测*配方以了解实际操作；除非在估计时没有未知标记，否则不要使用前面的构造函数。相关的Javadoc提供了更多详细信息。在以下代码片段中，语言模型被训练：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next relevant step is the creation of collocations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个相关步骤是创建配对：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The parameterization controls the phrase length in tokens; it also sets a minimum
    count of how often the phrase can be seen and how many phrases to return. We can
    look at phrases of length 3 as we have a language model that stores 3 grams. Next,
    we will visit the results:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化控制短语在标记中的长度；它还设置短语可以出现的最小次数以及要返回的短语数量。由于我们有一个存储3元组的语言模型，我们可以查看长度为3的短语。接下来，我们将查看结果：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `SortedSet<ScoredObject<String[]>>` collocation is sorted from a high score
    to a low score. The intuition behind the score is that a higher score is given
    when the tokens are seen together more than one would expect, given their singleton
    frequency in the training data. In other words, phrases are scored depending on
    how much they vary from the independence assumption based on the tokens. See the
    Javadoc at [http://alias-i.com/lingpipe/docs/api/com/aliasi/lm/TokenizedLM.html](http://alias-i.com/lingpipe/docs/api/com/aliasi/lm/TokenizedLM.html)
    for the exact definitions—an interesting exercise will be to create your own score
    and compare it with what is done in LingPipe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedSet<ScoredObject<String[]>>` 配对从高分数到低分数排序。分数背后的直觉是，当标记一起出现次数超过预期时，会给予更高的分数，这取决于它们在训练数据中的单标记频率。换句话说，短语根据它们与基于标记的独立性假设的差异进行评分。有关确切定义，请参阅[http://alias-i.com/lingpipe/docs/api/com/aliasi/lm/TokenizedLM.html](http://alias-i.com/lingpipe/docs/api/com/aliasi/lm/TokenizedLM.html)中的Javadoc——一个有趣的练习是创建自己的评分标准并与LingPipe中使用的评分标准进行比较。'
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Given that this code is close to being usable on a website, it is worth discussing
    tuning. Tuning is the process of looking at system output and making changes based
    on the mistakes the system makes. Some changes that we would immediately consider
    include:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此代码接近在网站上使用，因此讨论调整是值得的。调整是查看系统输出并根据系统犯的错误进行更改的过程。我们立即会考虑的一些更改包括：
- en: A language ID classifier that will be handy to filter out non-English texts
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个语言ID分类器，可以方便地过滤掉非英文文本
- en: Some thought around how to better tokenize the data
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何更好地标记数据的思考
- en: Varying token lengths to include 3 grams and unigrams in the summary
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化的标记长度，包括3元组和单标记在摘要中
- en: Using named entity recognition to highlight proper nouns
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名实体识别来突出显示专有名词
- en: Foreground- or background-driven interesting phrase detection
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前景或背景驱动的有趣短语检测
- en: 'Like the previous recipe, this recipe finds interesting phrases, but it uses
    another language model to determine what is interesting. Amazon''s statistically
    improbable phrases (**SIP**) work this way. You can get a clear view from their
    website at [http://www.amazon.com/gp/search-inside/sipshelp.html](http://www.amazon.com/gp/search-inside/sipshelp.html):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方类似，这个配方也寻找有趣的短语，但它使用另一个语言模型来确定什么是有趣的。亚马逊的统计不可能短语（**SIP**）就是这样工作的。您可以从他们的网站[http://www.amazon.com/gp/search-inside/sipshelp.html](http://www.amazon.com/gp/search-inside/sipshelp.html)获得清晰的了解：
- en: '*"Amazon.com''s Statistically Improbable Phrases, or "SIPs", are the most distinctive
    phrases in the text of books in the Search Inside!™ program. To identify SIPs,
    our computers scan the text of all books in the Search Inside! program. If they
    find a phrase that occurs a large number of times in a particular book relative
    to all Search Inside! books, that phrase is a SIP in that book.*'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Amazon.com的统计不可能短语，或"SIPs"，是搜索内部!™计划中书籍文本中最独特的短语。为了识别SIPs，我们的计算机扫描搜索内部!计划中所有书籍的文本。如果它们在特定书籍中相对于所有搜索内部!书籍出现次数很多，那么这个短语就是该书籍中的SIP。*'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SIPs are not necessarily improbable within a particular book, but they are improbable
    relative to all books in Search Inside!."
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SIPs在特定书籍中不一定是不可能的，但相对于搜索内部!中的所有书籍来说是不可能的。
- en: The foreground model will be the book being processed, and the background model
    will be all the other books in Amazon's Search Inside!™ program. While Amazon
    has probably introduced tweaks that differ, it is the same basic idea.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前景模型将是正在处理的书籍，背景模型将是亚马逊搜索内部!™计划中的所有其他书籍。虽然亚马逊可能已经引入了不同的调整，但基本思想是相同的。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are a few sources of data worth looking at to get interesting phrases
    with two separate language models. The key is you want the background model to
    function as the source of expected word/phrase distributions that will help highlight
    interesting phrases in the foreground model. Some examples include:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个数据来源值得一看，以获取两个独立语言模型中的有趣短语。关键是你希望背景模型作为预期单词/短语分布的来源，这将有助于突出前景模型中的有趣短语。以下是一些例子：
- en: '**Time-separated Twitter data**: The examples of time-separated Twitter data
    are as follows:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间分离的Twitter数据**：时间分离的Twitter数据的例子如下：'
- en: '**Background model**: This refers to a year worth of tweets about Disney World
    up to yesterday.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景模型**：这指的是昨天之前一年的关于迪士尼世界的推文。'
- en: '**Foreground model**: Tweets for today.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前景模型**：今天的推文。'
- en: '**Interesting phrases**: What''s new in Disney World today on Twitter.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有趣短语**：今天在Twitter上关于迪士尼世界的新鲜事。'
- en: '**Topic-separated Twitter data**: The examples of topic-separated Twitter data
    are as follows:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题分离的Twitter数据**：主题分离的Twitter数据的例子如下：'
- en: '**Background model**: Tweets about Disneyland'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景模型**：关于迪士尼乐园的推文'
- en: '**Foreground model**: Tweets about Disney World'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前景模型**：关于迪士尼世界的推文'
- en: '**Interesting phrases**: What is said about Disney World that is not said about
    Disneyland'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有趣短语**：关于迪士尼世界所说但没有在迪士尼乐园说的内容'
- en: '**Books on very similar topics**: The examples of books on similar topics are
    as follows:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非常相似主题的书籍**：相似主题书籍的例子如下：'
- en: '**Background model**: A pile of early sci-fi novels'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景模型**：一堆早期的科幻小说'
- en: '**Foreground model**: Jules Verne''s *War of the Worlds*'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前景模型**：儒勒·凡尔纳的*世界大战*'
- en: '**Interesting phrases**: The unique phrases and concepts of "War of the Worlds"'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有趣短语**：关于“世界大战”的独特短语和概念'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to run a foreground or background model on tweets about
    Disneyland versus tweets about Disney World:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于迪士尼乐园和迪士尼世界推文的推文中运行前景或背景模型的步骤如下：
- en: 'In the command line, type:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中输入：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will look something like:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将类似于：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The foreground model consists of tweets for the search term, `disneyland`, and
    the background model consists of tweets for the search term, `disneyworld`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前景模型由搜索词`disneyland`的推文组成，背景模型由搜索词`disneyworld`的推文组成。
- en: The top tied results are for unique features of California-based Disneyland,
    namely, the name of the castle, Sleeping Beauty's Castle, and a theme park built
    in the parking lot of Disneyland, California Adventure.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最相关的结果是为了加州迪士尼乐园的独特特征，即城堡的名字、睡美人的城堡，以及建在加州迪士尼乐园停车场上的主题公园。
- en: The next bigram is for *Winter Dreams*, which refers to a premier for a film.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个双词组是关于*Winter Dreams*的，它指的是一部电影的预映。
- en: Overall, not a bad output to distinguish between the tweets of the two resorts.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总体来说，区分两个度假村的推文，输出还不错。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The code is in `src/com/lingpipe/cookbook/chapter4/InterestingPhrasesForegroundBackground.java`.
    The exposition starts after we loaded the raw `.csv` data for the foreground and
    background models:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码位于`src/com/lingpipe/cookbook/chapter4/InterestingPhrasesForegroundBackground.java`。在加载前景和背景模型的原始`.csv`数据之后，解释开始：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What is being built here is the model that is used to judge the novelty of
    phrases in the foreground model. Then, we will create and train the foreground
    model:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正在构建的是用于判断前景模型中短语新颖性的模型。然后，我们将创建并训练前景模型：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will access the `newTermSet()` method from the foreground model. The
    parameters and `phraseSize` determine how long the token sequences are; `minCount`
    specifies a minimum number of instances of the phrase to be considered, and `maxReturned`
    controls how many results to return:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从前景模型中访问`newTermSet()`方法。参数和`phraseSize`确定标记序列的长度；`minCount`指定要考虑的短语的最小实例数，而`maxReturned`控制要返回的结果数量：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding `for` loop prints out the phrases in order of the most surprising
    phrase to the least surprising one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`for`循环按从最令人惊讶的短语到最不令人惊讶的短语的顺序打印短语。
- en: The details of what is going on here are beyond the scope of the recipe, but
    the Javadoc again starts us down the road to enlightenment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情的细节超出了食谱的范围，但Javadoc再次为我们指明了通往启迪的道路。
- en: The exact scoring used is the z-score, as defined in `BinomialDistribution.z(double,int,int)`,
    with the success probability defined by the n-grams probability estimate in the
    background model, the number of successes being the count of the n-gram in this
    model, and the number of trials being the total count in this model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的精确评分方法是z分数，如`BinomialDistribution.z(double,int,int)`中定义的那样，成功概率由背景模型中的n-gram概率估计定义，成功次数是此模型中n-gram的计数，试验次数是此模型中的总计数。
- en: There's more...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This recipe is the first place where we have faced unknown tokens, which can
    have very bad properties if not handled correctly. It is easy to see why this
    is a problem with a maximum likelihood of a token-based language model, which
    is a fancy name for a language model that provides an estimate of some unseen
    tokens by multiplying the likelihoods of each token. Each likelihood is the number
    of times the token was seen in training divided by the number of tokens seen in
    data. For example, consider training on the following data from *A Connecticut
    Yankee in King Arthur''s Court*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是我们第一次遇到未知标记的地方，如果不正确处理，这些标记可能会具有非常糟糕的特性。很容易看出为什么这是一个基于最大似然的语言模型的问题，这是一个语言模型的华丽名称，它通过乘以每个标记的似然来估计一些未见过的标记。每个似然是标记在训练中出现的次数除以在数据中看到的标记数。例如，考虑以下来自《亚瑟王宫廷中的康涅狄格州扬基》的训练数据：
- en: '*"The ungentle laws and customs touched upon in this tale are historical, and
    the episodes which are used to illustrate them are also historical."*'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “本故事中提到的那些不温柔的习俗和历史事件都是历史的，用来说明它们的情节也是历史的。”
- en: This is very little training data, but it is sufficient for the point being
    made. Consider how we will get an estimate for the phrase, "The ungentle inlaws"
    using our language model. There are 24 words with "The" occurring once; we will
    assign a probability of 1/24 to this. We will assign a probability of 1/24 to
    "ungentle" as well. If we stop here, we can say that the likelihood of "The ungentle"
    is 1/24 * 1/24\. However, the next word is "inlaws", which does not exist in the
    training data. If this token is assigned a value of 0/24, it will make the likelihood
    of the entire string 0 (1/24 * 1/24 * 0/20). This means that whenever there is
    an unseen token for which the estimate is likely going to be zero, this is generally
    an unhelpful property.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常少的训练数据，但对于要说明的观点来说已经足够了。考虑一下我们如何使用我们的语言模型来估计短语“不温柔的岳父”的值。有24个单词包含一次出现的“The”，我们将分配1/24的概率给这个。我们也将1/24的概率分配给“ungentle”。如果我们在这里停止，我们可以说“The
    ungentle”的可能性是1/24 * 1/24。然而，下一个词是“inlaws”，它不在训练数据中。如果这个标记被分配0/24的值，这将使整个字符串的可能性变为0（1/24
    * 1/24 * 0/20）。这意味着每当有一个未见过的标记，其估计很可能是零时，这通常是一个无益的特性。
- en: 'The standard response to this issue is to substitute and approximate the value
    to stand in for data that has not been seen in training. There are a few approaches
    to solving this problem:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对此问题的标准响应是用替代值和近似值来代替训练中未见过的数据。有几种解决此问题的方法：
- en: Provide a low but non-zero estimate for unknown tokens. This is a very common
    approach.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为未知标记提供一个低但非零的估计。这是一个非常常见的做法。
- en: Use character language models with the unknown token. There are provisions for
    this in the class—refer to the Javadoc.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含未知标记的字符语言模型。类中有这方面的规定——请参阅Javadoc。
- en: There are lots of other approaches and substantial research literature. Good
    search terms are "back off" and "smoothing".
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多其他方法和大量的研究文献。好的搜索词是“回退”和“平滑”。
- en: Hidden Markov Models (HMM) – part-of-speech
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏马尔可夫模型（HMM）- 词性
- en: This recipe brings in the first hard-core linguistic capability of LingPipe;
    it refers to the grammatical category for words or **part-of-speech** (**POS**).
    What are the verbs, nouns, adjectives, and so on in text?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方引入了LingPipe的第一个核心语言能力；它指的是单词或**词性**（**POS**）的语法类别。文本中的动词、名词、形容词等等是什么？
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s jump right in and drag ourselves back to those awkward middle-school
    years in English class or our equivalent:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接跳进去，回到那些尴尬的中学英语课或我们等效的年份：
- en: 'As always, head over to your friendly command prompt and type the following:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，前往你友好的命令提示符并输入以下内容：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The system will respond with a prompt to which we will add a Jorge Luis Borges
    quote:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统将响应一个提示，我们将添加一个豪尔赫·路易斯·博尔赫斯（Jorge Luis Borges）的引言：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The system will respond delightfully to this quote with:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统将愉快地响应这个引言：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Appended to each token is `_` with a part-of-speech tag; `nn` is noun, `rb`
    is adverb, and so on. The complete tag set and description of the corpus of the
    tagger can be found at [http://en.wikipedia.org/wiki/Brown_Corpus](http://en.wikipedia.org/wiki/Brown_Corpus).
    Play around with it a bit. POS tagger was one of the first breakthrough machine-learning
    applications in NLP back in the '90s. You can expect this one to perform at better
    than 90-percent accuracy, although it might suffer a bit on Twitter data given
    that that the underlying corpus was collected in 1961.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标记后面都附加了`_`和词性标签；`nn`是名词，`rb`是副词，等等。完整的标签集和标注器的语料库描述可以在[http://en.wikipedia.org/wiki/Brown_Corpus](http://en.wikipedia.org/wiki/Brown_Corpus)找到。稍作尝试。词性标注器是90年代早期NLP中第一个突破性的机器学习应用之一。你可以期待这个应用的准确率超过90%，尽管由于基础语料库是在1961年收集的，因此在Twitter数据上可能会有所下降。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As appropriate for a recipe book, we are not revealing the fundamentals of
    how part-of-speech taggers are built. There is Javadoc, the Web, and the research
    literature to help you understand the underlying technology—in the recipe for
    training an HMM, there is a brief discussion of the underlying HMM. This is about
    how to use the API as presented:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如食谱书所应有的，我们不会透露词性标注器构建的基本原理。有Javadoc、网络和科研文献来帮助你理解底层技术——在训练HMM的配方中，对底层HMM有一个简要的讨论。这是关于如何使用API的展示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code starts by setting up `TokenizerFactory`, which makes sense because
    we need to know what the words that are going to get the parts of speech are.
    The next line reads in a previously trained part-of-speech tagger as `HiddenMarkovModel`.
    We will not go into too much detail; you just need to know that an HMM assigns
    a part-of-speech tag for token *n* as a function of the tag assignments that preceded
    it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先设置`TokenizerFactory`，这是有道理的，因为我们需要知道将要获得词性的单词。下一行读取一个之前训练好的词性标注器作为`HiddenMarkovModel`。我们不会过多深入细节；你只需要知道HMM将根据其前面的标签分配为token
    *n* 分配一个词性标签。
- en: The fact that these tags are not directly observed in data makes the Markov
    model hidden. Usually, one or two tokens back are looked at. There is a lot going
    on with HMMs that is worth understanding.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签在数据中不是直接观察到的，这使得马尔可夫模型是隐藏的。通常，会查看一个或两个标记之前的标记。HMM中有许多值得理解的事情在进行。
- en: 'The next line with HmmDecoder decoder wraps the HMM in code to tag provided
    tokens. Our standard interactive `while` loop is up next with all the interesting
    bits happening in the firstBest(tokenList,decoder) method at the end. The method
    is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用`HmmDecoder`解码器将HMM包装在代码中以标注提供的标记。接下来是我们的标准交互式`while`循环，所有有趣的代码都在`firstBest(tokenList,decoder)`方法中。方法如下：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the `decoder.tag(tokenList)` call that produces a `Tagging<String>` tagging.
    Tagging does not have an iterator or useful encapsulation of the tag/token pair,
    so the information is accessed by incrementing an index i.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`decoder.tag(tokenList)`调用，它产生一个`Tagging<String>`标签。标签没有迭代器或标签/标记对的封装，因此信息是通过增加索引i来访问的。
- en: N-best word tagging
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: N-best词性标注
- en: The certainty-driven nature of Computer Science is not reflected in the vagaries
    of linguistics where reasonable PhDs can agree or disagree at least until Chomsky's
    henchmen show up. This recipe uses the same HMM trained in the preceding recipe
    but provides a ranked list of possible tags for each word.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的确定性本质在语言学的不确定性中并未得到体现，在乔姆斯基的助手出现之前，合理的博士们可以至少同意或不同意。这个食谱使用在前面食谱中训练的相同HMM，但为每个单词提供可能的标记排名列表。
- en: Where might this be helpful? Imaging a search engine that searched for words
    and a tag—not necessarily part-of-speech. The search engine can index the word
    and the top *n*-best tags that will allow a match into a non-first best tag. This
    can help increase recall.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在哪里有帮助？想象一个搜索引擎，它搜索单词和标记——不一定是词性。搜索引擎可以索引单词和前*n*-best标记，这将允许匹配到非最佳标记。这可以帮助提高召回率。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '`N`-best analyses push the sophistication boundaries of NLP developers. What
    used to be a singleton is now a ranked list, but it is where the next level of
    performance occurs. Let''s get started by performing the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`N`-best分析推动了NLP开发者的复杂度边界。曾经是单例的现在变成了一个排名列表，但这是下一个性能级别的发生地。让我们通过执行以下步骤开始：'
- en: 'Put away your copy of *Syntactic Structures* face down and type out the following:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的《句法结构》副本面朝下放好，并输入以下内容：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, enter the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入以下内容：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It yields the following output:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它产生了以下输出：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The output lists from most likely to least likely the estimate of the entire
    sequence of tokens given the estimates from the HMM. Remember that the joint probabilities
    are log 2 based. To compare joint probabilities subtract -93.9 from -91.1 for
    a difference of 2.8\. So, the tagger thinks that option 1 is 2 ^ 2.8 = 7 times
    less likely to occur than option 0\. The source of this difference is in assigning
    green to noun rather than adjective.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列表从最有可能到最不可能列出整个标记序列的估计，给定HMM的估计。记住，联合概率是以2为底的对数。要比较联合概率，从-93.9减去-91.1得到2.8的差异。所以，标记器认为选项1比选项0发生的机会低7倍。这种差异的来源在于将`green`分配为名词而不是形容词。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'The code to load the model and command I/O is the same as that of the previous
    recipe. The difference is in the method used to get and display the tagging:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 加载模型和命令I/O的代码与之前的食谱相同。不同之处在于获取和显示标记的方法：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is nothing much to it other than working out the formatting issues as
    the taggings are being iterated over.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有什么太多的事情，除了在迭代标记时解决格式问题。
- en: Confidence-based tagging
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于置信度的标记
- en: There is another view into the tagging probabilities; this reflects the probability
    assignments at the level of word. The code reflects the underlying `TagLattice`
    and offers insights into whether the tagger is confident or not.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待标记概率的方法；这反映了单词层面的概率分配。代码反映了底层的`TagLattice`，并提供了关于标记器是否自信的见解。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe will focus the probability estimates on the individual token. Perform
    the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将聚焦于对单个标记的概率估计。执行以下步骤：
- en: 'Type in the following on the command line or IDE equivalent:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行或IDE等效环境中输入以下内容：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, enter the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入以下内容：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It yields the following output:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它产生了以下输出：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This view of the data distributes the joint probabilities of the tag and word.
    We can see that there is `.208` chance that `green` should be tagged as `nn` or
    a singular noun, but the correct analysis is still `.788` with adjective `jj`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据视图将标记和单词的联合概率分布。我们可以看到，`green`被标记为`nn`或单数名词的概率是`.208`，但正确的分析仍然是`.788`，带有形容词`jj`。
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: 'We are still using the same old HMM from the *Hidden Markov Models (HMM) –
    part-of-speech* recipe but using different parts of it. The code to read in the
    model is exactly the same, with a major difference in how we report results. `src/com/lingpipe/cookbook/chapter4/ConfidenceBasedTagger.java`
    the method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用与《隐藏马尔可夫模型（HMM）- 词性》食谱中相同的旧HMM，但使用它的不同部分。读取模型的代码完全相同，但在报告结果的方式上有重大差异。`src/com/lingpipe/cookbook/chapter4/ConfidenceBasedTagger.java`中的方法：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The method demonstrates the underlying lattice of tokens to the probabilities
    explicitly, which is at the heart of the HMM. Change the termination condition
    on the `for` loop to see more or fewer tags.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法明确展示了标记的底层图，这是HMM的核心。通过改变`for`循环的终止条件来查看更多或更少的标记。
- en: Training word tagging
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练词标记
- en: Word tagging gets much more interesting when you can create your own models.
    The realm of annotating part-of-speech tagging corpora is a bit too much for a
    mere recipe book—annotation of the part-of-speech data is very difficult because
    it requires considerable linguistic knowledge to do well. This recipe will directly
    address the machine-learning component of the HMM-based sentence detector.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以创建自己的模型时，词性标注就变得更有趣了。对词性标注语料库进行标注的领域对于一本简单的食谱书来说有点过于广泛——对词性数据的标注非常困难，因为它需要相当的语言学知识才能做好。这个食谱将直接解决基于HMM的句子检测器的机器学习部分。
- en: As this is a recipe book, we will minimally explain what an HMM is. The token
    language models that we have been working with do their previous context calculations
    on some number of words/tokens that precede the current word being estimated.
    HMMs take into account some length of the previous tags while calculating estimates
    for the current token's tag. This allows for seemingly disparate neighbors such
    as `of` and `in` to be similar, because they are both prepositions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本食谱书，我们将最小化解释HMM是什么。我们一直在使用的标记语言模型在计算当前估计的单词的前一个上下文时，考虑了一些单词/标记的数量。HMM在计算当前标记的标签估计时，会考虑到一些前一个标签的长度。这使得看似不同的邻居，如
    `of` 和 `in`，看起来相似，因为它们都是介词。
- en: In the *Sentence detection* recipe, from [Chapter 5](part0061_split_000.html#page
    "Chapter 5. Finding Spans in Text – Chunking"), *Finding Spans in Text – Chunking*,
    a useful but not very flexible sentence detector is based on the `HeuristicSentenceModel`
    in LingPipe. Rather than mucking about with modifying/extending the `HeuristicSentenceModel`,
    we will build a machine-learning-based sentence system with the data that we annotate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *句子检测* 食谱中，从 [第5章](part0061_split_000.html#page "第5章. 在文本中查找范围 – 分块")，*在文本中查找范围
    – 分块*，一个有用但不太灵活的句子检测器基于LingPipe中的 `HeuristicSentenceModel`。我们不会去修改/扩展 `HeuristicSentenceModel`，而是将使用我们标注的数据构建一个基于机器学习的句子系统。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps here describe how to run the program in `src/com/lingpipe/cookbook/chapter4/HMMTrainer.java`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何在 `src/com/lingpipe/cookbook/chapter4/HMMTrainer.java` 中运行程序：
- en: 'Either create a new corpus of the sentence-annotated data or use the following
    default data, which is in `data/connecticut_yankee_EOS.txt`. If you are rolling
    your own data, simply edit some text with `['' and '']` to mark the sentence boundaries.
    Our example looks like the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么创建一个句子标注数据的新的语料库，要么使用以下默认数据，该数据位于 `data/connecticut_yankee_EOS.txt`。如果你正在自己生成数据，只需用
    `['` 和 `']` 编辑一些文本以标记句子边界。我们的例子如下：
- en: '[PRE27]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Go to the command prompt and run the program with the following command:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往命令提示符并使用以下命令运行程序：
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It will give the following output:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将给出以下输出：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is a tokenized text with one of the three tags: `BOS` for the beginning
    of a sentence, `EOS` for the end of a sentence, and `WORD` for all other tokens.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出是一个标记化文本，包含三个标签之一：`BOS` 表示句子的开始，`EOS` 表示句子的结束，以及 `WORD` 表示所有其他标记。
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Like many span-based markups, the `span` annotation is translated into a token-level
    annotation, as shown earlier in the recipe''s output. So, the first order of business
    is to collect the annotated text, set up `TokenizerFactory`, and then call a parsing
    subroutine to add to `List<Tagging<String>>`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多基于范围的标记一样，`span` 标注被转换成之前在食谱输出中展示的标记级别标注。因此，首要任务是收集标注文本，设置 `TokenizerFactory`，然后调用一个解析子例程将其添加到
    `List<Tagging<String>>`：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The subroutine to parse the preceding format works by first tokenizing the
    text with `IndoEuropeanTokenizer`, which has the desirable property of treating
    the `['' and '']` sentence delimiters as separate tokens. It does not check whether
    the sentence delimiters are well formed—a more robust solution will be needed
    to do this. The tricky bit is that we want to ignore this markup in the resulting
    token stream, but we want to use it to have the token following `['' be a BOS
    and the token preceding '']` be `EOS`. Other tokens are just `WORD`. The subroutine
    builds a parallel `Lists<String>` instance for tags and tokens, which is then
    used to create `Tagging<String>` and is added to `taggingList`. The tokenization
    recipes in [Chapter 2](part0027_split_000.html#page "Chapter 2. Finding and Working
    with Words"), *Finding and Working with Words*, cover what is going on with the
    tokenizer. Have a look at the following code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 解析前述格式的子例程通过首先使用 `IndoEuropeanTokenizer` 对文本进行标记化来实现，该标记化器具有将 `['` 和 `']` 句子分隔符作为单独标记的有益特性。它不会检查句子分隔符是否格式正确——需要更健壮的解决方案来完成这项工作。棘手的部分在于我们希望忽略结果标记流中的这种标记，但同时又想使用它来确保跟随
    `['` 的标记是 BOS，而跟随 `']` 的标记是 EOS。其他标记只是 `WORD`。子例程为标签和标记构建了一个并行 `Lists<String>`
    实例，然后用于创建 `Tagging<String>` 并添加到 `taggingList` 中。第 2 章（part0027_split_000.html#page
    "Chapter 2. Finding and Working with Words"）*Finding and Working with Words* 中的标记化配方涵盖了标记化器正在处理的内容。查看以下代码片段：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There is a subtlety with the preceding code. The training data is treated as
    a single tagging—this will emulate what the input will look like when we use the
    sentence detector on novel data. If more than one document/chapter/paragraph is
    being used for training, then we will call this subroutine for each block of text.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码有一个细微之处。训练数据被视为单个标记——这将模拟当我们使用句子检测器对新颖数据进行处理时输入将看起来像什么。如果使用多个文档/章节/段落进行训练，那么我们将为每个文本块调用此子例程。
- en: 'Returning to the `main()` method, we will set up `ListCorpus` and add the tagging
    to the training side of the corpus, one tagging at a time. There is an `addTest()`
    method as well, but this recipe is not concerned with evaluation; if it was, we
    would most likely use `XValidatingCorpus` anyway:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `main()` 方法，我们将设置 `ListCorpus` 并将标记添加到语料库的训练部分，一次添加一个标记。还有一个 `addTest()`
    方法，但这个配方不涉及评估；如果是评估，我们可能无论如何都会使用 `XValidatingCorpus`：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will create `HmmCharLmEstimator`, which is our HMM. Note that there
    are constructors that allow for customized parameters that affect performance—see
    the Javadoc. Next, the estimator is trained against the corpus, and `HmmDecoder`
    is created, which will actually tag tokens, as shown in the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `HmmCharLmEstimator`，这是我们使用的 HMM。请注意，有一些构造函数允许自定义参数，这些参数会影响性能——请参阅
    Javadoc。接下来，估计器将对语料库进行训练，并创建 `HmmDecoder`，它将实际标记标记，如以下代码片段所示：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That's it! To truly wrap this as a proper sentence detector, we will need to
    map back to the character offsets in the original text, but this is covered in
    [Chapter 5](part0061_split_000.html#page "Chapter 5. Finding Spans in Text – Chunking"),
    *Finding Spans in Text – Chunking*. This is sufficient to show how to work with
    HMMs. A more full-featured approach will make sure that each BOS has a matching
    EOS and the other way around. The HMM has no such requirement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！为了真正将其作为一个合适的句子检测器，我们需要将字符偏移量映射回原始文本，但这在第 5 章（part0061_split_000.html#page
    "Chapter 5. Finding Spans in Text – Chunking"）*Finding Spans in Text – Chunking*
    中有所介绍。这足以展示如何使用 HMM。一个更完整的功能方法将确保每个 BOS 都有一个匹配的 EOS，反之亦然。HMM 没有这样的要求。
- en: There's more…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have a small and easy-to-use corpus of the part-of-speech tags; this allows
    us to show how training the HMM for a very different problem works out to be the
    same thing. It is like our *How to classify a sentiment – simple version* recipe,
    in [Chapter 1](part0014_split_000.html#page "Chapter 1. Simple Classifiers"),
    *Simple Classifiers*; the only difference between the language ID and sentiment
    is the training data. We will start with a hard-coded corpus for simplicity—it
    is in `src/com/lingpipe/cookbook/chapter4/TinyPosCorus.java`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个小型且易于使用的词性标注语料库；这使我们能够展示如何训练用于非常不同问题的 HMM 与训练简单分类器（[Chapter 1](part0014_split_000.html#page
    "Chapter 1. Simple Classifiers"）*Simple Classifiers*）中的配方相同。它就像我们的 *如何对情感进行分类
    – 简单版本* 配方，在 [Chapter 1](part0014_split_000.html#page "Chapter 1. Simple Classifiers")
    *Simple Classifiers*；语言 ID 和情感之间的唯一区别是训练数据。我们将从一个硬编码的语料库开始，以保持简单——它位于 `src/com/lingpipe/cookbook/chapter4/TinyPosCorus.java`：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The corpus manually creates tokens as well as the tags for the tokens in the
    static `WORDS_TAGS` and creates `Tagging<String>` for each sentence; `Tagging<String>`
    consists of two aligned `List<String>` instances in this case. The taggings are
    then sent to the `handle()` method for the `Corpus` superclass. Swapping in this
    corpus looks like the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 语料库手动创建标记以及标记中的静态 `WORDS_TAGS` 中的标记，并为每个句子创建 `Tagging<String>`；在这种情况下，`Tagging<String>`
    由两个对齐的 `List<String>` 实例组成。然后，标记被发送到 `Corpus` 超类的 `handle()` 方法。替换这个语料库看起来如下：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We just commented out the code that loads the corpus with sentence detection
    and features in `TinyPosCorpus` in its place. It doesn''t need data to be added
    so we will just train the HMM with it. To avoid confusion we have created a separate
    class `HmmTrainerPos.java`. Running it results in the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是注释掉了在 `TinyPosCorpus` 中加载带有句子检测和特征的代码，取而代之。由于它不需要添加数据，我们将仅用此训练HMM。为了避免混淆，我们创建了一个单独的类
    `HmmTrainerPos.java`。运行它会产生以下结果：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The only mistake is that `in` is a transitive verb `TV`. The training data is
    very small so mistakes are to be expected. Like the difference in language ID
    and sentiment classification in [Chapter 1](part0014_split_000.html#page "Chapter 1. Simple
    Classifiers"), *Simple Classifiers*, the HMM is used to learn a very different
    phenomenon just by changing what the training data is.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的错误是 `in` 是一个及物动词 `TV`。由于训练数据非常小，所以错误是可以预料的。就像在[第1章](part0014_split_000.html#page
    "Chapter 1. Simple Classifiers")中语言ID和情感分类的差异一样，HMM通过改变训练数据来学习一个非常不同的现象。
- en: Word-tagging evaluation
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词性标注评估
- en: Word tagging evaluation drives developments in downstream technologies such
    as named entity detection, which, in turn, drives high-end applications such as
    coreference. You will notice that much of the evaluation resembles the evaluation
    from our classifiers except that each tag is evaluated like its own classifier
    category.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 词性标注评估推动了下游技术，如命名实体检测的发展，反过来，又推动了高端应用，如指代消解。您会注意到，大部分评估与我们的分类器评估相似，只是每个标记都像其自己的分类器类别一样进行评估。
- en: This recipe should serve to get you started on evaluation, but be aware that
    there is a very good tutorial on tagging evaluation on our website at [http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html);
    this recipe goes into greater detail on how to best understand tagger performance.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱应该可以帮助您开始评估，但请注意，我们网站上有一个关于词性标注评估的优秀教程[http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html)；这个菜谱更详细地介绍了如何最好地理解标记器的性能。
- en: This recipe is short and easy to use, so you have no excuses to not evaluate
    your tagger.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱简短且易于使用，所以你没有不评估你的标记器的借口。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following is the class source for our evaluator located at `src/com/lingpipe/cookbook/chapter4/TagEvaluator.java`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们评估器的类源代码，位于 `src/com/lingpipe/cookbook/chapter4/TagEvaluator.java`：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will call out the interesting bits of the preceding code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指出前面代码中的有趣部分：
- en: 'First off, we will set up `TaggerEvaluator` with a null `HmmDecoder` and `boolean`
    that controls whether the tokens are stored or not. The `HmmDecoder` object will
    be set in the cross-validation code later in the code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用空 `HmmDecoder` 和控制标记是否存储的 `boolean` 来设置 `TaggerEvaluator`。`HmmDecoder`
    对象将在代码中的交叉验证部分稍后设置：
- en: '[PRE40]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we will load `TinyPosCorpus` from the previous recipe and use it to populate
    `XValididatingObjectCorpus`—a pretty neat trick that allows for easy conversion
    between corpus types. Note that we pick 10 folds—the corpus only has 11 training
    examples, so we want to maximize the amount of training data per fold. See the
    *How to train and evaluate with cross validation* recipe in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Simple Classifiers"), *Simple Classifiers*, if you are new to this
    concept. Have a look at the following code snippet:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从上一个菜谱中加载 `TinyPosCorpus` 并用它来填充 `XValididatingObjectCorpus`——这是一个非常巧妙的技巧，允许轻松地在语料库类型之间进行转换。请注意，我们选择了10个折——语料库只有11个训练示例，所以我们希望最大化每个折的训练数据量。如果您对这个概念不熟悉，请参阅[第1章](part0014_split_000.html#page
    "Chapter 1. Simple Classifiers")中的*如何使用交叉验证进行训练和评估*菜谱，*简单分类器*。查看以下代码片段：
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following code snippet is a `for()` loop that iterates over the number
    of folds. The first half of the loop handles training:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段是一个 `for()` 循环，它遍历折的数量。循环的前半部分处理训练：
- en: '[PRE42]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The rest of the loop first creates a decoder for the HMM, sets the evaluator
    to use this decoder, and then applies the appropriately configured evaluator to
    the test portion of the corpus:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环的其余部分首先为HMM创建解码器，将评估器设置为使用此解码器，然后将配置适当的评估器应用于语料库的测试部分：
- en: '[PRE43]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The last lines apply after all folds of the corpus have been used for training
    and testing. Notice that the evaluator is `BaseClassifierEvaluator`! It reports
    on each tag as a category:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后几行在语料库的所有折都用于训练和测试之后应用。注意，评估器是`BaseClassifierEvaluator`！它报告每个标签作为类别：
- en: '[PRE44]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Brace yourself for the torrent of evaluation. The following is a small bit
    of it, namely, the confusion matrix that you should be familiar with from [Chapter
    1](part0014_split_000.html#page "Chapter 1. Simple Classifiers"), *Simple Classifiers*:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备迎接评估的洪流。以下只是其中的一小部分，即你应该从[第1章](part0014_split_000.html#page "Chapter 1. Simple
    Classifiers")*简单分类器*中熟悉的混淆矩阵：
- en: '[PRE45]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That's it. You have an evaluation setup that is strongly related to the classifier
    evaluation from [Chapter 1](part0014_split_000.html#page "Chapter 1. Simple Classifiers"),
    *Simple Classifiers*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你有一个与[第1章](part0014_split_000.html#page "Chapter 1. Simple Classifiers")*简单分类器*中的分类器评估紧密相关的评估设置。
- en: There's more…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are evaluation classes for the n-best word tagging, that is, `NBestTaggerEvaluator`
    and `MarginalTaggerEvaluator`, for the confidence ranked. Again, look at the more
    detailed tutorial on part-of-speech tagging for a quite thorough presentation
    on evaluation metrics and some example software to help tune the HMM.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于n-best词标注有评估类，即`NBestTaggerEvaluator`和`MarginalTaggerEvaluator`，用于置信度排名。再次提醒，查看关于词性标注的更详细教程，以获得关于评估指标和一些帮助调整HMM的示例软件的全面介绍。
- en: Conditional random fields (CRF) for word/token tagging
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于词/标记标注的条件随机场（CRF）
- en: '**Conditional random fields** (**CRF**) are an extension of the *Logistic regression*
    recipe in [Chapter 3](part0036_split_000.html#page "Chapter 3. Advanced Classifiers"),
    *Advanced Classifiers*, but are applied to word tagging. At the end of [Chapter
    1](part0014_split_000.html#page "Chapter 1. Simple Classifiers"), *Simple Classifiers*,
    we discussed various ways to encode a problem into a classification problem. CRFs
    treat the sequence tagging problem as finding the best category where each category
    (C) is one of the C*T tag (T) assignments to tokens.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件随机场**（**CRF**）是[第3章](part0036_split_000.html#page "Chapter 3. Advanced
    Classifiers")*高级分类器*中*逻辑回归*公式的扩展，但应用于词标注。在[第1章](part0014_split_000.html#page "Chapter 1. Simple
    Classifiers")*简单分类器*的结尾，我们讨论了将问题编码为分类问题的各种方法。CRFs将序列标注问题视为寻找最佳类别，其中每个类别（C）是C*T标签（T）分配给标记之一。'
- en: 'For example, if we have the tokens `The` and `rain` and tag `d` for determiner
    and `n` for noun, then the set of categories for the CRF classifier are:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有标记`The`和`rain`，并且将`d`标记为限定词，将`n`标记为名词，那么CRF分类器的类别集合是：
- en: '**Category 1**: `d d`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别1**：`d d`'
- en: '**Category 2**: `n d`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别2**：`n d`'
- en: '**Category 3**: `n n`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别3**：`n n`'
- en: '**Category 4**: `d d`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别4**：`d d`'
- en: Various optimizations are applied to keep this combinatoric nightmare computable,
    but this is the general idea. Crazy, but it works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个组合噩梦可计算，已经应用了各种优化，但这是基本思路。疯狂，但有效。
- en: Additionally, CRFs allow random features to be used in training in the exact
    same way that logistic regression does for classification. Additionally, it has
    data structures optimized for HMM style observations against context. Its use
    for part-of-speech tagging is not very exciting, because our current HMMs are
    pretty close to state of the art. Where CRFs really make a difference is in use
    cases like named entity detection which are covered in [Chapter 5](part0061_split_000.html#page
    "Chapter 5. Finding Spans in Text – Chunking"), *Finding Spans in Text – Chunking*,
    but we wanted to address the pure CRF implementation before complicating the presentation
    with a chunking interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CRFs允许在训练中使用随机特征，这与逻辑回归用于分类的方式完全相同。此外，它具有针对HMM风格观察的优化数据结构。它在词性标注方面的应用并不令人兴奋，因为我们的当前HMMs已经非常接近最先进水平。CRFs真正发挥作用的地方是在诸如命名实体识别等用例中，这些用例在[第5章](part0061_split_000.html#page
    "Chapter 5. Finding Spans in Text – Chunking")*在文本中查找跨度 - 分块*中有介绍，但我们希望在将分块接口复杂化之前先解决纯CRF实现问题。
- en: There is an excellent detailed tutorial on CRFs at [http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html);
    this recipe follows this tutorial fairly closely. You will find more information
    and proper references there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html)有一个关于CRF的优秀详细教程；这道菜谱非常接近这个教程。你将在那里找到更多信息以及适当的引用。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'All of the technologies we have been presenting up to now were invented in
    the previous millennium; this is a technology from the new millennium. Perform
    the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至今所展示的所有技术都是在上一个千年发明的；这是一个来自新千年的技术。执行以下步骤：
- en: 'In the command line, type:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下命令：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The console continues with the convergence results that should be familiar
    from the *Logistic regression* recipe of [Chapter 3](part0036_split_000.html#page
    "Chapter 3. Advanced Classifiers"), *Advanced Classifiers*, and we will get the
    standard command prompt:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台继续显示收敛结果，这些结果应该与[第3章](part0036_split_000.html#page "第3章。高级分类器")中的*逻辑回归*菜谱中熟悉的结果一样，我们将得到标准的命令提示符：
- en: '[PRE47]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In response to this, we will get some fairly confused output:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为对此的回应，我们将得到一些相当混乱的输出：
- en: '[PRE48]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is an awful output, but the CRF has been trained on 11 sentences. So, let's
    not be too harsh—particularly since this technology mostly reigns supreme for
    word tagging and span tagging when given sufficient training data to do its work.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个糟糕的输出，但CRF已经在11个句子上进行了训练。所以，我们不要太苛刻——尤其是考虑到这项技术主要在给足训练数据以完成其工作时，在词性标注和跨度标注方面占据主导地位。
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Like logistic regression, there are many configuration-related tasks that we
    need to perform to get this class up and running. This recipe will address the
    CRF-specific aspects of the code and refer to *the Logistic regression* recipe
    of [Chapter 3](part0036_split_000.html#page "Chapter 3. Advanced Classifiers"),
    *Advanced Classifiers* for the logistic-regression aspects of the configuration.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 就像逻辑回归一样，我们需要执行许多配置相关的任务来使这个类运行起来。这道菜谱将解决代码中CRF特定的方面，并参考[第3章](part0036_split_000.html#page
    "第3章。高级分类器")中的*逻辑回归*菜谱，*高级分类器*中的逻辑回归配置方面。
- en: 'Starting at the top of the `main()` method, we will get our corpus, which was
    discussed in the earlier three recipes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从`main()`方法的顶部开始，我们将获取我们的语料库，这在前面三道菜谱中已经讨论过：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next up is the feature extractor, which is the actual input to the CRF trainer.
    The only reason it is final is that an anonymous inner class will access it to
    demonstrate how feature extraction works in the next recipe:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是特征提取器，它是CRF训练器的实际输入。它之所以是最终的，唯一的原因是有一个匿名内部类将访问它，以展示在下一道菜谱中特征提取是如何工作的：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will address how this class works later in the recipe.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在菜谱的后面部分讨论这个类的工作方式。
- en: 'The next block of configuration is for the underlying logistic-regression algorithm.
    Refer to the *logistic regression* recipe in [Chapter 3](part0036_split_000.html#page
    "Chapter 3. Advanced Classifiers"), *Advanced Classifiers*, for more information
    on this. Have a look at the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置块是为底层逻辑回归算法准备的。有关此方面的更多信息，请参阅[第3章](part0036_split_000.html#page "第3章。高级分类器")中的*逻辑回归*菜谱，*高级分类器*。请查看以下代码片段：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next up, the CRF is trained with:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下内容训练CRF：
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The rest of the code just uses the standard I/O loop. Refer to [Chapter 2](part0027_split_000.html#page
    "Chapter 2. Finding and Working with Words"), *Finding and Working with Words*,
    for how the `tokenizerFactory` works:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分只是使用了标准的I/O循环。有关`tokenizerFactory`的工作方式，请参阅[第2章](part0027_split_000.html#page
    "第2章。查找和使用单词")，*查找和使用单词*。
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: SimpleCrfFeatureExtractor
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SimpleCrfFeatureExtractor
- en: 'Now, we will get to the feature extractor. The provided implementation closely
    mimics the features of a standard HMM. The class at `com/lingpipe/cookbook/chapter4/SimpleCrfFeatureExtractor.java`
    starts with:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入特征提取器。提供的实现紧密模仿了标准HMM的特征。在`com/lingpipe/cookbook/chapter4/SimpleCrfFeatureExtractor.java`中的类开始于：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `ChainCrfFeatureExtractor` interface requires an `extract()` method with
    the tokens and associated tags that get converted into `ChainCrfFeatures<String>`
    in this case. This is handled by an inner class below `SimpleChainCrfFeatures`;
    this inner class extends `ChainCrfFeatures` and provides implementations of the
    abstract methods, `nodeFeatures()` and `edgeFeatures()`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainCrfFeatureExtractor` 接口需要一个 `extract()` 方法，该方法接受标记和相关标签，这些标签在此情况下被转换为
    `ChainCrfFeatures<String>`。这是通过以下 `SimpleChainCrfFeatures` 下的内部类处理的；这个内部类扩展了 `ChainCrfFeatures`
    并提供了 `nodeFeatures()` 和 `edgeFeatures()` 抽象方法的实现：'
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following constructor access passes the tokens and tags to the super class,
    which will do the bookkeeping to support looking up `tags` and `tokens`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下构造函数传递标记和标签到超类，超类将进行账目管理以支持查找 `tags` 和 `tokens`：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The node features are computed as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 节点特征的计算如下：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The tokens are indexed by their position in the sentence. The node feature for
    the word/token in position `n` is the `String` value returned by the base class
    method `token(n)` from `ChainCrfFeatures` with the prefix `TOK_`. The value here
    is `1.0`. Feature values can be usefully adjusted to values other than 1.0, which
    is handy for more sophisticated approaches to CRFs, such as using the confidence
    estimates of other classifiers. Take a look at the following recipe for an example
    of this.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 标记按其在句子中的位置进行索引。位置 `n` 的单词/标记的节点特征是 `ChainCrfFeatures` 的基类方法 `token(n)` 返回的
    `String` 值，带有前缀 `TOK_`。这里的值是 `1.0`。特征值可以有效地调整到其他值，这对于更复杂的 CRF 方法很有用，例如使用其他分类器的置信估计。以下是一个示例。
- en: 'Like HMMs, there are features that are dependent on other positions in the
    input—these are called **edge features**. The edge features take two arguments:
    one for the position that features are being generated for `n` and `k`, which
    will apply to all other positions in the sentence:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HMMs 一样，有一些特征依赖于输入中的其他位置——这些被称为 **边缘特征**。边缘特征接受两个参数：一个用于为 `n` 和 `k` 生成特征的参数，这将应用于句子中的所有其他位置：
- en: '[PRE58]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The next recipe will address how to modify feature extraction.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法将说明如何修改特征提取。
- en: There's more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is an extensive research literature referenced in the Javadoc and a much
    more exhaustive tutorial on the LingPipe website.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 中引用了广泛的研究文献，LingPipe 网站上还有更详尽的教程。
- en: Modifying CRFs
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 CRFs
- en: The power and appeal of CRFs comes from rich feature extraction—proceed with
    an evaluation harness that provides feedback on your explorations. This recipe
    will detail how to create more complex features.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: CRFs 的强大和吸引力来自于丰富的特征提取——继续使用一个提供反馈的评估工具来探索。这个方法将详细说明如何创建更复杂的特征。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will not train and run a CRF; instead, we will print out the features. Substitute
    this feature extractor for the one in the previous recipe to see them at work.
    Perform the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会训练和运行一个 CRF；相反，我们将打印出特征。用这个特征提取器替换上一个方法中的特征提取器，以查看它们的工作情况。执行以下步骤：
- en: 'Go to a command line and type:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往命令行并输入：
- en: '[PRE59]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The feature extractor class outputs for each token in the training data the
    truth tagging that is being used to learn:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征提取器类为训练数据中的每个标记输出正在使用的真实标签，以用于学习：
- en: '[PRE60]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This reflects the training tagging for the token `John` as determined by `src/com/lingpipe/cookbook/chapter4/TinyPosCorpus.java`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这反映了由 `src/com/lingpipe/cookbook/chapter4/TinyPosCorpus.java` 确定的标记 `John` 的训练标签。
- en: 'The node features follow the top-three POS tags from our Brown corpus HMM tagger
    and the `TOK_John` feature:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点特征遵循来自我们 Brown 语料库 HMM 标签器的三个最高 POS 标签以及 `TOK_John` 特征：
- en: '[PRE61]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, the edge features are displayed for the other tokens in the sentence,
    "John ran":'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，显示句子 "John ran" 中其他标记的边缘特征：
- en: '[PRE62]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The rest of the output are the features for the remaining tokens in the sentence
    and then the remaining sentences in `TinyPosCorpus`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出的其余部分是句子中剩余标记的特征，然后是 `TinyPosCorpus` 中剩余句子的特征。
- en: How it works…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our feature extraction code occurs in `src/com/lingpipe/cookbook/chapter4/ModifiedCrfFeatureExtractor.java`.
    We will start with the `main()` method that loads a corpus, runs the contents
    past the feature extractor, and prints it out:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特性提取代码位于 `src/com/lingpipe/cookbook/chapter4/ModifiedCrfFeatureExtractor.java`。我们将从
    `main()` 方法开始，该方法加载语料库，将内容传递给特征提取器，并打印出来：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We will tee up `TinyPosCorpus` from the previous recipe as our corpus, and then,
    we will create a feature extractor from the containing class. The use of `final`
    is required by referencing the variable in the anonymous inner class that follows.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前步骤中的`TinyPosCorpus`作为我们的语料库，然后，我们将从包含的类中创建一个特征提取器。在匿名内部类中引用变量时需要使用`final`。
- en: 'Apologies for the anonymous inner class, but it is just the easiest way to
    access what is stored in the corpus for various reasons such as copying and printing.
    In this case, we are just generating and printing the features found for the training
    data:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于匿名内部类表示歉意，但这只是访问语料库中存储内容的简单方法，原因有很多，比如复制和打印。在这种情况下，我们只是生成和打印训练数据中找到的特征：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The corpus contains `Tagging` objects, and they, in turn, contain a `List<String>`
    of tokens and tags. Then, this information is used to create a `ChainCrfFeatures<String>`
    object by applying the `featureExtractor.extract()` method to the tokens and tags.
    This will involve substantial computation, as will be shown.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 语料库包含`Tagging`对象，它们反过来包含一个`List<String>`的标记和标记。然后，通过将`featureExtractor.extract()`方法应用于标记和标记来创建一个`ChainCrfFeatures<String>`对象，这将涉及大量的计算，如下所示。
- en: 'Next, we will do reporting of the training data with tokens and the expected
    tagging:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用标记和预期的标记报告训练数据：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we will follow with the features that will be used to inform the CRF
    model in attempting to produce the preceding tagging for nodes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下节点先前标记的节点来告知CRF模型使用的特征：
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, the edge features are produced by the following iteration of relative
    positions to the source node `i`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过以下迭代相对位置到源节点`i`来生成边特征：
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This is it to print out the features. Now, we will address how the feature
    extractor is constructed. We assume that you are familiar with the previous recipe.
    First, the constructor that brings in the Brown corpus POS tagger:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是打印特征的步骤。现在，我们将讨论如何构建特征提取器。我们假设你已经熟悉之前的步骤。首先，引入布朗语料库POS标记器的构造器：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The constructor brings in some external resources for feature generation, namely,
    a POS tagger trained on the Brown corpus. Why involve another POS tagger for a
    POS tagger? We will call the role of the Brown POS tagger a "feature tagger" to
    distinguish it from the tagger we are trying to build. A few reasons to use the
    feature tagger are:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 构造器引入了一些用于特征生成的外部资源，即一个在布朗语料库上训练的POS标记器。为什么要在POS标记器中涉及另一个POS标记器？我们将布朗POS标记器的角色称为“特征标记器”，以区别于我们试图构建的标记器。使用特征标记器的一些原因包括：
- en: We are using a stupidly small corpus for training, and a more robust generalized
    POS feature tagger will help things out. `TinyPosCorpus` is too small for even
    this benefit, but with a bit more data, the fact that there is a feature `at`
    that unifies `the`, `a`, and `some` will help the CRF recognize that `some dog`
    is `'DET'` `'N'`, even though it has never seen `some` in training.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一个非常小的语料库进行训练，一个更健壮的通用POS特征标记器将有助于解决问题。"TinyPosCorpus"对于这种好处来说太小了，但有了更多数据，存在一个将`the`、`a`和`some`统一起来的特征`at`将有助于CRF识别`some
    dog`是`'DET'` `'N'`，即使它从未在训练中看到`some`。
- en: We have had to work with tag sets that are not aligned with POS feature taggers.
    The CRF can use these observations in the foreign tag set to better reason about
    the desired tagging. The simplest case is that `at`, from the Brown corpus tag
    set, maps cleanly onto `DET` in this tag set.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不与不与POS特征标记器对齐的标记集一起工作。CRF可以使用这些观察结果在外国标记集中更好地推理所需的标记。最简单的情况是，来自布朗语料库标记集的`at`在这个标记集中干净地映射到`DET`。
- en: There can be performance improvements to run multiple taggers that are either
    trained on different data or use different technologies to tag. The CRF can then,
    hopefully, recognize contexts where one tagger outperforms others and use this
    information to guide the analysis. Back in the day, our MUC-6 system featured
    3 POS taggers that voted for the best output. Letting the CRF sort it out will
    be a superior approach.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过运行在训练数据上训练的不同数据或使用不同技术进行标记的多个标记器来提高性能。CRF可以，希望如此，识别出某个标记器优于其他标记器的上下文，并使用这些信息来指导分析。在那些日子里，我们的MUC-6系统有3个POS标记器，它们为最佳输出投票。让CRF来解决这个问题将是一个更优越的方法。
- en: 'The guts of feature extraction are accessed with the `extract` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 特征提取的核心可以通过`extract`方法访问：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`ModChainCrfFeatures` is created as an inner class just to keep the proliferation
    of classes to a minimum, and the enclosing class is very lightweight:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModChainCrfFeatures` 被创建为一个内部类，目的是将类的数量保持在最小，并且包含它的类非常轻量级：'
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding constructor hands off the tokens and tags to the super class,
    which handles bookkeeping of this data. Then, the "feature tagger" is applied
    to the tokens, and the resulting output is assigned to the member variable, `mBrownTaggingLattice`.
    The code will access the tagging, one token at a time, so it must be computed
    now.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个构造函数将标记和标签传递给超类，该超类处理此数据的管理。然后，将“特征标记器”应用于标记，并将结果输出分配给成员变量 `mBrownTaggingLattice`。代码将逐个访问标记，因此必须现在计算。
- en: 'The feature creation step happens with two methods: `nodeFeatures` and `edgeFeatures`.
    We will start with a simple enhancement of `edgeFeatures` from the previous recipe:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 特征创建步骤通过两种方法进行：`nodeFeatures` 和 `edgeFeatures`。我们将从对之前食谱中 `edgeFeatures` 的简单增强开始：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The code adds a token-shaped feature that generalizes `12` and `34` into `2-DIG`
    and many other generalizations. To CRF, the similarity of `12` and `34` as two-digit
    numbers is non-existent unless feature extraction says otherwise. Refer to the
    Javadoc for the complete categorizer output.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 代码添加了一个形状为标记的特征，将 `12` 和 `34` 通用于 `2-DIG` 以及许多其他通用的形式。对于 CRF 来说，除非特征提取表明不同，否则
    `12` 和 `34` 作为两位数的相似性是不存在的。请参阅 Javadoc 以获取完整的分类器输出。
- en: Candidate-edge features
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 候选边特征
- en: 'CRFs allow random features to be applied, so the question is what features
    make sense to use. Edge features are used in conjunction with node features, so
    another issue is whether a feature should be applied to edges or nodes. Edge features
    will be used to reason about relationships between the current word/token to those
    around it. Some possible edge features are:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: CRF 允许应用随机特征，因此问题是什么特征是有意义的。边特征与节点特征一起使用，因此另一个问题是特征是否应该应用于边或节点。边特征将用于推理当前单词/标记与其周围标记之间的关系。一些可能的边特征包括：
- en: The token shape (all caps, starts with a number, and so on) of the previous
    token as done earlier.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个标记的形状（全部大写，以数字开头等）与之前所做的相同。
- en: Recognition of iambic pentameter that requires a correct ordering of stressed
    and unstressed syllables. This will require a syllable-stress tokenizer as well.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要正确排列重音和非重音音节的扬抑格识别。这需要音节重音标记器。
- en: It often happens that text contains one or more languages—this is called code
    switching. It is a common occurrence in tweets. A reasonable edge feature will
    be the language of surrounding tokens; this language will better model that the
    next word is likely to be of the same language as the previous word.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本中经常包含一种或多种语言——这被称为代码切换。这在推文中很常见。一个合理的边特征将是周围标记的语言；这将更好地模拟下一个单词可能具有与上一个单词相同的语言。
- en: Node features
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点特征
- en: 'The node features tend to be where the action is in CRFs, and they can get
    very rich. The *Named entity recognition using CRFs with better features* recipe
    in [Chapter 5](part0061_split_000.html#page "Chapter 5. Finding Spans in Text
    – Chunking"), *Finding Spans in Text – Chunking*, is an example. We will add part-of-speech
    tags in this recipe to the token feature of the previous recipe:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 节点特征在 CRF 中往往是最活跃的部分，并且可以变得非常丰富。在 [第 5 章](part0061_split_000.html#page "第 5
    章. 文本中的跨度查找 – 分块") 的 *使用更好的特征的 CRF 命名实体识别* 食谱中，*文本中的跨度查找 – 分块* 是一个例子。我们将在此食谱中添加之前食谱的标记特征：
- en: '[PRE72]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then as in the previous recipe the token feature is added with:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像之前的食谱一样，通过以下方式添加标记特征：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This results in the token string being prepended with `TOK_` and a count of
    `1`. Note that while `tag(n)` is available in training, it doesn't make sense
    to use this information, as that is what the CRF is trying to predict.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致标记字符串被 `TOK_` 预先附加，并计数为 `1`。请注意，虽然 `tag(n)` 在训练中可用，但使用此信息没有意义，因为这正是 CRF 试图预测的内容。
- en: Next, the top-three tags are extracted from the POS feature tagger and added
    with the associated conditional probability. CRFs will be able to work with the
    varying weights productively.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从 POS 特征标记器中提取前三个标签，并添加相关的条件概率。CRF 将能够有效地处理具有不同权重的标签。
- en: There's more…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When generating new features, some thought about the sparseness of data is
    worth considering. If dates were likely to be an important feature for the CRF,
    it would probably not be a good idea to do the standard Computer Science thing
    and convert the date to milliseconds since Jan 1, 1970 GMT. The reason is that
    the `MILLI_1000000000` feature will be treated as completely different from `MILLI_1000000001`.
    There are a few reasons:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成新特征时，考虑数据的稀疏性是值得思考的。如果日期对于CRF来说可能是一个重要的特征，那么做标准的计算机科学事情，将日期转换为自1970年1月1日GMT以来的毫秒数可能不是一个好主意。原因如下：
- en: The underlying classifier does not know that the two values are nearly the same
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层分类器不知道这两个值几乎相同
- en: The classifier does not know that the `MILLI_` prefix is the same—the common
    prefix is only there for human convenience
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类器不知道`MILLI_`前缀是相同的——公共前缀只是为了方便人类
- en: The feature is unlikely to occur in training more than once and will likely
    be pruned by a minimum feature count
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该特征在训练中不太可能多次出现，并且可能会被最小特征计数剪枝
- en: Instead of normalizing dates to milliseconds, consider an abstraction over the
    dates that will likely have many instances in training data, such as the `has_date`
    feature that ignores the actual date but notes the existence of the date. If the
    date is important, then compute all the important information about the date.
    If it is a day of the week, then map to days of the week. If temporal order matters,
    then map to coarser measurement that is likely to have many measurements. Generally
    speaking, CRFs and the underlying logistic regression classifier are robust against
    ineffective features, so feel free to be creative—you are unlikely to make accuracy
    worse by adding features.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与将日期规范化为毫秒数不同，考虑对训练数据中可能存在多个实例的日期进行抽象，例如`has_date`特征，它忽略实际日期但记录日期的存在。如果日期很重要，那么计算所有关于日期的重要信息。如果它是星期几，那么映射到星期几。如果时间顺序很重要，那么映射到更粗略的测量，这种测量可能有很多测量值。一般来说，条件随机场（CRFs）及其底层的逻辑回归分类器对无效特征具有鲁棒性，所以请随意发挥创意——添加特征不太可能降低准确性。
