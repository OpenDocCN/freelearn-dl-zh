["```py\nusing UnityEngine;\nusing System.Collections;\npublic class UnityFlock : MonoBehaviour { \n    public float minSpeed = 20.0f;\n    public float turnSpeed = 20.0f; \n    public float randomFreq = 20.0f;\n    public float randomForce = 20.0f;\n    //alignment variables\n    public float toOriginForce = 50.0f;\n    public float toOriginRange = 100.0f;\n    public float gravity = 2.0f;\n    //seperation variables\n    public float avoidanceRadius = 50.0f;\n    public float avoidanceForce = 20.0f;\n    //cohesion variables\n    public float followVelocity = 4.0f;\n    public float followRadius = 40.0f;\n    //these variables control the movement of the boid\n    private Transform origin;\n    private Vector3 velocity;\n    private Vector3 normalizedVelocity;\n    private Vector3 randomPush;\n    private Vector3 originPush;\n    private Transform[] objects;\n    private UnityFlock[] otherFlocks;\n    private Transform transformComponent;\n    private float randomFreqInterval;\n```", "```py\nvoid Start () {\n    randomFreqInterval = 1.0f / randomFreq;\n    // Assign the parent as origin \n    origin = transform.parent;\n    // Flock transform \n    transformComponent = transform;\n    // Temporary components \n    Component[] tempFlocks= null;\n    // Get all the unity flock components from the parent \n    // transform in the group \n    if (transform.parent) {\n        tempFlocks = transform.parent\n          .GetComponentsInChildren<UnityFlock>();       \n    }\n    // Assign and store all the flock objects in this group \n    objects = new Transform[tempFlocks.Length];\n    otherFlocks = new UnityFlock[tempFlocks.Length];\n    for (int i = 0;i<tempFlocks.Length;i++) { \n        objects[i] = tempFlocks[i].transform;\n        otherFlocks[i] = (UnityFlock)tempFlocks[i];\n    }\n    // Null Parent as the flock leader will be \n    // UnityFlockController object \n    transform.parent = null;\n    // Calculate random push depends on the random \n    // frequency provided\n    StartCoroutine(UpdateRandom());\n}\n```", "```py\n    IEnumerator UpdateRandom() { \n        while (true) {\n            randomPush = \n              Random.insideUnitSphere * randomForce;\n            yield return new WaitForSeconds(\n              randomFreqInterval + Random.Range(\n                -randomFreqInterval / 2.0f, \n                randomFreqInterval / 2.0f));\n        }\n    }\n    ```", "```py\n    void Update() {\n            //Internal variables\n            float speed = velocity.magnitude;\n            Vector3 avgVelocity = Vector3.zero;\n            Vector3 avgPosition = Vector3.zero;\n            int count = 0;\n            Vector3 myPosition = \n              transformComponent.position;\n            Vector3 forceV;\n            Vector3 toAvg;\n            for (int i = 0; i < objects.Length; i++) {\n                Transform boidTransform = objects[i];\n                if (boidTransform != transformComponent) {\n                    Vector3 otherPosition =\n                      boidTransform.position;\n                    // Average position to calculate \n                    // cohesion\n                    avgPosition += otherPosition;\n                    count++;\n                    //Directional vector from other flock\n                    // to this flock\n                    forceV = myPosition - otherPosition;\n                    //Magnitude of that directional \n                    //vector(Length)\n                    float directionMagnitude = \n                      forceV.magnitude;\n                    float forceMagnitude = 0.0f;\n                    if (directionMagnitude < followRadius)\n                    {\n                        if (directionMagnitude <\n                             avoidanceRadius) {\n                            forceMagnitude = 1.0f – \n                              (directionMagnitude / \n                               avoidanceRadius);\n                            if (directionMagnitude > 0)\n                                avgVelocity += (forceV /\n                                  directionMagnitude) *\n                                  forceMagnitude * \n                                  avoidanceForce;\n                        }\n                        forceMagnitude =\n                          directionMagnitude / \n                          followRadius;\n                        UnityFlock tempOtherBoid = \n                          otherFlocks[i];\n                        avgVelocity += followVelocity *\n                          forceMagnitude * \n                         tempOtherBoid.normalizedVelocity;\n                    }\n                }\n            }\n    ```", "```py\n            if (count > 0) {\n                //Calculate the average flock\n               //velocity(Alignment)\n                avgVelocity /= count;\n                //Calculate Center value of the \n                //flock(Cohesion)\n                toAvg = (avgPosition / count) –\n                  myPosition;\n            } else {\n                toAvg = Vector3.zero;\n            }\n            //Directional Vector to the leader\n            forceV = origin.position - myPosition;\n            float leaderDirectionMagnitude = \n              forceV.magnitude;\n            float leaderForceMagnitude =\n              leaderDirectionMagnitude / toOriginRange;\n            //Calculate the velocity of the flock to the\n            //leader\n            if (leaderDirectionMagnitude > 0)\n                originPush = leaderForceMagnitude * \n                  toOriginForce * (forceV /\n                  leaderDirectionMagnitude);\n            if (speed < minSpeed && speed > 0) {\n                velocity = (velocity / speed) * minSpeed;\n            }\n            Vector3 wantedVel = velocity;\n            //Calculate final velocity\n            wantedVel -= wantedVel * Time.deltaTime;\n            wantedVel += randomPush * Time.deltaTime;\n            wantedVel += originPush * Time.deltaTime;\n            wantedVel += avgVelocity * Time.deltaTime;\n            wantedVel += gravity * Time.deltaTime * \n              toAvg.normalized;\n            velocity = Vector3.RotateTowards(velocity,\n              wantedVel, turnSpeed * Time.deltaTime, \n              100.00f);\n            transformComponent.rotation =\n              Quaternion.LookRotation(velocity);\n            //Move the flock based on the calculated\n            //velocity\n            transformComponent.Translate(velocity * \n              Time.deltaTime, Space.World);\n            normalizedVelocity = velocity.normalized;\n        }\n    ```", "```py\nusing UnityEngine;\nusing System.Collections;\npublic class UnityFlockController : MonoBehaviour { \n    public Vector3 bound;\n    public float speed = 100.0f;\n    public float targetReachedRadius = 10.0f;\n    private Vector3 initialPosition;\n    private Vector3 nextMovementPoint;\n    // Use this for initialization \n    void Start () {\n        initialPosition = transform.position;\n        CalculateNextMovementPoint();\n    }\n    // Update is called once per frame \n    void Update () {\n        transform.Translate(Vector3.forward * speed * \n          Time.deltaTime);\n        transform.rotation = \n          Quaternion.Slerp(transform.rotation,\n            Quaternion.LookRotation(nextMovementPoint –\n            transform.position), 1.0f * Time.deltaTime);\n        if (Vector3.Distance(nextMovementPoint, \n            transform.position) <= targetReachedRadius) \n            CalculateNextMovementPoint();\n    }\n```", "```py\nvoid CalculateNextMovementPoint () {\n    float posX = Random.Range(initialPosition.x - bound.x,\n      initialPosition.x + bound.x);\n    float posY = Random.Range(initialPosition.y - bound.y, \n      initialPosition.y + bound.y);\n    float posZ = Random.Range(initialPosition.z - bound.z,\n      initialPosition.z + bound.z);\n    nextMovementPoint = initialPosition + new Vector3(posX,\n      posY, posZ);\n}\n```", "```py\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\npublic class Flock : MonoBehaviour { \n    internal FlockController controller;\n    private new Rigidbody rigidbody;\n    private void Start() {\n        rigidbody = GetComponent<Rigidbody>();\n    }\n    void Update () {\n        if (controller) {\n            Vector3 relativePos = Steer() * Time.deltaTime;\n            if (relativePos != Vector3.zero)\n              rigidbody.velocity = relativePos;\n            // enforce minimum and maximum speeds for the\n            // boids \n            float speed = rigidbody.velocity.magnitude;\n            if (speed > controller.maxVelocity) {\n                rigidbody.velocity =\n                  rigidbody.velocity.normalized *\n                  controller.maxVelocity;\n            } else if (speed < controller.minVelocity) {\n                rigidbody.velocity =\n                  rigidbody.velocity.normalized *\n                  controller.minVelocity;\n            }\n        }\n    }\n```", "```py\nprivate Vector3 Steer () {\n    Vector3 center = controller.flockCenter – \n      transform.localPosition;   // cohesion\n    Vector3 velocity = controller.flockVelocity –\n      rigidbody.velocity; // allignement\n    Vector3 follow = controller.target.localPosition – \n      transform.localPosition; // follow leader\n    Vector3 separation = Vector3.zero;\n    foreach (Flock flock in controller.flockList) { \n        if (flock != this) {\n            Vector3 relativePos = transform.localPosition - \n              flock.transform.localPosition;\n            separation += relativePos.normalized;\n        }\n    }\n    // randomize\n    Vector3 randomize = new Vector3( (Random.value * 2) –\n      1, (Random.value * 2) - 1, (Random.value * 2) - 1);\n    randomize.Normalize();\n    return (controller.centerWeight * center + \n            controller.velocityWeight * velocity + \n            controller.separationWeight * separation +\n            controller.followWeight * follow + \n            controller.randomizeWeight * randomize);\n}\n```", "```py\n    using UnityEngine;\n    using System.Collections;\n    using System.Collections.Generic;\n    public class FlockController : MonoBehaviour { \n        public float minVelocity = 1;\n        public float maxVelocity = 8;\n        public int flockSize = 20;\n        public float centerWeight = 1;\n        public float velocityWeight = 1;\n        public float separationWeight = 1;\n        public float followWeight = 1;\n        public float randomizeWeight = 1;\n        public Flock prefab; \n        public Transform target;\n        Vector3 flockCenter;\n        internal Vector3 flockVelocity;\n        public ArrayList flockList = new ArrayList();\n        void Start () {\n            for (int i = 0; i < flockSize; i++) {\n                Flock flock = Instantiate(prefab,\n                  transform.position, transform.rotation)\n                  as Flock;\n                flock.transform.parent = transform;\n                flock.controller = this;\n                flockList.Add(flock);\n            }\n        }\n    ```", "```py\n        void Update() {\n            //Calculate the Center and Velocity of the\n            // whole flock group\n            Vector3 center = Vector3.zero;\n            Vector3 velocity = Vector3.zero;\n            foreach (Flock flock in flockList) {\n                    center += \n                      flock.transform.localPosition;\n                    velocity += flock.GetComponent\n                      <Rigidbody>().velocity;\n            }\n            flockCenter = center / flockSize;\n            flockVelocity = velocity / flockSize;\n        }\n    }\n    ```", "```py\n    using UnityEngine;\n    using System.Collections;\n    public class TargetMovement : MonoBehaviour {\n        // Move target around circle with tangential speed\n        public Vector3 bound;\n        public float speed = 100.0f;\n        public float targetReachRadius = 10.0f;\n        private Vector3 initialPosition;\n        private Vector3 nextMovementPoint;\n        void Start () {\n            initialPosition = transform.position;\n            CalculateNextMovementPoint();\n        }\n        void CalculateNextMovementPoint () {\n            float posX = Random.Range(initialPosition.x =\n              bound.x, initialPosition.x+bound.x);\n            float posY = Random.Range(initialPosition.y = \n              bound.y, initialPosition.y+bound.y);\n            float posZ = Random.Range(initialPosition.z =\n              bound.z, initialPosition.z+bound.z);\n            nextMovementPoint = initialPosition + \n              new Vector3(posX, posY, posZ);\n        }\n        void Update () {\n            transform.Translate(Vector3.forward * speed *\n              Time.deltaTime); \n            transform.rotation = \n              Quaternion.Slerp(transform.rotation,\n            Quaternion.LookRotation(nextMovementPoint –\n              transform.position), Time.deltaTime);\n            if (Vector3.Distance(nextMovementPoint,\n              transform.position) <= targetReachRadius)\n              CalculateNextMovementPoint();\n        }\n    }\n    ```"]