- en: '*Chapter 9*: Programming RGB Strips in Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LED lights can be used with a robot to debug and give it feedback so that the
    code running on the robot can show its state. Colored RGB LEDs let you mix the
    red, green, and blue components of light to make many colors, adding brightness
    and color to a robot. We have not paid much attention to making it look fun, so
    this time we will focus on that.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing different sequences of LEDs can be used to convey information in real
    time. You can use which are on/off, their brightness, or their color to represent
    information. This feedback is easier to read than a stream of text, which will
    help as sensors are added to the robot. This also means the code on the robot
    can show state without relying on the SSH terminal to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an RGB strip?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing light strip technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching the light strip to the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a robot display a code object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the light strip for debugging the avoid behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a rainbow display with LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build this you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with internet access and Wi-Fi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot, a Raspberry Pi, and the code from the previous chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pimoroni LED SHIM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is on GitHub at [https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9](https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the video at the following link to see the Code in Action: [https://bit.ly/39vglXm](https://bit.ly/39vglXm).'
  prefs: []
  type: TYPE_NORMAL
- en: What is an RGB strip?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using lights to display data can be a simple yet flexible way to get data to
    the user without connecting a full display. For example, a single light could
    be turned on or off to indicate whether a robot is powered on or the state of
    a simple sensor. A multicolor light can change color to show more detail, to indicate
    a few different states that the robot is in. RGB in this chapter stands for Red-Green-Blue,
    so by controlling the intensity levels of these color channels in a light, multiple
    colors can be shown. We'll investigate how this happens later in the *RGB values*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple lights lets you show more data. These can be in a strip (a line
    of lights), as well as panels/matrixes, rings, and other interesting shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing light strip technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many competing technologies for lights and light strips. For light
    types, incandescent lights, such as old light bulbs, tend to use a lot of power
    and take up too much space to be useful in robots. Fluorescent lights, such as
    kitchen strips or curly compact types, need complex power systems that also take
    up too much space. Electroluminescent wire, also known as EL wire, is often used
    to decorate objects by outlining them; it looks interesting but is tricky to control.
    **Light Emitting Diode** (**LED**) technology is low power and tends to be small
    and easy to control, which makes it best suited for robots such as ours. LEDs
    are also cheap.
  prefs: []
  type: TYPE_NORMAL
- en: The most useful kind, in our case, which we will use in this chapter, are addressable
    RGB LEDs. Addressable means that each individual LED in the strip can be set to
    different colors and brightness, allowing a sequence of colors along the strip.
    To keep it simple, we will use a type with a built-in controller.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.1* shows some of the types of addressable RGB LED configurations
    I have experimented with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Types of addressable RGB LEDs
  prefs: []
  type: TYPE_NORMAL
- en: All of these LED controllers take a stream of data. Some types, such as the
    Neopixel, WS2812, SK9822, APA102C, DotStar, and 2801 types, take the red, green,
    and blue components that they need, and then pass the remaining data to the next
    LED. Designers arrange these LEDs into strips, rings, or square matrixes, chaining
    them to take advantage of how they pass the data along. The LED strips can come
    as rigid sticks or as flexible strips on a reel. For our robot, eight or more
    LEDs make for a great display.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some completely different technologies, such as the LED SHIM
    from Pimoroni and LED matrices in color using shift registers. The Pimoroni LED
    SHIM is one of the easiest to use (with a Raspberry Pi) of the LED strips. It
    houses a controller (the IS31FL3731), which is controlled over the I2C data bus.
    The Pimoroni LED SHIM has 24 LEDs, which is more than enough to cater to our needs.
    It doesn't need any extra power handling and is also widely available.
  prefs: []
  type: TYPE_NORMAL
- en: Our robot uses the I2C data bus for the motor controller, which happily shares
    with other devices, such as the LED SHIM, by having a different address. I2C instructions
    are sent as an address for the device, followed by an I2C register to write and
    a value for it.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its simplicity and compatibility with our robot, I will continue
    this chapter with the Pimoroni LED SHIM. This can be bought from Mouser Electronics
    in most countries, along with Pimoroni, Adafruit, and SparkFun.
  prefs: []
  type: TYPE_NORMAL
- en: RGB values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The colors red, green, and blue can mix to make almost any color combination.
    Systems express these as RGB values. RGB is the same principle used by most, if
    not all, color display screens you see. TVs, mobile phones, and computer screens
    use this. Multicolor LEDs use the same principle to produce many colors. Code
    usually specifies the amounts of each color to mix as three-number components,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The RGB color space [SharkD / CC BY-SA (https://creativecommons.org/licenses/by-sa/3.0)]
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in *Figure 9.2* shows an RGB color cube. It has arrows showing axes
    for increasing each of the red, green, and blue components. The exposed surfaces
    of the cube show different shades and intensities as the color combinations mix
    throughout the cube.
  prefs: []
  type: TYPE_NORMAL
- en: The corner to the bottom-front-right is blue, the top-front-right is turquoise
    (mixing blue and green), the bottom-front-left is purple (mixing red and blue),
    the bottom-far-left is red (with no green or blue), and the top-far-left is yellow
    (high red and green, no blue).
  prefs: []
  type: TYPE_NORMAL
- en: As each value is increased, we get different colors from them being mixed. The
    top-front-left corner would be the maximum of all three – white. The bottom-rear-right
    corner would be the minimum of all three – black. The cutout shows a color with
    intensities as fractions.
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we will use numbers ranging from 0 for absolutely turned off to
    255 for full intensity, with values in between for many levels of intensity. The
    colors are mixed by adding, so adding all of them at full brightness makes white.
  prefs: []
  type: TYPE_NORMAL
- en: Although this theoretically gives many colors, in practice, the differences
    between the intensity of 250 and 255 are not discernible on most RGB LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen some of the LED technologies and a little information about how
    to mix colors for them. We have also made a decision about which technology to
    use, the Pimoroni LED SHIM. Since we'll be attaching this to our robot, please
    buy one and come back for the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the light strip to the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we write code to display color sequences on the LED SHIM, we need to
    attach it to the Raspberry Pi on our robot. After we have finished this section,
    the robot block diagram will look as in *Figure 9.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The robot block diagram with the LED strip
  prefs: []
  type: TYPE_NORMAL
- en: The block diagram now shows the LED strip connected to the Raspberry Pi, with
    an arrow indicating information flow from the Raspberry Pi to the strip. The strip
    is highlighted as a new addition to the system. Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the LED strip to the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Pimoroni LED SHIM attaches quite readily to the Raspberry Pi. We put it
    on top of the motor controller, with its pass-through header, so that we can see
    the lights on top. Take a look at *Figure 9.4* to see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Fitting the LEDs
  prefs: []
  type: TYPE_NORMAL
- en: 'Use *Figure 9.4* with the following steps to attach the strip:'
  prefs: []
  type: TYPE_NORMAL
- en: The strip is small. Line the strip up with the header pins coming from the top
    of the motor HAT. You will need to unplug the wires already plugged into the Raspberry
    Pi to add the SHIM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wider part should be sticking out from the HAT. Gently push the SHIM onto
    the pins, only a little at first, working across the strip until all the pins
    are in the holes – it is slightly stiff but should grip on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the pins are in, evenly push the SHIM down so that the pins mostly
    stick out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you'll need to replace the wires. Refer to *Figure 8.15* in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, for the distance sensor wiring information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you've attached the LED SHIM, this robot is ready to light up. Let's
    program it.
  prefs: []
  type: TYPE_NORMAL
- en: Making a robot display the code object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we are building around the Pimoroni LED SHIM, we've already seen that
    there are other types of RGB LED systems. Since we might later swap the SHIM out
    for a different system, it would be a good idea to make an interface on top of
    the LEDs. Like the motor's interface, this decouples handling hardware and making
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Making an LED interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what interface do we want for the LEDs? First, we want them to be available
    on the robot as `robot.leds`. We want to clear the LEDs (turn them all off), set
    each individual LED to a different color, and set a bunch/range of LEDs to a list
    of colors.
  prefs: []
  type: TYPE_NORMAL
- en: It's useful for the code to tell us how many LEDs we have, so if the number
    changes, the animations or displays still make some sense.
  prefs: []
  type: TYPE_NORMAL
- en: For the colors, we use three values – `r`, `g`, and `b` – to represent the red,
    green, and blue components. Python has a type called a `color` as a parameter,
    this is a tuple of `(r, g, b)`.
  prefs: []
  type: TYPE_NORMAL
- en: The LEDs in strips are addressable, so our code uses an LED number starting
    at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a structure, our code starts with `robot.leds`. `leds` will be a member
    of the existing `robot` class. It is an object with these members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_one(led_number, color)`: This sets one LED at `led_number` to the specified
    color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_range(led_range, color)`: This sets all the LEDs defined by a Python iterable
    `led_range` to `color`. A Python iterable can be a list of LED numbers [`0`, `3`],
    or it can be a range made using the `range` function. For example, `range(2,8)`
    creates the list `[2, 3, 4, 5, 6, 7]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_all(color)`: This sets all of the LEDs to the color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This clears all of the LEDs to black, turning them all off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show()`: All of the other methods prepare a display, allowing you to set combinations
    of LEDs. Nothing is updated on the LED device until your code calls this. This
    method reflects how most LED strips expect to set all the LEDs from one stream
    of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: This holds the number of LEDs in the strip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keeping the preceding points in mind, let''s write this code for the LED SHIM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the LED SHIM library. So, on the Raspberry Pi, type
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our code must start by importing this and setting up the device. Put the following
    code in `leds_led_shim.py` (named after the device type):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create the methods to interact with the strip. Setting a single LED
    is fairly straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Setting a bunch of LEDs is also a simple wrapper in our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want a way to set all of the LEDs. This code is similar to setting
    a single LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s add a method for clearing the LEDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need the `show` code, to send the colors we''ve configured to the
    LEDs. The Pimoroni LED SHIM library has made this very simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have installed the LED SHIM library and created an interface for ourselves.
    We can use this interface to communicate with the LEDs, and it is designed to
    be swapped out for compatible code for a different type of LED device. Now, we'll
    make this LED interface available in our `Robot` object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding LEDs to the Robot object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we update our `robot.py` file to deal with an LED system. For this, we
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `leds_led_shim` file to the imports (the new code is in
    bold):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add an instance of the SHIM to the constructor (`init`) method for
    `Robot` (the new code is in bold):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we have to stop more than just the motors, we''ll swap `stop_motors` for
    a new `stop_all` method in the `atexit` call to stop other devices (such as the
    LEDs) too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `stop_all` method, which stops the motors and clears the LEDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The complete code can be found at [https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9](https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have now added support for the LEDs to the `Robot` class, making the interface
    we designed earlier available, and ensuring that the LEDs are cleared when the
    robot code exits. Next, we will start testing and turning on LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing one LED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have installed some hardware, along with a library for it, and then added
    code to make this available in our robot. However, before we go further, we should
    make sure that everything works with a test. This is a good place to find any
    problems and troubleshoot them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try testing a single LED. One aspect of our robot running Python that
    we''ve not explored is that it can run the Python **REPL** – **read, eval, print
    loop**. What that means is you can start Python and immediately type code to run
    there. We''ll use this to test our LEDs a little:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `leds_led_shim.py` and `robot.py` code onto the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SSH into the robot, and just type `python3`. The Raspberry Pi should respond
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s get our `robot` library ready to use. Type the parts shown in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try turning on an LED, setting it to red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hmm – nothing happened. Remember, we need to call `leds.show` to display our
    setting on them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now see a single red LED.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try and set another to purple by mixing red and blue LEDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To stop this session, press *Ctrl* +*D* on an empty line. The `atexit` code
    automatically turns all the LEDs off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have seen an LED working and lighting up in multiple colors.
    This demonstrates that the code so far is good. If not, please refer to the following
    section. If this is all working, skip on ahead to the *Testing all LEDs* section.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you encounter problems trying to light the LEDs, there are some troubleshooting
    steps you can take.
  prefs: []
  type: TYPE_NORMAL
- en: 'If running the code shows errors, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check that you have enabled I2C (as shown in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `sudo i2cdetect -y 1`, as seen in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*. You should see the LEDs at the address
    `74`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that you have installed the `ledshim` Python package with `pip3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carefully check the code for mistakes and errors. If it's the code from GitHub,
    create an issue!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the LEDs do not light at all, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the example code that comes with the SHIM at [https://github.com/pimoroni/led-shim/tree/master/examples](https://github.com/pimoroni/led-shim/tree/master/examples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure you have installed the LEDs the correct way around, as shown in *Figure
    9.4*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure you have evenly pushed the LED strip down onto the header pins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you remember to use `leds.show()`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these troubleshooting tips, you will have eliminated the most common
    issues with this system. You should now have a working LED and be able to proceed
    to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing all LEDs
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can try the `set_all` method. We''ll make something that simply flashes
    a couple of different colors on the LEDs. Create a file called `leds_test.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need imports. We need to import our `R``obot` library and `time`
    to animate this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s set up our bot, along with a couple of named colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next part is the main loop. It alternates between the two colors, with
    `sleep`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have uploaded these files to the Raspberry Pi, type the following
    to show the red/blue alternating LED display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press *Ctrl* + *C* on the terminal to stop this running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now shown all the LEDs working. This has also shown them switching between
    different colors, using timing to produce a very simple animation. We can build
    on this, producing more interesting uses of color and animation, but first, we
    will divert to learn a bit more about mixing colors.
  prefs: []
  type: TYPE_NORMAL
- en: Making a rainbow display with the LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we get to use these for some fun. We will extend our avoiding behavior from
    the previous chapter to show rainbow bar graphs on a side corresponding to the
    distances read. We could also use this for sensors. Before we can link the movement
    to the animation, how is a rainbow created?
  prefs: []
  type: TYPE_NORMAL
- en: Colour systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RGB is how the hardware expects colors. However, RGB is less convenient for
    expressing intermediate colors or creating gradients between them. Colors that
    appear close to the eye can be a little far apart when in RGB. Because of this,
    there are other color systems.
  prefs: []
  type: TYPE_NORMAL
- en: The other color system we use is **Hue, Saturation, and Value** (**HSV**). We
    use HSV in this chapter to make rainbow-type displays and when doing computer
    vision in a later chapter to assist our code in detecting objects.
  prefs: []
  type: TYPE_NORMAL
- en: Hue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine taking the colors of the spectrum and placing them on a circle, blending
    through red to orange, orange to yellow, yellow to green, green to blue, blue
    to purple, and back around to red. The **hue** expresses a point around this circle.
    It does not affect the brightness of the color or how vivid it is. *Figure 9.5*
    shows how we can represent these points on a color wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – A color wheel of hues
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9.5*, the circle shows that around 0 degrees, a red hue is seen.
    The compass points around the circle correspond to different colors. Colors are
    blended as you move around from one hue to another. You may have seen something
    like this in a color wheel gadget on a painting or drawing computer program. A
    continuous wheel setup like this is what lets us make a rainbow.
  prefs: []
  type: TYPE_NORMAL
- en: Saturation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you take a color such as red, it can be a grayish/dull red or a vivid, intense
    red. **Saturation** is an expression of the vividness of the color. As you go
    toward zero, it only makes shades of gray. As we increase the saturation, color
    begins to emerge – first in pastel tones, through to poster colors, and then to
    a striking hazard sign or pure colors at the high end of the saturation scale.
  prefs: []
  type: TYPE_NORMAL
- en: Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **value** of the color is its brightness. It ranges from black at 0, through
    to a very dark version of the color, to a very bright color. Note that this does
    not approach white (in other words, pink colors), but a very bright red. To make
    a white color, you need to reduce the saturation too. Other color systems (such
    as HSL) specify a *light* component that would make things white this way.
  prefs: []
  type: TYPE_NORMAL
- en: Converting HSV to RGB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are complicated formulas to convert between one color system to another.
    However, Python can make this conversion itself.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `colorsys.hsv_to_rgb` to make this conversion. It accepts the three
    HSV components as fractions between 0 and 1, inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the hue component, 0 is the start of the circle, 0.5 represents
    180 degrees, the half circle, and 1 is all the way around to 360, the full circle.
  prefs: []
  type: TYPE_NORMAL
- en: The saturation component at 0 is gray, fully desaturated, and 1 is the most
    intense color.
  prefs: []
  type: TYPE_NORMAL
- en: The value component at 0 is black, fully dark, and at 1 is the brightest – a
    fully lit color.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a bright cyan color, we would go past the half circle to about 0.6
    for hue, 1.0 for saturation, and 1.0 for value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not enough. The output from the `colorsys` call is a tuple,
    a collection of three items for the R, G, and B components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output components are in terms of 0 to 1.0, too. Most RGB systems expect
    values between 0 and 255\. To use them, we need to convert these values back up
    by multiplying them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line, we loop over each component, `c`, and multiply it by
    255\. By putting a `for` loop in square brackets like that in Python, we can loop
    over elements, and put the result back into a list.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to convert HSV values to RGB, let's use this information
    to make a rainbow.
  prefs: []
  type: TYPE_NORMAL
- en: Making a rainbow on the LEDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use our color system understanding to make a rainbow on the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – LEDs showing a rainbow on the robot
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.6* shows a rainbow being displayed on the LEDs attached to the robot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this! Make a new file called `led_rainbow.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over this file line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: This code starts by importing `colorsys`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define a function, `show_rainbow`, which takes two parameters, a link to
    our LEDs system (which would usually be given `robot.leds`) and an LED range to
    set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we want to know the length of our LED range, we need to make sure it
    is a list, so we cast this on the first line of our function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a rainbow, the hue value should sweep a full circle. In Python, `colorsys`
    is the values from 0 to 1\. We want to advance the hue a fraction of a step for
    each LED in the range. By dividing 1.0 by the number of LEDs in a range, we get
    this fraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then loop over the LEDs. `enumerate` gives us an index while `led_address`
    advances. This code makes no assumptions about the range so that it could use
    an arbitrary list of LEDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then multiply `hue_step` and `index` to give the `hue` value, the right fraction
    of 1.0 to use. The following line converts this into an RGB value with a fixed
    saturation and brightness value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because `colorsys` outputs values between 0 and 1, the code needs to multiply
    this by 255 and make the resulting number into an integer: `rgb = [int(c*255)
    for c in rgb]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code uses the `leds.set_one` method with this RGB value and the LED address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s test this with a file called `test_rainbow.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is quite similar to our previous red/blue test. However, in the first section,
    we use the `show_rainbow` function, which the code has imported from `led_rainbow`.
    It passed in the robot's LEDs and makes a range covering all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The code waits for half a second and then clears the LEDs for half a second.
    These are in a loop to make an on/off rainbow effect. Start this with `python3
    test_rainbow.py`, and use *Ctrl* + *C* to stop it after seeing it work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've seen some simple animation and multicolor LED usage, we can
    take this to the next level by making the LEDs respond to sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Using the light strip for debugging the avoid behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LEDs in rainbows are fun, and switching colors looks nice. However, LEDs can
    be used for practical purposes too. In [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, we added sensors to our robot to avoid
    obstacles. You can follow along in a PuTTY window, and see what the sensors are
    detecting by reading the numbers. But we can do better; with the light strip,
    we can put information on the robot to tell us what it is detecting.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will tie the LED output together to values from a behavior,
    first by basic lighting, and then by making some rainbow colors, too.
  prefs: []
  type: TYPE_NORMAL
- en: Adding basic LEDs to the avoid behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get fancy and reintroduce the rainbow, let's start with the basic
    version. The intent here will be to make two *indicator* bars to the left and
    right side of the LED bar. For each bar, more LEDs will light when the corresponding
    distance sensor detects a closer obstacle. We'll make it so that the bars go into
    the middle, so when a single outer LED is lit, the obstacle is far away. When
    most or all of the LEDs on one side are lit, the obstacle is much closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a few parts to our avoid behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Some variables to set up the LED display, and how our distances map to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to convert a distance in to how many LEDs to show
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to display the state of our sensors on the LEDs using the preceding
    items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To call the `display_state` method from the behavior's main loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to incorporate the preceding points. Open the `avoid_behavior.py`
    file that you made in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use the LEDs in this behavior, we need to separate them into
    the bars. In the `__init__` method of `ObstacleAvoidingBehavior`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need a color for the LEDs when sensing. I chose red. I encourage you
    to try another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the variables'' setup out of the way, let''s add a method for converting
    the distance into LEDs. I added this after the `__init__` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The distances are in terms of meters, with 1.0 being 1 meter, so subtracting
    the distance from 1.0 inverts this. The `max` function will return the largest
    of the two values, here it is used to ensure we don''t go below zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we multiply this number, some fraction between 0 and 1, by the `self.led_half`
    value to get the number of LEDs to use. We round it up and turn this into an integer
    with `int(round())`, as we can only have a whole number of LEDs turned on. Rounding
    means that after our multiplication, if we end up with a value such as 3.8, we
    round it up to 4.0, then convert it into an integer to light four LEDs. We add
    1 to this so that there''s always at least one LED, and then return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next method is a trickier one; it will create the two bars. Let''s start
    by declaring the method and clearing the LEDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the left bar, we convert the left sensor distance to the number of LEDs,
    then create a range covering 0 to this number. It uses the `set_range` method
    to set a bunch of LEDs to `sense_color`. Note that your LEDs might be the other
    way around, in which case swap `left_distance` and `right_distance` in this `display`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The right side is trickier; after converting to an LED count, we need to create
    a range for the LEDs. The variable `led_bar` holds the number of LEDs to light.
    To light the right of the bar, we need to subtract this from the count of the
    LEDs to find the first LED, and create a range starting there to the total length.
    We must subtract 1 from the length – otherwise it will count 1 LED too far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to show the display we''ve now made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then display our readings on the LEDs by calling `display_state` inside
    the behavior''s `run` method. Here are a couple of lines for context, with the
    extra line highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save this, send it to the Raspberry Pi, and run it. When it's running, you should
    be able to see the LEDs light up in a bar based on the distance. This is both
    satisfying and gives a good feel for what the robot is detecting. Let's make this
    a little more interesting by adding rainbows.
  prefs: []
  type: TYPE_NORMAL
- en: Adding rainbows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use our LED rainbow to make our distance-sensing demo even more fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Distance sensor rainbow bars
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.7* shows a photo of the rainbow bars for each distance sensor. This
    is a great visual demonstration of the LEDs animating.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we added a library for showing rainbows, we can reuse it here. Let''s
    see how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `avoid_behaviour.py` code from the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top, import `led_rainbow` so that we can use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our existing code displayed a bar for the left. Instead of a bar, display a
    rainbow here. We need to ensure we have at least one item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, the right side will be a little bit trickier; as we want the rainbow
    to go the other way, we need to make the range count backward for the rainbow
    too. The Python `range` function, along with the `start` and `end` parameters,
    takes a step parameter. By making a step of -1, we can count down in the range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upload this and run it, and the bar graph will be in rainbow colors instead
    of a solid color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have gone from a single LED to a number of LEDs. With some work on color
    systems, we were able to generate a rainbow and use it to show the status of a
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to interact with and use RGB LEDs, as well
    as how to choose and buy RGB LED strips that work with the Raspberry Pi. You learned
    how to make code for the LEDs on the robot, using them with robot behaviors. You
    also saw how the HSV color system works, which can be used to generate rainbows.
  prefs: []
  type: TYPE_NORMAL
- en: You can take the techniques used here to add LED-based status displays to robots
    and write code to link them with behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at servo motors and build a pan and tilt mechanism
    for moving sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try mixing a different RGB color, or looking one up, and using `set_one`, `set_all`,
    or `set_range` to light LEDs in that color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the show left rainbow and show right rainbow functions to make the robot
    turn on rainbows corresponding to the side it's turning to in the `behaviour_path`
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By making a timer loop and advancing an index or changing a range, it would
    be possible to animate the rainbows or make them *scan* across the LED bar. Try
    this out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Could the other parts of the HSV color be used to make pulsing LED strips that
    change brightness?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Make Electronics: Learning by Discovery*, *Charles Platt*, *Make Community,
    LLC*: I''ve only started to cover some basic electronics with the switch and breadboard.
    To get a real feel for electronics, *Make Electronics* is a superb introduction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more advanced electronics, try *Practical Electronics for Inventors, Fourth
    Edition*, *Paul Scherz*, *Simon Monk*, *McGraw-Hill Education TAB*: This gives
    practical building blocks for electronics that can be used to interface a robot
    controller with almost anything or build new sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `colorsys` library, like most Python core libraries, has a great reference:
    [https://docs.python.org/3/library/colorsys.html](https://docs.python.org/3/library/colorsys.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pimoroni have some other demos with the LED SHIM at [https://github.com/pimoroni/led-shim/tree/master/examples](https://github.com/pimoroni/led-shim/tree/master/examples).
    These could be fun to adapt to our LED layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
