<html><head></head><body>
		<div id="_idContainer162">
			<h1 id="_idParaDest-170"><em class="italic"><a id="_idTextAnchor646"/><a id="_idTextAnchor647"/>Chapter 12</em>: Putting It All Together</h1>
			<p>Over the previous eleven chapters, we've looked at various AI methods and built some simple demo applications using Unity3D. In this final chapter, we'll develop a more complex game example using some of the techniques we explored in previous chapters. The techniques we'll be using in this chapter include navigation meshes and <strong class="bold">finite-state machines</strong> (<strong class="bold">FSMs</strong>), but, more importantly, we will learn how to navigate and add AI to a pre-existing complex game. So, unlike the other chapters, this example is more like a real-world scenario.</p>
			<p>In this chapter, we'll add AI to a simple tank combat game called <em class="italic">TANKS!</em> and contained in one of the official Unity tutorials, which, in turn, was inspired by an historic tank game called <em class="italic">Combat</em> for the Atari 2600. In the default version, TANKS! is a two-player game. Each player takes control of a tank, and the goal is to destroy each other. To make things more complicated, the player can decide the shot's strength (and, thus, the distance) by pressing and holding the <em class="italic">Spacebar</em> for a shorter or longer duration.</p>
			<p>However, because we are AI developers, we want to build an AI for the enemy tank to play in single-player mode. So, this is what we'll do in this chapter.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Developing the basic game structure</li>
				<li>Adding automated navigation</li>
				<li>Creating decision-making AI with FSM</li>
			</ul>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor648"/><a id="_idTextAnchor649"/><a id="_idTextAnchor650"/><a id="_idTextAnchor651"/>Technical requirements</h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <strong class="source-inline">Chapter 12</strong> folder in the book's GitHub repository: <a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter12">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter12</a>.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor652"/>Developing the basic game structure</h1>
			<p><a id="_idTextAnchor653"/><a id="_idTextAnchor654"/>For this demo, we will write an AI for the free tutorial game <em class="italic">TANKS!</em>. You can download the base game from Unity Asset Store (<strong class="source-inline">https://assetstore.unity.com/packages/essentials/tutorial-projects/tanks-tutorial-46209</strong>), or follow <a id="_idIndexMarker588"/>along with the version included in the <strong class="source-inline">Chapter 12</strong> folder of this book's GitHub repository. The version included with this book has the advantage of already having been tested for Unity 2022.</p>
			<p>In either case, the game is the same. When we start the game, we see a pleasant desert scenario, with rocks, structures, palm trees, and so on. Using the keyboard, we should be able to control the blue tank (the tank moves with <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> and shoots with the <em class="italic">Spacebar</em>).</p>
			<p>The following screenshot shows the basic structure of the game:</p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B17984_12_1.jpg" alt="Figure 12.1 – Basic hierarchy of the game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – Basic hierarchy of the game</p>
			<p>The first time you start with an existing project, spend as much time as you can familiarizing yourself with the game structure, the basic scripts, and the components. You must know how to operate at ease in a project you don't know. To do this, run the game a couple of times, try minor modifications to the code to see the effect, and add debug messages to learn about the flow in which information moves around the game. The following image will give you an idea of how the game will look when we run it:</p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B17984_12_2.jpg" alt="Figure 12.2 – The TANKS! game in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">F<a id="_idTextAnchor655"/>igure 12.2 – The TANKS! game in action</p>
			<p class="callout-heading">Info</p>
			<p class="callout">It may be helpful to follow the complete Unity tutorial, available at <a href="https://unity3d.com/learn/tutorials/s/tanks-tutorial">https://unity3d.com/learn/tutorials/s/tanks-tutorial</a>. Even if it does not involve AI and is quite old (the tutorial has been recorded in 2015), you will still find many important teachings for game development, such as how to design a game manager, basic controls, and audio.</p>
			<h1 id="_idParaDest-173">A<a id="_idTextAnchor656"/><a id="_idTextAnchor657"/>dding automated navigation</h1>
			<p>The first step <a id="_idIndexMarker589"/>is to modify the level to support automated navigation. In the original game, the players control all the moving objects (the tanks), so pathfinding is unnecessary. Now that we want to add AI, we need to have a world representation through which the AI can move. Luckily, this process is straightforward, thanks to NavMeshes.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor658"/><a id="_idTextAnchor659"/>Creating the NavMesh</h2>
			<p>To do <a id="_idIndexMarker590"/>this, perform the following steps:</p>
			<ol>
				<li>Open the <a id="_idIndexMarker591"/>Navigation window (<strong class="bold">Window</strong> | <strong class="bold">AI</strong> | <strong class="bold">Navigation</strong>) and look at the NavMesh generation parameters. In this case, NavMesh generation is relatively easy: we are only interested in moving around on the ground surface plane, so there are no jumps, no links, and no slopes we need to care of.</li>
				<li>The only adjustment to the default NavMesh parameters we need to make is for the baking agent size (that is, the measures of the virtual agent used by Unity to verify whether a location is large enough to allow the Agent to pass).</li>
				<li>The tanks used in the game are about three units large, so we need to instruct the generator to remove the areas that are too small for the tank to pass through. The following screenshot shows the baking setting for the navigation mesh:</li>
			</ol>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B17984_12_3.jpg" alt="Figure 12.3 – The NavMesh baking options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3 – The NavMesh baking options</p>
			<p>Just to <a id="_idIndexMarker592"/>be on the safe side, we use <a id="_idIndexMarker593"/>an <strong class="bold">Agent Radius</strong> value of <strong class="source-inline">1.8</strong> and reduce the <strong class="bold">Max Slope</strong> value to about <strong class="source-inline">20</strong> (after all, we are not interested in slopes: the game is completely flat).</p>
			<ol>
				<li value="4">After that, press <strong class="bold">Bake</strong>. You should get a nice NavMesh, as in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B17984_12_4.jpg" alt="Figure 12.4 – The baked NavMesh in the map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4 – The baked NavMesh in the map</p>
			<ol>
				<li value="5">We now <a id="_idIndexMarker594"/>want to add some patrolling <a id="_idIndexMarker595"/>points that the AI tank can follow. To do this, we create an empty GameObject; feel free to create as many other GameObject instances as you like.</li>
				<li>Then, we create a <strong class="source-inline">PatrolPoint</strong> tag, and tag all the patrol points with it.</li>
			</ol>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B17984_12_5.jpg" alt="Figure 12.5 – The patrol points labeled PPoint in the Editor view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5 – The patrol points labeled PPoint in the Editor view</p>
			<p>Now that <a id="_idIndexMarker596"/>we have a world representation <a id="_idIndexMarker597"/>and a set of points that we can use to wa<a id="_idTextAnchor660"/>nder around, we need to create an AI-controlled ag<a id="_idTextAnchor661"/>ent.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor662"/>Setting up the Agent</h2>
			<p>Unfortunately, the game <a id="_idIndexMarker598"/>does not support AI, so we <a id="_idIndexMarker599"/>need to add the Agent ourselves. To do this, perform the following steps:</p>
			<ol>
				<li value="1">We have to identify the player tank. There is no tank in the scene, as you can see from the game hierarchy. As you should know from your preliminary exploration, it is the job of <strong class="source-inline">GameManager</strong> to spawn the tanks. The tank model we'll use is a prefab called <strong class="bold">CompleteTank</strong>.</li>
				<li>Let's copy the prefab and call it <strong class="source-inline">CompleteTankAI</strong>.</li>
				<li>Then we need to add the <strong class="bold">Nav Mesh Agent</strong> component to it so that we can move it around on the new NavMesh.</li>
			</ol>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B17984_12_6.jpg" alt="Figure 12.6 – The Inspector for the Nav Mesh Agent component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6 – The Inspector for the Nav Mesh Agent component</p>
			<p>But this <a id="_idIndexMarker600"/>is not enough. First, we'll reuse the <strong class="source-inline">TankShooting</strong> script from the <strong class="bold">TANKS!</strong> demo, so we need to disable shooting if this script is attached to an AI (otherwise, the player could shoot for the AI agent).</p>
			<ol>
				<li value="4">For this, we <a id="_idIndexMarker601"/>create a public Boolean variable, called <strong class="source-inline">m_IsAI</strong>. Note that for this demo, we are using the variable naming convention of the original tutorial. This is to not confuse people working from the Asset Store. Moreover, it is always wise to adopt the coding convention of an existing project without imposing our preferences on the entire code base. Anyway, let's add the following lines to the <strong class="source-inline">Update</strong> script:<p class="source-code">private void Update () {</p><p class="source-code">    if (m_IsAI) {</p><p class="source-code">        return;</p><p class="source-code">    }</p><p class="source-code">    …</p></li>
			</ol>
			<p>These lines just stop the <strong class="source-inline">Update</strong> script for the AI agent, thereby disabling player input for AI characters. It is important to enable this variable in the AI tank prefab. We <a id="_idIndexMarker602"/>also need to add another patch; in fact, if we disable the input, we will also disable the shot strength.</p>
			<ol>
				<li value="5">So, we <a id="_idIndexMarker603"/>need to add this back into the <strong class="source-inline">Fire</strong> function:<p class="source-code"><strong class="bold">// We need to make Fire public.</strong></p><p class="source-code"><strong class="bold">public</strong> void Fire (){</p><p class="source-code">    // Set the fired flag so only Fire is only called</p><p class="source-code">    // once. </p><p class="source-code">    m_Fired = true;</p><p class="source-code">    // Create an instance of the shell and store a</p><p class="source-code">    // reference to its rigidbody.</p><p class="source-code">    Rigidbody shellInstance = Instantiate (m_Shell, </p><p class="source-code">      m_FireTransform.position,</p><p class="source-code">      m_FireTransform.rotation) as Rigidbody;</p><p class="source-code"><strong class="bold">    // New lines: if AI, we shoot with average force. </strong></p><p class="source-code"><strong class="bold">    if (m_IsAI) {</strong></p><p class="source-code"><strong class="bold">        m_CurrentLaunchForce = </strong></p><p class="source-code"><strong class="bold">          m_MaxLaunchForce / 2.0f;</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    // Set the shell's velocity to the launch force in</p><p class="source-code">    // the fire position's forward direction.</p><p class="source-code">    shellInstance.velocity = </p><p class="source-code">      m_CurrentLaunchForce * m_FireTransform.forward;</p><p class="source-code">    // Change the clip to the firing clip and play it. </p><p class="source-code">    m_ShootingAudio.clip = m_FireClip;</p><p class="source-code">    m_ShootingAudio.Play ();</p><p class="source-code">    // Reset the launch force. This is a precaution in</p><p class="source-code">    // case of missing button events.</p><p class="source-code">    m_CurrentLaunchForce = m_MinLaunchForce;</p><p class="source-code">}</p></li>
			</ol>
			<p>We are <a id="_idIndexMarker604"/>replacing the variable shooting <a id="_idIndexMarker605"/>force with a constant shooting force for simplicity.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">As an exercise, you could make <strong class="source-inline">m_CurrentLaunchForce</strong> a parameter of the <strong class="source-inline">Fire()</strong> functions. We also <a id="_idIndexMarker606"/>make the <strong class="source-inline">Fire()</strong> function public: in fact, we need to call this function from the FSM that we'll implement later.</p>
			<p>Finally, we can remove the <strong class="source-inline">TankMovement</strong> component from the Tank AI prefab. Now it is time to update the <strong class="source-inline">GameManager</strong> script to enable <em class="italic">player versus com<a id="_idTextAnchor663"/>puter</em> mode. </p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor664"/>Fixing the GameManager script</h2>
			<p>As a final <a id="_idIndexMarker607"/>step, we need to instruct <a id="_idIndexMarker608"/>the <strong class="source-inline">GameManager</strong> script to spawn a player tank and an AI tank:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">GameManager</strong> script and add a new public variable in which we'll store the new AI tank prefab:<p class="source-code">// Reference to the prefab the players will control.</p><p class="source-code">public GameObject m_TankPrefab;</p><p class="source-code">// Reference to the prefab the AI will control.</p><p class="source-code">public GameObject m_TankAIPrefab;</p></li>
				<li>Then, modify the <strong class="source-inline">SpawnAllTanks</strong> function in this way:<p class="source-code">private void SpawnAllTanks(){</p><p class="source-code">    // Spaw the Player</p><p class="source-code">    m_Tanks[0].m_Instance = Instantiate(m_TankPrefab,</p><p class="source-code">       m_Tanks[0].m_SpawnPoint.position,</p><p class="source-code">       m_Tanks[0].m_SpawnPoint.rotation);</p><p class="source-code">    m_Tanks[0].m_PlayerNumber = 01;</p><p class="source-code">    m_Tanks[0].Setup();</p><p class="source-code">    // Spawn the AI Tanks</p><p class="source-code">    for (int i = 1; i &lt; m_Tanks.Length; i++) {</p><p class="source-code">        m_Tanks[i].m_Instance =</p><p class="source-code">          Instantiate(m_TankAIPrefab,</p><p class="source-code">          m_Tanks[i].m_SpawnPoint.position,</p><p class="source-code">          m_Tanks[i].m_SpawnPoint.rotation);</p><p class="source-code">        m_Tanks[i].m_PlayerNumber = i + 1;</p><p class="source-code">        m_Tanks[i].Setup();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now that this game is a single-player game, we assume that the first tank is always <a id="_idIndexMarker609"/>the player (we spawn the <strong class="source-inline">m_TankPrefab</strong> model), and any other tank is AI-controlled (we spawn the <strong class="source-inline">m_TankAIPrefab</strong> model).</p>
			<ol>
				<li value="3">Finally, just <a id="_idIndexMarker610"/>add the prefab to the Inspector as follows. Remember to enable the <strong class="source-inline">m_IsAI</strong> variable in the <strong class="source-inline">CompleteTankAI</strong> prefab and change its layer from <strong class="bold">Player</strong> to <strong class="bold">AI</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B17984_12_7.jpg" alt="Figure 12.7 – The Game Manager script in the inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7 – The Game Manager script in the inspector</p>
			<p>Now that we have set up the basics, it is finally time to write the AI of t<a id="_idTextAnchor665"/><a id="_idTextAnchor666"/>he enemy tanks.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor667"/>Creating decision-making AI with FSM</h1>
			<p>In <a href="B17984_02_Epub.xhtml#_idTextAnchor100"><em class="italic">Chapter 2</em></a>, <em class="italic">Finite State Machines</em>, we saw how to implement a simple FSM. In this section, we are <a id="_idIndexMarker611"/>using the same technique, but will <a id="_idIndexMarker612"/>apply it to the more complex scenario of this demo.</p>
			<p>First, we need an FSM plan. We are interested only in connecting the FSM to the existing game for this demo, so we will keep it simple. The FSM for our tank is composed of just two states – patrolling and shooting.</p>
			<p>The plan is nice and straightforward:</p>
			<ol>
				<li value="1">The AI tank starts in the <strong class="source-inline">Patrol</strong> state and wanders around the previously defined patrolling points.</li>
				<li>Then, if the players get in range, the tank switches to the <strong class="source-inline">Attack</strong> state.</li>
				<li>In the <strong class="source-inline">Attack</strong> state, the tank turns toward the player and starts shooting at it. </li>
				<li>Finally, if we are in the <strong class="source-inline">Attack</strong> state and the players leave the AI's range, the tank will return to the <strong class="source-inline">Patrol</strong> state.</li>
			</ol>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B17984_12_08.jpg" alt="Figure 12.8 – The simple FSM for the enemy tanks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8 – The simple FSM for the enemy tanks</p>
			<p>For the <a id="_idIndexMarker613"/>implementation, perform the following steps:</p>
			<ol>
				<li value="1">Let's <a id="_idIndexMarker614"/>start with the FSM class:<p class="source-code">using UnityEngine;</p><p class="source-code">using System.Collections;</p><p class="source-code">public cl<a id="_idTextAnchor668"/><a id="_idTextAnchor669"/>ass FSM : Complete.TankMovement {</p><p class="source-code">    // Next destination position of the NPC Tank</p><p class="source-code">    protected Vector3 destPos;</p><p class="source-code">    // List of points for patrolling</p><p class="source-code">    protected GameObject[] pointList;</p><p class="source-code">    protected virtual void Initialize() { } </p><p class="source-code">    protected virtual void FSMUpdate() { } </p><p class="source-code">    protected virtual void FSMFixedUpdate() { }</p><p class="source-code">    // Use this for initialization</p><p class="source-code">    void Start() {</p><p class="source-code">        Initialize();</p><p class="source-code">    }</p><p class="source-code">    // Update is called once per frame </p><p class="source-code">    void Update() {</p><p class="source-code">        FSMUpdate();</p><p class="source-code">    }</p><p class="source-code">    void FixedUpdate() {</p><p class="source-code">        FSMFixedUpdate();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>As you can see, this class extends the <strong class="source-inline">Complete.TankMovement</strong> script. In this way, we <a id="_idIndexMarker615"/>can reuse the existing <strong class="source-inline">TankMovement</strong> code for things such as the engine sounds and other cosmetic aspects.</p>
			<p>As explained in <a href="B17984_02_Epub.xhtml#_idTextAnchor100"><em class="italic">Chapter 2</em></a>, <em class="italic">Finite State Machines</em>, the FSM class stores the data we <a id="_idIndexMarker616"/>need for the decision-making AI. Moreover, it contains the functions that the actual <strong class="bold">Tank Controller</strong> can override for the <strong class="source-inline">Update</strong>, <strong class="source-inline">FixedUpdate</strong>, and <strong class="source-inline">Start</strong> methods. In the FSM class, we want to store all the patrol points and the destination point (the current patrol points the tank is looking for).</p>
			<ol>
				<li value="2">Now it is time for the complete controller. We create a new <strong class="source-inline">AITankController</strong> script with the following initial content:<p class="source-code">using UnityEngine;</p><p class="source-code">using System;</p><p class="source-code">using UnityEngine.AI;</p><p class="source-code">public class AITankController : FSM {</p><p class="source-code">    public Complete.TankShooting tankShooter;</p><p class="source-code">    public Complete.TankHealth tankHealth;</p><p class="source-code">    public float playerChaseRadius = 15.0f;</p><p class="source-code">    public float platerAttackRadius = 10.0f;</p><p class="source-code">    public float shootRate = 3.0f;</p><p class="source-code">    public float targetReachedRadius = 5.0f;</p><p class="source-code">    private bool isDead = false;</p><p class="source-code">    private float elapsedTime = 0.0f;</p><p class="source-code">    private GameObject player = null;</p><p class="source-code">    private NavMeshAgent navMeshAgent;</p><p class="source-code">    public enum FSMState {</p><p class="source-code">        None, Patrol, Attack, Dead,</p><p class="source-code">    }</p><p class="source-code">    // Current state that the NPC is reaching</p><p class="source-code">    public FSMState curState;</p><p class="source-code">…</p></li>
			</ol>
			<p>In the <a id="_idIndexMarker617"/>preceding code, the class starts by <a id="_idIndexMarker618"/>extending FSM and defining the states. As you can see in the <strong class="source-inline">FSMState</strong> enum, we have <strong class="source-inline">Patrol</strong> and <strong class="source-inline">Attack</strong>, an empty state (<strong class="source-inline">None</strong>), and a final state (<strong class="source-inline">Dead</strong>). Then we add some class attributes to store the data we need.</p>
			<p>The first two attributes are references to the <strong class="source-inline">TankShooter</strong> and <strong class="source-inline">TankHealth</strong> scripts in the tank. We will use them to check the health and to fire bullets. Then we have an <strong class="source-inline">isDead</strong> Boolean to stop FSM execution. Then we have <strong class="source-inline">elapsedTime</strong> and <strong class="source-inline">shootRate</strong> for controlling how rapidly the tank will shoot, followed by two private attributes that store a reference to the player (if in range) and a <a id="_idIndexMarker619"/>reference to <strong class="source-inline">NavMeshAgent</strong>. Lastly, we have a variable holding the current state in the FSM.</p>
			<ol>
				<li value="3">The <strong class="source-inline">Initialize</strong> function <a id="_idIndexMarker620"/>is used to initialize, of course, the FSM:<p class="source-code">    //Initialize the Finite state machine for the NPC tank</p><p class="source-code">    protected override void Initialize() {</p><p class="source-code">        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();</p><p class="source-code">        // Get the list of points </p><p class="source-code">        pointList = GameObject.FindGameObjectsWithTag(</p><p class="source-code">          "PatrolPoint");</p><p class="source-code">        int rndIndex = UnityEngine.Random.Range(0,</p><p class="source-code">          pointList.Length);</p><p class="source-code">        destPos =</p><p class="source-code">          pointList[rndIndex].transform.position;</p><p class="source-code">    }</p></li>
			</ol>
			<p>In this function, we do three things:</p>
			<ul>
				<li>We get the reference to <strong class="source-inline">NavMeshAgent</strong>.</li>
				<li>We get a list of all <strong class="source-inline">PatrolPoint</strong> in the scene</li>
				<li>We randomly select one of the patrol points as the Agent's current destination.</li>
			</ul>
			<ol>
				<li value="4">Then it <a id="_idIndexMarker621"/>is time for the <strong class="source-inline">Update</strong> function. Before <a id="_idIndexMarker622"/>this, however, we need to expose the tanks' current health. Let's add the following line to the <strong class="source-inline">TankHealth</strong> component:<p class="source-code">    // ...</p><p class="source-code">    private AudioSource m_ExplosionAudio </p><p class="source-code">    private ParticleSystem m_ExplosionPar<a id="_idTextAnchor670"/><a id="_idTextAnchor671"/>ticles</p><p class="source-code">    private float m_CurrentHealth;</p><p class="source-code">    private boo<a id="_idTextAnchor672"/><a id="_idTextAnchor673"/>l m_Dead;</p><p class="source-code">    <strong class="bold">public float CurrentHealth { get; }</strong></p><p class="source-code">    // ...</p></li>
			</ol>
			<p>We add the <strong class="source-inline">CurrentHealth</strong> property so that we can get read-only public access to the private member, <strong class="source-inline">m_CurrentHealth</strong>.</p>
			<ol>
				<li value="5">We are now ready to implement the FSM's <strong class="source-inline">FSMUpdate</strong> method:<p class="source-code">    protected override void FSMUpdate() {</p><p class="source-code">        switch (curState) {</p><p class="source-code">            case FSMState.Patrol: </p><p class="source-code">                UpdatePatrolState();</p><p class="source-code">                break; </p><p class="source-code">            case FSMState.Attack: </p><p class="source-code">                UpdateAttackState(); </p><p class="source-code">                break;</p><p class="source-code">            case FSMState.Dead: </p><p class="source-code">                UpdateDeadState();</p><p class="source-code">                break;</p><p class="source-code">        }</p><p class="source-code">        elapsedTime += Time.deltaTime;</p><p class="source-code">        // Go to dead state is <a id="_idTextAnchor674"/><a id="_idTextAnchor675"/>no health left</p><p class="source-code">        if (tankHealth.CurrentHealth &lt;= 0) {</p><p class="source-code">            curState = FSMState.Dead;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
			</ol>
			<p>As we <a id="_idIndexMarker623"/>explained previously, the main <a id="_idIndexMarker624"/>task of the <strong class="source-inline">Update</strong> function is to invoke the proper function depending on the current state. In addition to that, <strong class="source-inline">FSMUpdate</strong> also updates the <strong class="source-inline">elapsedTime</strong> timer and sets the Agent to the <strong class="source-inline">Dead</strong> state if the tank has no health.</p>
			<ol>
				<li value="6">The <strong class="source-inline">Dead</strong> state is very simple: the tank does nothing, and writes on the console that it is dead:<p class="source-code">    private void UpdateDeadState() {</p><p class="source-code">        if (!isDead) {</p><p class="source-code">            Debug.Log("Dead");</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>The <strong class="source-inline">Attack</strong> state <a id="_idIndexMarker625"/>is <a id="_idIndexMarker626"/>more interesting:<p class="source-code">    private void UpdateAttackState() {</p><p class="source-code">        Collider[] players = Physics.OverlapSphere(</p><p class="source-code">          Transform.position, playerChaseRadius,</p><p class="source-code">          LayerMask.GetMask("Players"));</p><p class="source-code">        if (players.Length == 0) {</p><p class="source-code">            curState = FSMState.Patrol;</p><p class="source-code">            player = null;</p><p class="source-code">            navMeshAgent.enabled = true; </p><p class="source-code">            return;</p><p class="source-code">        }</p><p class="source-code">        player = players[0].gameObject;</p><p class="source-code">        Vector3 _direction = </p><p class="source-code">          (player.transform.position – </p><p class="source-code">           transform.position).normalized;</p><p class="source-code">        Quaternion _lookRotation =</p><p class="source-code">          Quaternion.LookRotation(_direction);</p><p class="source-code">        transform.rotation = </p><p class="source-code">          Quaternion.Slerp(transform.rotation,</p><p class="source-code">          _lookRotation, Time.deltaTime * 3);</p><p class="source-code">        if (elapsedTime &gt; shootRate) {</p><p class="source-code">            tankShooter.Fire(); </p><p class="source-code">            elapsedTime = 0;</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
			</ol>
			<p>In the <a id="_idIndexMarker627"/>first part of the preceding code, we <a id="_idIndexMarker628"/>cast a sphere using Unity's physics engine to <em class="italic">see</em> all the <em class="italic">players</em> in a radius of <strong class="source-inline">15</strong> units. Then, if there is none (meaning that the player is out of range), we switch to the <strong class="source-inline">Patrol</strong> state, remove the player reference, enable the <strong class="source-inline">NavMeshAgent</strong> component, and terminate the state. Otherwise, we proceed with the attack: we get the player reference, rotate the tank in its direction, and shoot (at the correct rate).</p>
			<p>Luckily, the original game already implemented the <strong class="source-inline">Fire</strong> function! That's why good class design is essential: if a class is functional, you can reutilize it very well, even for things that you didn't initially consider!</p>
			<ol>
				<li value="8">Finally, we have the <strong class="source-inline">Patrol</strong> state function:<p class="source-code">    private void UpdatePatrolState() {</p><p class="source-code">        Collider[] players = Physics.OverlapSphere(</p><p class="source-code">          transform.position, playerAttackRadius,</p><p class="source-code">          LayerMask.GetMask("Players")"));</p><p class="source-code">        if (players.Length &gt; 0) {</p><p class="source-code">            curState = FSMState.Attack;</p><p class="source-code">            player = players[0].gameObject;</p><p class="source-code">            navMeshAgent.enabled = false;</p><p class="source-code">            return;</p><p class="source-code">        }</p><p class="source-code">        if (IsInCurrentRange(destPos)) {</p><p class="source-code">            int rndIndex = UnityEngine.Random.Range(0,</p><p class="source-code">              pointList.Length);</p><p class="source-code">            destPos =</p><p class="source-code">              pointList[rndIndex].transform.position;</p><p class="source-code">        }</p><p class="source-code">        navMeshAgent.destination = destPos;</p><p class="source-code">    }</p></li>
			</ol>
			<p>If no <a id="_idIndexMarker629"/>player is in range, then we proceed <a id="_idIndexMarker630"/>to wander around. First, we check whether we have reached the current destination. If so, we need to select a new destination. Then, we set up the patrol point as the destination of the <strong class="source-inline">navMeshAgent</strong> component (as described in <a href="B17984_08_Epub.xhtml#_idTextAnchor447"><em class="italic">Chapter 8</em></a>, <em class="italic">Navigation Mesh</em>).</p>
			<ol>
				<li value="9">The <strong class="source-inline">IsInCurrentRange</strong> function is just a simple comparison, as shown in the following code:<p class="source-code">    protected bool IsInCurrentRange(Vector3 pos) {</p><p class="source-code">        float xPos = </p><p class="source-code">          Mathf.Abs(pos.x - transform.position.x);</p><p class="source-code">        float zPos = </p><p class="source-code">          Mathf.Abs(pos.z - transform.position.z);</p><p class="source-code">        if (xPos &lt;= targetReachedRadius  &amp;&amp; zPos &lt;=</p><p class="source-code">            targetReachedRadius ) return true;</p><p class="source-code">        return false;</p><p class="source-code">    }</p></li>
				<li>That's it. Add <a id="_idIndexMarker631"/>the <strong class="source-inline">AITankController</strong> script <a id="_idIndexMarker632"/>to the <strong class="source-inline">CompleteAITank</strong> prefab and connect all the required elements. You can see how the <strong class="source-inline">AITankController</strong> component should look in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B17984_12_9.jpg" alt="Figure 12.9 – The AI Tank Controller script in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.9 – The AI Tank Controller script in the Inspector</p>
			<p>Remember <a id="_idIndexMarker633"/>also to set the prefab's <a id="_idIndexMarker634"/>layer to <strong class="bold">AI</strong>.</p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B17984_12_10.jpg" alt="Figure 12.10 – The Layer configuration for the CompleteTankAI prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.10 – The Layer configuration for the CompleteTankAI prefab</p>
			<p>At this point, everything is in place. So run the game and enjoy your simple<a id="_idTextAnchor676"/><a id="_idTextAnchor677"/> tank moving around, shooting at you.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor678"/>Summary</h1>
			<p>In this chapter, we applied some of the AI techniques that we learned previously to our simple tanks combat game. Then, of course, we'd be able to use some more techniques in a larger game scope. Still, in this short chapter, we reused the simple FSM framework that we built in <a href="B17984_02_Epub.xhtml#_idTextAnchor100"><em class="italic">Chapter 2</em></a>, <em class="italic">Finite State Machines</em>, as well as Unity's built-in navigation meshes capabilities.</p>
			<p>This example project is a perfect starting point for exploring the AI techniques introduced in this book. You can implement many more improvements to the AI of this demo, and I encourage you to play with it a bit more. There are several pieces of low-hanging fruit, so here are my suggestions:</p>
			<p>As a first exercise, you can increase the number of states, for instance, by adding a <em class="italic">Chasing</em> state in which the tank will actively look for the player. This structure is like the <em class="italic">Attack</em> state, but with a bigger radius. Then, as a more significant step, try to replace the FSM with a Behavior tree. The Behavior tree that we implemented in the Behavior tree demo is incredibly apt for this scenario. Finally, you need to change the script to call the correct function for the tank game, but it is an excellent exercise.</p>
			<p>We hope that you learned something new in areas related to AI in games and Unity3D. We just scratched the surface of gameplay AI programming, but if you have reached the end of this book, you are suited for any challenge you may encounter in the future. Good luck, and have fun!</p>
		</div>
	</body></html>