<html><head></head><body>
        

                            
                    <h1 class="header-title">Autonomous Maze Navigation</h1>
                
            
            
                
<p class="mce-root">The maze navigation is a classic computer science problem related to the autonomous navigation domain. In this chapter, you will learn how neuroevolution-based methods can be used to solve the challenge of maze navigation. Also, we will explain how to define a goal-oriented fitness function using the fitness scores of the navigator agent calculated as a derivative of the agent's distance from the final goal. By the end of this chapter, you will understand the basics of training an autonomous navigation agent using neuroevolution methods and will be able to create the more advanced maze solver that will be introduced in the next chapter. You will become familiar with advanced visualization techniques that will make it easier to understand the results of algorithm execution. Also, you will obtain hands-on experience of writing simulators of maze-navigating robots and related maze environments using the Python programming language.</p>
<p class="p1">In this chapter, you will become familiar with the following topics:</p>
<ul class="ul1">
<li class="li1">The deceptive nature of the maze navigation problem</li>
<li class="li1">Writing a simulator of a maze-navigating robot equipped with an array of sensors and actuators</li>
<li class="li1">Defining a goal-oriented fitness function to guide the process of creating an appropriate maze solver using the neuroevolution algorithm</li>
<li class="li1">Running the experiments with a simple and hard-to-solve  maze configurations</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="p1">The following technical requirements should be met to complete the experiments described in this chapter:</p>
<ul class="ul1">
<li class="li1">Windows 8/10, macOS 10.13 or newer, or modern Linux</li>
<li class="li1">Anaconda Distribution version 2019.03 or newer</li>
</ul>
<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter5">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter5</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maze navigation problem</h1>
                
            
            
                
<p>The maze navigation problem is a classic computer science problem that is closely related to creating autonomous navigation agents that can find a path through ambiguous environments. The maze environment is an illustrative domain for the class of problems that have a deceptive fitness landscape. This means that the goal-oriented fitness function can have steep gradients of fitness scores in dead ends in the maze that are close to the final goal point. Such areas of the maze become the local optima for objective-based search algorithms that may converge in these areas. When the search algorithm converges in such deceptive local optima, it cannot find an adequate maze-solver agent.</p>
<p>In the following example, you can see a two-dimensional maze with local optima dead ends, which are shaded in:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-765 image-border" src="img/fd56ef1f-ea8c-4f17-8d58-62c569a8352f.png" style="width:19.25em;height:19.25em;"/></p>
<p>The two-dimensional maze configuration</p>
<p>The maze configuration in the diagram visualizes the landscape of the deceptive fitness scores concentrated in the local optima dead ends (marked as filled segments). The maze-solver agent navigating from the starting point (bottom circle) to the exit point (top circle) using the objective-based search algorithm will be prone to getting stuck in the local optima dead ends. Also, a deceptive fitness score landscape such as this can prevent the objective-based search algorithm from finding a successful maze solver.</p>
<p>The agent navigating through the maze is a robot equipped with a set of sensors, allowing it to detect nearby obstacles and get the direction to the maze exit. The motion of the robot is controlled by two actuators, which affect the linear and angular movement of the robot body. The actuators of the robot are controlled by an ANN, which receives input from the sensors and produces the two control signals for the actuators.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maze simulation environment</h1>
                
            
            
                
<p>The environment for the maze simulation consists of three major components that are implemented as separate Python classes:</p>
<ul class="ul1">
<li class="li1"><kbd>Agent</kbd>: The class that holds information related to the maze navigator agent that is used by simulation (see the <kbd>agent.py</kbd><em> </em>file for the implementation details).</li>
<li class="li1"><kbd>AgentRecordStore</kbd>: The class that manages the storage of records relating to evaluations of all the solver agents during the evolutionary process. The collected records can be used to analyze the evolutionary process after its completion (see the <kbd>agent.py</kbd> file for the implementation details).</li>
<li class="li1"><kbd>MazeEnvironment</kbd>: The class that contains information about the maze simulation environment. This class also provides methods that manage the simulation environment, control the position of a solver agent, perform collision detection, and generate the input data for sensors of the agent (see the <kbd>maze_environment.py</kbd> file for the implementation details).</li>
</ul>
<p>In the following sections, we will look at each part of the maze simulation environment in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maze-navigating agent</h1>
                
            
            
                
<p>In this chapter, we consider a two-dimensional maze navigation task. This task is easy to visualize, and it is relatively easy to write the simulator of the maze-navigating robot for a two-dimensional maze. The main goal of the robot is to navigate through a maze to the defined goal point in a specified number of time steps. The ANN that controls the robot is a product of the neuroevolution process.</p>
<p class="mce-root">The neuroevolution algorithm starts with a very basic initial ANN configuration that only has input nodes for sensors and output nodes for actuators, which gradually becomes more complex until a successful maze solver is found. This task is complicated by a peculiar configuration of the maze that has several <em>cul-de-sacs</em>, which prevent finding the route to the goal by creating local optima in the fitness landscape, as discussed previously.</p>
<p>The following diagram shows the schematic drawing of the maze agent used in the maze-solving simulation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-766 image-border" src="img/6d5ee7a0-e182-4b03-9e75-4d8dab75b2f9.png" style="width:17.75em;height:17.67em;"/></p>
<p>The maze agent (robot) schema</p>
<p>In the preceding diagram, the filled circle defines the rigid body of the robot. The arrow within the filled circle shows the heading of the robot. The six arrows around the filled circle represent <strong>six rangefinder sensors</strong> that indicate the distance to the nearest obstacle in a given direction. The four outer circle segments denote the <strong>four pie-slice radar sensors</strong> that act as a compass toward the goal point (maze exit).</p>
<p class="mce-root">The specific radar sensor becomes activated when the line from the goal point to the center of the robot falls within its <strong>field of view</strong> (<strong>FOV</strong>). The detection range of the radar sensor is limited by the area of the maze that falls into its FOV. Thus, at any given time, one of the four radar sensors is activated, indicating the maze exit direction.</p>
<p class="p1">The radar sensors have the following FOV zones relative to the robot's heading:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Sensor</strong></td>
<td><strong>FOV, degrees</strong></td>
</tr>
<tr>
<td>Front</td>
<td>315.0 ~ 405.0</td>
</tr>
<tr>
<td>Left</td>
<td>45.0 ~ 135.0</td>
</tr>
<tr>
<td>Back</td>
<td>135.0 ~ 225.0</td>
</tr>
<tr>
<td>Right</td>
<td>225.0 ~ 315.0</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The rangefinder sensor is a trace ray drawn from the center of the robot in a specific direction. It becomes activated when intersecting with any obstacle and returns a distance to the detected obstacle. The detection range of this sensor is defined by a particular configuration parameter.</p>
<p class="p1">The rangefinder sensors of the robot monitor the following directions relative to the agent heading:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Sensor</strong></td>
<td><strong>Direction, degrees</strong></td>
</tr>
<tr>
<td>Right</td>
<td>-90.0</td>
</tr>
<tr>
<td>Front-right</td>
<td>-45.0</td>
</tr>
<tr>
<td>Front</td>
<td>0.0</td>
</tr>
<tr>
<td>Front-left</td>
<td>45.0</td>
</tr>
<tr>
<td>Left</td>
<td>90.0</td>
</tr>
<tr>
<td>Back</td>
<td>-180.0</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The movement of the robot is controlled by two actuators that apply forces that turn and/or propel the agent frame, that is, change its linear and/or angular velocity.</p>
<p>The Python implementation of the maze-solver agent has multiple fields to hold its current state and to maintain the activation states of its sensors:</p>
<pre>    def __init__(self, location, heading=0, speed=0, <br/>                 angular_vel=0, radius=8.0, range_finder_range=100.0):<br/>        self.heading = heading<br/>        self.speed = speed<br/>        self.angular_vel = angular_vel<br/>        self.radius = radius<br/>        self.range_finder_range = range_finder_range<br/>        self.location = location<br/>        # defining the range finder sensors<br/>        self.range_finder_angles = [-90.0, -45.0, 0.0, 45.0, 90.0, -180.0]<br/>        # defining the radar sensors<br/>        self.radar_angles = [(315.0, 405.0), (45.0, 135.0),<br/>                             (135.0, 225.0), (225.0, 315.0)]<br/>        # the list to hold range finders activations<br/>        self.range_finders = [None] * len(self.range_finder_angles)<br/>        # the list to hold pie-slice radar activations<br/>        self.radar = [None] * len(self.radar_angles)</pre>
<p>For more implementation details, refer to the <kbd>agent.py</kbd> file at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/agent.py">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/agent.py</a>.</p>
<p>The preceding code shows a default constructor of the <kbd>Agent</kbd> class, where all fields of the agent are initialized. The maze environment simulation will use those fields to store the current state of the agent at each simulation step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maze simulation environment implementation</h1>
                
            
            
                
<p>To simulate the solver agent navigating the maze, we need to define an environment that manages the configuration of the maze, tracks the position of the maze-solving agent, and provides inputs to the sensor data arrays of the navigating robot. </p>
<p class="p1">All of these features fit into one logical block that is encapsulated into the <kbd>MazeEnvironment</kbd> Python class, which has the following fields (as can be seen from the class constructor):</p>
<pre>    def __init__(self, agent, walls, exit_point, exit_range=5.0):<br/>        self.walls = walls<br/>        self.exit_point = exit_point<br/>        self.exit_range = exit_range<br/>        # The maze navigating agent<br/>        self.agent = agent<br/>        # The flag to indicate if exit was found<br/>        self.exit_found = False<br/>        # The initial distance of agent from exit<br/>        self.initial_distance = self.agent_distance_to_exit()</pre>
<p class="p1">The preceding code shows the default constructor of the <kbd>MazeEnvironment</kbd> class with initialization of all its fields:</p>
<ul class="ul1">
<li class="li2">The maze configuration is determined by a list of walls and <kbd>exit_point</kbd>. Walls are lists of line segments; each line segment represents a specific wall in the maze, and <kbd>exit_point</kbd> is the location of maze's exit.</li>
<li class="li2">The <kbd>exit_range</kbd> field stores value of the range distance around the <kbd>exit_point</kbd> that defines the exit area. We consider that the agent has successfully solved a maze when its position is in the exit area.</li>
<li class="li2">The <kbd>agent</kbd> field holds a reference to the initialized <kbd>Agent</kbd> class described in the previous section, which defines the starting location of the solver agent in the maze among other agent-related data fields.</li>
<li class="li2">The <kbd>initial_distance</kbd> field stores the distance from the agent's starting position to the maze exit point. This value will be later used for the agent's fitness score calculation.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Sensor data generation</h1>
                
            
            
                
<p class="p1">The maze-solver agent is controlled by an ANN that needs to receive sensor data as input to produce the corresponding control signals as output. As we have already mentioned, the navigator agent is equipped with an array of two types of sensors:</p>
<ul class="ul1">
<li class="li1">Six <em>rangefinder sensors</em> for the detection of collisions with the maze walls, which indicate the distance to the closest obstacle in a particular direction.</li>
<li class="li1">Four <em>pie-slice radar sensors</em>, which indicate the direction to the maze's exit point from any place in the maze.</li>
</ul>
<p class="p1">The sensor values need to be updated at each simulation step, and the <kbd>MazeEnvironment</kbd> class provides two designated methods that update both types of sensor.</p>
<p class="p1">The array of rangefinder sensors is updated as follows (see the <kbd>update_rangefinder_sensors</kbd> function):</p>
<pre>        for i, angle in enumerate(self.agent.range_finder_angles):<br/>            rad = geometry.deg_to_rad(angle)<br/>            projection_point = geometry.Point(<br/>                x = self.agent.location.x + math.cos(rad) * \<br/>                    self.agent.range_finder_range,<br/>                y = self.agent.location.y + math.sin(rad) * \<br/>                    self.agent.range_finder_range<br/>            )<br/>            projection_point.rotate(self.agent.heading, <br/>                                    self.agent.location)<br/>            projection_line = geometry.Line(a = self.agent.location, <br/>                                            b = projection_point)<br/>            min_range = self.agent.range_finder_range<br/>            for wall in self.walls:<br/>                found, intersection = wall.intersection(projection_line)<br/>                if found:<br/>                    found_range = intersection.distance(<br/>                                                   self.agent.location)<br/>                    if found_range &lt; min_range:<br/>                        min_range = found_range<br/>            # Store the distance to the closest obstacle<br/>            self.agent.range_finders[i] = min_range</pre>
<p>This code enumerates all detection directions of the rangefinder sensors, which are determined by the direction angles (see the <kbd>range_finder_angles</kbd> field initialization in the <kbd>Agent</kbd> constructor). For each direction, a projection line is then created, starting from the current position of the agent and with a length equal to the rangefinder's detection range. After that, the projection line is tested to see if it intersects any of the maze walls. If multiple intersections are detected, the distance to the closest wall is stored as a value to a specific rangefinder sensor. Otherwise, the maximal detection range will be saved as a value for a rangefinder sensor.</p>
<p class="p1">The array of pie-slice radar sensors needs to be updated with the following code in the <kbd>MazeEnvironment</kbd> class:</p>
<pre>    def update_radars(self):<br/>        target = geometry.Point(self.exit_point.x, self.exit_point.y)<br/>        target.rotate(self.agent.heading, self.agent.location)<br/>        target.x -= self.agent.location.x<br/>        target.y -= self.agent.location.y<br/>        angle = target.angle()<br/>        for i, r_angles in enumerate(self.agent.radar_angles):<br/>            self.agent.radar[i] = 0.0 # reset specific radar <br/>            if (angle &gt;= r_angles[0] and angle &lt; r_angles[1]) or <br/>               (angle + 360 &gt;= r_angles[0] and angle + 360 &lt; r_angles[1]):<br/>                # fire the radar<br/>                self.agent.radar[i] = 1.0</pre>
<p>The preceding code creates a copy of the maze exit point and rotates it with respect to the agent's heading and position within the global coordinate system. The target point is then translated to align it with the local coordinate system of the maze-solver agent; the agent is placed at the origin of the coordinates. After that, we calculate the angle of the vector drawn from the origin of the coordinates to the target point within the local coordinate system of the agent. This angle is an azimuth to the maze exit point from the current agent position. When the azimuth angle is found, we enumerate over the registered pie-sliced radar sensors to find the one that includes the azimuth angle in its FOV. The corresponding radar sensor is activated by setting its value to 1, while other radar sensors are deactivated by zeroing their values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Agent position update</h1>
                
            
            
                
<p>The position of the maze-solver agent within a maze needs to be updated in each simulation step after receiving the corresponding control signals from the controller ANN. The following code is executed to update the position of the maze-solver agent:</p>
<pre>    def update(self, control_signals):<br/>        if self.exit_found:<br/>            return True # Maze exit already found<br/>        self.apply_control_signals(control_signals)<br/>        vx = math.cos(geometry.deg_to_rad(self.agent.heading)) * \<br/>                      self.agent.speed<br/>        vy = math.sin(geometry.deg_to_rad(self.agent.heading)) * \<br/>                      self.agent.speed<br/>        self.agent.heading += self.agent.angular_vel<br/>        if self.agent.heading &gt; 360:<br/>            self.agent.heading -= 360<br/>        elif self.agent.heading &lt; 0:<br/>            self.agent.heading += 360<br/>        new_loc = geometry.Point(<br/>            x = self.agent.location.x + vx, <br/>            y = self.agent.location.y + vy<br/>        )<br/>        if not self.test_wall_collision(new_loc):<br/>            self.agent.location = new_loc<br/>        self.update_rangefinder_sensors()<br/>        self.update_radars()<br/>        distance = self.agent_distance_to_exit()<br/>        self.exit_found = (distance &lt; self.exit_range)<br/>        return self.exit_found</pre>
<p class="p1">The <kbd>update(self, control_signals)</kbd> function is defined in the <kbd>MazeEnvironment</kbd> class and is invoked in each simulation time step. It receives a list with control signals as input and returns a Boolean value indicating whether the maze-solver agent has reached the exit area after its position update.</p>
<p class="p1">The code at the beginning of this function applies received control signals to the current values of the agent's angular and linear velocities as follows (see the <kbd>apply_control_signals(self, control_signals)</kbd> function):</p>
<pre>       self.agent.angular_vel += (control_signals[0] - 0.5)<br/>       self.agent.speed += (control_signals[1] - 0.5)</pre>
<p class="p1">After that, the <kbd>x</kbd> and <kbd>y</kbd> velocity components, along with the agents heading, are calculated and used to estimate its new position within the maze. If this new position doesn't collide with any of the maze walls, then it is assigned to the agent and becomes its current position:</p>
<pre>        vx = math.cos(geometry.deg_to_rad(self.agent.heading)) * \<br/>                      self.agent.speed<br/>        vy = math.sin(geometry.deg_to_rad(self.agent.heading)) * \<br/>                      self.agent.speed<br/>        self.agent.heading += self.agent.angular_vel<br/>        if self.agent.heading &gt; 360:<br/>            self.agent.heading -= 360<br/>        elif self.agent.heading &lt; 0:<br/>            self.agent.heading += 360<br/>        new_loc = geometry.Point(<br/>            x = self.agent.location.x + vx, <br/>            y = self.agent.location.y + vy<br/>        )<br/>        if not self.test_wall_collision(new_loc):<br/>            self.agent.location = new_loc</pre>
<p class="p1">After this, the new agent position is used in the following functions, which update the rangefinder and radar sensors to estimate new sensor inputs for the next time step:</p>
<pre>        self.update_rangefinder_sensors()<br/>        self.update_radars()</pre>
<p class="p1">Finally, the following function tests whether the agent has reached the maze exit, which is defined by the circular area around the exit point with a radius equal to the value of the <kbd>exit_range</kbd> field:</p>
<pre>        distance = self.agent_distance_to_exit()<br/>        self.exit_found = (distance &lt; self.exit_range)<br/>        return self.exit_found</pre>
<p>If the maze exit has been reached, the value of the <kbd>exit_found</kbd> field is set to <kbd>True</kbd> to indicate the successful completion of the task, and its value is returned from the function call.</p>
<p>For more implementation details, refer to the <kbd>maze_environment.py</kbd> file at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_environment.py">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_environment.py</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Agents records store</h1>
                
            
            
                
<p class="p1">After completing the experiment, we are interested in evaluating and visualizing how each individual solver agent performed during the evolutionary process through all generations. This is accomplished by collecting additional statistical data about each agent after running the maze-solving simulation for a specified number of time steps. The collection of agent records is mediated by two Python classes: <kbd>AgentRecord</kbd> and <kbd>AgentRecordStore</kbd>.</p>
<p>The <kbd>AgentRecord</kbd> class consists of several data fields, as can be seen in the class constructor:</p>
<pre>    def __init__(self, generation, agent_id):<br/>        self.generation = generation<br/>        self.agent_id = agent_id<br/>        self.x = -1<br/>        self.y = -1<br/>        self.fitness = -1<br/>        self.hit_exit = False<br/>        self.species_id = -1<br/>        self.species_age = -1</pre>
<p class="p1">The fields are defined as follows:</p>
<ul class="ul1">
<li class="li2"><kbd>generation</kbd> holds the ID of the generation when the agent record was created.</li>
<li class="li2"><kbd>agent_id</kbd> is a unique agent identifier.</li>
<li class="li2"><kbd>x</kbd> and <kbd>y</kbd> is the agent's position within the maze after a simulation has been completed.</li>
<li class="li2"><kbd>fitness</kbd> is the resulting fitness score of the agent.</li>
<li class="li2"><kbd>hit_exit</kbd> is a flag that indicates whether the agent has reached the maze exit area or not.</li>
<li class="li2"><kbd>species_id</kbd> and <kbd>species_age</kbd> are the ID and age of the species the agent belongs to.</li>
</ul>
<p class="p1">The <kbd>AgentRecordStore</kbd> class holds a list of agent records and provides functions to load/dump the collected records from/to the specific file.</p>
<p>See the <kbd>agent.py</kbd> file in the directory associated with this chapter in the source code repository for the complete implementation details.</p>
<p class="p1">New <kbd>AgentRecord</kbd> instances are added to the store after evaluation of the genome fitness, as defined in the <kbd>eval_fitness(genome_id, genome, config, time_steps=400)</kbd> function implemented in the <kbd>maze_experiment.py</kbd> file. This is done with the following code:</p>
<pre>def eval_fitness(genome_id, genome, config, time_steps=400):<br/>    maze_env = copy.deepcopy(trialSim.orig_maze_environment)<br/>    control_net = neat.nn.FeedForwardNetwork.create(genome, config)<br/>    fitness = maze.maze_simulation_evaluate(<br/>              env=maze_env, net=control_net, time_steps=time_steps)<br/>    record = agent.AgentRecord(<br/>        generation=trialSim.population.generation,<br/>        agent_id=genome_id)<br/>    record.fitness = fitness<br/>    record.x = maze_env.agent.location.x<br/>    record.y = maze_env.agent.location.y<br/>    record.hit_exit = maze_env.exit_found<br/>    record.species_id = trialSim.population.species.\<br/>                                       get_species_id(genome_id)<br/>    record.species_age = record.generation - \<br/>      trialSim.population.species.get_species(genome_id).created<br/>    trialSim.record_store.add_record(record)<br/>    return fitness</pre>
<p class="p1">This code first creates a deep copy of the original maze environment to avoid interference between evaluation runs. After that, it creates the control ANN from the specified genome using the provided NEAT configuration and starts the evaluation of the maze simulation for a given number of time steps. The returned fitness score of the agent along with other statistics are then stored into a particular <kbd>AgentRecord</kbd> instance and are added to the record store.</p>
<p class="mce-root">The records collected during one trial of the experiment will be saved to the <kbd>data.pickle</kbd> file in the <kbd>output</kbd> directory and used to visualize the performance of all the evaluated agents.</p>
<p>See the <kbd>maze_experiment.py</kbd> file for the complete implementation details: <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_experiment.py">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_experiment.py</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The agent record visualization</h1>
                
            
            
                
<p>After all agents' evaluation records are collected during the neuroevolutionary process, we are interested in visualizing the recorded data to get insights into performance. The visualization should include the final positions of all solver agents and allow to set the threshold value for the fitness of the species to control what species will be added to the corresponding plot. We decided to present the collected agent records in two plots drawn one above the other. The top plot is for the agent records that belong to the species with a fitness score greater than or equal to the specified fitness threshold, and the bottom plot is for the rest of the records.</p>
<p class="p1">The visualization of the agent records is implemented in the new methods in the <kbd>visualize.py</kbd> script. You should already be familiar with this script from the previous experiments described in this book.</p>
<p>See the <kbd>draw_maze_records(maze_env, records, best_threshold=0.8, filename=None, view=False, show_axes=False, width=400, height=400)</kbd> function definition in the <kbd>visualize.py</kbd> file at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/visualize.py">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/visualize.py</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Objective function definition using the fitness score</h1>
                
            
            
                
<p>In this section, you will learn about the creation of successful maze-solver agents using a goal-oriented objective function to guide the evolutionary process. This objective function is based on the estimation of the fitness score of the maze solver by measuring the distance between its final position and the maze exit after executing the 400 simulation steps. Thus, the objective function is goal-oriented and solely depends on the ultimate goal of the experiment: reaching the maze exit area.</p>
<p>In the next chapter, we will consider a different approach for solution search optimization, which is based on the <strong>Novelty Search</strong> (<strong>NS</strong>) optimization method. The NS optimization method is built around exploring new configurations of the solver agent during evolution and doesn't include proximity to the final goal (in this case, the maze exit) in the objective function definition. We will demonstrate that the NS approach can outperform the conventional goal-oriented objective function definition that we consider in this chapter.</p>
<p>The goal-oriented objective function used in this experiment is determined as follows. First, we need to define the loss function as the <em>Euclidean distance</em> between the final position of the agent at the end of the simulation and the position of the maze exit:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/c15d4c04-be73-46a0-8646-389753f2063f.png" style="width:10.50em;height:4.08em;"/></p>
<p><img class="fm-editor-equation" src="img/6cf451c8-aadb-4687-83ce-03c2010b1639.png" style="width:0.67em;height:0.92em;"/> is a loss function, <img class="fm-editor-equation" src="img/81e08623-15b0-4415-ab2b-5ce0ca539338.png" style="width:0.75em;height:0.83em;"/> is the coordinates of the final position of the agent, and <img class="fm-editor-equation" src="img/79fa5d4c-f267-4202-b143-38f359cf7e81.png" style="width:0.42em;height:0.92em;"/> is the coordinates of the maze exit. In this experiment, we considered a two-dimensional maze configuration, so the coordinates have two values, one for each dimension.</p>
<p>With the loss function defined previously, we now can specify the fitness function:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/ce2af4c9-1d4c-44b0-8e44-7283a2ee9c1e.png" style="width:11.75em;height:2.67em;"/></p>
<p><img class="fm-editor-equation" src="img/77443d18-44e5-4825-ad13-e2e97b4fbea7.png" style="width:2.33em;height:1.08em;"/> is the radius of the exit area around the maze exit point and <img class="fm-editor-equation" src="img/7eee273d-055d-4d6b-a6dd-e728f8d893bb.png" style="width:1.25em;height:1.00em;"/> is the normalized fitness score. The normalized fitness score is given as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/e0806012-1153-441c-9cca-ecc9e2d334ea.png" style="width:6.92em;height:2.42em;"/></p>
<p><img class="fm-editor-equation" src="img/412eae6e-5bcb-478b-abed-32e75ca636c1.png" style="width:2.33em;height:1.08em;"/> is the initial distance from the solver agent to the maze exit at the start of the navigation simulation.</p>
<p class="mce-root">The equation normalizes the fitness score to be in the range <kbd>(0,1]</kbd>, but can result in negative values in rare cases when the final position of the agent is far away from its initial position and the maze exit. The following amendments to the normalized fitness score will be applied to avoid negative values:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/2a5fb3c0-5f4a-4ad0-8a6a-b8e87b8c6f69.png" style="width:11.58em;height:2.58em;"/></p>
<p>When the fitness score is less than or equal to <kbd>0.01</kbd>, it will be assigned the minimal fitness score value (<kbd>0.01</kbd>) supported; otherwise, it will be used as is. We selected the minimal fitness score to be higher than zero to give every genome the chance to reproduce.</p>
<p>The following code in Python implements the goal-oriented objective function:</p>
<pre>    # Calculate the fitness score based on distance from exit<br/>    fitness = env.agent_distance_to_exit()<br/>    if fitness &lt;= self.exit_range:<br/>         fitness = 1.0<br/>    else:<br/>        # Normalize fitness score to range (0,1]<br/>        fitness = (env.initial_distance - fitness) / \<br/>                   env.initial_distance<br/>        if fitness &lt;= 0.01:<br/>            fitness = 0.01</pre>
<p class="p1">The code first invokes the <kbd>agent_distance_to_exit()</kbd> function, which calculates the Euclidean distance from the current agent position to the maze exit and uses the returned value as a first approximation of the fitness score. After that, the fitness score (distance to the maze exit) is compared with the exit range value. If the fitness score is less or equal to the exit range value, we assign it the final value of <kbd>1.0</kbd>. Otherwise, the normalized fitness score is calculated as a division of the difference between the final and initial distances from the agent to the maze exit by the initial distance. Sometimes, this can lead to a negative value of the normalized fitness value, which is corrected by comparing the fitness value with <kbd>0.01</kbd> and making the necessary amendments.</p>
<p>See the <kbd>maze_environment.py</kbd> script for complete implementation details.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the experiment with a simple maze configuration</h1>
                
            
            
                
<p>We start our experiments related to the creation of the successful maze navigation agent with a simple maze configuration. The simple maze configuration, while having the deceptive <em>local optima cul-de-sacs</em> discussed earlier, has a relatively straightforward path from the start point to the exit point.</p>
<p>The following diagram represents the maze configuration used for this experiment:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-767 image-border" src="img/a30ae052-0e37-42e9-bc05-602ff422106d.png" style="width:27.00em;height:11.58em;"/></p>
<p>The simple maze configuration</p>
<p>The maze in the diagram has two specific positions marked with filled circles. The top-left circle denotes the starting position of the maze navigator agent. The bottom-right circle marks the exact location of the maze exit that needs to be found by the maze solver. The maze solver is required to reach the vicinity of the maze exit point denoted by the specific exit range area around it in order to complete the task.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hyperparameter selection</h1>
                
            
            
                
<p>According to the objective function definition, the maximum value of the navigator agent fitness score that can be obtained by reaching the maze exit area is <kbd>1.0</kbd>. We are also expecting that the initial configuration of the controller ANN is more complicated than in the previous experiments described earlier in the book, and this will impact the speed of the algorithm's execution. Due to this, it would take too long on a moderate PC to complete the neuroevolution algorithm with a significantly large genome population. But at the same time, the task at hand is much more complicated than in previous experiments and requires using a wider search area for successful solution exploration. Thus, through trial and error, we found that the population size can be set to <kbd>250</kbd>.</p>
<p>The following section from the configuration file contains the definition of the parameters we've just discussed:</p>
<pre>[NEAT]<br/>fitness_criterion = max<br/>fitness_threshold = 1.0<br/>pop_size = 250<br/>reset_on_extinction = False</pre>
<p>The initial configuration of the phenotype ANN includes <kbd>10</kbd> input nodes, <kbd>2</kbd> output nodes, and <kbd>1</kbd> hidden node. The input and output nodes correspond to the input sensors and the control signal outputs. The hidden node is provided to introduce non-linearity from the start of the neuroevolutionary process and to save time for the evolution process to discover it. The ANN configuration is as follows:</p>
<pre>num_hidden = 1<br/>num_inputs = 10<br/>num_outputs = 2</pre>
<p>To extend the solution search area, we need to boost the speciation of the population to try different genome configurations within a limited number of generations. This can be done either by reducing the compatibility threshold or by increasing the values of the coefficients that are used to perform the calculation of genome compatibility scores.</p>
<p>In this experiment, we used both amendments because the fitness function landscape is deceptive, and we need to emphasize even tiny changes in the genome configurations to create a new species. The following configuration parameters are affected:</p>
<pre>[NEAT]<br/>compatibility_disjoint_coefficient = 1.1<br/>[DefaultSpeciesSet]<br/>compatibility_threshold = 3.0</pre>
<p>We are particularly interested in creating the optimal configuration of a maze solver control ANN that has a minimum number of hidden nodes and connections. The optimal ANN configuration is less computationally expensive during training by the neuroevolutionary process, as well as during the inference phase in a maze-solving simulator. The optimal ANN configuration can be produced by reducing the likelihood of adding new nodes, as shown in the following snippet from the NEAT configuration file:</p>
<pre>node_add_prob          = 0.1<br/>node_delete_prob       = 0.1</pre>
<p>Finally, we allow the neuroevolutionary process to exploit not only the ANN configurations with feed-forward connections, but also recurrent ones. By having the recurrent connections, we enable the possibility for the ANN to have a memory and become a state machine. This happens to be beneficial for the evolutionary process. The following configuration hyperparameter controls this behavior:</p>
<pre>feed_forward            = False</pre>
<p>The hyperparameters described in this section were found to be beneficial to the NEAT algorithm that is used in the experiment to create a successful maze-solving agent within a limited number of generations.</p>
<p>For the complete list of the hyperparameters used in the simple maze-solving experiment, please refer to the <kbd>maze_config.ini</kbd> file at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_config.ini">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_config.ini</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maze configuration file</h1>
                
            
            
                
<p>The maze configuration for our experiment is provided in plain text. This file is loaded into the simulation environment, and the corresponding maze configuration becomes instantiated. The configuration file has content similar to the following:</p>
<pre>11<br/>30 22<br/>0<br/>270 100<br/>5 5 295 5<br/>295 5 295 135<br/>295 135 5 135<br/>…</pre>
<p class="p1">The format of the maze configuration file is as follows:</p>
<ul class="ul1">
<li class="li1">The first line holds the number of walls in the maze.</li>
<li class="li1">The second line determines the agent's starting position (<em>x</em>, <em>y</em>).</li>
<li class="li1">The third line denotes the initial heading of the agent in degrees.</li>
<li class="li1">The fourth line holds the maze exit position (<em>x</em>, <em>y</em>).</li>
<li class="li1">The following lines define the walls of the maze. The number of maze walls is given by the first number in the file.</li>
</ul>
<p>The maze wall is presented as a line segment with the first two numbers defining the coordinates of the starting point and the last two numbers determining the coordinates of the endpoint. The starting position of the agent and the maze exit are presented in the form of two numbers indicating the <em>x</em> and <em>y</em> coordinates of a point in a two-dimensional space.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working environment setup</h1>
                
            
            
                
<p class="p1">The working environment for the simple maze-solving experiment can be set up with the following commands entered in your terminal application of choice:</p>
<pre><strong>$ conda create --name maze_objective_neat python=3.5</strong><br/><strong>$ conda activate maze_objective_neat</strong><br/><strong>$ pip install neat-python==0.92 </strong><br/><strong>$ conda install matplotlib</strong><br/><strong>$ conda install graphviz</strong><br/><strong>$ conda install python-graphviz</strong></pre>
<p>These commands create and activate a <kbd>maze_objective_neat</kbd> virtual environment with Python 3.5. After that, the NEAT-Python library with version 0.92 was installed, along with other dependencies used by our visualization utilities.</p>
<p>After that, we are ready to start with the implementation of the experiment runner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The experiment runner implementation</h1>
                
            
            
                
<p class="p1">The experiment runner is implemented in the <kbd>maze_experiment.py</kbd> file, which you should refer to for the complete implementation details. This Python script provides functions to read command-line arguments, to configure and start the neuroevolution process, and to render the experiment's results after completion. Also, it includes the implementation of callback functions to evaluate the fitness of genomes belonging to the particular population. These callback functions will be provided to the NEAT-Python library environment during the initialization.</p>
<p class="p1">Further, we discuss the essential parts of the experiment runner's implementation that were not addressed previously in this chapter:</p>
<ol>
<li class="mce-root">We begin by initializing the maze simulation environment with the following lines:</li>
</ol>
<pre style="padding-left: 60px">    maze_env_config = os.path.join(local_dir, '%s_maze.txt' % <br/>                                   args.maze)<br/>    maze_env = maze.read_environment(maze_env_config)</pre>
<p class="p1" style="padding-left: 60px"><kbd>args.maze</kbd> refers to the command-line argument supplied by the user when starting the Python script and refers to the type of maze environment with which we would like to experiment. It can have two values: <em>medium</em> and <em>hard</em>. The former refers to the simple maze configuration that we use in this experiment.</p>
<ol start="2">
<li>After that, we set the specific seed number for the random number generator, create the NEAT configuration object, and create the <kbd>neat.Population</kbd> object using the created configuration object:</li>
</ol>
<pre style="padding-left: 60px">    seed = 1559231616<br/>    random.seed(seed)<br/>    config = neat.Config(neat.DefaultGenome, <br/>                         neat.DefaultReproduction,<br/>                         neat.DefaultSpeciesSet, <br/>                         neat.DefaultStagnation,<br/>                         config_file)<br/>    p = neat.Population(config)</pre>
<p>It happens that the random seed value found in the double-pole balancing experiment is suitable for this experiment too. We can assume that we found a random attractor that is specific to the stochastic process implemented by the NEAT-Python library. Later in the book, we will check whether this is true for other experiments as well.</p>
<ol start="3">
<li>Now we are ready to create the appropriate maze simulation environment and store it as a global variable to simplify access to it from the fitness evaluation callback functions:</li>
</ol>
<pre style="padding-left: 60px">    global trialSim<br/>    trialSim = MazeSimulationTrial(maze_env=maze_env, <br/>                                   population=p)</pre>
<p class="p1" style="padding-left: 60px">The <kbd>MazeSimulationTrial</kbd> object holds fields that provide access to the original maze simulation environment and to the record store used to save the evaluation results of the maze-solver agents. At each call to the fitness evaluation callback function, <kbd>eval_fitness(genome_id, genome, config, time_steps=400)</kbd>, the original maze simulation environment will be duplicated and will be used for the maze-solving simulation by a specific solver agent for 400 time steps. After that, the full statistics about the maze-solver agent, including its final position within the maze, will be collected from the environment and added to the record store.</p>
<ol start="4">
<li>The following code has become standard for our experiments, and it is related to adding various statistics reporters:</li>
</ol>
<pre style="padding-left: 60px">    p.add_reporter(neat.StdOutReporter(True))<br/>    stats = neat.StatisticsReporter()<br/>    p.add_reporter(stats)<br/>    p.add_reporter(neat.Checkpointer(5, <br/>                 filename_prefix='%s/maze-neat-checkpoint-' % <br/>                 trial_out_dir))</pre>
<p style="padding-left: 60px">The reporters are used to display the intermediate results of the neuroevolution process to the console, as well as to collect more detailed statistics that will be rendered after the process is completed.</p>
<ol start="5">
<li>Finally, we run the neuroevolution process for the specified number of generations and check whether the solution has been found:</li>
</ol>
<pre style="padding-left: 60px">    start_time = time.time()<br/>    best_genome = p.run(eval_genomes, n=n_generations)<br/>    elapsed_time = time.time() - start_time<br/>    solution_found = (best_genome.fitness &gt;= \<br/>                      config.fitness_threshold)<br/>    if solution_found:<br/>        print("SUCCESS: The stable maze solver controller was found!!!")<br/>    else:<br/>        print("FAILURE: Failed to find the stable maze solver controller!!!")</pre>
<p>We assume that a solution has been found if the best genome returned by the NEAT-Python library has a fitness score that is greater than or equal to the fitness threshold value set in the configuration file (<kbd>1.0</kbd>). The elapsed time is calculated to print how long it took to complete the process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Genome fitness evaluation</h1>
                
            
            
                
<p>The callback function to evaluate the fitness scores of all genomes belonging to a particular population of organisms is implemented as follows:</p>
<pre>def eval_genomes(genomes, config):<br/>    for genome_id, genome in genomes:<br/>        genome.fitness = eval_fitness(genome_id, genome, config)</pre>
<p class="mce-root"/>
<p class="p1">The <kbd>eval_fitness(genome_id, genome, config)</kbd> function evaluates the fitness of a specific genome by running the maze-solving simulation against the solver agent controlled by the ANN encoded with this genome. The implementation of this function is not provided here as it has already been discussed in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the simple maze navigation experiment</h1>
                
            
            
                
<p class="p1">Having implemented the maze-solver simulator, as well as the experiment runner and fitness evaluation callbacks, we are ready to start a maze-solving experiment. Make sure you copy all the related Python scripts and configuration files (<kbd>maze_config.ini</kbd> and <kbd>medium_maze.txt</kbd>) into the working directory.</p>
<p class="p1">After that, enter this directory and execute the following command from your terminal application of choice:</p>
<pre><strong>$ python maze_experiment.py -m medium -g 150</strong></pre>
<p>Do not forget to activate the appropriate virtual environment with the following command:<br/>
<br/> <kbd>conda activate maze_objective_neat</kbd></p>
<p class="p1">The preceding command loads the simple maze configuration from the <kbd>medium_maze.txt</kbd> file and creates the appropriate maze simulation environment. After that, it launches the neuroevolutionary process under the control of the NEAT algorithm, using the hyperparameters specified in the <kbd>maze_config.ini</kbd><em> </em>file. The NEAT algorithm uses a maze-solver simulation environment to evaluate the fitness of every genome produced during the neuroevolution over <kbd>150</kbd> generations<br/>
(<kbd>-g</kbd> in the command-line arguments).</p>
<p>After <kbd>144</kbd> generations of evolution, the successful maze-solver agent is found at generation <kbd>145</kbd>. The console output for the last generation is as follows:</p>
<ol>
<li>First, general statistics about the genome population:</li>
</ol>
<pre style="padding-left: 60px"><strong>****** Running generation 145 ****** </strong><br/><br/><strong>Maze solved in 388 steps</strong><br/><strong>Population's average fitness: 0.24758 stdev: 0.25627</strong><br/><strong>Best fitness: 1.00000 - size: (3, 11) - species 7 - id 35400</strong><br/><br/><strong>Best individual in generation 145 meets fitness threshold - complexity: (3, 11)</strong></pre>
<ol start="2">
<li>Second, the configuration of the genome encoding the successful maze-solver controller ANN:</li>
</ol>
<pre style="padding-left: 60px"><strong>Best genome:</strong><br/><strong>Key: 35400</strong><br/><strong>Fitness: 1.0</strong><br/><strong>Nodes:</strong><br/><strong>  0 DefaultNodeGene(key=0, bias=5.534849614521037, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>  1 DefaultNodeGene(key=1, bias=1.8031133229851957, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>  158 DefaultNodeGene(key=158, bias=-1.3550878188609456, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>Connections:</strong><br/><strong>  DefaultConnectionGene(key=(-10, 158), weight=-1.6144052085440168, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-8, 158), weight=-1.1842193888036392, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-7, 0), weight=-0.3263706518456319, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-7, 1), weight=1.3186165993348418, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-6, 0), weight=2.0778575294986945, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-6, 1), weight=-2.9478037554862824, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-6, 158), weight=0.6930281879212032, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-4, 1), weight=-1.9583885391583729, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-3, 1), weight=5.5239054588484775, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-1, 0), weight=0.04865917999517305, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(158, 0), weight=0.6973191076874032, enabled=True)</strong><br/><strong>SUCCESS: The stable maze solver controller was found!!!</strong><br/><strong>Record store file: out/maze_objective/medium/data.pickle</strong></pre>
<p>In the console output, you can see that the successful maze solver controller was found during evolution and was able to reach the maze exit area in 388 steps from the allotted 400. The configuration of the control ANN of the successful maze solver consists of 2 output nodes and 1 hidden node, with 11 connections in between these nodes and from the inputs. The final configuration of the controller ANN is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-768 image-border" src="img/1f5be19e-6d05-4715-8a90-d99e2c4d8c7f.png" style="width:39.00em;height:17.00em;"/></p>
<p>The ANN configuration controlling a successful solver of a simple maze</p>
<p class="p1">It is interesting to look at the graph to study how different sensor inputs influence the output control signals. We can see that the ANN configuration completely ignores the inputs from the front and left rangefinder sensors (<strong>RF_FR</strong> and <strong>RF_L</strong>) and from the backward pie-slice radar sensor (<strong>RAD_B</strong>) of the robot. At the same time, the linear and angular velocities of the robot are controlled by unique combinations of other sensors.</p>
<p class="p1">Furthermore, we can see the aggregation of the left and right pie-slice radar sensors (<strong>RAD_L</strong> and <strong>RAD_R</strong>) with the backward rangefinder (<strong>RF_B</strong>) through the hidden node, which then relayed an aggregated signal to a node controlling the angular velocity. If we take a look at the simple maze configuration image shown in this chapter (see the simple maze configuration image), the aggregation seems pretty natural. This allows the robot to turn around and continue to explore the maze when it is trapped in dead ends, where the local fitness optima are located.</p>
<p>The fitness scores of the solver agents over generations is shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-769 image-border" src="img/7742ca6f-7471-4c1c-a546-46feb0ed5a9e.png" style="width:36.42em;height:28.75em;"/></p>
<p>The average fitness scores over generations</p>
<p>In this plot, we can see that the evolutionary process was able to produce pretty successful maze-solver agents at generation <kbd>44</kbd> with a fitness score of <strong>0.96738</strong>. But it took an additional 100 generations to evolve the genome that encodes the ANN of the successful maze-solver agent.</p>
<p>Also, it is interesting to note that the boost in performance at generation <kbd>44</kbd> is generated by the species with ID <kbd>1</kbd>, but the genome of the successful maze solver belongs to a species with ID <kbd>7</kbd>, which was not even known at the time of the first spike. The species producing the champion appeared after 12 generations and remained in the population until the end, preserving the beneficial mutation and elaborating over it.</p>
<p>The speciation over generations is shown in the following plot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-770 image-border" src="img/496ddb2e-cbce-463a-8e06-8079fe6bd57c.png" style="width:33.58em;height:26.33em;"/></p>
<p>The speciation over generations</p>
<p>On the speciation plot, we can see the species with ID <kbd>7</kbd> marked in pink. This species ultimately produced the genome of the successful maze solver during the evolutionary process. The size of species 7 varies considerably throughout its life, and at one time it was the only species in the entire population for several generations (from 105 until 108).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Agent record visualization</h1>
                
            
            
                
<p>In this experiment, we presented a new visualization method that allows us to visually discern the performance of various species in the evolutionary process. The visualization can be performed using the following command, executed from the working directory of the experiment:</p>
<pre><strong>$ python visualize.py -m medium -r out/maze_objective/medium/data.pickle --width 300 --height 150</strong></pre>
<p>The command loads records about the fitness evaluation of each maze-solving agent during the evolution, which is stored in the <kbd>data.pickle</kbd> file. After that, it draws the final positions of the agents on the maze map at the end of the maze-solving simulation. Each agent's final position is presented as a color-coded circle. The color of the circle encodes the species to which the particular agent belongs. Each species produced during the evolution has a unique color code. The results of this visualization can be seen in the following plot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-771 image-border" src="img/0618c36d-4f70-4b38-91e4-9c565ea53733.png" style="width:31.83em;height:30.50em;"/></p>
<p>The visualization of the evaluation of the solver agents</p>
<p>To make the visualization more informative, we have introduced the fitness threshold to filter out the most performant species. The top subplot shows the final positions of the solver agents belonging to the champion species (the fitness score is above <strong>0.8</strong>). As you can see, the organisms belonging to these six species are active explorers, who have genes inciting search through unknown places in the maze. Their final locations are distributed almost uniformly through the maze area around the starting point and have a low density at the local optima <em>cul-de-sacs</em>.</p>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>At the same time, you can see in the bottom subplot that the evolutionary losers demonstrate more conservative behavior, concentrating mainly near the walls in the starting area and in the strongest local optima region—the biggest <em>cul-de-sac</em>, which is at the bottom of the maze.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<ol class="ol1">
<li class="li1">Try to increase the <kbd>compatibility_disjoint_coefficient</kbd> parameter in the <kbd>maze_config.ini</kbd> file and run the experiment with new settings. What impact does this modification have on the number of species produced during the evolution? Is the neuroevolution process able to find a successful maze solver?</li>
<li class="li1">Increase the population size by 200% (the <kbd>pop_size</kbd> parameter). Was the neuroevolution process able to find a solution in this case, and if so, how many generations did it take?</li>
<li class="li1">Change the seed value of the random number generator (see line 118 of the <kbd>maze_experiment.py</kbd> file). Does the neuroevolution process succeed with this new value?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the experiment with a hard-to-solve maze configuration</h1>
                
            
            
                
<p>The next experiment in this chapter is to run the neuroevolution process to find an agent that can solve a maze with a more complex configuration of walls. This hard-to-solve maze configuration introduces powerful local fitness optima traps and does not have a straightforward route from the start position of the agent to the exit area of the maze. You can see the maze configuration in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-772 image-border" src="img/b6a9ca88-aa2a-4fa0-b0b9-976e1312b55a.png" style="width:20.25em;height:19.33em;"/></p>
<p>The hard-to-solve maze configuration</p>
<p class="p1">The maze configuration has its start position in the bottom-left corner, marked with a green circle, and the position of the maze exit point is in the top-left corner, marked with a red circle. You can see that, to solve the maze, the navigator agent must develop a complex control strategy that allows it to avoid the local fitness optima traps around the starting point. The control strategy needs to be able to follow an elaborate trajectory from the starting point to the exit, which has several turns and more local optima traps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hyperparameter selection</h1>
                
            
            
                
<p>For this experiment, we will use the same hyperparameters that we used in the simple maze solving experiment. Our idea is to have the same initial conditions for the neuroevolutionary algorithm and to see whether it can evolve a successful solver agent for a different, more complex maze configuration. This will indicate how well the algorithm generalizes using the hyperparameter settings used for a different maze configuration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working environment setup and experiment runner implementation</h1>
                
            
            
                
<p>The setup of the working environment remains the same as for a simple maze navigation experiment. The experiment runner implementation also remains the same. We only change the file describing the maze environment configuration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the hard-to-solve maze navigation experiment</h1>
                
            
            
                
<p>As we mentioned, we will use the same experiment runner implementation and the same NEAT hyperparameters settings as in the previous experiment. But we will configure the different maze environment as follows:</p>
<pre><strong>$ python maze_experiment.py -m hard -g 500</strong></pre>
<p>After a while, when the experiment is over, we see that even after <kbd>500</kbd> generations of evolution, a successful maze solver has not been found. The best genome obtained using the neuroevolution algorithm encodes a bizarre and non-functional controller ANN configuration, which is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-773 image-border" src="img/86d45012-74e5-49fd-b7e1-b5d3cd3ee482.png" style="width:40.08em;height:21.25em;"/></p>
<p>ANN configuration controlling the solver of the hard-to-solve maze</p>
<p>It can be seen in the graph that the rotation of the robot depends only on the frontal rangefinder sensor (<strong>RF_FR</strong>), and the linear movement is controlled by a combination of several rangefinders and radar sensors. Such control configuration leads to simplified linear movements of the robot until a wall is detected in front of the robot. Our assumption about motion patterns is confirmed when we look at the visualization of the agent evaluation records:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-774 image-border" src="img/5c570b8e-b28f-4f8f-afbe-59f83f72ed85.png" style="width:15.75em;height:33.00em;"/></p>
<p>The visualization of solver agents' evaluation records</p>
<p>The visualization of the final positions of the solver agents demonstrates that most species are trapped around the start position, where some areas of local fitness score optima are located. None of the species could even show a fitness score above our threshold (<strong>0.8</strong>). Also, as we mentioned earlier, there are clearly distinguishable vertical lines formed by the final positions of the solver agents (gray dots creating vertical columns). This confirms our assumption about the incorrect configuration of the controller ANN that was encoded by the best genome found during the evolutionary process.</p>
<p class="p1">The average fitness scores over generations are shown in the following plot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-775 image-border" src="img/8988407f-0d34-4c5e-9cb0-823a070d778c.png" style="width:30.75em;height:24.50em;"/></p>
<p>The average fitness score over generations</p>
<p>In the plot of the average fitness scores, we can see that the neuroevolutionary process was able to significantly increase the fitness scores of solver agents in the very first generations, but after that it reached a plateau, showing no improvements. This means that a further increase in the number of evolutionary generations does not make any sense, and other measures need to be taken to improve the performance of the neuroevolutionary process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<ol class="ol1">
<li class="li1">Try to increase the population size by tweaking the <kbd>pop_size</kbd> parameter in the <kbd>maze_config.ini</kbd> file. Did this help the neuroevolutionary process to evolve a successful maze solver?</li>
</ol>
<p>This may take a long time to execute.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="p1">In this chapter, you have learned about a class of planning and control problems that use goal-oriented fitness functions that have a deceptive definition landscape. In this landscape, there are multiple traps created by the local optima areas of the fitness function that mislead the solution search process, which is based only on the fitness score calculated as a derivative of the distance from the agent to the goal. You have learned that the conventional goal-oriented fitness function can help the search process to create a successful maze navigator agent for a simple maze configuration, but failed with a more complex maze due to the local optima traps.</p>
<p>We presented a useful visualization method that allowed us to visualize the final positions of all evaluated agents on the maze map. With this visualization, you can make assumptions about the performance of the evolutionary process. You can then make decisions about changes to the configuration settings that may lead to further performance improvements.</p>
<p>Also, you have learned that when there is a higher chance of fitness function convergence in the local optima, the neuroevolution process tends to produce fewer species. In extreme cases, it creates only one species, which impedes innovation and hinders the evolutionary process. To avoid this, you learned how speciation can be boosted by changing the value of the compatibility disjoint coefficient, which is used in the calculation of the genome compatibility factor. This coefficient controls the weight that will be assigned to the excess or disjoint parts of genomes being compared. Higher coefficient values increase the importance of topological differences in the compared genomes and allow more diverse genomes to belong to the same species.</p>
<p>In the next chapter, we will present the NS optimization method, which is better at solving deceptive tasks such as maze navigation.</p>


            

            
        
    </body></html>