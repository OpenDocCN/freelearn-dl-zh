<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-33">
    <a id="_idTextAnchor035">
    </a>
    
     2
    
   </h1>
   <h1 id="_idParaDest-34">
    <a id="_idTextAnchor036">
    </a>
    
     Introducing the Unreal Engine AI System
    
   </h1>
   <p>
    
     Welcome to the exciting world of AI programming with Unreal Engine!
    
    
     In this chapter, I’ll be introducing you to Unreal Engine’s powerful tools that will bring life and intelligence to your virtual worlds.
    
    
     By exploring various aspects of the Unreal Engine AI system, such as moving agents using the
    
    <strong class="bold">
     
      Navigation System
     
    </strong>
    
     , implementing semi-intelligent behaviors through
    
    <strong class="bold">
     
      behavior trees
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Blackboards
     
    </strong>
    
     , and incorporating features such as smart objects and
    
    <strong class="bold">
     
      mass entities
     
    </strong>
    
     , you will gain a comprehensive understanding of the remarkable capabilities offered by this
    
    
     
      robust framework.
     
    
   </p>
   <p>
    
     Mastering these skills will elevate you to the ranks of elite game programmers – and who wouldn’t want to be one
    
    
     
      of those?
     
    
   </p>
   <p>
    
     By the end of this chapter, you will have a sharp vision of what can be accomplished using the Unreal Engine AI system, empowering you to create advanced AI pawns in
    
    
     
      your projects.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Getting to know the Unreal Engine
     
     
      
       Gameplay Framework
      
     
    </li>
    <li>
     
      Presenting the Unreal Engine
     
     
      
       AI system
      
     
    </li>
    <li>
     
      Understanding advanced
     
     
      
       AI features
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-35">
    <a id="_idTextAnchor037">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     There are no technical requirements to follow for
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-36">
    <a id="_idTextAnchor038">
    </a>
    
     Getting to know the Unreal Engine Gameplay Framework
    
   </h1>
   <p>
    
     As you may already know, Unreal Engine provides an out-of-the-box system called
    
    <strong class="bold">
     
      Gameplay Framework
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GF
     
    </strong>
    
     ) that includes many features necessary for developing a game; this spans from having an advanced input
    
    <a id="_idIndexMarker046">
    </a>
    
     system to common entry points that will allow you to easily access data or
    
    
     
      game state.
     
    
   </p>
   <p>
    
     Here are some key points explaining why the GF is
    
    
     
      so important:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Structure and organization
      
     </strong>
     
      : The GF provides a structured and organized approach to developing games.
     
     
      It offers a
     
     <a id="_idIndexMarker047">
     </a>
     
      collection of systems, classes, and interfaces that work together to create the core structure of
     
     
      
       a game.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Game logic and progression
      
     </strong>
     
      : This framework includes predefined concepts that help define the logic, progression, and organization of
     
     
      
       a game.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Player and AI control
      
     </strong>
     
      : The GF includes systems for handling player input and decision-making for characters within the game world.
     
     
      This encompasses player and AI control, which are essential for creating interactive and immersive
     
     
      
       gaming experiences.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Utility functions
      
     </strong>
     
      : The framework provides a library of utility functions that assist with common gameplay operations and interactions.
     
     
      These functions can streamline gameplay logic and enhance efficiency in implementing
     
     
      
       various functionalities.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Flexibility and integration
      
     </strong>
     
      : The GF is highly flexible and integrates deeply with the Unreal Engine.
     
     
      It uses common game programming patterns and performs heavy lifting, allowing developers to focus on building their games rather than creating their own
     
     
      
       game framework.
      
     
    </li>
   </ul>
   <p>
    
     As a personal reflection, I have found that using and comprehending the GF over the years has significantly enhanced my overall understanding of game programming
    
    
     
      best practices.
     
    
   </p>
   <p>
    
     Quite obviously, managing an AI system is also part of the GF job, so, in the next subsections, I will provide you with a concise introduction to the key AI features available in the GF, enabling you
    
    <a id="_idIndexMarker048">
    </a>
    
     to be prepared for
    
    
     
      their use.
     
    
   </p>
   <h2 id="_idParaDest-37">
    <a id="_idTextAnchor039">
    </a>
    
     Actors and components
    
   </h2>
   <p>
    
     I’m pretty sure you’re
    
    <a id="_idIndexMarker049">
    </a>
    
     already familiar with
    
    <strong class="bold">
     
      actors
     
    </strong>
    
     and
    
    <strong class="bold">
     
      components
     
    </strong>
    
     in Unreal Engine, but just in case, let’s do a quick refresher on both
    
    
     
      of them.
     
    
   </p>
   <p>
    
     In Unreal Engine, an
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     class refers to any entity that can be placed within a level, whether it’s a camera, a static mesh, or the player’s character.
    
    
     An actor can undergo transformations such as translation, rotation,
    
    
     
      and scaling.
     
    
   </p>
   <p>
    
     Actors serve as containers for specialized
    
    <a id="_idIndexMarker050">
    </a>
    
     classes known as
    
    <strong class="bold">
     
      components
     
    </strong>
    
     that play various roles in controlling a movement, rendering, and more.
    
    
     There are three types of components that serve different purposes within
    
    
     
      an actor:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Actor components
      
     </strong>
     
      : These primarily
     
     <a id="_idIndexMarker051">
     </a>
     
      contain code logic for an actor.
     
     
      They
     
     <a id="_idIndexMarker052">
     </a>
     
      handle various functionalities and interactions without any
     
     
      
       visual representation.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Scene components
      
     </strong>
     
      : These are used to position and orient other components within the actor.
     
     
      They serve as reference
     
     <a id="_idIndexMarker053">
     </a>
     
      points for transformations such as
     
     <a id="_idIndexMarker054">
     </a>
     
      translation, rotation, and scaling but do not have any visible presence and are mainly used for
     
     
      
       organizational purposes.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Primitive components
      
     </strong>
     
      : These are
     
     <a id="_idIndexMarker055">
     </a>
     
      responsible for the visual
     
     <a id="_idIndexMarker056">
     </a>
     
      representation of an actor within a level.
     
     
      They can be rendered and interacted with by players or
     
     
      
       other objects.
      
     
    </li>
   </ul>
   <p>
    
     By combining these components, a game developer can create complex and interactive actors with both functional and
    
    
     
      visual aspects.
     
    
   </p>
   <h2 id="_idParaDest-38">
    <a id="_idTextAnchor040">
    </a>
    
     Main GF elements
    
   </h2>
   <p>
    
     The Unreal Engine GF is a comprehensive collection of classes that serves as a modular foundation for constructing
    
    <a id="_idIndexMarker057">
    </a>
    
     gameplay experiences.
    
    
     Within this framework, game developers have the freedom to handpick specific elements that best suit the game, while being assured that these classes are intricately designed to seamlessly work together and enhance
    
    
     
      one another.
     
    
   </p>
   <p>
    
     In the upcoming subsections, we will present the main elements involved to have a clear view of how
    
    
     
      things work.
     
    
   </p>
   <h3>
    
     GameInstance
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      GameInstance
     
    </strong>
    
     class
    
    <a id="_idIndexMarker058">
    </a>
    
     serves as a manager that operates behind the scenes (i.e., it is not an Unreal Engine actor); a single instance is created when the engine launches and the instance remains active until the engine shuts down.
    
    
     Its primary purpose is to track data and execute code
    
    
     
      as needed.
     
    
   </p>
   <p>
    
     A game instance provides a handy central hub for managing persistent data, such as save game systems, and acts as a manager for other subsystems, offering convenient control over the flow of
    
    
     
      your game.
     
    
   </p>
   <h3>
    
     GameMode
    
   </h3>
   <p>
    
     Different from the
    
    <strong class="source-inline">
     
      GameInstance
     
    </strong>
    
     class, the
    
    <strong class="source-inline">
     
      GameModeBase
     
    </strong>
    
     or its direct descendant,
    
    <strong class="source-inline">
     
      GameMode
     
    </strong>
    
     , instance only exists in a single level and is created right after
    
    <a id="_idIndexMarker059">
    </a>
    
     the level itself has been loaded and the world has been constructed.
    
    
     This class serves as a manager to handle a gameplay session, and each level can have its own different game mode logic.
    
    
     Its main role is to create the remaining
    
    
     
      framework actors.
     
    
   </p>
   <h3>
    
     GameState and PlayerState
    
   </h3>
   <p>
    <strong class="source-inline">
     
      GameState
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PlayerState
     
    </strong>
    
     are specialized
    
    <a id="_idIndexMarker060">
    </a>
    
     actors that play a key
    
    <a id="_idIndexMarker061">
    </a>
    
     role in tracking the state of the game and the players involved.
    
    
     The game state is responsible for storing and handling data pertinent to all players in a game, while the player state focuses on a specific player.
    
    
     Given their inherent characteristics, these classes find their primary application in multiplayer games, regardless of whether they are played online
    
    
     
      or locally.
     
    
   </p>
   <h3>
    
     Pawn and Character
    
   </h3>
   <p>
    
     A
    
    <strong class="bold">
     
      pawn
     
    </strong>
    
     refers to the
    
    <a id="_idIndexMarker062">
    </a>
    
     base class of all actors that can be controlled by players or AI entities within the game world.
    
    
     It serves as the physical representation of an entity, handling its involvement within the game world, including collisions and other physical interactions.
    
    
     It is also usually used to determine the visual appearance of
    
    
     
      an entity.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Pawn
     
    </strong>
    
     class gains additional
    
    <a id="_idIndexMarker063">
    </a>
    
     functionality through the
    
    <a id="_idIndexMarker064">
    </a>
    
     more advanced
    
    <strong class="source-inline">
     
      Character
     
    </strong>
    
     class.
    
    
     The character class is specifically designed to represent players in a vertically oriented manner, enabling them to perform a wide range of actions such as walking, running, jumping, and swimming within a level.
    
    
     As a side note, the character class incorporates essential features for
    
    
     
      multiplayer handling.
     
    
   </p>
   <h3>
    
     Controller
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     class
    
    <a id="_idIndexMarker065">
    </a>
    
     is responsible for governing the logic that determines a player’s actions within the game world.
    
    
     Two widely used types of controller classes are
    
    <strong class="source-inline">
     
      PlayerController
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      AIController
     
    </strong>
    
     ; the second option is something we eagerly anticipate, for
    
    
     
      obvious reasons.
     
    
   </p>
   <p>
    
     The player controller class acts as a managerial entity, capable of processing input from a human player, enabling interaction with the game environment and facilitating their overall gameplay experience.
    
    
     On the other hand, the AI controller governs the actions of an AI entity by using behavior trees, state trees, navigation,
    
    
     
      and more.
     
    
   </p>
   <p>
    
     The player controller and the AI controller classes can manage a character or a pawn by possessing them
    
    
     
      at runtime.
     
    
   </p>
   <h2 id="_idParaDest-39">
    <a id="_idTextAnchor041">
    </a>
    
     GameplayStatics
    
   </h2>
   <p>
    
     Unreal Engine provides a really helpful function library called
    
    <strong class="source-inline">
     
      GameplayStatics
     
    </strong>
    
     , which provides various utility functions for gameplay-related
    
    <a id="_idIndexMarker066">
    </a>
    
     tasks.
    
    
     These functions can be used to perform common gameplay operations and interactions within
    
    
     
      the engine.
     
    
   </p>
   <p>
    
     Some examples of these functions are spawning and destroying actors, retrieving information about the game world, managing gameplay tags, manipulating game instances, and more.
    
    
     These functions can be accessed and used from both Blueprint visual scripting and C++ programming and can streamline gameplay logic and serve as a valuable tool for managing and manipulating game elements
    
    
     
      during runtime.
     
    
   </p>
   <p>
    
     Now that I have dished out some Unreal Engine GF knowledge, get ready for the juiciest part (at least in the context of this book): how AI dives into the intricate workings of the engine, equipping you with the knowledge to embark
    
    <a id="_idIndexMarker067">
    </a>
    
     on the marvelous journey of crafting your own
    
    
     
      game logics!
     
    
   </p>
   <h1 id="_idParaDest-40">
    <a id="_idTextAnchor042">
    </a>
    
     Presenting the Unreal Engine AI system
    
   </h1>
   <p>
    
     Given the power of the previously described framework at your disposal, it should come as no surprise that Unreal Engine provides a comprehensive and robust
    
    
     
      AI system.
     
    
   </p>
   <p>
    
     In this section, we will show the comprehensive array of tools available for Unreal Engine AI programmers along with a short description of their main features.
    
    
     To begin, let us examine the Navigation System and
    
    
     
      its functionality.
     
    
   </p>
   <h2 id="_idParaDest-41">
    <a id="_idTextAnchor043">
    </a>
    
     Navigation System
    
   </h2>
   <p>
    
     The Unreal Engine
    
    <strong class="bold">
     
      Navigation System
     
    </strong>
    
     allows for
    
    <a id="_idIndexMarker068">
    </a>
    
     AI entities, called
    
    <strong class="bold">
     
      agents
     
    </strong>
    
     , to move
    
    <a id="_idIndexMarker069">
    </a>
    
     on a level by using
    
    <a id="_idIndexMarker070">
    </a>
    
     
      pathfinding algorithms.
     
    
   </p>
   <p>
    
     The Navigation System will create a
    
    <strong class="bold">
     
      nav mesh
     
    </strong>
    
     derived from the geometry present within the level by using
    
    <a id="_idIndexMarker071">
    </a>
    
     collisions.
    
    
     This mesh is subsequently divided into tiles, which are further partitioned into polygons, thereby forming a graph.
    
    
     Agents within the system use this graph to navigate toward their intended destinations.
    
    
     Polygons have a designated cost, which helps agents determine the most optimal path based on the lowest overall cost.
    
    
     Also, the Navigation System includes a range of components and settings that can be adjusted to modify the nav mesh generation process.
    
    
     These modifications can include alterations to the costs of polygons, influencing the navigation behavior of agents within the level.
    
    
     Finally, the system allows for the connection of non-contiguous areas within the nav mesh, such as platforms and bridges, thereby facilitating seamless navigation across these spatial elements.
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     shows a level available in the
    
    <strong class="bold">
     
      Content Examples
     
    </strong>
    
     project freely available on the Epic Games Launcher; the green area is the nav mesh and the character on the left is the
    
    
     
      AI agent.
     
    
   </p>
   <div><div><img alt="Figure 2.1 – Navigation System" src="img/B31016_02_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.1 – Navigation System
    
   </p>
   <p>
    <em class="italic">
     
      Part 2
     
    </em>
    
     of this book will be
    
    <a id="_idIndexMarker072">
    </a>
    
     devoted to understanding the
    
    <a id="_idIndexMarker073">
    </a>
    
     Unreal Navigation System and how to optimize and
    
    
     
      debug it.
     
    
   </p>
   <h2 id="_idParaDest-42">
    <a id="_idTextAnchor044">
    </a>
    
     Behavior trees
    
   </h2>
   <p>
    
     In Unreal Engine, behavior trees serve as a valuable tool for creating AI for NPCs in your games.
    
    
     The primary function of a
    
    <a id="_idIndexMarker074">
    </a>
    
     behavior tree asset is to execute branches containing logical instructions.
    
    
     In Unreal Engine, behavior trees are created in a pretty similar way to Blueprints – this means you
    
    <a id="_idIndexMarker075">
    </a>
    
     will be using some kind of visual scripting method – where a sequence of nodes with specific functionality attached to them is added and connected to form a behavior
    
    
     
      tree graph.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     depicts a portion of a behavior tree from the
    
    <strong class="bold">
     
      Lyra Starter Game
     
    </strong>
    
     project available on the Epic
    
    
     
      Games Launcher:
     
    
   </p>
   <div><div><img alt="Figure 2.2 – Behavior tree example" src="img/B31016_02_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.2 – Behavior tree example
    
   </p>
   <p>
    
     To determine which branches should be executed, the behavior tree relies on another asset known as a
    
    <a id="_idIndexMarker076">
    </a>
    
     Blackboard, which acts as the
    
    <em class="italic">
     
      brain
     
    </em>
    
     for the
    
    <a id="_idIndexMarker077">
    </a>
    
     behavior tree itself.
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .3
     
    </em>
    
     shows the Blackboard corresponding
    
    <a id="_idIndexMarker078">
    </a>
    
     to the previous
    
    
     
      behavior tree:
     
    
   </p>
   <div><div><img alt="Figure 2.3 – Blackboard example" src="img/B31016_02_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.3 – Blackboard example
    
   </p>
   <p>
    
     Behavior trees and Blackboards are pretty important in AI game programming; that’s why I have
    
    <a id="_idIndexMarker079">
    </a>
    
     dedicated
    
    <em class="italic">
     
      Part 3
     
    </em>
    
     of this
    
    <a id="_idIndexMarker080">
    </a>
    
     book to
    
    
     
      this topic.
     
    
   </p>
   <h2 id="_idParaDest-43">
    <a id="_idTextAnchor045">
    </a>
    
     Mass Entity
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      Mass Entity
     
    </strong>
    
     system is a
    
    <a id="_idIndexMarker081">
    </a>
    
     gameplay-focused framework for data-oriented
    
    <a id="_idIndexMarker082">
    </a>
    
     calculations and provides a paradigm for staging elements with behavior in the game; it is designed to handle large numbers of
    
    <strong class="bold">
     
      entities
     
    </strong>
    
     and facilitate behavior controls for both skeletal and
    
    
     
      static meshes.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     shows a screenshot from the
    
    <strong class="bold">
     
      City Sample
     
    </strong>
    
     project – available on the Epic Games Launcher – that makes use of Mass Entity for both crowd and
    
    
     
      traffic control:
     
    
   </p>
   <div><div><img alt="Figure 2.4 – Mass Entity in action" src="img/B31016_02_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.4 – Mass Entity in action
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     At the time of writing this book, Mass Entity is still marked as experimental; consequently, it should be used cautiously as things may break or change as time
    
    
     
      goes by.
     
    
   </p>
   <p>
    
     Mass Entity will be presented in
    
    <em class="italic">
     
      Part 4
     
    </em>
    
     of
    
    
     
      this book.
     
    
   </p>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor046">
    </a>
    
     State tree
    
   </h2>
   <p>
    
     A
    
    <strong class="bold">
     
      state tree
     
    </strong>
    
     is a versatile hierarchical
    
    <a id="_idIndexMarker083">
    </a>
    
     state machine that integrates
    
    <a id="_idIndexMarker084">
    </a>
    
     some features from behavior trees with some others from state machines.
    
    
     With this system – organized in a tree structure – developers will be able to create highly performant logic that remains structured and adaptable.
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .5
     
    </em>
    
     shows a state tree from the aforementioned
    
    <strong class="bold">
     
      City
     
    </strong>
    
     <strong class="bold">
      
       Sample
      
     </strong>
    
    
     
      project:
     
    
   </p>
   <div><div><img alt="Figure 2.5 – State tree example" src="img/B31016_02_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.5 – State tree example
    
   </p>
   <p>
    
     I’ll be showing you how state trees work in
    
    <em class="italic">
     
      Part 4
     
    </em>
    
     of
    
    
     
      this book.
     
    
   </p>
   <h2 id="_idParaDest-45">
    <a id="_idTextAnchor047">
    </a>
    
     Smart objects
    
   </h2>
   <p>
    
     In Unreal Engine,
    
    <strong class="bold">
     
      smart objects
     
    </strong>
    
     represent a
    
    <a id="_idIndexMarker085">
    </a>
    
     set of activities in the level
    
    <a id="_idIndexMarker086">
    </a>
    
     that can be used through a reservation system that ensures that only one AI agent can use a smart object at a time, preventing other agents from using it until it becomes available again.
    
    
     These objects are placed on a level and can be interacted with by AI agents and players.
    
    
     Smart objects contain all the information
    
    <a id="_idIndexMarker087">
    </a>
    
     needed for these interactions and can be queried at runtime using dedicated filters.
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .6
     
    </em>
    
     shows a smart object asset from the
    
    <strong class="bold">
     
      City
     
    </strong>
    
     <strong class="bold">
      
       Sample
      
     </strong>
    
    
     
      project:
     
    
   </p>
   <div><div><img alt="Figure 2.6 – Smart object example" src="img/B31016_02_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.6 – Smart object example
    
   </p>
   <p>
    
     Smart objects will be
    
    <a id="_idIndexMarker088">
    </a>
    
     presented in
    
    <em class="italic">
     
      Part 4
     
    </em>
    
     of
    
    
     
      this book.
     
    
   </p>
   <h2 id="_idParaDest-46">
    <a id="_idTextAnchor048">
    </a>
    
     Environment Query System
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      Environment Query System
     
    </strong>
    
     (
    
    <strong class="bold">
     
      EQS
     
    </strong>
    
     ) collects data from the environment, enabling AIs to inquire about the
    
    <a id="_idIndexMarker089">
    </a>
    
     data using various tests.
    
    
     This process results in selecting an item that best matches the
    
    
     
      question
     
    
    
     <a id="_idIndexMarker090">
     </a>
    
    
     
      posed.
     
    
   </p>
   <p>
    
     Queries can be called from a behavior tree and used to make decisions on how to proceed based on the results of the executed tests.
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .7
     
    </em>
    
     depicts an environment query from the
    
    <strong class="bold">
     
      Lyra Starter
     
    </strong>
    
     <strong class="bold">
      
       Game
      
     </strong>
    
    
     
      project.
     
    
   </p>
   <div><div><img alt="Figure 2.7 – An environment query example" src="img/B31016_02_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.7 – An environment query example
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     At the time of writing this book, the EQS is still marked as experimental so you should use it cautiously as things may break or change as development
    
    
     
      goes on.
     
    
   </p>
   <p>
    
     I will be presenting
    
    <a id="_idIndexMarker091">
    </a>
    
     you EQS by the end of
    
    <em class="italic">
     
      Part 4
     
    </em>
    
     of this book, just after you have gained a solid understanding of how behavior
    
    
     
      trees work.
     
    
   </p>
   <h2 id="_idParaDest-47">
    <a id="_idTextAnchor049">
    </a>
    
     AI Perception System
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      AI Perception System
     
    </strong>
    
     provides another way for pawns to receive data from the environment, such as where noises
    
    <a id="_idIndexMarker092">
    </a>
    
     are coming from or if the AI sees something.
    
    
     It allows for the generation of
    
    <a id="_idIndexMarker093">
    </a>
    
     awareness for AI by providing sensory data for it.
    
    
     The system allows data sources to create stimuli so that data listeners can be periodically updated about them.
    
    
     This system is used to enable AI sensing within games and can react to an array of
    
    
     
      customizable sensors.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .8
     
    </em>
    
     shows a character from the
    
    <strong class="bold">
     
      Lyra Starter Game
     
    </strong>
    
     with a stimuli source
    
    
     
      component attached:
     
    
   </p>
   <div><div><img alt="Figure 2.8 – AI perception example" src="img/B31016_02_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.8 – AI perception example
    
   </p>
   <p>
    
     AI Perception will be
    
    <a id="_idIndexMarker094">
    </a>
    
     presented along with behavior trees in
    
    <em class="italic">
     
      Part 4
     
    </em>
    
     of this book to make your AI characters
    
    <a id="_idIndexMarker095">
    </a>
    
     aware of
    
    
     
      their surroundings.
     
    
   </p>
   <h2 id="_idParaDest-48">
    <a id="_idTextAnchor050">
    </a>
    
     AI debugging
    
   </h2>
   <p>
    
     No serious framework
    
    <a id="_idIndexMarker096">
    </a>
    
     would be complete without a debugging system.
    
    <strong class="bold">
     
      Debugging
     
    </strong>
    
     is an essential aspect of software
    
    <a id="_idIndexMarker097">
    </a>
    
     development, allowing developers to identify and fix errors or bugs in their code.
    
    
     It plays a crucial role in ensuring the reliability and functionality of
    
    
     
      the framework.
     
    
   </p>
   <p>
    
     That’s why Unreal Engine offers a full arsenal of tools and features to assist developers in debugging AI, including visual debugging tools, behavior tree visualization, and AI simulation modes.
    
    
     These tools allow developers to inspect and modify AI behavior in real time, identify issues such as pathfinding errors or erratic decision-making, and make necessary adjustments to improve the overall AI performance within the
    
    
     
      game environment.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .9
     
    </em>
    
     shows the
    
    <strong class="bold">
     
      City Sample
     
    </strong>
    
     project in action with the AI debugging
    
    
     
      tools enabled:
     
    
   </p>
   <div><div><img alt="Figure 2.9 – The debugging tools enabled in a level" src="img/B31016_02_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.9 – The debugging tools enabled in a level
    
   </p>
   <p>
    
     Throughout the book, I will be showing different techniques for debugging your game, depending on the tools
    
    <a id="_idIndexMarker098">
    </a>
    
     you will be using.
    
    
     These techniques will empower you to efficiently track down and address bugs, errors, and other issues within your game’s
    
    
     
      code logic.
     
    
   </p>
   <p>
    
     In this section, I showed you the main AI features available in the Unreal Engine GF; in the following section, I will present some of the latest technologies that have been implemented in the engine
    
    <a id="_idIndexMarker099">
    </a>
    
     involving
    
    <strong class="bold">
     
      machine learning
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       ML
      
     </strong>
    
    
     
      ) systems.
     
    
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor051">
    </a>
    
     Understanding advanced AI features
    
   </h1>
   <p>
    
     Now that you have a basic
    
    <a id="_idIndexMarker100">
    </a>
    
     understanding of the main AI features available in Unreal Engine, I’d like to present to you some of the most experimental and, to some extent,
    
    
     
      non-gameplay-related features.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Keep in mind that these features are still in experimental or beta release, so they need to be handled
    
    
     
      with care.
     
    
   </p>
   <h2 id="_idParaDest-50">
    <a id="_idTextAnchor052">
    </a>
    
     Learning Agents
    
   </h2>
   <p>
    <strong class="bold">
     
      Learning Agents
     
    </strong>
    
     is an experimental plugin designed specifically to enable you to train AI characters using ML.
    
    
     This plugin offers a unique opportunity to enhance or even replace traditional game AI systems, such
    
    <a id="_idIndexMarker101">
    </a>
    
     as behavior trees or state machines.
    
    
     With learning agents, you can leverage reinforcement learning
    
    <a id="_idIndexMarker102">
    </a>
    
     and imitation learning approaches to create intelligent and adaptive
    
    
     
      AI characters.
     
    
   </p>
   <p>
    
     The primary goal of this plugin is to provide a robust solution for character decision-making in Unreal Engine.
    
    
     However, its potential applications extend beyond game development.
    
    
     As an example, Learning Agents can be used to automate testing processes by creating AI characters that perform specific actions and scenarios repeatedly.
    
    
     This helps identify potential issues and ensures the robustness of
    
    
     
      your game.
     
    
   </p>
   <p>
    
     Although still in development, this is an impressive plugin, and you should expect more and more improvements as time
    
    
     
      goes by.
     
    
   </p>
   <h2 id="_idParaDest-51">
    <a id="_idTextAnchor053">
    </a>
    
     Neural network engine
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      neural network engine
     
    </strong>
    
     (
    
    <strong class="bold">
     
      NNE
     
    </strong>
    
     ) plugin provides developers with an API that allows unified access to
    
    <a id="_idIndexMarker103">
    </a>
    
     different neural network inference engines.
    
    
     This enables programmers to seamlessly
    
    <a id="_idIndexMarker104">
    </a>
    
     switch between inference runtimes as needed, optimizing their use case and targeting specific
    
    
     
      platforms effectively.
     
    
   </p>
   <p>
    
     If you are familiar with the
    
    <a id="_idIndexMarker105">
    </a>
    
     Unreal Engine
    
    <strong class="bold">
     
      Rendering Hardware Interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      RHI
     
    </strong>
    
     ), you can think about the NNE as similar; it is a tool whose main purpose is to abstract from different
    
    
     
      inference runtimes.
     
    
   </p>
   <h2 id="_idParaDest-52">
    <a id="_idTextAnchor054">
    </a>
    
     ML Deformer
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      ML Deformer
     
    </strong>
    
     is a plugin that
    
    <a id="_idIndexMarker106">
    </a>
    
     provides an API for accessing different implementations
    
    <a id="_idIndexMarker107">
    </a>
    
     of ML inference runtimes, allowing developers to approximate complex deformation models and improve the quality of characters’
    
    
     
      mesh deformations.
     
    
   </p>
   <p>
    
     The ML Deformer is specifically designed for creating accurate non-linear deformer systems for characters in real-time game engines.
    
    
     It leverages some inner Unreal Engine tools to perform computations on the GPU, optimizing performance.
    
    
     A sample project – called
    
    <strong class="bold">
     
      ML Sample Project
     
    </strong>
    
     – is available
    
    <a id="_idIndexMarker108">
    </a>
    
     on the Unreal Engine marketplace and the results are pretty amazing;
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .10
     
    </em>
    
     shows a lighting test made by
    
    <a id="_idIndexMarker109">
    </a>
    
     my fellow teacher, Giovanni Visai, starting from the aforementioned
    
    
     
      sample project:
     
    
   </p>
   <div><div><img alt="Figure 2.10 – The ML Deformer plugin in action" src="img/B31016_02_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.10 – The ML Deformer plugin in action
    
   </p>
   <h2 id="_idParaDest-53">
    <a id="_idTextAnchor055">
    </a>
    
     ML cloth simulation
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      ML cloth simulation
     
    </strong>
    
     system offers developers a high-fidelity and highly performant solution for real-time cloth
    
    <a id="_idIndexMarker110">
    </a>
    
     simulation.
    
    
     This system excels in
    
    <a id="_idIndexMarker111">
    </a>
    
     producing clothing meshes of comparable quality to pre-simulated data while maintaining fast and efficient performance with minimal
    
    
     
      memory usage.
     
    
   </p>
   <p>
    
     In conclusion, the integration of ML capabilities in Unreal Engine opens up a world of possibilities for developers.
    
    
     By leveraging these technologies, developers will be able to create more immersive, intelligent, and dynamic experiences within
    
    
     
      their projects.
     
    
   </p>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor056">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, I introduced you to the key features available in the Unreal Engine GF.
    
    
     After that, I provided an overview of the main AI systems, beginning with the Navigation System and progressing to behavior trees.
    
    
     Additionally, I discussed more advanced systems such as Mass Entity and state trees.
    
    
     Finally, I introduced you to experimental features such as the Learning Agents and
    
    
     
      NNE plugins.
     
    
   </p>
   <p>
    
     Congratulations!
    
    
     You’ve reached the end of
    
    <em class="italic">
     
      Part 1
     
    </em>
    
     of this book.
    
    
     In the upcoming chapter, get ready to take a deep dive into the Navigation System and how to create basic AI characters that will navigate through it.
    
    
     So, get ready to roll up your sleeves, and let’s start creating
    
    
     
      something amazing!
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-55" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor057">
    </a>
    
     Part 2: Understanding the Navigation System
    
   </h1>
   <p>
    
     In the second part of this book, you will delve into the essential features of Unreal Engine’s Navigation System.
    
    
     From there, you will create your own project and learn how to implement a fully working environment that is navigable by
    
    
     
      AI agents.
     
    
   </p>
   <p>
    
     This part includes the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B31016_03.xhtml#_idTextAnchor058">
      <em class="italic">
       
        Chapter 3
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Presenting the Unreal Engine Navigation System
      
     </em>
    </li>
    <li>
     <a href="B31016_04.xhtml#_idTextAnchor073">
      <em class="italic">
       
        Chapter 4
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Setting Up a Navigation Mesh
      
     </em>
    </li>
    <li>
     <a href="B31016_05.xhtml#_idTextAnchor099">
      <em class="italic">
       
        Chapter 5
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Improving Agent Navigation
      
     </em>
    </li>
    <li>
     <a href="B31016_06.xhtml#_idTextAnchor116">
      <em class="italic">
       
        Chapter 6
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Optimizing the Navigation System
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>