- en: Agent Awareness
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能体意识
- en: '*You can run, but you can''t hide!*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以跑，但你无法藏！*'
- en: Oh, you're back? That's great, because it means that your eyes are capturing
    some light information that your brain is perceiving in an act that it is usually
    called reading. Everything we do, every decision we make, is based on what we
    perceive, and biologically we make short decision-making processes because time
    is crucial (e.g. you see a snake and your amygdala processes that information
    much faster and quicker than your visual cortex!).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，你回来了？太好了，因为这意味着你的眼睛捕捉到了一些光线信息，你的大脑正在感知，这通常被称作阅读。我们做的每一件事，我们做的每一个决定，都是基于我们的感知，从生物学角度来看，我们做出快速的决定过程，因为时间是至关重要的（例如，你看到一条蛇，你的杏仁核处理这些信息比你的视觉皮层要快得多和快！）
- en: With the same very concept, AI needs to base their decisions from facts by gathering
    information they need to perceive first. This chapter is all about perception,
    and how AI can get this information from the environment, so that it can be aware
    of its surroundings. We looked at EQS in the previous chapter, which gathers a
    lot of information about the surrounding environment and processes. Here, we will
    just limit ourselves to the simple act of perception. What the AI will do with
    that information is a topic for other chapters (and some we have already covered).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念，AI需要通过收集他们需要感知的信息来基于事实做出决策。本章全部关于感知，以及AI如何从环境中获取这些信息，以便它能够意识到其周围的环境。我们在上一章中探讨了EQS，它收集了大量关于周围环境的信息并进行处理。在这里，我们将仅限于简单的感知行为。AI将如何使用这些信息是其他章节（以及我们已经讨论过的章节）的主题。
- en: 'Here is a quick rundown of the topics we will face in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章我们将要讨论的主题的简要概述：
- en: Perception and awareness in existing video games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有视频游戏中的感知和意识
- en: Overview of the Sensing System within Unreal
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal中感知系统的概述
- en: Perception Component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感知组件
- en: Senses for Sight and Hear
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉和听觉感知
- en: Perception Stimuli
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感知刺激
- en: Implementing sight in an agent (both in Blueprint and in C++)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在智能体中实现视觉（在蓝图和C++中）
- en: Implementing hearing in an agent (both in Blueprint and C++)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在智能体中实现听觉（在蓝图和C++中）
- en: So, let's start by looking at some examples of AI awareness in video games,
    and then we will see how we can set up a Perceiving system in Unreal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们先看看一些关于视频游戏中AI意识的例子，然后我们将看到如何在Unreal中设置感知系统。
- en: Perception of AI in video games
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的人工智能感知
- en: It's all a matter of perception, right? But when it comes to artificial intelligence—and
    AI in games, in particular—perception can make all the difference between winning
    and losing. In other words, *how* an AI character is able to perceive a player
    during gameplay can create a range of different experiences, thus creating environments
    full of tension and suspense while you turn every corner with slow, tentative
    footsteps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是感知的问题，对吧？但是当涉及到人工智能——特别是游戏中的AI——感知可以决定胜负。换句话说，AI角色在游戏过程中如何感知玩家可以创造一系列不同的体验，从而在你缓慢、试探性地转弯时，营造出充满紧张和悬念的环境。
- en: Sound
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音
- en: Have you ever tried to sneak past a guard in a game, trying not to make a noise
    or get detected? This is one of the most common ways that AI perceive a player
    and respond accordingly (often not in your favor!). However, one of the benefits
    of using sounds to influence an AI's perception of a player is that it gives the
    player the opportunity to initiate surprise attacks (e.g. Hitman, Assassin's Creed).
    For example, a player can sneak up on an enemy and stun or attack them from behind,
    therefore providing the player with an advantage. This can be particularly helpful
    when enemies are challenging to defeat, or a player is low in resources (e.g.
    ammunition, health packs/potions, etc).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有尝试在游戏中悄悄绕过守卫，试图不发出声音或被发现？这是AI感知玩家并相应反应（通常不是对你有利）的最常见方式之一！然而，使用声音来影响AI对玩家的感知的好处是，它给了玩家发起突袭的机会（例如，《杀手》，《刺客信条》）。例如，玩家可以悄悄地接近敌人，从后面击晕或攻击他们，从而为玩家提供优势。这在敌人难以击败或玩家资源不足（例如，弹药、医疗包/药水等）时尤其有用。
- en: Footsteps
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚步声
- en: 'Just like the preceding example suggests, one of the most common ways that
    AI can perceive characters via sound is through footsteps. No surprises here about
    how, but the proximity of detection here can depend on many factors. For example,
    some characters can walk while crouching to avoid detection, or simply by sneaking
    (e.g. *Abe''s Oddyssey*); other games allow some characters to be undetectable
    while moving around, unless visually spotted by an enemy (e.g. Natalia in *Resident
    Evil: Revelations 2*). Another key ingredient in using footsteps as a trigger
    for an AI''s perception is the type of ground material that a player is walking
    on. For example, a player walking through a forest, crunching on leaves and bark,
    is going to be a lot more obvious (and loud) than a player who is walking on sand.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '正如前面的例子所暗示的，AI通过声音感知角色的最常见方式之一是通过脚步声。这里没有关于如何做到的惊喜，但检测的邻近性可能取决于许多因素。例如，一些角色可以蹲着走以避免被检测到，或者简单地通过潜行（例如
    *Abe''s Oddyssey*）；其他游戏允许某些角色在移动时不可检测，除非被敌人视觉上发现（例如 *Resident Evil: Revelations
    2* 中的Natalia）。使用脚步声作为AI感知的触发器的另一个关键因素是玩家行走的地面材料类型。例如，一个在森林中行走的玩家，踩在树叶和树皮上，会比在沙地上行走的玩家更明显（也更响亮）。'
- en: Knocking over objects
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撞倒物体
- en: While sneaking through a level or walking while crouching, or even in the prone
    position (e.g. *Battlefield*), will not trigger an enemy, chances are if you knock
    something over (e.g. a bottle, box, random item) it's going to alert them. In
    this case, environmental objects play an important role in an AI's ability to
    perceive a player's location by simply the player themselves fumbling around an
    environment. In some cases, certain objects are likely to attract more attention
    than others, depending on how much noise they make. Of course, as game designers,
    you have the power to determine this!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在关卡中潜行或蹲着走，甚至是在卧姿（例如 *Battlefield*）时，不会触发敌人，但如果你撞倒了某个东西（例如瓶子、箱子、随机物品），它很可能会引起他们的注意。在这种情况下，环境物体在AI通过玩家在环境中的笨拙动作来感知玩家位置方面发挥着重要作用。在某些情况下，某些物体可能比其他物体更容易吸引注意力，这取决于它们产生的噪音大小。当然，作为游戏设计师，你有权决定这一点！
- en: Position
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置
- en: Similar to sound, AI have the ability to see you based on your proximity to
    them. This one is a little more obvious and a bit harder to avoid when you are
    in plain sight of an enemy. Imagine that you're sneaking past an enemy and as
    soon as you come close enough to them, that's it, it's all over, you've been spotted!
    This is the unfortunate peril that many players face, but one that has many pay-offs,
    especially in terms of satisfaction to having outsmarted the enemy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于声音，AI可以根据你与它们之间的距离看到你。当你被敌人直接看到时，这种情况会更明显，也更难以避免。想象一下，你正在悄悄地绕过敌人，一旦你足够接近他们，那就完了，你已经被发现！这是许多玩家面临的悲惨危险，但也是一个有很多回报的事情，尤其是在战胜敌人的满足感方面。
- en: 'Let''s examine this concept a little further with some examples. To begin,
    we have games like *Assassin''s Creed*, *Hitman: Absolution*, and *Thief*, where
    the art of eluding your enemy through manoeuvring is paramount to the player''s
    success in completing a mission. Often, this requires that the play leverages
    the environmental surroundings such as NPCs, walls, haystacks, plants (trees,
    bushes), rooftops, and utilizing the element of surprise.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们通过一些例子进一步探讨这个概念。首先，我们有像 *Assassin''s Creed*、*Hitman: Absolution* 和 *Thief*
    这样的游戏，在这些游戏中，通过操纵来避开敌人的艺术对于玩家完成任务的成败至关重要。通常，这要求玩家利用环境周围的环境，如NPC、墙壁、干草堆、植物（树木、灌木）、屋顶，以及利用惊喜元素。'
- en: Zone of proximity
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离区域
- en: 'In other cases, there is an explicit zone of proximity that a player can remain
    out of before they are detected. Often, in games, this is articulated by a light
    source such as a flashlight, forcing the player to dance between shadow and light
    to avoid detection. An excellent example of games that have adopted this approach
    are *Monaco: What''s Yours Is Mine* and *Metal Gear Solid*, where certain AI characters
    have a proximity of visibility via the use of torches or by simply facing you
    for an extended period of time.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '在其他情况下，有一个明确的距离区域，玩家可以在被检测到之前保持在这个区域之外。在游戏中，这通常通过光源，如手电筒来体现，迫使玩家在阴影和光线之间穿梭以避免被检测到。采用这种方法的优秀游戏例子有
    *Monaco: What''s Yours Is Mine* 和 *Metal Gear Solid*，其中某些AI角色通过火炬或长时间面对玩家来获得可见性。'
- en: 'You can see an example of this in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的屏幕截图中看到这个例子：
- en: '![](img/3352ac11-2ea1-4ee9-9d47-71ffbc4ba88d.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3352ac11-2ea1-4ee9-9d47-71ffbc4ba88d.png)'
- en: 'Screenshot from the game *Monaco: What''s Yours Is Mine*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏截图来自《摩纳哥：你的就是我的》
- en: 'Here (in *Monaco: What''s Yours Is Mine*), you can see the radius of the flashlights,
    and as soon as a player enters it, they have a limited amount of time before they
    grab the attention of the guards.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里（在《摩纳哥：你的就是我的》中），你可以看到手电筒的半径，一旦玩家进入，他们就有有限的时间来吸引警卫的注意。
- en: 'Since *Monaco: What''s Yours Is Mine* is entirely based on this mechanic, let''s
    look at some more screenshots to get a better feeling of how sight perception
    works in this game.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于《摩纳哥：你的就是我的》完全基于这种机制，让我们看看更多截图，以更好地了解这款游戏中视觉感知的工作方式。
- en: 'In the following screenshot, we can see how the perception changes when the
    player changes room:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到当玩家改变房间时感知是如何变化的：
- en: '![](img/42ef940a-7398-4ab6-981a-06388b9875ab.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42ef940a-7398-4ab6-981a-06388b9875ab.png)'
- en: 'Screenshot from the game *Monaco: What''s Yours Is Mine*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏截图来自《摩纳哥：你的就是我的》
- en: 'In the following screenshot, we have a close-up of the player''s perception:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们看到了玩家的感知特写：
- en: '![](img/58bf00d1-89d8-48fa-befb-e153919fb408.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58bf00d1-89d8-48fa-befb-e153919fb408.png)'
- en: 'Screenshot from the game *Monaco: What''s Yours Is Mine*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏截图来自《摩纳哥：你的就是我的》
- en: 'Then, we have a close-up of a guard''s flashlight:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了一名警卫手电筒的特写：
- en: '![](img/a6d333a7-f573-4b7d-965a-8f3b6ffa6ad2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6d333a7-f573-4b7d-965a-8f3b6ffa6ad2.png)'
- en: 'Screenshot from the game *Monaco: What''s Yours Is Mine*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏截图来自《摩纳哥：你的就是我的》
- en: 'Changing game, In *Metal Gear Solid*, perception is used in a similar way with
    enemies (red dots) patrolling the environment around the player (white dot). In
    the following screenshot, you can see a camera (represented as a red dot in the
    *minimap*) with a yellow cone of view in the *minimap* (guards have a blue cone,
    instead):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 改变游戏，在《合金装备》中，感知与敌人（红色圆点）在玩家（白色圆点）周围巡逻环境的方式相似。在下面的截图中，你可以看到一个摄像头（在*小地图*中以红色圆点表示）在*小地图*中有一个黄色的视野锥（警卫有一个蓝色的视野锥）：
- en: '![](img/89aa9ea2-407f-46cb-8e95-6444a386fbb2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89aa9ea2-407f-46cb-8e95-6444a386fbb2.png)'
- en: Screenshot from the game *Metal Gear Solid*
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏截图来自《合金装备》
- en: The Metal Gear Solid game series is entirely based on perception, and it is
    worthwhile exploring more and learning about the game if you are interested in
    developing game AIs with this mechanic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 《合金装备》游戏系列完全基于感知，如果你对使用这种机制开发游戏AI感兴趣，那么探索更多并了解这款游戏是值得的。
- en: Wrapping up, if you get too close to NPCs (e.g. within their range of visibility)
    you will be noticed, and they will try to interact with your character, whether
    it be good (beggars in *Assassin's Creed*) or bad (enemy attacks you), which unlocks
    many interesting mechanics based on perception.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，如果你离NPC（例如，在他们的可视范围内）太近，你会被发现，他们会尝试与你的人物互动，无论是好是坏（例如《刺客信条》中的乞丐或敌人攻击你），这解锁了许多基于感知的有趣机制。
- en: Interacting with other enemies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他敌人的互动
- en: An AI's perception about your position isn't necessarily related to when you
    enter their zone of visibility. In other cases (e.g. first-person shooters), this
    may happen when you start to shoot an enemy. This creates a ripple effect in that
    many AIs within your initial proximity will then target you (e.g. Metal Gear Solid,
    Army of Two, Battlefield, etc.).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个AI对你的位置的感知并不一定与你进入他们的可视区域的时间有关。在其他情况下（例如第一人称射击游戏），这可能会在你开始射击敌人时发生。这会在你的初始近距离内的许多AI中产生连锁反应，它们会以你为目标（例如《合金装备》、《双雄》、《战地》等）。
- en: It isn't all about the "enemy"
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并非所有都与“敌人”有关
- en: In many sporting games, AI has to be perceptive in order to respond accordingly,
    e.g. from preventing a goal, hitting a ball, or shooting hoops. AI within sports
    must be perceptive (and competitive) when it comes to playing *against* you. They
    need to know your location and the location of the ball (or any other object)
    so that they can respond (e.g. kicking the ball away from the goal posts).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多体育游戏中，AI必须具有感知能力才能相应地做出反应，例如防止进球、击球或投篮。在体育游戏中，AI在与你对抗时必须具有感知能力（和竞争力）。他们需要知道你的位置和球的位置（或任何其他物体），以便他们可以做出反应（例如将球踢离球门柱）。
- en: Perceptive AI isn't just humanoid or animalistic
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感知AI不仅仅是人形或动物性的
- en: Perceptive AI can also include machines, such as cars and other vehicles. Take
    the games *Grand Theft Auto*, *Driver*, and *The Getaway*, into account, these
    games require that a player navigates around a 3D world space at some point inside
    of a car. In some instances, there are NPCs inside, but for the most part, the
    cars themselves respond to your driving. This is also the case in more sport oriented
    games such as *Grand Turismo*, *Need for Speed*, and *Ridge Racer* (to name a
    few).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 感知AI也可以包括机器，例如汽车和其他车辆。以游戏《侠盗猎车手》、《赛车手》和《逃离》为例，这些游戏要求玩家在车内某个时刻在3D世界空间中导航。在某些情况下，车内有NPC，但大部分情况下，汽车本身会对你驾驶做出反应。这种情况也适用于更多以运动为导向的游戏，如《极品飞车》、《速度与激情》和《
    Ridge Racer》（仅举几个例子）。
- en: Impact of Players
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家的影响
- en: As we have seen, there are many ways in which AI can detect players. But one
    thing that a game designer must consider among all of this is how this will influence
    the game's experience; how will it drive gameplay? While the use of perceptive
    AI is quite a nice addition to any game, it also impacts how a game is played.
    For example, if you want to have gameplay that is heavily focused on skill, player
    dexterity, and more environmentally aware, then the perception of AI needs to
    be quite sensitive, with the player being a lot more vulnerable (e.g. Thief).
    But if, on the other hand, you want a fast-paced action game, you will need to
    have perceptive AI with the balance of allowing the player to respond accordingly.
    For example, they have a level playing field to fight against the AI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，AI检测玩家的方式有很多种。但在所有这些中，游戏设计师必须考虑的是这将对游戏体验产生怎样的影响；它将如何驱动游戏玩法？虽然感知AI的使用对任何游戏来说都是一个很好的补充，但它也会影响游戏玩法。例如，如果你想有一个高度关注技能、玩家敏捷性和更多环境意识的玩法，那么AI的感知需要非常敏感，玩家将更加脆弱（例如，盗贼）。但另一方面，如果你想有一个快节奏的动作游戏，你需要有一个平衡的感知AI，允许玩家相应地做出反应。例如，他们有一个与AI对抗的公平竞技场。
- en: Overview of the Sensing System
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感知系统概述
- en: Coming back to Unreal, as you would expect, there is a subsystem of the AI Framework
    that implements AI Perception. Once again, you are free to implement your own
    system, especially if you have particular needs…
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到虚幻引擎，正如你所预期的那样，AI框架中有一个子系统实现了AI感知。再次强调，你可以自由地实现自己的系统，尤其是如果你有特殊需求的话…
- en: With ***Sensing and Perception***, we are collocating at a lower level than
    ***Decision-Making*** (like *Behavior Trees* and *EQS*). In fact, there is no
    decision to take, no place to select, but just a passage/flow of information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在**感知与感知**方面，我们处于比**决策**（如行为树和EQS）更低的层次。实际上，这里没有需要做出的决策，没有需要选择的地方，而只是信息的流动/流程。
- en: If the Sensing System perceives something "interesting" (we will define what
    this means later), then it notifies the AI controller, which will decide what
    to do about the received stimuli (which is its perception, in Unreal terminology).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果感知系统感知到某些“有趣”的东西（我们稍后会定义这是什么意思），那么它会通知AI控制器，AI控制器将决定如何处理收到的刺激（这在虚幻引擎术语中是其感知）。
- en: Therefore, in this chapter, we will focus on how to properly set up the Sensing
    System so that our AI can perceive, but we won't deal with what to do once we
    have received the stimuli (e.g. the player is in sight, so start chasing them).
    After all, if you already have the behavior ready (e.g. a *Behavior Tree* that
    chases the player; we will build such a tree later in this book), the logic behind
    the sensing is simple as "if the player is in sight (the AI controller received
    a stimuli from the Sensing system), then execute the Chasing Behavior tree".
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将重点介绍如何正确设置感知系统，以便我们的AI能够感知，但我们不会处理收到刺激后的操作（例如，玩家在视线中，开始追逐他们）。毕竟，如果你已经有了准备好的行为（例如，追逐玩家的行为树；我们将在本书后面构建这样的树），感知背后的逻辑简单到“如果玩家在视线中（AI控制器从感知系统中收到刺激），则执行追逐行为树”。
- en: 'In practical terms, the built-in sensing system of Unreal is based mainly on
    the use of two components: **AIPerceptionComponent** and **AIPerceptionStimuliSourceComponent**.
    The first is able to perceive stimuli, whereas the latter is able to produce one
    (but it is not the only way we can produce stimuli, as we will soon see).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，虚幻引擎内置的感知系统主要基于两个组件的使用：**AIPerceptionComponent**和**AIPerceptionStimuliSourceComponent**。前者能够感知刺激，而后者能够产生刺激（但产生刺激的方式不止这一种，我们很快就会看到）。
- en: As odd as it might seem, the system believes that the AIPerceptionComponent
    is attached to the AI Controller (and not the Pawn/Character that they control).
    In fact, it's the AI Controller that will make a decision based on the stimuli
    received, not the mere Pawn. As a result, the AIPerceptionComponent needs to be
    attached directly to the AI Controller.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来可能有些奇怪，但系统认为 AIPerceptionComponent 是附加到 AI 控制器上的（而不是它们所控制的 Pawn/Character）。实际上，是
    AI 控制器将根据接收到的刺激做出决定，而不是单纯的 Pawn。因此，AIPerceptionComponent 需要直接附加到 AI 控制器上。
- en: The AIPerceptionComponent
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AIPerceptionComponent
- en: Let's break down how the **AIPerceptionComponent** works. We are going to do
    this both in Blueprint and C++.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下 **AIPerceptionComponent** 的工作原理。我们将同时在蓝图和 C++ 中进行这一操作。
- en: AIPerceptionComponent in Blueprint
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图中的 AIPerceptionComponent
- en: 'If we open our Blueprint AI Controller, we are able to add the **AIPerceptionComponent**
    like we would any other component: from the Components tab, click on **Add Component**
    and select the **AIPerceptionComponent**, as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开蓝图 AI 控制器，我们就可以像添加任何其他组件一样添加 **AIPerceptionComponent**：从组件选项卡，点击 **添加组件**
    并选择 **AIPerceptionComponent**，如下面的截图所示：
- en: '![](img/2367df79-29df-45cf-a653-8361ab6d60d3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/2367df79-29df-45cf-a653-8361ab6d60d3.png)'
- en: 'When you select the component, you will see how it appears in the *Details*
    panel, as shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择组件时，你将看到它在 *详细信息* 面板中的样子，如下面的截图所示：
- en: '![](img/11de9f01-0203-4253-be9c-f3aaee0d4d45.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/11de9f01-0203-4253-be9c-f3aaee0d4d45.png)'
- en: 'It only has two parameters. One defines the dominant senses. In fact, **AIPerceptionComponent**
    can have more than one sense, and when it comes to retrieving the location of
    the target that''s been sensed, which one should the AI use? The **Dominant Sense**
    removes ambiguity by giving one sense priority over the others. The other parameter
    is an Array of senses. As you fill the Array with the different senses, you will
    be able to customize each one of them, as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有两个参数。一个定义了主要感官。实际上，**AIPerceptionComponent** 可以拥有多个感官，当涉及到检索已感知的目标位置时，AI
    应该使用哪一个？**主要感官**通过给予一个感官相对于其他感官的优先权来消除歧义。另一个参数是一个感官数组。当你将不同的感官填充到数组中时，你将能够自定义每一个，如下面的截图所示：
- en: '![](img/71c2ecc9-71b8-4232-b45b-2f316f5bdb20.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/71c2ecc9-71b8-4232-b45b-2f316f5bdb20.png)'
- en: 'Keep in mind that you can have more than one sense of each kind. Suppose that
    your enemy has two heads, facing a different direction: you might want to have
    two sight senses, one for each head. Of course, in this case, it requires a bit
    more setup to make them work correctly since you need to modify how the sight
    component works since, let''s say, the AI always watches from its forward vector.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以拥有每种类型超过一个感官。假设你的敌人有两个头，朝向不同的方向：你可能想要有两个视觉感官，一个对应每个头。当然，在这种情况下，需要更多的设置来确保它们正确工作，因为你需要修改视觉组件的工作方式，比如说，AI
    总是从其前向矢量观察。
- en: 'Each sense has its own properties and parameters. Let''s go through the two
    main ones: sight and hearing.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个感官都有自己的属性和参数。让我们来看两个主要的：视觉和听觉。
- en: Sense – Sight
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感官 – 视觉
- en: 'The Sight sense works as you would expect, and it comes pretty ready out of
    the box (this might not be true for other senses, but sight and hearing are the
    most common). This is what it looks like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉感官的工作方式正如你所期望的，并且它几乎可以直接使用（这可能不适用于其他感官，但视觉和听觉是最常见的）。它看起来是这样的：
- en: '![](img/0c3fee81-8fd0-45b1-8358-ac6b1cf19ea2.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/0c3fee81-8fd0-45b1-8358-ac6b1cf19ea2.png)'
- en: 'Let''s break down the main parameters that control sense of Sight:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下控制视觉感官的主要参数：
- en: '**Sight Radius**: If a target (an object that can be seen) enters within this
    range, and it is not occluded, then the target is detected. In this sense, it
    is the "*Maximus sight distance to notice the target*".'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视线半径**：如果一个目标（一个可以看到的对象）进入这个范围内，并且没有被遮挡，那么目标就会被检测到。在这种情况下，它就是“*最大视线距离以注意到目标*”。'
- en: '**Lose Sight Radius**: If the target has already been seen, then the target
    will be still seen within this range, if not occluded. This value is greater than
    *Sight Radius*, meaning that the AI is able to perceive the target at a greater
    distance if it is already seen. In this sense, it is the "*Maximus sight distance
    to notice a target that has already been seen*".'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失去视线半径**：如果目标已经被看到，那么如果未被遮挡，目标仍然会在这个范围内被看到。这个值大于 *视线半径*，这意味着如果目标已经被看到，AI
    能够在更远的距离上感知到目标。在这种情况下，它就是“*最大视线距离以注意到已经看到的目标*”。'
- en: '**PeripheralVisionHalfAngleDegrees**: As the name suggests, it specifies how
    far (in degrees) the AI can look. A value of 90 means (since this value is just
    half of the angle) that the AI is able to see everything that is in front of it
    up to 180 degrees. A value of 180 would mean that the AI can look in any direction;
    it has 360-degree vision. Also, it is important to note that this half angle is
    measured from the forward vector. The following diagram illustrates this:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围视野半角度数**：正如其名所示，它指定了AI可以看多远（以度为单位）。90的值意味着（因为这个值只是角度的一半）AI能够看到其前方直到180度的所有事物。180的值意味着AI可以朝任何方向看；它有360度的视野。此外，重要的是要注意，这个半角是从前进向量测量的。以下图表说明了这一点：'
- en: '![](img/eedbf74b-20da-4d5c-9437-70784e032a1f.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eedbf74b-20da-4d5c-9437-70784e032a1f.png)'
- en: '**Auto Success Range From Last Seen**: By default, this is set to an invalid
    value (-1.0f), meaning that it isn''t used. This specifies a range from the last
    seen location of a target, and if it is within this range, then the target is
    always visible.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从上次看到的位置自动成功范围**：默认情况下，它设置为无效值（-1.0f），这意味着它没有被使用。这指定了从目标上次看到的位置的范围，如果它在这个范围内，则目标总是可见的。'
- en: 'There are other settings that are more general, and can be applied to many
    senses (including hearing, so they will not be repeated in the next section):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他一些更通用的设置，可以应用于许多感官（包括听觉，因此它们将在下一节中不再重复）：
- en: '**Detection By Affiliation**: *See the Different Teams* section.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过隶属关系检测**：*参见不同的团队*部分。'
- en: '**Debug Color**: As the name suggests, it is the color with which this sense
    should be displayed in the visual debugger (see [Chapter 11](de51b2fe-fb19-4347-8de9-a31b2c2a6f2f.xhtml),
    *Debugging methods for AI – Logging*, for more information).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试颜色**：正如其名所示，这是在视觉调试器中显示此感官的颜色（参见第11章[de51b2fe-fb19-4347-8de9-a31b2c2a6f2f.xhtml]，*AI调试方法
    – 记录*，获取更多信息）。'
- en: '**Max Age**: It indicates the time (expressed in seconds) that a stimulus is
    recorded for. Imagine that a target exits from the vision of the AI; its last
    location is still recorded, and it is assigned an age (how old is that data).
    If the Age gets bigger than the Max Age, then the stimuli are erased. For instance,
    an AI is chasing the player, who escapes from his/her sight. Now, the AI should
    first check the last position where the player has been seen to try to bring him/her
    back into their sight. If it fails, or the position was recorded many minutes
    ago, that data is not relevant anymore, and it can be erased. In summary, this
    specifies the age limit after the stimuli that''s generated by this sense is forgotten.
    Moreover, a value of 0 means never.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大年龄**：它表示刺激被记录的时间（以秒为单位）。想象一下，一个目标从AI的视野中消失；它的最后位置仍然被记录，并分配了一个年龄（这些数据有多久）。如果年龄大于最大年龄，则刺激将被删除。例如，一个AI正在追逐玩家，玩家逃离了他的视野。现在，AI应该首先检查玩家最后被看到的位置，试图将其带回视野中。如果失败，或者位置记录了许多分钟之前，那么这些数据就不再相关，可以将其删除。总之，这指定了由这个感官产生的刺激被遗忘后的年龄限制。此外，0的值表示永不。'
- en: Sense – Hearing
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感官 – 听觉
- en: 'The Hearing sense has just one proper parameter, which is the Hearing Range.
    This sets the distance at which the AI is able to hear. The others are the general
    ones we already have seen for Sight (e.g. *Max Age*, *Debug Color*, and *Detection
    By Affiliation*). This is what it looks like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 听觉感官只有一个合适的参数，即听觉范围。这设置了AI能够听到的距离。其他的是我们已经看到的通用参数（例如*最大年龄*、*调试颜色*和*通过隶属关系检测*）。它看起来是这样的：
- en: '![](img/1c6deb86-c037-44d0-9ca6-308076ac2239.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c6deb86-c037-44d0-9ca6-308076ac2239.png)'
- en: To make this book complete, it's worth mentioning that there is another option,
    called *LoSHearing*. To the best of my knowledge, and by looking at the Unreal
    Source code (version 4.20), this parameter doesn't seem to affect anything (except
    debugging). As a result, we leave it as not enabled.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这本书完整，值得提一下，还有一个选项，称为*LoSHearing*。据我所知，通过查看虚幻引擎源代码（版本4.20），这个参数似乎不影响任何事物（除了调试）。因此，我们将其设置为未启用。
- en: In any case, there are other options to control how sound is produced. Actually,
    the Hearing events need to be manually triggered with a special function/Blueprint
    node.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，都有其他选项来控制声音的产生。实际上，听觉事件需要使用特殊的功能/蓝图节点手动触发。
- en: AIPerceptionComponent and Senses in C++
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AIPerceptionComponent 和 C++中的感官
- en: If you skipped the previous sections, please read them first. In fact, all the
    concepts are the same, and in this section, I'm just going to show the use of
    the component in C++ without re-explaining all the concepts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳过了前面的部分，请先阅读它们。实际上，所有概念都是相同的，在这个部分，我只是将要展示组件在 C++ 中的使用，而不会重新解释所有概念。
- en: 'Here are the `#include` statements for the classes we would like to use (I
    only included Sight and Hearing):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们想要使用的类的 `#include` 语句（我只包含了视觉和听觉）：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To add the component to a C++ AI Controller, you do so like any other component,
    with a variable in the `.h` file. So, to keep track of it, you can use the `inerith`
    variable from the base class, which is declared as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要将组件添加到 C++ AI 控制器中，就像添加任何其他组件一样，在 `.h` 文件中添加一个变量。因此，为了跟踪它，你可以使用基类中的 `inerith`
    变量，它声明如下：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As a result, you are able to use this variable in any *AIController*, without
    declaring it in the header (`.h`) file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在任何 *AIController* 中使用这个变量，而无需在头文件（`.h`）中声明它。
- en: 'Then, with the `CreateDefaultSubobject()` function in the constructor in the
    `.cpp` file, we can create the component:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `.cpp` 文件构造函数中的 `CreateDefaultSubobject()` 函数，我们可以创建组件：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moreover, you will need extra variables, one for each of the senses you want
    to configure. For example, for the Sight and Hearing senses, you will need the
    following variables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将需要额外的变量，每个你想要配置的感官都需要一个。例如，对于视觉和听觉感官，你需要以下变量：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To configure a Sense, you need to create it first, and you have access to all
    its properties and can set what you need:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置一个感官，你首先需要创建它，你可以访问它的所有属性，并设置你需要的内容：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, you need to bind the senses to the **AIPerceptionComponent**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将感官绑定到 **AIPerceptionComponent**：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In case you need to call back for the events, you can do so by bypassing the
    callback function (it has to have the same signature, not necessarily the same
    name):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要调用回事件，你可以通过绕过回调函数（它必须具有相同的签名，不一定是相同的名称）来这样做：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This concludes the use of the **AIPerceptionComponent** and **Senses** in C++.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了在 C++ 中使用 **AIPerceptionComponent** 和 **Senses** 的过程。
- en: Different Teams
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同团队
- en: As the AI perception system that's built into Unreal goes, AIs and anything
    that can be detected can have a team. Some teams are against each other, whereas
    some are just neutral. As a result, when an AI comes to perceive something, that
    something can be Friendly (it is in the same team), Neutral, or an Enemy. For
    instance, if an AI is patrolling a camp, we can ignore Friendly and Neutral entities,
    and focus only on Enemies. By the way, the default settings are to perceive only
    enemies.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就内置在 Unreal 中的 AI 感知系统而言，AI 和任何可以被检测到的内容都可以有一个团队。有些团队是相互对立的，而有些则是中立的。因此，当 AI
    来感知某物时，那物可以是友好的（它在同一个团队中），中立的，或者敌人。例如，如果一个 AI 在巡逻营地，我们可以忽略友好的和中立的实体，只专注于敌人。顺便说一句，默认设置是只感知敌人。
- en: 'The way in which you can change which kind of entities an AI can perceive is
    through the *Detecting for Affiliation* settings of *Sense*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 *Sense* 的 *Detecting for Affiliation* 设置来改变 AI 可以感知的实体类型：
- en: '![](img/5c50f213-fa1a-4343-80e6-aabd93154d5c.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c50f213-fa1a-4343-80e6-aabd93154d5c.png)'
- en: This provides three checkboxes where we can choose what we would like that AI
    to perceive.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了三个复选框，我们可以选择我们希望 AI 感知的内容。
- en: There are 255 teams in total, and by default, every entity is within team 255
    (the only special team). Whoever is in team 255 is perceived as Neutral (even
    if both the entities are in the same team). Otherwise, if two entities are in
    the same team (different than 255), they "see" each other as Friendly. On the
    other hand, two entities in two different teams (different than 255) the "see"
    each other as Enemies.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有 255 个团队，默认情况下，每个实体都在团队 255（唯一的特殊团队）中。在团队 255 中的实体被视为中立（即使两个实体都在同一个团队中）。否则，如果两个实体在同一个团队中（不同于
    255），它们“看到”对方是友好的。另一方面，两个不同团队（不同于 255）的实体“看到”对方是敌人。
- en: 'Now the question is, how can we change teams? Well, at the moment, this is
    only possible in C++. Moreover, we have talked about entities, but who can actually
    be in a team? Everything that implements the **IGenericTeamAgentInterface** can
    be part of a team. *AIControllers* already implements it. As a result, changing
    teams on an AI Controller is easy, as shown in the following snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何更改团队？目前，这只能在 C++ 中完成。此外，我们已经讨论了实体，但谁实际上可以成为团队的一员？所有实现了 **IGenericTeamAgentInterface**
    的内容都可以成为团队的一部分。*AIControllers* 已经实现了它。因此，在 AI 控制器上更改团队很容易，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For other entities, once they implement the **IGenericTeamAgentInterface**,
    they can override the `GetGenericTeamId()` function, which provides a way for
    the AI to check in which team that entity is.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他实体，一旦它们实现了**IGenericTeamAgentInterface**，它们就可以重写`GetGenericTeamId()`函数，这为AI提供了一种检查该实体属于哪个团队的方法。
- en: The AIStimuliSourceComponent
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AIStimuliSourceComponent
- en: We have seen how an AI can perceive through a Sense, but how are the stimuli
    generated in the first place?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了AI如何通过感知来感知，但刺激最初是如何生成的？
- en: All Pawns are automatically detected
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有Pawns都会自动检测。
- en: 'In the case of the Sight sense, by default, all the Pawns are already a stimuli
    source. In fact, later in this chapter, we will use the Player character, who
    will be detected by the AI without having an **AIStimuliSourceComponent**. In
    case you are interested in disabling this default behavior, you can do so by going
    into your project directory, and then going inside the **Config** folder. There,
    you will find a file named **DefaultGame.ini**, in which you can set a series
    of configuration variables. If you add the following two lines at the end of the
    file, Pawns will not produce Sight stimuli by default, and they will need the
    **AIStimuliSourceComponent** as well as everything else:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉感知的情况下，默认情况下，所有Pawns已经是刺激源。实际上，在本章的后面，我们将使用玩家角色，该角色将由AI检测，而无需**AIStimuliSourceComponent**。如果你有兴趣禁用此默认行为，你可以通过进入你的项目目录，然后进入**Config**文件夹来实现。在那里，你会找到一个名为**DefaultGame.ini**的文件，你可以在其中设置一系列配置变量。如果你在文件末尾添加以下两行，Pawns将默认不产生视觉刺激，并且它们还需要**AIStimuliSourceComponent**以及所有其他内容：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our project, we are not going to add these lines, since we want the Pawns
    to be detected without using having to add more components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们不会添加这些行，因为我们想要Pawns被检测，而无需添加更多组件。
- en: AIStimuliSourceComponent in Blueprint
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AIStimuliSourceComponent在蓝图中的使用
- en: 'Like any other component, it can be added to a Blueprint:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他组件一样，它可以添加到蓝图：
- en: '![](img/57288860-895c-44b1-8f27-48c4ea2fea33.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57288860-895c-44b1-8f27-48c4ea2fea33.png)'
- en: 'If you select it, you will see in the *Details* panel that it has just two
    parameters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择它，你将在**详细信息**面板中看到它只有两个参数：
- en: '**Auto Register as a Source**: As the name suggests, if checked, the source
    automatically registers inside the Perception system, and it will start proving
    stimuli from the start'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动注册为源**：正如其名所示，如果选中，源将自动在感知系统中注册，并且它将从一开始就开始提供刺激。'
- en: '**Register as Source for Senses**: This is an array of all the senses that
    this component provides stimuli for'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册为感知源**：这是一个数组，包含该组件提供的所有感知刺激。'
- en: There is not much more to say about this component. It is very simple to use,
    but important (your AI might not perceive any stimuli!). Thus, remember to add
    it to the non-Pawn entities when you want them to generate a stimulus (which can
    be as simple as being seen from the AI).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个组件没有太多可说的。它非常简单易用，但很重要（你的AI可能无法感知任何刺激！）。因此，当你想要它们生成刺激（这可能只是被AI看到）时，记得将其添加到非Pawns实体中。
- en: AIStimuliSourceComponent in C++
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的AIStimuliSourceComponent
- en: Using this component in C++ is easy since you just create it, configure it,
    and it is ready to go.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中使用此组件很容易，因为你只需创建它、配置它，它就准备好了。
- en: 'This is the `#include` statement you need to use so that you have access to
    the class of the component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要使用的`#include`语句，以便你可以访问该组件的类：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Like any other component, you need to add a variable in the `.h` file to keep
    track of it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他组件一样，你需要在`.h`文件中添加一个变量来跟踪它：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, you need to generate it in the constructor with the `CreateDefaultSubobject()`
    function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在构造函数中使用`CreateDefaultSubobject()`函数来生成它：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, you need to register a source Sense, as follows (in this case, *Sight*,
    but you can change `TSubClassOf<UAISense>()` to the Sense you need):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要注册一个源感知，如下所示（在这个例子中是**视觉**，但你可以将`TSubClassOf<UAISense>()`更改为你需要的感知）：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The **Auto Register as a Source** bool is protected and true by default.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动注册为源**布尔值是受保护的，默认为true。'
- en: Hands-on with the perception system – Sight AI Controller
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践感知系统 – 视觉AI控制器
- en: The best way we to learn about something is by using it. So, let's start by
    creating a simple perception system in which we print on the screen when something
    enters or leave the perception field of the AIs, along with the number of currently
    seen objects (including/excluding the one that just entered/exited).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 了解某物的最佳方式就是使用它。所以，让我们先创建一个简单的感知系统，当有东西进入或离开AI的感知区域时，我们在屏幕上打印出来，同时显示当前看到的对象数量（包括/不包括刚刚进入/离开的对象）。
- en: Once again, we will do this twice, once with Blueprint and another time with
    C++, so that we can get to know about both methods of creation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将这样做两次，一次使用蓝图，另一次使用C++，这样我们就可以了解两种创建方法。
- en: A Blueprint perception system
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个蓝图感知系统
- en: First of all, we need to create a new AI controller (unless you want to use
    the one we've already been using). In this example, I'm going to call it "SightAIController".
    Open up the Blueprint editor, add the AIPerception component, and feel free to
    rename it (if you like) to something like "SightPerceptionComponent".
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的AI控制器（除非你想要继续使用我们之前一直在使用的那个）。在这个例子中，我将称它为“SightAIController”。打开蓝图编辑器，添加AIPerception组件，并且如果你喜欢的话，可以将其重命名为“SightPerceptionComponent”。
- en: 'Select this component. In the *Details* panel, we need to add this as a sense
    to *Sight*, as shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个组件。在*详细信息*面板中，我们需要将其添加为*视野*的一个感知，如下面的截图所示：
- en: '![](img/9e782229-d2b9-4538-a23d-b97a187574e4.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e782229-d2b9-4538-a23d-b97a187574e4.png)'
- en: 'We can set the **Sight Radius** and the **Lose Sight Radius** to something
    reasonable, such as *600* and *700*, respectively, so that we have something like
    this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将**视野半径**和**失去视野半径**设置为合理的值，例如*600*和*700*，这样我们就可以得到类似这样的效果：
- en: '![](img/5d351646-69df-40d5-8ca4-8a1b2d15f792.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d351646-69df-40d5-8ca4-8a1b2d15f792.png)'
- en: 'We can leave the angle untouched, but we need to change the **Detection By
    Affiliation**. In fact, it isn''t possible to change the Team from Blueprint,
    so the player will be in the same 255th team, which is neutral. Since we are just
    getting our hands dirty on how the system works, we can check all three checkboxes.
    Now, we should have something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保持角度不变，但我们需要更改**通过归属检测**。实际上，在蓝图上无法更改团队，所以玩家将处于相同的255号团队，这是一个中立团队。由于我们只是刚开始了解这个系统的工作原理，我们可以勾选所有三个复选框。现在，我们应该有类似这样的效果：
- en: '![](img/bac0a4d6-a13b-40a3-a34c-b278ada0d7f6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bac0a4d6-a13b-40a3-a34c-b278ada0d7f6.png)'
- en: 'At the bottom of the component, we should have all the different events. In
    particular, we will need **On Target Perception** **Updated**, which is called
    every time a target enters or exits the perception field—exactly what we need:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的底部，我们应该有所有不同的事件。特别是，我们需要**目标感知更新**，每次目标进入或退出感知区域时都会调用它——这正是我们所需要的：
- en: '![](img/48f8450c-3c7e-4028-87d7-4f57ba8edb47.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48f8450c-3c7e-4028-87d7-4f57ba8edb47.png)'
- en: 'Click on the "**+**" sign to add the event in the graph:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 点击图中的“**+**”符号来添加事件：
- en: '![](img/2b352ecc-ed31-4a25-99dc-c36c5365aa0e.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b352ecc-ed31-4a25-99dc-c36c5365aa0e.png)'
- en: This event will provide us with the Actor that caused the update and created
    the stimuli (it's worth remembering that a Perception component might have more
    than one perception at the time, and this variable tells you which stimuli caused
    the update). In our case, we have only Sight, so it can't be anything else. The
    next step is to understand how many targets we have insight and which one left
    or entered the field of view.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件将为我们提供导致更新并创建刺激的演员（值得记住的是，感知组件可能同时有多个感知，这个变量告诉你哪个刺激导致了更新）。在我们的例子中，我们只有视野，所以它不可能是其他任何东西。下一步是了解我们有多少目标在视野中，以及哪个目标离开了或进入了视野。
- en: 'So, drag the **SightPerceptionComponent** into the graph. From there, we can
    drag a pin to get all the "**Currently Perceived Actors**", which will give us
    back an array of Actors. Don''t forget to set the *Sense Class* to *Sight*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将**SightPerceptionComponent**拖入图中。从那里，我们可以拖动一个引脚来获取所有的“**当前感知到的演员**”，这将给我们一个演员数组。别忘了将*感知类*设置为*视野*：
- en: '![](img/7b2cf273-5140-456a-9672-7f11dcc3925d.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b2cf273-5140-456a-9672-7f11dcc3925d.png)'
- en: 'By measuring the length of this array, we can get the number of currently perceived
    actors at the moment. Moreover, by checking whether the Actor that was passed
    from the event is in the currently "*seen Actors*" array, we can determine whether
    such an actor has left or entered the field of view:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测量这个数组的长度，我们可以得到当前感知到的演员的数量。此外，通过检查从事件传递过来的演员是否在当前“*可见演员*”数组中，我们可以确定这样的演员是否已经离开或进入了视野：
- en: '![](img/42ca93c2-6540-44c1-a5e9-9d44809b2b64.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42ca93c2-6540-44c1-a5e9-9d44809b2b64.png)'
- en: 'The last step is to format all of this information in a nice formatted string
    so that it can be shown on-screen. We will use the Append node to build the string,
    along with a select for the "*entered*" or "*left*" Actor. Finally, we will plug
    the end result into a *Print String*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将所有这些信息格式化成一个漂亮的格式化字符串，以便可以在屏幕上显示。我们将使用 Append 节点来构建字符串，以及一个用于选择 "*进入*"
    或 "*离开*" 实体的选择器。最后，我们将最终结果连接到 *Print String*：
- en: '![](img/545cd541-2591-466c-9780-c691b041834e.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/545cd541-2591-466c-9780-c691b041834e.png)'
- en: The *Print String* is just for debugging purposes and it is not available when
    shipping games, but we are just testing and understanding how the perception system
    works.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*Print String* 仅用于调试目的，在发布游戏时不可用，但我们现在只是在测试和理解感知系统的工作原理。'
- en: Also, I know that when the number of perceived actors is one, the string will
    produce "*1 objects*", which is incorrect, but correcting plurals (although possible,
    both with an if statement or in a more complex fashion to take care of language(s)
    structure(s)) is outside the scope of this book. This is why I am using this expression.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我知道当感知到的实体数量为一个是，字符串将产生 "*1 objects*"，这是不正确的，但修正复数（尽管可能，无论是使用 if 语句还是以更复杂的方式处理语言结构）超出了本书的范围。这就是为什么我使用这个表达式的理由。
- en: Save the AI controller and go back to the level. If you don't want to do the
    same in C++, skip the next section, and go directly to "*Test it all"*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 AI 控制器并返回到关卡。如果你不想在 C++ 中做同样的事情，请跳过下一节，直接进入 "*测试一切*"。
- en: A C++ perception system
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 感知系统
- en: Again, if you are more on the C++ side, or want to experiment with how we can
    build the same AI Controller in C++, this is the section for you. We will follow
    the exact same steps (more or less), and instead of images, we will have code!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你更倾向于 C++ 方面，或者想要实验如何用 C++ 构建相同的 AI 控制器，这部分就是为你准备的。我们将遵循完全相同的步骤（或多或少），而不是图片，我们将有代码！
- en: Let's start by creating a new AIController class (if you don't remember how
    to, have a look at [Chapter 2](42076317-364e-4824-a8b7-cc2c418f021e.xhtml), *Moving
    the first steps in the AI world*). We will name it SightAIController and place
    it within the `AIControllers` folder.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的 AIController 类开始（如果你不记得如何做，可以查看[第2章](42076317-364e-4824-a8b7-cc2c418f021e.xhtml)，*在AI世界中迈出第一步*）。我们将将其命名为
    SightAIController 并将其放置在 `AIControllers` 文件夹中。
- en: 'Let''s start editing the `SightAIController.h` file, in which we need to include
    some other `.h` files so that our compiler knows where the implementations of
    the class we need are. In fact, we will need access to the **AIPerception** and
    **AISense_Config** classes. So, at the top of your code file, you should have
    the following `#include` statements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编辑 `SightAIController.h` 文件，其中我们需要包含一些其他的 `.h` 文件，以便我们的编译器知道我们需要的类的实现位置。实际上，我们需要访问
    **AIPerception** 和 **AISense_Config** 类。因此，在你的代码文件顶部，你应该有以下的 `#include` 语句：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in our class, we need to keep a reference to the `AIPerception` Component
    and an extra variable that will hold the configuration for the Sight sense:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的类中，我们需要保留对 `AIPerception` 组件的引用，以及一个将保存视觉感知配置的额外变量：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Moreover, we need to add the `Constructor` function, as well as a callback
    for the `OnTargetPerceptionUpdate` event. In order to work, this last one has
    to be a `UFUNCTION()`, and needs to have an **Actor** and a **AIStimulus** as
    inputs. In this way, the reflection system will work as excepted:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要添加 `Constructor` 函数，以及 `OnTargetPerceptionUpdate` 事件的回调。为了使其工作，最后一个必须是一个
    `UFUNCTION()`，并且需要有一个 **Actor** 和一个 **AIStimulus** 作为输入。这样，反射系统才能按预期工作：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s move into our `.cpp` file. First, we need to create the `AIPerception`
    Component, as well as a Sight configuration:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的 `.cpp` 文件。首先，我们需要创建 `AIPerception` 组件，以及一个视觉配置：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we can configure the *Sight Sense* with the same parameters: **Sight
    Radius** to *600* and **Lose Sight Radius** to *700*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用相同的参数配置 *Sight Sense*：**视野半径** 为 *600* 和 **失去视野半径** 为 *700*：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to check all the flags for the **DetectionByAffiliation** so
    that we detect our Player (since, at the moment, they both are in the 255th team;
    look at the *Exercise* section to learn how to improve this):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查 **DetectionByAffiliation** 的所有标志，以便检测我们的玩家（因为，目前，他们都在第 255 个团队中；查看
    *练习* 部分了解如何改进这一点）：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we associate the Sight configuration with the `AIPerception` Component,
    and bind the `OnTargetPerceptionUpdate` function to the homonym event on the `AIPerceptionComponent`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将视觉配置与`AIPerception`组件关联起来，并将`OnTargetPerceptionUpdate`函数绑定到`AIPerceptionComponent`上的同名列事件：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This concludes the *Constructor*, but we still need to implement the `OnTargetPerceptionUpdate()`
    function. First of all, we need to retrieve all the **Currently Perceived Actors**.
    This function requires an array of actors that it can fill, along with the implementation
    of the Sense to use.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了*构造函数*，但我们仍然需要实现`OnTargetPerceptionUpdate()`函数。首先，我们需要检索所有**当前感知到的演员**。这个函数需要一个演员数组来填充，以及要使用的感知实现。
- en: 'As a result, we will have our array filled up with the Perceived Actors:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的数组将填充感知到的演员：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By measuring the length of this array, we can get the number of currently perceived
    actors at the moment. Moreover, by checking if the Actor that was passed from
    the event (the parameter of the function) is in the currently "*seen Actors*" array,
    we can determine whether such an actor has left or entered the field of view:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测量数组的长度，我们可以得到当前感知到的演员数量。此外，通过检查从事件传递过来的演员（函数的参数）是否在当前"*可见演员*"数组中，我们可以确定这样的演员是否已经离开或进入了视野：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we need to pack this information into a formatted string, and then
    print it on the screen:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将此信息打包到一个格式化的字符串中，然后将其打印到屏幕上：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once again, I know that "1 objects" is incorrect, but correcting plurals (although
    possible) is outside the scope of this book; let's keep it simple.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，我知道“1 objects”是不正确的，但修正复数（尽管可能）超出了本书的范围；让我们保持简单。
- en: Testing it all
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试所有这些
- en: Now, you should have an AI controller with the perception system implemented
    (whether it is in Blueprint or C++ – it doesn't matter, they should behave identically).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经实现了一个带有感知系统的AI控制器（无论是蓝图还是C++——这并不重要，它们应该表现相同）。
- en: 'Create another `ThirdPersonCharacter` by *Alt* + *Dragging* the player into
    the level (if you want to use an AI that we created in the previous chapters,
    you can do so):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按*Alt* + *拖动*将玩家拖入关卡中创建另一个`ThirdPersonCharacter`（如果你想在上一章中创建的AI中使用，可以这样做）：
- en: '![](img/df7f7507-b26d-4568-a1a2-f47c14969dee.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df7f7507-b26d-4568-a1a2-f47c14969dee.png)'
- en: 'In the *Details* panel, we make it be controlled by our AI controller, and
    not a player (this should be a process that''s easy to you by now):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在*详细信息*面板中，我们让它由我们的AI控制器控制，而不是玩家（这个流程现在应该对你来说很容易）：
- en: '![](img/8c134131-d15e-4d83-9e7c-60f7cd77f2f3.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c134131-d15e-4d83-9e7c-60f7cd77f2f3.png)'
- en: 'Alternatively, if you are going with a C++ setup, choose the following settings:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用C++设置，选择以下设置：
- en: '![](img/50b3295c-6d69-4dc9-b9f4-63982f12d0a9.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50b3295c-6d69-4dc9-b9f4-63982f12d0a9.png)'
- en: Before pressing play, it would be nice to create some other objects that can
    be detected. We know that all the Pawns are detected (unless disabled), so let's
    try something that isn't a Pawn – maybe a moving platform. As a result, if we
    want to detect it, we need to use the **AIPerceptionStimuliSourceComponent**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下播放之前，创建一些可以被检测到的其他对象会很好。我们知道所有的Pawns都可以被检测到（除非被禁用），所以让我们尝试一个不是Pawn的对象——也许是一个移动平台。因此，如果我们想检测它，我们需要使用**AIPerceptionStimuliSourceComponent**。
- en: 'First, let''s create the floating platform (which can be easily pushed by our
    character). If you are in the default level of the *ThirdPersonCharacter Example*,
    you can duplicate with *Alt + Drag* this big mesh, which is highlighted in the
    following screenshot (otherwise, if you are using a custom level, a cube that
    you can squash will work fine):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个浮动平台（可以被我们的角色轻易推动）。如果你在*ThirdPersonCharacter Example*的默认关卡中，你可以通过*Alt
    + 拖动*复制以下截图中的大网格，否则，如果你使用自定义关卡，一个可以被压扁的立方体将工作得很好）：
- en: '![](img/b681cee9-abf5-45c6-b6c5-75d0a6a19f0b.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b681cee9-abf5-45c6-b6c5-75d0a6a19f0b.png)'
- en: 'So far, it''s way too big, so let''s scale it down to (1, 1, 0.5). Also, to
    be on the same page, you can move it to (-500, 310, 190). Finally, we need to
    change the mobility to Movable, since it needs to move:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它太大，所以让我们将其缩小到（1, 1, 0.5）。此外，为了保持一致，你可以将其移动到（-500, 310, 190）。最后，我们需要将移动性更改为可移动，因为它需要移动：
- en: '![](img/4cc272c4-56b5-4a87-8d07-fb1be8ddb556.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cc272c4-56b5-4a87-8d07-fb1be8ddb556.png)'
- en: 'Next, we want to be able to push such a platform, so we need to enable Physics
    simulation. To keep it pushable by our character, let''s give it a mass of *100
    Kg* (I know, it seems like a lot, but with little friction and with the fact that
    the platform floats, it''s the right amount). Moreover, we don''t want the platform
    to rotate, so we need to block all the three rotational axes inside **Constraints**.
    The same goes if we want the platform to float – if we lock the z-axis, the platform
    can only move along the *XY plane* with no rotation. This will ensure a nice,
    pushable platform. This is what the Physics part should look like:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望能够推动这样的平台，因此我们需要启用物理模拟。为了保持我们的角色可以推动它，让我们给它一个质量为*100 Kg*（我知道，这看起来很多，但考虑到摩擦很小，并且平台可以漂浮，这是正确的数量）。此外，我们不希望平台旋转，因此我们需要在**约束**中阻止所有三个旋转轴。如果我们想让平台漂浮，也是同样的道理——如果我们锁定z轴，平台只能沿着*XY平面*移动，没有旋转。这将确保平台易于推动。这就是物理部分应该看起来像的：
- en: '![](img/e6752a91-6659-41af-a376-858798e8c904.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6752a91-6659-41af-a376-858798e8c904.png)'
- en: 'Finally, we need to add a **AIPerceptionStimuliSourceComponent**, from the
    **Add Component** green button near the name of the Actor:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个**AIPerceptionStimuliSourceComponent**，从Actor名称附近的**添加组件**绿色按钮：
- en: '![](img/e5a6ec6f-30c6-48a5-85bd-527d4e6bbeee.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a6ec6f-30c6-48a5-85bd-527d4e6bbeee.png)'
- en: 'Once the component has been added, we can select it from the preceding menu.
    As a result, the *Details* panel will allow us to change **AIPerceptionStimuliSourceComponent**
    settings. In particular, we want to add the *Sight Sense*, and automatically register
    the component as a source. This is how we should set it up:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了组件，我们就可以从前面的菜单中选择它。结果，*详细信息*面板将允许我们更改**AIPerceptionStimuliSourceComponent**设置。特别是，我们想要添加*视觉感知*，并自动将组件注册为源。这就是我们应该如何设置它：
- en: '![](img/67575c9b-2175-4d6d-a9ff-f7be80327656.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67575c9b-2175-4d6d-a9ff-f7be80327656.png)'
- en: As an optional step, you can convert this into a blueprint so that you can reuse
    it, and maybe assign a more meaningful name. Also, you can duplicate it a few
    times if you want to have several objects be tracked by the *Sight Perception
    System*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可选步骤，你可以将其转换为蓝图，以便可以重用，并可能赋予一个更有意义的名称。此外，如果你想让多个对象被*视觉感知系统*跟踪，你可以复制它几次。
- en: 'Finally, you can hit play and test what we have achieved so far. If you pass
    our *AI controlled Character*, you will get a notification on the top of the screen.
    We get the same output if we push a platform inside or out of the AI''s field
    of view. In the following screenshot, you can see the C++ implementation, but
    it works very similarly with the Blueprint one (just the color of the print changes):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以点击播放并测试我们迄今为止所取得的成果。如果你通过了我们的*AI控制角色*，你将在屏幕顶部收到通知。如果我们推动平台进入或离开AI的视野，我们会得到相同的结果。以下截图显示了C++实现，但它与蓝图实现非常相似（只是打印的颜色不同）：
- en: '![](img/0baa2090-609d-4055-ab47-a299a33f8607.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0baa2090-609d-4055-ab47-a299a33f8607.png)'
- en: 'Also, as anticipation, it is possible to see the AI field of view with the
    visual debugger, which we will explore in [Chapter 13](a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml),
    *Debugging Methods for AI - The Gameplay Debugger*. The following screenshot is
    a reference of the field of view of the AI Character we have created. For details
    on how to display it and understand what all this information means, hang on until [Chapter
    13](a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml), *Debugging Methods for AI - The
    Gameplay Debugger*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为预期，你可以使用可视化调试器查看AI的视野，我们将在[第13章](a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml)中探讨，即*AI调试方法
    - 游戏调试器*。以下截图是我们创建的AI角色的视野参考。关于如何显示它以及理解所有这些信息的详细说明，请耐心等待[第13章](a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml)的介绍，即*AI调试方法
    - 游戏调试器*：
- en: '![](img/c0ffc59c-02df-4c6c-b515-6a9b19be5fc2.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0ffc59c-02df-4c6c-b515-6a9b19be5fc2.png)'
- en: It's time to pat yourself on the back because it might seem like you've only
    done a little, but actually, you managed to learn about a complex system. Also,
    if you tried one way (Blueprint or C++), try the other one if you want to be able
    to master the system both in Blueprint and in C++.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给自己鼓掌了，因为这可能看起来你只做了一点点，但实际上，你成功地了解了一个复杂的系统。此外，如果你尝试了一种方法（蓝图或C++），如果你想掌握蓝图和C++中的系统，尝试另一种方法。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: And that was a lot of information to perceive, wasn't it?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 难道这不是一个感知到的信息量很大吗？
- en: We started by understanding how the different pieces of the built-in perception
    system in Unreal works within the AI framework. From there, we explored how we
    can actually use those components (both in C++ and Blueprint), and learned how
    to properly configure them as well.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先理解了内置感知系统中的不同组件如何在 Unreal 的 AI 框架内工作。从那里，我们探索了如何实际使用这些组件（无论是在 C++ 中还是在蓝图），并学习了如何正确配置它们。
- en: We concluded with a practical example of setting up a *Sight* perception system,
    and once again did so both in Blueprint and C++.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个设置 *视觉* 感知系统的实际例子来总结，这次我们既在蓝图（Blueprint）中，也在 C++ 中实现了这一点。
- en: In the next chapter, we will see how we can simulate large *Crowds*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到我们如何模拟大型 *人群*。
