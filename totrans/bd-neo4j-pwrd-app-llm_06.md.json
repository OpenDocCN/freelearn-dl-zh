["```py\n    pip install neo4j \n    ```", "```py\npip install haystack-ai \n```", "```py\npip install openai \n```", "```py\n    pip install gradio \n    ```", "```py\n    pip install python-dotenv \n    ```", "```py\n    pip install haystack haystack-ai openai neo4j-haystack \n    ```", "```py\n    makefile\n    OPENAI_API_KEY=your_openai_api_key_here \n    ```", "```py\n    # Initialize Haystack with OpenAI for text embeddings\n    def initialize_haystack():\n        # Initialize document store (In-memory for now, but you can configure other stores)\n        document_store = InMemoryDocumentStore()\n        # Initialize OpenAITextEmbedder to generate text embeddings\n        embedder = OpenAITextEmbedder(\n            api_key=Secret.from_env_var(\"OPENAI_API_KEY\"),\n            model=\"text-embedding-ada-002\"\n        )\n        return embedder \n    ```", "```py\n    # Retrieve movie plots and titles from Neo4j\n    def retrieve_movie_plots():\n        # The query retrieves the \"title\", \"overview\", and \"tmdbId\" properties of each Movie node\n        query = \"\"\"\n        MATCH (m:Movie)\n        WHERE m.embedding IS NULL\n        RETURN m.tmdbId AS tmdbId, m.title AS title, m.overview AS overview\n        \"\"\"\n        with driver.session() as session:\n            results = session.run(query)\n            # Each movie's title, plot (overview), and ID are retrieved and stored in the movies list\n            movies = [\n                {\n                    \"tmdbId\": row[\"tmdbId\"],\n                    \"title\": row[\"title\"],\n                    \"overview\": row[\"overview\"]\n                }\n                for row in results\n            ]\n        return movies \n    ```", "```py\n    #Parallel embedding generation with ThreadPoolExecutor\n    def generate_and_store_embeddings(embedder, movies, max_workers=10): \n        results_to_store = []\n        def process_movie(movie):\n            title = movie.get(\"title\", \"Unknown Title\")\n            overview = str(movie.get(\"overview\", \"\")).strip()\n            tmdbId = movie.get(\"tmdbId\")\n            if not overview:\n                print(f\"Skipping {title} — No overview available.\")\n                return None\n            try:\n                print(f\"Generating embedding for: {title}\")\n                embedding_result = embedder.run(overview)\n                embedding = embedding_result.get(\"embedding\")\n                if embedding:\n                    return (tmdbId, embedding)\n                else:\n                    print(f\"No embedding generated for: {title}\")\n            except Exception as e:\n                print(f\"Error processing {title}: {e}\")\n            return None \n    ```", "```py\n    # Store the embeddings back in Neo4j\n    def store_embedding_in_neo4j(tmdbId, embedding):\n        query = \"\"\"\n        MATCH (m:Movie {tmdbId: $tmdbId})\n        SET m.embedding = $embedding\n        \"\"\"\n        with driver.session() as session:\n            session.run(query, tmdbId=tmdbId, embedding=embedding)\n        print(f\"Stored embedding for TMDB ID: {tmdbId}\") \n    ```", "```py\n    # Verify embeddings stored in Neo4j\n    def verify_embeddings():\n        query = \"\"\"\n        MATCH (m:Movie)\n        WHERE exists(m.embedding)\n        RETURN m.title, m.embedding\n        LIMIT 10\n        \"\"\"\n        with driver.session() as session:\n            results = session.run(query)\n            for record in results:\n                title = record[\"title\"]\n                embedding = np.array(record[\"embedding\"])[:5]\n                print(f\" {title}: {embedding}...\") \n    ```", "```py\ndef create_or_reset_vector_index():\n    with driver.session() as session:\n        try:\n            # Drop the existing vector index if it exists\n            session.run(\"DROP INDEX overview_embeddings IF EXISTS \")\n            print(\"Old index dropped\")\n        except:\n            print(\"No index to drop\")\n        # Create a new vector index on the embedding property\n        print(\"Creating new vector index\")\n        query_index = \"\"\"\n        CREATE VECTOR INDEX overview_embeddings IF NOT EXISTS\n        FOR (m:Movie) ON (m.embedding)\n        OPTIONS {indexConfig: {\n            `vector.dimensions`: 1536,\n            `vector.similarity_function`: 'cosine'}}\n        \"\"\"\n        session.run(query_index)\n        print(\"Vector index created successfully\") \n```", "```py\ntext_embedder = OpenAITextEmbedder(\n        api_key=Secret.from_env_var(\"OPENAI_API_KEY\"),\n        model=\"text-embedding-ada-002\"\n    )\n    # Step 1: Create embedding for the query\n    query_embedding = text_embedder.run(query).get(\"embedding\")\n\n    if query_embedding is None:\n        print(\"Query embedding not created successfully.\")\n        return\n\n    print(\"Query embedding created successfully.\") \n```", "```py\n# Step 2: Search for similar documents using the query embedding\n    similar_documents = document_store.query_by_embedding(\n        query_embedding, top_k=3\n    )\n    if not similar_documents:\n        print(\"No similar documents found.\")\n        return\n    print(f\"Found {len(similar_documents)} similar documents.\")\n    print(\"\\n\\n\")\n    # Step 3: Displaying results\n    for doc in similar_documents:\n        title = doc.meta.get(\"title\", \"N/A\")\n        overview = doc.meta.get(\"overview\", \"N/A\")\n        score = doc.score\n        print(\n             f\"Title: {title}\\nOverview: {overview}\\n\"\n             f\"Score: {score:.2f}\\n{'-'*40}\"\n        )\n    print(\"\\n\\n\") \n```", "```py\n    cypher_query = \"\"\"\n        CALL db.index.vector.queryNodes(\"overview_embeddings\", $top_k, $query_embedding)\n        YIELD node AS movie, score\n        MATCH (movie:Movie)\n        RETURN movie.title AS title, movie.overview AS overview, score\n    \"\"\" \n    ```", "```py\n    text_embedder = OpenAITextEmbedder(\n        api_key= Secret.from_env_var(\"OPENAI_API_KEY\"),\n        model=\"text-embedding-ada-002\"\n    ) \n    ```", "```py\n        retriever = Neo4jDynamicDocumentRetriever(\n            client_config=client_config,\n            runtime_parameters=[\"query_embedding\"],\n            compose_doc_from_result=True,\n            verify_connectivity=True,\n        )\n        pipeline = Pipeline()\n        pipeline.add_component(\"query_embedder\", text_embedder)\n        pipeline.add_component(\"retriever\", retriever)\n        pipeline.connect(\n            \"query_embedder.embedding\", \"retriever.query_embedding\"\n        )\n        result = pipeline.run(\n            {\n                \"query_embedder\": {\"text\": query},\n                \"retriever\": {\n                    \"query\": cypher_query,\n                    \"parameters\": {\n                        \"index\": \"overview_embeddings\", \"top_k\": 3\n                    },\n                },\n            }\n        ) \n        ```", "```py\n    # Extracting documents from the retriever results\n    documents = result[\"retriever\"][\"documents\"]\n    for doc in documents:\n        # Extract title and overview from document metadata\n        title = doc.meta.get(\"title\", \"N/A\")\n        overview = doc.meta.get(\"overview\", \"N/A\")\n        # Extract score from the document\n        score = getattr(doc, \"score\", None)\n        score_display = f\"{score:.2f}\" if score is not None else \"N/A\"\n        # Print the title, overview, and score (or N/A for missing score)\n        print(\n             f\"Title: {title}\\nOverview: {overview}\\n\"\n             f\"Score: {score_display}\\n{'-'*40}\\n\"\n        ) \n    ```", "```py\nTitle: The Matrix\nOverview: A computer hacker learns from mysterious rebels about the true nature of his reality and his role in the war against its controllers.\nScore: 0.98\n----------------------------------------\nTitle: Inception\nOverview: A thief who steals corporate secrets through dream-sharing technology is given the inverse task of planting an idea into the mind of a CEO.\nScore: 0.96\n----------------------------------------\nTitle: The Dark Knight\nOverview: Batman raises the stakes in his war on crime, with the help of Lieutenant Jim Gordon and District Attorney Harvey Dent.\nScore: 0.94\n---------------------------------------- \n```", "```py\npip install gradio \n```", "```py\nimport gradio as gr\n# Define the Gradio chatbot interface\ndef chatbot(user_input):\n    return perform_vector_search_cypher(user_input)\n# Create Gradio interface\nchat_interface = gr.Interface(\n    fn=chatbot,\n    inputs=gr.Textbox(\n        placeholder=\"What kind of movie would you like to watch?\",\n        lines=3,\n        label=\"Your movie preference\"\n    ),\n    outputs=gr.Textbox(\n        label=\"Recommendations\",\n        lines=12\n    ),\n    title=\"AI Movie Recommendation System\",\n    description=\"Ask me about movies! I can recommend movies based on your preferences.\",\n    examples=[\n        [\"I want to watch a sci-fi movie with time travel\"],\n        [\"Recommend me a romantic comedy with a happy ending\"],\n        [\"I'm in the mood for something with superheroes but not too serious\"],\n        [\"I want a thriller that keeps me on the edge of my seat\"],\n        [\"Show me movies about artificial intelligence taking over the world\"]\n    ],\n    flagging_mode=\"never\" \n```", "```py\n# Conversational chatbot handler using Cypher-powered search and Haystack\ndef perform_vector_search(query):\n    print(\"MESSAGES RECEIVED:\", user_input)\n    cypher_query = \"\"\"\n        CALL db.index.vector.queryNodes(\"overview_embeddings\", $top_k, $query_embedding)\n        YIELD node AS movie, score\n        MATCH (movie:Movie)\n        RETURN movie.title AS title, movie.overview AS overview, score\n    \"\"\"\n    # Embedder\n    embedder = OpenAITextEmbedder(\n        api_key=Secret.from_env_var(\"OPENAI_API_KEY\"),\n        model=\"text-embedding-ada-002\"\n    )\n    # Retriever\n    retriever = Neo4jDynamicDocumentRetriever(\n        client_config=client_config,\n        runtime_parameters=[\"query_embedding\"],\n        compose_doc_from_result=True,\n        verify_connectivity=True,\n    )\n    # Pipeline\n    pipeline = Pipeline()\n    pipeline.add_component(\"query_embedder\", embedder)\n    pipeline.add_component(\"retriever\", retriever)\n    pipeline.connect(\n        \"query_embedder.embedding\", \"retriever.query_embedding\"\n    ) \n```", "```py\n# Main function to orchestrate the entire process\ndef main():\n    # Step 1: Create or reset vector index in Neo4j AuraDB\n    create_or_reset_vector_index()\n    # Step 2: Launch Gradio chatbot interface\n    chat_interface.launch()\nif __name__ == \"__main__\":\n    main() \n```", "```py\npython search_chatbot.py \n```", "```py\n\"Tell me about a hero who saves the world.\" \n```", "```py\nembedder = OpenAITextEmbedder(\n    api_key=Secret.from_env_var(\"OPENAI_API_KEY\"),\n    model=\"text-embedding-babbage-001\"  # Experiment with different models\n) \n```", "```py\ndef create_additional_indexes():\n    with driver.session() as session:\n        session.run(\"CREATE INDEX IF NOT EXISTS movie_title_index FOR (m:Movie) ON (m.title)\")\n        session.run(\"CREATE INDEX IF NOT EXISTS movie_tmdbId_index FOR (m:Movie) ON (m.tmdbId)\")\n        print(\"Additional indexes created successfully\") \n```", "```py\nimport logging\nlogging.basicConfig(filename='chatbot_queries.log', level=logging.INFO)\ndef log_query(query):\n    logging.info(f\"User query: {query}\") \n```"]