- en: Flocks and Crowds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flocks and crowds are two additional core AI concepts we''ll be exploring in
    this book. As you''ll see in this chapter, flocks are relatively simple to implement,
    and they add a fairly extraordinary amount of realism to your simulation in just
    a few lines of code. Crowds can be a bit more complex, but we''ll be exploring
    some of the powerful tools that come bundled with Unity to get the job done. In
    this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the history of flocks and herds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the concepts behind flocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flocking using the traditional algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using realistic crowds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the origins of flocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flocking algorithm dates all the way back to the mid-80s. It was first developed
    by *Craig Reynolds*, who developed it for use in films, the most famous adaptation
    of the technology being the swarm of bats in *Batman Returns* in 1992, for which
    he won an Oscar. Since then, the use of the flocking algorithm has expanded beyond
    the world of film into various fields, from games to scientific research. Despite
    being relatively efficient and accurate, the algorithm is also very simple to
    understand and implement.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concepts behind flocks and crowds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with previous concepts, it's easiest to understand flocks and herds by relating
    them to the real-life behaviors they model. As simple as it sounds, these concepts
    describe a group of objects, or boids as they are called in artificial intelligence
    lingo, moving together as a group. The flocking algorithm gets its name from the
    behavior birds exhibit in nature, where a group of birds follow one another toward
    a common destination, mostly keeping a fixed distance from each other. The emphasis
    here is on the group. We've explored how single agents can move and make decisions
    on their own, but flocks are a relatively computationally efficient way of simulating
    large groups of agents moving in unison while modeling unique movement in each
    boid that doesn't rely on randomness or predefined paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation that we''ll be building in this chapter for flocking is
    built upon the concepts originally developed by Craig Reynolds himself. There
    are many ways to approach Reynolds'' flocking behavior, and in our example we''ve
    gone with a single-threaded optimized version that allocates no memory. Performance
    will vary based on the hardware, but generally speaking, the more boids in your
    flock, the more CPU time it will take to compute the swarm''s direction. There
    are three basic concepts that define how a flock works, and these concepts have
    been around since the algorithm''s introduction in the 80s:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation**: This means maintaining a distance with other neighbors in the
    flock to avoid collision. The following diagram illustrates this concept:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5376f28d-d54f-44bd-a6e5-c7d01e066b7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of separation in flocking
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, the middle boid is shown moving in a direction away
    from the rest of the boids, without changing its heading.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alignment**: This means to moving in the same direction as the flock, and
    with the same velocity. The following image illustrates this concept:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3aaf5ba6-bd9e-42cb-8ada-f15b9a95c815.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of alignment in flocking
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, the boid in the middle is shown changing its heading
    toward the arrow to match the heading of the boids surrounding it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cohesion**: This means maintaining a maximum distance from the flock''s center.
    The following image illustrates this concept:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f7a635d5-684e-45b9-9556-04746229e91e.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of cohesion in flocking
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, the boid to the right of the flock moves in the direction
    of the arrow to be within the minimum distance to its nearest group of boids.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Reynolds algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without further ado, let''s dive into the Reynolds flocking algorithm. There
    are two main scripts for our flocking implementation: `Boid.cs` and `FlockController.cs`.
    The sample code for this chapter provides a scene with all the necessary setup
    for testing. You''ll also notice a third script named `TargetMovement.cs`, which
    we use to move a target that our flock will follow around the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our boid, we can use a simple cube as a prefab. Of course, feel free to
    replace the cube with any art you want. Let''s add the `Boid.cs` script to our
    boid prefab. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Right off the bat, you'll notice a reference to `FlockController`, which we
    will create next. You can think of `FlockController` as the shared brain of the
    swarm/flock. Each boid does not need to be aware of its neighbors directly, because
    `FlockController` handles this information separately. This allows us to keep
    the boid code nice and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: We initialize the direction vector in our `Awake` method, and we make sure that
    the `FlockController` is assigned, or we log an error. There are several ways
    you can enforce null-safety, such as creating the instance if not provided, but
    in our case we'll assume you assigned the value via the inspector.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update` method does the rest of the workit calls the `Flock()` method on `FlockController`
    and passes in a reference to itself, its local position, and its direction. This
    will return a vector that we then normalize to keep movement from appearing jerky
    or too fast, and apply the movement by using `Transform.Translate()`. As usual,
    make sure you're easing the movement over the `Time.deltaTime` to ensure smooth
    frame-to-frame movement.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that we make sure to cache as many `Vector3` variables
    as needed. Avoid allocations by avoiding the use of `new Vector3()` where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the FlockController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FlockController` is going to handle the orchestration of the entire flock.
    There is a quite a bit going on here in terms of variables. Let''s take a look
    at `FlockController.cs` chunk by chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we simply assign the size of our flock. You''ll see this value being
    used up ahead in the `Awake` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We then declare a series of modifier and weight values. `speedModifier` directly
    affects how fast our boids can move. Tweak this as needed. The three values following
    `speedModifier` are weight values for alignment, cohesion, and separation, respectively.
    These values will multiply their weight in the final calculation of all the direction
    vectors that drive the movement of the boid. `followWeight` is used to weight
    the effect of the target's delta versus the boid. If you want the boids to follow
    the target more closely, increase this value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The following chunk of variables defines some more setup variables that we assign
    in the inspector. First, we have the prefab of the boid to spawn (which should
    have the `Boid.cs` component attached to it). `spawnRadius` is used to avoid artifacts
    that may come from spawning all the boids on top of each other if we were to spawn
    them all on one point. Instead, we spawn them within the given radius, as defined
    in this variable. Lastly, `target` is a reference to the transform of the target
    our flock/swarm will follow. In our test scene, it's a sphere with the `TargetMovement.cs`
    component attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Awake` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We iterate through a loop enough times to spawn enough boids for our `flockSize`
    variable. This is where our `spawnLocation` and `spawnRadius` come into play.
    Unity's `Random.insideUnitSphere` generates the random position, which we add
    to our transform's position to get the actual spawn location. We then instantiate
    the boid prefab, while assigning to a `Boid` instance, which we then add to our
    `flockList`. Also note that we assign the boid instance's `FlockController` property
    in this step.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that instantiating prefabs can be slow in Unity, so increasing
    the number of boids in the flock will lead to a huge performance dip during the
    instantiation frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other method in this class is the `Flock()` method, which we saw being
    called from `Boid` earlier. This does all the computation for the individual boids''
    directions. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes some information about our `Boid`, as well as a copy of it.
    We then iterate through every boid in the `flockList` and assign the boid at the
    current iteration''s index to a temporary value called `neighbor`. To avoid doing
    multiple loops, we do several things in the same `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Sum up all the neighbors' directions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum up all the neighbors' positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum up the position deltas to all neighbors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once done with the loop (and thus aggregating all of the preceding values),
    we calculate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The flock direction, which we get by averaging the direction of all the boids.
    Since we've already got the sum of all the directions, we just divide it by the
    number of boids, the `flockSize`. We then normalize the value and apply the weight
    we defined earlier. This will give us our alignment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we get the centroid of the flock by averaging all the positions of
    all the boids. As with direction, we normalize the vector before applying the
    weighting. The `flockCenter` gives us our cohesion vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may be seeing a pattern here, right? As with the previous two values, we
    average, normalize, then weight our separation value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetDirection` is a bit different. We first take the delta between the boid''s
    position and the target''s position, then we apply the weight. We don''t normalize
    this value in this implementation, but feel free to experiment by doing so. Normalizing
    this value won''t break the simulation, but you may notice your boids casually
    floating away from the target if it moves too fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of the values—cohesion, alignment, and separation—calculated, we add
    them up and return them to the `Boid` instance that called the method. The boid
    will use this vector as its target direction, as we saw in the `Boid.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we could potentially have dozens or hundreds of boids, it''s important
    to avoid any unnecessary computations at runtime. If you profile our implementation,
    you''ll notice it allocates no memory whatsoever, meaning you won''t have any
    annoying stuttering due to garbage collection. While the system will slow down
    as the boid count goes into the hundreds due to its single-threaded nature, having
    a few dozen boids is very fast. As you can see in the following screenshot, having
    a small flock flying around can be computed in less than a millisecond:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55fe85bc-eac2-400e-a151-842a32fae26a.png)'
  prefs: []
  type: TYPE_IMG
- en: The stats panel showing our scene's performance
  prefs: []
  type: TYPE_NORMAL
- en: The flock target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Last, but not least, we have our flock target. To reiterate, you can use any
    art you like, or you can stick with the handsome little sphere in the provided
    sample project. The code for the target component is in the `TargetMovement.cs`
    file. The contents look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are two main chunks of work in this class. First, `Update` moves the game
    object towards the `forward` vector, while rotating it towards the `targetPosition`.
    We provide two variables to modify the move and turn speed: `moveSpeed` and `turnSpeed`,
    respectively. We then check whether we've arrived at the destination point by
    comparing the distance to it against a tolerance radius that we define in `targetPointTolerance`.
    If we're close enough, we then set the next target point by calling `CalculateNextMovementPoint()`.
  prefs: []
  type: TYPE_NORMAL
- en: In `CalculateNextMovementPoint()`, we set a random target position, but constrain
    it based on our bounds values, relative to the position of the target when we
    first run the script, as we set the `initialPosition` in `Awake`. Constraining
    this point will prevent the target from slowly deviating away from our game area
    and floating off into the sunset. Dramatic as it may be, it's not quite the effect
    we're going for here.
  prefs: []
  type: TYPE_NORMAL
- en: The scene layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all of our code covered, let''s take a look at our scene.
    Our sample scene looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb0618ef-90db-4055-be9c-5c970a4da466.png)'
  prefs: []
  type: TYPE_IMG
- en: An overview of our scene layout
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, there isn''t a lot of complexity
    to our setup. We have a plane, some environment cubes for perspective, a light,
    a camera, and our target. The full hierarchy looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3512b5a-05c6-446e-a545-a47b397cf1bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Our scene hierarchy with FlockController highlighted
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, we have a Directional light, and
    nested underneath it is a reflection probe. This is strictly for making the scene
    look nice, and has essentially no functional value, but hey, a little vanity never
    hurt anyone! We then have an empty game object named FlockController, which our
    `FlockController` script is attached to. The Target game object is a sphere with
    a bright yellow material and the `TargetMovement` script attached to it. All of
    the environment blocks are nested under the Environment game object, which in
    this case is a plane. The last three items are there to drive our camera, which
    will automatically lock on to our target, and keep it in frame. As it is outside
    the scope of this book, we'll skip over how the camera works, but if you're the
    curious type, you'll want to explore the official Unity documentation for more
    information on **Cinemachine** and **Timeline**, which drive the camera in our
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the matter at hand—let''s take a look at the `FlockController`, which
    looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a75fa6d5-c731-4065-89cb-7d2ec8322047.png)'
  prefs: []
  type: TYPE_IMG
- en: The FlockController component
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows the values we have set in the sample scene.
    As you can see, the separation weight is a bit higher than the rest. Feel free
    to tweak the weight values in play mode to see how it affects the boids'' behavior.
    Next, let''s take a look at the target game object. The following screenshot shows
    our sample setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b639f13-9322-4063-9078-79fe5cf80c49.png)'
  prefs: []
  type: TYPE_IMG
- en: The test values for our target movement script
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot shows the optimal values for our test scene. Tweaking the bounds
    might result in some wild camera movement, but play with the move and turn speed
    to see how it affects the scene in play mode. Lastly, let''s take a look at our
    boid prefab, which has the `Boid` component on it. The provided sample project''s
    boid settings can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d7cd9c4-38d7-4dd5-880a-2e7c785a7cf7.png)'
  prefs: []
  type: TYPE_IMG
- en: All the components and setup for the Boid game object
  prefs: []
  type: TYPE_NORMAL
- en: There isn't too much excitement in the preceding screenshot. As you can see,
    the Flock Controller is empty (because we assign it via code at runtime), and
    there are no other values to be tweaked on the boid itself, besides the appearance
    if you feel so inclined, but our neon green cube is a work of art, if I do say
    so myself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you hit play, you''ll see your boids spawn and follow the target as it
    zooms around the scene. It''ll look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2c2f552-2999-4cd5-a261-ee41ca3f3e40.png)'
  prefs: []
  type: TYPE_IMG
- en: Our flock of boids swarming towards the target sphere
  prefs: []
  type: TYPE_NORMAL
- en: And just like that, we've created our very own flocking system. It's highly
    encouraged that you not only tweak the values in the inspector, but that you take
    a stab at modifying the code. The easiest way to see how a value affects the entire
    system is to either remove it, or increase it by a ridiculous amount. Next, we'll
    take a look at crowds in Unity 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Using crowds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Crowd simulations are far less cut-and-dried. There really isn't any *one* way
    to implement them in a general sense. While not a strict definition, the term
    "crowd simulation" generally refers to simulating crowds of humanoid agents navigating
    an area while avoiding each other and the environment. Like flocks, the use of
    crowd simulations has been widely used in films. For example, the epic armies
    of Rohan, Gondor, and Mordor battling one another in *The Lord of the Rings* were
    completely procedurally generated using the crowd simulation software **Massive**,
    which was created for use in the film. While the use of crowd algorithms is not
    as widespread in video games as in films, certain genres rely on the concept more
    than others. Real-time strategy games often involve armies of characters moving
    in unison across the screen, and many sandbox games simulate dense cities with
    many agents on-screen going about their day while avoiding each other, the player,
    and even traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple crowd simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our implementation will be quick, simple, and effective, and it will focus
    on using Unity''s NavMesh feature. Thankfully, NavMesh will handle much of the
    heavy lifting for us. Our sample Crowds scene has a simple walking surface with
    a NavMesh baked onto it, a couple of targets, and two teams of capsules, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1959a40f-bac4-421e-bb75-c5579d0a08f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The classic scenario: red versus blue'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see that our red and blue targets are opposite
    their teams: red and blue, respectively. Your guess is as good as mine as to why
    the blue and red clans just can''t get along, but it''ll work for our sample,
    so I''m just going to let them do their thing. The setup is straightforward. Each
    capsule has a `CrowdAgent.cs` component attached to it, and when you hit play,
    each agent will head towards their target while avoiding each other and the oncoming
    capsules from the opposite team. Once they reach their destination, they will
    gather around the target.'
  prefs: []
  type: TYPE_NORMAL
- en: This setup takes our example from [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way *and takes it to the next level. Now we have large groups of
    agents that are not only navigating to a target location, but doing so while avoiding
    large groups of agents at the same time. As you can see, Unity's NavMesh handles
    these interactions beautifully. The system is efficient and very robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the game is running, you can even select a single capsule or a group
    of them in the editor to see their behavior visualized. As long as you have the
    navigation window active, you''ll be able to see some debugging information about
    your NavMesh and the agents on it, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54ded18e-6ecc-4350-ae27-39cf54c1c6a0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The debug view from an agent's perspective
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth checking this out in the editor to really get an idea of how this
    looks in motion, but we''ve labeled a few key elements in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the destination arrow that points toward the `NavMeshAgent` destination,
    which for this little guy is `RedTarget`. All this arrow cares about is where
    the destination is, regardless of the direction the agent is facing or moving
    toward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This arrow is the heading arrow. It shows the actual direction the agent is
    moving in. The direction of the agent takes into account several factors, including
    the position of its neighbors, space on the NavMesh, and the destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This debug menu allows you to show a few different things. In our case, we enabled
    Show Avoidance and Show Neighbours.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Speaking of avoidance, this cluster of squares, ranging from dark to light and
    floating over the agents, represents the areas to avoid between our agent and
    the destination. The darker squares indicate areas that are densely populated
    by other agents or blocked by the environment, while the lighter-white squares
    indicate areas that are safe to walk through. Of course, this is a dynamic display,
    so watch it change as you play in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the CrowdAgent component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CrowdAgent` component is incredibly simple, but gets the job done. As
    mentioned earlier, Unity does most of the heavy lifting for us. The following
    code gives our `CrowdAgent` a destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The script requires a component of type `NavMeshAgent`, which it assigns to
    the `agent` variable on `Start()`. We then set its speed randomly between two
    values for some added visual variety in our simulation. Lastly, we set its destination
    to be the position of the target marker. The target marker is assigned via the
    inspector, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab320924-64ec-410f-809f-2b8ca35d8525.png)'
  prefs: []
  type: TYPE_IMG
- en: The inspector settings for the NavMeshAgent
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates a red capsule's `CrowdAgent` component
    with RedTarget (Transform) set as its Target. For fun, you can try setting different
    targets. Since the only requirement is that it be of type `Transform`, you could
    even set another agent as the target!
  prefs: []
  type: TYPE_NORMAL
- en: Adding some fun obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without having to do anything else in our code, we can make a few changes to
    our scene layout and enable a few components provided by Unity to dramatically
    alter the behavior of our agents. In our `CrowdsObstacles` scene, we''ve added
    a few walls to the environment, creating a maze-like layout for our red and blue
    teams of capsules to traverse, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/248be45b-ff66-4947-9771-ba2dcfdc1296.png)'
  prefs: []
  type: TYPE_IMG
- en: Let the games begin!
  prefs: []
  type: TYPE_NORMAL
- en: 'The fun part about this example is that, because of the randomized speed of
    each agent, the results will be totally different each time you run the game.
    As the agents move through the environment, they''ll be blocked by teammates or
    opposing agents and will be forced to re-route and find the quickest route to
    their target. Of course, this concept is not new to us, as we saw `NavMeshAgent`
    avoiding obstacles in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*, except that we have many, many more agents in this scenario.
    To add a bit more fun to the example, we''ve also added a simple up-down animation
    to one of the walls and a `NavMeshObstacle` component, which looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4d97355-d9ae-465b-9eb5-67d6500a0d9d.png)'
  prefs: []
  type: TYPE_IMG
- en: NavMeshObstacle looks a bit different in Unity 2017
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that our obstacle does not need to be set to Static when we are using
    this component. Our obstacle is mostly box-like, so we leave the default Shape
    setting as Box (Capsule is another choice). The Size and Center options let us
    move the outline of our shape around and resize it, but the default settings fit
    our shape perfectly, which is what we want, so let''s leave that alone. The next
    option, Carve, is important. It essentially does exactly what it says; it carves
    a space out of the NavMesh, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12c743d8-ed57-48d0-9ec6-e2b15056d012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same obstacle at two different points of its up-down animation
  prefs: []
  type: TYPE_NORMAL
- en: The left screenshot shows the space carved out when the obstacle is on the surface,
    while the NavMesh is connected in the right screenshot when the obstacle is raised
    off the surface. We can leave Time to Stationary and Move Threshold as they are,
    but we do want to make sure that Carve Only Stationary is turned off. This is
    because our obstacle is moving, and if we didn't tick this box, it would not carve
    out the space from the NavMesh, and our agents would be trying to move through
    the obstacle whether it was up or down, which is not the behavior we are after
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: As the obstacle moves up and down and the mesh is carved out and reconnected,
    you'll notice the agents changing their heading. With the navigation debug options
    enabled, we can also see a very interesting visualization of everything going
    on with our agents at any given moment. It may seem a bit cruel to mess with our
    poor agents like this, but we're doing it for science!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot gives us a glimpse into the chaos and disorder we''re
    subjecting our poor agents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d98f34b-bff9-4c65-ad54-1be5fd8138bf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I'm secretly rooting for the blue team
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement a flocking behavior system. We
    implemented it using custom direction vectors to control the boids' movement that
    we calculated by applying Craig Reynolds' three main flocking concepts—alignment,
    coherence, and separation. We then applied our flocking behavior to the flying
    objects, but you can apply the techniques in these examples to implement other
    character behaviors, such as fish shoaling, insects swarming, or land animals
    herding. You'll only have to implement different leader movement behaviors, such
    as limiting movement along the *y* axis for characters that can't move up and
    down. For a 2D game, we would just freeze the *y* position. For 2D movement along
    uneven terrain, we would have to modify our script to not put any forces in the
    *y* direction.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a look at crowd simulation and even implemented our own version
    of it using Unity's NavMesh system, which we first learned about in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*. We learned how to visualize our agents' behavior and decision-making
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the behavior tree pattern and learn to implement
    our own version of it from scratch.
  prefs: []
  type: TYPE_NORMAL
