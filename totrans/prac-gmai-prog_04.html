<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Environment and AI</h1>
                </header>
            
            <article>
                
<p>When creating AI for video games, one of the most important aspects is its placement. As we discovered previously, the position of the AI character can completely change his behavior and future decisions. In this chapter, we'll be exploring how the environment of the game can influence our AI and how he should be using it properly, in-depth. This will cover a wide range of game genres with different map structures such as open world, arcade, and racing.</p>
<p>As a player, we like to have a vivid world to explore, with many things to do, and interact with. As a game developer or game designer, that generally means a lot of work because everything that the player is able to interact with has to be carefully planned and executed the right way, to avoid bugs or any other unfortunate distractions from the gameplay. The same goes for the AI characters that we are creating. If we allow the character to interact with the environment, that requires a lot of work, thought, planning, and coding to make it work properly. The number of options available for the player or AI usually equals the number of issues that can occur, so we need to give special attention to the environment while creating our games.</p>
<p>Not every game necessarily has a map or terrain, but perhaps the position where the action is happening at the time still has importance for the gameplay, and the AI should have that in mind. Also, sometimes, the environment or positioning has a subtle impact on the characters of the game that we don't notice while playing the game but, most of the time, those subtle changes contribute to a good and enjoyable experience. That is why the interaction with the environment is an important aspect while creating a video game because it is responsible for giving life to the characters and, without it, they would remain simple 3D or 2D models.</p>
<p>On the other hand, we can't forget the opposite, interaction with the environment by the characters of the game. If our life could be represented in a video game, the impact that we have on the environment should be one of the aspects involved in the game. For example, if we throw a cigarette into a forest, it has a high probability of burning some leaves and causing a fire, leaving all the animals that inhabit that forest with ailments, and the consequences just keep growing. So, it's also interesting to look at how the environment should react according to what is happening in the game. During the game design process, we have the opportunity to choose if that interaction is relevant to the gameplay or if it's only there for visual purposes, but, either way, it certainly contributes to a rich environment that everybody loves. In this chapter, we'll have the opportunity to explore all of the options above in depth and we'll start exploring the basic interactions that don't change the gameplay. We'll finish the chapter with advanced interactions that have a deep impact on the game experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual interactions</h1>
                </header>
            
            <article>
                
<p>Visual interactions are the basic ones that don't influence the gameplay directly but help to polish our video game and characters, making them part of the environment that we are creating, contributing significantly to the immersion of the player in the game. There are many examples of this subject and we can find them in almost any type of game. This shows us the importance of the environment being part of the game and not merely existing to help fill the screen. It's getting more usual to see these types of interaction in games and players expect them. If there's an object in the game, it should do something, important or not. This makes the environment that we are creating more vibrant and alive, which is definitely a good thing.</p>
<p>We can find one of the first examples of environment interaction in the original <em>Castlevania</em>, released in 1986 for the Nintendo Entertainment System. Right from the start, the player can use the whip to destroy the candles and fire pits that originally made up part of the background.</p>
<div class="CDPAlignCenter CDPAlign"><img height="304" width="325" class=" image-border" src="assets/8497f937-9654-450f-8627-bd6e834e93b3.jpg"/></div>
<p>This game and a few others released at the time, opened many doors and possibilities in terms of the perception that we have in relation to the background or environment that surround the characters of the game. Obviously, because of the hardware limitations of this generation of consoles, it was much harder to create simple things that we see as common by today's standards. But every generation of consoles kept bringing more capabilities and creators like us kept using that in our favor to create amazing games.</p>
<p>So, our first example of a visual interaction is the object in the background that can be destroyed without interfering directly with the gameplay. This type of interaction can be seen in multiple games and is as simple as coding an object to animate when it's attacked. Then, we can decide if the object drops some points or collectibles just to reward the player for exploring the game. We'll now move on to our next example, the assets in the game that are animated or which move when the characters pass through them. It's the same principle as the destroyable object but this time, a subtler interaction that requires the character to move near the position where the asset is positioned. This can be applied to different things inside the game, from the grass moving, to dust or water, birds that fly away, or people that perform a funny gesture; there are endless possibilities. When we analyze these interactions, we can easily determine that they don't necessarily have an artificial intelligence behind them, where most of the time, it is just a Boolean function that activates according to some predetermined action. But they make up part of the environment and, for that reason, they needs to be taken into consideration when we want a good integration between environment and AI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic environment interactions</h1>
                </header>
            
            <article>
                
<p>As we saw previously, the environment became part of the video game experience and that sparked many new concepts and ideas for future game titles. The next step was to integrate those slight changes into the gameplay and use them to shape the way characters behave inside the game. This definitely had a positive contribution to video game history, where everything inside the scene started to gain life and the player became aware of those rich surroundings. Using the environment to achieve goals inside the game started to be part of the gameplay experience.</p>
<div class="CDPAlignCenter CDPAlign"><img height="252" width="447" class=" image-border" src="assets/5a9f20a1-cf94-46b6-acb5-7cf2c036c12c.jpg"/></div>
<p>To demonstrate one example of an environment object that directly influences the gameplay, we have the Tomb Raider franchise that showcases this perfectly. In this example, our character, Lara Croft, needs to push the cube until it is positioned on top of the marked area. This will change the environment and unlock a new path that allows the player to move forward in the level. We can find this type of challenge in a number of games where it's necessary to trigger a specific position in the map in order to make something happen in another part, and this can be used to accomplish a specific objective in the game. Usually we need to change the environment as it is, in order to progress on that level. So, when we plan the map or stage, we take those interactions into consideration and then we create all the rules that belong to each interaction. For example:</p>
<pre>if(cube.transform.position == mark.transform.position) <br/>{ <br/>   openDoor = true; <br/>} </pre>
<p>Now let's imagine for a minute that Lara Croft had an allied character whose main task was to help her put that box in place? And that's exactly one type of interaction that we will be looking at in this chapter, where the AI character understands how the environment works and how to use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving environment objects</h1>
                </header>
            
            <article>
                
<p>Let's jump right into that scenario and try to recreate the situation where we have an AI character that is able to help our player achieve his goal. For this example, let's assume that our player is trapped in a position where he cannot access the interactive object that releases him from that situation. The character that we'll be creating needs to be able to find the cube and push it toward the desired position.</p>
<div class="CDPAlignCenter CDPAlign"><img height="337" width="602" class=" image-border" src="assets/314c7afa-d832-4c63-b7bd-cb8dac9fac4d.jpg"/></div>
<p>So now that we have all the characters and objects set in our environment example, let's plan how the AI character should behave in this situation. First, he needs to see that the player is near so he can start searching and move the cube to the right position. Let's assume that if the cube is on that mark, a new block will rise from the sand allowing the player to proceed in the level. The AI character can push the cube in four different directions, left, right, front, and back, making sure it aligns perfectly with the position mark.</p>
<div class="CDPAlignCenter CDPAlign"><img height="535" width="334" class=" image-border" src="assets/f4f26438-7bd6-4cf1-be26-c91a8ce44f1d.jpg"/></div>
<p>The AI character needs to question and validate every action demonstrated in the behavior tree previously. The first and most important thing in order to proceed with the objective is the character needs to be sure that the player is positioned on his mark. If the player has not arrived yet, our character needs to wait and hold position. If the player has arrived already, the AI character proceeds and asks himself if he is near the cube object or not. If not, our character needs to go toward the cube, and once that action is validated, he will ask the same question again. Once the answer is yes and the character is near the cube, he needs to calculate in which direction the cube needs to be pushed first. Then he will be pushing towards the <strong>Y</strong> <strong>AXIS</strong> or <strong>X</strong> <strong>AXIS</strong> until the cube is aligned with the MARK POSITION and the objective gets completed.</p>
<p> </p>
<pre> public GameObject playerMesh;<br/> public Transform playerMark;<br/> public Transform cubeMark;<br/> public Transform currentPlayerPosition;<br/> public Transform currentCubePosition;<br/><br/> public float proximityValueX;<br/> public float proximityValueY;<br/> public float nearValue;<br/><br/> private bool playerOnMark;<br/><br/><br/> void Start () {<br/><br/> }<br/>void Update () {<br/><br/> // Calculates the current position of the player<br/> currentPlayerPosition.transform.position = playerMesh.transform.position;<br/><br/> // Calculates the distance between the player and the player mark of the X axis<br/> proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<br/><br/> // Calculates the distance between the player and the player mark of the Y axis<br/> proximityValueYplayerMark.transform.position.y - currentPlayerPosition.transform.position.y;<br/><br/> // Calculates if the player is near of his MARK POSITION<br/> if((proximityValueX + proximityValueY) &lt; nearValue)<br/> {<br/>    playerOnMark = true;<br/> } <br/>}  </pre>
<p>We start adding the information into our code that allows the character to validate if the player is near his marked position. For this, we create all the variables necessary to calculate the distances of the player and the position that he needs to be in. <kbd>playerMesh</kbd> refers to the 3D model of the player where we'll extract his position and use it as <kbd>currentPlayerPosition</kbd>. To know if he is near his mark, we need a variable that represents the MARK POSITION and in this example, we created the <kbd>playerMark</kbd> variable where we can write down the position in which we want our player to be. Then we added three variables that allow us to know if the player is near. <kbd>proximityValueX</kbd> will calculate the distance between the player and the mark on the X axis. <kbd>proximityValueY</kbd> will calculate the distance between the player and the mark on the Y axis. Then we have the <kbd>nearValue</kbd> where we can define how far the player can be from the MARK POSITION so that our AI character can start working on the objective. Once the player is near his mark, the <kbd>playerOnMark</kbd> Boolean changes to true.</p>
<div class="packt_tip">To calculate the distance between the player and his mark, we used this: Distance between the player and his mark is the same as (mark.position - player.position).</div>
<p>Now, to discover if the AI character is near the cube, we will be doing the same equation, calculating the distance between the AI and the cube. Also, we completed the code, as follows, with the positions of both marks (player and cube mark):</p>
<pre> public GameObject playerMesh;<br/> public Transform playerMark;<br/> public Transform cubeMark;<br/> public Transform currentPlayerPosition;<br/> public Transform currentCubePosition;<br/><br/> public float proximityValueX;<br/> public float proximityValueY;<br/> public float nearValue;<br/><br/> public float cubeProximityX;<br/> public float cubeProximityY;<br/> public float nearCube;<br/><br/> private bool playerOnMark;<br/> private bool cubeIsNear;<br/><br/><br/> void Start () {<br/><br/>    Vector3 playerMark = new Vector3(81.2f, 32.6f, -31.3f);<br/>    Vector3 cubeMark = new Vector3(81.9f, -8.3f, -2.94f);<br/>    nearValue = 0.5f;<br/>    nearCube = 0.5f;<br/> }<br/><br/> void Update () {<br/><br/> // Calculates the current position of the player<br/> currentPlayerPosition.transform.position = playerMesh.transform.position;<br/><br/> // Calculates the distance between the player and the player mark of the X axis<br/> proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x; <br/><br/> // Calculates the distance between the player and the player mark of the Y axis<br/> proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<br/><br/> // Calculates if the player is near of his MARK POSITION<br/> if((proximityValueX + proximityValueY) &lt; nearValue)<br/> {<br/>    playerOnMark = true;<br/> }<br/><br/> cubeProximityX = currentCubePosition.transform.position.x - this.transform.position.x;<br/> cubeProximityY = currentCubePosition.transform.position.y - this.transform.position.y;<br/><br/> if((cubeProximityX + cubeProximityY) &lt; nearCube)<br/> {<br/>    cubeIsNear = true;<br/> }<br/><br/>else<br/> {<br/>    cubeIsNear = false;<br/> }<br/>}  </pre>
<p>Now, our AI character knows if he is near the cube or not, this will answer the question and determine if he can proceed to the next branch that we have planned. But what happens when our character is not near the cube? He will need to walk toward the cube. So, we'll add that into our code:</p>
<pre> public GameObject playerMesh;<br/> public Transform playerMark;<br/> public Transform cubeMark;<br/> public Transform cubeMesh;<br/> public Transform currentPlayerPosition;<br/> public Transform currentCubePosition;<br/><br/> public float proximityValueX;<br/> public float proximityValueY;<br/> public float nearValue;<br/><br/> public float cubeProximityX;<br/> public float cubeProximityY;<br/> public float nearCube;<br/><br/> private bool playerOnMark;<br/> private bool cubeIsNear;<br/><br/> public float speed;<br/> public bool Finding;<br/><br/><br/> void Start () {<br/><br/>  Vector3 playerMark = new Vector3(81.2f, 32.6f, -31.3f);<br/>  Vector3 cubeMark = new Vector3(81.9f, -8.3f, -2.94f);<br/>  nearValue = 0.5f;<br/>  nearCube = 0.5f;<br/>  speed = 1.3f;<br/>}<br/><br/> void Update () {<br/><br/> // Calculates the current position of the player<br/> currentPlayerPosition.transform.position = playerMesh.transform.position;<br/><br/> // Calculates the distance between the player and the player mark of the X axis<br/> proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x; <br/><br/> // Calculates the distance between the player and the player mark of the Y axis<br/> proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<br/><br/> // Calculates if the player is near of his MARK POSITION<br/> if((proximityValueX + proximityValueY) &lt; nearValue)<br/> {  <br/>     playerOnMark = true;<br/> }<br/><br/> cubeProximityX = currentCubePosition.transform.position.x - this.transform.position.x;<br/> cubeProximityY = currentCubePosition.transform.position.y - this.transform.position.y;<br/><br/> if((cubeProximityX + cubeProximityY) &lt; nearCube)<br/> {<br/>     cubeIsNear = true;<br/> }<br/><br/> else<br/> {<br/>     cubeIsNear = false;<br/> }<br/><br/> if(playerOnMark == true &amp;&amp; cubeIsNear == false &amp;&amp; Finding == false)<br/> {<br/>    PositionChanging();<br/> }<br/><br/> if(playerOnMark == true &amp;&amp; cubeIsNear == true)<br/> {<br/>    Finding = false;<br/> }<br/><br/> }<br/><br/> void PositionChanging () {<br/><br/> Finding = true;<br/> Vector3 positionA = this.transform.position;<br/> Vector3 positionB = cubeMesh.transform.position;<br/> this.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<br/> }</pre>
<p>So far, our AI character is able to calculate the distance between himself and the cube; if they are too far apart, he will go toward the cube. Once this quest is completed, he can move on to the next phase and start pushing the cube. The last thing that he needs to calculate is how far the cube is from the mark position and he then decides which side needs to be pushed first by taking into consideration how far it is from each side.</p>
<div class="CDPAlignCenter CDPAlign"><img height="176" width="281" class=" image-border" src="assets/66f26ccc-3afc-474d-b013-e5085aae87de.jpg"/></div>
<p>The cube can only be pushed on the <strong>X</strong> axis or <strong>Z</strong> axis and the rotation isn't relevant for now as the button is activated once the cube is on top of it. Taking that into consideration, our character AI needs to calculate how far the cube is from the <strong>X MARK POSITION</strong> and <strong>Z MARK POSITION</strong>. Then he will compare the two different axis values and choose which one is farther away from the desired position and start pushing from that one. The character will push in that direction until the cube is aligned with the marked position and then switch to the other side, and push it until it's completely on top of the <strong>MARK POSITION</strong>:</p>
<pre> public GameObject playerMesh;<br/> public Transform playerMark;<br/> public Transform cubeMark;<br/> public Transform cubeMesh;<br/> public Transform currentPlayerPosition;<br/> public Transform currentCubePosition;<br/><br/> public float proximityValueX;<br/> public float proximityValueY;<br/> public float nearValue;<br/><br/> public float cubeProximityX;<br/> public float cubeProximityY;<br/> public float nearCube;<br/><br/> public float cubeMarkProximityX;<br/> public float cubeMarkProximityZ;<br/><br/> private bool playerOnMark;<br/> private bool cubeIsNear;<br/><br/> public float speed;<br/> public bool Finding;<br/><br/><br/> void Start () {<br/><br/>         Vector3 playerMark = new Vector3(81.2f, 32.6f, -31.3f);<br/>         Vector3 cubeMark = new Vector3(81.9f, -8.3f, -2.94f);<br/>         nearValue = 0.5f;<br/>         nearCube = 0.5f;<br/>         speed = 1.3f;<br/> }<br/><br/> void Update () {<br/><br/> // Calculates the current position of the player<br/> currentPlayerPosition.transform.position = playerMesh.transform.position;<br/><br/> // Calculates the distance between the player and the player mark of the X axis<br/> proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x; <br/><br/> // Calculates the distance between the player and the player mark of the Y axis<br/> proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<br/><br/> // Calculates if the player is near of his MARK POSITION<br/> if((proximityValueX + proximityValueY) &lt; nearValue)<br/> {<br/>    playerOnMark = true;<br/> }<br/><br/> cubeProximityX = currentCubePosition.transform.position.x - this.transform.position.x;<br/> cubeProximityY = currentCubePosition.transform.position.y - this.transform.position.y;<br/><br/> if((cubeProximityX + cubeProximityY) &lt; nearCube)<br/> {<br/>    cubeIsNear = true;<br/> }<br/><br/> else<br/> {<br/>    cubeIsNear = false;<br/> }<br/><br/> if(playerOnMark == true &amp;&amp; cubeIsNear == false &amp;&amp; Finding == false)<br/> {<br/>     PositionChanging();<br/> }<br/><br/> if(playerOnMark == true &amp;&amp; cubeIsNear == true)<br/> {<br/>     Finding = false;<br/>   }<br/><br/>  cubeMarkProximityX = cubeMark.transform.position.x - currentCubePosition.transform.position.x;<br/>  cubeMarkProximityZ = cubeMark.transform.position.z - currentCubePosition.transform.position.z;<br/><br/>  if(cubeMarkProximityX &gt; cubeMarkProximityZ)<br/>  {<br/>    PushX();<br/>  }<br/><br/>  if(cubeMarkProximityX &lt; cubeMarkProximityZ)<br/>  {<br/>    PushZ();<br/>  }<br/><br/> }<br/><br/> void PositionChanging () {<br/><br/> Finding = true;<br/> Vector3 positionA = this.transform.position;<br/> Vector3 positionB = cubeMesh.transform.position;<br/> this.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<br/><br/> <br/>} </pre>
<p>With the final actions added to our code, our AI character should be able to conclude its objective and find and push the cube to the desired position, so the player can proceed and finish the level. In this example, we focused on how to calculate distances between objects of the scene and characters. This will help create similar types of interactions where it's necessary to put an object in the game in a certain position.</p>
<p>The example demonstrates an allied AI character that helps the player, but the same principles could be applied if we wanted the opposite effect (being an enemy) where the character would need to find the cube as fast as possible to stop the player.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obstructive environment objects</h1>
                </header>
            
            <article>
                
<p>As we saw previously, we can use or move objects in the game to fulfill an objective, but what happens if the character has an object obstructing his way? The object could be placed by the player or simply designed to be in that position of the map and either way, the AI character should be able to determine what to do in that situation.</p>
<p>We can observe this behavior, for example, in a strategy game called <em>Age of Empires II</em> developed by Ensemble Studios. Every time the characters of the game can't access the enemy territory because of their surrounded fortified walls, the AI characters focus and start destroying a portion of the wall so they can get in. This type of interaction is very smart and important as well, because otherwise they would just be going around the wall searching for an entry and that wouldn't look intelligent. Because the fortified wall is created by the player, it can be placed anywhere, with any shape or form and for that reason, it is necessary to think about that when developing an AI opponent.</p>
<div class="CDPAlignCenter CDPAlign"><img height="283" width="502" class=" image-border" src="assets/17c103d0-b23d-4624-83af-bc3a93573f1e.jpg"/></div>
<p>This example is also relevant because, in the planning phase, when we are creating behavior trees, we need to think about what happens if something gets in the way of the character and he can't accomplish his objectives. That will be explored in depth in a future chapter of the book, but for now, we'll simplify this situation and analyze how the AI character should behave if an environment object is interfering with his objective.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="195" width="348" class=" image-border" src="assets/e2904501-8a41-4ad0-8e5a-f555b3716f44.png"/></div>
<p>In our example, the AI character needs to enter the house but when he arrives near, realizes that it is surrounded by wooden fences and he can't pass through. At that point, we want the character to choose a target and start attacking until that portion of the fence is destroyed so he can find a way to enter the house.</p>
<p>For this example, we´ll need to calculate which fence our character needs to attack, taking into consideration the distance and the current health state of the fence. The fence with low HP should have a higher priority to be attacked first compared to a fence that is at full HP, so we'll be including that in our calculation.</p>
<div class="CDPAlignCenter CDPAlign"><img height="155" width="264" class=" image-border" src="assets/45359cb2-6da9-48b0-be07-75ff01592691.jpg"/></div>
<p>We want to define a circumference around the character where the closest fences give their information to the AI so he can decide which one is the easiest to destroy. This can be done with different methods, either by using collision detection on the fences that get triggered by the player, or having them calculate the distance between fences/objects and the player; we define a distance value where the player perceives the condition of the fence. For this example, we'll be calculating the distance and use it to alert the character about the HP of the fences.</p>
<p>Let's start by creating the code that will be implemented on the <kbd>fence</kbd> object; all of them will have the same script as follows:</p>
<pre> public float HP;<br/> public float distanceValue;<br/> private Transform characterPosition;<br/> private GameObject characterMesh;<br/><br/> private float proximityValueX;<br/> private float proximityValueY;<br/> private float nearValue;<br/><br/> // Use this for initialization<br/> void Start () {<br/><br/> HP = 100f;<br/> distanceValue = 1.5f;<br/><br/> // Find the Character Mesh<br/> characterMesh = GameObject.Find("AICharacter");<br/> }<br/><br/> // Update is called once per frame<br/> void Update () {<br/><br/> // Obtain the Character Mesh Position<br/> characterPosition = characterMesh.transform;<br/><br/> //Calculate the distance between this object and the AI Character<br/> proximityValueX = characterPosition.transform.position.x - this.transform.position.x;<br/> proximityValueY = characterPosition.transform.position.y - this.transform.position.y;<br/><br/> nearValue = proximityValueX + proximityValueY;<br/> } </pre>
<p>In this script, we added the basic information about the HP and distances that we'll be using to connect with the AI character. This time, we are adding the script that calculates the distances into the <kbd>environment</kbd> object instead of the character; this gives more dynamism to the object and allows us to create more things with it. As an example, if the characters of the game are the ones responsible for creating the fences, they will have different states, such as currently building, completed, and damaged; then the character will receive that information and use it to his advantage.</p>
<p>Let's move forward and define our AI character to interact with the <kbd>environment</kbd> object. His primary objective is to access the house, but when he arrives near, he realizes that he cannot get inside because it's surrounded by the wood fences. After analyzing the situation, we want our character to destroy a fence so he can finally accomplish his objective and get into the house.</p>
<p>In the character script, we'll be adding a <kbd>static</kbd> function, where the fences can input their information about their current health; this will help the AI character choose a better fence to destroy.</p>
<pre> public static float fenceHP;<br/> public static float lowerFenceHP;<br/> public static float fencesAnalyzed;<br/> public static GameObject bestFence;<br/><br/> private Transform House;<br/><br/> private float timeWasted;<br/> public float speed;<br/><br/><br/><br/> void Start () {<br/><br/>         fenceHP = 100f;<br/>         lowerFenceHP = fenceHP;<br/>         fencesAnalyzed = 0;<br/>         speed = 0.8;<br/><br/>         Vector3 House = new Vector3(300.2f, 83.3f, -13.3f);<br/><br/> }<br/><br/> void Update () {<br/><br/>         timeWasted += Time.deltaTime;<br/><br/>         if(fenceHP &gt; lowerFenceHP)<br/>         {<br/>             lowerFenceHP = fenceHP;<br/>         }<br/><br/>         if(timeWasted &gt; 30f)<br/>         {<br/>             GoToFence();   <br/>         }<br/> }<br/><br/> void GoToFence() {<br/><br/>         Vector3 positionA = this.transform.position;<br/>         Vector3 positionB = bestFence.transform.position;<br/>         this.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<br/> } </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="414" width="258" class=" image-border" src="assets/05bf51f5-f295-41a5-9b34-239542d532bd.jpg"/></div>
<p>We already added the basic information into our character. <kbd>fenceHP</kbd> will be the static variable where every fence triggered by the character gives their information about the current HP. Then the AI character analyzes the collected information and compares it with the lowest HP fence that is represented as <kbd>lowerFenceHP</kbd>. The character has a <kbd>timeWasted</kbd> variable that represents the number of seconds that he has already spent looking for a good fence to attack. <kbd>fencesAnalyzed</kbd> will be used to know if there's already a fence in the code, and if not, it will have added the first fence that he finds; in the case of the fences having the same HP value, the character will attack them first. Now let's update our fence code, so they can access the character script and input some useful information.</p>
<pre> public float HP;<br/> public float distanceValue;<br/> private Transform characterPosition;<br/> private GameObject characterMesh;<br/><br/> private float proximityValueX;<br/> private float proximityValueY;<br/> private float nearValue;<br/> void Start () {<br/><br/>         HP = 100f;<br/>         distanceValue = 1.5f;<br/><br/>         // Find the Character Mesh<br/>         characterMesh = GameObject.Find("AICharacter");<br/> }<br/><br/> void Update () {<br/><br/>         // Obtain the Character Mesh Position<br/>         characterPosition = characterMesh.transform;<br/><br/>         //Calculate the distance between this object and the AI Character<br/>         proximityValueX = characterPosition.transform.position.x - this.transform.position.x;<br/>         proximityValueY = characterPosition.transform.position.y - this.transform.position.y;<br/><br/>         nearValue = proximityValueX + proximityValueY;<br/><br/>         if(nearValue &lt;= distanceValue){<br/>             if(AICharacter.fencesAnalyzed == 0){<br/>                 AICharacter.fencesAnalyzed = 1;<br/>                 AICharacter.bestFence = this.gameObject;<br/>             }<br/><br/>             AICharacter.fenceHP = HP;<br/><br/>             if(HP &lt; AICharacter.lowerFenceHP){<br/>                 AICharacter.bestFence = this.gameObject;<br/>             }<br/>         }<br/> } </pre>
<p>We finally conclude this example, where the fence compares their current HP with the data that the character has (<kbd>lowerFenceHP</kbd>) and if their HP is lower than the lowest value that the character has, that fence will be considered the <kbd>bestFence</kbd>.</p>
<p>This example demonstrates how to adapt the AI character to different dynamic objects of the game; the same principle can be expanded and used to interact with almost any object. It's also relevant and useful to use the objects to interact with the character as well, linking information between the two.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking down the environment by area</h1>
                </header>
            
            <article>
                
<p>When we create a map, often we have two or more different areas that could be used to change the gameplay, areas that could contain water, quicksand, flying zones, caves, and much more. If we wish to create an AI character that can be used in any level of our game, and anywhere, we need to take this into consideration and make the AI aware of the different zones of the map. Usually that means that we need to input more information into the character's behavior, including how to react according to the position in which he is currently placed, or a situation where he can choose where to go.</p>
<p>Should he avoid some areas? Should he prefer others? This type of information is relevant because it makes the character aware of the surroundings, choosing or adapting and taking into consideration his position. Not planning this correctly can lead to some unnatural decisions; for example, in <em>Elder Scrolls V: Skyrim</em> developed by Bethesda Softworks studio, we can watch some AI characters of the game simply turning back when they do not have information about how they should behave in some parts of the map, especially on mountains or rivers.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="360" width="639" class=" image-border" src="assets/585a7be3-5542-4fa4-ac7d-ac0fbf1c10f5.png"/></div>
<p>Depending on the zones that our character finds, he might react differently or update his behavior tree to adapt to his environment. We have previously created a soldier that changed the way he would react according to his health, aim success, and player health, and now we are exploring the environment so the character can use it to better define what to do. We could also use this to update one of our previous examples, the real-life simulation. If the Sofie character goes to one specific section of the house, she could use that information to update her priorities and replenish all the necessities that are attached to that portion of the house. Let's say that she was in the kitchen; once she is there, after preparing the breakfast, she takes the opportunity to take out the garbage. As we see, the environment that surrounds our characters can redefine their priorities or completely change their behaviors.</p>
<p>This is a little similar to what Jean-Jacques Rousseau said about humanity: "<span class="QuoteChar"><em>We are good by nature, but corrupted by society.</em></span>" As humans, we are a representation of the environment that surrounds us, and for that reason, artificial intelligence should follow the same principle.</p>
<p>Let's pick a previous character that we have already created and update his code to work on a different scenario. The chosen one for this example is the soldier and we want to change his behavior according to three different zones, beach, river, and forest. So, we'll create three public static Boolean functions with the names <kbd>Beach</kbd>, <kbd>Forest</kbd> and <kbd>River</kbd>; then we define the zones on the map that will turn them on or off.</p>
<pre> public static bool Beach;<br/> public static bool River;<br/> public static bool Forest;</pre>
<p>Because in this example, just one of them can be true at a time, we'll add a simple line of code that disables the other options once one of them gets activated.</p>
<pre>if(Beach == true) <br/>{<br/> Forest = false;<br/> River = false;<br/> }<br/><br/> if(Forest == true){<br/> Beach = false;<br/>  River = false;<br/> }<br/><br/> if(River == true){<br/> Forest = false;<br/>  Beach = false;<br/> }</pre>
<p>Once we have that done, we can start defining the different behaviors for each zone. For example, in the beach zone, the characters don't have a place to get cover, so that option needs to be taken away and updated with a new one. The river zone can be used to get across to the other side, so the character can hide from the player and attack from that position. To conclude, we can define the character to be more careful and use the trees to get cover. Depending on the zones, we can change the values to better adapt to the environment, or create new functions that would allow us to use some specific characteristics of that zone.</p>
<pre>if (Forest == true)<br/> {// The AI will remain passive until an interaction with the player occurs<br/> if (Health == 100 &amp;&amp; triggerL == false &amp;&amp; triggerR == false &amp;&amp; triggerM == false)<br/> {<br/> statePassive = true;<br/> stateAggressive = false;<br/> stateDefensive = false;<br/> }<br/><br/> // The AI will shift to the defensive mode if player comes from the right side or if the AI is below 20 HP<br/> if (Health &lt;= 100 &amp;&amp; triggerR == true || Health &lt;= 20)<br/> {<br/> statePassive = false;<br/> stateAggressive = false;<br/> stateDefensive = true;<br/> }<br/><br/> // The AI will shift to the aggressive mode if player comes from the left side or it's on the middle and AI is above 20HP<br/> if (Health &gt; 20 &amp;&amp; triggerL == true || Health &gt; 20 &amp;&amp; triggerM == true)<br/> {<br/> statePassive = false;<br/> stateAggressive = true;<br/> stateDefensive = false;<br/> }<br/><br/> walk = speed * Time.deltaTime;<br/> walk = speedBack * Time.deltaTime;<br/> } </pre>
<p>This segment will be explored in depth later on when talking about AI Planning and Decision Making, as well as Tactics and Awareness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced environment interactions</h1>
                </header>
            
            <article>
                
<p>As the video game industry and the technology associated with it kept evolving, new gameplay ideas appeared, and rapidly, interaction between the characters of the game and the environment became even more interesting, especially when using physics. This means that the outcome of the environment could be completely random, where it was required for the AI characters to constantly adapt to different situations. One honorable mention on this subject is the video game <em>Worms</em> developed by Team17, where the map can be fully destroyed and the AI characters of the game are able to adapt and maintain smart decisions.</p>
<div class="CDPAlignCenter CDPAlign"><img height="350" width="467" class=" image-border" src="assets/610f8e86-282b-44fd-b160-515714811ec2.jpg"/></div>
<p>The objective of this game is to destroy the opponent team by killing all their worms, the last man standing wins. From the start, the characters can find some extra health points or ammunition on the map and from time to time, it drops more points from the sky. So, there are two main objectives for the character, namely survive and kill. To survive, he needs to keep a decent amount of HP and away from the enemy, the other part is to choose the best character to shoot and take as much health as possible from him. Meanwhile, the map gets destroyed by the bombs and all of the fire power used by the characters, making it a challenge for artificial intelligence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adapting to unstable terrain</h1>
                </header>
            
            <article>
                
<p>Let's decompose this example and create a character that could be used in this game. We'll start by looking at the map. At the bottom, there's water that automatically kills the worms. Then, we have the terrain where the worms can walk, or destroy if needed. Finally, there's the absence of terrain, specifically, the empty space that cannot be walked on. Then we have the characters (worms) they are placed in random positions at the beginning of the game and they can walk, jump, and shoot.</p>
<div class="CDPAlignCenter CDPAlign"><img height="467" width="389" class=" image-border" src="assets/3be1a9b4-50c8-45c5-9f68-6bfe0e1fd24d.jpg"/></div>
<p>The characters of the game should be able to constantly adapt to the instability of the terrain, so we need to use that and make it part of the behavior tree. As demonstrated in the diagram above, the character will need to understand the position where he is currently placed, as well as the opponent's position, health, and items.</p>
<p>Because the terrain can be blocking them, the AI character has a chance of being in a situation where he cannot attack or obtain an item. So, we give him options on what to do in those situations and many others that he might find, but the most important is to define what happens if he cannot successfully accomplish any of them. Because the terrain can be shaped into different forms, during gameplay there will be times that it is near impossible to do anything, and that is why we need to provide options on what to do in those situations.</p>
<div class="CDPAlignCenter CDPAlign"><img height="385" width="520" class=" image-border" src="assets/ddf44f51-de44-44f0-bf4d-9e1c409396fb.jpg"/></div>
<p>For example, in this situation where the worm doesn't have enough free space to move, a close item to pick up, or an enemy that can be properly attacked, what should he do? It's necessary to make information about the surroundings available to our character so he can make a good judgment for that situation. In this scenario, we have defined our character to shoot anyway, against the closest enemy, or to stay close to a wall. Because he is too close to the explosion that would occur from attacking the closest enemy, he should decide to stay in a corner and wait there until the next turn.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using raycast to evaluate decisions</h1>
                </header>
            
            <article>
                
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/89057d8e-dabd-4fab-90c6-727a155fc6aa.jpg"/></div>
<p>Ideally, at the start of the turn, the character has two raycasts, one for his left side and another for the right side. This will check if there's a wall obstructing one of those directions. This can be used to determine what side the character should be moving toward if he wants to protect himself from being attacked. Then, we would use another <span class="packt_screen">raycast</span> in the aim direction, to see if there's something blocking the way when the character is preparing to shoot. If there's something in the middle, the character should be calculating the distance between the two to determine if it's still safe to shoot.</p>
<p>So, each character should have a shared list of all of the worms that are currently in the game; that way they can compare the distance between them all and choose which of them are closest and shoot them. Additionally, we add the two raycasts to check if there's something blocking the sides, and we have the basic information to make the character adapt to the constant modifications of the terrain.</p>
<pre> public int HP;<br/> public int Ammunition;<br/><br/> public static List&lt;GameObject&gt; wormList = new List&lt;GameObject&gt;(); <br/> //creates a list with all the worms<br/> public static int wormCount; //Amount of worms in the game<br/> public int ID; //It's used to differentiate the worms<br/><br/> private float proximityValueX;<br/> private float proximityValueY;<br/> private float nearValue;<br/> public float distanceValue; //how far the enemy should be<br/><br/> private bool canAttack;<br/><br/> void Awake ()<br/> {<br/>         wormList.Add(gameObject); //add this worm to the list<br/>         wormCount++; //adds plus 1 to the amount of worms in the game<br/> }<br/><br/> void Start ()<br/> {<br/>         HP = 100;<br/>         distanceValue = 30f;<br/> }<br/><br/>void Update ()<br/> {<br/>         proximityValueX = wormList[1].transform.position.x - this.transform.position.x;<br/>         proximityValueY = wormList[1].transform.position.y - this.transform.position.y;<br/>         nearValue = proximityValueX + proximityValueY;<br/><br/>         if(nearValue &lt;= distanceValue)<br/>         {<br/>             canAttack = true;<br/>         }<br/><br/>         else<br/>         {<br/>             canAttack = false;<br/>         }<br/><br/>         Vector3 raycastRight = transform.TransformDirection(Vector3.forward);<br/><br/>         if (Physics.Raycast(transform.position, raycastRight, 10)) <br/>             print("There is something blocking the Right side!");<br/><br/>         Vector3 raycastLEft = transform.TransformDirection(Vector3.forward);<br/><br/>         if (Physics.Raycast(transform.position, raycastRight, -10)) <br/>             print("There is something blocking the Left side!");<br/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored different ways to interact with the environment. The techniques demonstrated in this chapter can be expanded to a wide range of game genres and used to accomplish basic to advanced interactions between the AI characters and the environment. Now we understand how to create interactive and dynamic objects that can be used by the AI characters, it will make the game a new and different experience every time we play. In addition, have lightly touched on some related topics that will be covered in depth in the next chapters, such as the interaction with other AI characters of the game and decision making.</p>
<p>In our next chapter, we'll be talking about animation behavior. Animations make up part of the visual perception that the player has of the artificially intelligent characters that we create, and it's very important to use that to demonstrate how realistic our AI behaves. We will be discussing animation graphs, gameplay and animation, animation behaviors, and animation architecture.</p>


            </article>

            
        </section>
    </body></html>