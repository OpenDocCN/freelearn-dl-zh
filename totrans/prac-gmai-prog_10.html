<html><head></head><body>
        

                            
                    <h1 class="header-title">Awareness</h1>
                
            
            
                
<p>In our last chapter, we will be looking at how we can develop AI characters that use <strong>tactics</strong> and awareness to accomplish their goals. Here we will be using everything that we have explored before, understanding how we can combine everything together to create artificial intelligent characters that can be used in stealth games or games that also rely on tactics or awareness.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stealth sub-genre</h1>
                
            
            
                
<p>Stealth games are a very popular sub-genre where the main objective of the player is to use stealth elements, being undetected by the opponents in order to complete the main goals. Even being a genre that is widely popular in military games it is possible to see this sub-genre being applied in almost any game. If we take a deep look, any game where the enemy character is triggered by noise or vision of the player, is using stealth elements. This means that at some point or another, having awareness or even tactics implemented on our AI characters can be very useful regardless of the game genre that we are working on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">About tactics</h1>
                
            
            
                
<p>The tactics is the process that the character or a group of characters take in order to achieve certain objectives. It usually means that the characters can use all of their abilities, choosing the best ones depending on the situations, to defeat the opponent. The concept of tactics in video games is to give to the AI the power of decision, making him behave smartly while trying to reach the main goal. We can compare this to the tactics that are used by the soldiers or police officers in order to catch the bad guys of the real world.</p>
<p>They have a wide array of technology and human resources to catch a bandit, but in order to accomplish that task with success they need to choose wisely what they are going to do, step by step. The same principles can be applied to our AI characters; we can make them choose the best options available in order to accomplish their objective.</p>
<p>To create this, we can use every topic that was covered before in this book and with that, we are able to develop an AI character capable of choosing the best tactic that takes down the player or achieving his goal.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">About awareness</h1>
                
            
            
                
<p>One very important aspect that correlates with the tactics is the awareness of the character. Some common factors can make part of the awareness of an AI character such as audio, vision, and perception, for example. These factors are inspired on the human features that we all have, vision, audio, touch, and perception of what is happening around us.</p>
<p>Therefore, what we are looking for is to create artificial intelligent characters that can process all of that information at the same time that they are doing other things making them aware of the surroundings, making better judgment of what decisions should be taken on that given moment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing vision awareness</h1>
                
            
            
                
<p>Before starting out with the tactics, we will take a look at how we can implement an awareness system into our characters.</p>
<p>Let's start by implementing a vision awareness into our game character. The idea is to simulate the human vision, where we can see very good at close range and not so good when something is really far away. Many games have adopted this system and they all have differences, some have a more complex system while others have a basic one. The basic example can be found especially on a more juvenile adventure game such as <em>Zelda - Ocarina of Time</em> for example, where the enemies will only appear or react when you reach a certain trigger zone as shown in the following screenshot:</p>
<div><img class=" image-border" src="img/7e634c2a-2595-451a-b6cc-c9e2a4445eac.jpg"/></div>
<p>For example, in this situation if the player goes back and exits the enemy trigger zone, the enemy will stay in an idle position, even if he is clearly able to see the player. This is a basic system of awareness and we can include it in the vision section.</p>
<p>Meanwhile, other games have developed their entire gameplay around this subject (vision awareness), where the vision range has an extremely important aspect on the gameplay itself. One of the several examples can be the Ubisoft title, Splinter Cell.</p>
<div><img class=" image-border" src="img/4c0e34f2-de5e-46c0-9652-709813e5cfc2.jpg"/></div>
<p>In this game all types of awareness systems are used, sound, vision, touch, and perception. If the player stays quiet in a shadowy area, it has less chance of being discovered than being quiet in a well-illuminated area and the same for the sound. So, for the example in the preceding screenshot, the player has approached very close to the enemy that is looking in another direction.</p>
<p>In order for the player to get this near, it was necessary to move very quietly and in the shadows. If the player was making noise or walking straight into illuminated areas, the enemy would have spotted him. This is a much more complex system than the <em>Zelda</em> game, but once again, it all depends on the game that we are creating and which system fits better on the gameplay that we are looking for. We will be demonstrating basic examples and then moving on to more advanced ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic vision detection</h1>
                
            
            
                
<p>First, we start by creating and adding a scene into our game, and then we add the player.</p>
<div><img height="390" width="694" class=" image-border" src="img/43d47bd0-21c0-4543-9e03-e731913062e0.png"/></div>
<p>We assign all the necessary codes into the player so it is possible for us to move and test the game. For this example, we have quickly assigned some basic movement information into our player, because that is the only interaction that will occur between the player and the AI character.</p>
<p class="mce-root"/>
<div><img height="346" width="613" class=" image-border" src="img/b737f4f7-884b-4436-9704-aeb9e6d8e543.png"/></div>
<p>So now, we have our character moving freely on the scene and we are ready to start working on the enemy character. We want to replicate that specific moment on the <em>Zelda</em> game, where the enemy comes from the ground when the player gets near from his position and once the player gets far away, the enemy goes back into the ground.</p>
<div><img height="420" width="747" class=" image-border" src="img/1c1e20d6-31c5-4d0d-9afc-677e27a5c4cf.png"/></div>
<p>The rabbit that we can see in the screenshot is the AI character that we have just imported into the game and now we need to define the area around him that will serve as awareness. Therefore, if the player gets near the rabbit he will detect the player and will eventually get out of his hole.</p>
<div><img class=" image-border" src="img/6d504395-bf16-4b46-ac42-99bac8e2e8ff.png"/></div>
<p>Let's say that we want the rabbit to be able to see from his hole the area that is represented by the dashed line. How can we proceed from now? We can do two things here, one is adding the trigger <kbd>Collider</kbd> into the hole object, where it will detect the player and instantiate the rabbit from the hole position, two is adding the trigger <kbd>Collider</kbd> directly to the rabbit that will be invisible (hypothetically inside the hole) and in the code we have a state for when the rabbit is inside the hole and another state for the moment when he is outside.</p>
<p>We decided for this example to use the hole as the main object for that moment where the rabbit is hiding and at the moment that the player enters the trigger area, the hole object instantiates the AI character.</p>
<div><img class=" image-border" src="img/5e3beb94-d755-4f89-be6e-9e9d28596418.png"/></div>
<p>We transformed the rabbit into a prefab, so we can instantiate it later and then we removed him from the scene. Then we have created a cube inside the game and we positioned it on the hole position. Because we don't need the hole to be visible for this example, we will be turning off the mesh from this object.</p>
<p>Creating a cube instead of an empty object allow us to better visualize the object inside the game editor in case we need to change something or simply have a notion of where we have those objects.</p>
<p>At this point, we need to make this object detect the player and so we will be adding a trigger with the dimension that we previously planned to use.</p>
<div><img class=" image-border" src="img/aa95e62c-686b-4076-8ba6-48180128656f.png"/></div>
<p>We deleted the default cube trigger that appears automatically when you create the cube and then we assigned a new sphere trigger. Why are we not using the cube trigger? We could be using the cube trigger and technically it would work too, but the covered area would be completely different from the circular area that we planned and for that reason we deleted the default trigger and assigned a new one that fits our purpose.</p>
<p>Now that we have the sphere trigger covering the area that we want, we need to make it detect the player. For this, we need to create the script that will be assigned to the cube/hole:</p>
<pre>void OnTriggerEnter (Collider other) {<br/><br/> if(other.gameObject.tag == "Player")<br/> {<br/> Debug.Log("Player Detected");<br/> } } </pre>
<p>Inside the script, we add this line of code. It is a simple trigger check for when the object gets inside the trigger area (we have used this to demonstrate previous examples). For now we simply have the trigger to check if the player gets detected using <kbd>Debug.Log("Player Detected");</kbd>. We assign this script to the cube/hole object and then we can test it.</p>
<div><img class=" image-border" src="img/9e357aff-bca8-4c18-9d77-528c9011aafc.png"/></div>
<p>If we move the player into the trigger area that we created, we can see the message Player Detected.</p>
<div><img height="38" width="257" class=" image-border" src="img/6cb7af3a-3a51-4556-8ab7-17e5b6f1a714.png"/></div>
<p>Well this is the first part of the basic example; we have the player moving around the map and the hole that is capable of detecting the player when he is near.</p>
<p>This method where we use the trigger Collider to detect something isn't directly associated with any kind of awareness because this is just the technical part, the way we use it is what will determine if this is meant to be the vision of our AI character or not.</p>
<p>Now, we can work on the rabbit, our AI character. We already have him created and set as a prefab, ready to appear in the game. So the next step is for the hole object to instantiate the rabbit, transmitting the sensation to the player that the rabbit saw him and for that reason he decided to get out of the hole. On the hole object code we update the <kbd>Player Detected</kbd> message to the <kbd>instantiate</kbd>:</p>
<pre> public GameObject rabbit;<br/> public Transform startPosition;<br/> public bool isOut;<br/><br/> void Start ()<br/> {<br/> isOut = <strong>false</strong>;<br/> }<br/><strong> void</strong> OnTriggerEnter (Collider other)<br/> {<br/><br/> if(other.gameObject.tag == "Player" &amp;&amp; isOut == false)<br/> {<br/> isOut = true;<br/> Instantiate(rabbit, startPosition.position,<br/> startPosition.rotation);<br/> }<br/> }</pre>
<p>So what we have done is define what would be the instantiated object, which in this case is the character AI <kbd>rabbit</kbd>. Then we added the <kbd>startPosition</kbd> variable that will set the position where we want the character to appear, in alternative we could also use the hole object position that would work just fine for this example. Finally, we added a simple Boolean <kbd>isOut</kbd> to prevent the hole creating more than one rabbit at the same time.</p>
<p>When the player gets inside the trigger zone, the rabbit gets instantiated and jumps out of the hole.</p>
<div><img class=" image-border" src="img/fdd9bccc-80e9-4448-8a58-6951a968870e.png"/></div>
<p>Now, we have a rabbit that jumps out of the hole when he sees the player. Our next step is to also add the same vision to the rabbit itself, but this time we want the rabbit to constantly check if the player is inside the trigger zone, this would represent that it can see the player and if the player gets away from his vision, the rabbit cannot see him anymore and returns to the hole.</p>
<p>For the AI character, we can use a wider area than the hole.</p>
<div><img class=" image-border" src="img/064e7d41-56cf-4232-9338-69760341c0df.png"/></div>
<p>So as we can see, that would be the area where the rabbit can see the player, if the player gets out of that area, the rabbit can't see the player no more.</p>
<div><img height="140" width="227" class=" image-border" src="img/e8e0c30a-b820-40c6-a666-037c85207eda.png"/></div>
<p>Once again, let's add a sphere <kbd>Collider</kbd>, but this time to the rabbit.</p>
<p>Enable the Is Trigger option in order to turn the Collider into activation zones. Otherwise it won't work.</p>
<div><img height="404" width="680" class=" image-border" src="img/078db524-bf56-4d32-ae1c-8e00a5579b24.png"/></div>
<p>This is what we have so far, the sphere <kbd>Collider</kbd> with the dimensions that we planned and ready to receive the player position information that will serve as the vision to our AI character.</p>
<p>Now, what we need to do is add to the rabbit script the portion of the code that is responsible for the trigger zone:</p>
<pre>void OnTriggerStay (Collider other) {<br/><br/> if(other.gameObject.tag == "Player")<br/> {<br/> Debug.Log("I can see the player");<br/> }<br/> } </pre>
<p>What we have here is a trigger check to see if the player continues inside the trigger zone, to do this we simply use the <kbd>OnTriggerStay</kbd>, which works perfectly to this example that we are creating.</p>
<p>We use <kbd>Debug.Log("I can see the player");</kbd> simply to test if this is working as intended.</p>
<div><img height="32" width="209" class=" image-border" src="img/ef9de8f0-baef-4eb6-a81a-150b6e9d72e5.png"/></div>
<p>We test the game and we can notice that when the player gets inside the rabbit area, we receive the console message that we wrote and this means that it is working.</p>
<p>Now, let's add the second part of the rabbit vision, where the player gets out of the trigger zone and the rabbit can't see him no more. To do this we need to add another trigger check, which will serve to check if the player already left the area:</p>
<pre>void OnTriggerStay (Collider other) {<br/><br/> if(other.gameObject.tag == "Player")<br/> {<br/> Debug.Log("I can see the player");<br/> }<br/> }<br/><br/> void OnTriggerExit (Collider other){<br/><br/> if(other.gameObject.tag == "Player")<br/> {<br/> Debug.Log("I've lost the player");<br/> }<br/> } </pre>
<p>Following is the <kbd>OnTriggerStay</kbd> that we added into the AI character code, we add some new lines of code that checks if the player has left the trigger zone. To do this we use the <kbd>OnTriggerExit</kbd> that does what the name says, checks the exit of the object that has entered the trigger zone. But to make this work we need to first set an <kbd>OnTriggerEnter</kbd>, otherwise it won't count if the player entered the zone or not, it only knows if he is there or not:</p>
<pre>void OnTriggerEnter (Collider other) {<br/><br/> if(other.gameObject.tag == "Player")<br/> {<br/> Debug.Log("I can see the player");<br/> }<br/> }<br/><br/> void OnTriggerStay (Collider other){<br/><br/> if(other.gameObject.tag == "Player")<br/> {<br/> Debug.Log("I can see the player");<br/> }<br/> }<br/><br/> void OnTriggerExit (Collider other){<br/><br/> if(other.gameObject.tag == "Player")<br/> {<br/> Debug.Log("I've lost the player");<br/> }<br/> } </pre>
<p>Now, we have the trigger counting when the player gets inside the area, when he keeps inside the area, and also the moment that he exits that same area. This represents the moment that the rabbit starts seeing the player, when he keeps seeing him, and when he loses eye contact with the player.</p>
<div><img class=" image-border" src="img/634c1045-8a71-4703-b133-88a9ce03ee0b.png"/></div>
<p>At this point, we can test the game and see if what we have done is working correctly or not. When we start the game, we can confirm that by looking at the console messages that we wrote to see if everything is working as intended.</p>
<div><img class=" image-border" src="img/e8e5353b-0612-489b-b423-d3df3180d983.png"/></div>
<p>It is normal to see a higher number on the <kbd>OnTriggerStay</kbd> function because it is constantly checking every frame for the player, so as we can see in the preceding screenshot, our AI character now has the basic vision check working.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced vision detection</h1>
                
            
            
                
<p>Now that we understand how a basic vision detection that we can find in many action/adventure games works, we can move on and take a look at the advanced vision detection that can be found in stealth games. Let's take a deep look into the <em>Metal Gear</em> game and see how the AI characters have their vision developed.</p>
<div><img height="522" width="696" class=" image-border" src="img/21de399f-a13e-485a-a98f-0bda9bc35904.png"/></div>
<p>If we take a look at this screenshot, we notice that the enemy AI cannot see the player, but the player is inside of the area where the enemy is well capable of seeing. So why doesn't the AI character turn to the player and start attacking him? Simply because the trigger area is set only to be in front of the enemy eyes.</p>
<p>For that reason, if the player is behind the enemy, he won't notice the player.</p>
<div><img height="456" width="608" class=" image-border" src="img/9376beea-2a4f-46a5-8bda-eb95074f9b10.png"/></div>
<p>As we can see in the second screenshot, everything that is in the darker area, the enemy doesn't have any way of getting information regarding the players presence, while the light area represents the vision of the character and there he can see everything that is happening. Now we will be taking a look at how we can develop a similar system into our AI characters.</p>
<p>Let's start by creating a test scenario. It can be simple cube meshes for now and later on we can change them into a better looking object.</p>
<div><img height="251" width="251" class=" image-border" src="img/a51a55a1-eaeb-486d-8ca0-677bbd014fe7.png"/></div>
<p>We have created a few cube meshes and placed them randomly on top of a plane (that will be the ground). The next step will be creating the character, we'll be using a capsule to represent the character.</p>
<div><img height="303" width="303" class=" image-border" src="img/376b44cb-3496-49c9-8d3b-d03b7687e10e.png"/></div>
<p>We can place the newly created capsule anywhere on the map. Now, we need to create some targets that will be spotted by our AI character.</p>
<div><img height="288" width="288" class=" image-border" src="img/ce7aec7e-ad9f-42ab-b59a-d7a765a111c9.png"/></div>
<p>We can distribute the target objects anywhere on the map as well. Now, we need to define two different layers, one for the obstacles and another one for the targets.</p>
<div><img height="170" width="144" class=" image-border" src="img/a2333f05-eb2a-4e4e-969a-243af5bf1a31.png"/></div>
<p>In Unity we click under the Layers button to expand more options, and then we click where it says Edit Layers....</p>
<div><img height="351" width="211" class=" image-border" src="img/159cbdd1-f4c1-4cb5-9364-ef0d3cede3f6.png"/></div>
<p>This column will open and here we can write the layers we need to create. As we can see, there's already the two layers that we need, one called Obstacles and the other called Targets. After this, we need to assign them to the objects.</p>
<div><img height="150" width="121" class=" image-border" src="img/d1e4d60e-6596-4a80-8e2f-6f4514afc08c.png"/></div>
<p>To do this we simply need to select the Obstacles objects and then click on the Layers button and choose the Obstacles layer. We also do the same for the Target objects, choosing the Targets layer.</p>
<p>The next thing to do is start adding the necessary code into our character. We will also need to add to the character a rigid body and freeze all the rotation axis demonstrated in the following screenshot:</p>
<div><img height="178" width="226" class=" image-border" src="img/fdc08b62-156b-4eb1-acc4-c700048a4268.png"/></div>
<p>Then we can create a new script for the character:</p>
<pre> public float moveSpeed = 6;<br/> <br/> Rigidbody myRigidbody;<br/> Camera viewCamera;<br/> Vector3 velocity;<br/><br/> void Start ()<br/>{<br/> myRigidbody = GetComponent&lt;Rigidbody&gt; ();<br/> viewCamera = Camera.main;<br/> }<br/><br/> void Update ()<br/>{<br/> Vector3 mousePos = viewCamera.ScreenToWorldPoint(new<br/>     Vector3(Input.mousePosition.x, Input.mousePosition.y,<br/>     viewCamera.transform.position.y));<br/> transform.LookAt (mousePos + Vector3.up * transform.position.y);<br/> velocity = new Vector3 (Input.GetAxisRaw ("Horizontal"), 0,<br/>     Input.GetAxisRaw ("Vertical")).normalized * moveSpeed;<br/> }<br/><br/> void FixedUpdate()<br/>{<br/> myRigidbody.MovePosition (myRigidbody.position + velocity *<br/> Time.fixedDeltaTime);<br/>}</pre>
<p>What we have here is the basic movement of our character, so we can test it ourselves by controlling the character to move anywhere we want to. With this done, we are able to move around the map with the character and with the mouse we can simulate the direction in which the character is looking at.</p>
<p>Now, let's work on the script that simulates the vision of our character:</p>
<pre>public float viewRadius;<br/> public float viewAngle; public Vector3 DirFromAngle(float <br/>    angleInDegrees) <br/>{<br/> } </pre>
<p>We start out with two public floats, one for the <kbd>viewRadius</kbd> and another one for <kbd>viewAngle</kbd>. Then we create a public <kbd>Vector3</kbd> called <kbd>DirFromAngle</kbd> and we want the results to be in degrees and so we will be using trigonometry to solve this.</p>
<div><img height="179" width="217" class=" image-border" src="img/1097ca5f-880c-4d4d-a98e-da65a7ebaba1.png"/></div>
<p>The preceding diagram represents the default trigonometry values in degrees, where it starts from the right side with the number zero and the values will increase in a counter-clockwise way.</p>
<div><img height="173" width="193" class=" image-border" src="img/55cfbbda-2541-4ae9-b953-ca465958f95a.png"/></div>
<p>Because we are developing this example in Unity, we need to keep in mind that the trigonometry values are in a different order, as we can see in the preceding diagram. Here, the zero number starts on the top and the value increase in a clockwise way.</p>
<p>With this information in mind, we can now proceed with the direction angle in which our character will be looking at:</p>
<pre> public float viewRadius;<br/> public float viewAngle; public Vector3 DirFromAngle(float<br/>    angleInDegrees)<br/> { <br/>   return new Vector3(Mathf.Sin(angleInDegrees *<br/>   Mathf.Deg2Rad), 0,<br/>   Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));<br/> } </pre>
<p>Now, we have the basic foundation of our exercise done, but in order to visually see it on the game editor we need to create a new script that will show the radius of the character vision:</p>
<div><img height="357" width="291" class=" image-border" src="img/e38b974d-71ae-487a-be08-dda6e03d466e.png"/></div>
<p>To do this, we go ahead and create a new folder in the project section:</p>
<div><img height="143" width="430" class=" image-border" src="img/4716b447-8e41-479b-9411-6737f25dbcfd.png"/></div>
<p>In order for the game engine to use this content that will appear in the game editor we need to name the folder as <kbd>Editor</kbd>. Everything inside this folder can be used/seen in the game editor, without clicking the play button, which can be very handy in many situations just like the one we are creating.</p>
<p>Then inside of the <kbd>Editor</kbd> folder that we just created, we create a new script that will be responsible for the visualization of the character field of view:</p>
<pre> using UnityEngine;<br/> using System.Collections;<br/> using UnityEditor; </pre>
<p>Because we want to use this script in editor mode, we need to specify that on the top of our script. To do that, we start by adding <kbd>using UnityEditor</kbd>.</p>
<p>Then after that we add one more line in which we will be connecting with the previous script we created to be able to use that in editor mode:</p>
<pre> using UnityEngine;<br/> using System.Collections;<br/> using UnityEditor;<br/><br/> [CustomEditor (typeof (FieldOfView))] </pre>
<p>And now let's work on what is going to appear on the screen to represent the field of view that we created:</p>
<pre> using UnityEngine;<br/> using System.Collections;<br/> using UnityEditor;<br/><br/> [CustomEditor (typeof (FieldOfView))]<br/> public class FieldOfViewEditor : Editor{<br/><br/> void OnSceneGUI(){<br/> FieldOfView fow = (FieldOfView)target; } } </pre>
<p>We created a <kbd>void OnSceneGUI()</kbd> and this will contain all the information that we want to be visible on our game editor. We start by adding the target of the field of view; this will get the field of view object reference:</p>
<pre> using UnityEngine;<br/> using System.Collections;<br/> using UnityEditor;<br/><br/> [CustomEditor (typeof (FieldOfView))]<br/> public class FieldOfViewEditor : Editor{<br/><br/> void OnSceneGUI(){<br/> FieldOfView fow = (FieldOfView)target; Handles.color = color.white; } } </pre>
<p>Next we define the color that we want to represent the vision of our character, to do this we added the <kbd>Handles.color</kbd> and we have chosen the color to be white. This won't be visible on the export version of our game, so we can choose the color that is easier for us to see in the editor:</p>
<pre> using UnityEngine;<br/> using System.Collections;<br/> using UnityEditor;<br/><br/> [CustomEditor (typeof (FieldOfView))]<br/> public class FieldOfViewEditor : Editor{<br/><br/> void OnSceneGUI(){<br/> FieldOfView fow = (FieldOfView)target; Handles.color = color.white;<br/> Handles.DrawWireArc (fow.transform.position, Vector3.up,<br/> Vector3.forward, 360, fow.viewRadius); } } </pre>
<p>What we have done now is give a form to the visualization that we are creating. The form is set to be in an arch and that is why we use <kbd>DrawWireArc</kbd>. Now, let's take a look at what we have done so far:</p>
<div><img height="62" width="255" class=" image-border" src="img/79738248-3fd4-45f8-9be7-5515b8cc397c.png"/></div>
<p>On the script that we created and assigned to the character, we need to change the value of View Radius to any desired value.</p>
<div><img height="402" width="508" class=" image-border" src="img/6e536add-dc73-498c-932c-f7d311bc6915.png"/></div>
<p>When increasing that value, we will notice a circle growing around the character, this means that our script is working well so far. The circle is representing the vision of our character and now let's change a few things to make it look like the <em>Metal Gear Solid</em> image that we used as a reference.</p>
<p>Let's open the character <kbd>FieldOfView</kbd> script again to add new modifications:</p>
<pre>public float viewRadius;<br/>[Range(0,360)]<br/>public float viewAngle;<br/>public Vector3 DirFromAngle(float angleInDegrees, bool angleIsGlobal)<br/> { <br/>  if(!angleIsGlobal)<br/> { <br/>  angleInDegrees += transform.eulerAngles.y;<br/> }<br/>  return new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0,<br/>  Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));<br/> } </pre>
<p>We added a range for the <kbd>viewRadius</kbd> so that way we can make sure that the circle does not surpass the <kbd>360</kbd> degrees mark. Then we added a Boolean parameter to <kbd>public Vector3 DirFromAngle</kbd> to check if the angle value is set to global, so that way we can control the direction that our character is facing.</p>
<p>Then we are going to open the <kbd>FieldOfViewEditor</kbd> script once again to add the <kbd>viewAngle</kbd> information:</p>
<pre> using UnityEngine;<br/> using System.Collections;<br/> using UnityEditor;<br/><br/> [CustomEditor (typeof (FieldOfView))]<br/> public class FieldOfViewEditor : Editor<br/>{<br/> void OnSceneGUI()<br/> {<br/>  FieldOfView fow = (FieldOfView)target;<br/>  Handles.color = color.white;<br/>  Handles.DrawWireArc (fow.transform.position, Vector3.up,<br/>  Vector3.forward, 360, fow.viewRadius);<br/>  Vector3 viewAngleA =<br/>  fow.DirFromAngle(-fow.viewAngle/2, false);<br/>  Handles.DrawLine(fow.transform.position, fow.transform.position +<br/>  viewAngleA * fow.viewRadius);<br/>  Handles.DrawLine(fow.transform.position,<br/>  fow.transform.position +<br/>  viewAngleB * fow.viewRadius);<br/> }<br/> } </pre>
<p>Now, let's test it again to see the new modifications that we have done:</p>
<div><img height="54" width="241" class=" image-border" src="img/78418ef8-559d-443d-9dff-48b02acdd1ec.png"/></div>
<p>On the <kbd>View Angle</kbd> option we are going to change the value from zero to any other to see what it is doing:</p>
<div><img height="364" width="412" class=" image-border" src="img/f7d5a8ad-8d76-4bbe-82fd-4b53cfe05133.png"/></div>
<p>Now, if we look at the circle that is around the character, we will notice a triangular shape inside. The size of that shape can be controlled precisely with the <kbd>View Angle</kbd> option, and the triangle shape represents the vision of our character, so at this moment we can notice that the character is looking slightly to the bottom right.</p>
<div><img height="329" width="332" class=" image-border" src="img/30a6878a-9e4a-40ad-9348-f841e9c96efb.png"/></div>
<p>Because we have set the angle value to be at a global angle, we can rotate the character and the view angle will follow the character rotation.</p>
<p>Now let's work on the vision raycast, this part is responsible for detecting what exists in the direction that our character is looking at. Once again, we are going to edit our <kbd>FieldOfView</kbd> script that we created for our character:</p>
<pre>public float viewRadius;<br/>[Range(0,360)]<br/>public float viewAngle;<br/>public LayerMask targetMask;<br/>public LayerMask obstacleMask;<br/>public List&lt;Transform&gt; visibleTargets = new List&lt;Transform&gt;();<br/>void FindVisibleTargets ()<br/> {<br/>  visibleTargets.Clear ();<br/>  Collider[] targetInViewRadius =<br/>  Physics.OverlapSphere(transform.position, viewRadius, targetMask);      <br/>   for (int i = 0; i &lt; targetsInViewRadius.Length; i++)<br/>   {<br/>   Transform target = targetInViewRadius [i].transform; Vector3<br/>    dirToTarget = (target.position - transform.position).normalized;<br/>   if (Vector3.Angle (transform.forward, dirToTarget) &lt; viewAngle / 2)<br/>    {<br/>      float dstToTarget = Vector3.Distance (transform.position,<br/>       target.position); <br/>      if (!Physics.Raycast(transform.position,<br/>       dirToTarget, dstToTarget, obstacleMask))<br/>           { <br/>             visibleTargets.Add (target);<br/>            } <br/>   }<br/> }<br/> public Vector3 DirFromAngle(float angleInDegrees, bool angleIsGlobal) {<br/>  if(!angleIsGlobal) <br/>     { <br/>       angleInDegrees += transform.eulerAngles.y;<br/>     }  <br/>  return new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0,<br/>     Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));<br/>} </pre>
<p>What we have done here, is add the <kbd>Physics</kbd> information into our script, detecting only the objects that can be found inside of the character <kbd>View Angle</kbd>. To check if something is in sight of our character, we use a <kbd>Raycast</kbd> to check if any object with the layer <kbd>obstacleMask</kbd> is detected. Now let's create an <kbd>IEnumerator</kbd> function to implement a small delay for our character detecting new obstacles:</p>
<pre>public float viewRadius; [Range(0,360)]<br/>public float viewAngle; public LayerMask targetMask; <br/>public LayerMask obstacleMask; <br/>[HideInInspector] public List&lt;Transform&gt; visibleTargets = new List&lt;Transform&gt;(); <br/>void Start () <br/>    { <br/>     StartCoroutine("FindTargetsWithDelay", .2f); <br/>    } <br/>IEnumerator FindTargetsWithDelay(float delay) <br/>{ <br/>while (true) {<br/> yield return new WaitForSeconds (delay);<br/> FindVisibleTargets ();<br/> } <br/>} <br/>void FindVisibleTargets ()<br/> { <br/> visibleTargets.Clear ();<br/> Collider[] targetInViewRadius<br/> =Physics.OverlapSphere(transform.position,viewRadius, targetMask);<br/> <br/>for (int i = 0; i &lt; targetsInViewRadius.Length; i++) <br/>{<br/> Transform target = targetInViewRadius [i].transform; Vector3 dirToTarget = (target.position - transform.position).normalized;<br/> if (Vector3.Angle (transform.forward, dirToTarget) &lt; viewAngle / 2) { float dstToTarget = Vector3.Distance (transform.position, target.position);<br/> if (!Physics.Raycast(transform.position, dirToTarget, dstToTarget,<br/>     obstacleMask))<br/> {<br/>  visibleTargets.Add (target);<br/> }<br/> }<br/> }<br/> public Vector3 DirFromAngle(float angleInDegrees, bool angleIsGlobal)         { <br/>if(!angleIsGlobal)<br/> {<br/> angleInDegrees += transform.eulerAngles.y;<br/> }<br/> return new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0,<br/> Mathf.Cos(angleInDegrees * Mathf.Deg2Rad)); } </pre>
<p>Now that, we have created an <kbd>IEnumerator</kbd>, the character has a small reaction time that in this case is set to <kbd>.2f</kbd> to find targets inside of his vision zone. In order to test this we need to make some new modifications inside of our <kbd>FieldOfViewEditor</kbd> script. So let's open it and add a few new lines of code:</p>
<pre> using UnityEngine;<br/> using System.Collections;<br/> using UnityEditor;<br/><br/> [CustomEditor (typeof (FieldOfView))]<br/> public class FieldOfViewEditor : Editor{<br/><br/> void OnSceneGUI(){<br/> FieldOfView fow = (FieldOfView)target;<br/> Handles.color = color.white; Handles.DrawWireArc<br/> (fow.transform.position, Vector3.up,<br/> Vector3.forward, 360, fow.viewRadius); Vector3 viewAngleA =<br/> fow.DirFromAngle(-fow.viewAngle/2, false);<br/><br/> Handles.DrawLine(fow.transform.position, fow.transform.position +<br/> viewAngleA * fow.viewRadius);<br/> Handles.DrawLine(fow.transform.position,fow.transform.position +<br/> viewAngleB * fow.viewRadius); Handles.color = Color.red;<br/> Foreach (Transform visibleTarget in fow.visibleTargets)<br/> { <br/> Handles.DrawLine(fow.transform.position, visibleTarget.position);<br/> }<br/> }<br/> } </pre>
<p>With the new modifications on the code, we should be able to see when the character has detected an obstacle and when that obstacle get out of his vision zone.</p>
<div><img height="94" width="189" class=" image-border" src="img/4398190c-ffd9-48e9-b252-338b396fc9ac.png"/></div>
<p>To test this out we first need to select all the obstacles that we have inside of our game:</p>
<div><img height="143" width="115" class=" image-border" src="img/4dff5f35-6ed4-41f5-a130-5060fd93419d.png"/></div>
<p>Then assign them the Obstacles layer:</p>
<div><img height="122" width="195" class=" image-border" src="img/9415dad8-b0fc-4f0f-867a-0341fd843eba.png"/></div>
<p>We also need to select all of the Targets inside of the game:</p>
<div><img height="134" width="104" class=" image-border" src="img/5845b7ee-386c-4923-a4fe-d6afca4fd8b6.png"/></div>
<p>We then assign them the Targets layer. This step is very important so that our Raycast can identify what is inside of the character field of view. Now, let's click on the character object and define which layer represents the Targets and which layer represents the Obstacles:</p>
<div><img height="27" width="276" class=" image-border" src="img/f7df547b-b1e7-401b-a477-1f85a1881182.png"/></div>
<p>We go to the Layer Mask option that can be found in the Field Of View script options:</p>
<div><img height="147" width="110" class=" image-border" src="img/37a177a9-443e-4d69-bb69-ced606aa47fd.png"/></div>
<p>And we choose the Targets layer:</p>
<div><img height="30" width="302" class=" image-border" src="img/b0ba92b9-9c58-466b-899e-4b6b23d5108e.png"/></div>
<p>Then we go to the Obstacles option:</p>
<div><img height="155" width="116" class=" image-border" src="img/1289f14d-ed96-4f32-9b76-8335278b63af.png"/></div>
<p>And we choose the Obstacles layer.</p>
<p>With this part done we can finally test the exercise to see what happens when the character finds a target.</p>
<div><img height="461" width="738" class=" image-border" src="img/ac684402-40d5-4e88-b964-3beede2eaa5a.png"/></div>
<p>When playing the exercise, we can see that a red line appears connecting the character and the target, when a target gets inside of the vision zone. This represents that our character has spotted an enemy for example.</p>
<div><img height="480" width="768" class=" image-border" src="img/b681cc3a-af97-4dda-817b-a3e19420e60e.png"/></div>
<p>But, when we move our character and we have an obstacle in front of a target, even if the target is inside the vision zone, the character cannot detect him because there is an object in front of him blocking his view. This is why we need to assign the Obstacle layer to every object that might block the character vision, that way he won't have any X-Ray vision.</p>
<div><img height="493" width="789" class=" image-border" src="img/46329859-33d4-4704-8634-40ebc544b164.png"/></div>
<p>We can also point our character to two targets that both of them will connect to, this means that our character is also able to detect more than one target at the same time, which is very useful to define better strategies and tactics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Realistic field of view effect</h1>
                
            
            
                
<p>Now that we have the vision detection working, we can move on to the next step and add a realistic field of view effect. This will allow the character to have peripheral vision, making what is seen on the sides less detailed and what is seen in the front more detailed. It is a simulation of our real human vision, where we tend to focus more on what is in front of us and if we need to check something that is on the sides, we need to turn into that direction in order to have a better look.</p>
<p>Let's start by opening our <kbd>FieldOfView</kbd> script. Then we add a new float variable called <kbd>meshResolution</kbd>:</p>
<pre>public float viewRadius; [Range(0,360)]<br/>public float viewAngle; public LayerMask targetMask; public LayerMask obstacleMask; [HideInInspector] public List&lt;Transform&gt; visibleTargets = new List&lt;Transform&gt;(); public float meshResolution; </pre>
<p>Now, we need to create a new method and we are going to call it <kbd>DrawFieldOfView</kbd>. Inside of this method, we will define the amount of <kbd>Raycast</kbd> lines that our field of view will have. Also we will define the angle of each line that will be drawn:</p>
<pre>void DrawFieldOfView() {<br/> int stepCount = Mathf.RoundToInt(viewAngle * meshResolution);<br/> float stepAngleSize = viewAngle / stepCount;<br/> for (int i = 0; i &lt;= stepCount; i++) {<br/> float angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;Debug.DrawLine (transform.position, transform.position + DirFromAngle (angle, true) * viewRadius, Color.red);<br/> }<br/> }</pre>
<p>After creating this new method, we simply need to call it from the update:</p>
<pre> void LateUpdate() {<br/> DrawFieldOfView ();<br/> } </pre>
<p>At this point, we can open the game editor and test it to visualize what we have created:</p>
<div><img height="339" width="580" class=" image-border" src="img/f630c4ad-fc30-417f-a05e-2f1eccffc35e.png"/></div>
<p>Right away when we press play to test our script, we won't see any difference between the old version and the new one. This is normal because we need to increase the Mesh Resolution of our character.</p>
<div><img height="117" width="244" class=" image-border" src="img/fbeb3b37-d971-4b52-aec0-de7e0f2652bb.png"/></div>
<p>As we can see in the preceding screenshot, we need to add a value in the Mesh Resolution variable in order to see the desirable results.</p>
<div><img height="316" width="432" class=" image-border" src="img/a9f5c71a-1b2d-4b44-b89a-38acc21c00d3.png"/></div>
<p>Adding 0.08 into the Mesh Resolution variable, we can notice already that on the game editor window, a few red lines appear and that's exactly what we wanted.</p>
<p>If we keep increasing the value, more lines will be added, meaning that more detailed the vision will be, which is exemplified in the following screenshot:</p>
<div><img height="282" width="476" class=" image-border" src="img/3b826825-f63f-4f31-a0cd-afcf2658e88c.png"/></div>
<p>But, we need to remember that increasing this value also increases the device CPU usage and we need to take this into consideration, especially if we are going to have multiple characters at once on the screen.</p>
<p>Now let's get back to our script and add a collision detection for each line, allowing our character to receive information from multiple lines at once. We start by creating a new method in which we will store all the information regarding the raycasts that will be created:</p>
<pre> public struct ViewCastInfo {<br/> public bool hit;<br/> public Vector3 point;<br/> public float dst;<br/> public float angle;<br/><br/> public ViewCastInfo(bool _hit, Vector3 _point, float _dst, float<br/> _angle) {<br/> hit = _hit;<br/> point = _point;<br/> dst = _dst;<br/> angle = _angle;<br/> } } </pre>
<p>Once this new method is created we can go back to our <kbd>DrawFieldOfView()</kbd> method and start adding the raycasts that will detect the collisions for each line:</p>
<pre> void DrawFieldOfView() {<br/> int stepCount = Mathf.RoundToInt(viewAngle * meshResolution);<br/> float stepAngleSize = viewAngle / stepCount;<br/> List&lt;Vector3&gt; viewPoints = new List&lt;Vector3&gt;();<br/> for (int i = 0; i &lt;= stepCount; i++)<br/> {<br/>  float angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize<br/>  * i;<br/>  ViewCastInfo newViewCast = ViewCast(angle);<br/>  Debug.DrawLine(transform.position, transform.position +<br/>  DirFromAngle(angle, true) * <br/>  viewRadius, Color.red);<br/>  viewPoints.Add(newViewCast.point); <br/> }<br/> }</pre>
<p>To understand the next steps, let's see how a mesh is generated from a script:</p>
<div><img height="237" width="347" class=" image-border" src="img/8e577532-6cde-4c04-a4bc-f0b619d54ea6.jpg"/></div>
<p>In the preceding diagram, we can see one dark circle that represents the character and four with circles, representing the raycast finish position.</p>
<div><img height="217" width="317" class=" image-border" src="img/bd643b69-4fe1-405d-8f2b-bc3af4098046.jpg"/></div>
<p>Each vertices has a value assigned to them, the first vertex that starts from the character, is the number zero, then it goes on a clockwise sense with the next vertex starting on the left and continuing counting to the right side.</p>
<div><img height="216" width="316" class=" image-border" src="img/3d80f535-0054-421d-ac84-5a3c7a2fa642.jpg"/></div>
<p>The vertex zero connects to the vertex <strong>1</strong>.</p>
<div><img height="201" width="294" class=" image-border" src="img/3b28398f-7ccc-4f4a-89b9-85a9088a81eb.jpg"/></div>
<p>Then vertex one connects to vertex <strong>2</strong>.</p>
<div><img height="207" width="303" class=" image-border" src="img/7c1ce432-df92-4de6-aa0b-3ea4eb7ad587.jpg"/></div>
<p>And then vertex two connects back to vertex <strong>0</strong>, creating a triangle mesh.</p>
<div><img height="223" width="326" class=" image-border" src="img/fd33acfe-727d-4d67-9b79-e5912f4fb855.jpg"/></div>
<p>Once the first triangle mesh is created, it continues to the next one, starting from <em>0 &gt; 2 &gt; 3 &gt; 0</em> and the second triangle is also created. And finally the last one, <em>0 &gt; 3 &gt; 4 &gt; 0</em>. Now, we want to transcribe this information into our code, so in this case the array of the field of view is:</p>
<p><kbd><a>[0,1,2,0,2,3,0,3,4]</a></kbd></p>
<p>The total number of vertices on this example is five:</p>
<p><kbd>v = 5</kbd></p>
<p>The total number of triangles created is three:</p>
<p><kbd>t = 3</kbd></p>
<p>So the number of triangles is:</p>
<p><kbd>t = v-2</kbd></p>
<p>That means that the length of our array will be:</p>
<p><kbd>(v-2)*3</kbd></p>
<p>Now let's get back to our script and add the information that we have solved here:</p>
<pre>void DrawFieldOfView() {<br/>int stepCount = Mathf.RoundToInt(viewAngle * meshResolution);<br/>float stepAngleSize = viewAngle / stepCount;<br/> List&lt;Vector3&gt; viewPoints = new List&lt;Vector3&gt; ();<br/> ViewCastInfo oldViewCast = new ViewCastInfo ();<br/>for (int i = 0; i &lt;= stepCount; i++) {<br/>float angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;<br/> ViewCastInfo newViewCast = ViewCast (angle);<br/> Debug.DrawLine(transform.position, transform.position + DirFromAngle(angle, true) * viewRadius, Color.red);<br/> viewPoints.Add (newViewCast.point);<br/> }<br/><br/>int vertexCount = viewPoints.Count + 1;<br/> Vector3[] vertices = new Vector3[vertexCount];<br/>int[] triangles = newint[(vertexCount-2) * 3];<br/><br/> vertices [0] = Vector3.zero;<br/>for (int i = 0; i &lt; vertexCount - 1; i++) {<br/> vertices [i + 1] = viewPoints [i];<br/><br/>if (i &lt; vertexCount - 2) {<br/> triangles [i * 3] = 0;<br/> triangles [i * 3 + 1] = i + 1;<br/> triangles [i * 3 + 2] = i + 2;<br/> }<br/> } } </pre>
<p>Now, let's go to the top of our script and add two new variables, <kbd>public MeshFilter viewMeshFilter</kbd> and <kbd>Mesh viewMesh</kbd>:</p>
<pre>publicfloat viewRadius;<br/> [Range(0,360)]<br/>publicfloat viewAngle;<br/><br/>public LayerMask targetMask;<br/>public LayerMask obstacleMask;<br/><br/> [HideInInspector]<br/>public List&lt;Transform&gt; visibleTargets = new List&lt;Transform&gt;();<br/><br/>publicfloat meshResolution;<br/><br/>public MeshFilter viewMeshFilter;<br/> Mesh viewMesh; </pre>
<p>Next, we need to call those variables into our start method:</p>
<pre> void Start() {<br/> viewMesh = new Mesh ();<br/> viewMesh.name = "View Mesh";<br/> viewMeshFilter.mesh = viewMesh;<br/><br/> StartCoroutine ("FindTargetsWithDelay", .2f);<br/> } </pre>
<div><img height="94" width="167" class=" image-border" src="img/95763e1f-765a-4c97-aa1b-254e556b4080.png"/></div>
<p>The next step is to select our Character object inside the game editor:</p>
<div><img height="153" width="138" class=" image-border" src="img/9a9b1fb9-0d47-4921-8bdf-3fd1e66b0eb8.png"/></div>
<p>Go to the GameObejct section and select Create Empty Child:</p>
<div><img height="38" width="239" class=" image-border" src="img/4c1a9279-a634-46f5-9c9f-e509234a12a7.png"/></div>
<p>Rename the object to View Visualization.</p>
<div><img height="197" width="225" class=" image-border" src="img/7c219883-29ed-4ef9-a3b0-106a78f48dc9.png"/></div>
<p>With the same object selected, we go to: Component | Mesh | Mesh Filter, to add a mesh filter to our object.</p>
<div><img height="231" width="265" class=" image-border" src="img/123ea51a-f0c6-4ebf-81ed-cdccaca7b551.png"/></div>
<p>Then we need to do the same for the Mesh Renderer, Component | Mesh | Mesh Renderer.</p>
<div><img height="122" width="243" class=" image-border" src="img/d592e1a7-f96e-45d3-a88a-53c5a9d43da9.png"/></div>
<p>We can turn off the Cast Shadows and Receive Shadows.</p>
<div><img height="119" width="226" class=" image-border" src="img/0ce28d17-f2cb-4d11-9753-e19552e3c95e.png"/></div>
<p>Finally, we add the object that we just created into our script variable View Mesh Filter and change the Mesh Resolution to any desirable value, in this case we have chosen 1.</p>
<p>Now, we can return to our script and add edit once again the <kbd>DrawFieldOfView</kbd> method:</p>
<pre>void DrawFieldOfView() {<br/>int stepCount = Mathf.RoundToInt(viewAngle * meshResolution);<br/>float stepAngleSize = viewAngle / stepCount;<br/> List&lt;Vector3&gt; viewPoints = new List&lt;Vector3&gt; ();<br/> ViewCastInfo oldViewCast = new ViewCastInfo ();<br/>for (int i = 0; i &lt;= stepCount; i++) {<br/>float angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;<br/> ViewCastInfo newViewCast = ViewCast (angle);<br/> viewPoints.Add (newViewCast.point);<br/> }<br/><br/>int vertexCount = viewPoints.Count + 1;<br/> Vector3[] vertices = new Vector3[vertexCount];<br/>int[] triangles = newint[(vertexCount-2) * 3];<br/><br/> vertices [0] = Vector3.zero;<br/>for (int i = 0; i &lt; vertexCount - 1; i++) {<br/> vertices [i + 1] = viewPoints [i];<br/><br/>if (i &lt; vertexCount - 2) {<br/> triangles [i * 3] = 0;<br/> triangles [i * 3 + 1] = i + 1;<br/> triangles [i * 3 + 2] = i + 2;<br/> }<br/> }<br/><br/> viewMesh.Clear ();<br/><br/> viewMesh.vertices = vertices;<br/> viewMesh.triangles = triangles;<br/> viewMesh.RecalculateNormals ();<br/> } </pre>
<p>Let's test the game, to see what we have done here:</p>
<div><img height="334" width="335" class=" image-border" src="img/66995580-5e1c-475e-8e8e-a6093f2f6952.png"/></div>
<p>When we play the game, we will notice the mesh being rendered on the game and that's our objective so far.</p>
<p>Remember to remove the <kbd>Debug.DrawLine</kbd> line of code, otherwise the mesh won't show on the game editor.</p>
<p>In order to optimize the visualization, we need to change the <kbd>viewPoints</kbd> from global to local space points. To do this we are going to use <kbd>InverseTransformPoint</kbd>:</p>
<pre>void DrawFieldOfView() {<br/>int stepCount = Mathf.RoundToInt(viewAngle * meshResolution);<br/>float stepAngleSize = viewAngle / stepCount;<br/> List&lt;Vector3&gt; viewPoints = new List&lt;Vector3&gt; ();<br/> ViewCastInfo oldViewCast = new ViewCastInfo ();<br/>for (int i = 0; i &lt;= stepCount; i++) {<br/>float angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;<br/> ViewCastInfo newViewCast = ViewCast (angle);<br/> viewPoints.Add (newViewCast.point);<br/> }<br/><br/>int vertexCount = viewPoints.Count + 1;<br/> Vector3[] vertices = new Vector3[vertexCount];<br/>int[] triangles = newint[(vertexCount-2) * 3];<br/><br/> vertices [0] = Vector3.zero;<br/>for (int i = 0; i &lt; vertexCount - 1; i++) {<br/> vertices [i + 1] = transform.InverseTransformPoint(viewPoints [i]) + Vector3.forward * maskCutawayDst;<br/><br/>if (i &lt; vertexCount - 2) {<br/> triangles [i * 3] = 0;<br/> triangles [i * 3 + 1] = i + 1;<br/> triangles [i * 3 + 2] = i + 2;<br/> }<br/> }<br/><br/> viewMesh.Clear ();<br/><br/> viewMesh.vertices = vertices;<br/> viewMesh.triangles = triangles;<br/> viewMesh.RecalculateNormals (); }<strong> </strong> </pre>
<p>Now, if we test it again it will be more accurate.</p>
<div><img height="306" width="308" class=" image-border" src="img/8b85c7e6-45b2-4d6d-8112-5dbd61cf1c9e.png"/></div>
<p>It looks good already, but we can still improve it by changing from <kbd>Update</kbd> to <kbd>LateUpdate</kbd>:</p>
<pre> void LateUpdate() {<br/> DrawFieldOfView ();<br/> } </pre>
<p>Doing this the movement of our mesh will be smoother.</p>
<div><img height="301" width="303" class=" image-border" src="img/3c05259b-0101-4e75-83f9-93d968b1c1da.png"/></div>
<p>With this part of the script updated, we conclude our example, completing a realistic field of view system into our character.</p>
<div><img height="128" width="226" class=" image-border" src="img/06eb7e13-eeb5-4708-9ec3-db14387c3f68.png"/></div>
<p>All we need is to change the values in order to fit the results that we are looking for, making our character more or less aware of his surroundings.</p>
<div><img height="275" width="489" class=" image-border" src="img/a5b0af90-f822-48c7-acc6-fde42381d24c.png"/></div>
<p>For example, if we set the <kbd>View Angle</kbd> value to <kbd>360</kbd>, that makes our character completely aware of what is happening around and if we decrease the value, we will reach a more realistic vision, just like it's used in a <em>Metal Gear Solid</em> game.</p>
<div><img height="446" width="594" class=" image-border" src="img/33e412a2-e599-4054-a96f-d385b03c160a.png"/></div>
<p>At this point we are able to pick a stealth game and copy their most iconic features such as realistic vision and audio awareness. We have learned the foundations and now we can start from there and develop our own game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we unveiled how stealth games work and how we can recreate that same system so we can use it in our games. We went from a simple approach to a complex one, allowing us to decide what fits better in the game that we are creating, if it relies heavily on stealth or if we simply need a basic system to make our character detect the player by vision or audio awareness. The features that we have learned in this chapter can also be expanded and used in practically any example that we have created before, amplifying the collision detection, the pathfinding, the decisions, animations, and many more features, turning them from functional to realistic.</p>
<p>The way we create games is constantly updating, every game published brings a new or different method to create something, which is only possible if we are willing to experiment and blend everything we know, adjusting our knowledge to achieve the results we want to even if they look extremely complicated. Sometimes it is just a matter of exploring basic concepts and expanding them, turning a simple idea into a complex system.</p>


            

            
        
    </body></html>