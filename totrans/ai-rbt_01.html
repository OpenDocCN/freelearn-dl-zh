<html><head></head><body>
<div id="_idContainer016">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">The Foundation of Robotics and Artificial Intelligence</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this book, I invite you to go on a journey with me to discover how to add </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Artificial Intelligence</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">AI</span></strong><span class="koboSpan" id="kobo.7.1">) to a</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.8.1"> mobile robot. </span><span class="koboSpan" id="kobo.8.2">The basic difference between what I will </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.9.1">call an </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">AI robot</span></strong><span class="koboSpan" id="kobo.11.1"> and a more </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">regular robot</span></strong><span class="koboSpan" id="kobo.13.1"> is the</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.14.1"> ability of the robot and its software to make decisions and to learn and adapt to its environment based on data from its sensors. </span><span class="koboSpan" id="kobo.14.2">To be a bit more specific, we are leaving the world of pre-coded robot design behind. </span><span class="koboSpan" id="kobo.14.3">Instead of programming all of the robot’s behaviors in advance, the robot, or more correctly, the robot software, will learn from examples we provide, or from interacting with the outside world. </span><span class="koboSpan" id="kobo.14.4">The robot software will not control its behavior as much as the data that we use to train the AI </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">system will.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">The AI robot will use its learning process to make predictions about the environment and how to achieve goals, and then use those predictions to create behavior. </span><span class="koboSpan" id="kobo.16.2">We will be trying out several forms of AI on our journey, including supervised and unsupervised learning, reinforcement learning, neural networks, and genetic algorithms. </span><span class="koboSpan" id="kobo.16.3">We will create a digital robot assistant that can talk and understand commands (and tell jokes), and we will create an </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">Artificial Personality</span></strong><span class="koboSpan" id="kobo.18.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.19.1">AP</span></strong><span class="koboSpan" id="kobo.20.1">) for our robot. </span><span class="koboSpan" id="kobo.20.2">We will learn how to teach our robot to navigate without a map, grasp objects by trial and error, and see in </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">three dimensions.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">key topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">The basic principles of robotics </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">and AI</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">What is AI and autonomy (and what is </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">it not)?</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Are recent developments in AI </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">anything new?</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">a robot?</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Introducing our </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">sample problem</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">When do you need AI for </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">your robot?</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Introducing the robot and our </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">development environment</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.38.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.39.1">The technical requirements for completing the tasks in this chapter are described in the </span><em class="italic"><span class="koboSpan" id="kobo.40.1">Preface</span></em><span class="koboSpan" id="kobo.41.1"> at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">All of the code for this book is available on the GitHub repository, available </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">at </span></span><a href="https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/"><span class="No-Break"><span class="koboSpan" id="kobo.45.1">https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.46.1">.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.47.1">The basic principle of robotics and AI</span></h1>
<p><span class="koboSpan" id="kobo.48.1">AI applied to </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">robotics development</span></strong><span class="koboSpan" id="kobo.50.1"> requires</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.51.1"> a different set of skills from </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.52.1">you, the</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.53.1"> robot designer or developer. </span><span class="koboSpan" id="kobo.53.2">You may have made robots before. </span><span class="koboSpan" id="kobo.53.3">You probably have a quadcopter or a 3D printer (which is, in fact, a robot). </span><span class="koboSpan" id="kobo.53.4">The familiar</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.54.1"> world of </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">Proportional-Integral-Derivative</span></strong><span class="koboSpan" id="kobo.56.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.57.1">PID</span></strong><span class="koboSpan" id="kobo.58.1">) controllers, sensor loops, and state machines is augmented by </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Artificial Neural Networks</span></strong><span class="koboSpan" id="kobo.60.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.61.1">ANNs</span></strong><span class="koboSpan" id="kobo.62.1">), expert systems, genetic algorithms, and searching path planners. </span><span class="koboSpan" id="kobo.62.2">We want a robot that does not just react to its environment as a reflex action but has goals and intent – and can learn and adapt to the environment and is taught or trained rather than programmed. </span><span class="koboSpan" id="kobo.62.3">Some of the problems we can solve this way would be difficult, intractable, or </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">impossible otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">What we are going to do in this book is introduce a problem – picking up toys in a playroom – that we will use as our example throughout the book as we learn a series of techniques for applying AI to our robot. </span><span class="koboSpan" id="kobo.64.2">It is important to understand that, in this book, the journey is far more important than the destination. </span><span class="koboSpan" id="kobo.64.3">At the end of the book, you should have gained some important skills with broad applicability, not just learned how to pick </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">up toys.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">What we are going to do is first provide some tools and background to match the infrastructure that was used to develop the examples in the book. </span><span class="koboSpan" id="kobo.66.2">This is both to provide an even playing field and to not assume any practical knowledge on your part. </span><span class="koboSpan" id="kobo.66.3">To execute some of the advanced neural networks that we are going to build, we will use the GPUs in </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the Jetson.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">In the rest of this chapter, we will discuss some basics about robotics and AI, and then proceed to develop two important tools that we will use in all of the examples in the rest of the book. </span><span class="koboSpan" id="kobo.68.2">We will introduce the concept of soft real-time control, and then provide a </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.69.1">framework, or </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.70.1">model, for creating autonomy for our robot</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.71.1"> called the </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Observe-Orient-Decide-Act</span></strong><span class="koboSpan" id="kobo.73.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.74.1">OODA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">) loop.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.76.1">What is AI and autonomy (and what is it not)?</span></h1>
<p><span class="koboSpan" id="kobo.77.1">What would</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.78.1"> be the definition of AI? </span><span class="koboSpan" id="kobo.78.2">In general, it means a machine that</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.79.1"> exhibits some characteristics of intelligence – thinking, reasoning, planning, learning, and adapting. </span><span class="koboSpan" id="kobo.79.2">It can also mean a software program that can simulate thinking or reasoning. </span><span class="koboSpan" id="kobo.79.3">Let’s try some examples: a robot that avoids obstacles by simple rules (if the obstacle is to the right, go left) is not AI. </span><span class="koboSpan" id="kobo.79.4">A program that learns, by example, to recognize a cat in a video is AI. </span><span class="koboSpan" id="kobo.79.5">A robot arm that is operated by a joystick does not use AI, but a robot arm that adapts to different objects in order to pick them up is an application </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">of AI.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">There are two defining characteristics of AI robots that you must be aware of. </span><span class="koboSpan" id="kobo.81.2">First of all, AI robots are primarily </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">trained</span></strong><span class="koboSpan" id="kobo.83.1"> to perform tasks, by providing examples, rather than being programmed step by step. </span><span class="koboSpan" id="kobo.83.2">For example, we will teach the robot’s software to recognize toys – things we want it to pick up – by training a neural network with examples of what toys look like. </span><span class="koboSpan" id="kobo.83.3">We will provide a training set of pictures with the toys in the images. </span><span class="koboSpan" id="kobo.83.4">We will specifically annotate what parts of the images are toys, and the robot will learn from that. </span><span class="koboSpan" id="kobo.83.5">Then we will test the robot to see that it learned what we wanted it to, somewhat like a teacher would test a student. </span><span class="koboSpan" id="kobo.83.6">The second characteristic is </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">emergent behavior</span></strong><span class="koboSpan" id="kobo.85.1">, in </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.86.1">which the robot exhibits evolving actions that were not explicitly programmed into it. </span><span class="koboSpan" id="kobo.86.2">We provide the robot with controlling software that is inherently non-linear and self-organizing. </span><span class="koboSpan" id="kobo.86.3">The robot may suddenly exhibit some bizarre or unusual reaction to an event or situation that might appear to be odd, quirky, or even emotional. </span><span class="koboSpan" id="kobo.86.4">I worked with a self-driving car that we swore had delicate sensibilities and moved very daintily, earning it the nickname </span><em class="italic"><span class="koboSpan" id="kobo.87.1">Ferdinand</span></em><span class="koboSpan" id="kobo.88.1">, after the sensitive, flower-loving bull from a cartoon, which was strange in a nine-ton truck that appeared to like plants. </span><span class="koboSpan" id="kobo.88.2">These behaviors are just caused by interactions of the various software components and control algorithms and do not represent anything more </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">than that.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">One concept you will hear in AI circles is the </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">Turing test</span></strong><span class="koboSpan" id="kobo.92.1">. </span><span class="koboSpan" id="kobo.92.2">The Turing test was proposed by Alan Turing in 1950, in a paper entitled </span><em class="italic"><span class="koboSpan" id="kobo.93.1">Computing Machinery and Intelligence</span></em><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">He postulated that a human interrogator would question a hidden, unseen AI system, along with another human. </span><span class="koboSpan" id="kobo.94.3">If the human posing the questions was unable to tell which person was the computer and which was the human, then that AI computer would pass the test. </span><span class="koboSpan" id="kobo.94.4">This test supposes that the AI would be fully capable of listening to a conversation, understanding the content, and giving the same sort of answers a person would. </span><span class="koboSpan" id="kobo.94.5">Current </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">AI chatbots</span></strong><span class="koboSpan" id="kobo.96.1"> can </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.97.1">easily pass the Turing test and you may have interacted several times this week with AI on the phone without </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">realizing it.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">One group from the </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Association for the Advancement of Artificial Intelligence</span></strong><span class="koboSpan" id="kobo.101.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.102.1">AAAI</span></strong><span class="koboSpan" id="kobo.103.1">) proposed</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.104.1"> that a more suitable test for AI might be the assembly of flatpack furniture – using the supplied instructions. </span><span class="koboSpan" id="kobo.104.2">However, to date, no robot has passed </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">this test.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">Our objective in this book is not to pass the Turing test, but rather to take some novel approaches to solving problems using techniques in machine learning, planning, goal seeking, pattern recognition, grouping, and clustering. </span><span class="koboSpan" id="kobo.106.2">Many of these problems would be very difficult to solve any other way. </span><span class="koboSpan" id="kobo.106.3">AI software that could pass the Turing test would be an</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.107.1"> example of </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">general AI</span></strong><span class="koboSpan" id="kobo.109.1">, or a full, working intelligent artificial brain, and, just like you, general AI does not need to be specifically trained to solve any particular problem. </span><span class="koboSpan" id="kobo.109.2">To date, general AI has not been created, but what we do have is </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">narrow AI</span></strong><span class="koboSpan" id="kobo.111.1"> or </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.112.1">software that simulates thinking in a very narrow application, such as recognizing objects, or picking good stocks </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">to buy.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">While we are </span><em class="italic"><span class="koboSpan" id="kobo.115.1">not</span></em><span class="koboSpan" id="kobo.116.1"> building general AI in this book, that means we are not going to be worried about our creations developing a mind of their own or getting out of control. </span><span class="koboSpan" id="kobo.116.2">That comes from the</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.117.1"> realm</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.118.1"> of science fiction and bad movies, rather than the reality of computers today. </span><span class="koboSpan" id="kobo.118.2">I am firmly of the mind that anyone preaching about the </span><em class="italic"><span class="koboSpan" id="kobo.119.1">evils</span></em><span class="koboSpan" id="kobo.120.1"> of AI or predicting that robots will take over the world has likely not seen the dismal state of AI research in terms of solving general problems or creating something resembling </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">actual intelligence.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.122.1">Are recent developments in AI anything new?</span></h1>
<p><em class="italic"><span class="koboSpan" id="kobo.123.1">What has been is what will be, and what has been done is what will be done, and there is nothing new under the sun – Ecclesiastes 1:9, King </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.124.1">James Bible</span></em></span></p>
<p><span class="koboSpan" id="kobo.125.1">The modern</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.126.1"> practice of AI is not new. </span><span class="koboSpan" id="kobo.126.2">Most of these techniques were developed in the 1960s and 1970s and fell out of favor because the computing machinery of the day was insufficient for the complexity of software or the number of calculations required. </span><span class="koboSpan" id="kobo.126.3">They only waited for computers to get bigger and for another very significant event – the invention of the </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">internet</span></strong><span class="koboSpan" id="kobo.128.1">. </span><span class="koboSpan" id="kobo.128.2">In previous decades, if you needed 10,000 digitized pictures of cats to compile a database to train a neural network, the task would be almost impossible – you could take a lot of cat pictures, or scan images from books. </span><span class="koboSpan" id="kobo.128.3">Today, a Google search for cat pictures returns 126,000,000 results in 0.44 seconds. </span><span class="koboSpan" id="kobo.128.4">Finding cat pictures, or anything else, is just a search away, and you have your training set for your neural network – unless you need to train on a very specific set of objects that don’t happen to be on the internet, as we will see in this book, in which case we will once again be taking a lot of pictures with another modern aid not found in the sixties, a digital camera. </span><span class="koboSpan" id="kobo.128.5">The happy combination of very fast computers, cheap, plentiful storage, and access to almost unlimited data of every sort has produced a renaissance </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">in AI.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Another modern development has occurred on the other end of the computer spectrum. </span><span class="koboSpan" id="kobo.130.2">While anyone can now have what we would have called a supercomputer back in 2000 on their desk at home, the development of the smartphone has driven a whole series of innovations that are just being felt in technology. </span><span class="koboSpan" id="kobo.130.3">Your wonder of a smartphone has accelerometers and gyroscopes made of tiny silicon chips called </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">Micro-Electromechanical Systems</span></strong><span class="koboSpan" id="kobo.132.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.133.1">MEMS</span></strong><span class="koboSpan" id="kobo.134.1">). </span><span class="koboSpan" id="kobo.134.2">It also has a high-resolution but very small digital camera </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.135.1">and a multi-core computer processor that takes very little power to run. </span><span class="koboSpan" id="kobo.135.2">It also contains (probably) three radios – a Wi-Fi wireless network, a cellular phone, and a Bluetooth transceiver. </span><span class="koboSpan" id="kobo.135.3">As good as these parts are at making your iPhone fun to use, they have also found their way into parts available for robots. </span><span class="koboSpan" id="kobo.135.4">That is fun for us because what used to be only available for research labs and universities is now for sale to individual users. </span><span class="koboSpan" id="kobo.135.5">If you happen to have a university or research lab or work for a technology company with multi-million-dollar development budgets, you will also learn something from this book, and find tools and ideas that hopefully will inspire your robotics creations or power new products with </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">exciting capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">Now that you’re</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.138.1"> familiar with the concept of AI for robotics, let’s look at what a robot </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">actually is.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.140.1">What is a robot?</span></h1>
<p><span class="koboSpan" id="kobo.141.1">The word </span><strong class="bold"><span class="koboSpan" id="kobo.142.1">robot</span></strong><span class="koboSpan" id="kobo.143.1"> entered </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.144.1">the modern language from the play </span><em class="italic"><span class="koboSpan" id="kobo.145.1">R.U.R</span></em><span class="koboSpan" id="kobo.146.1"> by the Czech author Karel Capek, which was published back in 1920. </span><em class="italic"><span class="koboSpan" id="kobo.147.1">Roboti</span></em><span class="koboSpan" id="kobo.148.1"> is a Czech word meaning </span><em class="italic"><span class="koboSpan" id="kobo.149.1">forced servitude</span></em><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">In the play, an industrialist learns how to build artificial people – not mechanical, metal men, but made of flesh and blood, and coming from a factory fully grown. </span><span class="koboSpan" id="kobo.150.3">The English translation of the name </span><em class="italic"><span class="koboSpan" id="kobo.151.1">R.U.R</span></em><span class="koboSpan" id="kobo.152.1"> as </span><em class="italic"><span class="koboSpan" id="kobo.153.1">Rossum’s Universal Robots</span></em><span class="koboSpan" id="kobo.154.1"> introduced the word </span><em class="italic"><span class="koboSpan" id="kobo.155.1">robot</span></em><span class="koboSpan" id="kobo.156.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the world.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">For the purposes of this book, a robot is a machine that is capable of sensing and reacting to its environment, and that has some human- or animal-like function. </span><span class="koboSpan" id="kobo.158.2">We generally think of a robot as an automated, self-directing mobile machine that can interact with the environment. </span><span class="koboSpan" id="kobo.158.3">That is to say, a robot </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.159.1">has a </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">physical form</span></strong><span class="koboSpan" id="kobo.161.1"> and exhibits some form</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.162.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.163.1">autonomy</span></strong><span class="koboSpan" id="kobo.164.1">, or the ability to make decisions for itself based on observation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">external environment.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Next, let’s discuss the problem we will be trying to solve in </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">this book.</span></span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.168.1">Our sample problem – clean up this room!</span></h1>
<p><span class="koboSpan" id="kobo.169.1">In the course of this book, we </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.170.1">will be using a single problem set that I feel most people can relate to easily, while still representing a real challenge for the most seasoned roboticist. </span><span class="koboSpan" id="kobo.170.2">We will be using AI and robotics techniques to pick up toys in my house after my grandchildren have visited. </span><span class="koboSpan" id="kobo.170.3">That sound you just heard was the gasp from the professional robotics engineers and researchers in the audience – this is a tough problem. </span><span class="koboSpan" id="kobo.170.4">Why is this a tough problem, and why is it ideal for </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">this book?</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Let’s discuss the problem and break it down a bit. </span><span class="koboSpan" id="kobo.172.2">Later, in </span><a href="B19846_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.173.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.174.1">, we will do a full task analysis, learn how to write use cases, and create storyboards to develop our approach, but we can start here with some </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">general observations.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">Robotics designers first start with the environment – where does the robot work? </span><span class="koboSpan" id="kobo.176.2">We divide environments into two categories: structured and unstructured. </span><span class="koboSpan" id="kobo.176.3">A structured environment, like the playing field for a FIRST robotics competition (a contest for robots built by high school students in the US, where all of the playing field is known in advance), an assembly line, or a lab bench, has everything in an organized space. </span><span class="koboSpan" id="kobo.176.4">You might have heard the saying </span><em class="italic"><span class="koboSpan" id="kobo.177.1">“A place for everything and everything in its place”</span></em><span class="koboSpan" id="kobo.178.1"> – that is a </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">structured environment</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">Another way to think about it is that we know in advance where everything</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.181.1"> is or is going to be. </span><span class="koboSpan" id="kobo.181.2">We know what color things are, where they are placed in space, and what shape they are. </span><span class="koboSpan" id="kobo.181.3">A name for this type of information is </span><em class="italic"><span class="koboSpan" id="kobo.182.1">a priori</span></em><span class="koboSpan" id="kobo.183.1"> knowledge – things we know in advance. </span><span class="koboSpan" id="kobo.183.2">Having advanced knowledge of the environment in robotics is sometimes absolutely essential. </span><span class="koboSpan" id="kobo.183.3">Assembly line robots expect parts to arrive in an exact position and orientation to be grasped and placed into position. </span><span class="koboSpan" id="kobo.183.4">In other words, we have arranged the world to suit </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">In the world of my house, this is simply not an option. </span><span class="koboSpan" id="kobo.185.2">If I could get my grandchildren to put their toys in exactly the same spot each time, then we would not need a robot for this task. </span><span class="koboSpan" id="kobo.185.3">We have a set of objects that are fairly fixed – we only have so many toys for them to play with. </span><span class="koboSpan" id="kobo.185.4">We occasionally add things or lose toys, or something falls down the stairs, but the toys are elements of a set of fixed objects. </span><span class="koboSpan" id="kobo.185.5">What they are not is positioned or oriented in any particular manner – they are just where they were left when the kids finished playing with them and went home. </span><span class="koboSpan" id="kobo.185.6">We also have a fixed set of furniture, but some</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.186.1"> parts move – the footstool or chairs can be moved around. </span><span class="koboSpan" id="kobo.186.2">This is an </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">unstructured environment</span></strong><span class="koboSpan" id="kobo.188.1">, where </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.189.1">the robot and the software have to adapt, not the toys </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">or furniture.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The problem is to have the robot drive around the room and pick up toys. </span><span class="koboSpan" id="kobo.191.2">Here are some objectives for </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">this task:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.193.1">We want the</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.194.1"> user to </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">interact</span></strong><span class="koboSpan" id="kobo.196.1"> with the robot by </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">talking</span></strong><span class="koboSpan" id="kobo.198.1"> to it. </span><span class="koboSpan" id="kobo.198.2">We want the robot to understand what we want it to do, which is to say, what our intent is for the commands we are </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">giving it.</span></span></li>
<li><span class="koboSpan" id="kobo.200.1">Once commanded to start, the robot will have to </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">identify an object</span></strong><span class="koboSpan" id="kobo.202.1"> as being a toy or not being a toy. </span><span class="koboSpan" id="kobo.202.2">We only want to pick </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">up toys.</span></span></li>
<li><span class="koboSpan" id="kobo.204.1">The robot must </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">avoid hazards</span></strong><span class="koboSpan" id="kobo.206.1">, the most important being the stairs going down to the first floor. </span><span class="koboSpan" id="kobo.206.2">Robots have a particular problem with negative obstacles (dropoffs, curbs, cliffs, stairs, etc.), and that is exactly what we </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">have here.</span></span></li>
<li><span class="koboSpan" id="kobo.208.1">Once the robot finds a toy, it has to determine how to </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">pick the toy up</span></strong><span class="koboSpan" id="kobo.210.1"> with its robot arm. </span><span class="koboSpan" id="kobo.210.2">Can it grasp the object directly, or must it scoop the item up, or push it along? </span><span class="koboSpan" id="kobo.210.3">We expect that the robot will try different ways to pick up toys and may need several </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">trial-and-error attempts.</span></span></li>
<li><span class="koboSpan" id="kobo.212.1">Once the toy is picked up by the robot arm, the robot needs to </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">carry the toy</span></strong><span class="koboSpan" id="kobo.214.1"> to a toy box. </span><span class="koboSpan" id="kobo.214.2">The robot must recognize the toy box in the room, remember where it is for repeat trips, and then position itself to place the toy in the box. </span><span class="koboSpan" id="kobo.214.3">Again, more than one attempt may </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">be required.</span></span></li>
<li><span class="koboSpan" id="kobo.216.1">After the toy is dropped off, the robot returns to </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">patrolling the room</span></strong><span class="koboSpan" id="kobo.218.1"> looking for more toys. </span><span class="koboSpan" id="kobo.218.2">At some point, hopefully, all of the toys will be retrieved. </span><span class="koboSpan" id="kobo.218.3">It may have to ask us, the</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.219.1"> human, whether the room is acceptable, or whether it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">continue cleaning.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.221.1">What will we learn from this problem? </span><span class="koboSpan" id="kobo.221.2">We will be using this backdrop to examine a variety of AI techniques and tools. </span><span class="koboSpan" id="kobo.221.3">The purpose of the book is to teach you how to develop AI solutions with robots. </span><span class="koboSpan" id="kobo.221.4">It is the process and the approach that is the critical information here, not the problem and not the robot I developed for the book. </span><span class="koboSpan" id="kobo.221.5">We will be demonstrating </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.222.1">techniques for making a moving machine that can learn and adapt to its environment. </span><span class="koboSpan" id="kobo.222.2">I would expect that you will pick and choose which chapters to read and in which order, according to your interests and your needs, and as such, each of the chapters will be </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">standalone lessons.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">The first three chapters are foundation material that supports the rest of the book by setting up the problem and providing a firm framework to attach the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the material.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.226.1">The basics of robotics</span></h2>
<p><span class="koboSpan" id="kobo.227.1">Not all of the chapters or</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.228.1"> topics in this book are considered </span><em class="italic"><span class="koboSpan" id="kobo.229.1">classical</span></em><span class="koboSpan" id="kobo.230.1"> AI approaches, but they do represent different ways of approaching machine learning and decision-making problems. </span><span class="koboSpan" id="kobo.230.2">We will be exploring together the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">following topics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">Control theory and timing</span></strong><span class="koboSpan" id="kobo.233.1">: We will build a firm foundation for robot control by understanding control theory and timing. </span><span class="koboSpan" id="kobo.233.2">We will be using a soft real-time control scheme with what I </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.234.1">call a </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">frame-based control loop</span></strong><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">This technique has a fancy technical name – </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">rate monotonic scheduling</span></strong><span class="koboSpan" id="kobo.238.1"> – but I think you will find the concept intuitive and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">to understand.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.240.1">OODA loop</span></strong><span class="koboSpan" id="kobo.241.1">: At the most basic level, AI is a way for the robot to make decisions about its actions. </span><span class="koboSpan" id="kobo.241.2">We will introduce a model for decision-making that comes from the US Air Force, called the </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">OODA loop</span></strong><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">This </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.244.1">describes how a robot (or a person) makes decisions. </span><span class="koboSpan" id="kobo.244.2">Our robot will have two of these loops, an inner loop </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.245.1">or </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">introspective loop</span></strong><span class="koboSpan" id="kobo.247.1">, and an</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.248.1"> outward-looking </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">environment sensor loop</span></strong><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">The lower, inner loop takes priority over the slower, outer loop, just as the autonomic parts of your body (such as the heartbeat, breathing, and eating) take precedence over your task functions (such as going to work, paying bills, and mowing the yard). </span><span class="koboSpan" id="kobo.250.3">This makes our system a type</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.251.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">subsumption architecture</span></strong><span class="koboSpan" id="kobo.253.1">, a biologically inspired control paradigm named by Rodney Brooks of </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.254.1">MIT, one of the founders of iRobot and Rethink Robotics, and the designer of a robot </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">named Baxter.</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.256.1"><img alt="Figure 1.1 – My version of the OODA loop" src="image/B19846_01_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.257.1">Figure 1.1 – My version of the OODA loop</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.258.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.259.1">The OODA loop was invented by Col. </span><span class="koboSpan" id="kobo.259.2">John Boyd, a man also called </span><em class="italic"><span class="koboSpan" id="kobo.260.1">The Father of the F-16</span></em><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">Col. </span><span class="koboSpan" id="kobo.261.3">Boyd’s ideas are still widely quoted today, and his OODA loop is used to describe robot AI, military planning, or marketing strategies with equal utility. </span><span class="koboSpan" id="kobo.261.4">OODA provides a model for how a thinking machine that interacts with its environment </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">might work.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">Our robot works not by simply following commands or instructions step by step but by setting goals and then working to achieve those goals. </span><span class="koboSpan" id="kobo.263.2">The robot is free to set its own path or determine how to get to its goal. </span><span class="koboSpan" id="kobo.263.3">We will tell the robot </span><em class="italic"><span class="koboSpan" id="kobo.264.1">pick up that toy</span></em><span class="koboSpan" id="kobo.265.1"> and the robot will decide which toy, how to get in range, and how to pick up the toy. </span><span class="koboSpan" id="kobo.265.2">If we, the human robot owner, instead tried to treat the robot as a teleoperated hand, we would have to give the robot many individual instructions, such as </span><em class="italic"><span class="koboSpan" id="kobo.266.1">move forward</span></em><span class="koboSpan" id="kobo.267.1">, </span><em class="italic"><span class="koboSpan" id="kobo.268.1">move right</span></em><span class="koboSpan" id="kobo.269.1">, </span><em class="italic"><span class="koboSpan" id="kobo.270.1">extend arm</span></em><span class="koboSpan" id="kobo.271.1">, </span><em class="italic"><span class="koboSpan" id="kobo.272.1">and open hand</span></em><span class="koboSpan" id="kobo.273.1">, each individually, and without giving the robot any idea why we were making those motions. </span><span class="koboSpan" id="kobo.273.2">In a goal-oriented structure, the robot will be aware of which objects are toys and which are not and it will know how to find the toy box and how to put toys in the box. </span><span class="koboSpan" id="kobo.273.3">This is the difference between an autonomous robot and a radio-controlled </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">teleoperated device.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Before designing the specifics of our robot and its software, we have to match its capabilities to the environment and the problem it must solve. </span><span class="koboSpan" id="kobo.275.2">The book will introduce some tools for designing the robot and managing the development of the software. </span><span class="koboSpan" id="kobo.275.3">We will use two tools from </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.276.1">the discipline of systems engineering to accomplish this – </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">use cases</span></strong><span class="koboSpan" id="kobo.278.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">storyboards</span></strong><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">I will make this process as streamlined as possible. </span><span class="koboSpan" id="kobo.280.3">More advanced types of systems engineering are used by NASA, aerospace, and automobile companies to design rockets, cars, and aircraft – this gives you a taste of those types of </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">structured processes.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.282.1">The techniques used in this book</span></h2>
<p><span class="koboSpan" id="kobo.283.1">The following sections </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.284.1">will each detail step-by-step</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.285.1"> examples of applying AI techniques to a </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">robotics problem:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.287.1">We start</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.288.1"> with </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">object recognition</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">We need our robot to recognize objects, and then classify them as either </span><em class="italic"><span class="koboSpan" id="kobo.291.1">toys</span></em><span class="koboSpan" id="kobo.292.1"> to be picked up or </span><em class="italic"><span class="koboSpan" id="kobo.293.1">not toys</span></em><span class="koboSpan" id="kobo.294.1"> to be left alone. </span><span class="koboSpan" id="kobo.294.2">We will use a trained </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">ANN</span></strong><span class="koboSpan" id="kobo.296.1"> to recognize</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.297.1"> objects from a video camera from various angles and lighting conditions. </span><span class="koboSpan" id="kobo.297.2">We will be using the process</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.298.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">transfer learning</span></strong><span class="koboSpan" id="kobo.300.1"> to extend an existing object recognition</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.301.1"> system, </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">YOLOv8</span></strong><span class="koboSpan" id="kobo.303.1">, to recognize our toys quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">and reliably.</span></span></li>
<li><span class="koboSpan" id="kobo.305.1">The next task, once a toy is identified, is to pick it up. </span><span class="koboSpan" id="kobo.305.2">Writing a general-purpose </span><em class="italic"><span class="koboSpan" id="kobo.306.1">pick up anything</span></em><span class="koboSpan" id="kobo.307.1"> program for a robot arm is a difficult task involving a lot of higher mathematics (use the internet to look up </span><em class="italic"><span class="koboSpan" id="kobo.308.1">inverse kinematics</span></em><span class="koboSpan" id="kobo.309.1"> to see what I mean). </span><span class="koboSpan" id="kobo.309.2">What if we let the robot sort this out for itself? </span><span class="koboSpan" id="kobo.309.3">We use </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">genetic algorithms</span></strong><span class="koboSpan" id="kobo.311.1"> that </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.312.1">permit the robot to invent its own behaviors and learn to use its arm on its own. </span><span class="koboSpan" id="kobo.312.2">Then we will employ </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">deep reinforcement learning</span></strong><span class="koboSpan" id="kobo.314.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.315.1">DRL</span></strong><span class="koboSpan" id="kobo.316.1">) to let </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.317.1">the robot teach itself how to grasp various objects using an </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">end effector</span></strong><span class="koboSpan" id="kobo.319.1"> (robot </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.320.1">speak for </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">a hand).</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">Our robot needs to understand commands and instructions from its owner (us). </span><span class="koboSpan" id="kobo.322.2">We use </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">natural language processing</span></strong><span class="koboSpan" id="kobo.324.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.325.1">NLP</span></strong><span class="koboSpan" id="kobo.326.1">) to not</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.327.1"> just recognize speech but to </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.328.1">understand </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.329.1">our intent for the robot to create goals consistent with what we want it to do. </span><span class="koboSpan" id="kobo.329.2">We use a neat technique that I call the </span><em class="italic"><span class="koboSpan" id="kobo.330.1">fill in the blank</span></em><span class="koboSpan" id="kobo.331.1"> method to allow the robot to reason from the context of a command. </span><span class="koboSpan" id="kobo.331.2">This process is useful for a lot of robot </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">planning tasks.</span></span></li>
<li><span class="koboSpan" id="kobo.333.1">The robot’s next problem is navigating rooms while avoiding the stairs and other hazards. </span><span class="koboSpan" id="kobo.333.2">We will use a combination of a unique, mapless navigation technique with 3D vision provided by a special stereo camera to see and </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">avoid obstacles.</span></span></li>
<li><span class="koboSpan" id="kobo.335.1">The robot will need to be able to find the toy box to put items away, as well as have a general framework for planning moves in the future. </span><span class="koboSpan" id="kobo.335.2">We will use </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">decision trees</span></strong><span class="koboSpan" id="kobo.337.1"> for </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.338.1">path planning, as well as discussing </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">pruning</span></strong><span class="koboSpan" id="kobo.340.1"> or</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.341.1"> quickly rejecting bad plans. </span><span class="koboSpan" id="kobo.341.2">If you imagine what a computer chess program algorithm must do, looking several moves ahead and scoring good moves versus bad moves before selecting a strategy, that will give you an idea of the power of this technique. </span><span class="koboSpan" id="kobo.341.3">This type of decision tree has many uses and can handle many dimensions of strategies. </span><span class="koboSpan" id="kobo.341.4">We’ll be using it as one of two ways to find a path to our toy box to put </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">toys away.</span></span></li>
<li><span class="koboSpan" id="kobo.343.1">Our final task brings a different set of tools not normally used in robotics, or at least not the way we are going to </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">employ them.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.345.1">I have five wonderful, talented, and delightful grandchildren who love to come and visit. </span><span class="koboSpan" id="kobo.345.2">You’ll be hearing a lot about them throughout the book. </span><span class="koboSpan" id="kobo.345.3">The oldest grandson is 10 years old, and autistic, as is my granddaughter, the third child, who is 8, as well as the youngest boy, who is 6 as I write this. </span><span class="koboSpan" id="kobo.345.4">I introduced my eldest grandson, William, to the robot – and he immediately wanted to have a conversation with it. </span><span class="koboSpan" id="kobo.345.5">He asked, </span><em class="italic"><span class="koboSpan" id="kobo.346.1">“What’s your name?”</span></em><span class="koboSpan" id="kobo.347.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.348.1">“What do you do?”</span></em><span class="koboSpan" id="kobo.349.1"> He was disappointed when the robot made no reply. </span><span class="koboSpan" id="kobo.349.2">So for the grandkids, we will be developing an engine for the robot to carry out a short conversation – we will be creating a robot personality to interact with children. </span><span class="koboSpan" id="kobo.349.3">William had one more request for this robot – he wants it to tell and respond to </span><em class="italic"><span class="koboSpan" id="kobo.350.1">knock, knock</span></em><span class="koboSpan" id="kobo.351.1"> jokes, so we will use that as a prototype of </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">special dialog.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.353.1">While developing a robot with actual feelings is far beyond the state of the art in robotics or AI today, we can simulate having a personality with a finite state machine and some Monte Carlo modeling. </span><span class="koboSpan" id="kobo.353.2">We will also give the robot a model for human interaction so that the robot will take into account the child’s mood as well. </span><span class="koboSpan" id="kobo.353.3">I like to call this type of</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.354.1"> software </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.355.1">an </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">AP</span></strong><span class="koboSpan" id="kobo.357.1"> to distinguish it from our</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.358.1"> AI. </span><span class="koboSpan" id="kobo.358.2">AI builds a model of thinking, and an AP builds a model of emotion for </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">our robot.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Now that you’re familiar with the problem we will be addressing in this book, let’s briefly discuss when and why you might need AI for </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">your robot.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.362.1">When do you need AI for your robot?</span></h1>
<p><span class="koboSpan" id="kobo.363.1">We generally </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.364.1">describe AI as a technique for </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.365.1">modeling or simulating processes that emulate how our brains make decisions. </span><span class="koboSpan" id="kobo.365.2">Let’s discuss how AI can be used in robotics to provide capabilities that may be difficult for </span><em class="italic"><span class="koboSpan" id="kobo.366.1">traditional</span></em><span class="koboSpan" id="kobo.367.1"> programming techniques to achieve. </span><span class="koboSpan" id="kobo.367.2">One of those is identifying objects in images or pictures. </span><span class="koboSpan" id="kobo.367.3">If you connect a camera to a computer, the computer receives not an image, but an array of numbers that represent pixels (picture elements). </span><span class="koboSpan" id="kobo.367.4">If we are trying to determine whether a certain object, say a toy, is located in the image, then this can be quite tricky. </span><span class="koboSpan" id="kobo.367.5">You can find shapes, such as circles or squares, but a teddy bear? </span><span class="koboSpan" id="kobo.367.6">Moreover, what if the teddy bear is upside down, or lying flat on a surface? </span><span class="koboSpan" id="kobo.367.7">This is the sort of problem that an AI program can solve when nothing </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">else can.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">Our traditional approach for creating robot behaviors is to figure out what function we want and to write code to make that happen. </span><span class="koboSpan" id="kobo.369.2">When we have a simple function, such as driving around an obstacle, then this approach works well, and we can get results with a </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">little tuning.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Some examples of AI and </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">ML</span></strong><span class="koboSpan" id="kobo.373.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">robotics include:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.375.1">NLP</span></strong><span class="koboSpan" id="kobo.376.1">: Using AI/ML to</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.377.1"> allow the robot to understand and respond to natural human speech and commands. </span><span class="koboSpan" id="kobo.377.2">This makes interacting with the robot much </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">more intuitive.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.379.1">Computer vision</span></strong><span class="koboSpan" id="kobo.380.1">: Using AI to let the robot see and recognize objects or people’s faces, read text, and so on. </span><span class="koboSpan" id="kobo.380.2">This helps the robot operate in </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">real-world environments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.382.1">Motion planning</span></strong><span class="koboSpan" id="kobo.383.1">: AI can help the robot plan optimal paths and motions to navigate around obstacles and people. </span><span class="koboSpan" id="kobo.383.2">This makes the robot’s movements more efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">and human-like.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.385.1">Reinforcement learning</span></strong><span class="koboSpan" id="kobo.386.1">: The robot can learn how to do, and improve at doing, tasks through trial and error using AI reinforcement learning algorithms. </span><span class="koboSpan" id="kobo.386.2">This means less explicit programming </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">is needed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.388.1">The main rule of thumb is to use AI/ML whenever you want the robot to perform robustly in a complex, dynamic real-world environment. </span><span class="koboSpan" id="kobo.388.2">The AI gives it more perceptual and </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">decision-making capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Now let’s look at one function we need for this robot – recognizing that an object is either a toy (and needs to be picked up) or is not. </span><span class="koboSpan" id="kobo.390.2">Creating a standard function for this via programming is quite difficult. </span><span class="koboSpan" id="kobo.390.3">Regular computer vision processes separate an image into shapes, colors, or areas. </span><span class="koboSpan" id="kobo.390.4">Our problem is the toys don’t have predictable shapes (circles, squares, or triangles), they don’t have consistent colors, and they are not all the same size. </span><span class="koboSpan" id="kobo.390.5">What we would rather do is to teach the robot what is a toy and what is not. </span><span class="koboSpan" id="kobo.390.6">That is what we would do with a person. </span><span class="koboSpan" id="kobo.390.7">We just need a process for teaching the robot how to use a camera to recognize a particular object. </span><span class="koboSpan" id="kobo.390.8">Fortunately, this is an area of AI that has been deeply studied, and there are already techniques to accomplish this, which we will use in </span><a href="B19846_04.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.391.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">We will </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.393.1">use a </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">convolutional neural network</span></strong><span class="koboSpan" id="kobo.395.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.396.1">CNN</span></strong><span class="koboSpan" id="kobo.397.1">) to recognize toys from camera images. </span><span class="koboSpan" id="kobo.397.2">This is a type</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.398.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">supervised learning</span></strong><span class="koboSpan" id="kobo.400.1">, where we use examples to show the software what type of object we want to recognize, and then create a customized function that </span><em class="italic"><span class="koboSpan" id="kobo.401.1">predicts</span></em><span class="koboSpan" id="kobo.402.1"> the class (or type) of object based on the pixels that represent it in an image. </span><span class="koboSpan" id="kobo.402.2">One of the principles of AI that we will be applying is </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">gradual learning</span></strong><span class="koboSpan" id="kobo.404.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">gradient descent</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">This </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.407.1">means that instead of trying to make the </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.408.1">computer learn a skill all in one go, we will train it a little bit at a time, gently training </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.409.1">a</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.410.1"> function to output what we want by looking at errors (or loss) and making small changes. </span><span class="koboSpan" id="kobo.410.2">We use the principle of gradient descent – looking at the slope of the change in errors – to determine which way to adjust </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">the training.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">You may be thinking at this point, </span><em class="italic"><span class="koboSpan" id="kobo.413.1">“If that works for learning to classify pictures, then maybe it can be used to classify other things,"</span></em><span class="koboSpan" id="kobo.414.1"> and you would be right. </span><span class="koboSpan" id="kobo.414.2">We’ll use a similar approach – with somewhat different neural networks – to teach the robot to answer to its name, by recognizing </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the sound.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">So, in general, when do we need to use AI in a robot? </span><span class="koboSpan" id="kobo.416.2">When we need to emulate some sort of decision-making process that would be difficult or impossible to create with procedural steps (i.e., programming). </span><span class="koboSpan" id="kobo.416.3">It’s easy to see that neural networks are emulations of animal thought processes since they are a (greatly) simplified model of how neurons interact. </span><span class="koboSpan" id="kobo.416.4">Other AI techniques can be more difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">One common theme could be that AI consistently uses </span><em class="italic"><span class="koboSpan" id="kobo.419.1">programming by example</span></em><span class="koboSpan" id="kobo.420.1"> as a technique to replace code with a common framework and variables with data. </span><span class="koboSpan" id="kobo.420.2">Instead of </span><em class="italic"><span class="koboSpan" id="kobo.421.1">programming by process</span></em><span class="koboSpan" id="kobo.422.1">, we are programming by showing the software what result we want and having the software come up with how to get to that result. </span><span class="koboSpan" id="kobo.422.2">So for </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">object recognition</span></strong><span class="koboSpan" id="kobo.424.1"> using </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.425.1">pictures, we provide pictures of objects </span><em class="italic"><span class="koboSpan" id="kobo.426.1">and</span></em><span class="koboSpan" id="kobo.427.1"> the answer to what kind of object is represented by the picture. </span><span class="koboSpan" id="kobo.427.2">We repeat this over and over and train the software – by modifying the parameters in </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Another type of behavior we can create with AI has to do with behaviors. </span><span class="koboSpan" id="kobo.429.2">There are a lot of tasks that can be thought of as games. </span><span class="koboSpan" id="kobo.429.3">We can easily imagine how this works. </span><span class="koboSpan" id="kobo.429.4">Let’s say you want your children to pick up the toys in their room. </span><span class="koboSpan" id="kobo.429.5">You could command them to do it – which may or may not work. </span><span class="koboSpan" id="kobo.429.6">Or, you could make it a game by awarding points for each toy picked up, and giving a reward (such as giving a dollar) based on the number of points scored. </span><span class="koboSpan" id="kobo.429.7">What did we add by doing this? </span><span class="koboSpan" id="kobo.429.8">We added a </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">metric</span></strong><span class="koboSpan" id="kobo.431.1">, or measurement tool, to let the children know how well they are doing – a point system. </span><span class="koboSpan" id="kobo.431.2">And, more critically, we added a reward for specific behaviors. </span><span class="koboSpan" id="kobo.431.3">This can be a process we can use to modify or create behaviors in a robot. </span><span class="koboSpan" id="kobo.431.4">This is formally called </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">reinforcement learning</span></strong><span class="koboSpan" id="kobo.433.1">. </span><span class="koboSpan" id="kobo.433.2">While </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.434.1">we can’t give a robot an emotional reward (as robots don’t have wants or needs), we can program the robot to seek to maximize a reward function. </span><span class="koboSpan" id="kobo.434.2">Then we can use the same process of making a small adjustment in parameters that change the reward, see whether that improves the score, and then either keep that change (when learning results in more reward, our reinforcement) or discard it if the score goes down. </span><span class="koboSpan" id="kobo.434.3">This type of process works well for robot motion, and for controlling </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">robot arms.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">I must tell you that the task set out in this book – to pick up toys in an unstructured environment – is nearly impossible to perform without AI techniques. </span><span class="koboSpan" id="kobo.436.2">It could be done by modifying the environment – say, by putting RFID tags in the toys – but not otherwise. </span><span class="koboSpan" id="kobo.436.3">That, then, is</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.437.1"> the purpose of this book – to </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.438.1">show how certain tasks, which are difficult or impossible to solve otherwise, can be completed using the combination of AI </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">and robotics.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Next, let’s discuss our robot and the development environment that we’ll be using in </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">this book.</span></span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.442.1">Introducing the robot and our development environment</span></h1>
<p><span class="koboSpan" id="kobo.443.1">This is a book </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.444.1">about </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.445.1">robots and AI, so we really need to have a robot to use for all of our practical examples. </span><span class="koboSpan" id="kobo.445.2">As we will discuss in </span><a href="B19846_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.446.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.447.1"> at some length, I have selected robot hardware and software that will be accessible to the average reader. </span><span class="koboSpan" id="kobo.447.2">The particular brand and type are not important, and I’ve upgraded Albert considerably since the first edition was published some five years ago. </span><span class="koboSpan" id="kobo.447.3">In the interest of keeping things up to date, we are putting all of the hardware details in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">As shown in the following photographs taken from two different perspectives, my robot has new omnidirectional wheels, a mechanical six-degree-of-freedom arm, and a </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">computer brain:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.451.1"><img alt="Figure 1.2 – Albert the robot has wheels and a mechanical arm" src="image/B19846_01_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.452.1">Figure 1.2 – Albert the robot has wheels and a mechanical arm</span></p>
<p><span class="koboSpan" id="kobo.453.1">I’ll call it </span><em class="italic"><span class="koboSpan" id="kobo.454.1">Albert</span></em><span class="koboSpan" id="kobo.455.1">, since it needs some sort of name, and I like the reference to Prince Albert, consort of Queen Victoria, who was famous for taking marvelous care of their nine children. </span><span class="koboSpan" id="kobo.455.2">All nine of</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.456.1"> his </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.457.1">children survived to adulthood, which was a rarity in the Victorian age, and he had 42 grandchildren. </span><span class="koboSpan" id="kobo.457.2">He went by his middle name; his actual first name </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">was Francis.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Our tasks in this book center around picking up toys in an interior space, so our robot has a solid base with four motors and omni wheels for driving over carpet. </span><span class="koboSpan" id="kobo.459.2">Our steering method is the tank type, or differential drive, where we steer by sending different commands to the wheel motors. </span><span class="koboSpan" id="kobo.459.3">If we want to go straight ahead, we set all four motors to the same forward speed. </span><span class="koboSpan" id="kobo.459.4">If we want to travel backward, we reverse both motors the same amount. </span><span class="koboSpan" id="kobo.459.5">Turns are accomplished by moving one side forward and the other backward (which makes the robot turn in place) or by giving one side more forward drive than the other. </span><span class="koboSpan" id="kobo.459.6">We can make any sort of turn this way. </span><span class="koboSpan" id="kobo.459.7">The omni wheels allow us to do some other tricks as well – we can turn the wheels toward each other and translate directly sideways, and even turn in a circle while pointing at the same spot on the ground. </span><span class="koboSpan" id="kobo.459.8">We will mostly drive like a truck or car but will use the </span><em class="italic"><span class="koboSpan" id="kobo.460.1">y</span></em><span class="koboSpan" id="kobo.461.1">-axis motion occasionally to line things up. </span><span class="koboSpan" id="kobo.461.2">Speaking of axes, I’ll use the </span><em class="italic"><span class="koboSpan" id="kobo.462.1">x</span></em><span class="koboSpan" id="kobo.463.1"> axis to mean that the robot will move straight ahead, the </span><em class="italic"><span class="koboSpan" id="kobo.464.1">y</span></em><span class="koboSpan" id="kobo.465.1"> axis refers to horizontal movement from side to side, and the </span><em class="italic"><span class="koboSpan" id="kobo.466.1">z</span></em><span class="koboSpan" id="kobo.467.1"> axis is up and down, which we need for the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">robot’s arm.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">In order to pick up toys, we need some sort of manipulator, so I’ve included a six-axis robot arm that imitates a shoulder–elbow–wrist–hand combination that is quite dexterous and, since it is made out of standard digital servos, quite easy to wire </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">and program.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">The main control of the Albert robot is the Nvidia Nano </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">single-board computer</span></strong><span class="koboSpan" id="kobo.473.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.474.1">SBC</span></strong><span class="koboSpan" id="kobo.475.1">), which </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.476.1">talks to the operator via a USB Wi-Fi dongle. </span><span class="koboSpan" id="kobo.476.2">The Nvidia talks to an Arduino Mega 2560 microcontroller and motor controller that we will use to control </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.477.1">motors via </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">Pulse Width Modulation</span></strong><span class="koboSpan" id="kobo.479.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">PWM</span></strong><span class="koboSpan" id="kobo.481.1">) pulses. </span><span class="koboSpan" id="kobo.481.2">The following figure depicts the internal</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.482.1"> components </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.483.1">of </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">the robot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.485.1"><img alt="Figure 1.3 – Block diagram of the robot" src="image/B19846_01_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.486.1">Figure 1.3 – Block diagram of the robot</span></p>
<p><span class="koboSpan" id="kobo.487.1">We will be primarily concerned with the Nvidia Nano SBC, which is the brains of our robot. </span><span class="koboSpan" id="kobo.487.2">We will set up the rest of the components once and not change them for the </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">entire book.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">The Nvidia Nano acts as the main interface between our control station, which is a PC running Windows, and the robot itself via a Wi-Fi network. </span><span class="koboSpan" id="kobo.489.2">Just about any low-power, Linux-based SBC can perform this job, such as a BeagleBone Black, Odroid XU4, or an Intel Edison. </span><span class="koboSpan" id="kobo.489.3">One of the advantages of the Nano is that it can use its </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">Graphics Processing Units</span></strong><span class="koboSpan" id="kobo.491.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.492.1">GPUs</span></strong><span class="koboSpan" id="kobo.493.1">) to </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.494.1">speed up the processing of </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">neural networks.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Connected to the SBC is an Arduino with a motor controller. </span><span class="koboSpan" id="kobo.496.2">The Nano talks through a USB port addressed as a serial port. </span><span class="koboSpan" id="kobo.496.3">We also need a 5V regulator to provide the proper power from the 11.1V rechargeable lithium battery power pack into the robot. </span><span class="koboSpan" id="kobo.496.4">My power pack is a rechargeable 3S1P (three cells in series and one in parallel) 2700 Ah battery (normally used for quadcopter drones) and came with the appropriate charger. </span><span class="koboSpan" id="kobo.496.5">As with any lithium battery, follow all of the directions that come with the battery pack and recharge it in a </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.497.1">metal </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.498.1">box or container in case </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">of fire.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.500.1">Software components (ROS, Python, and Linux)</span></h2>
<p><span class="koboSpan" id="kobo.501.1">I am going to direct </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.502.1">you once again to the Git repository to see all of the software that runs the robot, but I’ll cover the basics here to remind you. </span><span class="koboSpan" id="kobo.502.2">The base operating system for the robot is Linux running on an Nvidia Nano SBC, as we said. </span><span class="koboSpan" id="kobo.502.3">We are using the ROS 2 to connect all of our various software components together, and it also does a wonderful job of taking care of all of the finicky networking tasks such as setting up sockets and establishing connections. </span><span class="koboSpan" id="kobo.502.4">It also comes with a great library of already prepared functions that we can just take advantage of, such as a joystick interface. </span><span class="koboSpan" id="kobo.502.5">ROS 2 is not a true operating system that controls the whole computer like Linux or Windows does, but rather is a backbone of communications and interface standards and utilities that make putting together a robot a lot simpler. </span><span class="koboSpan" id="kobo.502.6">The name I like to use for this type of system is </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">Modular Open System Architecture</span></strong><span class="koboSpan" id="kobo.504.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.505.1">MOSA</span></strong><span class="koboSpan" id="kobo.506.1">). </span><span class="koboSpan" id="kobo.506.2">ROS 2 uses a </span><em class="italic"><span class="koboSpan" id="kobo.507.1">publish/subscribe</span></em><span class="koboSpan" id="kobo.508.1"> technique</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.509.1"> to move data from one place to another that truly decouples the programs that produce data (such as sensors and cameras) from those programs that use data, such as controls and displays. </span><span class="koboSpan" id="kobo.509.2">We’ll be making a lot of our own stuff and only using a few ROS functions. </span><span class="koboSpan" id="kobo.509.3">Packt has several great books for learning ROS; my favorite is </span><em class="italic"><span class="koboSpan" id="kobo.510.1">Effective Robotics Programming </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.511.1">with ROS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">The programming language we will use throughout this book, with a couple of minor exceptions, will</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.514.1"> be </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">Python</span></strong><span class="koboSpan" id="kobo.516.1">. </span><span class="koboSpan" id="kobo.516.2">Python is a great language for this purpose for two great reasons: it is widely used in the robotics community in conjunction with ROS, and it is also widely accepted in the machine learning and AI community. </span><span class="koboSpan" id="kobo.516.3">This double whammy makes using Python irresistible. </span><span class="koboSpan" id="kobo.516.4">Python is an interpreted language, which has three amazing advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">for us:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.518.1">Portability</span></strong><span class="koboSpan" id="kobo.519.1">: Python is</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.520.1"> very portable between Windows, Mac, and Linux. </span><span class="koboSpan" id="kobo.520.2">Usually, you can get by with just a line or two of changes if you use a function out of the operating system, such as opening a file. </span><span class="koboSpan" id="kobo.520.3">Python has access to a huge collection of C/C++ libraries that also add to </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">its utility.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.522.1">No compilation</span></strong><span class="koboSpan" id="kobo.523.1">: As an interpreted language, Python does not require a compile step. </span><span class="koboSpan" id="kobo.523.2">Some of the programs we are developing in this book are pretty involved, and if we wrote them in C or C++, it would take 10 or 20 minutes of build time each time we made a change. </span><span class="koboSpan" id="kobo.523.3">You can do a lot with that much time, which you can spend getting your program to run and not waiting for the </span><em class="italic"><span class="koboSpan" id="kobo.524.1">make</span></em><span class="koboSpan" id="kobo.525.1"> process </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">to finish.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.527.1">Isolation</span></strong><span class="koboSpan" id="kobo.528.1">: This is a benefit that does not get talked about much but having had a lot of experience with crashing operating systems with robots, I can tell you that the fact that Python’s interpreter is isolated from the core operating system means that having one of your Python ROS programs crash the computer is very rare. </span><span class="koboSpan" id="kobo.528.2">A computer crash means rebooting the computer and also probably losing all of the data you need to diagnose the crash. </span><span class="koboSpan" id="kobo.528.3">I had a professional robot project that we moved from Python to C++, and immediately the operating system crashes began, which shot the reliability of our robot. </span><span class="koboSpan" id="kobo.528.4">If a Python program crashes, another program can monitor that and restart it. </span><span class="koboSpan" id="kobo.528.5">If the operating system has crashed, there is not much you can do without some extra hardware that can push the </span><em class="italic"><span class="koboSpan" id="kobo.529.1">Reset</span></em><span class="koboSpan" id="kobo.530.1"> button </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">for you.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.532.1">Before we dive into the coding of our base control system, let’s talk about the theory we will use to create a robust, modular, and flexible control system </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">for robotics.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.534.1">Robot control systems and a decision-making framework</span></h2>
<p><span class="koboSpan" id="kobo.535.1">As I mentioned </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.536.1">earlier in</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.537.1"> this chapter, we are going to use two sets of tools in the sections: </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">soft real-time control</span></strong><span class="koboSpan" id="kobo.539.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">OODA loop</span></strong><span class="koboSpan" id="kobo.541.1">. </span><span class="koboSpan" id="kobo.541.2">One</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.542.1"> gives us a base for controlling</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.543.1"> the robot easily and consistently, and the other provides a basis for the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">robot’s autonomy.</span></span></p>
<h3><span class="koboSpan" id="kobo.545.1">How to control your robot</span></h3>
<p><span class="koboSpan" id="kobo.546.1">The basic concept of</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.547.1"> how a robot works, especially one that drives, is simple. </span><span class="koboSpan" id="kobo.547.2">There is a master control loop that does the same thing over and over – reads data from the sensors and motor controller, looks for commands from the operator (or the robot’s autonomy functions), makes any changes to the state of the robot based on those commands, and then sends instructions to the motors or effectors to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">robot move.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.549.1"><img alt="Figure 1.4 – Robot control loop" src="image/B19846_01_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.550.1">Figure 1.4 – Robot control loop</span></p>
<p><span class="koboSpan" id="kobo.551.1">The preceding diagram illustrates how we have instantiated the OODA loop in the software and hardware of our robot. </span><span class="koboSpan" id="kobo.551.2">The robot can either act autonomously or accept commands from a control station connected via a </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">wireless network.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">What we need to do is perform this control loop in a consistent manner all of the time. </span><span class="koboSpan" id="kobo.553.2">We need to set a base frame rate or basic update frequency that sets the timing of our control loop. </span><span class="koboSpan" id="kobo.553.3">This makes all the systems of the robot perform together. </span><span class="koboSpan" id="kobo.553.4">Without some sort of time manager, each control cycle of the robot takes a different amount of time to complete, and any sort of path planning, position estimate, or arm movement becomes very complicated. </span><span class="koboSpan" id="kobo.553.5">ROS</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.554.1"> does not provide a time manager as it is inherently non-synchronous; if required, we have to create </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">one ourselves.</span></span></p>
<h3><span class="koboSpan" id="kobo.556.1">Using control loops</span></h3>
<p><span class="koboSpan" id="kobo.557.1">In order to have</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.558.1"> control of our robot, we have to establish some sort of control or feedback loop. </span><span class="koboSpan" id="kobo.558.2">Let’s say that we tell the robot to move 12 inches (30 cm) forward. </span><span class="koboSpan" id="kobo.558.3">The robot must send a command to the motors to start moving forward, and then have some sort of mechanism to measure 12 inches of travel. </span><span class="koboSpan" id="kobo.558.4">We can use several means, but let’s just use a clock. </span><span class="koboSpan" id="kobo.558.5">The robot moves 3 inches (7.5 cm) per second. </span><span class="koboSpan" id="kobo.558.6">We need the control loop to start the movement, and then each update cycle, or time through the loop, check the time and see whether four seconds have elapsed. </span><span class="koboSpan" id="kobo.558.7">If they have, then it sends a </span><em class="italic"><span class="koboSpan" id="kobo.559.1">stop</span></em><span class="koboSpan" id="kobo.560.1"> command to the motors. </span><span class="koboSpan" id="kobo.560.2">The timer is the </span><em class="italic"><span class="koboSpan" id="kobo.561.1">control</span></em><span class="koboSpan" id="kobo.562.1">, four seconds is the </span><em class="italic"><span class="koboSpan" id="kobo.563.1">set point</span></em><span class="koboSpan" id="kobo.564.1">, and the motor is the </span><em class="italic"><span class="koboSpan" id="kobo.565.1">system</span></em><span class="koboSpan" id="kobo.566.1"> that is controlled. </span><span class="koboSpan" id="kobo.566.2">The process also generates an error signal that tells us what control to apply (in this case, to stop). </span><span class="koboSpan" id="kobo.566.3">Let’s look at a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">control loop:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.568.1"><img alt="Figure 1.5 – Sample control loop – maintaining the temperature of a pot of water" src="image/B19846_01_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.569.1">Figure 1.5 – Sample control loop – maintaining the temperature of a pot of water</span></p>
<p><span class="koboSpan" id="kobo.570.1">Based on the preceding figure, what we want is a constant temperature</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.571.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.572.1">pot of water</span></strong><span class="koboSpan" id="kobo.573.1">. </span><span class="koboSpan" id="kobo.573.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.574.1">valve</span></strong><span class="koboSpan" id="kobo.575.1"> controls</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.576.1"> the heat produced by the </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">fire</span></strong><span class="koboSpan" id="kobo.578.1">, which warms the </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">pot of water</span></strong><span class="koboSpan" id="kobo.580.1">. </span><span class="koboSpan" id="kobo.580.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.581.1">temperature sensor</span></strong><span class="koboSpan" id="kobo.582.1"> detects whether</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.583.1"> the water is too cold, too hot, or just right. </span><span class="koboSpan" id="kobo.583.2">The controller uses this information to control the valve for more heat. </span><span class="koboSpan" id="kobo.583.3">This type of schema is </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.584.1">called a </span><strong class="bold"><span class="koboSpan" id="kobo.585.1">closed loop </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.586.1">control system</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">You can think of this also in terms of a process. </span><span class="koboSpan" id="kobo.588.2">We start the process, and then get feedback to show our progress so that we know when to stop or modify the process. </span><span class="koboSpan" id="kobo.588.3">We could be doing speed control, where we need the robot to move at a specific speed, or pointing control, where the robot aims or turns in a </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">specific direction.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">Let’s look at another example. </span><span class="koboSpan" id="kobo.590.2">We have a robot with a self-charging docking station, with a set </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.591.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">light-emitting diodes</span></strong><span class="koboSpan" id="kobo.593.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.594.1">LEDs</span></strong><span class="koboSpan" id="kobo.595.1">) on the top as an optical target. </span><span class="koboSpan" id="kobo.595.2">We want the robot to drive straight into the docking station. </span><span class="koboSpan" id="kobo.595.3">We use the camera to see the target LEDs on the docking station. </span><span class="koboSpan" id="kobo.595.4">The camera generates an error signal, which is used to guide the robot toward </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.596.1">the LEDs. </span><span class="koboSpan" id="kobo.596.2">The distance between the LEDs also gives us a rough range to the dock. </span><span class="koboSpan" id="kobo.596.3">This process is illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.598.1"><img alt="Figure 1.6 – Target tracking for a self-docking charging station" src="image/B19846_01_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.599.1">Figure 1.6 – Target tracking for a self-docking charging station</span></p>
<p><span class="koboSpan" id="kobo.600.1">Let’s understand this in some </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">more detail:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.602.1">Let’s say that the LEDs in the figure are off to the left of the center 50% and the distance from the robot to the target is 3 feet (1 m). </span><span class="koboSpan" id="kobo.602.2">We send that information through a control loop to the motors – turn left a bit and drive forward </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">a bit.</span></span></li>
<li><span class="koboSpan" id="kobo.604.1">We then check again, and the LEDs are closer to the center (40%) and the distance to the target is 2.9 feet or 90 cm. </span><span class="koboSpan" id="kobo.604.2">Our error signal is a bit less, and the distance is a bit less. </span><span class="koboSpan" id="kobo.604.3">We’ll have to</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.605.1"> develop a </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">scaling factor</span></strong><span class="koboSpan" id="kobo.607.1"> to determine how many pixels equate to how much </span><strong class="bold"><span class="koboSpan" id="kobo.608.1">turn rate</span></strong><span class="koboSpan" id="kobo.609.1">, which is measured as a percentage of full power. </span><span class="koboSpan" id="kobo.609.2">Since we are using a fixed camera and lens, this will be </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">a constant.</span></span></li>
<li><span class="koboSpan" id="kobo.611.1">Now we send a slower turn and a slower movement to the motors this update cycle. </span><span class="koboSpan" id="kobo.611.2">We end up exactly in the center and come to zero speed just as we touch the </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">docking station.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.613.1">For those people currently saying, </span><em class="italic"><span class="koboSpan" id="kobo.614.1">“But if you use a PID controller …”</span></em><span class="koboSpan" id="kobo.615.1">, yes, you are correct – you also know that I’ve just described a </span><em class="italic"><span class="koboSpan" id="kobo.616.1">P</span></em><span class="koboSpan" id="kobo.617.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.618.1">proportional</span></em><span class="koboSpan" id="kobo.619.1"> control scheme. </span><span class="koboSpan" id="kobo.619.2">We can add more bells and whistles to help prevent the robot from overshooting or undershooting the target </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.620.1">due to its own weight and inertia and to damp out oscillations caused by </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">those overshoots.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">PID controller</span></strong><span class="koboSpan" id="kobo.624.1"> is a </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.625.1">type of control system that uses three types of inputs to manage a closed-loop control</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.626.1"> system. </span><span class="koboSpan" id="kobo.626.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">proportional control</span></strong><span class="koboSpan" id="kobo.628.1"> uses a multiple of the detected error to drive </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">a control.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">For example, in our pot of water, we measure the error in the temperature. </span><span class="koboSpan" id="kobo.630.2">If the desired temperature is 100°C and we measure 90°C with our thermometer, then the error in the temperature is 10 °C. </span><span class="koboSpan" id="kobo.630.3">We need to add more heat by opening the valve in proportion to the temperature error. </span><span class="koboSpan" id="kobo.630.4">If the error is 0, the change in the value is 0. </span><span class="koboSpan" id="kobo.630.5">Let’s say that we try changing the value of the valve by 10% for a 10°C error. </span><span class="koboSpan" id="kobo.630.6">So we multiply 10°C by 0.01 to set our valve position to +0.1. </span><span class="koboSpan" id="kobo.630.7">This 0.01 value is</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.631.1"> our </span><em class="italic"><span class="koboSpan" id="kobo.632.1">P</span></em><span class="koboSpan" id="kobo.633.1"> term or </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.634.1">proportional constant</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">In our next sample, we see that the temperature of our pot is now 93°C and our error is 7°C. </span><span class="koboSpan" id="kobo.636.2">We change our valve position to +0.07, slightly less than before. </span><span class="koboSpan" id="kobo.636.3">We will probably find that by using this method, we will overshoot the desired temperature due to the hysteresis of the water – it takes a while for the water to heat up, creating a delay in the response. </span><span class="koboSpan" id="kobo.636.4">We will end up overheating the water and overshooting our desired temperature. </span><span class="koboSpan" id="kobo.636.5">One way to help prevent that is with the </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">D</span></strong><span class="koboSpan" id="kobo.638.1"> term of the PID controller, that is, a </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">derivative</span></strong><span class="koboSpan" id="kobo.640.1"> term. </span><span class="koboSpan" id="kobo.640.2">You remember that a derivative describes the slope of the line of a function – in this case, the temperature curve we measure. </span><span class="koboSpan" id="kobo.640.3">The </span><em class="italic"><span class="koboSpan" id="kobo.641.1">y</span></em><span class="koboSpan" id="kobo.642.1"> axis of our temperature graph is time, so we have </span><em class="italic"><span class="koboSpan" id="kobo.643.1">delta temperature/delta time</span></em><span class="koboSpan" id="kobo.644.1">. </span><span class="koboSpan" id="kobo.644.2">To add a </span><em class="italic"><span class="koboSpan" id="kobo.645.1">D</span></em><span class="koboSpan" id="kobo.646.1"> term to our controller, we also add in the difference between the error of the last sample and the error of this sample (</span><em class="italic"><span class="koboSpan" id="kobo.647.1">-10 – (-7) = -3</span></em><span class="koboSpan" id="kobo.648.1">). </span><span class="koboSpan" id="kobo.648.2">We add this to our control by multiplying this value times a constant, </span><em class="italic"><span class="koboSpan" id="kobo.649.1">D</span></em><span class="koboSpan" id="kobo.650.1">. </span><span class="koboSpan" id="kobo.650.2">The integral term is just the cumulative sum of the error multiplied by a constant we’ll call </span><em class="italic"><span class="koboSpan" id="kobo.651.1">I</span></em><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">We can modify the </span><em class="italic"><span class="koboSpan" id="kobo.653.1">P</span></em><span class="koboSpan" id="kobo.654.1">, </span><em class="italic"><span class="koboSpan" id="kobo.655.1">I</span></em><span class="koboSpan" id="kobo.656.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.657.1">D</span></em><span class="koboSpan" id="kobo.658.1"> constants to adjust (tune) our PID controller to provide the proper response for our control loop – with no overshoots, undershoots, or drifts. </span><span class="koboSpan" id="kobo.658.2">More explanation is available at </span><a href="https://jjrobots.com/pid/"><span class="koboSpan" id="kobo.659.1">https://jjrobots.com/pid/</span></a><span class="koboSpan" id="kobo.660.1">. </span><span class="koboSpan" id="kobo.660.2">The point of these examples is to point out the concept of control in a machine – we have to take measurements, compare them to our desired result, compute the error signal, and then make any corrections to the controls over and over many times a</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.661.1"> second, and doing that consistently is the concept of </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">real-time control.</span></span></p>
<h4><span class="koboSpan" id="kobo.663.1">Types of control loops</span></h4>
<p><span class="koboSpan" id="kobo.664.1">In order to perform </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.665.1">our control loop at a consistent time interval (or to use the proper term, deterministically), we have two ways of controlling our program </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.666.1">execution: </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">soft real time</span></strong><span class="koboSpan" id="kobo.668.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">hard real time</span></strong><span class="koboSpan" id="kobo.670.1">. </span><span class="koboSpan" id="kobo.670.2">Hard</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.671.1"> real-time control systems require assistance from the hardware of the computer – that is where the </span><em class="italic"><span class="koboSpan" id="kobo.672.1">hard</span></em><span class="koboSpan" id="kobo.673.1"> part of the title comes from. </span><span class="koboSpan" id="kobo.673.2">Hard real time generally</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.674.1"> requires a </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">real-time operating system</span></strong><span class="koboSpan" id="kobo.676.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.677.1">RTOS</span></strong><span class="koboSpan" id="kobo.678.1">) or complete control over all of the computer cycles in the processor. </span><span class="koboSpan" id="kobo.678.2">The problem we are faced with is that a computer running an operating system is constantly getting interrupted by other processes, chaining threads, switching contexts, and performing tasks. </span><span class="koboSpan" id="kobo.678.3">Your experience with desktop computers, or even smartphones, is that the same process, such as starting up a word processor program, always seems to take a different amount of time whenever you start </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">it up.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">This sort of behavior is intolerable in a real-time system where we need to know in advance exactly how long a process will take down to the microsecond. </span><span class="koboSpan" id="kobo.680.2">You can easily imagine the problems if we created an autopilot for an airliner that, instead of managing the aircraft’s direction and altitude, was constantly getting interrupted by disk drive access or network calls that played havoc with the control loops giving you a smooth ride or making a touchdown on </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">the runway.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">An RTOS system allows the programmers and developers to have complete control over when and how the processes execute and which routines are allowed to interrupt and for how long. </span><span class="koboSpan" id="kobo.682.2">Control loops in RTOS systems always take the exact same number of computer cycles (and thus time) every loop, which makes them reliable and dependable when the output is critical. </span><span class="koboSpan" id="kobo.682.3">It is important to know that in a hard real-time system, the hardware enforces timing constraints and makes sure that the computer resources are available when they </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">are needed.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">We can actually do hard real time in an Arduino microcontroller because it has no operating system and can only do one task at a time or run only one program at a time. </span><span class="koboSpan" id="kobo.684.2">Our robot will also have a more capable processor in the form of an Nvidia Nano running Linux. </span><span class="koboSpan" id="kobo.684.3">This computer, which has some real power, does a number of tasks simultaneously to support the operating system, run the network interface, send graphics to the output HDMI port, provide a user interface, and even support </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">multiple users.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">Soft real time is a bit more of a relaxed approach, and is more appropriate to our playroom-cleaning robot than a safety-critical hard real-time system – plus, RTOSs can be expensive (there are open source versions) and require special training for you. </span><span class="koboSpan" id="kobo.686.2">What we are going to do is treat our control loop as a feedback system. </span><span class="koboSpan" id="kobo.686.3">We will leave some extra room – say about 10% – at the end of each cycle to allow the operating system to do its work, which should leave us with a consistent control loop that executes at a constant time interval. </span><span class="koboSpan" id="kobo.686.4">Just like our control loop example that we just discussed, we will take a measurement, determine the error, and apply a correction to </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">each cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">We are not just worried about our update rate. </span><span class="koboSpan" id="kobo.688.2">We also must worry</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.689.1"> about </span><strong class="bold"><span class="koboSpan" id="kobo.690.1">jitter</span></strong><span class="koboSpan" id="kobo.691.1">, or random variability in the timing loop caused by the operating system getting interrupted and doing other things. </span><span class="koboSpan" id="kobo.691.2">An interrupt will cause our timing loop to take longer, causing a random jump in our</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.692.1"> cycle time. </span><span class="koboSpan" id="kobo.692.2">We have to design our control loops to handle a certain amount of jitter for soft real time, but these are comparatively </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">infrequent events.</span></span></p>
<h4><span class="koboSpan" id="kobo.694.1">Running a control loop</span></h4>
<p><span class="koboSpan" id="kobo.695.1">The process of running </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.696.1">a control loop is fairly simple in practice. </span><span class="koboSpan" id="kobo.696.2">We start by initializing our timer, which needs to be the high-resolution clock. </span><span class="koboSpan" id="kobo.696.3">We are writing our control loop in Python, so we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">time.time()</span></strong><span class="koboSpan" id="kobo.698.1"> function, which is specifically designed to measure our internal program timing performance (set frame rate, do loop, measure time, generate error, sleep for error, loop). </span><span class="koboSpan" id="kobo.698.2">Each time we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">time.time()</span></strong><span class="koboSpan" id="kobo.700.1">, we get a floating-point number, which is the number of seconds from the Unix clock and has microsecond resolution on the </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">Nvidia Nano.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">The concept for this process is to divide our processing into a set of fixed time intervals we will </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.703.1">call </span><strong class="bold"><span class="koboSpan" id="kobo.704.1">frames</span></strong><span class="koboSpan" id="kobo.705.1">. </span><span class="koboSpan" id="kobo.705.2">Everything we do will fit within an integral number of frames. </span><span class="koboSpan" id="kobo.705.3">Our basic running speed will process 30 </span><strong class="bold"><span class="koboSpan" id="kobo.706.1">frames per second</span></strong><span class="koboSpan" id="kobo.707.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.708.1">fps</span></strong><span class="koboSpan" id="kobo.709.1">). </span><span class="koboSpan" id="kobo.709.2">That is how fast we will be updating the robot’s position estimate, reading sensors, and sending commands to motors. </span><span class="koboSpan" id="kobo.709.3">We have other functions that run slower than the 30 frames, so we can divide them between frames in even multiples. </span><span class="koboSpan" id="kobo.709.4">Some functions run every frame (30 fps) and are called and executed </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">every frame.</span></span></p>
<p><span class="koboSpan" id="kobo.711.1">Let’s say that we have a sonar sensor that can only update 10 times a second. </span><span class="koboSpan" id="kobo.711.2">We call the </span><em class="italic"><span class="koboSpan" id="kobo.712.1">read sonar</span></em><span class="koboSpan" id="kobo.713.1"> function every third frame. </span><span class="koboSpan" id="kobo.713.2">We assign all our functions to be some multiple of our basic 30 fps frame rate, so we have 30, 15, 10, 7.5, 6, 5, 4.28, 2, and 1 fps if we call the functions every frame, every second frame, every third frame, and so on. </span><span class="koboSpan" id="kobo.713.3">We can even do less than 1 fps – a function called every 60 frames executes once every </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">2 seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">The tricky bit is we </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.716.1">need to make sure that each process fits into one frame time – which is 1/30 of a second or 0.033 seconds or 33 milliseconds. </span><span class="koboSpan" id="kobo.716.2">If the process takes longer than that, we have to either divide it up into parts or run it in a separate thread or program where we can start the process in one frame and get the result in another. </span><span class="koboSpan" id="kobo.716.3">It is also important to try and balance the frames so that not all processing lands in the same frame. </span><span class="koboSpan" id="kobo.716.4">The following figure shows a task scheduling system based on a 30 fps basic rate. </span><span class="koboSpan" id="kobo.716.5">Here, we have four tasks to take care of: task </span><em class="italic"><span class="koboSpan" id="kobo.717.1">A</span></em><span class="koboSpan" id="kobo.718.1"> runs at 15 fps, task </span><em class="italic"><span class="koboSpan" id="kobo.719.1">B</span></em><span class="koboSpan" id="kobo.720.1"> runs at 6 fps (every five frames), task </span><em class="italic"><span class="koboSpan" id="kobo.721.1">C</span></em><span class="koboSpan" id="kobo.722.1"> runs at 10 fps (every three frames), and task </span><em class="italic"><span class="koboSpan" id="kobo.723.1">D</span></em><span class="koboSpan" id="kobo.724.1"> runs at 30 fps (</span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">every frame):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.726.1"><img alt="Figure 1.7 – Frame-based task schedule" src="image/B19846_01_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.727.1">Figure 1.7 – Frame-based task schedule</span></p>
<p><span class="koboSpan" id="kobo.728.1">Our first pass (the top of the figure) at the schedule has all four tasks landing on the same frame at frames 1, 13, and 25. </span><span class="koboSpan" id="kobo.728.2">We can improve the balance of the load on the control program if we delay the start of task </span><em class="italic"><span class="koboSpan" id="kobo.729.1">B</span></em><span class="koboSpan" id="kobo.730.1"> on the second frame as shown in the bottom half of </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">the diagram.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">This is akin to how measures in music work, where a measure is a certain amount of time, and different</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.733.1"> notes have different intervals – one whole note can only appear once per measure, a half note can appear twice, all the way down to 64</span><span class="superscript"><span class="koboSpan" id="kobo.734.1">th</span></span><span class="koboSpan" id="kobo.735.1"> notes. </span><span class="koboSpan" id="kobo.735.2">Just like a composer makes sure that each measure has the right number of beats, we can make sure that our control loop has a balanced measure of processes to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">each frame.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">Let’s start by writing a little program to control our timing loop and to let you play with </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">these principles.</span></span></p>
<p><span class="koboSpan" id="kobo.739.1">This is exciting – our first bit of coding together. </span><span class="koboSpan" id="kobo.739.2">This program just demonstrates the timing control loop we are going to use in the main robot control program and is here to let you play around with some parameters and see the results. </span><span class="koboSpan" id="kobo.739.3">This is the simplest version I think is possible of a soft time-controlled loop, so feel free to improve and embellish it. </span><span class="koboSpan" id="kobo.739.4">I’ve made you a flowchart to help you understand this a </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">little better:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.741.1"><img alt="Figure 1.8 – Flowchart of soft real-time controller" src="image/B19846_01_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.742.1">Figure 1.8 – Flowchart of soft real-time controller</span></p>
<p><span class="koboSpan" id="kobo.743.1">Let’s look more </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.744.1">closely at the terms used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">preceding diagram:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.746.1">FrameTime</span></strong><span class="koboSpan" id="kobo.747.1">: The time we have allocated to execute one iteration of </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">the loop</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.749.1">StartTime</span></strong><span class="koboSpan" id="kobo.750.1">: When the </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">loop/frame begins</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.752.1">Do a Bunch of Math</span></strong><span class="koboSpan" id="kobo.753.1">: The program that you </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">are managing</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.755.1">StopTime</span></strong><span class="koboSpan" id="kobo.756.1">: When the </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">frame completes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.758.1">Remaining Time</span></strong><span class="koboSpan" id="kobo.759.1">: The difference between the elapsed time and the desired </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">frame time</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.761.1">Elapsed Time</span></strong><span class="koboSpan" id="kobo.762.1">: The time it takes to actually run through the </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">loop once</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.764.1">Frame Sleep Time</span></strong><span class="koboSpan" id="kobo.765.1">: We use </span><strong class="bold"><span class="koboSpan" id="kobo.766.1">Remaining Time</span></strong><span class="koboSpan" id="kobo.767.1"> to tell the computer to sleep so that the frame takes exactly the amount of time </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">we want.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.769.1">Now we’ll begin with coding. </span><span class="koboSpan" id="kobo.769.2">This is pretty straightforward Python code – we won’t get fancy </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">until later:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.771.1">We start by importing our libraries. </span><span class="koboSpan" id="kobo.771.2">It is not surprising that we start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">time</span></strong><span class="koboSpan" id="kobo.773.1"> module. </span><span class="koboSpan" id="kobo.773.2">We also will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">mean</span></strong><span class="koboSpan" id="kobo.775.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">numpy</span></strong><span class="koboSpan" id="kobo.777.1"> (Python numerical analysis) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">matplotlib</span></strong><span class="koboSpan" id="kobo.779.1"> to draw our graph at the end. </span><span class="koboSpan" id="kobo.779.2">We will also be doing</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.780.1"> some math calculations to simulate our processing and create a load on the </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">frame rate:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.782.1">
import time
from numpy import mean
import matplotlib.pyplot as plt
import math
#</span></pre></li> <li><span class="koboSpan" id="kobo.783.1">Now we have some parameters to control our test. </span><span class="koboSpan" id="kobo.783.2">This is where you can experiment with different timings. </span><span class="koboSpan" id="kobo.783.3">Our basic control is </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">FRAMERATE</span></strong><span class="koboSpan" id="kobo.785.1"> – how many updates per second do we want to try? </span><span class="koboSpan" id="kobo.785.2">Let’s start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">30</span></strong><span class="koboSpan" id="kobo.787.1">, as we did in the example we </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">discussed earlier:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.789.1">
# set our frame rate - how many cycles per second to run our loop?
</span><span class="koboSpan" id="kobo.789.2">FRAMERATE = 30
# how long does each frame take in seconds?
</span><span class="koboSpan" id="kobo.789.3">FRAME = 1.0/FRAMERATE
# initialize myTimer
# This is one of our timer variables where we will store the clock time from the operating system.
</span><span class="koboSpan" id="kobo.789.4">myTimer = 0.0</span></pre></li> <li><span class="koboSpan" id="kobo.790.1">The duration of the test is set by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">counter</span></strong><span class="koboSpan" id="kobo.792.1"> variable. </span><span class="koboSpan" id="kobo.792.2">The time the test will take is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">FRAME</span></strong><span class="koboSpan" id="kobo.794.1"> time times the number of cycles in </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">counter</span></strong><span class="koboSpan" id="kobo.796.1">. </span><span class="koboSpan" id="kobo.796.2">In our example, 2,000 frames divided by 30 fps is 66.6 seconds, or a bit over a minute to run </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">the test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.798.1">
# how many cycles to test? </span><span class="koboSpan" id="kobo.798.2">counter*FRAME = runtime in seconds
counter = 2000</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.799.1">We will be controlling our timing loop in </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">two ways:</span></span></p><ul><li><span class="koboSpan" id="kobo.801.1">We will first measure the amount of time it takes to perform the calculations for this frame. </span><span class="koboSpan" id="kobo.801.2">We have a stub of a program with some trigonometry functions we will call to put a load on the computer. </span><span class="koboSpan" id="kobo.801.3">Robot control functions, such as computing the angles needed in a robot arm, need lots of </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.802.1">trig to work. </span><span class="koboSpan" id="kobo.802.2">This is available from </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">import math</span></strong><span class="koboSpan" id="kobo.804.1"> in the header of </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">the program.</span></span></li></ul></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.806.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.807.1">We will measure the time for our control function to run, which will take some part of our frame. </span><span class="koboSpan" id="kobo.807.2">We then compute how much of our frame remains, and tell the computer to sleep this process for the rest of the time. </span><span class="koboSpan" id="kobo.807.3">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">sleep</span></strong><span class="koboSpan" id="kobo.809.1"> function releases the computer to go and take care of other business in the operating system, and is a better way to mark time rather than running a tight loop of some sort to waste the rest of our </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">frame time.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.811.1">The second way we control our loop is by measuring the complete frame – compute time plus rest time – and looking to see whether we are over or under our frame time. </span><span class="koboSpan" id="kobo.811.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">TIME_CORRECTION</span></strong><span class="koboSpan" id="kobo.813.1"> for this function to trim our sleep time to account for variability in the sleep function and any delays getting back from the </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">operating system:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.815.1">
# factor for our timing loop computations
TIME_CORRECTION= 0.0</span></pre></li> </ul>
<ol>
<li value="4"><span class="koboSpan" id="kobo.816.1">We will collect some data to draw a jitter graph at the end of the program. </span><span class="koboSpan" id="kobo.816.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">dataStore</span></strong><span class="koboSpan" id="kobo.818.1"> structure for this. </span><span class="koboSpan" id="kobo.818.2">Let’s put a header on the screen to tell you the program has begun, since it takes a while </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">to finish:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.820.1">
# place to store data
dataStore = []
# Operator information ready to go
# We create a heading to show that the program is starting its test
print "START COUNTING: FRAME TIME", FRAME, "RUN TIME:",FRAME*counter</span></pre></li> <li><span class="koboSpan" id="kobo.821.1">In this step, we </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.822.1">are going to set up some variables to measure our timing. </span><span class="koboSpan" id="kobo.822.2">As we mentioned, the objective is to have a bunch of compute frames, each the same length. </span><span class="koboSpan" id="kobo.822.3">Each frame has two parts: a </span><strong class="bold"><span class="koboSpan" id="kobo.823.1">compute</span></strong><span class="koboSpan" id="kobo.824.1"> part, where we are doing work, and a </span><strong class="bold"><span class="koboSpan" id="kobo.825.1">sleep</span></strong><span class="koboSpan" id="kobo.826.1"> period, when we are allowing the computer to do other things. </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">myTime</span></strong><span class="koboSpan" id="kobo.828.1"> is the </span><em class="italic"><span class="koboSpan" id="kobo.829.1">top of frame</span></em><span class="koboSpan" id="kobo.830.1"> time, when the frame begins. </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">newTime</span></strong><span class="koboSpan" id="kobo.832.1"> is the end of the work period timer. </span><span class="koboSpan" id="kobo.832.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">masterTime</span></strong><span class="koboSpan" id="kobo.834.1"> to compute the total time the program </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">is running:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.836.1">
# initialize the precision clock
 myTime = newTime = time.time()
 # save the starting time for later
 masterTime=myTime
 # begin our timing loop
 for ii in range(counter):</span></pre></li> <li><span class="koboSpan" id="kobo.837.1">This section is our </span><strong class="bold"><span class="koboSpan" id="kobo.838.1">payload</span></strong><span class="koboSpan" id="kobo.839.1"> – the section of the code doing the work. </span><span class="koboSpan" id="kobo.839.2">This might be an arm angle calculation, a state estimate, or a command interpreter. </span><span class="koboSpan" id="kobo.839.3">We’ll stick in some trig functions and some math to get the CPU to do some work for us. </span><span class="koboSpan" id="kobo.839.4">Normally, this </span><em class="italic"><span class="koboSpan" id="kobo.840.1">working</span></em><span class="koboSpan" id="kobo.841.1"> section is the majority of our frame, so let’s repeat these math terms </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">1,000 times:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.843.1">
    # we start our frame - this represents doing some detailed 
    math calculations
    # this is just to burn up some CPU cycles
    for jj in range(1000):
          x = 100
          y = 23 + ii
          z = math.cos(x)
          z1 = math.sin(y)
    #
    # read the clock after all compute is done
    # this is our working frame time
    #</span></pre></li> <li><span class="koboSpan" id="kobo.844.1">Now we read the </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.845.1">clock to find the working time. </span><span class="koboSpan" id="kobo.845.2">We can now compute how long we need to sleep the process before the next frame. </span><span class="koboSpan" id="kobo.845.3">The important part is that </span><em class="italic"><span class="koboSpan" id="kobo.846.1">working time + sleep time = frame time</span></em><span class="koboSpan" id="kobo.847.1">. </span><span class="koboSpan" id="kobo.847.2">I’ll call </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">this </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">timeError</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.851.1">
    newTime = time.time()
    # how much time has elapsed so far in this frame
    # time = UNIX clock in seconds
    # so we have to subract our starting time to get the elapsed
    time
    myTimer = newTime-myTime
    # what is the time left to go in the frame?
</span><span class="koboSpan" id="kobo.851.2">    timeError = FRAME-myTimer</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.852.1">We carry forward some information from the previous frame here. </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">TIME_CORRECTION</span></strong><span class="koboSpan" id="kobo.854.1"> is our adjustment for any timing errors in the previous frame time. </span><span class="koboSpan" id="kobo.854.2">We initialized it earlier to zero before we started our loop so we don’t get an undefined variable error here. </span><span class="koboSpan" id="kobo.854.3">We also do some range checking because we can get some large jitters in our timing caused by the operating system that can </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.855.1">cause our sleep timer to crash if we try to sleep a negative amount </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">of time:</span></span></p></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.857.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.858.1">We use the Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">max</span></strong><span class="koboSpan" id="kobo.860.1"> function as a quick way to clamp the value of sleep time to be zero or greater. </span><span class="koboSpan" id="kobo.860.2">It returns the greater of two arguments. </span><span class="koboSpan" id="kobo.860.3">The alternative is something like </span><em class="italic"><span class="koboSpan" id="kobo.861.1">if a&lt; 0 : </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.862.1">a=0</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.864.1">
    # OK time to sleep
    # the TIME CORRECTION helps account for all of this clock
    reading
    # this also corrects for sleep timer errors
    # we are using a porpotional control to get the system to
    converge
    # if you leave the divisor out, then the system oscillates
    out of control
    sleepTime = timeError + (TIME_CORRECTION/2.0)
    # quick way to eliminate any negative numbers
    # which are possible due to jitter
    # and will cause the program to crash
    sleepTime=max(sleepTime,0.0)</span></pre> <ol>
<li value="8"><span class="koboSpan" id="kobo.865.1">So, here is our actual sleep command. </span><span class="koboSpan" id="kobo.865.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">sleep</span></strong><span class="koboSpan" id="kobo.867.1"> command does not always provide a precise time interval, so we will be checking </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">for errors:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.869.1">
    # put this process to sleep
    time.sleep(sleepTime)</span></pre></li> <li><span class="koboSpan" id="kobo.870.1">This is the time correction section. </span><span class="koboSpan" id="kobo.870.2">We figure out how long our frame time was in total (working and sleeping) and subtract it from what we want the frame time to be (</span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">FrameTime</span></strong><span class="koboSpan" id="kobo.872.1">). </span><span class="koboSpan" id="kobo.872.2">Then we set our time correction to that value. </span><span class="koboSpan" id="kobo.872.3">I’m also going to save the measured frame time into a data store so we can graph how we did later using </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">matplotlib</span></strong><span class="koboSpan" id="kobo.874.1">. </span><span class="koboSpan" id="kobo.874.2">This technique is one of Python’s more </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">useful features:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.876.1">
    #print timeError,TIME_CORRECTION
    # set our timer up for the next frame
    time2=time.time()
    measuredFrameTime = time2-myTime
    ##print measuredFrameTime,
    TIME_CORRECTION=FRAME-(measuredFrameTime)
    dataStore.append(measuredFrameTime*1000)
    #TIME_CORRECTION=max(-FRAME,TIME_CORRECTION)
    #print TIME_CORRECTION
    myTime = time.time()</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.877.1">This </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.878.1">completes the looping section of the program. </span><span class="koboSpan" id="kobo.878.2">This example does 2,000 cycles of 30 frames a second and finishes in 66.6 seconds. </span><span class="koboSpan" id="kobo.878.3">You can experiment with different cycle times and </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">frame rates.</span></span></p></li> <li><span class="koboSpan" id="kobo.880.1">Now that we have completed the program, we can make a little report and a graph. </span><span class="koboSpan" id="kobo.880.2">We print out the frame time and total runtime, compute the average frame time (total time/counter), and display the average error we encountered, which we can get by averaging the data </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">dataStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.884.1">
# Timing loop test is over - print the results
#
# get the total time for the program
endTime = time.time() - masterTime
# compute the average frame time by dividing total time by our number of frames
avgTime = endTime / counter
#print report
 print "FINISHED COUNTING"
 print "REQUESTED FRAME TIME:",FRAME,"AVG FRAME TIME:",avgTime
 print "REQUESTED TOTAL TIME:",FRAME*counter,"ACTUAL TOTAL TIME:", endTime
 print "AVERAGE ERROR",FRAME-avgTime, "TOTAL_ERROR:",(FRAME*counter) - endTime
 print "AVERAGE SLEEP TIME: ",mean(dataStore),"AVERAGE RUN TIME",(FRAME*1000)-mean(dataStore)
 # loop is over, plot result
 # this lets us see the "jitter" in the result
 plt.plot(dataStore)
 plt.show()</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.885.1">The results from our</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.886.1"> program are shown in the following code block. </span><span class="koboSpan" id="kobo.886.2">Note that the average error is just 0.00018 of a second, or 0.18 milliseconds out of a frame of </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">33 milliseconds:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.888.1">START COUNTING: FRAME TIME 0.0333333333333 RUN TIME: 66.6666666667
FINISHED COUNTING
REQUESTED FRAME TIME: 0.0333333333333 AVG FRAME TIME: 0.0331549999714
REQUESTED TOTAL TIME: 66.6666666667 ACTUAL TOTAL TIME: 66.3099999428
AVERAGE ERROR 0.000178333361944 TOTAL_ERROR: 0.356666723887
AVERAGE SLEEP TIME: 33.1549999714 AVERAGE RUN TIME 0.178333361944</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.889.1">The following figure shows the timing graph of </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">our program:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.891.1"><img alt="Figure 1.9 – Timing graph of our program" src="image/B19846_01_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.892.1">Figure 1.9 – Timing graph of our program</span></p>
<p><span class="koboSpan" id="kobo.893.1">The </span><em class="italic"><span class="koboSpan" id="kobo.894.1">spikes</span></em><span class="koboSpan" id="kobo.895.1"> in the image are</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.896.1"> jitter caused by operating system interrupts. </span><span class="koboSpan" id="kobo.896.2">You can see the program controls the frame time in a fairly narrow range. </span><span class="koboSpan" id="kobo.896.3">If we did not provide control, the frame time would get greater and greater as the program executed. </span><span class="koboSpan" id="kobo.896.4">The graph shows that the frame time stays in a narrow range that keeps returning to the </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">correct value.</span></span></p>
<p><span class="koboSpan" id="kobo.898.1">Now that we have exercised our programming muscles, we can apply this knowledge to the main control loop for our robot with soft real-time control. </span><span class="koboSpan" id="kobo.898.2">This control loop has two </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">primary functions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.900.1">Respond to commands from the </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">control station</span></span></li>
<li><span class="koboSpan" id="kobo.902.1">Interface to the robot’s motors and sensors in the </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">Arduino Mega</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.904.1">We will discuss this in detail in </span><a href="B19846_07.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.905.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.906.1">.</span></span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.907.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.908.1">In this chapter, we introduced the subject of AI, which will be emphasized throughout this book. </span><span class="koboSpan" id="kobo.908.2">We identified the main difference between an AI robot and a </span><em class="italic"><span class="koboSpan" id="kobo.909.1">regular</span></em><span class="koboSpan" id="kobo.910.1"> robot, which is that an AI robot may be nondeterministic. </span><span class="koboSpan" id="kobo.910.2">This is to say it may have a different response to the same stimulus, due to learning. </span><span class="koboSpan" id="kobo.910.3">We introduced the problem we will use throughout the book, which is picking up toys in a playroom and putting them into a toy box. </span><span class="koboSpan" id="kobo.910.4">Next, we discussed two critical tools for AI robotics: the OODA loop, which provides a model for how our robot makes decisions, and the soft real-time control loop, which manages and controls the speed of execution of our program. </span><span class="koboSpan" id="kobo.910.5">We applied these techniques in a timing loop demonstration and began to develop our main robot </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">control program.</span></span></p>
<p><span class="koboSpan" id="kobo.912.1">In the next chapter, we will teach the robot to recognize toys – the objects we want the robot to pick up and put away. </span><span class="koboSpan" id="kobo.912.2">We will use computer vision with a video camera to find and recognize the toys left on </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">the floor.</span></span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.914.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.915.1">What does the acronym </span><em class="italic"><span class="koboSpan" id="kobo.916.1">PID</span></em><span class="koboSpan" id="kobo.917.1"> stand for? </span><span class="koboSpan" id="kobo.917.2">Is this considered an AI </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">software method?</span></span></li>
<li><span class="koboSpan" id="kobo.919.1">What is the Turing test? </span><span class="koboSpan" id="kobo.919.2">Do you feel this is a valid method of </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">assessing AI?</span></span></li>
<li><span class="koboSpan" id="kobo.921.1">Why do you think robots have a problem with negative obstacles such as stairs </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">and potholes?</span></span></li>
<li><span class="koboSpan" id="kobo.923.1">In the OODA loop, what does the </span><em class="italic"><span class="koboSpan" id="kobo.924.1">Orient</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.925.1">step do?</span></span></li>
<li><span class="koboSpan" id="kobo.926.1">From the discussion of Python and its advantages, compute the following. </span><span class="koboSpan" id="kobo.926.2">Your program needs 50 changes tested. </span><span class="koboSpan" id="kobo.926.3">Assuming each change requires a recompile step and one run to test, a C Make compile takes 450 seconds and a Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">run</span></strong><span class="koboSpan" id="kobo.928.1"> command takes 3 seconds. </span><span class="koboSpan" id="kobo.928.2">How much time do you sit idle waiting on </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">the compiler?</span></span></li>
<li><span class="koboSpan" id="kobo.930.1">What does RTOS </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">stand for?</span></span></li>
<li><span class="koboSpan" id="kobo.932.1">Your robot has the following scheduled tasks: telemetry at 10 Hz, GPS at 5 Hz, inertial measurements at 50 Hz, and motor control at 20 Hz. </span><span class="koboSpan" id="kobo.932.2">At what frequency would you schedule the base task, and what intervals would you use for the slower tasks (i.e., 10 Hz base, motors every three frames, telemetry every two </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">frames, etc.)?</span></span></li>
<li><span class="koboSpan" id="kobo.934.1">Given that a frame rate scheduler has the fastest task at 20 fps, how would you schedule a task that needs to run at 7 fps? </span><span class="koboSpan" id="kobo.934.2">How about one that runs at </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">3.5 fps?</span></span></li>
<li><span class="koboSpan" id="kobo.936.1">What is a blocking call function? </span><span class="koboSpan" id="kobo.936.2">Why is it bad to use blocking calls in a real-time system like </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">a robot?</span></span></li>
</ol>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.938.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.939.1">You can refer to the following resources for </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">further details:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.941.1">Effective Robotics Programming with ROS – Third Edition</span></em><span class="koboSpan" id="kobo.942.1">, by Anil Mahtani, Luis Sanchez, and Enreque Fernandez Perdomo, Packt </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">Publishing, 2016</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.944.1">Introduction to AI Robotics – Second Edition</span></em><span class="koboSpan" id="kobo.945.1"> by Robin R. </span><span class="koboSpan" id="kobo.945.2">Murphy, Bradford </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">Books, 2019</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.947.1">Real-Time scheduling: from hard to soft real-time systems</span></em><span class="koboSpan" id="kobo.948.1">, a whitepaper by Palopoli Lipari, </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">2015 (</span></span><a href="https://arxiv.org/pdf/1512.01978.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.950.1">https://arxiv.org/pdf/1512.01978.pdf</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.951.1">)</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.952.1">Boyd: The Fighter Pilot Who Changed the Art of War</span></em><span class="koboSpan" id="kobo.953.1">, by Robert Coram, Little, Brown and </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">Company, 2002</span></span></li>
</ul>
</div>
</body></html>