- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving Agent Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a strong grip on the basics of the Unreal Engine pathfinding
    system, it’s time to get deeper and start delving into the intricate workings
    of enhancing the agent Navigation System.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will discover how to improve your nav mesh generation
    and agent movement: starting from dynamically generated meshes, going through
    querying the environment, up until avoiding other agents efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have some brand-new skills to make your
    levels more engaging and interesting. This knowledge will serve as a fundamental
    building block in guiding your path toward creating sophisticated games, ultimately
    enhancing your skills as an AI game programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating navigation meshes at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Influencing navigation with query filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing agent avoidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in this book’s
    companion project repository at [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files corresponding to the end of the last chapter by clicking
    on the **Unreal Agility Arena –** **Chapter 04** **-** **End** link.
  prefs: []
  type: TYPE_NORMAL
- en: Generating navigation meshes at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s continue our short novel started in [*Chapter 4*](B31016_04.xhtml#_idTextAnchor073)
    , *Setting Up a* *Navigation Mesh* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the secret research laboratory, a groundbreaking experiment was underway.
    The artificial intelligence dummy puppets, developed by Dr. Markus and Professor
    Viktoria, were primed for a quest: equipped with advanced pathfinding systems,
    the puppets were cleverly placed in the lab’s complex network of corridors and*
    *interconnected rooms.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*They faced simulated construction zones, unexpected barriers, and even simulated
    distractions that obstructed their path. However, armed with their state-of-the-art
    AI capabilities, the puppets swiftly adapted to the changing circumstances, employing
    their ingenuity to find alternative routes and skillfully navigate through the
    intricate layout of* *the laboratory.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with nav meshes, chances are you will sooner or later have
    objects that will be moving around and will cause the agent’s path to the target
    to change.
  prefs: []
  type: TYPE_NORMAL
- en: This is why having a static nav mesh generation will become useless; you will
    need some kind of system that will update the nav mesh at runtime. This is why
    Unreal Engine provides more than one method for generating such meshes.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [*Chapter 3*](B31016_03.xhtml#_idTextAnchor058) , *Presenting
    the Unreal Engine Navigation System* , the generation method can be changed from
    **Project Settings** or the **Recast Nav Mesh** actor in a level; as we need to
    change the nav mesh generation just for this level, we will be selecting the second
    option.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to create a level for our puppet agent to walk on!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create this gym, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select **File** | **New Level** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/LevelInstances** folder and drag an instance of **LI_Lighting**
    inside your level; set its transform **Location** value to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/PackedLevelActors** folder and drag an instance of **PLA_Lab_02**
    inside your level; set its transform **Location** value to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the level in the **Maps** folder and name it **Gym_NavMesh_04** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This gym has a block of stairs along with a detached platform, as depicted
    in *Figure 5* *.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The gym](img/B31016_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The gym
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the nav mesh along with the agent and the target point:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Nav Mesh Bounds Volume** actor and set its boundaries so it covers the
    whole level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **NS_Target** Niagara system at the top of the isolated platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the **BP_NavMeshAgent** Blueprint on the blue tile and set the **Target
    Actor** property value to **NS_Target** . The level should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The gym with the nav mesh](img/B31016_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The gym with the nav mesh
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are using a level that is slightly more complex than those presented
    in the previous chapter, you may experience a mesh generation that is slightly
    different from the one depicted in my screenshot; the stairs nav mesh may seem
    detached from the rest, or you may experience some other issue. *Figure 5* *.3*
    shows a typical scenario you may encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Broken nav mesh](img/B31016_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Broken nav mesh
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this type of problem, you will need to tweak the **Recast Nav Mesh**
    actor settings a bit. As an example, you may try to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the **Default Cell Height** property value to **40.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Agent Radius** to **70.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first value will make the stairs navigable area connect to the rest of the
    level, while the second one will add some more padding to the border of the mesh
    so as to avoid an agent walking too close to the edges. Just play around with
    the values a bit until you get your desired result.
  prefs: []
  type: TYPE_NORMAL
- en: If you test the level right now, you will notice that the agent will try to
    reach the target point but it will get stuck at the base of the detached platform;
    obviously, there isn’t a route to the destination, and your little agent may not
    make it all the way there, but it will give its best shot to get as close as it
    can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try to add some obstacles around the level to force your agent to climb
    the stairs – something like *Figure 5* *.4* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The gym with some obstacles](img/B31016_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The gym with some obstacles
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the level, the agent will stop at the very first step of the stairs;
    this is happening because the step height is too high for the poor fellow! To
    solve this, open the **BP_NavMeshAgent** Blueprint, and in the **Details** panel,
    look for the **Character Movement: Walking** category and set the **Max Step Height**
    value to **55.0** .'
  prefs: []
  type: TYPE_NORMAL
- en: This will allow the agent to take higher steps and climb the stairs. Test the
    level again and you should see the agent climbing the stairs and stopping at the
    very edge of them. The journey to the ultimate destination appears to be quite
    a challenge for our little friend!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s help it out by adding a pathway to the isolated platform, where the target
    point is located.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a moving platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make our agent reach its target point, we are going to add a moving platform;
    this will allow us to create a dynamically generated nav mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To do this, we will start with a static mesh and make it a Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Content Drawer** , open the **KayKit/ProtorypeBits/Models** folder and
    drag a **Primitive_Cube_Primitive_Cube** instance into the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Location** attribute to **(380.0, 50.0, 60.0)** so that it connects
    the staircase and the isolated yellow platforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Mobility** of this actor to **Movable** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this actor selected, convert it into a Blueprint by clicking the **Convert
    to** **Blueprint** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The Convert to Blueprint button](img/B31016_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The Convert to Blueprint button
  prefs: []
  type: TYPE_NORMAL
- en: Save the Blueprint in the **Blueprints** folder and name it **BP_MovingPlatform**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Blueprint by double-clicking the asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now going to add some code logic, in order to make it move.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the **BP_MovingPlatform** Blueprint open, start doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable of the **Vector** type and name it **StartLocation** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new variable of the **Float** type and name it **VerticalOffset** .
    From the **Details** panel, check the **Instance** **Editable** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These two variables will store the initial position of the platform and the
    vertical distance it will cover while moving, respectively. The second one has
    also been made editable from the level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, in **Event Graph** , perform the following steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a **Set Start Location** node and connect its incoming execution pin to
    the outgoing execution pin of the **Event Begin** **Play** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get Actor Location** node and connect its **Return Value** outgoing
    pin to the **Start Location** incoming pin of the previously added setter node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing execution pin of the **Set Start Location** node, add a **Timeline**
    node and double-click on it to start editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This part of the code stores the platform’s initial position and initializes
    a timeline to set up the platform animation. The code so far is shown in *Figure
    5* *.6* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The first part of the graph](img/B31016_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The first part of the graph
  prefs: []
  type: TYPE_NORMAL
- en: 'The timeline is going to be a simple sinusoidal curve that will control the
    vertical offset of the platform. To create the curve, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **+ Track** button and, from the dropdown menu, select **Add** **Float
    Track** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the track **Alpha** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Length** value of the curve to **15.00** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Loop** button to make the **Timeline** repeat indefinitely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the curve graph, add three keys by right-clicking and selecting the **Add
    key** option. Set the keys’ values, respectively, to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Time** to **0.0** and **Value** to **0.0** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time** to **7.5** and **Value** to **1.0** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time** to **15.0** and **Value** to **0.0** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right-click on each key and set the **KEY INTERPOLATION** value to **Auto**
    ; this will make the curve sinusoidal and not linear. The resulting curve is shown
    in *Figure 5* *.7* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Timeline curve](img/B31016_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Timeline curve
  prefs: []
  type: TYPE_NORMAL
- en: 'Get back to **Event Graph** and you should notice that the **Timeline** node
    now has an **Alpha** outgoing pin; we will use it to control the vertical position
    of the platform. Start doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Get Vertical** **Offset** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get Start Location** node; right-click on its outgoing pin and select
    **Split Struct Pin** to expose the **X** , **Y** , and **Z** pins of the structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Multiply** node and connect its two incoming pins to the **Vertical
    Offset** outgoing pin and to the **Alpha** outgoing pin of **Timeline** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **Add** node and connect its two incoming pins to the outgoing pin of
    the **Multiply** node and the outgoing **Start Location Z** pin of the **Get Start**
    **Location** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Set Actor Location** node to the graph, connect its incoming execution
    pin to the outgoing execution pin of the **Timeline** node, and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **New Location** incoming pin and select **Split Struct Pin**
    to expose the **X** , **Y** , and **Z** pins of the structure.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the incoming **New Location X** pin to the outgoing **Start Location
    X** pin of the **Get Start** **Location** node.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the incoming **New Location Y** pin to the outgoing **Start Location
    Y** pin of the **Get Start** **Location** node.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the incoming **New Location Z** pin to the outgoing pin of the **Add**
    node. The result of this part of the graph is shown in *Figure 5* *.8* :'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The second part of the graph](img/B31016_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The second part of the graph
  prefs: []
  type: TYPE_NORMAL
- en: Although quite lengthy, this code is pretty straightforward; it simply uses
    the **Timeline** node to compute an offset over time and applies it to the platform’s
    **Z** position. At runtime, the platform will keep going up and down, creating
    a passage to the target point once every 15 seconds – that is, the duration of
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you simulate the gym right now – with the nav mesh visible – something weird
    will happen; although the platform will be moving up and down, the nav mesh will
    stay as originally generated, leaving a floating passage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Static generation](img/B31016_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Static generation
  prefs: []
  type: TYPE_NORMAL
- en: This issue is happening because the nav mesh is generated statically and won’t
    be changed at runtime; the poor little fellow will drop off while trying to reach
    its target point, believing that a passage exists!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fix this immediately by making the nav mesh dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Making the nav mesh dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated at the beginning of this section, we are going to set the mesh runtime
    generation active just for this level, so we need to change the **Recast Nav Mesh**
    actor. To do this, select the **Recast Nav Mesh** actor and, in the **Details**
    panel, locate the **Runtime** category. Set the **Runtime Generation** dropdown
    value to **Dynamic** .
  prefs: []
  type: TYPE_NORMAL
- en: If you test the gym, you will now see the nav mesh updating at regular intervals
    and the passage will be interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Dynamic generation](img/B31016_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Dynamic generation
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that the agent will stop at the edge of the stairs platform
    and won’t go on when the moving platform creates the passage. To fix this small
    issue, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **BP_NavMeshAgent** and disconnect the **Event** **BeginPlay** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Move to Actor** incoming execution pin to the outgoing execution
    pin of the **Event** **Tick** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Class Defaults** tab and set the **Tick Interval (secs)** attribute
    to **0.5** , to make the update a bit sparser. The updated Blueprint is shown
    in *Figure 5* *.11* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Updated Blueprint](img/B31016_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Updated Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: What we have done here is pretty simple; instead of executing the code once
    at the start of the game, we set it to be executed once every tick – set to half
    a second – in order to keep on setting the final destination. This may not be
    the most performance-efficient solution, but it should work well for our small
    prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that updating a nav mesh at runtime is heavy on computation; this
    means that you should use this feature only when necessary and stick to the static
    generation most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have mastered creating dynamic nav meshes, your tiny little agent
    will be in for a challenge as it navigates toward its target point. Life – or
    rather, artificial life – won’t be as simple for it anymore!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I’m going to introduce you to navigation filters, a feature
    that will let you change the way an agent behaves on the nav mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Influencing navigation with query filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already mentioned in [*Chapter 3*](B31016_03.xhtml#_idTextAnchor058) , *Presenting
    the Unreal Engine Navigation System* , with query filters, you can custom tailor
    the navigation paths of AI agents, enabling you to enhance and optimize their
    movement in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the **Move to Actor** method in the previously created
    graph has an attribute named **Filter Class** (see *Figure 5* *.11* ); this will
    allow us to customize the way our agent behaves on a nav mesh.
  prefs: []
  type: TYPE_NORMAL
- en: A filter is created by extending the **NavigationQueryFilter** class and setting
    some appropriate values, so let’s start by creating one such class and see how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a first step, we will need a gym for testing filters; in this case, we are
    going to duplicate a pre-existing one and tweak it a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the **Gym_NavMesh_02** map, rename it **Gym_NavMesh_05** , and open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all the obstacles from the bridge – if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the agent and put it at the side of the first one, on the blue tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the agents recognizable, you may wish to change the material of the
    duplicate; in my case, I opted for **MI_Prototype_B** . The final level should
    be like the one depicted in *Figure 5* *.12* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The base gym](img/B31016_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The base gym
  prefs: []
  type: TYPE_NORMAL
- en: If you test the level, unsurprisingly, both agents will go toward the bridge,
    traverse it, and get to the target point.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s spice things up a bit, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Creating the query filter class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to create a query filter that will override the way navigation
    modifiers are considered; we want the mud area to be considered less costly and
    easily traversable, but just for a single agent. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Content Drawer** and, in the **Blueprints** folder, create a new Blueprint
    class of the **Navigation Query** **Filter** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the asset **NavFilter_MudWalker** and double-click on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, you will see an **Areas** array attribute; click on
    the **+** button to add an element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the element and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Area Class** dropdown menu, select **NavArea_Mud** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the **Travel Cost Override** checkbox and set its value to **1.0** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the **Entering Cost Override** checkbox and set its value to **0.0** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Query filter settings](img/B31016_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Query filter settings
  prefs: []
  type: TYPE_NORMAL
- en: We are basically creating a different cost for the muddy area of our level –
    that is, where the **NavArea_Mud** modifiers are placed.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to modify the AI agent a bit, so it will accept this kind of modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to make a slight modification to the agent, so open the **BP_NavMeshAgent**
    Blueprint class and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Move to Actor** node, click and drag on the **Filter Class** incoming
    pin, and, once released, select **Promote** **to variable** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created variable **FilterClass** and make it **Instance Editable**
    by checking the corresponding attribute in the **Details** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the **Blueprint** and double-check in the **Details** panel that **Default
    Value** is set to **None** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you tell the agent to move to a target point, it will use the **FilterClass**
    variable – if set to any value – to override the nav mesh cost rules.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it out in action. Open your gym and select the second agent; then,
    from the **Details** panel, from the **Filter Class** dropdown, select **NavFilter_MudWalker**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Test the gym and you will now notice the second agent go straight to the target
    point, moving through the mud. This cheeky AI agent has gone rogue and decided
    to play dirty, hasn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have discovered the ability to override the cost of a nav
    mesh, which grants you significant power in creating highly customizable AI characters.
    With this newfound capability, you can make your AI characters behave distinctively
    and stand out from the rest of the crowd. I am pretty confident you will understand
    that this opens up a world of possibilities for creating unique and dynamic gameplay
    experiences.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will show you another important technique in AI pathfinding,
    and that’s how to make your AI agents avoid each other.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing agent avoidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It comes as no surprise that, most of the time, you will be working with more
    than a single agent in a level, and this means there will be a high probability
    that they will have crossing pathfinding rules; this means that your poor AI entities
    will be at a significant risk of colliding with each other. As funny as it may
    be, I guess that’s not the intended behavior in your game.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why Unreal Engine provides an out-of-the-box – but disabled by default
    – avoidance system. In this section, we are going to consider how to make AI agents
    avoid each other.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we will start with a brand-new gym.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a first step, we will need a gym with some obstacles around. To get started,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select **File** | **New Level** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/LevelInstances** folder and drag an instance of **LI_Lighting**
    inside your level; set its transform **Location** value to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/PackedLevelActors** folder and drag an instance of **PLA_Lab_05**
    inside your level; set its transform **Location** value to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the level in the **Maps** folder and name it **Gym_NavMesh_06** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This gym is slightly bigger than the previous ones and has some obstacles to
    make things more interesting. Additionally, there are eight blue tiles – we’re
    going to use eight agents – as depicted in *Figure 5* *.14* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The gym](img/B31016_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – The gym
  prefs: []
  type: TYPE_NORMAL
- en: Adding the agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously mentioned, we are going to add several agents – eight in total
    – to check how they behave in a crowded environment. So, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add eight instances of the **BP_NavMeshAgent** Blueprint on the level and put
    each one in a blue tile in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add eight instances of the **NS_Target** Niagara system and put them just behind
    each blue tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each agent, set the **Target Actor** property value to the **NS_Target**
    Niagara system that is on the opposite side of the gym. The level should now look
    like *Figure 5* *.15* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The finished gym](img/B31016_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The finished gym
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try testing the gym, chances are that some of your agents will collide
    with some other agent moving in the opposite direction, as depicted in *Figure
    5* *.16* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Ouch, this hurts!](img/B31016_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Ouch, this hurts!
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, our agents are geared up with safety helmets, unlike the characters
    in your game who might be cruising without any protection! That’s why we are going
    to make the agents’ pathfinding slightly cleverer.
  prefs: []
  type: TYPE_NORMAL
- en: Activating avoidance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have opened the **BP_NavMeshAgent** Blueprint, you are ready to enable
    the avoidance system. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Details** panel, locate the **Character Movement: Avoidance** category
    and check the **Use** **RVOAvoidance** property.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Avoidance Consideration Radius** to **2000.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As stated in [*Chapter 3*](B31016_03.xhtml#_idTextAnchor058) , *Presenting the
    Unreal Engine Navigation System* , RVO refers to a feature that enables AI agents
    to avoid collisions with each other.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Use RVOAvoidance** property is enabled for a character or agent,
    it allows them to dynamically adjust their movement to avoid colliding with other
    agents in the environment. The **Avoidance Consideration Radius** property is
    used to define the radius within which an agent considers other agents for collision
    avoidance.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the gym at this point will let you see the avoidance system at work;
    agents will avoid each other while reaching their target point.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a worst-case scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s test something different; we will be creating a gym where spaces will
    be a bit more challenging for the agents. The new gym will be a duplicate of the
    previous one. Start by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the **Gym_NavMesh_06** map and call it **Gym_NavMesh_07** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some obstacles that will create a narrow path, almost forcing the characters
    to follow a single, specific route. My gym is shown in *Figure 5* *.17* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Worst-case scenario](img/B31016_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Worst-case scenario
  prefs: []
  type: TYPE_NORMAL
- en: Test the game, and you will witness all the agents diligently making efforts
    to avoid colliding with one another. You can make a countertest and uncheck the
    **Use RVOAvoidance** property; you will notice that all the agents initially cluster
    together and collide with each other before eventually resolving their paths and
    reaching their respective target points.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Mass collision](img/B31016_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Mass collision
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how to implement collision avoidance for agents
    moving on a nav mesh, ensuring that they can successfully navigate while actively
    avoiding collisions with other agents.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to some more advanced features of the Unreal
    Engine pathfinding system. Firstly, we saw how to create a nav mesh that can be
    updated at runtime. Next, we saw how you can override the way an agent interprets
    the cost of a nav mesh section. Finally, we saw how to use the built-in avoidance
    system so that AI agents won’t collide with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming chapter, we will explore the final component of the pathfinding
    system: debugging and optimization techniques. We will explore ways to identify
    and resolve any issues that may arise and optimize the system for improved performance.
    Get ready for an exciting and informative session!'
  prefs: []
  type: TYPE_NORMAL
