- en: Crowd Interactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群体互动
- en: After understanding how to develop an AI character that can move freely around
    the map, searching for the best paths to arrive at certain destinations, we can
    start working on the interaction between characters. In this chapter, we will
    be looking at realistic crowd interactions, how to develop a believable crowd
    behavior, and how a character should perceive the rest of the group. The goal
    of this chapter is to keep giving information to our AI character about the environment,
    and in this particular case, about the other intelligent agents of the game. On
    this chapter, we will be talking about AI coordination, communication and crowd
    collision avoidance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了如何开发一个可以在地图上自由移动的AI角色，并寻找到达特定目的地的最佳路径之后，我们可以开始着手角色之间的互动。在本章中，我们将探讨现实中的群体互动，如何开发可信的群体行为，以及角色应该如何感知其他群体成员。本章的目标是继续向我们的AI角色提供关于环境的信息，在这个特定案例中，关于游戏中的其他智能代理。在本章中，我们将讨论AI协调、通信和群体碰撞避免。
- en: What is crowd interaction
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是群体互动
- en: Crowd interaction is a real-life subject that usually refers to multiple organisms
    sharing the same space. One big example is the human life, how humans interact
    with other humans and also other species. The decisions that we make most of the
    time involve other people, from the simple decisions to the most advanced and
    complicated ones. Let's assume that we want to buy a ticket for the cinema and
    the movie starts at 3pm. If we were the only ones interested in watching that
    movie, we could arrive only 2 minutes before it starts to buy a ticket and we
    would be on time to watch the movie. But if more than 100 people are interested
    in watching that same movie, we need to anticipate that and arrive much earlier
    at the cinema so we have time to buy the ticket. Once we arrive at the cinema,
    there are rules about how we should wait until it is our turn to buy the ticket.
    Usually we wait behind the last person that is in the line. This behavior is an
    example of crowd interactions. We live surrounded by other humans, and for that
    reason we need to adapt our goals accordingly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 群体互动是一个现实生活中的主题，通常指的是多个生物共享同一空间。一个很大的例子是人类生活，人类如何与其他人类和其他物种互动。我们大多数时候所做的决定都涉及其他人，从简单的决定到最先进和复杂的决定。让我们假设我们想要买一张电影票，电影在下午3点开始。如果我们是唯一对看这部电影感兴趣的人，我们可以在电影开始前2分钟到达电影院买票，这样我们就能准时看电影。但如果超过100人对看同一部电影感兴趣，我们就需要提前做好预测，并更早地到达电影院，以便有时间买票。一旦我们到达电影院，就有关于我们如何等待直到轮到我们买票的规则。通常我们会排在最后一个人的后面。这种行为是群体互动的一个例子。我们生活在其他人类周围，因此我们需要相应地调整我们的目标。
- en: In video games, we also can find this type of interaction, and can go from simple
    behaviors to advanced and complex ones. If we have more than one AI character
    in the game and they share the same space, there will be times where one will
    collide with another. It's up to the creators to think about that, about what
    would happen if two characters try to do the same thing at the same time, if it
    makes sense or if it will result in bugs. To solve these problems, we need to
    think about them and implement decisions that will help characters share the same
    space together, avoiding errors and behaving more realistically.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，我们也可以找到这种类型的互动，并且可以从简单的行为到高级和复杂的行为。如果我们游戏中有多于一个AI角色，并且它们共享同一空间，那么有时一个角色可能会与另一个角色发生碰撞。这取决于创作者思考，如果两个角色试图同时做同一件事会发生什么，这是否合理，或者它会导致错误。为了解决这些问题，我们需要思考并实施帮助角色共享同一空间、避免错误并更真实地行为的决策。
- en: Video games and crowd interactions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频游戏和群体互动
- en: As we have discovered before, crowd interactions are a real-life matter, but
    it can be found in video games, especially those that relies on human-like aspects.
    Because of the popularity of open-world maps, crowd interactions became a very
    important aspect when developing the game, because the AI agents of the game are
    constantly sharing the same space. This means that almost every open world game
    has the necessity to plan a crowd interaction system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所发现的，群体互动是现实生活中的问题，但它也可以在视频游戏中找到，尤其是在那些依赖于类似人类方面的游戏中。由于开放世界地图的流行，群体互动在游戏开发中成为一个非常重要的方面，因为游戏中的AI代理始终共享同一空间。这意味着几乎每个开放世界游戏都有必要规划一个群体互动系统。
- en: Assassin's Creed
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刺客信条
- en: 'A very popular case of crowd interaction system on a video game can be found
    in the Assassin''s Creed series. The non-playable characters walk around the map
    in groups, and in a simple way they avoid collisions and interact with the environment.
    This helps create a realistic atmosphere to the game, a crucial point that can
    make the game believable and submerging the player into a virtual world:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，一个非常流行的群体互动系统案例可以在《刺客信条》系列中找到。非玩家角色成群结队地在地图上行走，以简单的方式避免碰撞并与环境互动。这有助于为游戏创造一种真实氛围，这是一个至关重要的点，可以使游戏可信并让玩家沉浸于虚拟世界：
- en: '![](img/52444350-b868-4ab5-97b1-3a826afe3222.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52444350-b868-4ab5-97b1-3a826afe3222.jpg)'
- en: Not only can we see group interaction in the general population of the game,
    but also in the guards and especially in the combat. From time to time, the player
    needs to fight against a few guards, and usually there is more than one guard
    ready to attack the player. One interesting point is that the guards don't attack
    at the same time; they evaluate the situation and wait for a better opportunity
    to attack.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅能在游戏的一般人群中看到群体互动，还能在守卫和尤其是在战斗中看到。时不时地，玩家需要与几个守卫战斗，通常不止一个守卫准备攻击玩家。一个有趣的观点是守卫不会同时攻击；他们会评估情况，等待更好的攻击机会。
- en: 'This concept gives a sense of interaction between the multiple non-playable
    characters:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念给多个非玩家角色之间的互动带来了一种感觉：
- en: '![](img/f2ad65ed-e933-45e8-aa94-d7ca1e6f8741.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2ad65ed-e933-45e8-aa94-d7ca1e6f8741.jpg)'
- en: Grand Theft Auto (GTA)
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《侠盗猎车手》（GTA）
- en: The Grand Theft Auto game series is a source of many interesting lessons that
    we can learn with it. The constant seek to keep improving the game every time
    by trying to make it more realistic and believable changed the focus of the player
    to the surroundings, instead of simply looking at the main character. To make
    the surroundings more appealing and realistic, the creators of the game started
    to spend more time developing AI agents, how they move, how they react, and how
    they interact. The interaction between the AI characters was groundbreaking at
    the time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 《侠盗猎车手》游戏系列是我们可以从中学到许多有趣教训的源泉。不断寻求通过尝试使其更加真实和可信来改进游戏，改变了玩家的关注点，从简单地关注主要角色转向周围环境。为了使环境更具吸引力和真实感，游戏的创作者开始花更多时间开发人工智能代理，如何移动，如何反应，以及如何互动。当时人工智能角色的互动具有开创性。
- en: 'The player could see characters stopping to talk with each other, confronting
    physically with each other in more dramatic events, and all of that made the environment
    much more alive:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以看到角色停止交谈，在更戏剧性的事件中身体对抗，所有这些都使得环境更加生动：
- en: '![](img/21a41ff4-8535-4980-b5d8-7d1bd150ddc3.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21a41ff4-8535-4980-b5d8-7d1bd150ddc3.jpg)'
- en: As we can see on the preceding screenshot, the streets of the game are populated
    by distinct individuals that are interacting with each other. We can see a man
    taking his dog for a walk, two girls talking, a young woman taking a picture of
    another woman, and all of this does not contribute in any way to the gameplay
    but it makes the experience much more vivid and realistic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，游戏中的街道上挤满了不同的个体，他们正在相互互动。我们可以看到一个男人带着他的狗散步，两个女孩在交谈，一个年轻女人在给另一个女人拍照，所有这些都不以任何方式对游戏玩法做出贡献，但它们使体验更加生动和真实。
- en: The Sims
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《模拟人生》
- en: Another great example of crowd interaction can be found in the real-life simulator
    game, *The Sims*. Once again we are mentioning this game because it shaped the
    way developers create their games, and in terms of AI, they have contributed a
    lot about it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个群体互动的绝佳例子可以在现实生活模拟游戏《模拟人生》中找到。再次提到这款游戏是因为它塑造了开发者创造游戏的方式，在人工智能方面，他们对此做出了很多贡献。
- en: 'Non-playable characters do not mean that they simply need to be in idle position,
    waiting for something to happen. Here we can see that all the characters have
    unique personalities and that they interact with each other. Even if the player
    sets aside the controller and just watches the game, there will be many interesting
    things going on, and all of that comes from the AI characters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 非玩家角色并不意味着他们只需要处于闲置位置，等待事情发生。在这里我们可以看到所有角色都有独特的个性，并且它们相互互动。即使玩家放下控制器，只是观看游戏，也会有许多有趣的事情发生，所有这些都来自人工智能角色：
- en: '![](img/1605c596-5a81-48d4-81ef-299150733b38.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1605c596-5a81-48d4-81ef-299150733b38.jpg)'
- en: Previously in this book we have analyzed the priorities of *The Sims* characters,
    and we know that they can decide not to do one thing if another is more important
    at the time. And now that we know how pathfinding works, we can even implement
    a more advanced system into the characters, for example, letting them organize
    their priorities, taking in consideration the time that its necessary for them
    in order to reach the specific destination that lets them conclude the task. But
    all of that will be explored in a moment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书之前的部分，我们已经分析了《模拟人生》角色的优先级，我们知道如果当时有更重要的事情，他们可以决定不做某件事。而现在我们知道了路径查找的工作原理，我们甚至可以给角色实现一个更高级的系统，例如，让他们根据自己的优先级进行组织，考虑他们到达特定目的地所需的时间，以便完成特定任务。但所有这些将在稍后进行探讨。
- en: FIFA/Pro evolution soccer
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIFA/职业进化足球
- en: Another example that is extremely important to mention is the AI character that
    can be found in multiple sports games. Even if from the outside it doesn't look
    a game genre that is complex, sports games are probably the most advanced in terms
    of AI development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要特别提到的例子是多款体育游戏中可以找到的AI角色。即使从外表上看，它不是一个复杂的游戏类型，但体育游戏在AI开发方面可能是最先进的。
- en: 'The reason is that the games are based on real-life sports, and many of them
    are team sports. The difficulties in developing a realistic and functional team
    sports game are numerous, and for that reason it is a great case study:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是这些游戏基于现实生活中的体育项目，其中许多是团队运动。开发一个真实且功能齐全的团队体育游戏存在许多困难，因此它是一个很好的案例研究：
- en: '![](img/2cb015b7-8035-4e2e-beaa-86203143963e.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2cb015b7-8035-4e2e-beaa-86203143963e.jpg)'
- en: The preceding screenshot shows gameplay footage of FIFA 17\. Here we can see
    that only one character has the possession of the ball, while all the others are
    spread apart, either waiting for the character to pass the ball or anticipating
    the character's position in order to attempt win the ball from him. In total,
    that makes one ball for twenty-two characters in the game (eleven for each side).
    This is the reason why sports games require well-developed AI characters, because
    they are constantly working even if they don't have the ball. Individually, they
    have a position/role that they play, defending or attacking, left, right, or middle
    position, and many more. In the group, they all need to follow a strategy together
    and obey the rules of the game. If our teammate has the ball and is running forward,
    we can support him by running in the same direction, making it easy for him to
    pass, or we can stay behind because if that player loses the ball, someone needs
    to catch it back.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了FIFA 17的游戏画面。在这里我们可以看到，只有一名角色拥有球权，而其他所有人则分散开来，要么等待角色传球，要么预测角色的位置，试图从他那里赢得球。总共，游戏中22个角色（每边11个）只有一个球。这就是为什么体育游戏需要高度发展的AI角色，因为他们即使没有球也在不断工作。个别来看，他们都有自己的位置/角色，扮演防守或进攻，左边、右边或中间位置，等等。在团队中，他们都需要共同遵循策略并遵守游戏规则。如果我们的队友有球并且在向前跑，我们可以通过朝同一方向跑来支持他，这样他传球就会更容易，或者我们可以留在后面，因为如果那个球员失去球，就需要有人去捡回来。
- en: The interactions between the other characters are happening constantly, and
    it's not only about running after the ball to see who can get it first, it's about
    sharing a lot of information between them and trying to win the game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他角色的互动是持续发生的，不仅关乎追逐球以看谁能先拿到球，还关乎他们之间共享大量信息并试图赢得比赛。
- en: Planning crowd interactions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划人群互动
- en: Sometimes we put aside the planning phase while creating a game and think that
    all we need to create an awesome game is to have an idea and everything will flow
    smoothly from our head. Successful games are successful because every step of
    the development is planned to the smallest detail, and we should remember that
    when creating our own games. At this point, we have a strong technical knowledge
    to develop a challenging and interesting game with plenty of AI features in it,
    so our next step is to combine the ability to create games with a plan to make
    them look better.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们在制作游戏的过程中会忽略规划阶段，认为只要有一个好点子，一切就会从我们的脑海中顺畅地流淌出来。成功的游戏之所以成功，是因为每个开发步骤都被计划到了最细节的程度，我们在创建自己的游戏时也应该记住这一点。目前，我们拥有强大的技术知识，可以开发出具有丰富AI功能的挑战性和有趣的游戏，因此我们的下一步是将创建游戏的能力与使它们看起来更好的计划相结合。
- en: Now that we've analyzed some popular examples of crowd interaction systems in
    video games, we can take a look at how to plan these types of interaction. We
    will follow the examples from before and see how we can plan similar crowd interaction
    into our games.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Group fight
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a scenario where we have multiple AI characters fighting the player.
    We start by implementing the combat features into the character code, such as
    attacking with one hand, attacking with two hands, defending, going after the
    player, and all of that. Once we have that implemented, the character is able
    to fight the player and that's the starting point. If we didn't plan anything
    and we had four characters fighting the player, they all would attack at the same
    time to defeat the player.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'That would have worked with a few bugs here and there, but it would do the
    job if we didn''t have time to create a better system. What we are looking for
    is to get some interaction between the AI characters so they won''t look stupid
    attacking the player at the same time without analyzing the situation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a39d025-1b69-4b1c-bd63-f1160e9bbd32.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: So, now that we have the game running and we have enemy characters that follow
    the player and attack him, we want to plan the interaction between the AI characters
    to let them decide who should attack first and when the others can attack too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose from numerous factors that the characters will have in consideration
    to make this decision, and the more we plan, more developed and challenging the
    AI character become:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/402773a6-d468-4987-9fa4-bea1699958cd.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: For this example, we used the distance between the AI characters and the player
    to determine which one will attack first. We want the closest character to attack
    first and all the others will wait until that one has low HP. Once that character
    has low HP, the second closest character will intervene in the fight and attack
    the player.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our first criteria set on our characters to decide which one
    should be the first to attack, we can move on to determine what happens to the
    other characters while they are waiting. We also need to take into consideration
    that the player can decide to attack any other character at any time, and we don''t
    want the AI character to stay on idle position just because it''s not his time
    to attack. So the idea is to think about different situations that can happen
    and plan how the AI would behave in those situations, in particular, especially
    how they will interact with each other:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can start with a simple code just to determine the behavior of the character
    according to the situation that we are working with, and then we can keep adding
    more content as necessary to make it work as we want to. For this example, we
    have created a static integer called `attackOrder` that will contain the attack
    order of each character, so they know if it's their time to attack or not. After
    that, we have a public Boolean called `nearPlayer`, which will check whether the
    player is close the player character or not. We can have 30 characters on the
    map but we just want the closest ones to attack the characters. For this example,
    the others will simply ignore the player. To determine whether the AI character
    is near or not, we have a public float called `distancePlayer`, which will be
    the result of the distance between the AI character and the player. Then we have
    added a public static `int` called `charactersAttacking`, where the number will
    increase each time a new character arrives near the player. We can use this to
    give information to the other characters about how many skeletons are currently
    attacking the player.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个简单的代码开始，仅为了确定角色根据我们正在处理的情况的行为，然后我们可以根据需要继续添加更多内容，使其按我们的意愿工作。在这个例子中，我们创建了一个静态整数`attackOrder`，它将包含每个角色的攻击顺序，这样他们就知道是否是他们的攻击时间。之后，我们有一个公共布尔值`nearPlayer`，它将检查玩家是否靠近玩家角色。地图上可以有30个角色，但我们只想让最近的那几个攻击角色。在这个例子中，其他角色将简单地忽略玩家。为了确定AI角色是否靠近，我们有一个公共浮点值`distancePlayer`，它将是AI角色和玩家之间的距离。然后我们添加了一个公共静态整数`charactersAttacking`，其数值将在每个新角色靠近玩家时增加。我们可以使用这个信息来向其他角色提供有多少骨骼正在攻击玩家的信息。
- en: 'A small and simple code such as this one can make a huge difference for the
    crowd interaction that we are working on, because we can use the information about
    how many characters are attacking the player to decide what they will do. For
    example, we can determine that if there''s only two characters attacking, one
    will constantly defend the player''s attacks while the other attacks, and when
    the player switches from one character to another, they will do the same thing
    and swap their roles, making it harder for the player to defeat the enemies:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样的一个小而简单的代码可以为我们在进行的群体互动带来巨大的变化，因为我们可以使用关于有多少角色正在攻击玩家的信息来决定他们的行为。例如，我们可以确定如果只有两个角色在攻击，一个将不断防御玩家的攻击，而另一个进行攻击，当玩家从一个角色切换到另一个角色时，他们将做同样的事情并交换他们的角色，这使得玩家更难击败敌人：
- en: '![](img/1261c301-06be-4e0c-9059-7881464163ed.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1261c301-06be-4e0c-9059-7881464163ed.png)'
- en: This can be seen in the preceding screenshot, where one of the skeletons tells
    the other that it will be defending and that the other one can attack the player
    from behind. This is exactly what crowd interaction is, one character giving information
    to another about what it can do or how it should behave. The more information
    the characters share with the others, the more options they have of what they
    can do, and the more realistic their interactions will look because they are not
    acting alone.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这在前面的截图中可以体现出来，其中一个骨骼角色告诉另一个角色它将进行防御，而另一个角色可以从背后攻击玩家。这正是群体互动的本质，一个角色向另一个角色提供关于它能做什么或应该如何表现的信息。角色之间共享的信息越多，他们能做的选择就越多，他们的互动看起来就越真实，因为他们不是在单独行动。
- en: As we can see, even with simple codes we can achieve complex results, but it's
    necessary to think about it and plan everything ahead, and obviously the code
    will get bigger every time we add more details and options to it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，即使使用简单的代码，我们也能实现复杂的结果，但思考并提前规划一切是必要的，并且显然，每次我们添加更多细节和选项时，代码都会变得更长。
- en: Communication (attention zones)
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信（注意区域）
- en: Continuing with the same example, where we have a few skeletons on the map that
    will start attacking the player if the player gets near them, we can add one more
    feature that will make them interact even more one with another. Another thing
    that will make the characters behave like a group instead of single characters
    placed on the game is the communication. For example, here we have the skeletons
    that will only attack if the player is near, but what happens if one of the skeletons
    that is near the player yells that he saw the player character? We can assume
    that all the AI characters around that area will hear the yell and will start
    running in that direction in order to help their friend.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以同样的例子为例，我们地图上有几个骨骼，如果玩家靠近他们，他们就会开始攻击玩家，我们可以添加一个额外的功能，使他们之间的交互更加紧密。另一个能让角色像一群人而不是游戏中的单个角色一样行动的因素是沟通。例如，这里我们有骨骼，只有当玩家靠近时才会攻击，但如果靠近玩家的一个骨骼大声呼喊他看到了玩家角色，会发生什么呢？我们可以假设该区域周围的所有AI角色都会听到呼喊，并开始朝那个方向奔跑，以帮助他们的朋友。
- en: Once again, we can use simple lines of code in order to achieve this, but if
    we don't plan the interactions and how the characters should behave has a group,
    this type of element will be missing from the AI characters and they will behave
    independently, which will make it not so smart.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，我们可以使用简单的代码行来实现这一点，但如果我们没有计划交互以及角色应该如何作为一个群体行动，这种类型的元素将缺失在AI角色中，它们将独立行动，这会使它们不够智能。
- en: '![](img/ddf1011a-737e-41e4-81ff-9da3af333044.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddf1011a-737e-41e4-81ff-9da3af333044.png)'
- en: As we can see, this is the system that we have right now. The AI characters
    don't communicate with each other and so the only skeletons that are aware of
    the player's position are the ones that are close enough to the player. If we
    are trying to create a crowd system, we need to plan situations like this one.
    Just because the other ones don't see the player character, doesn't necessarily
    mean that they have to react like nothing is happening.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是我们目前拥有的系统。AI角色之间没有沟通，所以只有足够靠近玩家的骨骼才知道玩家的位置。如果我们试图创建一个群体系统，我们需要计划类似这种情况。仅仅因为其他人看不到玩家角色，并不意味着他们必须像什么都没发生一样反应。
- en: Let's think about a real-life situation. For example, we have one person inside
    a house and another one outside. The person that is outside of the house sees
    an incredible beautiful bird while the person that is inside doesn't see it, so
    it will remain inside of the house. If the person that saw the bird doesn't communicate
    with the other one, the person that is inside the house will never know about
    it. So, normally what would happen is the person that sees the bird will call
    the other one to come outside so it can see the beautiful bird as well. This is
    a realistic behavior that can be implemented in our crowd interaction system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一个现实生活中的场景。例如，我们有一个人在房子里，另一个人在外面。外面的人看到了一只令人难以置信的美丽的鸟，而房子里的人却看不到，所以它将留在房子里。如果看到鸟的人不与另一个人沟通，房子里的人将永远不知道这件事。所以，通常会发生的情况是，看到鸟的人会叫另一个人出来，这样他也能看到这只美丽的鸟。这是可以在我们的群体交互系统中实现的一种现实行为。
- en: 'To change this non-interaction situation to a more realistic version, we need
    to add one more feature to our characters that will make them communicate with
    each other. At this point, we just need simple communication, and we could use
    a similar code to what we have used to determine if the character can see the
    player or not:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这种非交互情况转变为更现实版本，我们需要给我们的角色添加一个额外的功能，使他们能够相互沟通。在这个阶段，我们只需要简单的沟通，我们可以使用与之前用来确定角色是否可以看到玩家相似的代码：
- en: '![](img/1d7f0886-1d48-4e06-a4c3-38c0ab660c71.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d7f0886-1d48-4e06-a4c3-38c0ab660c71.png)'
- en: 'So now we have a AI character that has entered on the player trigger area,
    and for that reason he will yell so the others AI characters that are near are
    aware of the player''s position as well. In the preceding diagram, we can see
    that now not only the player has a trigger area, but the enemy that has spotted
    the player has one as well. This new trigger area will serve to alert the other
    characters, and it''s meant to represent a yell. So when we play the game, and
    the enemy spots us, we will hear a yell that will give a sense of communication
    between the AI characters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在我们有一个AI角色进入了玩家的触发区域，因此他会大声喊叫，让附近的AI角色也意识到玩家的位置。在先前的图中，我们可以看到现在不仅玩家有一个触发区域，被玩家发现的敌人也有一个。这个新的触发区域将用于警告其他角色，它代表的是一声喊叫。所以当我们玩游戏时，如果敌人发现了我们，我们会听到一声喊叫，这会给AI角色之间的交流带来一种感觉：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make this happen, we simply added new Boolean called `nearEnemyAttacked`.
    In conjunction with this, we add a trigger detection to check if there are some
    skeletons near that have spotted the player. If it's triggered, the Boolean turns
    true; otherwise, it will remain false.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们简单地添加了一个新的布尔值`nearEnemyAttacked`。与此相结合，我们添加了一个触发检测来检查是否有发现玩家的近处骨骼。如果触发，布尔值变为真；否则，它将保持为假。
- en: 'Once it gets triggered, it''s time for that same AI character to call for any
    other ones that are around:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发，该AI角色就需要呼叫周围的其他角色：
- en: '![](img/c6916b02-6981-4e05-971b-b09d393e5732.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6916b02-6981-4e05-971b-b09d393e5732.png)'
- en: 'As we can see in the preceding diagram, due to the communication system we
    have implemented, we now have three characters that are fully aware of the player''s
    position. The last character will also yell, trying to tell others about the player''s
    position, but if the trigger area doesn''t overlap an AI character, nothing will
    happen:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，由于我们实施的交流系统，现在有三个角色完全清楚玩家的位置。最后一个角色也会喊叫，试图告诉其他人玩家的位置，但如果触发区域没有与AI角色重叠，则不会发生任何事情：
- en: '![](img/66e30258-f099-46f9-8db1-adbc18b111f5.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66e30258-f099-46f9-8db1-adbc18b111f5.png)'
- en: For example, ENEMY 4 is far too away to be affected by the trigger zone, so
    it will remain in that position until the player gets near his location; otherwise,
    he won't know what is happening.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，敌人4离得太远，无法受到触发区域的影响，所以它会保持在那个位置，直到玩家接近他的位置；否则，他不会知道发生了什么。
- en: The trick of this example is to have characters talking to each other, yelling
    or trying to get the attention of characters that are near. This will give a sense
    of communication turning simple and individual actions into a more appealing group
    interaction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的技巧是让角色之间进行交谈，大声喊叫或试图引起附近角色的注意。这将使交流变得简单，将个体行为转化为更具吸引力的群体互动。
- en: Communication (talking to other AI characters)
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交流（与其他AI角色交谈）
- en: There are many other examples that can be shown in terms of communication, because
    it's always possible to find new ways to communicate between characters; just
    like in real life, we are constantly finding new ways of communicating. But for
    now, we will stick to the basic form of communication, talking.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在交流方面，可以展示的例子还有很多，因为总有可能找到新的方法在角色之间进行交流；就像在现实生活中，我们总是在寻找新的交流方式。但就目前而言，我们将坚持基本的交流形式，即谈话。
- en: 'If we plan to have a lot of AI characters in the game, it will rapidly take
    a big part of the game, where the focus of the player will be set directly or
    indirectly to them. Probably not every game that we will be creating will have
    characters that react instantly to the presence of the player, and maybe the player
    could be just one more character in the game, and for that reason could be ignored.
    So in this section, will be excluding the player part and we will exclusively
    plan the AI character interactions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们计划在游戏中拥有很多AI角色，这将会迅速占据游戏的大部分内容，玩家的焦点将直接或间接地集中到他们身上。可能我们不会创建的每个游戏都会有对玩家出现立即做出反应的角色，也许玩家在游戏中只是另一个角色，因此可能会被忽略。所以在这个部分，我们将排除玩家部分，并将专门规划AI角色的交互：
- en: '![](img/638efc24-46aa-4970-8a79-dea07294d710.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/638efc24-46aa-4970-8a79-dea07294d710.png)'
- en: Let's create a city with a lot of people and assign a few details to them so
    they can behave like a realistic crowd. We can start by adding basic movement
    information into our character, such as walking, running, idle, and pathfinding.
    With that implemented in our character, we have an individual character that can
    walk around the city that avoids colliding with the buildings and walks on the
    sidewalk.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个拥有大量人群的城市，并为其中的一些人分配一些细节，使他们能够像真实的人群一样行动。我们可以从在我们的角色中添加基本的移动信息开始，比如行走、跑步、闲置和路径查找。在我们的角色中实现这一点后，我们就有一个可以在城市中四处走动、避免碰撞建筑并在人行道上行走的人物。
- en: 'Now our first suggestion for this example is to add a simple trigger detection
    so the characters are aware when another characters passes nearby:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们首先的建议是添加一个简单的触发检测，使角色意识到当另一个角色经过附近时：
- en: '![](img/6fe41764-6a25-493b-b103-a7f30abe984a.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fe41764-6a25-493b-b103-a7f30abe984a.png)'
- en: 'After adding the trigger area to the characters, we can advance to the next
    step and work on the interaction between them. Our plan here is to have a probability
    map to determine a probability to find a known person that can start a conversation
    with:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在为角色添加触发区域之后，我们可以进入下一步，并着手处理它们之间的交互。我们的计划是使用一个概率图来确定找到可以开始对话的已知人物的概率：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To make this work, we added an integer function that for this example we called
    it `probabilityFriendly`. This refers to the probability of finding a friendly
    person. When a new character enters the trigger area, the calculation will be
    made randomly, and if the number fits our percentage, both characters will stop
    walking around and will start a conversation. After that, we can keep adding more
    details to this situation, such as when they end the conversation, we could make
    them walk side by side while talking, and endless other options that could derive
    from this small trigger detection and probability map.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个系统能够工作，我们添加了一个整数函数，在这个例子中我们称之为`probabilityFriendly`。这指的是找到友好人物的概率。当一个新角色进入触发区域时，计算将随机进行，如果数字符合我们的百分比，两个角色将停止四处走动并开始交谈。之后，我们可以继续添加更多细节到这个场景中，比如当他们的对话结束时，我们可以让他们边走边聊，还有无数其他可能从这个小的触发检测和概率图中派生出来的选项。
- en: The idea behind this is to have characters that can interact with each other
    randomly. From the player's point of view, it would look like the characters are
    friends and they simply have stopped to talk because they know each other. This
    helps create a realistic atmosphere, and it's not so much about a technical point
    but instead about planning every possible interaction between characters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的背后的目的是拥有可以相互随机交互的角色。从玩家的角度来看，这看起来就像角色们是朋友，他们只是因为彼此认识而停下来聊天。这有助于创造一个逼真的氛围，这更多是关于规划角色之间所有可能的交互，而不是技术点。
- en: Team sports
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队运动
- en: As we saw previously while explaining some popular examples of crowd interaction
    systems in video games, sports games have a well-developed AI system that works
    specifically well in team sports. Now we will take an in-depth look at some of
    the core features of team sports video games and see how they have achieved some
    interesting results, making the AI characters of those games very challenging
    and realistic.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在解释一些流行的游戏中的群体交互系统时所见，体育游戏有一个高度发展的AI系统，在团队运动中特别有效。现在我们将深入探讨一些团队体育视频游戏的核心功能，看看它们是如何取得一些有趣的结果，使得这些游戏的AI角色既具有挑战性又逼真。
- en: 'If we analyze the real-life sport football, we have two teams each composed
    of eleven individual players. In order to win the game, the team needs to score
    more goals than the opponent, so the game can be divided into two basic forms:
    attacking, where the focus is scoring goals; and defending, where the focus is
    avoiding conceding goals. There is just one ball in the game, so a lot of the
    players'' time is spent without having the possession of the ball, and that time
    can be very important to the end result of the game. Either the player tries to
    take the ball from the opponent or get in a good position to receive the ball.
    That''s the two basic forms when the player doesn''t have the possession of the
    ball.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析现实生活中的足球运动，我们会看到有两个队伍，每个队伍由十一个单独的球员组成。为了赢得比赛，球队需要比对手进更多的球，因此比赛可以分为两种基本形式：进攻，重点是进球；防守，重点是避免失球。比赛中只有一个球，所以球员的大部分时间都是在没有球权的情况下度过的，而这段时间对比赛的结果可能非常重要。球员要么试图从对手那里抢球，要么找到一个好的位置来接球。这就是当球员没有球权时的两种基本形式。
- en: The video game tries to mimic every detail of the sport, and because it is a
    team sport, there is a lot of work on the development of the AI group interaction.
    The mindset of the AI characters needs to be more on team play and less on simple
    individual play. So they only make certain decisions, if those decisions follow
    the group objectives.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 电子游戏试图模仿体育的每一个细节，由于它是一项团队运动，因此在人工智能群体交互的开发上投入了大量的工作。人工智能角色的心态需要更多地关注团队合作，而不是简单的个人表现。因此，他们只会做出某些决定，如果这些决定符合团队目标的话。
- en: If we watch a football match, we can hear the players talking to each other
    to pass them the ball, to move forward, to go backwards, and so on. The idea is
    to have that type of communication inside of the video game as well. It does not
    necessarily need to be about verbal communication, but the rather about actions
    that makes the game much more realistic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观看一场足球比赛，我们可以听到球员之间互相交谈，传递球，向前移动，向后移动等等。想法是在电子游戏中也有这种类型的交流。这并不一定需要是口头交流，而是关于使游戏更加逼真的动作。
- en: 'Let''s analyze step-by-step the basic AI decisions that the characters make
    while playing the game. We will start by taking a look the organization of the
    characters on the field, as shown in the following diagram:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析角色在游戏中做出的基本人工智能决策。我们将从查看角色在场地的组织结构开始，如下面的图表所示：
- en: '![](img/5bbd7b0f-5dae-4fa1-a25e-21f40e36d377.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bbd7b0f-5dae-4fa1-a25e-21f40e36d377.png)'
- en: This is one example of a simple formation of a football team on the field. At
    the bottom, we can see just one circle, and that represents the goalkeeper, the
    one that is responsible for defending the goal. This character is the only one
    that remains constantly around this area; all the others can move freely if they
    want to. Now that we have a visual representation of how a football team is distributed
    on the field, we can move on with the example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在场地上足球队简单阵型的例子之一。在底部，我们可以看到一个圆圈，它代表守门员，负责防守球门。这个角色是唯一一个始终围绕这个区域的人；其他人如果愿意的话可以自由移动。现在我们已经有了足球队在场地上分布的视觉表示，我们可以继续这个例子。
- en: Each character in the game has an individual objective. This may be passing
    the ball to the offensive players, shooting as much as possible to try to score
    goals, simply staying behind to defend, and so on. While they have these individual
    objectives, they also need to think about the team objectives and decide if one
    objective or another is more important at a certain point, and if the decision
    that they are making will help to achieve the objective successfully.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的每个角色都有一个个人目标。这可能包括将球传给进攻球员，尽可能多地射门以尝试进球，简单地留在后面防守等等。虽然他们有这些个人目标，但他们也需要考虑团队目标，并决定在某个时刻哪个目标更重要，以及他们所做的决定是否有助于成功实现目标。
- en: 'Let''s move on to the creation of an individual player. We start from the basics,
    running after the ball. To create this, we can use techniques that were explained
    earlier in the book, such as walking towards an object''s position:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建单个球员。我们从基础开始，跟随球跑。为了创建这个，我们可以使用书中之前解释过的技术，例如走向一个物体的位置：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we have the code that makes the character running after the ball. At this
    moment, we will be working on just one character and then we''ll gradually add
    team interactions in order to have at least a basic form of what we can see on
    a fully developed sports game. So if we play the game with only this code, we
    can see that the character will move towards the ball''s position, and that is
    the basics of the football game, to reach the ball:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有使角色追球的代码。在这个时候，我们将只处理一个角色，然后我们将逐步添加团队互动，以便至少有一个基本的我们可以在完全开发的游戏中看到的形式。所以如果我们只使用这段代码玩游戏，我们可以看到角色会朝向球的位置移动，这就是足球游戏的基本原则，即达到球：
- en: '![](img/7be935a8-c620-4d76-931d-a160eb5dcf6b.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7be935a8-c620-4d76-931d-a160eb5dcf6b.png)'
- en: 'At the moment, we have an individual player working properly, and that is want
    we expected for now. If we added more characters into the game, all of them would
    run towards the ball, ignoring everything else, so no communication or interaction
    would be happening in the game:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个单独的玩家正在正常工作，这是我们目前所期望的。如果我们向游戏中添加更多角色，他们都会朝向球移动，忽略其他一切，所以在游戏中不会发生任何沟通或互动：
- en: '![](img/66a8a47f-3f5c-4f02-83bb-b6b9d3c37fcf.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66a8a47f-3f5c-4f02-83bb-b6b9d3c37fcf.png)'
- en: 'If we had all the characters in the game running towards the ball''s position,
    as we can see in the preceding diagram, it will be like the characters don''t
    have a perception of the others around them. So to avoid this situation, we can
    get the character that is closest to the ball to communicate that to the other
    characters, so they don''t need to run for the ball as well. To create that, we
    can have a constant calculation between the distance of each character and the
    ball:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏中的所有角色都朝向球的位置移动，就像我们在前面的图中看到的那样，那么这些角色就好像没有意识到周围的其他角色一样。为了避免这种情况，我们可以让离球最近的角色将这一信息传达给其他角色，这样他们就不需要为球而奔跑了。为了实现这一点，我们可以在每个角色与球之间的距离上进行一个恒定的计算：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To achieve this, we have used the distance calculation that we have explored
    previously on the book. So now we have three new variables on the code, `ballDistance`
    that is a float that will be the measurement of how far the character is from
    the ball.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用了在书中之前探索过的距离计算方法。因此，现在代码中有三个新的变量，`ballDistance`是一个浮点数，它将测量角色与球之间的距离。
- en: 'Now that we have this set we need to have the character verifying if he is
    the closest of them all from the ball and if so, he can then move on and run towards
    the ball position:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个设定，我们需要让角色验证自己是否是所有人中最接近球的人，如果是的话，他就可以继续前进并朝向球的位置奔跑：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For this example, we decided to simply add a variable that will be shared for
    all the characters, so we added a static float variable called `teamDistance`.
    This will store the value of the character that is closest to the ball. At this
    point, the characters will know if they are the ones that are closest to the ball.
    From this point, it is simple to move to the next step and have the character
    check if it is the closest one, and if so, it can run towards the ball. This will
    be the first team element that we''ll be adding to our AI characters. They will
    check with the others to see which one should get the ball, and as we planned,
    it makes more sense to be the one that is closest to the ball, but we can break
    it down further so they can check which one will get to the ball first. However,
    for this example we''ll stick with the principle that all of the characters run
    at the same velocity:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们决定简单地添加一个变量，这个变量将被所有角色共享，所以我们添加了一个静态浮点变量，称为`teamDistance`。这个变量将存储离球最近的角色的值。在这个时候，角色将知道他们是否是离球最近的人。从这个点开始，简单地移动到下一步，让角色检查自己是否是最接近球的人，如果是的话，它就可以朝向球的位置奔跑。这将是我们将添加到我们的AI角色中的第一个团队元素。他们将与其他角色核对，看看哪个角色应该得到球，正如我们计划的那样，离球最近的角色更有意义，但我们可以进一步分解，让他们检查哪个角色会先到达球。然而，对于这个例子，我们将坚持所有角色以相同速度移动的原则：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/d0b5bff4-c9f4-4e83-b5d2-1af953176255.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0b5bff4-c9f4-4e83-b5d2-1af953176255.png)'
- en: st the , we can see that only one character is running after the ball. All the
    other characters have the perception that one of their team is closer to the ball,
    so that one will get the ball. At this moment, we already have a simple form of
    group interaction and we are on the right track.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，我们可以看到只有一名角色在追球。其他所有角色都有一种感觉，即他们的某个队友离球更近，所以那个队友会得到球。在这个时刻，我们已经有了一种简单的群体互动形式，并且我们正在正确的道路上。
- en: 'The next thing that we need to work on is that the ball will be moving throughout
    the game, and our code works in a static scenario, but if the ball gets moved,
    the team distance check should be reset. The reason is that the value will be
    getting lower when the character AI gets closer to the ball, and that value never
    increases, so we need to update it. We start by creating a new script for the
    ball:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要处理的问题是球将在整个游戏中移动，而我们的代码是在静态场景中工作的，但如果球被移动，团队距离检查应该重置。原因是当角色AI靠近球时，这个值会降低，而这个值永远不会增加，所以我们需要更新它。我们首先为球创建一个新的脚本：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After adding this script to the ball, the distance check of the players will
    get updated every time the ball get's moved. Now let's make sure that the ball
    moves. To make this happen, we need to allow the character to kick the ball.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个脚本添加到球上后，每当球被移动时，球员的距离检查都会更新。现在让我们确保球可以移动。为了实现这一点，我们需要允许角色踢球。
- en: 'First, we will update the ball script that we just created. We want to add
    a variable that will store the position where the ball will land after the character
    shooting it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新我们刚刚创建的球脚本。我们想要添加一个变量来存储角色射击后球将落下的位置：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, what we have done here is give information about the landing position of
    the ball. To make this happen, we added a `public static Transform` variable called
    `characterPos`. We have chosen to have character positions here for the test,
    because we want the characters to pass the ball and not simply kick it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里提供的是关于球落点位置的信息。为了实现这一点，我们添加了一个名为`characterPos`的`public static Transform`变量。我们选择在这里使用角色位置进行测试，因为我们希望角色传球而不是简单地踢球：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then we updated the variables of the character AI script. Here, we have a list
    that will contain all the players' coordinates of the team. The idea is to have
    the character choosing a friendly teammate to pass the ball and shoot it in that
    direction.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们更新了角色AI脚本的变量。在这里，我们有一个列表，将包含所有球员的坐标。想法是让角色选择一个友好的队友传球并朝那个方向射击。
- en: 'So for this example, we have chosen to use the coordinates of the characters
    as a waypoint for the ball. To make this feature more realistic, we can add more
    details about the trajectory of the ball being affected by gravity or wind:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，我们选择使用角色的坐标作为球的航点。为了使这个特性更加逼真，我们可以添加更多关于球轨迹的细节，比如球受到重力或风的影响：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we use the variables that we just added to our code to send the new direction
    to the ball when the character AI gets close enough to the ball. `void passBall
    ()` is the function that we created that will be called every time the character
    wants to pass the ball. At this moment, we just want the characters to pass the
    ball to each other, so we have assigned a random number to select a character
    from the list.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用刚刚添加到代码中的变量，在角色AI足够接近球时将新的方向发送给球。`void passBall()`是我们创建的函数，每次角色想要传球时都会调用它。在这个时候，我们只想让角色互相传球，所以我们给列表中的角色分配了一个随机数来选择一个角色。
- en: '![](img/37eb57dc-f559-4080-8d72-59c3cdb0585d.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37eb57dc-f559-4080-8d72-59c3cdb0585d.png)'
- en: If we test the game, we can see that there is a lot more movement and interaction
    going on. So what we can see is that the closest character will get near the ball
    and when that happens, he will pass the ball to another character. The ball will
    move towards the character and the character will get closer to the ball so he
    can pass the ball to another character. Currently, this will happen forever in
    a loop, a character gets the ball, passes, another one gets the ball and passes,
    and so on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试游戏，我们可以看到有更多的移动和交互正在进行。所以我们可以看到的是，最近的角色会靠近球，当这种情况发生时，他会将球传给另一个角色。球会朝向角色移动，角色会靠近球，以便他将球传给另一个角色。目前，这将在循环中无限发生，一个角色得到球，传球，另一个角色得到球并传球，如此循环。
- en: Now we have the foundation of a simple football game, and we can simply keep
    adding more features like the ones we just created to make them communicate to
    see who's going to get the ball and pass the ball to the teammates.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了简单足球游戏的基础，我们可以简单地继续添加更多像我们刚刚创建的功能，使它们能够沟通，看看谁将得到球并将球传给队友。
- en: Crowd collision avoidance
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群体碰撞避免
- en: 'To finalize this chapter, we''ll be talking about crowd collision avoidance.
    The idea of having a lot of characters in the same map is becoming a standard
    for open world games. But this often brings a problem, collision avoidance:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，我们将讨论人群避碰。在同一个地图上有许多角色的想法正在成为开放世界游戏的标准。但这也常常带来一个问题，即避碰：
- en: '![](img/dd12ac37-9842-4739-9b53-df26f789e93c.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd12ac37-9842-4739-9b53-df26f789e93c.png)'
- en: We have already discovered how advanced pathfinding works, and we know that
    is a powerful system when developing AI movement. But if we have a lot of characters
    trying to reach the same position at the same time, it will cause them to collide
    with each other and they will probably block the path that is needed to reach
    that destination. As we can see in the preceding screenshot, everything is running
    smoothly and without any abnormal situation because the characters are following
    different directions and rarely do they interfere with the others.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现了路径查找是如何工作的，我们知道这是一个在开发人工智能移动时非常强大的系统。但是，如果我们有很多角色同时试图到达同一个位置，它们可能会相互碰撞，并且可能会阻塞通往那个目的地的必经之路。正如我们在前面的截图中所看到的，一切都在顺利运行，没有任何异常情况，因为角色们正在遵循不同的方向，很少会相互干扰。
- en: But what happens if all the characters try to access the same position at the
    same time, for example trying to get inside the house. It is only possible for
    one character at a time to go through the door, and that means that plenty of
    other characters will wait in line to enter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果所有角色都试图同时访问同一个位置，比如试图进入房子，那么一次只能有一个角色通过门，这意味着许多其他角色将排队等待进入。
- en: The solution for this problem is still being explored, and there is not a definite
    answer, but there are some ways to get around this.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，解决方案仍在探索中，还没有一个确定的答案，但有一些方法可以绕过这个问题。
- en: '![](img/b5570415-5b5b-446e-9734-dc993b55797a.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5570415-5b5b-446e-9734-dc993b55797a.jpg)'
- en: Currently crowd dynamics solutions usually involve two different layers, one
    for the pathfinding and another one for the local collision avoidance. Using this
    approach, we have a few benefits, it will produce a high quality movement and
    also it will have avoidance on a small scale, it is a very common method used
    on multiple games.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，人群动态解决方案通常涉及两个不同的层次，一个用于路径查找，另一个用于局部避碰。使用这种方法，我们有几个好处，它将产生高质量的移动，并且它将在小范围内进行避碰，这是在多个游戏中非常常见的方法。
- en: There are different alternatives to achieve this with a satisfactory result.
    A popular choice for many games is the combination of the Theta Algorithm A* with
    the velocity obstacle. This allow us to calculate the distance between our character
    and the other one that will collide against us.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以达到这个目的并获得令人满意的结果。许多游戏的一个流行选择是将Theta算法A*与速度障碍结合使用。这使我们能够计算我们的角色与其他将要与我们碰撞的角色之间的距离。
- en: In high-density crowd situations, solely relying on local collision avoidance
    and idealized pathfinding will cause agents to pile up at popular, shared path
    waypoints. Collision avoidance algorithms only help to avoid local collisions
    in the pursuit of following the ideal path. Often, games rely on these algorithms
    to divert agents to less-congested, less-direct routes in high-density situations.
    In certain situations, collision avoidance can lead to this desired behavior,
    though it is always a side effect of the system and not a deliberate consideration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在高密度人群情况下，仅仅依靠局部避碰和理想化的路径查找会导致代理在流行的、共享的路径航点上堆积。避碰算法仅有助于在追求理想路径的过程中避免局部碰撞。通常，游戏依赖于这些算法在高密度情况下将代理引导到不太拥挤、不太直接的路线。在某些情况下，避碰可以导致这种期望的行为，尽管这始终是系统的一个副作用，而不是一个有意的考虑。
- en: 'Work has been done in incorporating aggregate crowd movement and crowd density
    into pathfinding computations. Approaches that augment pathing via crowd density
    do not take into account the aggregate movement or direction of movement of the
    crowd, which leads to overcorrection of the phenomenon, which can be seen in the
    following image:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有人研究了将聚合人群移动和人群密度整合到路径查找计算中的方法。通过人群密度增强路径的方法没有考虑到人群的整体移动或移动方向，这会导致对这种现象的过度纠正，这在以下图像中可以观察到：
- en: '![](img/9a88bcad-a166-4171-8bc9-def9c3d9faa5.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a88bcad-a166-4171-8bc9-def9c3d9faa5.png)'
- en: Congestion maps are similar in many ways to existing cooperative pathfinding
    algorithms, such as Direction Maps (DMs), but they differ in a few key respects.
    DMs use average crowd motion over time to encourage agents to move with the crowd.
    Because of this, many of the oscillations present in the congestion map approach
    are smoothly resolved. Conversely, this temporal smoothing prevents DMs from quickly
    and accurately reacting to changes in the environment and crowd behavior. Both
    congestion maps and DMs apply the aggregate crowd movement information to the
    path planning process in much the same way; however, congestion maps handle agents
    of varying size and shape, while DMs traditionally assume homogeneity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 拥挤地图在很多方面与现有的合作路径查找算法类似，例如方向图（DMs），但在一些关键方面有所不同。DMs使用随时间变化的平均群体运动来鼓励代理与群体一起移动。正因为如此，拥挤地图方法中存在的许多振荡都得到了平滑解决。相反，这种时间平滑阻止了DMs快速准确地对外界环境和群体行为的变化做出反应。拥挤地图和DMs都以类似的方式将群体移动信息汇总应用于路径规划过程；然而，拥挤地图处理不同大小和形状的代理，而DMs传统上假设同质性。
- en: The final major difference between DMs and congestion maps is that congestion
    maps weight movement penalties proportional to the density of the crowd. Without
    taking density into account, DMs display overly pessimistic pathfinding behavior,
    where agents are encouraged to path around sparse groups of agents blocking the
    ideal path.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: DMs和拥挤地图之间最后的重大区别在于，拥挤地图根据群体的密度来权衡移动惩罚。如果不考虑密度，DMs会表现出过于悲观的路径查找行为，鼓励代理绕过稀疏的代理群体来避开理想路径。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored some popular examples of crowd interaction systems
    used on popular video games and we saw how important is to plan every interaction
    that we can think of because this is what will turn a few simple lines of code
    into a realistic-looking game. To conclude the chapter, we revisited the advanced
    pathfinding system and we saw how multiple characters in the game can share the
    same final destination, taking an alternative path to avoid colliding, and waiting
    in line for other characters to move forward.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在流行视频游戏中使用的流行群体交互系统的几个示例，并看到了为什么计划我们所能想到的每一个交互是多么重要，因为这正是将几行简单的代码变成看起来逼真的游戏的关键。为了结束本章，我们回顾了高级路径查找系统，并看到了游戏中的多个角色如何可以共享同一个最终目的地，采取替代路径以避免碰撞，并在其他角色前进时排队等待。
- en: In the next chapter, we'll be looking at AI planning and decision making. We'll
    see how we can have AI anticipating things, knowing in advance what it will do
    when arriving at a certain position or facing a certain problem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨人工智能规划和决策。我们将看到人工智能如何能够预测事物，提前知道它在到达某个位置或面对某个问题时将做什么。
