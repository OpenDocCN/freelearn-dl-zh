<html><head></head><body><div><div><h1 id="_idParaDest-267"><em class="italic"><a id="_idTextAnchor251"/>Chapter 12</em>: IMU Programming with Python</h1>
			<p>Modern robots need to know their position relative to the world. In <a href="B15660_11_Final_ASB_ePub.xhtml#_idTextAnchor219"><em class="italic">Chapter 11</em></a>, <em class="italic">Programming Encoders with Python</em>, we looked at how encoders can get an idea of how much the robot has moved or turned. However, this turning was relative to where the robot was and had no absolute reference. Wheel slipping could lead to false readings. In this chapter, you will see more ways the robot can read changes in its position and measure its movements.</p>
			<p>In principle, an <strong class="bold">inertial measurement unit</strong> (<strong class="bold">IMU</strong>) can give absolute position measurements and not slip. In practice, they are complicated. This chapter is a small practical tour of adding an IMU to your robot. I will introduce the components of an IMU in this chapter. You will also learn how to solder in order to add headers to a breakout, a skill that opens up a world of additional robot parts.</p>
			<p>We'll write some code to try the various functions and see the kind of output the sensors provides. We will then make animated visualizations of the sensor data. By the end of this chapter, you will be able to work with these advanced sensors, have some soldering experience, and put together dashboards for monitoring sensors. As you investigate more in robotics, you'll learn that animated dashboards will be vital if you want to see what your robot can see.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Learning more about inertial measurement units</li>
				<li>Soldering – attaching headers to the IMU</li>
				<li>Attaching the IMU to the robot</li>
				<li>Reading the temperature</li>
				<li>Reading the gyroscope</li>
				<li>Reading the accelerometer</li>
				<li>Reading the magnetometer</li>
			</ul>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor252"/>Technical requirements</h1>
			<p>For this chapter, you will need the following items:</p>
			<ul>
				<li>The robot from <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>, <em class="italic">Drive and Turn – Moving Motors with Python</em></li>
				<li>The robot code from <a href="B15660_11_Final_ASB_ePub.xhtml#_idTextAnchor219"><em class="italic">Chapter 11</em></a>, <em class="italic">Programming Encoders with Python</em>, which can be found at <a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11</a></li>
				<li>An ICM20948 breakout board with headers, such as the Pimoroni PIM448 module</li>
				<li>A soldering iron and stand</li>
				<li>A soldering iron tip-cleaning wire</li>
				<li>Solder – should be flux-cored solder for electronics</li>
				<li>A solder sucker</li>
				<li>A well-lit bench for soldering</li>
				<li>A ventilated space or extractor</li>
				<li>Safety goggles</li>
				<li>A breadboard</li>
				<li>A 2.5 mm standoff kit</li>
				<li>Female-to-female Dupont jumper wires</li>
			</ul>
			<p>For the complete code for this chapter, please go to <a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/38FJgsr">https://bit.ly/38FJgsr</a></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor253"/>Learning more about IMUs</h1>
			<p>An IMU is a <a id="_idIndexMarker647"/>combination of sensors designed to sense a robot's movement in a 3D space. These devices are found in drones, useful in floor-based robots, and critical for balancing robots. The IMU is not a single sensor, but a collection designed to be used together and have their readings combined.</p>
			<p>These devices are tiny but hav<a id="_idTextAnchor254"/>e their roots in flight hardware with large spinning gyroscopes. IMUs <a id="_idIndexMarker648"/>use the <strong class="bold">micro-electro-mechanical systems</strong> (<strong class="bold">MEMS</strong>) technology to put mechanical devices on micro-scale chips. They do have tiny moving parts and use electronic sensors to measure their movements.</p>
			<p>Since some measurements are analog (see <a href="B15660_02_Final_ASB_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Controllers and I/O</em>, IMU modules <a id="_idIndexMarker649"/>often include an <strong class="bold">analog to digital converter</strong> (<strong class="bold">ADC</strong>) and communicate over I2C.</p>
			<p>There are different combinations of sensors on an IMU. These sensors are as follows:</p>
			<ul>
				<li>A temperature sensor, to account for temperature effects on other sensors</li>
				<li>A gyroscope, which measures rates of rotation</li>
				<li>An accelerometer, which measures accelerations or forces</li>
				<li>A magnetometer, which measures magnetic fields and can act as a compass</li>
			</ul>
			<p>As we work with each of these sensor types, we will learn more about them and their quirks.</p>
			<p>Now that we know a little about IMUs, let's learn how to choose one.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor255"/>Suggested IMU models</h2>
			<p>IMUs can be constructed <a id="_idIndexMarker650"/>with a separate accelerometer, gyroscope, and magnetometer, along with devices to convert the output of the sensor. To reduce the wiring and space this needs, I suggest using a board with all the devices or a single chip solution. For the same reason, I recommend I2C or serial IMUs.</p>
			<p>IMU systems use <strong class="bold">degrees-of-freedom</strong> (<strong class="bold">DOF</strong>) to denote how <a id="_idIndexMarker651"/>many sensor axes are present. A 9-DOF system has three axes (X, Y, and Z) for each sensor.</p>
			<p>BNO sensors are easier to code for but are incompatible with the Raspberry Pi due to the way they use the I2C bus, and they may require an intermediate interface chip.</p>
			<p>Another thing to consider is if there is documentation (readme files and manuals) and a supported library to control the device from Python. The following picture shows a suggested IMU breakout:</p>
			<div><div><img src="img/B15660_12_01.jpg" alt="" width="1303" height="366"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – Photo of the ICM20948</p>
			<p>The preceding image is of <a id="_idIndexMarker652"/>the PIM448 breakout board for the ICM20948, a <a id="_idIndexMarker653"/>well-supported 9-DOF sensor for Python libraries. It also has a temperature sensor. It is also well distributed. Since IMUs are complex devices, I strongly suggest choosing the PIM448 for this chapter.</p>
			<p>Now that we've explored what IMU devices are and how to choose one, it's time to prepare a PIM448 for our robot with a new skill: soldering.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor256"/>Soldering – attaching headers to the IMU</h1>
			<p>Most IMU <a id="_idIndexMarker654"/>breakouts, including the suggested <a id="_idIndexMarker655"/>PM448, are likely to come with <a id="_idIndexMarker656"/>headers in a bag, which you will need to solder onto the board. You are going to need a small bit of tuition if you want to solder on these headers:</p>
			<div><div><img src="img/B15660_12_02.jpg" alt="" width="637" height="172"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2 – Bare PIM448 with headers</p>
			<p>The preceding image shows the PIM448 as it comes out of the bag. On the left is the ICM20948 board with only holes and no headers. In the middle are the male headers, while the female headers are on the right. We will use the male headers since these are easier to hold in place when soldering.</p>
			<p>As we mentioned in the <em class="italic">Technical requirements</em> section, you need a soldering iron and solder, a soldering <a id="_idIndexMarker657"/>iron stand, safety goggles, an extractor or well-ventilated space, an <a id="_idIndexMarker658"/>additional breadboard, and a well-lit <a id="_idIndexMarker659"/>workspace. Soldering creates fumes that you do not want to breathe in.</p>
			<p>Wear your safety goggles at this point. Heat the soldering iron; depending on the iron, this may take a few minutes. Pull out a bit of solder ready to use too.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor257"/>Making a solder joint</h2>
			<p>You are now ready to <a id="_idIndexMarker660"/>make a solder joint.</p>
			<p>The following image shows three of the stages of soldering the module:</p>
			<div><div><img src="img/B15660_12_03.jpg" alt="" width="1179" height="337"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 12.3 – Stages of soldering the PIM448 </p>
			<p>To make a solder joint, perform the follow steps while looking at the preceding image:</p>
			<ol>
				<li value="1">We need to ensure the part won't move while the solder dries. The preceding image shows the PIM448 lined up on the male headers, pushed into a breadboard on the bottom, with the female headers on the top. An excellent way to hold the part in place is to put the long side of the headers into the breadboard with our device on top. Since we are attaching male headers, we will use the female headers to prop up the other side.</li>
				<li>The soldering iron tip should be hot at about 300°C and tinned. Melt a little solder on the tip to test that it's warm enough. Before you can solder, you need to tin the tip. Tinning is where you put a small layer of solder onto the iron to improve its heat conductivity and protect the tip from oxidizing (getting rusty when hot). To tin the tip, push a little solder into the iron's tip, and it will stick to it. The solder should melt freely.</li>
				<li>Ensure the tip is clean – with the iron hot, push the tip of the iron into the brass cleaner, making a wiping motion with it in the wire.</li>
				<li>Heat the pin from the <a id="_idIndexMarker661"/>header and the pad (the ring that the pin goes through). We'll start on the pin that reads <strong class="bold">2-6V</strong>. Heat both the pin and the pad to avoid a dry joint, where the solder will not flow properly over the pad. Dry joints are weak, both electrically and mechanically.</li>
				<li>After a second or so, gently feed a little solder into the other side of the pin; when the pin is hot enough, the solder will melt and flow over the pad, making a rounded tent-like shape. This is just enough solder. You will see flux resin coming from the solder.</li>
				<li>The preceding image shows the next step in the middle. Here, I've soldered two pins; things gets easier from here on out since the board can't move. Move on to the next pin and repeat – heat the pin and pad, then feed in the solder.</li>
				<li>If you've added too much solder, use a solder sucker to remove the excess. Push down the plunger, bring the sucker up close to the joint, melt the solder, and press the release button of the plunger for it to suck any solder away. You can remake this joint with a bit less solder.</li>
				<li>If you find you've connected two pins with a blob of solder (bridged them), you can draw the hot iron down between the pins to divide them again. You may also need to remove any excess solder, as mentioned in <em class="italic">Step 7</em>.</li>
				<li>Repeat the preceding steps for the remaining pins. The right-hand side of the preceding image  shows what your IMU should look like once all the pins have been soldered.<p class="callout-heading">Important Note</p><p class="callout">For the sake of safety, ensure that you return the soldering iron to its stand and switch the iron off before you do anything else. A soldering iron can be a dangerous device, leading to burns or fires if left unattended.</p></li>
				<li>Once the part is cool, unplug it <a id="_idIndexMarker662"/>from the breadboard. Optionally, you can use isopropyl alcohol and a cotton bud to clean away flux residue for a better look.</li>
			</ol>
			<p>Before we wire this, make the following checks:</p>
			<ul>
				<li>You have soldered all five pins in place.</li>
				<li>Each soldered pin is like a silver "tent" shape. A bubble/round or flat shape is not right, and you will need to make that connection again.</li>
				<li>No two pins have solder <em class="italic">bridges</em> – blobs of solder connecting the pins.</li>
			</ul>
			<p>Congratulations – you have soldered your first part! This is a skill you will need again as you build more robotic and electronic devices. Now that you have soldered the ICM20948 module, let's attach it to your robot.</p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor258"/>Attaching the IMU to the robot</h1>
			<p>Before we <a id="_idIndexMarker663"/>can use the IMU and write code for it, we must securely mount it <a id="_idIndexMarker664"/>on the robot and wire it so that the Raspberry Pi can talk to it.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor259"/>Physical placement</h2>
			<p>The IMU magnetometer is <a id="_idIndexMarker665"/>sensitive to magnetic fields and needs to be away from the motors. For this reason, it should be on a stalk above the robot.</p>
			<p>The orientation of the IMU is essential for other experiments to make sense:</p>
			<div><div><img src="img/B15660_12_04.jpg" alt="" width="1385" height="334"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4 – Lining up the IMU with the robot</p>
			<p>There is a diagram on top of the IMU. The preceding diagram shows how this diagram should line up with the robot. The X-axis should face forward, while the Z-axis should face up, with the little square on the IMU pointing upward. Finally, the Y-axis should point to the left.</p>
			<p>The sensor uses I2C. I2C is sensitive to wire distances, so we should mount it above the Raspberry Pi and motor control board where the wire distances are low. The following image shows the <a id="_idIndexMarker666"/>parts you will need to do this:</p>
			<div><div><img src="img/B15660_12_05.jpg" alt="" width="1650" height="394"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5 – Parts needed to attach the IMU</p>
			<p>For this step, you will need the parts shown in the preceding image:</p>
			<ul>
				<li>The IMU, with headers mounted</li>
				<li>Many long standoffs, M2.5</li>
				<li>1x M2.5 nut</li>
			</ul>
			<p>We will assemble these parts using the standoffs to make a long post, as the following image shows:</p>
			<div><div><img src="img/B15660_12_06.jpg" alt="" width="1384" height="265"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6 – Joining the standoff posts</p>
			<p>The following steps are intended to be used with the preceding image to help you mount the IMU:</p>
			<ol>
				<li value="1">As shown in the preceding image, you just need to screw the thread of one post into the socket of the other to <a id="_idIndexMarker667"/>end up with a long post. This should give the IMU a little distance so that it can stand above the robot. Aim to be just under the cable length:<div><img src="img/B15660_12_07.jpg" alt="" width="1166" height="442"/></div><p class="figure-caption">Figure 12.7 – Bolting the IMU to the post</p></li>
				<li>As shown in the preceding image, push a post thread through the hole opposite the axis markers on the IMU <em class="italic">(a)</em>. The headers <em class="italic">(b)</em> should be facing down into the post. The <a id="_idIndexMarker668"/>thread is quite a snug fit but should fit through. Use the nut on top <em class="italic">(c)</em> to secure it in place:<div><img src="img/B15660_12_08.jpg" alt="" width="1650" height="669"/></div><p class="figure-caption">Figure 12.8 – Bolting the IMU post to the Raspberry Pi</p></li>
				<li>The preceding image shows the IMU post screwed onto a thread sticking up from the motor board. The motor board we suggested in <a href="B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, <em class="italic">Robot Building Basics – Wheels, Power, and Wiring</em>, has an I2C connector to the rear left of this board. We can bolt the IMU post to a hole near that:<div><img src="img/B15660_12_09.jpg" alt="" width="1650" height="650"/></div><p class="figure-caption">Figure 12.9 – The IMU ready for wiring</p></li>
				<li>The preceding image shows the ICM20948 attached to the post, which you bolt into the <a id="_idIndexMarker669"/>top of the motor board, with its pins ready for wiring. Adjust it so that the X-axis points forward and the Y-axis points to the left while tightening the top nut. The closer this is to square with the robot, the better your results will be!</li>
			</ol>
			<p>You have now mounted the IMU on the robot. You've lined up its axes, so we know what to expect from our sensors. Now that we have fitted this IMU module, it's firmly in place, but could be unbolted if we need to do that. The module is now ready for wiring.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor260"/>Wiring the IMU to the Raspberry Pi</h2>
			<p>Next, you need to <a id="_idIndexMarker670"/>wire the IMU to the I2C pins on the <a id="_idIndexMarker671"/>Raspberry Pi. While this seems to be an easy job, you must watch out since some connections aren't straight through.</p>
			<p>The motor board's handy I2C breakout should make this job a little easier:</p>
			<div><div><img src="img/B15660_12_10.jpg" alt="" width="1349" height="534"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.10 – The wiring of ICM20948</p>
			<p>As shown in the preceding diagram, the wiring is pretty straightforward: the <strong class="bold">GND</strong> from the IMU goes to the <strong class="bold">GND</strong> on the motor board I2C breakout, <strong class="bold">SDA</strong> goes to <strong class="bold">SDA</strong>, <strong class="bold">SCL</strong> goes to <strong class="bold">SCL</strong>, and <strong class="bold">2-6V</strong> goes to <strong class="bold">5V</strong> (in the 2-6V range). </p>
			<p>The <strong class="bold">GND</strong> goes from the left of the <a id="_idIndexMarker672"/>motor board to the right of the IMU. The <a id="_idIndexMarker673"/>four wires have a bend, with the <strong class="bold">5V</strong> line crossing it.</p>
			<p>In practice, we would use a jumper cable strip of four wires, which is shown by the dashed lines in the preceding diagram. The end going to the IMU would go straight through. The end going to the motor board has the power cable crossing the other wires:</p>
			<div><div><img src="img/B15660_12_11.jpg" alt="" width="1650" height="596"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.11 – ICM20948 IMU wired to the motor board</p>
			<p>In the preceding image, I've used a short female-to-female jumper wire to make the connections. The IMU board is at 90 degrees from its intended orientation to make the wiring more visible; it should have X facing forward. Notice that there is a twist in the wire, so the GND line (white here) ends up on the GND pin on the other side. Perform the <a id="_idIndexMarker674"/>following steps <a id="_idIndexMarker675"/>to make these connections:</p>
			<ol>
				<li value="1">Carefully pull off a strip of four wires. Aim to find a darker color for GND and a bright/vivid color for the 5V line.</li>
				<li>Plug one side directly into the IMU, ensuring you skip the INT pin.</li>
				<li>As you bring the wire to the motor board below, put a small turn in so that the cable faces the other way.</li>
				<li>Plug the GND in first, to set the orientation.</li>
				<li>Plug the 5V line in next, which will need to cross the other two wires.</li>
				<li>The final two wires should now be in the right orientation for SDA and SCL; plug in both.</li>
				<li>Use the wire colors to ensure you've made the right connections.<p>We do not intend to use the <code>INT</code> pin. This pin is designed to send an <em class="italic">interrupt</em> to the Pi, to notify us that <a id="_idIndexMarker676"/>there is a motion for wake-on-motion type <a id="_idIndexMarker677"/>behavior. However, use of this is beyond the scope of this book.</p><p>Now that we have wired this sensor in and attached it to our robot, you are ready to write some code. We'll start easy by reading the temperature.</p><h1 id="_idParaDest-276"><a id="_idTextAnchor261"/>Reading the temperature</h1><p>With the device <a id="_idIndexMarker678"/>wired and attached, you'll want to try some code on it to confirm we can talk to this device and get data out of it. Let's get some tools installed and make it work.</p><h2 id="_idParaDest-277"><a id="_idTextAnchor262"/>Installing the software</h2><p>Before we <a id="_idIndexMarker679"/>can start interacting with this device, as with most devices, we will install a helper library to <a id="_idIndexMarker680"/>communicate with it. Pimoroni, the suppliers of the ICM20948 module I've suggested, have made a handy library for Python to talk to it. I recommend taking their latest version from GitHub.</p><p>Perform the following steps to install it:</p><p>Boot up the Raspberry Pi on the robot. This Pi should have been used previously for the motor board and LED shim and have I2C enabled. If not, go back to <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>,<em class="italic"> Drive and Turn – Moving Motors with Python</em>, and follow the steps for preparing the I2C.</p></li>
				<li>Type in <code>i2cdetect -y 1</code> to check that you've installed the device correctly. The output should look like this:<pre>pi@myrobot:~ $ i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- 6f 
70: 70 -- -- -- -- -- -- —             </pre></li>
				<li>The device at 0x68 is our new device. If you do not see this, please power down the Raspberry Pi and check your wiring. The other two devices (0x6f and 0x70) are the motor board and the LED shim.</li>
				<li>Now, we can install the library:<pre>pi@myrobot:~ $ git clone https://github.com/pimoroni/icm20948-python
pi@myrobot:~ $ cd icm20948-python/
pi@myrobot:~ $ sudo ./install.sh
pi@myrobot:~ $ cd</pre></li>
				<li>You've <a id="_idIndexMarker681"/>now verified that the ICM20948 device is on the robot's I2C bus and installed the Pimoroni Python <a id="_idIndexMarker682"/>library so that it can talk with it. You are now ready to talk to it.</li>
			</ol>
			<p>We also will add some new software to visualize our data in real time. There is a system called <strong class="bold">Visual Python</strong> (<strong class="bold">VPython</strong>) that's been <a id="_idIndexMarker683"/>designed to create graphs and 3D representations in real time:</p>
			<pre>pi@myrobot:~ $ pip3 install git+https://github.com/orionrobots/vpython-jupyter.git</pre>
			<p>Now, the device and library should be installed. If this didn't work for you, try looking at the <em class="italic">Troubleshooting</em> section, which is next.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor263"/>Troubleshooting</h2>
			<p>Things can go <a id="_idIndexMarker684"/>wrong at this early stage. If you've not made things work so far, please try following these steps:</p>
			<ol>
				<li value="1">It is vital that the <code>i2cdetect</code> stage works here and shows the device at 0x68. If not, check your wiring. <em class="italic">Nothing</em> should be hot here.</li>
				<li>Ensure you have followed all the soldering checks.</li>
				<li>If the libraries fail to install, ensure you get connected to the internet. You may need to have the most recent version of Raspbian for them to work.</li>
			</ol>
			<p>Now that you have installed <a id="_idIndexMarker685"/>the device and checked for common issues, we can try our first experiment with it and read the temperature sensor.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor264"/>Reading the temperature register</h2>
			<p>In this section, we <a id="_idIndexMarker686"/>are going to set up an interface for the IMU, and then add a real-time graph for the temperature data from the Raspberry Pi.</p>
			<h3 id="_idParaDest-280">Creating the interface</h3>
			<p>As with other <a id="_idIndexMarker687"/>sensors and outputs, we must create an interface because there are many IMU devices on the market. However, the same interface allows us to change them out without rewriting other behaviors using that interface:</p>
			<ol>
				<li value="1">Create a file named <code>robot_imu.py</code></li>
				<li>Start by importing the Pimoroni device library – this will be different if you use another IMU device:<pre><strong class="bold">from icm20948 import ICM20948</strong></pre></li>
				<li>We'll make an IMU class to represent our device. This sets up a single IMU:<pre><strong class="bold">class RobotImu:</strong>
<strong class="bold">    def __init__(self):</strong>
<strong class="bold">        self._imu = ICM20948()</strong></pre></li>
				<li> For this exercise, we only need the temperature. Let's simply wrap that:<pre><strong class="bold">    def read_temperature(self):</strong>
<strong class="bold">        return self._imu.read_temperature()</strong></pre></li>
			</ol>
			<p>With this, the interface is ready. Now, we can use it to read the device's temperature.</p>
			<h3 id="_idParaDest-281">What is VPython?</h3>
			<p>VPython or Visual Python is a <a id="_idIndexMarker688"/>system designed to make visual – even 3D – displays <a id="_idIndexMarker689"/>in Python. It comes from a scientific community and will become very useful throughout this chapter. It serves output to a browser, and with the specific version installed here, it can be run on a Raspberry Pi while showing the output on a computer or smartphone.</p>
			<p>It has a few quirks, with one of them being a slow startup time, but it is worth it for the results.</p>
			<h3 id="_idParaDest-282">Graphing the temperature</h3>
			<p>A good way to observe <a id="_idIndexMarker690"/>temperature variations is by using a graph.</p>
			<p>Let's use VPython and create a graph showing the temperature of our IMU module:</p>
			<ol>
				<li value="1">Create a file named <code>plot_temperature.py</code>.</li>
				<li>Start by importing VPython and our robot IMU interface:<pre><code>vpython</code> by importing it as <code>vp</code>.</p></li>
				<li>We are going to plot temperature versus time on a graph, so we will need a time reference. Also, we will use logging to see what is going on:<pre><strong class="bold">import time</strong>
<strong class="bold">import logging</strong></pre></li>
				<li>Let's configure logging so that we can see all the <code>INFO</code> level logs:<pre><strong class="bold">logging.basicConfig(level=logging.INFO)</strong></pre></li>
				<li>Create our IMU instance:<pre><strong class="bold">imu = RobotImu()</strong></pre></li>
				<li>We want a few things from the graph. Since the X-axis is time and is in seconds, setting the minimum to <code>0</code> and the maximum to <code>60</code> will show us a minute of data. We also want the graph to scroll so that it shows new data once we've recorded more than a minute:<pre><strong class="bold">vp.graph(xmin=0, xmax=60, scroll=True)</strong>
<strong class="bold">temp_graph = vp.gcurve()</strong></pre></li>
				<li>Now that we have a time reference, let's record the start time before we get into the loop:<pre><strong class="bold">start = time.time()</strong></pre></li>
				<li>The main loop is a <code>while true</code> type. However, we need to use <code>vp.rate</code> to let VPython know we are animating and set a frame/update rate for our system:<pre><strong class="bold">while True:</strong>
<strong class="bold">    vp.rate(100)</strong></pre></li>
				<li>Now, we can capture our <a id="_idIndexMarker691"/>temperature, and while we are at it, we can log this:<pre><strong class="bold">    temperature = imu.read_temperature()</strong>
<strong class="bold">    logging.info("Temperature: {}".format(temperature))</strong></pre></li>
				<li>To put this into the graph, we need to get the elapsed time for the X-axis. We can get this by subtracting the start time from the current time:<pre><strong class="bold">    elapsed = time.time() - start</strong></pre></li>
				<li>Finally, we need to plot this in our temperature graph, with the elapsed time as <code>x</code> and the temperature as <code>y</code>:<pre><strong class="bold">    temp_graph.plot(elapsed, temperature)</strong></pre></li>
			</ol>
			<p>The code for plotting the temperature is now live. Let's run this on the Raspberry Pi.</p>
			<h3 id="_idParaDest-283">Running the temperature plotter</h3>
			<p>There are a few <a id="_idIndexMarker692"/>steps we need to follow to run this once we've copied the files to the Raspberry Pi. Our Raspberry Pi is headless, so we will need to view VPython remotely. To do so, we need to let VPython know we are doing this, and use a network port to make its view available. We can then use a browser to look at this. Let's see how:</p>
			<ol>
				<li value="1">In an SSH session to the Raspberry Pi, type the following:<pre>$ VPYTHON_PORT=9020 VPYTHON_NOBROWSER=true python3 plot_temperature.py</pre><p>We've chosen port <code>9020</code>, which is somewhat arbitrary but should be above <code>1000</code>. We will be using other web services later in this book on different ports, and this number is well clear of their ranges. When run, it should log a few messages to tell you it is ready:</p><pre>INFO:vpython.no_notebook:Creating server
http://localhost:9020
INFO:vpython.no_notebook:Server created
INFO:vpython.no_notebook:Starting serve forever loop
INFO:vpython.no_notebook:Started</pre><p>Note that it shows a localhost address. We intend to use it remotely. </p></li>
				<li>Next, point your <a id="_idIndexMarker693"/>browser (Chrome, Firefox, or Safari) from your desktop to the Raspberry Pi with the port number. In my case, based on my robot's hostname, this would be <code>http://myrobot.local:9020</code>.</li>
				<li>Now, be prepared to wait a bit – it can take a bit of time for VPython to set up. After this, you will either see your graph or any errors/problems.</li>
			</ol>
			<p>When it's running, you'll get a graph of the readings from the temperature sensor. You can experiment a little by carefully placing a finger on the sensor (the large black square on the PIM448) and watching the graph rise/fall in response to this. You could also find cold or hot objects, such as a hair dryer, to see how this manipulates it. However, be careful not to get the robot wet, and don't let metal touch the pins:</p>
			<div><div><img src="img/B15660_12_12.jpg" alt="" width="774" height="415"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 12.12 – A temperature graph</p>
			<p>The preceding image is a graph that's showing temperature in degrees (Y-axis) versus time in seconds (X-axis). The thick black line indicates the current temperature reading. It wiggles a lot – this is a noisy system.</p>
			<p>I placed my finger over the sensor at about 25 seconds. As shown in the preceding graph, the ambient temperature was 31 and raised to just under 34. It takes a few seconds to warm up. Keeping <a id="_idIndexMarker694"/>my finger there longer would have made it increase more. I had a fan present, so there was a sharp drop-off – there can be far slower drop-offs depending on your conditions. The code also logs the temperatures to the console:</p>
			<pre>INFO:root:Temperature 32.43858387995327
INFO:root:Temperature 32.726120945278105
INFO:root:Temperature 32.726120945278105
INFO:root:Temperature 32.39066103573247
INFO:root:Temperature 32.39066103573247
INFO:root:Temperature 32.63027525683649</pre>
			<p>There is a lot of noise in the decimal places that you can ignore here. When you close this browser tab, the code will stop graphing.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A warning about testing temperatures: Do not put metal objects on the sensor – this may short out the pins and damage the robot. Also, do not put wet items on it. Very cold objects may have condensation on them. Water will even short pins and damage the sensor, and possibly the Raspberry Pi.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor265"/>Troubleshooting</h2>
			<p>We are pulling two new <a id="_idIndexMarker695"/>components into our robot code here, so things may go wrong. Here are some things to check:</p>
			<ol>
				<li value="1">Be aware that VPython can be slow, so it may take a long time to start. Try refreshing the browser tab after 30 seconds.</li>
				<li>With VPython, it may take a long time to show an error message. Patience is needed when trying new code here.</li>
				<li>If you see I/O or communication errors, carefully check the wiring of the IMU. Please go back to the <em class="italic">Installing Software Troubleshooting</em> section for measures. I/O errors can also happen if you nudge a wire out while putting your finger on the sensor, or worse still if you try to cool it with a metal object and short the pins. DO NOT PUT A METAL OBJECT ON THE SENSOR!</li>
				<li>Similarly, if you see import errors, check that you do not have typing errors in the imports and ensure you have checked the <em class="italic">Installing software troubleshooting</em> section.</li>
				<li>If the temperature reading takes time to change, note that the IMU has some insulation/thermal resistance, so it takes a while to warm up (but it will) and cool down. The board also has a thermal mass, meaning it will all heat up or cool down, slowing the time it takes to reach the same temperature as the one you are measuring.</li>
				<li>There can be a few reasons for the temperature reading not being accurate. For one, the IMU can produce some heat – we've already mentioned the thermal mass. It could have a calibration offset value applied to it to make it more accurate, but do not expect it to match a thermometer to a fraction of a degree perfectly. It should certainly be able to register a finger or palm as close to 37 degrees, but in practice, and <a id="_idIndexMarker696"/>with patience, I usually got to about 36 point something.</li>
			</ol>
			<p>Our example is now working, but we could make it a bit easier to start our tests.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor266"/>Simplifying the VPython command line</h2>
			<p>We will be using VPython <a id="_idIndexMarker697"/>a lot in this chapter, and we don't want to type in a mouthful of settings to run each Python file. Let's create an alias (a command-line shortcut) to save us from having to type that stuff in every time:</p>
			<ol>
				<li value="1">Let's set it up for the current session. The <code>alias</code> command makes an alias we can reuse later. Here, it's named <code>vpython</code>. It contains the settings and the <code>python3</code> command:<pre>pi@myrobot:~ $ alias vpython="VPYTHON_PORT=9020 VPYTHON_NOBROWSER=true python3"</pre></li>
				<li>So that we can use it again at some point, we will put it into the current user's <code>.bashrc</code> file – a file that Raspbian automatically runs when you <code>ssh</code> in:<pre>pi@myrobot:~ $ echo 'alias vpython="VPYTHON_PORT=9020 VPYTHON_NOBROWSER=true python3"' &gt;&gt;~/.bashrc</pre><p>Wrapping something in <code>echo</code> will write text out instead of running a command. <code>&gt;&gt;</code> appends this to a file – in this case, <code>.bashrc</code>. The <code>~</code> mark picks the current user's home.</p></li>
				<li>You can rerun the temperature demo with <code>vpython plot_temperature.py</code>.</li>
			</ol>
			<p>In this section, you received data from the IMU device and saw how it responds to temperature. This confirms that the IMU is responding. You logged the data and graphed it and were introduced to the VPython system in the process, which can be used as a powerful graphics display system. We will use both the IMU and VPython to do far more throughout this chapter. Next, we will look at the gyroscope so that we can see how our robot is turning.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor267"/>Reading the gyroscope in Python</h1>
			<p>In this <a id="_idIndexMarker698"/>section, we are going to use the gyroscope in the IMU. We will use it to approximate where <a id="_idIndexMarker699"/>the robot is facing in three dimensions.</p>
			<p>But before we do that, let's understand it.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor268"/>Understanding the gyroscope</h2>
			<p>A gyroscope <a id="_idIndexMarker700"/>measures rotation as a rate of change in angle, perhaps in degrees per second. At each measurement, it can determine the speed of rotation around each axis:</p>
			<div><div><img src="img/B15660_12_13.jpg" alt="" width="943" height="447"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13 – Illustration of a gyroscope</p>
			<p>A gyroscope is <a id="_idIndexMarker701"/>traditionally a mechanical system, as shown in the preceding image. It has a gimbal – a set of concentric rings – connected by pivots so that they can pivot around the X-axis, Y-axis, and Z-axis. The middle has a spinning <a id="_idIndexMarker702"/>mass, known as a rotor. When the rotor is spinning, moving the handle (shown as a stand at the bottom of the image) does not affect the spinning mass, which keeps its orientation, with the gimbals allowing it to turn freely. </p>
			<p>In the case of a MEMS gyroscope, it moves a tiny mass back and forth (oscillates) very quickly. When the orientation of the gyroscope is changed, the mass will still be moving in another direction. This movement will change an electrical field that the sensor detects. In the original orientation, this <a id="_idIndexMarker703"/>movement appears to be a <a id="_idIndexMarker704"/>force, known as the Coriolis force.</p>
			<p>Before we can write some code so that we can work with the gyroscope, we need to understand coordinate systems – on the robot and in VPython.</p>
			<h3 id="_idParaDest-288">Representing coordinate and rotation systems</h3>
			<p>We are <a id="_idIndexMarker705"/>going to be using <a id="_idIndexMarker706"/>coordinate and rotation systems in this chapter. The following diagram should help you understand them:</p>
			<div><div><img src="img/B15660_12_14.jpg" alt="" width="360" height="636"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14 – The robot body coordinate system</p>
			<p>The preceding diagram shows the different coordinate systems we will be using. Let's take a look at the different sections of it:</p>
			<ol>
				<li value="1">This is the robot's <strong class="bold">Body Coordinate System</strong> – a stylized <a id="_idIndexMarker707"/>3D sketch of the robot with three axis arrows. First, there's the X-axis, which points toward the front of the robot. Rotating about this X-axis is <a id="_idIndexMarker708"/>known as <strong class="bold">roll</strong>. Then, there's the Y-axis, which indicates to the left of the robot (your right as you view the robot). Rotating about this <a id="_idIndexMarker709"/>axis is known as <strong class="bold">pitch</strong>. Finally, pointing up through the robot is the Z-axis. Rotating <a id="_idIndexMarker710"/>about this axis is <a id="_idIndexMarker711"/>known as <strong class="bold">heading</strong> or <strong class="bold">yaw</strong>.<p>The direction of rotation is important. There is a rule of thumb for this: take your right hand and put your thumb up. If your thumb is pointing along the axis, then the fingers on your fist have wrapped the way the rotation will go.</p></li>
				<li>This is the VPython <strong class="bold">World Coordinate System</strong>. We <a id="_idIndexMarker712"/>display 3D images in VPython here. VPython's coordinate system is a rotation of the robot body system.<p>In the preceding diagram, the Y-axis is going up, the X-axis is going to the right, and the Z-axis is pointing forward.</p></li>
			</ol>
			<p>We will represent the coordinates in 3D as X, Y, and Z components – this is <a id="_idIndexMarker713"/>known as a <strong class="bold">vector</strong>.</p>
			<p>When we apply <a id="_idIndexMarker714"/>our measurements to things in the VPython <a id="_idIndexMarker715"/>system, we will align our view with the robot coordinate system. When we're talking about a coordinate system relative to another, this is <a id="_idIndexMarker716"/>known as a <strong class="bold">pose</strong>. This is the robot's pose with respect to the VPython coordinate system.</p>
			<p>Let's represent this with a bit of code to help us out:</p>
			<ol>
				<li value="1">Create a file named <code>robot_pose.py</code>.</li>
				<li>We are manipulating the VPython view, so we need to import it, as follows:<pre><strong class="bold">import vpython as vp</strong></pre></li>
				<li>We can then add our function to set the view up; I've called it <code>robot_view</code>:<pre><strong class="bold">def robot_view():</strong></pre></li>
				<li>In this function, we need to set the two properties that VPython uses to control camera orientation:<div><img src="img/B15660_12_15.jpg" alt="" width="713" height="346"/></div><pre><strong class="bold">    vp.scene.forward = vp.vector(-3, -1, -1) </strong></pre></li>
				<li>An axis tells us where to look along, but not which way <em class="italic">up</em> is. We need the camera to align its definition of up with the robot (which has Z pointing up); otherwise, the vectors could be upside down or to the side:<pre><strong class="bold">    vp.scene.up = vp.vector(0, 0, 1)</strong></pre></li>
			</ol>
			<p>We will use this pose <a id="_idIndexMarker719"/>more in later sections; however, for <a id="_idIndexMarker720"/>now, it's useful to see that the Z-axis is now up, as well as where we rotate around the different axes.</p>
			<p>Now, let's set up the gyroscope for reading.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor269"/>Adding the gyroscope to the interface</h2>
			<p>Before we can read the <a id="_idIndexMarker721"/>gyroscope, we'll need to add it to our <code>robot_imu.py</code> interface:</p>
			<ol>
				<li value="1">We are going to be dealing with a few x, y, and z groups from our IMU. We will import a vector type to store these. I've highlighted the new code here:<pre><strong class="bold">from icm20948 import ICM20948</strong>
<strong class="bold">from vpython import vector</strong></pre></li>
				<li>A vector is a representation of three component coordinate systems. Now, we need to fetch the gyroscope data from the underlying IMU library and store it in a vector:<code>ICM20948</code> library we are using does not have a call to return only gyroscope data, but it does have one that returns both accelerometer and gyroscope data. </p><p>This <code>ICM20948</code> library returns the data as a list of six items. In Python, when unpacking return values, the underscore character, <code>_</code>, can denote things to ignore. </p></li>
				<li>We can now put the three gyroscope values into a body vector to return them:<pre><strong class="bold">        return vector(x, y, z)</strong></pre></li>
			</ol>
			<p>The IMU library is <a id="_idIndexMarker722"/>now ready for us to read gyroscope data from it. Next, we are going to read it and plot the data on a graph.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor270"/>Plotting the gyroscope</h2>
			<p>As we <a id="_idIndexMarker723"/>mentioned previously, the gyroscope measures the rate of rotation. It does so in degrees per second on each axis.</p>
			<p>Let's graph the output of this device:</p>
			<ol>
				<li value="1">Create a file named <code>plot_gyroscope.py</code>.</li>
				<li>We'll start with the imports, setting up logging, and the IMU, as we did previously:<pre><strong class="bold">import vpython as vp</strong>
<strong class="bold">import logging</strong>
<strong class="bold">import time</strong>
<strong class="bold">from robot_imu import RobotImu</strong>
<strong class="bold">logging.basicConfig(level=logging.INFO)</strong>
<strong class="bold">imu = RobotImu()</strong></pre></li>
				<li>We set up three graphs for the three axes that the gyroscope outputs – X rotation, Y rotation, and Z rotation. Note that we give each graph a different color:<pre><strong class="bold">vp.graph(xmin=0, xmax=60, scroll=True)</strong>
<strong class="bold">graph_x = vp.gcurve(color=vp.color.red)</strong>
<strong class="bold">graph_y = vp.gcurve(color=vp.color.green)</strong>
<strong class="bold">graph_z = vp.gcurve(color=vp.color.blue)</strong></pre><p>The three graphs will overlay on the same line.</p></li>
				<li>Now, we need to set a start time, start a loop, and measure the elapsed time:<pre><strong class="bold">start = time.time()</strong>
<strong class="bold">while True:</strong>
<strong class="bold">    vp.rate(100)</strong>
<strong class="bold">    elapsed = time.time() – start</strong></pre></li>
				<li>We can now read the IMU and put the three readings into the graphs:<pre><strong class="bold">    gyro = imu.read_gyroscope()</strong>
<strong class="bold">    graph_x.plot(elapsed, gyro.x)</strong>
<strong class="bold">    graph_y.plot(elapsed, gyro.y)</strong>
<strong class="bold">    graph_z.plot(elapsed, gyro.z)</strong></pre></li>
				<li>Upload the files and run them with <code>vpython plot_gyroscope.py</code>.</li>
				<li>Wait a minute or so and then point a browser at <code>myrobot.local:9020</code> – it can take up to 1 minute for this to appear.</li>
				<li>Start to move the <a id="_idIndexMarker724"/>robot around – lift it and try tilting in each of the three axes. You should see something like the following graph:</li>
			</ol>
			<div><div><img src="img/B15660_12_16.jpg" alt="" width="1056" height="530"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.16 – VPython plot of gyroscope data</p>
			<p>The preceding graph contains three lines. The Y-axis shows a movement rate in degrees per second, while the X-axis shows the time in seconds since the program started. On-screen, the graphs are in red, green, and blue.</p>
			<p>The graph spikes when you make movements, and then returns to zero. Try pushing the front of the robot (the nose) down; this is positive around the Y-axis. The green line should move up (shown at about 3 seconds in the preceding graph). If you keep it there, the line will flatten. When you return the robot to flat, there will be a negative green spike on the line. Now, try lifting the left-hand side by turning it around the X-axis, creating a positive red spike on your graph. When you return it flat, you'll get a negative peak. Next, try turning the robot to the left; this will create a positive blue spike. Now, if you turn it to the right, a negative blue spike will be created. Move around the axes to get a feel for these measurements.</p>
			<p>Unless you are spinning a robot constantly, you'll likely find that it's reasonably hard to keep up any turning force; this shows that the gyroscope data is a rate of turn, and not a measure of direction. What <a id="_idIndexMarker725"/>would be more useful is to approximate the heading of the robot. When we dive deeper, we'll learn how to use gyroscope data for this.</p>
			<p>In this section, you've seen the gyroscope and how it measures rotation rates via a graph demonstrating this principle. Now, let's move on to the accelerometer so that we can see the forces that are acting on our robot!</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor271"/>Reading an accelerometer in Python</h1>
			<p>In this section, we <a id="_idIndexMarker726"/>will learn how to use an accelerometer to <a id="_idIndexMarker727"/>measure forces acting on the robot, and most often, which way is down. Let's find out more about it, then write some code to see how it works.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor272"/>Understanding the accelerometer</h2>
			<p>An accelerometer <a id="_idIndexMarker728"/>measures acceleration or changes in speed, both in terms of size and direction. It does so by providing three values – one for each of the X, Y, and Z axes: </p>
			<div><div><img src="img/B15660_12_17.jpg" alt="" width="1352" height="339"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.17 – Accelerometer concept – mass with springs</p>
			<p>The preceding diagram shows a conceptual view of an accelerometer. Let's take a look at it in more detail:</p>
			<ol>
				<li value="1">This shows a ball (a mass) suspended by six springs in a box. When there are no forces on the box, the ball stays in the middle.</li>
				<li>This shows how this system behaves when the large arrow pushes it. The mass retains inertia by moving to the right, compressing the right spring and extending the left spring.</li>
			</ol>
			<p>Measuring the position of the mass shows the direction and size of an acceleration. A MEMS accelerometer is similar to this device and is constructed with a tiny silicon mass and springs. This measures an electric field that changes as the mass moves.</p>
			<p>While on Earth, a mass is <a id="_idIndexMarker729"/>pulled downward by gravity. This system behaves like a force is holding the box up, so an accelerometer will usually register an upward force. We can use this measurement to determine which way down is and sense the tilt of a robot.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor273"/>Adding the accelerometer to the interface</h2>
			<p>Let's start by <a id="_idIndexMarker730"/>adding the accelerometer measurement to our <code>RobotImu</code> library:</p>
			<ol>
				<li value="1">Open the <code>robot_imu.py</code> file.</li>
				<li>Add the following code to do the reading:<pre><strong class="bold">    def read_accelerometer(self):</strong>
<strong class="bold">        accel_x, accel_y, accel_z, _, _, _ = self._imu.read_accelerometer_gyro_data()</strong>
<strong class="bold">        return vector(accel_x, accel_y, accel_z)</strong></pre><p>This uses the same library call as the gyroscope; however, it now discards the last three data items instead of the first three.</p></li>
			</ol>
			<p>Now that the accelerometer is ready to read, we can render this to make the data visible. </p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor274"/>Displaying the accelerometer as a vector</h2>
			<p>The acceleration is a <a id="_idIndexMarker731"/>vector; it points to a 3D space <a id="_idIndexMarker732"/>with a direction and size. A great way to show this is as an arrow in 3D. To clarify where this vector is, we can plot an indicator for each of the X, Y, and Z axes:</p>
			<ol>
				<li value="1">Create a file named <code>accelerometer_vector.py</code>. Start it with some simple imports, including the robot view, the logging setup, and initializing the IMU:<pre><strong class="bold">import vpython as vp</strong>
<strong class="bold">import logging</strong>
<strong class="bold">from robot_imu import RobotImu</strong>
<strong class="bold">from robot_pose import robot_view</strong>
<strong class="bold">logging.basicConfig(level=logging.INFO)</strong>
<strong class="bold">imu = RobotImu()</strong></pre></li>
				<li>Let's look at this from the angle we tend to view the robot at:<pre><strong class="bold">robot_view()</strong></pre></li>
				<li>Now, we want to define four arrows. VPython arrows point along an axis and can have their color and length set:<pre><strong class="bold">accel_arrow = vp.arrow(axis=vp.vector(0, 0, 0))</strong>
<strong class="bold">x_arrow = vp.arrow(axis=vp.vector(1, 0, 0),</strong>
<strong class="bold">                   color=vp.color.red)</strong>
<strong class="bold">y_arrow = vp.arrow(axis=vp.vector(0, 1, 0), </strong>
<strong class="bold">                   color=vp.color.green)</strong>
<strong class="bold">z_arrow = vp.arrow(axis=vp.vector(0, 0, 1), </strong>
<strong class="bold">                   color=vp.color.blue)</strong></pre></li>
				<li>Now, we can start the main loop:<pre><strong class="bold">while True:</strong>
<strong class="bold">    vp.rate(100)</strong></pre></li>
				<li>Read the accelerometer and log it:<pre><strong class="bold">    accel = imu.read_accelerometer()</strong>
<strong class="bold">    print(f"Accelerometer: {accel}")</strong></pre></li>
				<li>Because bumps can knock our scale out, we will normalize the vector to so that its length is 1. We need to put this in the arrow axis:<pre><strong class="bold">    accel_arrow.axis = accel.norm()</strong></pre></li>
				<li>Upload this to the Raspberry Pi and start it with <code>vpython accelerometer_vector.py</code>. Point your browser to it to see the following output:<div><img src="img/B15660_12_18.jpg" alt="" width="1391" height="407"/></div><p class="figure-caption">Figure 12.18 – The accelerometer vector</p><p>The preceding image shows the three colored arrows – red for the X-axis (pointing to the viewer), green for the Y-axis (pointing left), and blue for the Z-axis (pointing up). There is a <a id="_idIndexMarker733"/>gray arrow showing the accelerometer vector. The accelerometer <a id="_idIndexMarker734"/>points up, which shows what is holding it up against gravity.</p></li>
				<li>Now, if you tilt the robot, the arrow will tilt to show you which way up is relative to the robot. You can tilt the robot a few ways to see how this feels.</li>
			</ol>
			<p>This is exciting – you have now shown where up is, relative to your robot. To use this to rotate things, we need to turn this vector into pitch and roll angles, which we'll learn how to do when we dive deeper.</p>
			<p>In this section, you have learned how to read data from the accelerometer component and how to display it as a vector. Now, we will move on to the next element of the IMU, known as the magnetometer, and read the magnetic fields that are acting on our system.</p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor275"/>Working with the magnetometer</h1>
			<p>A magnetometer reads <a id="_idIndexMarker735"/>magnetic field strengths in 3D to produce a vector. Code you write can use this to find the magnetic north, in the same way as a compass. In this section, we'll look closer at the device, learn how to get a reading from it, and see what vectors it produces.</p>
			<p>It may be useful to have a <a id="_idIndexMarker736"/>space with very few magnets present. Let's understand the magnetometer more.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor276"/>Understanding the magnetometer</h2>
			<p>A compass <a id="_idIndexMarker737"/>measures a heading from the Earth's magnetic field by using a magnetized needle or disk. The following image is of a compass:</p>
			<div><div><img src="img/B15660_12_19.jpg" alt="" width="1650" height="316"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.19 – A traditional compass</p>
			<p>The compass shown in the preceding image has a rotating magnetized disk balanced on a center pin. This variety is a small <em class="italic">button compass</em>, which is about 25 mm in diameter.</p>
			<p>Our chosen IMU contains a device <a id="_idIndexMarker738"/>known as a <strong class="bold">magnetometer</strong>. This electronically senses a magnetic field and can be used as a compass.</p>
			<p>Most magnetometers pass electricity through a material that creates a current when it's exposed to a magnetic field, as shown in the following diagram:</p>
			<div><div><img src="img/B15660_12_20.jpg" alt="" width="875" height="330"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.20 – A stylized picture of a Hall-effect sensor</p>
			<p>The preceding diagram <a id="_idIndexMarker739"/>shows an example of this in action:</p>
			<ol>
				<li value="1">This circuit passes an electric current from a battery (left) through a conducting plate (gray rectangle). The arrows demonstrate the electrons (negative charge carriers) that are moving around the circuit, from the top of the plate straight to the bottom. The small circle with a V inside it is a voltage (electric flow) sensor that's connected to the sides of the plate. The voltage sensor reads 0 since there's no flow to the sensor.</li>
				<li>A magnet is above the plate, deflecting the electrons to one side. They give one side of the plate a negative charge, and the other side a positive charge. This difference in charge makes voltage flow through the sensor, as shown by the arrows. The reading below is now above zero.</li>
				<li>Putting the magnet on the other side of the sensor changes the magnetic field; the electrons are deflected to the other side, causing reverse voltage to flow. The arrows going to the meter are going in the opposite direction, and the reading shows a voltage below zero.</li>
			</ol>
			<p>This is known <a id="_idIndexMarker740"/>as the Hall effect. By measuring three plates, you can measure magnetic fields in three dimensions. Magnetometers <a id="_idIndexMarker741"/>are sensitive to magnetic fields and metal objects.</p>
			<p>Another quirk is that on some IMUs, the magnetometer's axes are different from the other devices':</p>
			<div><div><img src="img/B15660_12_21.jpg" alt="" width="926" height="402"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.21 – The magnetometer's axes</p>
			<p>In the preceding <a id="_idIndexMarker742"/>diagram, the axes we looked at previously are shown on the left for the gyroscope and accelerometer. On the right, we can see the axes for the magnetometer. Here, we can see that the Z-axis points downward and that the Y-axis now points backward. It's like we've rotated 180 degrees around the X-axis.</p>
			<p>Now, let's add some code so that we can read this information.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor277"/>Adding the magnetometer interface</h2>
			<p>We'll wrap this the <a id="_idIndexMarker743"/>same way we wrapped the other readings; that is, by adding it to our interface library:</p>
			<ol>
				<li value="1">Open the <code>robot_imu.py</code> file.</li>
				<li>In the <code>RobotIMU</code> class, after the <code>read_gyroscope</code> method, add the new read method:<pre><strong class="bold">    def read_magnetometer(self):</strong></pre></li>
				<li>Unlike the accelerometer and gyroscope, this reads data from a separate call to the underlying device library. We wrap this up and return a vector. For a cheeky rotation by 180 degrees, we negate the Y and Z axes:<pre><strong class="bold">        mag_x, mag_y, mag_z = self._imu.read_magnetometer_data()</strong>
<strong class="bold">        return vector(mag_x, -mag_y, -mag_z)</strong></pre></li>
			</ol>
			<p>Now that this interface is ready to use, let's get some readings.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor278"/>Displaying magnetometer readings</h2>
			<p>One way we can <a id="_idIndexMarker744"/>visualize this is to turn magnetometer output into a vector, like so:</p>
			<ol>
				<li value="1">Create a file named <code>magnetometer_vector.py</code>.</li>
				<li>Add the familiar imports and setup:<pre><strong class="bold">import vpython as vp</strong>
<strong class="bold">import logging</strong>
<strong class="bold">from robot_imu import RobotImu</strong>
<strong class="bold">from robot_pose import robot_view</strong>
<strong class="bold">logging.basicConfig(level=logging.INFO)</strong>
<strong class="bold">imu = RobotImu()</strong>
<strong class="bold">robot_view()</strong></pre></li>
				<li>Now, we will create an arrow for the magnetometer reading, along with the reference X, Y, and Z axes:<pre><strong class="bold">mag_arrow = vp.arrow(pos=vp.vector(0, 0, 0))</strong>
<strong class="bold">x_arrow = vp.arrow(axis=vp.vector(1, 0, 0), color=vp.color.red)</strong>
<strong class="bold">y_arrow = vp.arrow(axis=vp.vector(0, 1, 0), color=vp.color.green)</strong>
<strong class="bold">z_arrow = vp.arrow(axis=vp.vector(0, 0, 1), color=vp.color.blue)</strong></pre></li>
				<li>Next, we start the main loop:<pre><strong class="bold">while True:</strong>
<strong class="bold">    vp.rate(100)</strong></pre></li>
				<li>Now, we can read the magnetometer:<pre><strong class="bold">    mag = imu.read_magnetometer()</strong></pre></li>
				<li>Finally, let's set an arrow's axis that will match this vector. We can use the <code>.norm()</code> method to normalize this vector. We also need to print the data:<pre><strong class="bold">    mag_arrow.axis = mag.norm()</strong>
<strong class="bold">    print(f"Magnetometer: {mag}")</strong></pre></li>
				<li>Send this to the <a id="_idIndexMarker745"/>robot and run it with the usual VPython settings. You should see something like the following:</li>
			</ol>
			<div><div><img src="img/B15660_12_22.jpg" alt="" width="1002" height="321"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.22 – The magnetometer's reading</p>
			<p>The preceding image shows a canvas with a red arrow for the X-axis pointing forward, a blue arrow for the Z-axis pointing up, and a green arrow for the Y-axis pointing right. There is a gray arrow showing the magnetometer vector (XZ only) pointing backward.</p>
			<p>Yours may be pointing in a different direction compared to mine. This is because it is likely to be pointing to where the pin headers are on your IMU. Why is this?</p>
			<p>Pin headers are usually made from magnetic metal. You can check this out for yourself by taking a magnet and seeing if it sticks to the headers (use some spares or do this when the power is off). You should also be able to observe what this does to the arrow. You could also take a bit of <a id="_idIndexMarker746"/>metal, such as a screwdriver, and wave it around the magnetometer. This should send the results all over the place.</p>
			<p>Later, we will need to compensate for nearby metal as it may be creating a large offset, large enough to overwhelm Earth's relatively weak magnetic field completely.</p>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor279"/>Summary</h1>
			<p>In this chapter, you learned how to read four sensors on an inertial measurement unit, as well as how to display or graph data. You then had your first experience with soldering – a vital skill when it comes to making robots. You also learned about robot coordinate systems.</p>
			<p>Later in this book, we will dive deeper into knitting the IMU sensors together to get an approximation of the robot's orientation.</p>
			<p>In the next chapter, we will look at computer vision; that is, how to extract information from a camera and make the robot respond to what it can see.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor280"/>Exercises</h1>
			<ul>
				<li>In the temperature graph, you will notice a lot of noise in the graph and the output. The Python <code>round</code> function takes a number and the number of decimal places to keep, defaulting to 0. Use this to round off the temperature to a more reasonable value.</li>
				<li>Try putting the accelerometer values into an X, Y, and Z graph, as we did for the gyroscope. Observe the changes in the chart when you move the robot. Is it smooth, or is there noise? </li>
				<li>Could the gyroscope values be shown as a vector?</li>
				<li>Are there other sensors that can be soldered that you might find interesting for your robot to use?</li>
			</ul>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor281"/>Further reading</h1>
			<p>Please refer to the following links for more information regarding what was covered in this chapter:</p>
			<ul>
				<li>To learn more about VPython, take a look at the extensive help at <a href="https://www.glowscript.org/docs/VPythonDocs/index.html">https://www.glowscript.org/docs/VPythonDocs/index.html</a>.</li>
				<li>Paul McWarter Arduino experiments with an IMU: <a href="https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/">https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/</a>.</li>
				<li>Adafruit have guides on using IMUs with their libraries: <a href="https://learn.adafruit.com/adafruit-sensorlab-magnetometer-calibration">https://learn.adafruit.com/adafruit-sensorlab-magnetometer-calibration</a>.</li>
				<li>This YouTube talk by Google contains excellent information on the subject of <em class="italic">Sensor Fusion on Android Devices: A Revolution in Motion Processing</em>: <a href="https://www.youtube.com/watch?v=C7JQ7Rpwn2k">https://www.youtube.com/watch?v=C7JQ7Rpwn2k</a>.</li>
			</ul>
		</div>
	</div></body></html>