["```py\nusing UnityEngine;\n\npublic class Path: MonoBehaviour\n{\n    [SerializeField]\n    private Vector3[] waypoints;\n\n    public bool isDebug = true;\n    public float radius = 2.0f;\n\n    public float PathLength {\n        get { return waypoints.Length; }\n    }\n\n    public Vector3 GetPoint(int index)\n    {\n        return waypoints[index];\n    }\n\n    private void OnDrawGizmos()\n    {\n        if (!isDebug) {\n            return;\n        }\n\n        for (int i = 0; i < waypoints.Length; i++)\n        {\n            if (i + 1 < waypoints.Length)\n            {\n                Debug.DrawLine(waypoints[i], waypoints[i + 1], Color.red);\n            }\n        }\n    }\n}\n```", "```py\npublic class Pathing : MonoBehaviour \n{\n    [SerializeField]\n    private Path path;\n    [SerializeField]\n    private float speed = 20.0f;\n    [SerializeField]\n    private float mass = 5.0f;\n    [SerializeField]\n    private bool isLooping = true;\n\n    private float currentSpeed;\n    private int currentPathIndex = 0;\n    private Vector3 targetPoint;\n    private Vector3 direction;\n    private Vector3 targetDirection;\n```", "```py\nprivate void Start () \n    {\n        // Initialize the direction as the agent's current facing direction\n        direction = transform.forward; \n        // We get the firt point along the path\n        targetPoint = path.GetPoint(currentPathIndex);\n  }\n```", "```py\n  private void Update () \n  {\n        if(path == null) {\n            return;\n        }\n\n        currentSpeed = speed * Time.deltaTime;\n\n        if(TargetReached())\n        {\n            if (!SetNextTarget()) {\n                return;\n            }\n        }\n\n        direction += Steer(targetPoint);\n        transform.position += direction; //Move the agent according to the direction\n        transform.rotation = Quaternion.LookRotation(direction); //Rotate the agent towards the desired direction\n  }\n```", "```py\nprivate bool TargetReached() \n{\n    return (Vector3.Distance(transform.position, targetPoint) < path.radius);\n}\n```", "```py\nprivate bool SetNextTarget() \n{\n    bool success = false;\n    if (currentPathIndex < path.PathLength - 1) {\n        currentPathIndex++;\n        success = true;\n    } \n    else \n    {\n        if(isLooping) \n        {\n            currentPathIndex = 0;\n            success = true;\n        } \n        else \n        {\n            success = false;\n        }\n    }\n    targetPoint = path.GetPoint(currentPathIndex);\n    return success;\n}\n```", "```py\npublic Vector3 Steer(Vector3 target)\n{\n    // Subtracting vector b - a gives you the direction from a to b. \n    targetDirection = (target - transform.position);\n    targetDirection.Normalize(); \n    targetDirection*= currentSpeed;\n\n    Vector3 steeringForce = targetDirection - direction; \n    Vector3 acceleration = steeringForce / mass;\n    return acceleration;\n}\n```", "```py\nusing UnityEngine;\n\npublic class Avoidance : MonoBehaviour \n{\n    [SerializeField]\n    private float movementSpeed = 20.0f;\n    [SerializeField]\n    private float rotationSpeed = 5.0f;\n    [SerializeField]\n    private float force = 50.0f;\n    [SerializeField]\n    private float minimumAvoidanceDistance = 20.0f;\n    [SerializeField]\n    private float toleranceRadius = 3.0f;\n\n    private float currentSpeed;\n    private Vector3 targetPoint;\n    private RaycastHit mouseHit;\n    private Camera mainCamera;\n    private Vector3 direction;\n    private Quaternion targetRotation;\n    private RaycastHit avoidanceHit;\n    private Vector3 hitNormal;\n\n    private void Start () \n    {\n        mainCamera = Camera.main;\n        targetPoint = Vector3.zero;\n    }\n```", "```py\n  private void Update () \n  {\n        CheckInput();\n        direction = (targetPoint - transform.position);\n        direction.Normalize();\n\n        //Apply obstacle avoidance\n        ApplyAvoidance(ref direction);\n\n        //Don't move the agent when the target point is reached\n        if(Vector3.Distance(targetPoint, transform.position) < toleranceRadius) {\n            return;\n        }\n\n        currentSpeed = movementSpeed * Time.deltaTime;\n\n        //Rotate the agent towards its target direction \n        targetRotation = Quaternion.LookRotation(direction);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed *                   Time.deltaTime);\n\n        //Move the agent forard\n        transform.position += transform.forward * currentSpeed;\n    }\n```", "```py\nprivate void CheckInput() \n{\n    if (Input.GetMouseButtonDown(0)) \n    {\n        var ray = mainCamera.ScreenPointToRay(Input.mousePosition);\n        if (Physics.Raycast(ray, out mouseHit, 100.0f)) {\n            targetPoint = mouseHit.point;\n        }\n    }\n}\n```", "```py\ndirection = (targetPoint - transform.position);\ndirection.Normalize();\n\n//Apply obstacle avoidance\nApplyAvoidance(ref direction);\n```", "```py\nprivate void ApplyAvoidance(ref Vector3 direction)\n{\n    //Only detect layer 8 (Obstacles)\n    //We use bitshifting to create a layermask with a value of \n    //0100000000 where only the 8th position is 1, so only it is active.\n    int layerMask = 1 << 8;\n\n    //Check that the agent hit with the obstacles within it's minimum distance to avoid\n    if (Physics.Raycast(transform.position, transform.forward, out avoidanceHit, minimumAvoidanceDistance, layerMask))\n    {\n        //Get the normal of the hit point to calculate the new direction\n        hitNormal = avoidanceHit.normal;\n        hitNormal.y = 0.0f; //Don't want to move in Y-Space\n\n        //Get the new directional vector by adding force to agent's current forward vector\n        direction = transform.forward + hitNormal * force;\n    }\n}\n```", "```py\n0000 0000 0000 0000 0000 0000 0000 0001\n```", "```py\n0000 0000 0000 0000 0000 0000 0000 1111\n```", "```py\n0000 0000 0000 0000 0000 0001 0000 0000\n```", "```py\nint layerMask = 1 << 8;\n```", "```py\n0000 0000 0000 0000 0000 0000 0000 0001 //Int value of 1\n                              <<<< <<<< //Shift left 8 times\n0000 0000 0000 0000 0000 0001 0000 0000 //Int value of 256\n```", "```py\n//Check that the agent hit with the obstacles within it's minimum distance to avoid\nif (Physics.Raycast(transform.position, transform.forward, out avoidanceHit, minimumAvoidanceDistance,     layerMask))\n{\n    //Get the normal of the hit point to calculate the new direction\n    hitNormal = avoidanceHit.normal;\n    hitNormal.y = 0.0f; //Don't want to move in Y-Space\n\n    //Get the new direction vector by adding force to agent's current forward vector\n    direction = transform.forward + hitNormal * force;\n}\n```", "```py\n//Don't move the agent when the target point is reached\nif(Vector3.Distance(targetPoint, transform.position) < toleranceRadius) {\n    return;\n}\n\ncurrentSpeed = movementSpeed * Time.deltaTime;\n\n//Rotate the agent towards its target direction \ntargetRotation = Quaternion.LookRotation(direction);\ntransform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed *                   Time.deltaTime);\n\n//Move the agent forard\ntransform.position += transform.forward * currentSpeed;\n```", "```py\nF = G + H\n```", "```py\nusing UnityEngine;\nusing System;\n\npublic class Node : IComparable\n{\n    //Total cost so far for the node\n    public float gCost;\n    //Estimated cost from this node to the goal node\n    public float hCost;\n    //Is this an obstacle node\n    public bool bObstacle;\n    //Parent of the node in the linked list\n    public Node parent;\n    //Position of the node in world space\n    public Vector3 position; \n\n    public Node()\n    {\n        hCost = 0.0f;\n        gCost = 1.0f;\n        bObstacle = false;\n        parent = null;\n    }\n\n    public Node(Vector3 pos)\n    {\n        hCost = 0.0f;\n        gCost = 1.0f;\n        bObstacle = false;\n        parent = null;\n\n        position = pos;\n    }\n\n    public void MarkAsObstacle()\n    {\n        bObstacle = true;\n    }\n\n    //IComparable Interface method implementation\n    public int CompareTo(object obj)\n    {\n        Node node = (Node)obj;\n        if (hCost < node.hCost) \n        {\n            return -1;\n        }\n        if (hCost > node.hCost) \n        {\n            return 1;\n        }\n        return 0;\n    }\n}\n```", "```py\nusing System.Collections;\n\npublic class PriorityQueue \n{\n    private ArrayList nodes = new ArrayList();\n\n    public int Length\n    {\n        get { return nodes.Count; }\n    }\n\n    public bool Contains(object node)\n    {\n        return nodes.Contains(node);\n    }\n\n    public Node GetFirstNode()\n    {\n        if (nodes.Count > 0)\n        {\n            return (Node)nodes[0];\n        }\n        return null;\n    }\n\n    public void Push(Node node)\n    {\n        nodes.Add(node);\n        nodes.Sort();\n    }\n\n    public void Remove(Node node)\n    {\n        nodes.Remove(node);\n        nodes.Sort();\n    }\n}\n```", "```py\n [SerializeField]\n private int numberOfRows = 20;\n [SerializeField]\n public int numberOfColumns = 20;\n [SerializeField]\n public float gridCellSize = 2;\n [SerializeField]\n public bool showGrid = true;\n [SerializeField]\n public bool showObstacleBlocks = true;\n\n private Vector3 origin = new Vector3();\n private GameObject[] obstacleList;\n private Node[,] nodes { get; set; } \n```", "```py\nobstacleList = GameObject.FindGameObjectsWithTag(\"Obstacle\");\n```", "```py\nprivate void InitializeNodes() \n{\n    nodes = new Node[numberOfColumns, numberOfRows];\n\n    int index = 0;\n    for (int i = 0; i < numberOfColumns; i++) \n    {\n        for (int j = 0; j < numberOfRows; j++) \n        {\n            Vector3 cellPosition = GetGridCellCenter(index);\n            Node node = new Node(cellPosition);\n            nodes[i, j] = node;\n            index++;\n        }\n    }\n}\n```", "```py\nprivate void CalculateObstacles()\n{\n    if (obstacleList != null && obstacleList.Length > 0)\n    {\n        foreach (GameObject data in obstacleList)\n        {\n            int indexCell = GetGridIndex(data.transform.position);\n            int column = GetColumnOfIndex(indexCell);\n            int row = GetRowOfIndex(indexCell);\n\n            nodes[row, column].MarkAsObstacle();\n        }\n    }\n}\n```", "```py\npublic void GetNeighbors(Node node, ArrayList neighbors)\n{\n    Vector3 neighborPosition = node.position;\n    int neighborIndex = GetGridIndex(neighborPosition);\n\n    int row = GetRowOfIndex(neighborIndex);\n    int column = GetColumnOfIndex(neighborIndex);\n\n    //Bottom\n    int leftNodeRow = row - 1;\n    int leftNodeColumn = column;\n    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);\n\n    //Top\n    leftNodeRow = row + 1;\n    leftNodeColumn = column;\n    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);\n\n    //Right\n    leftNodeRow = row;\n    leftNodeColumn = column + 1;\n    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);\n\n    //Left\n    leftNodeRow = row;\n    leftNodeColumn = column - 1;\n    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);\n}\n\n// Check the neighbor. If it's not an obstacle, assign the neighbor.\nprivate void AssignNeighbor(int row, int column, ArrayList neighbors)\n{\n    if (row != -1 && column != -1 && row < numberOfRows && column < numberOfColumns)\n    {\n        Node nodeToAdd = nodes[row, column];\n        if (!nodeToAdd.bObstacle)\n        {\n            neighbors.Add(nodeToAdd);\n        }\n    } \n}\n```", "```py\nusing UnityEngine;\nusing System.Collections;\n\npublic class AStar\n{\n    public static PriorityQueue closedList;\n    public static PriorityQueue openList;\n\n    private static ArrayList CalculatePath(Node node)\n    {\n        ArrayList list = new ArrayList();\n        while (node != null)\n        {\n            list.Add(node);\n            node = node.parent;\n        }\n        list.Reverse();\n        return list;\n    }\n\n    /// Calculate the estimated Heuristic cost to the goal \n    private static float EstimateHeuristicCost(Node curNode, Node goalNode)\n    {\n        Vector3 vecCost = curNode.position - goalNode.position;\n        return vecCost.magnitude;\n    }\n\n    // Find the path between start node and goal node using A* Algorithm\n    public static ArrayList FindPath(Node start, Node goal)\n    {\n        openList = new PriorityQueue();\n        openList.Push(start);\n        start.gCost = 0.0f;\n        start.hCost = EstimateHeuristicCost(start, goal);\n\n        closedList = new PriorityQueue();\n        Node node = null;\n        GridManager gridManager = GameObject.FindObjectOfType<GridManager>();\n        if(gridManager == null) {\n            return null;\n        }\n\n        while (openList.Length != 0)\n        {\n            node = openList.GetFirstNode();\n\n            if (node.position == goal.position)\n            {\n                return CalculatePath(node);\n            }\n\n            ArrayList neighbors = new ArrayList();\n            gridManager.GetNeighbors(node, neighbors);\n\n            //Update the costs of each neighbor node.\n            for (int i = 0; i < neighbors.Count; i++)\n            {\n                Node neighborNode = (Node)neighbors[i];\n\n                if (!closedList.Contains(neighborNode))\n                { \n                  //Cost from current node to this neighbor node\n                  float cost = EstimateHeuristicCost(node, neighborNode); \n\n                  //Total Cost So Far from start to this neighbor node\n                  float totalCost = node.gCost + cost;\n\n                  //Estimated cost for neighbor node to the goal\n                  float neighborNodeEstCost = EstimateHeuristicCost(neighborNode, goal); \n\n                  //Assign neighbor node properties\n                  neighborNode.gCost = totalCost;\n                  neighborNode.parent = node;\n                  neighborNode.hCost = totalCost + neighborNodeEstCost;\n\n                  //Add the neighbor node to the open list if we haven't already done so.\n                  if (!openList.Contains(neighborNode))\n                  {\n                      openList.Push(neighborNode);\n                  }\n                }\n            } \n            closedList.Push(node);\n            openList.Remove(node);\n        }\n\n        //We handle the scenario where no goal was found after looping thorugh the open list\n        if (node.position != goal.position)\n        {\n            Debug.LogError(\"Goal Not Found\");\n            return null;\n        }\n\n        //Calculate the path based on the final node\n        return CalculatePath(node);\n    }\n}\n```", "```py\n public static PriorityQueue closedList;\n public static PriorityQueue openList;\n```", "```py\nprivate static float EstimateHeuristicCost(Node currentNode, Node goalNode)\n{\n    Vector3 cost= currentNode.position - goalNode.position;\n    return cost.magnitude;\n}\n```", "```py\n  public static ArrayList FindPath(Node start, Node goal)\n  {\n      openList = new PriorityQueue();\n      openList.Push(start);\n      start.gCost = 0.0f;\n      start.hCost = EstimateHeuristicCost(start, goal);\n\n      closedList = new PriorityQueue();\n      Node node = null;\n\n      GridManager gridManager = GameObject.FindObjectOfType<GridManager>();\n      if(gridManager == null) {\n          return null;\n      }\n```", "```py\n   while (openList.Length != 0)\n   {\n       node = openList.GetFirstNode();\n\n       if (node.position == goal.position)\n       {\n           return CalculatePath(node);\n       }\n\n       ArrayList neighbors = new ArrayList();\n       gridManager.GetNeighbors(node, neighbors);\n\n       //Update the costs of each neighbor node.\n       for (int i = 0; i < neighbors.Count; i++)\n       {\n           Node neighborNode = (Node)neighbors[i];\n\n           if (!closedList.Contains(neighborNode))\n           { \n               //Cost from current node to this neighbor node\n               float cost = EstimateHeuristicCost(node, neighborNode); \n\n               //Total Cost So Far from start to this neighbor node\n               float totalCost = node.gCost + cost;\n\n               //Estimated cost for neighbor node to the goal\n               float neighborNodeEstCost = EstimateHeuristicCost(neighborNode, goal); \n\n               //Assign neighbor node properties\n               neighborNode.gCost = totalCost;\n               neighborNode.parent = node;\n               neighborNode.hCost = totalCost + neighborNodeEstCost;\n\n               //Add the neighbor node to the open list if we haven't already done so.\n               if (!openList.Contains(neighborNode))\n               {\n                   openList.Push(neighborNode);\n               }\n             }\n         } \n         closedList.Push(node);\n         openList.Remove(node);\n     }\n\n     //We handle the scenario where no goal was found after looping thorugh the open list\n     if (node.position != goal.position)\n     {\n         Debug.LogError(\"Goal Not Found\");\n         return null;\n     }\n\n     //Calculate the path based on the final node\n     return CalculatePath(node);\n }\n```", "```py\nprivate static ArrayList CalculatePath(Node node) \n{ \n    ArrayList list = new ArrayList(); \n    while (node != null) \n    { \n      list.Add(node); \n      node = node.parent; \n    } \n    list.Reverse(); \n    return list; \n} \n```", "```py\nusing UnityEngine;\nusing System.Collections;\n\npublic class TestCode : MonoBehaviour \n{\n    private Transform startPosition;\n    private Transform endPosition;\n\n    public Node startNode { get; set; }\n    public Node goalNode { get; set; }\n\n    private ArrayList pathArray;\n\n    private GameObject startCube;\n    private GameObject endCube;\n\n    private float elapsedTime = 0.0f;\n    public float intervalTime = 1.0f; \n    private GridManager gridManager;\n```", "```py\n\n  private void Start () \n  {\n      gridManager = FindObjectOfType<GridManager>();\n      startCube = GameObject.FindGameObjectWithTag(\"Start\");\n      endCube = GameObject.FindGameObjectWithTag(\"End\");\n\n      //Calculate the path using our AStart code.\n      pathArray = new ArrayList();\n      FindPath();\n  }\n\n  private void Update () \n  {\n      elapsedTime += Time.deltaTime;\n\n      if(elapsedTime >= intervalTime)\n      {\n          elapsedTime = 0.0f;\n          FindPath();\n      }\n  }\n```", "```py\nprivate void FindPath()\n{\n    startPosition = startCube.transform;\n    endPosition = endCube.transform;\n\n    startNode = new Node(gridManager.GetGridCellCenter(gridManager.GetGridIndex(startPosition.position)));\n    goalNode = new Node(gridManager.GetGridCellCenter(gridManager.GetGridIndex(endPosition.position)));\n\n    pathArray = AStar.FindPath(startNode, goalNode);\n}\n```", "```py\nprivate void OnDrawGizmos()\n{\n    if (pathArray == null) \n    {\n        return;\n    }\n\n    if (pathArray.Count > 0)\n    {\n        int index = 1;\n        foreach (Node node in pathArray)\n        {\n            if (index < pathArray.Count)\n            {\n                Node nextNode = (Node)pathArray[index];\n                Debug.DrawLine(node.position, nextNode.position, Color.green);\n                index++;\n            }\n        };\n    }\n}\n```", "```py\nusing UnityEngine;\nusing UnityEngine.AI;\n\npublic class Target : MonoBehaviour\n{\n    private NavMeshAgent[] navAgents;\n    public Transform targetMarker;\n\n    private void Start ()\n    {\n      navAgents = FindObjectsOfType(typeof(NavMeshAgent)) as NavMeshAgent[];\n    }\n\n    private void UpdateTargets ( Vector3 targetPosition )\n    {\n      foreach(NavMeshAgent agent in navAgents) \n      {\n        agent.destination = targetPosition;\n      }\n    }\n\n    private void Update ()\n    {\n        if(GetInput()) \n        {\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hitInfo;\n\n            if (Physics.Raycast(ray.origin, ray.direction, out hitInfo)) \n            {\n                Vector3 targetPosition = hitInfo.point;\n                UpdateTargets(targetPosition);\n                targetMarker.position = targetPosition;\n            }\n        }\n    }\n\n    private bool GetInput() \n    {\n        if (Input.GetMouseButtonDown(0)) \n        {\n            return true;\n        }\n        return false;\n    }\n\n    private void OnDrawGizmos() \n    {\n        Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * 5, Color.red);\n    }\n}\n```"]