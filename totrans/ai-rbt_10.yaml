- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Conclusions and Reflections
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论和反思
- en: We have been on quite a journey throughout this book. I’ve learned a lot, and
    I hope you have as well. I've had the chance to revisit my love of robotics and
    spend a lot of time examining the state of the art of **artificial intelligence**
    (**AI**) and robot design to try and find a way to explain the concepts to you
    in an easily digestible form.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个旅程中，我学到了很多，我希望你也一样。我有机会重新审视我对机器人的热爱，并花了很多时间研究人工智能和机器人设计的最新进展，试图以易于理解的形式向你解释这些概念。
- en: In this chapter, we will discuss finishing our robot. I’ll provide you with
    some advice on careers in AI and robotics. We will also talk a little about the
    future of AI, at least as I see it, and finish with a discussion about risk.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论完成我们的机器人。我将为你提供一些关于人工智能和机器人领域职业的建议。我们还将简要谈谈人工智能的未来，至少就我所见而言，并以关于风险的话题结束。
- en: 'The following main topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Learning when to stop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习何时停止
- en: Careers in robotics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人领域的职业
- en: Exploring the current state of AI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索人工智能的当前状态
- en: Understanding risk in AI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解人工智能中的风险
- en: Learning when to stop
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习何时停止
- en: Over the last nine chapters, we’ve worked on designing a specific robot to perform
    a specific task. We designed *Albert* the robot to pick up toys in an unstructured
    environment, namely a family home. To do this, it needed to be able to recognize
    toys with a camera, pick up toys with a robot arm and hand, navigate inside a
    house, and deposit toys in a toy box. We also added interaction, teaching the
    robot to listen and react to commands. Finally, it received an artificial personality
    and simulated emotions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的九个章节中，我们一直在设计一个特定的机器人来完成特定的任务。我们设计了名为*阿尔伯特*的机器人，使其能够在非结构化环境中捡起玩具，即家庭环境。为此，它需要能够通过摄像头识别玩具，用机器人的手臂和手捡起玩具，在屋内导航，并将玩具放入玩具箱中。我们还增加了交互功能，教会机器人听从并反应命令。最后，它获得了一个人工性格和模拟的情感。
- en: So, the next question is, are we finished with designing, building, and testing
    our robot? Sometimes, the most difficult part of designing, building, and testing
    a robot is determining when it is finished. Quite often, I see that some little
    thing might be improved, or some detail added, or some feature enhanced. Oh, the
    robot needs a spotlight. It would be nice if it could remember what toys are in
    the toy box. What if it had two arms? And so on. You can continue in this vein
    forever, tinkering and adding, never quite finishing anything.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，下一个问题是，我们是否完成了机器人的设计、构建和测试？有时，设计和构建机器人的最困难的部分是确定何时才算完成。我经常看到，有些小的地方可能需要改进，或者添加一些细节，或者增强一些功能。哦，机器人需要一盏聚光灯。如果它能记住玩具箱里有什么玩具那就好了。如果它有两个手臂会怎样？等等。你可以永远这样继续下去，修补和添加，永远不会真正完成任何事情。
- en: The solution to this is to set specific goals and measure against them. For
    example, we want the robot to pick up toys. How many toys? All of the ones that
    are on the floor. So, we can run several trials and, if at the end of each test,
    all of the toys have been picked up, that is finished. But what if not all of
    the toys have been picked up? What is good enough? How about we say if we can
    pick up any remaining toys in one pass by holding them all in our hands, then
    that is acceptable. What level would not be acceptable? Well, picking up no toys
    at all is not acceptable. What about half? Would we consider that OK? I’d say
    probably not. You can continue this self-conversation until you say with some
    clarity where the finish line is. Then, once you’ve crossed it, you’re done.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是设定具体的目标并与之衡量。例如，我们希望机器人能捡起玩具。多少玩具？地上所有的玩具。因此，我们可以进行多次试验，如果在每个测试结束时所有玩具都被捡起，那么任务就算完成了。但如果不是所有玩具都被捡起呢？什么程度算足够好？我们可以说，如果我们能一次性用手握住所有剩余的玩具，那么这是可以接受的。什么水平是不可以接受的？好吧，一个玩具都不捡起是不可以接受的。一半呢？我们会认为那可以吗？我会说可能不会。你可以继续这种自我对话，直到你清晰地界定终点在哪里。然后，一旦你越过了这条线，你就完成了。
- en: Sometimes, we have to temper expectations when we’re trying something new or
    innovative. Expect to spend some time ironing the bugs out. I’ve had the experience
    of creating something and having the robot do something new and unexpected that
    ended up being far better than what I started with. For example, I created a robot
    that had a fairly sophisticated *follow me* function. It used body recognition
    to identify humans, and then, when commanded, followed behind one person, even
    through a crowd – so long as it could always keep the person it was following
    in its field of view. The robot was programmed to keep a six-foot distance from
    the person. This means if you walked toward it, instead of away, it backed up.
    You could then steer the robot backward in any direction simply by walking toward
    it – my *follow me* function became a *walk* *ahead* function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们尝试新事物或创新时，我们必须调整期望。预计你需要花一些时间来消除错误。我有过这样的经历，创造了一些东西，然后机器人做了些新的、出乎意料的事情，结果比最初的好得多。例如，我创造了一个具有相当复杂的**跟随我**功能机器人。它使用人体识别来识别人类，然后，当被命令时，会跟在一个人后面，即使是在人群中——只要它总能保持在它视野中跟踪的人。机器人被编程为与人的距离保持六英尺。这意味着如果你朝它走去，而不是离开，它会后退。然后你可以通过朝它走去简单地控制机器人向后移动——我的**跟随我**功能变成了**向前走**功能。
- en: Other times, an innovation just does not work, and at some point, it must be
    abandoned. Generally, you can tell this when you have to keep adding *crutches*
    or workarounds over and over again. The software becomes more complex and fragile
    with each workaround. I had this problem with a sonar-based obstacle avoidance
    system – the sonar sensor I used was just too unreliable and was very sensitive
    to the surface involved – for example, it could not see (get any echoes) from
    polished wooden doors. After a few weeks of testing, we abandoned that sensor
    and went with another light-based sensor called an **Infrared Proximity Detector**
    (**IRPD**) that worked much more reliably.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一项创新可能根本不起作用，在某个时刻，它就必须被放弃。通常，当你不得不一次又一次地添加**拐杖**或解决方案时，你就能知道这一点。每一次解决方案都会使软件变得更加复杂和脆弱。我有一个用声纳避障系统的问题——我使用的声纳传感器太不可靠了，对表面的反应非常敏感——例如，它无法从抛光的木门上看到（获取任何回声）。经过几周的测试后，我们放弃了那个传感器，转而使用另一个名为**红外接近探测器**（**IRPD**）的光学传感器，它工作得更加可靠。
- en: In the next section, we’ll take a look at some career paths that you could take
    if you are interested in robotics and/or AI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些如果你对机器人或人工智能感兴趣可以走的职业道路。
- en: Careers in robotics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人领域的职业
- en: I am often asked what sorts of skills or degrees robot designers need to have,
    or what courses they should take. I meet a lot of young people at robot competitions,
    student events, conferences, and recruiting trips. A lot of the advice I give
    people I have put into this book already – especially now that AI, neural networks,
    **graphics processing units** (**GPUs**), expert systems, chatbots, navigation,
    and image processing are all important. You need to understand that *robotics*
    is an umbrella term that covers a lot of industries and a lot of skill sets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常被问及机器人设计师需要具备哪些技能或学位，或者他们应该上哪些课程。我在机器人竞赛、学生活动、会议和招聘之旅中遇到了很多年轻人。我给很多人的建议已经包含在这本书里了——特别是现在人工智能、神经网络、**图形处理单元**（**GPU**）、专家系统、聊天机器人、导航和图像处理都变得非常重要。你需要理解**机器人**是一个涵盖众多行业和技能集的宽泛术语。
- en: 'Who uses robotics? The range of applications is continuing to grow every day.
    These include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 谁使用机器人？应用范围每天都在不断扩大。以下是一些例子：
- en: In the medical field, there is robot-assisted surgery, robotic prosthetic limbs,
    exoskeletons helping paraplegics to walk, and implantable devices to help people
    hear and see.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在医疗领域，有机器人辅助手术、机器人假肢、外骨骼帮助截瘫者行走，以及植入式设备帮助人们听和看。
- en: We have self-driving cars and self-flying airplanes and helicopters in transportation
    (which is what I do).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在交通领域，我们有自动驾驶汽车、自动驾驶飞机和直升机（这就是我从事的工作）。
- en: We have robots delivering packages on the sidewalks in San Francisco, and a
    few companies testing parcel delivery by aerial drone in Africa, Switzerland,
    Texas, and other places.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在旧金山的街道上使用机器人递送包裹，一些公司在非洲、瑞士、德克萨斯州和其他地方测试通过无人机递送包裹。
- en: We have self-driving cars being tested in several countries. Safety features
    that debuted in the *DARPA Grand Challenge* robot car race in the United States
    and were developed for autonomous cars – lane keeping, adaptive cruise control,
    driver assistance, and self-parking – are now common features on even base-level
    automobiles. There are over 80 companies currently developing some sort of electric
    **vertical takeoff and landing** (**VTOL**) manned vehicle, every one of which
    uses advanced automation and autonomy as part of its control system. In far western
    Australia, Rio Tinto Mining has developed the *Mine of the Future* in Pilbara,
    where 80 autonomous trucks are remotely operated from Perth, 1,500 kilometers
    away.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在几个国家测试着自动驾驶汽车。在美国的**DARPA 大挑战**机器人汽车比赛中首次亮相的安全功能，以及为自动驾驶汽车开发的功能——车道保持、自适应巡航控制、驾驶员辅助和自动泊车——现在甚至是最基础的汽车上也已成为常见功能。目前有超过80家公司正在开发某种形式的电动**垂直起降**（**VTOL**）载人车辆，每一款都将其作为控制系统的一部分使用先进的自动化和自主技术。在澳大利亚的远西部地区，力拓矿业在皮尔巴拉开发了**未来矿山**，在那里，80辆自动驾驶卡车从1500公里外的珀斯远程操作。
- en: The future of robotics is just being written, and you, reading this book, may
    play a part in determining the path it takes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人技术的未来正在被书写，而你，正在阅读这本书，可能将在决定其走向中扮演一部分角色。
- en: 'So, what skills are required to design and make robots like the ones I just
    described? The truth is that a modern robot company would employ just about every
    skill imaginable. Let’s look more closely at some of these skills:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，设计并制造像我刚才描述的机器人需要哪些技能呢？事实是，一家现代机器人公司几乎会雇佣所有可想象到的技能。让我们更仔细地看看其中的一些技能：
- en: Even the simplest robot takes **mechanical designers** to develop the parts,
    gears, and levers to make robots move and help package the electronics.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是最简单的机器人也需要**机械设计师**来开发零部件、齿轮和杠杆，使机器人移动并帮助包装电子产品。
- en: '**Electrical engineers** work with batteries and motors.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电气工程师**与电池和电机工作。'
- en: '**Radiofrequency** (**RF**) **engineers** and **technicians** work with radios
    and datalinks that are used to connect mobile robots to their control stations
    (such as an **unmanned aerial** **vehicle** (**UAV**)).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**射频**（**RF**）**工程师**和**技术人员**使用无线电和数据链路，这些用于将移动机器人连接到其控制站（如**无人机****车辆**（**UAV**））。'
- en: '**Cognitive specialists** design AI routines, develop robot emotions, and harness
    machine learning techniques, as well as design user interfaces.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认知专家**设计人工智能程序，开发机器人情感，运用机器学习技术，以及设计用户界面。'
- en: '**Writers** and **artists** craft voice routines, write dialogue, design user
    interfaces, write manuals and documentation, and add creative touches to the inside
    and outside of the robot.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作家**和**艺术家**制作语音程序，编写对话，设计用户界面，编写手册和文档，并为机器人的内外部增添创意。'
- en: '**Managers** and **supervisors** track budgets and schedules.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经理**和**监督员**跟踪预算和进度。'
- en: '**Supply specialists** work with suppliers, parts, build-to-print shops, electronics
    warehouses, and salesmen to get the parts to put together the assembly line.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应链专家**与供应商、零部件、按图生产车间、电子产品仓库和销售人员合作，以确保零部件到位，组装生产线。'
- en: Industrial robots are managed by special types of **programmers** who use **programmable
    logic arrays** (**PLAs**) and **ladder logic** to control robot arms that paint
    and assemble components. This type of programming emulates how robots were originally
    designed using relays and switches.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工业机器人由特殊类型的**程序员**管理，他们使用**可编程逻辑阵列**（**PLAs**）和**梯形逻辑**来控制涂漆和组装组件的机器人手臂。这种编程模拟了机器人最初使用继电器和开关设计的原理。
- en: '**Bookkeepers** and **accountants** make sure the bills, as well as the employees,
    are paid.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**簿记员**和**会计师**确保账单以及员工得到支付。'
- en: '**Salespeople**, **marketing**, and **customer relations** teams get the product
    sold and keep the customers happy.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销售人员**、**市场营销**和**客户关系**团队负责产品的销售并保持客户满意。'
- en: All of these skills have to be present in some form in a professional roboticist,
    particularly if you think you will run your own company. I’ve been part of every
    size of robot project, from one person to thousands. Each has its strengths and
    weaknesses, but as a robot designer, you can be sure that you will be the center
    of the storm, making the magic happen, solving problems, and turning ideas into
    physical form. To me, there is no more satisfying moment than seeing my creation
    driving or flying around, doing its job, and knowing that all the hard work, research,
    coding, mechanics, sleepless nights, smashed fingers and toes, and skipped meals
    were worth this result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技能在专业机器人工程师身上都必须以某种形式存在，尤其是如果你认为自己将经营自己的公司。我曾参与过各种规模的机器人项目，从一个人到数千人。每个项目都有其优势和劣势，但作为一个机器人设计师，你可以确信你将是风暴的中心，让魔法发生，解决问题，将想法转化为实物。对我来说，没有比看到我的创造物在驾驶或飞行中，完成其工作，并知道所有这些辛勤的工作、研究、编码、机械、不眠之夜、手指和脚趾的挫伤，以及跳过的餐食都值得这个结果更令人满足的时刻了。
- en: Now, let’s talk a bit about the hype surrounding robotics and AI that you have
    probably seen in the news.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈围绕机器人和人工智能的新闻中的一些炒作。
- en: Exploring the current state of AI
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索人工智能的当前状态
- en: There is a lot of hype going on right now in the intersecting worlds of AI and
    robotics. And a lot of it is just exaggeration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在人工智能和机器人技术的交汇世界中，炒作很多。而且其中很多都是夸张的。
- en: One common myth is that robots are taking jobs away from people. In truth, robots
    and automation free up workers to do more productive tasks. The truth of this
    can be seen in job statistics – unemployment in the US is at a 50-year low ([https://www.wsj.com/articles/january-jobs-report-unemployment-rate-economy-growth-2023-11675374490](https://www.wsj.com/articles/january-jobs-report-unemployment-rate-economy-growth-2023-11675374490)),
    despite massive improvements in factory automation. However, according to *The
    Harvard Business Review*, the improved productivity of robotics creates more jobs
    than it removes ([https://hbr.org/2021/03/why-robots-wont-steal-your-job](https://hbr.org/2021/03/why-robots-wont-steal-your-job)).
    The overall level of employment has *increased*, not gone down because of automation
    and increased productivity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是机器人正在夺走人们的就业机会。实际上，机器人和自动化让工人能够从事更多富有成效的任务。这一真相可以从就业统计数据中看出——尽管工厂自动化取得了巨大进步，但美国的失业率处于50年来的最低水平([https://www.wsj.com/articles/january-jobs-report-unemployment-rate-economy-growth-2023-11675374490](https://www.wsj.com/articles/january-jobs-report-unemployment-rate-economy-growth-2023-11675374490))。然而，根据《哈佛商业评论》，机器人技术的提高生产率创造了比它消除的更多的工作机会([https://hbr.org/2021/03/why-robots-wont-steal-your-job](https://hbr.org/2021/03/why-robots-wont-steal-your-job))。由于自动化和生产率的提高，就业的整体水平是*增加*的，而不是下降。
- en: I do recognize that the modern worker, even someone like myself, who works in
    technology, must be ready and willing – at any age – to retrain themselves and
    to learn and adapt to new ways of working, new economies, and new opportunities.
    I’ve had to completely retrain myself at least six times as new markets were invented
    and new technologies emerged. Sometimes, there is a *second wave* where some technology
    was invented but then disappeared when it was too expensive for the benefits it
    provided, or the proper hardware had not been invented yet. Neural networks fit
    into that category, as does virtual reality, which was a big deal in 1999, and
    has now re-emerged with very small high-resolution screens that were developed
    for cell phones.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实认识到，现代工人，甚至像我这样的从事技术工作的人，必须随时准备并愿意——无论年龄多大——重新培训自己，学习并适应新的工作方式、新的经济和新的机遇。每当有新的市场和新技术出现时，我就不得不至少重新培训自己六次。有时，会出现一个*第二波*，其中一些技术被发明出来，但由于其提供的效益过高或适当的硬件尚未发明，这些技术随后消失了。神经网络就属于这一类，虚拟现实也是如此，它在1999年是一个大事件，而现在随着为手机开发的小型高分辨率屏幕的出现而重新出现。
- en: Looking ahead in AI and robotics
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望人工智能和机器人技术
- en: I’m quite interested in the long-term impact of what has been called the *sharing
    economy*, where companies such as Uber, Lyft, and Airbnb create value by connecting
    suppliers and consumers on a massive scale without owning any of the capital or
    resources to provide any services. All of this is enabled and made possible by
    the ubiquitous internet, which continues to grow and evolve at a rapid pace. The
    availability of the internet has allowed the general public or an individual student
    to have access to supercomputer-level capabilities to run AI programs such as
    ChatGPT online, which are too large to fit in a home computer, smartphone, or
    tablet. I often use the term, “*but that’s a decade in internet years*” while
    referring to some idea that is maybe 24 months old to indicate the rapid turnover
    in internet tech. This trend will continue. It will be interesting to see if anyone
    owns a car in 20 years, or only a subscription to a car service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我对所谓的*共享经济*的长期影响非常感兴趣，这种经济模式中，像Uber、Lyft和Airbnb这样的公司通过在巨大规模上连接供应商和消费者来创造价值，而不拥有提供任何服务的资本或资源。所有这一切都得益于无处不在的互联网，它以快速的速度持续增长和演变。互联网的可用性使得公众或单个学生能够访问超级计算机级别的能力，在线运行ChatGPT等AI程序，这些程序太大，无法装入家用电脑、智能手机或平板电脑。我经常在提到一些可能只有24个月历史的想法时使用“*但那在互联网年份中相当于十年*”这个术语，以表明互联网技术的快速更迭。这一趋势将持续下去。将很有趣地看到20年后是否还有人拥有汽车，或者只有汽车服务的订阅。
- en: Another trend that has become very interesting is the lowering of barriers to
    entry in a lot of businesses. You used to have to have an enormous machine shop
    and giant machines to make precision machine parts – before 3D printers came and
    put that capability on your desktop. **Generative AI** is AI that can synthesize
    writing and drawing and can also directly create music, write programs and software,
    provide advice, and assist users in writing scripts, drawing pictures, and making
    animations powered by only a text prompt. Do you want to make movies? You can
    do so on an iPhone. Do you want to start a recording studio? The parts for professional
    results (with a large amount of effort) are available for less than $200 and you
    can use AI to generate lyrics, chord progressions, arpeggios, or even song ideas.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变得非常有趣的趋势是许多行业中进入门槛的降低。过去，你需要一个庞大的机器车间和巨型机器来制造精密的机械部件——直到3D打印机出现，将这种能力带到了你的桌面。**生成式AI**是一种能够合成写作和绘画，并能直接创作音乐、编写程序和软件、提供建议，以及仅通过文本提示帮助用户编写脚本、绘制图片和制作动画的AI。你想制作电影吗？你可以在iPhone上做到。你想开设录音室吗？专业结果所需的部件（需要大量努力）的价格不到200美元，你还可以使用AI生成歌词、和弦进行、琶音，甚至歌曲创意。
- en: One item that fits into that category of lowering barriers to entry is drones
    or small UAVs. When I started making UAVs, a decent **global positioning system**
    (**GPS**) and **inertial measurement unit** (**IMU**) – the things that make unstable
    quadcopters possible to control – cost tens of thousands to hundreds of thousands
    of dollars. The real breakthrough in drone technology did not come from aviation,
    but rather from our cell phones. The developments in cell phones enabled companies
    to invest billions of dollars in making the next cell phone, smartphone, hand-held
    computer pacifier, or whatever you would want to call it. The convergence of very
    small radios, very small GPSs, and very, very small accelerometers enabled an
    entire world of unmanned flying objects – quadcopters, gliders, airships, airplanes,
    and hybrid VTOL craft – to emerge. That, along with higher density batteries that
    came from (you guessed it) cell phones and laptops, allowed people to discover
    that if you put enough power on it, you can make almost anything fly, including
    you.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 符合降低进入门槛这一类别的项目之一是无人机或小型无人机。当我开始制作无人机时，一个不错的**全球定位系统**（**GPS**）和**惯性测量单元**（**IMU**）——使不稳定的四旋翼无人机能够控制的东西——需要花费数万美元到数十万美元。无人机技术的真正突破并非来自航空领域，而是来自我们的手机。手机的发展使得公司能够投资数十亿美元来制造下一代手机、智能手机、手持电脑安抚器，或者你想要称之为什么的东西。非常小的无线电、非常小的GPS和非常非常小的加速度计的融合，使得一个无人驾驶飞行物的世界——四旋翼无人机、滑翔机、飞艇、飞机和混合垂直起降（VTOL）飞行器——得以出现。这，加上来自（你猜对了）手机和笔记本电脑的高密度电池，使得人们发现，如果你给它足够的动力，几乎任何东西都能飞起来，包括你自己。
- en: The secret to the flying quadcopter’s amazing success is that the tiny accelerometers
    (which measure changes in movement) and tiny gyroscopes (which measure orientation
    changes) became cheap and readily available. Without these sensors, and the robotics
    algorithms that control them, quadcopters are unstable and impossible to control.
    Another reason for the quadcopter’s success is that it uses only the throttle
    setting – the speed of the motors – to control all its aspects of flight, including
    stability. This compares with the very complicated collective controls and cyclic
    pitch controls that make a helicopter work. You can see the difference between
    a radio-controlled helicopter, which is very expensive and only a few people can
    fly, and a quadcopter, which is quite cheap and can be flown by anyone, with the
    help of a computer and some sensors. You can add a drone autopilot to a collective/cyclic
    radio-controlled helicopter and end up with a very controllable drone helicopter.
    Quadcopters and more complex flying machines use AI for stabilization, adaptive
    flight control, object recognition, and obstacle avoidance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行四旋翼无人机取得惊人成功的秘诀在于，那些测量运动变化的微型加速度计（加速度计）和测量方向变化的微型陀螺仪（陀螺仪）变得既便宜又容易获得。没有这些传感器，以及控制它们的机器人算法，四旋翼无人机将是不稳定的，无法控制。四旋翼无人机成功的另一个原因是，它仅使用油门设置——即电机的速度——来控制其所有飞行方面的稳定性。这与使直升机工作的非常复杂的集体控制和循环俯仰控制形成对比。你可以看到无线电遥控直升机和四旋翼无人机的区别，前者非常昂贵，只有少数人能够驾驶，而后者相当便宜，任何人都可以驾驶，只要有计算机和一些传感器。你可以在集体/循环无线电遥控直升机上添加无人机自动驾驶仪，最终得到一个非常可控的无人机直升机。四旋翼无人机和更复杂的飞行器使用人工智能进行稳定、自适应飞行控制、物体识别和避障。
- en: The other side of these advances in AI and robotics has also resulted in a backlash
    from some people and can be described as robot phobia.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能和机器人技术的这些进步也导致了一些人的反感和机器人恐惧症。
- en: Is AI phobia reasonable?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能恐惧症合理吗？
- en: You have probably seen some blazing headlines on the internet from various very
    credible sources saying some incredible things.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在网上看到过来自各种非常可信来源的令人震惊的标题，说了一些令人难以置信的事情。
- en: About a decade ago, Stephen Hawking, a leading scientist, stated that “*The
    development of full artificial intelligence could spell the end of the human race...
    It will take off on its own and re-design itself at an ever-increasing rate… Humans,
    who are limited by slow biological evolution, can’t compete, and will be superseded*”
    ([https://www.bbc.com/news/technology-30290540](https://www.bbc.com/news/technology-30290540)).
    This quote is frequently used even today by critics of AI.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大约十年前，著名科学家斯蒂芬·霍金表示，“*完全人工智能的发展可能会给人类带来末日...它将自行起飞并以越来越快的速度自我重新设计...受限于缓慢的生物进化的人类，无法与之竞争，将被取代*”
    ([https://www.bbc.com/news/technology-30290540](https://www.bbc.com/news/technology-30290540))。这句话至今仍被人工智能的批评者频繁引用。
- en: More recently, Elon Musk suggested that AI could lead to *civilization destruction*,
    although he has invested significantly in the growth of AI ([https://edition.cnn.com/2023/04/17/tech/elon-musk-ai-warning-tucker-carlson/index.html](https://edition.cnn.com/2023/04/17/tech/elon-musk-ai-warning-tucker-carlson/index.html)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，埃隆·马斯克表示，人工智能可能导致*文明毁灭*，尽管他已经在人工智能的增长上投入了大量资金 ([https://edition.cnn.com/2023/04/17/tech/elon-musk-ai-warning-tucker-carlson/index.html](https://edition.cnn.com/2023/04/17/tech/elon-musk-ai-warning-tucker-carlson/index.html))。
- en: Bill Gates, former chairman of Microsoft, takes a more middle ground, stating
    that AI presents both promise and concerns. In an open letter, he elaborated on
    AI’s potential but also discussed the risks of developing this tech. He wrote,
    “*The world needs to establish the rules of the road so that any downsides of
    artificial intelligence are far outweighed by its* *benefits*” ([https://www.forbes.com/sites/qai/2023/03/24/bill-gatess-open-letter-suggests-ais-potential-is-both-exciting-and-terrifying/](https://www.forbes.com/sites/qai/2023/03/24/bill-gatess-open-letter-suggests-ais-potential-is-both-exciting-and-terrifying/)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微软前董事长比尔·盖茨持更中庸的观点，他认为人工智能既带来了希望，也带来了担忧。在一封公开信中，他详细阐述了人工智能的潜力，但也讨论了发展这项技术的风险。他写道，“*世界需要建立交通规则，以确保人工智能的任何负面影响都远远小于其*
    *好处*” ([https://www.forbes.com/sites/qai/2023/03/24/bill-gatess-open-letter-suggests-ais-potential-is-both-exciting-and-terrifying/](https://www.forbes.com/sites/qai/2023/03/24/bill-gatess-open-letter-suggests-ais-potential-is-both-exciting-and-terrifying/))。
- en: First, let me clarify that I do not think I’m in the same league as these gentlemen.
    But what I am is someone who works every day at the leading edge of AI and unmanned
    vehicles and robotics, and who attends and speaks at a lot of AI conferences.
    The source of this fear of AI can be found in any bathroom, hanging on the wall
    – we are using our mirrors to reflect our motivations and desires onto our creations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我明确一点，我认为自己并不与这些先生们处于同一水平。但我是这样的人，每天都在人工智能、无人车辆和机器人技术的最前沿工作，并且参加并发表了许多人工智能会议。这种对人工智能的恐惧可以在任何浴室里找到，挂在墙上——我们正在用我们的镜子将我们的动机和欲望反映到我们的创造物上。
- en: 'I would liken the state of the art of AI today to a teenager who has managed
    to strap a V-8 engine to a skateboard – an enormous amount of power with no way
    to use it. While computers, hardware, and networks have advanced and scaled at
    an amazing rate, we are still building software the same way today as we did 20
    years ago, and many of the advances of AI were invented 40 or 50 years ago. For
    instance, neural networks were invented in the 1940s ([https://link.springer.com/article/10.1007/BF02478259](https://link.springer.com/article/10.1007/BF02478259)).
    Genetic algorithms were suggested by Alan Turing in the 1950s. We have been able
    to make some advancements in applying learning theory now that we have lots of
    data (thank you, internet) and lots of bandwidth, but we have not created any
    startling new concepts or capabilities that show any sort of breakthrough in AI.
    Recent work in generative AI –such as **ChatGPT** and **Dall-E** image generation
    – has created what might be described as a computer version of an imagination
    (creating data stepwise out of noise), which indeed is a step forward, but still,
    a generative AI such as ChatGPT is doing what neural networks did before: predict
    the next word in a sentence.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把目前人工智能的先进状态比作一个成功将V-8引擎安装在滑板上的青少年——拥有巨大的力量，却无法使用。虽然计算机、硬件和网络以惊人的速度发展和扩展，但我们今天构建软件的方式与20年前相同，许多人工智能的进步都是在40或50年前发明的。例如，神经网络是在1940年代发明的（[https://link.springer.com/article/10.1007/BF02478259](https://link.springer.com/article/10.1007/BF02478259)）。遗传算法是在1950年代由艾伦·图灵提出的。现在，由于我们拥有大量的数据（感谢互联网）和大量的带宽，我们能够在应用学习理论方面取得一些进步，但我们并没有创造出任何令人震惊的新概念或能力，显示出任何人工智能突破的迹象。最近在生成式人工智能方面的工作——如**ChatGPT**和**Dall-E**图像生成——创造了一种可以描述为计算机版的想象力（从噪声中逐步创建数据），这确实是一个进步，但仍然，像ChatGPT这样的生成式人工智能所做的，与神经网络之前所做的一样：预测句子中的下一个单词。
- en: 'What is generative AI? In this case, we can ask the AI itself for a definition.
    The following text was written by an AI program called ChatGPT4 in response to
    the prompt, “*Can you provide me with a definition of* *generative AI?*”:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是生成式人工智能？在这种情况下，我们可以向人工智能本身寻求定义。以下文本是由名为ChatGPT4的人工智能程序根据提示“*你能提供生成式人工智能的定义吗？*”所撰写的：
- en: “Generative AI refers to a subset of artificial intelligence technologies that
    can generate new content, such as text, images, music, or code, based on the patterns
    and information it has learned from its training data. This type of AI uses machine
    learning algorithms, particularly generative models such as generative adversarial
    networks (GANs) or transformers, to understand and replicate the complexities
    of human-generated content.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “生成式人工智能是指一类可以从其训练数据中学习到的模式和信息生成新内容的人工智能技术，例如文本、图像、音乐或代码。这类人工智能使用机器学习算法，特别是生成模型，如生成对抗网络（GANs）或转换器，来理解和复制人类生成内容的复杂性。”
- en: “The “generative” aspect implies that the AI isn’t just analyzing or processing
    existing information but actually creating something new and previously unseen.
    For instance, in the case of text, generative AI can write essays, poems, or code;
    for images, it can create artworks or realistic photos of things that don’t exist;
    in music, it can compose new pieces in various styles.”
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “‘生成’这一方面意味着人工智能不仅仅是分析或处理现有信息，而是实际上在创造一些新东西，以前从未见过。例如，在文本的情况下，生成式人工智能可以撰写文章、诗歌或代码；对于图像，它可以创作艺术品或不存在事物的逼真照片；在音乐中，它可以创作各种风格的新作品。”
- en: But is this what is referred to as **general AI** (software with human intelligence)?
    I don’t think so. While the hardware and software are advancing, I simply don’t
    see any path forward that leads to the type of problems that the esteemed Mr Gates,
    Mr Musk, or Dr Hawking suggested. Why not? We’ll focus on this in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但这难道就是所说的**通用人工智能**（具有人类智能的软件）吗？我不这么认为。尽管硬件和软件在进步，但我看不到任何通往那种类型问题的道路，正如尊敬的盖茨先生、马斯克先生或霍金博士所提出的。为什么没有呢？我们将在下一节中关注这一点。
- en: Comparing the needs of humans and AI
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较人类和人工智能的需求
- en: The reason why I don’t see significant problems is because robots don’t have
    needs. Humans have needs and ambitions to exist. We are encased in a frail flesh
    cell, what William Burroughs called the *Soft Machine*. We must provide air, food,
    water, shelter, and clothing to protect our fragile shells and interact with other
    soft machines (people) to reproduce and make more of ourselves. You can argue,
    as Richard Dawkins did in his book *The Selfish Gene*, that all of this is simply
    an evolved way for our DNA to perpetuate itself, and that we are simply the product
    of our biological programming. It is impossible to separate a human from their
    needs – if we don’t, we die in a matter of minutes. It is our needs that drive
    us forward, to come out of the trees, to learn to farm, to build cities, and to
    make civilizations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我看不到重大问题的原因是因为机器人没有需求。人类有生存和抱负的需求。我们被脆弱的肉体细胞包裹着，威廉·巴勒斯称之为**软机器**。我们必须提供空气、食物、水、住所和衣物来保护我们脆弱的外壳，并与其他软机器（人）互动以繁殖和创造更多自己。你可以像理查德·道金斯在他的书《自私的基因》中所做的那样争论，所有这些都是我们DNA延续的一种进化方式，而我们只是我们生物编程的产物。人类与需求是不可分割的——如果我们不这么做，我们几分钟就会死去。是我们的需求推动我们前进，走出树木，学会耕种，建造城市，并创造文明。
- en: Robots, on the other hand, do not have needs as a condition of their existence.
    They are just sets of instructions we have set down in electronics – golems with
    words in their heads that make them move (as described in the book *Feet of Clay*,
    by Terry Pratchett). If we don’t provide food to them – nothing happens. If we
    don’t use them – nothing happens. If we forget them for a week and check on them
    later, they are still the same.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，机器人作为其存在条件并不需要需求。它们只是我们在电子设备中设定的指令集——头脑中有文字的哥莱姆，这些文字使它们移动（如特里·普拉切特在《粘土之足》一书中所描述的）。如果我们不给他们提供食物——什么也不会发生。如果我们不使用它们——什么也不会发生。如果我们忘记它们一周，然后稍后检查，它们仍然是相同的。
- en: 'First, let’s discuss what humans’ needs are. Maslow came up with the **hierarchy
    of needs** back in 1943, and he has been quoted ever since. Maslow says that we
    not just have needs, but they form a hierarchy – the more important needs are
    at the bottom while the more abstract needs are at the top. We only worry about
    the need at any given level when all of the needs below it are satisfied, as shown
    in the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下人类的需求。马斯洛在1943年提出了**需求层次理论**，并且自那以后一直被引用。马斯洛说，我们不仅有需求，而且它们形成了一个层次——越重要的需求在底部，越抽象的需求在顶部。只有当所有低于这个级别的需求都得到满足时，我们才会担心这个级别的需求，如下面的图所示：
- en: '![Figure 10.1 – Hierarchy of needs for humans](img/B19846_10_1.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 人类需求层次结构](img/B19846_10_1.jpg)'
- en: Figure 10.1 – Hierarchy of needs for humans
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 人类需求层次结构
- en: 'Let’s look at this pyramid of needs in detail:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这个需求金字塔：
- en: At the bottom are the *physical needs* – air, food, water, and clothing.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部是**生理需求**——空气、食物、水和衣物。
- en: The next level is *security* – we need to feel secure from predators or from
    other humans wanting to harm us.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是**安全需求**——我们需要感到从捕食者或其他想要伤害我们的人类那里得到保护。
- en: Above the security needs are *social needs* – to be in a group or part of society.
    Humans want to belong to a family, a community, a nation. This drive is very strong,
    as our invention of war to protect our society attests.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全需求之上是**社交需求**——想要成为群体的一部分或社会的一部分。人类想要属于一个家庭、一个社区、一个国家。这种驱动力非常强烈，正如我们发明战争来保护我们的社会所证明的那样。
- en: Next, we have *ego needs* – the need to be recognized, to be special, to stand
    out from the crowd we fought so hard to be part of. Remember, we only get to express
    this once all the other needs are taken care of, so you only worry about recognition
    once you are part of a group.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是**自我实现需求**——被认可、特殊、与众不同的需求，从我们努力想要成为其中一员的人群中脱颖而出。记住，只有当所有其他需求都得到满足后，我们才能表达这种需求，所以你只有在成为群体的一部分后才会担心认可。
- en: Our final need is called *self-actualization*, as described by Maslow – we would
    call it self-improvement, or the drive to improve one’s self. This is where we
    get athletes, artists, musicians, and people who write books.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终的需求被称为*自我实现*，正如马斯洛所描述的——我们可能会称之为自我提升，或提高自己的驱动力。这就是我们得到运动员、艺术家、音乐家和写书的人的地方。
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: It has been a running joke between my wife and me that every textbook we ever
    read in college contained some reference to Maslow and his hierarchy of needs.
    This was quite unusual since I studied math and engineering, and my wife’s degree
    is in human resources. I appreciate the irony that this book now adds to that
    list of books that reference Maslow.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我和我妻子之间有一个持续的笑话，那就是我们在大学里读过的每一本教科书都包含对马斯洛及其需求层次理论的引用。这相当不寻常，因为我学习的是数学和工程，而我妻子的学位是人力资源管理。我很欣赏这本书为那个引用马斯洛的书籍列表增添的讽刺意味。
- en: 'Now, let’s look at machine intelligence and imagine for a moment what a set
    of robot needs might look like. I found this an interesting thought experiment
    – we make a baby robot that is fully capable of learning anything a baby human
    (or baby mouse, or baby cricket) can. What needs would it have? Let’s look at
    a modified version of Maslow’s hierarchy of needs:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看机器智能，并想象一下一组机器人需求可能是什么样子。我发现这是一个有趣的思想实验——我们制造了一个能够学习任何婴儿人类（或婴儿老鼠，或婴儿蟋蟀）能学会的东西的婴儿机器人。它会有什么需求？让我们看看马斯洛需求层次的一个修改版：
- en: '![Figure 10.2 – Hierarchy of needs for robots](img/B19846_10_2.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 机器人的需求层次](img/B19846_10_2.jpg)'
- en: Figure 10.2 – Hierarchy of needs for robots
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 机器人的需求层次
- en: 'We can break this down as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样分解：
- en: In contrast to a robot’s needs, hunger is built into humans’ biology. However,
    in the case of an AI system, we, the creators, would need to build it in. That
    would equate, as we did in our artificial personality, to *electrical power* or
    *battery life*.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与机器人的需求相比，饥饿是嵌入在人类生物学中的。然而，在AI系统的案例中，我们，作为创造者，需要将其构建进去。这相当于我们在人工个性中所做的那样，即*电能*或*电池寿命*。
- en: The next level of needs would be the *goals* and *tasks* for which the AI was
    created.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个需求层次将是AI被创造出的*目标*和*任务*。
- en: The next level up could potentially be *curiosity* and the need to explore –
    our AI system would have a drive to acquire more data, or to get access to more
    resources. Once a robot has data, this gives it the basis to get more data, and
    so on.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高层次的需求可能是*好奇心*和探索的需求——我们的AI系统会有获取更多数据或获取更多资源的驱动力。一旦机器人有了数据，这就会给它提供获取更多数据的基础，如此类推。
- en: The next level of needs we would endow to our AI would be the need for *friendship*
    or *communication*, either with other robots or with people.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将赋予我们的AI的下一个需求层次是*友谊*或*沟通*的需求，无论是与其他机器人还是与人。
- en: Finally, we could give our robot the need for *learning*, or to acquire and
    learn new skills and techniques – to grow as a robot.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以给我们的机器人赋予*学习*的需求，或者说是获取和学习新技能和技术——作为机器人成长。
- en: You may have noticed that we did not cover these subjects in this book, nor
    any other. We did not talk about giving the robot needs, only how to simulate
    emotions and some rules for conversation that make no sense to the robot at all.
    It gets no joy from telling a terrible joke to a 7-year-old because it does not
    know what any of those concepts are. It just sends electrons down one path or
    another because we tell it to. The only intelligence here is the reflection and
    imagination of us, the robot designers. Everything else is an illusion – a magician’s
    trick.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有在这本书中涵盖这些主题，也没有涵盖其他任何主题。我们没有谈论赋予机器人需求，只是如何模拟情感和机器人完全不懂的对话规则。它不会因为告诉一个7岁的孩子一个糟糕的笑话而感到快乐，因为它不知道这些概念中的任何一种。它只是因为我们的指令而将电子发送到一条路径或另一条路径。这里的唯一智能是我们，机器人设计师的反思和想象力。其他一切都是幻觉——魔术师的把戏。
- en: I get this sort of question quite a lot and felt that I could give you some
    of my answers if that helps arm you against the critics of AI. The bottom line
    is that I simply do not worry about AI taking over the world. I don’t mean to
    say that there will never be a general AI, just I don’t see one coming about in
    the foreseeable future.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常遇到这类问题，并觉得如果这能帮助你抵御AI批评者的攻击，我可以给你一些我的答案。底线是，我根本不担心AI会接管世界。我的意思并不是说永远不会有通用AI，只是我看不出在可预见的未来会有一个出现。
- en: With this context under our belt, let’s discuss how to understand and manage
    risk in AI.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个背景之后，让我们讨论如何理解和管理AI中的风险。
- en: Understanding risk in AI
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解AI中的风险
- en: One subject I talk about frequently at conferences and in print is the risk
    of AI in terms of *trust* and *control*. I’m not talking about AI running amok
    here, but rather how to make AI dependable. It is quite interesting that the sort
    of AI we have been considering – specifically, ANNs – does something very few
    other computer software do. Given the same inputs and conditions, the output of
    an AI system is not always the same. Given the same inputs, the AI system will
    sometimes come up with a different answer. The formal name for this behavior is
    **non-determinism**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我在会议和出版物中经常讨论的一个主题是AI在*信任*和*控制*方面的风险。我这里不是在谈论AI失控，而是在讨论如何使AI可靠。非常有趣的是，我们一直在考虑的这种AI——特别是人工神经网络（ANNs）——做了一些其他计算机软件很少做的事情。给定相同的输入和条件，AI系统的输出并不总是相同的。给定相同的输入，AI系统有时会得出不同的答案。这种行为的形式名称是**非确定性**。
- en: There is a second corollary to this. Given the same inputs, the AI process will
    sometimes take a different amount of time to complete its task. This is simply
    not normal behavior for a computer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有第二个推论。给定相同的输入，AI过程有时会花费不同的时间来完成其任务。这对计算机来说根本不是正常的行为。
- en: Admittedly, we are not using AI to get answers to math questions such as *2+2*,
    but rather how to do things such as diagnose a cancer tumor or recognize a pedestrian
    in a crosswalk for a self-driving car. How do we deal with a computer output that
    may be wrong? You can verify this for yourself – look at the examples we covered
    when we performed training on neural networks. Did we ever achieve 100% success
    from a training run, where we got all of the answers right? No, not once. This
    is because ANNs are *universal approximation functions* that map inputs – which
    can be quite complex – to outputs. They do this by dealing with probabilities
    and averages, which were developed over time. You can think of an artificial neuron
    as a probability engine that says, *45 out of the last 50 times I got this set
    of inputs, the output was supposed to be true. The odds are it will be true this
    time*. And it sets itself to true. We may have millions of little artificial neurons
    in our network, each of them making the same sort of calculation. The net result
    is making a very educated guess about the answer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，我们并不是用AI来解答像*2+2*这样的数学问题，而是如何去做诸如诊断癌症肿瘤或为自动驾驶汽车识别人行横道上的行人这类事情。我们如何处理可能错误的计算机输出呢？你可以亲自验证这一点——看看我们在进行神经网络训练时覆盖的例子。我们是否曾经在一次训练运行中实现了100%的成功，即所有答案都正确？没有，一次都没有。这是因为人工神经网络（ANNs）是*通用逼近函数*，它们将输入映射到输出——这些输入可能相当复杂。它们通过处理概率和平均值来实现这一点，这些都是在时间中发展起来的。你可以把一个人工神经元想象成一个概率引擎，它会说：“在过去的50次中，有45次我得到了这组输入，输出应该是正确的。这次它也有可能是正确的。”然后它就设定为正确。在我们的网络中，我们可能有数百万个这样的小人工神经元，每个都在做类似的计算。最终结果是做出一个关于答案的非常明智的猜测。
- en: For most applications of our neural networks, this is acceptable behavior. We
    are classifying pictures, and it is acceptable if a few are wrong. We do a Google
    search for platypus, and we get one picture out of 100 Platypus brand tennis shoes.
    That is OK for a Google search, but what if we were doing something more serious,
    such as recognizing pedestrians in a self-driving car? Is it OK if we misidentify
    one pedestrian out of 100 and don’t avoid them? Of course not. That’s why, right
    now, we don’t allow AI systems in such critical functions. But people want to
    use AI in this way – in fact, quite a lot. It would be great to have an AI system
    that recognizes geese in flight and tells your airliner how to avoid them. It
    would be great to have an AI system recognize that a patient was misdiagnosed
    in the hospital and needed immediate attention. But we can’t do that until we
    come up with processes for dealing with the non-deterministic and thus non-reliable
    nature of AI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们神经网络的大多数应用来说，这种行为是可以接受的。我们在对图片进行分类，如果有一两张分类错误是可以接受的。我们进行一次关于鸭嘴兽的谷歌搜索，结果在100张图片中有一张是鸭嘴兽品牌的网球鞋。这对于谷歌搜索来说是完全可以接受的，但如果我们在做更严肃的事情，比如在自动驾驶汽车中识别行人呢？如果我们错误地识别了100个行人中的一个，而没有避开他们，这是否可以接受？当然不行。这就是为什么，目前，我们不允许AI系统在如此关键的功能中使用。但人们希望以这种方式使用AI——实际上，很多人都在这样做。如果能有一个AI系统识别飞行中的鹅，并告诉你的飞机如何避开它们，那将是极好的。如果能有一个AI系统识别出患者在医院中被误诊，并需要立即关注，那也会很棒。但我们不能做到这一点，除非我们找到了处理AI非确定性和不可靠性的方法。
- en: 'Currently, we deal with non-deterministic elements in automobiles all of the
    time. They are called drivers. It is widely believed that the vast majority of
    car crashes are caused by the human element, which is why we need self-driving
    cars with a better percentage. How do we deal with human drivers? Let’s look at
    the necessary criteria for a driver:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们一直在汽车中处理非确定性元素，它们被称为驾驶员。人们普遍认为，绝大多数车祸是由人为因素造成的，这就是为什么我们需要具有更好百分比的自动驾驶汽车。我们如何处理人类驾驶员？让我们看看驾驶员所需的必要标准：
- en: We require them to be a certain age, which means they have gained experience
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要求他们达到一定的年龄，这意味着他们已经积累了经验。
- en: They have to pass a test, demonstrating competency in accomplishing tasks
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须通过测试，证明他们在完成任务方面的能力。
- en: They have to demonstrate compliance with rules and regulations by passing a
    knowledge test
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须通过知识测试来证明他们遵守规则和法规。
- en: They have to get periodically re-certified by renewing their license
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须定期通过更新执照来重新认证。
- en: We also require seat belts and airbags to partially mitigate the risk of the
    human driver making mistakes by reducing some of the resulting injuries
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还要求使用安全带和气囊来部分减轻人类驾驶员犯错误的风险，通过减少由此产生的伤害
- en: We can apply these types of criteria to AI. We can require a certain amount
    of training cases. We can test and demonstrate a level of competency. We can predict
    the level of errors or mistakes in advance and put measures in place to mitigate
    that risk. Perhaps we can have two AI systems – one that detects obstacles and
    another that has been trained to recognize that the first AI has made a mistake.
    If we have a 90% chance of the first AI being right, and another 90% chance of
    the second AI being right, then we have a *90% + (90% of 10%) = 99%* chance of
    avoidance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些类型的标准应用于AI。我们可以要求一定数量的训练案例。我们可以测试并证明一定的能力水平。我们可以提前预测错误或错误的水平，并采取措施减轻这种风险。也许我们可以有两个AI系统——一个用于检测障碍，另一个被训练来识别第一个AI已经犯了一个错误。如果我们有90%的第一个AI是正确的可能性，另一个90%的第二个AI是正确的可能性，那么我们就有*90%
    + (10%的90%) = 99%*的避免事故的可能性。
- en: I think the key to using AI in safety-critical applications is being able to
    predict risk in advance, and designing in advance to mitigate either the cause
    of the risk or the effect.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在关键安全应用中使用AI的关键是能够提前预测风险，并提前设计以减轻风险的原因或影响。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter of this book, we summarized our journey through robotics
    and AI. We talked about robotics as a career and discussed AI robotics as a profession.
    I brought up some issues regarding the future of AI, both real and imaginary.
    Drones and self-driving cars are real; robots taking jobs from humans or taking
    over the world is imaginary, at least in my opinion. I talked about robots and
    AI not having needs, and thus lacking the motivation, pressure, or even capability
    to evolve. Finally, we talked about risk in AI and how to recognize it. I hope
    that this information gives you some guidance in your interest in robotics and
    AI and provides some *insider information* from a practitioner in this area.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的最后一章中，我们总结了我们在机器人和AI方面的旅程。我们讨论了机器人作为职业，并讨论了AI机器人作为职业。我提出了一些关于AI未来的问题，既有现实的也有想象的。无人机和自动驾驶汽车是现实的；机器人取代人类工作或接管世界是想象的，至少在我看来是这样。我谈到了机器人和AI没有需求，因此缺乏进化所需的动机、压力甚至能力。最后，我们讨论了AI中的风险以及如何识别它。我希望这些信息能为你在机器人和AI方面的兴趣提供一些指导，并从该领域的从业者那里提供一些*内部信息*。
- en: Now that we’re almost at the end of this book, I want to thank you for coming
    on this journey with me. I hope you have learned something along the way, even
    if it is just to know more questions to ask. I encourage you to dive in and build
    your own robot, learn about AI, and become part of the community of people who
    contribute to robotics as a hobby or a profession.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎到了这本书的结尾，我想感谢您与我一起走过这段旅程。我希望您在旅途中有所收获，即使只是知道更多的问题去问。我鼓励您深入其中，构建自己的机器人，了解AI，并成为那些将机器人作为爱好或职业贡献的人的社区的一部分。
- en: I have to acknowledge a debt of gratitude to all of the robotics and AI open
    source communities for making all of this material, knowledge, and expertise available,
    and continuing to make AI the poster child for why open source, as a model for
    the advancement of human knowledge, works and works well. ROS, which is entirely
    run by volunteers, is a case in point as it makes building robots so much easier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，我非常感激所有机器人学和人工智能开源社区，因为它们使所有这些材料、知识和专业知识变得可用，并且继续使人工智能成为开源作为人类知识进步模式的成功例证。ROS（完全由志愿者运营）就是一个很好的例子，因为它使构建机器人变得容易得多。
- en: Questions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Given that we started the chapter on a light note and ended up talking about
    robot phobia and philosophical questions about existence, do you feel that AI
    is a threat? Why or why not?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们以轻松的语气开始本章，最终讨论了机器人恐惧和关于存在的哲学问题，你认为AI是一个威胁吗？为什么或为什么不？
- en: List five professions that would be necessary to turn our Albert robot into
    a product company.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出五个必要的职业，以将我们的Albert机器人转变为产品公司。
- en: If we imagine a company that was going to put Albert the robot into production,
    would it need a psychologist? For the robot, or for the humans?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想象一家公司打算将Albert机器人投入生产，它需要心理学家吗？是为了机器人，还是为了人类？
- en: What components found in cell phones or smartphones are also found in quadcopters?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手机或智能手机中发现的哪些组件也出现在四旋翼飞行器中？
- en: Why are AI systems, specifically ANNs, naturally non-deterministic in terms
    of results and time?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么AI系统，特别是ANNs，在结果和时间上自然是非确定性的？
- en: What might be a practical application of an AI system that predictably makes
    mistakes?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可预测地犯错的AI系统可能有哪些实际应用？
- en: If an AI system was picking stocks for you and predicted a winning stock 43%
    of the time, and then you had a second AI that was 80% accurate at determining
    when the first AI had *not* picked a good stock, what percent of the time would
    the AI combination pick a profitable stock?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个AI系统为你挑选股票，并且43%的时间预测到赢家股票，然后你有一个第二个AI，它在确定第一个AI没有挑选到好股票时80%准确，那么AI组合在多少时间内会挑选到盈利的股票？
- en: Further reading
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Organization of Behavior*, by Donald Hebb, Wiley.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*行为组织*》，由 Donald Hebb，Wiley 出版。
- en: '*Computing Machinery and Intelligence*, by Alan M. Turing in the journal *Mind*.
    Vol. LIX (238).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*计算机机制与智能*》，由 Alan M. Turing 在《Mind》杂志上发表。第LIX卷（238）。
- en: '*Feet of Clay*, by Terry Pratchett, published by HarperCollins, London 2009\.
    This book discusses the fictional concept of golems, which are clay creatures
    that are *programmed* by a set of instructions written on paper and put into their
    heads, an interesting analog to robots.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*粘土之足*》，作者 Terry Pratchett，由 HarperCollins 出版，伦敦 2009年。这本书讨论了虚构的哥莱姆概念，它们是由写在纸上的指令编程的粘土生物，并将其放入它们的头脑中，这是机器人的一种有趣的类比。
- en: '*A Theory of Human Motivation*, by A.H. Maslow in the journal *Psychological
    Review*, vol. 50 (4).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*人类动机理论*》，由 A.H. Maslow 在《Psychological Review》杂志上发表，第50卷（4）。
- en: US Dept. of Transportation. *National Motor Vehicle Crash Causation* *Survey*.
    [https://crashstats.nhtsa.dot.gov/Api/Public/ViewPublication/811059](https://crashstats.nhtsa.dot.gov/Api/Public/ViewPublication/811059).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国交通部。*全国机动车事故原因调查*。[https://crashstats.nhtsa.dot.gov/Api/Public/ViewPublication/811059](https://crashstats.nhtsa.dot.gov/Api/Public/ViewPublication/811059)。
- en: '*Attacking Faulty Reasoning: A Practical Guide to Fallacy- Free Arguments*,
    by T. Edward Damer, Cengage Learning.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*攻击错误推理：无谬误论证的实用指南*》，作者 T. Edward Damer，Cengage Learning。
- en: '*Modern Generative AI with ChatGPT and OpenAI Models*, by Valentina Alito,
    Packt Publishing.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*使用ChatGPT和OpenAI模型的现代生成式人工智能*》，作者 Valentina Alito，Packt Publishing。
- en: Answers
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '[Chapter 1](B19846_01.xhtml#_idTextAnchor015)'
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第1章](B19846_01.xhtml#_idTextAnchor015)'
- en: What does the acronym PID stand for? Is this considered an AI software method?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PID这个缩写代表什么？这被认为是AI软件方法吗？
- en: '**PID** stands for **Proportional, Integral, Derivative**, and is a type of
    closed-loop controller that does not require a model (simulation) to operate.
    PID is not an AI method because there is no learning or adaptation involved in
    the decision-making. PIDs are very useful control techniques and are widely used
    to control motors and thermostats.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**PID**代表**比例、积分、微分**，是一种不需要模型（模拟）即可运行的闭环控制器。PID不是AI方法，因为在决策过程中没有涉及学习或适应。PID是非常有用的控制技术，并且广泛用于控制电机和恒温器。'
- en: What is the Turing Test? Do you feel that this is a valid method of assessing
    an artificial intelligence system?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图灵测试是什么？你感觉这是评估人工智能系统的有效方法吗？
- en: The **Turing Test**, originally called *The Imitation Game* by Alan Turing,
    is an imaginary test, or thought experiment, in which a person communicates with
    someone or something via a **teletype** (or a text message, for you younger people).
    An AI would pass the Turing Test if the person was unable to tell whether the
    entity they were communicating with was a human or a robot. The Turing Test has
    been passed by modern AI-based chatbots and generative AI engines such as ChatGPT,
    and new intelligence tests are being created ([https://www.nature.com/articles/d41586-023-02361-7](https://www.nature.com/articles/d41586-023-02361-7)).
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图灵测试**，最初由艾伦·图灵命名为*模仿游戏*，是一个想象中的测试或思想实验，其中一个人通过**电传打字机**（或文本消息，对年轻人来说）与某人或某物进行交流。如果一个人无法判断他们正在与之交流的是人类还是机器人，那么人工智能就会通过图灵测试。现代基于人工智能的聊天机器人和生成式人工智能引擎（如ChatGPT）已经通过了图灵测试，并且正在创建新的智能测试（[https://www.nature.com/articles/d41586-023-02361-7](https://www.nature.com/articles/d41586-023-02361-7)）。'
- en: Why do you think robots have a problem in general with negative obstacles such
    as stairs and potholes?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为机器人通常为什么会有负向障碍物（如楼梯和坑洼）的问题？
- en: 'It is difficult to see negative obstacles (holes, drop-offs, stairs going down,
    etc.) using the robot’s sensors, which have an easier time with positive (going
    up) obstacles. Usually, cameras and LiDAR can only see part of a negative obstacle
    due to the bottom being obscured (not visible). It is sometimes easier to reason
    about negative obstacles by seeing their shadow – the area that the sensor cannot
    see. The following diagram shows how a robot perceives a hole:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用机器人的传感器很难看到负向障碍物（洞、悬崖、下行的楼梯等），这些传感器更容易处理正向（上升）障碍物。通常，由于底部被遮挡（不可见），摄像头和激光雷达只能看到负向障碍物的一部分。有时，通过看到它们的影子——传感器无法看到的部分——更容易对负向障碍物进行推理。以下图示显示了机器人如何感知一个洞：
- en: '![Figure 11.1 – How a robot perceives a hole or negative obstacle](img/B19846_11_1.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 机器人如何看待洞或负向障碍物](img/B19846_11_1.jpg)'
- en: Figure 11.1 – How a robot perceives a hole or negative obstacle
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 机器人如何看待洞或负向障碍物
- en: 'The following diagram shows how a robot perceives stairs:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了机器人如何感知楼梯：
- en: '![Figure 11.2 – How a robot sees stairs](img/B19846_11_2.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 机器人如何看待楼梯](img/B19846_11_2.jpg)'
- en: Figure 11.2 – How a robot sees stairs
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 机器人如何看待楼梯
- en: In the OODA loop, what does the orient step do?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OODA循环中，定位步骤做什么？
- en: In the *orient* step, all of the data is put into the same reference frame,
    which is usually the robot’s central point of view. This allows the robot to determine
    which data is relevant to decision-making. It is the most important step in decision-making.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*定位*步骤中，所有数据都被放入同一个参考框架中，这通常是机器人的中心视角点。这允许机器人确定哪些数据与决策相关。这是决策过程中最重要的步骤。
- en: 'From the discussion of Python advantages, compute the following: You have a
    program that needs 50 changes tested. Assuming each change requires one run and
    a recompile step to test. A Make compile and build in C takes 450 seconds and
    a Python `run` command takes three seconds. How much time do you sit idle waiting
    for the C compiler?'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Python优势的讨论中，计算以下内容：你有一个需要测试50次更改的程序。假设每次更改都需要一次运行和重新编译步骤来测试。C语言的Make编译和构建需要450秒，而Python的`run`命令需要3秒。你坐等C编译器的时间有多长？
- en: Using Python as an interpreted language can save a lot of time on very complex
    builds, where a C/C++ compiler and link can take 20 minutes or more. The C program
    test cycle in question would take 6.25 hours to complete, while the Python test
    program would take 2.5 minutes.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Python作为解释性语言可以在非常复杂的构建上节省大量时间，其中C/C++编译器和链接可能需要20分钟或更长时间。所讨论的C程序测试周期需要6.25小时才能完成，而Python测试程序只需要2.5分钟。
- en: What does RTOS stand for?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTOS代表什么？
- en: '**RTOS** stands for **real-time operating system**. This is an operating system
    that enforces time limits and processing partitions in the OS itself. An RTOS
    is a deterministic operating system that always executes a task in the exact same
    amount of time.'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**RTOS**代表**实时操作系统**。这是一个在操作系统内部强制执行时间限制和处理分区的操作系统。RTOS是一个确定性的操作系统，它总是以相同的时间执行一个任务。'
- en: 'Your robot has the following scheduled tasks: telemetry at 10 Hz, GPS at 5
    Hz, inertial measurements at 50 Hz, and motor control at 20 Hz. At what frequency
    would you schedule the base task, and what intervals would you use for the slower
    tasks (i.e., 10 Hz base, motors every three frames, telemetry every two frames,
    etc.)?'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的机器人有以下预定任务：遥测频率为10 Hz，GPS频率为5 Hz，惯性测量频率为50 Hz，电机控制频率为20 Hz。你会在什么频率下安排基本任务，以及你会使用什么间隔来安排较慢的任务（例如，10
    Hz基本频率，每三帧一次电机控制，每两帧一次遥测等）？
- en: You need a number that all of the rates (10, 5, 50, 20) divide into evenly.
    The smallest number that fits is 100 Hz. I would also accept 50 Hz if the student
    assumed that the 20 Hz would update two times in one frame and three times in
    the next frame, which is cheating a little but a common adaptation for a real-time
    system.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要一个所有这些速率（10、5、50、20）都能均匀除尽的数字。适合的最小数字是100 Hz。如果学生假设20 Hz会在一帧中更新两次，在下一帧中更新三次，我会接受50
    Hz，这有点作弊，但这是实时系统的一种常见适应方式。
- en: Given that a frame rate scheduler has the fastest task at 20 frames per second,
    how would you schedule a task that needs to run at 7 frames per second? How about
    one that runs at 3.5 frames per second?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个帧率调度器最快的任务为每秒20帧，你将如何安排一个需要以每秒7帧运行的任务？对于每秒3.5帧运行的又如何？
- en: As given in the previous questions, there does not have to be the same number
    of samples in each frame in order to come out with a constant frame rate as long
    as there is a multiple of the base frame rate that every sample divides into.
    In this case, *20 x 7 = 140*, so the 7 Hz can run at a 20 Hz base rate, and it
    will repeat patterns every 140 frames, or 7 seconds. Half of 7 is 3.5 and can
    run at the same base rate with a pattern that repeats every 70 frames, or 3.5
    seconds.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，为了得到一个恒定的帧率，每个帧中不一定需要有相同数量的样本，只要每个样本都是基本帧率的倍数即可。在这种情况下，*20 x 7 = 140*，所以7
    Hz可以在20 Hz的基本频率下运行，并且每140帧或7秒重复一次模式。7的一半是3.5，可以在相同的基频下运行，模式每70帧重复一次，或3.5秒。
- en: Each update would be 5.7 frames apart, which gets rounded up to 6.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次更新之间会有5.7帧的距离，这会被四舍五入到6。
- en: What is a blocking call function? Why is it bad to use blocking calls in a real-time
    system such as a robot?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是阻塞调用函数？为什么在像机器人这样的实时系统中使用阻塞调用是坏事？
- en: A **blocking call** suspends the execution of your program until an interruption
    or event occurs, such as receiving a datagram or UDP packet. These are bad because
    you lose control of your program timing and cannot maintain a soft real-time execution.
    Use **polling calls** instead for serial ports and network interfaces. A polling
    call looks for data on the interface and then continues when no data is available.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个**阻塞调用**会暂停你的程序执行，直到发生中断或事件，例如接收数据报或UDP数据包。这些调用很糟糕，因为你失去了对程序时序的控制，无法维持软实时执行。对于串行端口和网络接口，请使用**轮询调用**代替。轮询调用会在接口上查找数据，然后在没有数据可用时继续。
- en: '[Chapter 2](B19846_02.xhtml#_idTextAnchor032)'
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第二章](B19846_02.xhtml#_idTextAnchor032)'
- en: Name three types of robot sensors.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举三种机器人传感器的类型。
- en: 'A sensor is anything that conveys data from the outside world to the robot.
    Sensors mentioned in the text include the following:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传感器是任何将外部世界的数据传递给机器人的东西。文中提到的传感器包括以下几种：
- en: Sonar sensors
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声纳传感器
- en: Cameras
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像头
- en: Microphone
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦克风
- en: Buttons
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Analog-to-digital voltage sensors
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟-数字电压传感器
- en: Temperature via thermistors
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过热敏电阻测量温度
- en: What does the acronym PWM stand for?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PWM的缩写代表什么？
- en: '**PWM** stands for **pulse width modulation**, a type of digital-to-analog
    control scheme where pulses are sent out that get longer based on the amount of
    control desired. In other words, the pulse duty cycle (amount of time on/off)
    gets converted into a voltage to drive a motor. This is commonly used to control
    DC motors.'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**PWM**代表**脉冲宽度调制**，这是一种数字到模拟的控制方案，其中发送的脉冲根据所需的控制量变长。换句话说，脉冲占空比（开启/关闭的时间）被转换为电压来驱动电机。这通常用于控制直流电机。'
- en: What is analog-to-digital conversion? What goes in and what comes out?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模拟-数字转换？输入和输出是什么？
- en: As the name says, **analog-to-digital** (**A2D**) conversion takes in an analog
    value, typically a voltage, and converts it into a digital value or number that
    the digital part of the computer can understand. A typical application is measuring
    battery voltage to determine the state of charge.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如其名所示，**模拟-数字**（**A2D**）转换将模拟值（通常是电压）转换为数字值或数字，这是计算机的数字部分可以理解的。一个典型的应用是测量电池电压以确定充电状态。
- en: Who invented the subsumption architecture?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁发明了子吸收架构？
- en: 'As stated in *Cambrian Intelligence: The Early History of the New AI* by Rodney
    Brooks, the subsumption architecture was originally described by Dr. Rodney Brooks,
    a professor at MIT who would later help found iRobot Corporation and invent the
    Baxter Robot. Rodney was trying to develop analogs of insect brains to understand
    how to program intelligent robots.'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如罗德尼·布鲁克斯在《 Cambrian Intelligence: The Early History of the New AI》一书中所述，子吸收架构最初由麻省理工学院教授罗德尼·布鲁克斯博士描述，他后来帮助创立了
    iRobot 公司并发明了 Baxter 机器人。罗德尼试图开发昆虫大脑的类似物，以了解如何编程智能机器人。'
- en: Compare my diagram of the three-layer subsumption architecture to the three
    laws of robotics postulated by Isaac Asimov. Is there a correlation? Why or why
    not?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我的三层子吸收架构图与艾萨克·阿西莫夫提出的机器人三大法则进行比较。是否存在相关性？为什么或为什么不？
- en: No, not really. The three laws of robotics from Isaac Asimov are fictional,
    while the **Subsumption Architecture** (**SA**) is a real architecture that is
    used to make robots in the real world.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不，实际上并不是。艾萨克·阿西莫夫的机器人三大法则是虚构的，而**子吸收架构**（**SA**）是一个真实存在的架构，用于制作现实世界中的机器人。
- en: 'Asimov’s three laws:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阿西莫夫的三大法则：
- en: Robots will not harm a human being, or through inaction, allow a human to come
    to harm
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人不会伤害人类，或者通过不作为，让人类受到伤害
- en: Robots will obey orders from humans, except when that violates the first law
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人会服从人类的命令，除非这违反了第一条法则
- en: Robots will protect themselves from harm, except when that violates the first
    two laws
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人会保护自己免受伤害，除非这违反了前两条法则
- en: 'Let’s look at the three layers in the SA:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看看 SA 中的三层：
- en: The bottom layer of the SA is the part that looks inside the robot and takes
    care of internal systems – I like to compare it to the autonomic nervous system.
    That protects the robot.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SA 的底层是机器人内部的部分，负责处理内部系统——我喜欢将其比作自主神经系统。这保护了机器人。
- en: The second layer is the short-term manager – it tells the robot where to go,
    which includes obeying orders from users.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二层是短期管理者——它告诉机器人去哪里，包括遵守用户的命令。
- en: The top layer contains the strategic thinking and planning processes. The correlation
    is weak, to be truthful.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层包含战略思考和规划过程。坦白说，相关性较弱。
- en: 'And, readers, remember the final, or zeroth, law: A robot shall not harm humanity
    or allow humanity to come to harm. That was a later addition.'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有，读者们，记住最后的，或者说零法则：机器人不得伤害人类或让人类受到伤害。这是一项后来的补充。
- en: Do you think I should have given our robot project *Albert* a name? Do you name
    your robots individually or by model?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为我应该给我的机器人项目 *Albert* 取一个名字吗？你会单独给机器人命名还是按型号命名？
- en: Roombas, being robotic vacuum cleaners, exhibit characteristics that people
    often associate with living entities, such as movement and the ability to navigate
    spaces autonomously. This behavior can trigger a human tendency to anthropomorphize
    or attribute human-like qualities to non-human entities. Naming is a natural extension
    of this anthropomorphism.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Roombas 作为机器人吸尘器，表现出人们通常与生物实体相关联的特征，如移动和自主导航空间的能力。这种行为可能会引发人类将拟人化或赋予非人类实体类似人类品质的倾向。命名是这种拟人化的自然延伸。
- en: What is the importance of the `ROS_ROOT` environment variable?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ROS_ROOT` 环境变量的重要性是什么？'
- en: The most important variables are `ROS_ROOT` and `ROS_PACKAGE_PATH`. These variables
    are used to define the filesystem paths for ROS packages and resources. They are
    essential for the ROS system to locate and use various packages and resources
    correctly.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最重要的变量是 `ROS_ROOT` 和 `ROS_PACKAGE_PATH`。这些变量用于定义 ROS 包和资源的文件系统路径。它们对于 ROS 系统正确定位和使用各种包和资源至关重要。
- en: '[Chapter 3](B19846_03.xhtml#_idTextAnchor043)'
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 3 章](B19846_03.xhtml#_idTextAnchor043)'
- en: Describe some of the differences between a storyboard for a movie or cartoon
    and a storyboard for a software program.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一下电影或卡通的分镜脚本与软件程序分镜脚本之间的区别。
- en: A storyboard for a movie is used not only for advancing the plot, but also for
    showing what point of view will be used – in other words, it is used to plan camera
    angles, directions, and movements. In that the purpose of both storyboards is
    to “tell the story” of what happens, they are the same. The point of view of a
    computer software storyboard should be the user.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电影的分镜脚本不仅用于推进剧情，还用于展示将使用什么视角——换句话说，它用于规划摄像机角度、方向和动作。由于两个分镜脚本的目的都是为了“讲述”发生的事情，它们是相同的。计算机软件分镜脚本的视角应该是用户。
- en: What are the five *W* questions? Can you think of any more questions that would
    be relevant in examining a use case?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 五个 *W* 问题是什么？你能想到任何其他在检查用例时相关的疑问吗？
- en: '*Who*, *What*, *When*, *Where*, *Why* (with *Why* being the most important).
    More relevant questions might be: How well? How often? How many or how much?'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*谁*，*什么*，*何时*，*何地*，*为什么*（*为什么*是最重要的）。更相关的问题可能包括：做得怎么样？多长时间一次？多少或多少？'
- en: 'Complete this sentence: A use case shows what the robot does but not ________.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个句子：用例展示了机器人做什么，但不是 ________。
- en: “How it does it.” Use cases are from the user’s perspective and never include
    implementation details.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “它是如何做到的。”用例是从用户的角度出发的，永远不会包括实现细节。
- en: Take the storyboard in *step 9*, where the robot is driving to the toybox, and
    break it down into more sequenced steps in your own storyboard. Think about everything
    that must happen between *frames 9* and *10*.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 9* 中取故事板，其中机器人正在驶向玩具箱，并在你自己的故事板中将它分解成更多有序的步骤。考虑在 *帧 9* 和 *帧 10* 之间必须发生的一切。
- en: 'The robot has to do the following:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器人必须执行以下操作：
- en: Determine a route to the toybox.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定通往玩具箱的路线。
- en: Plan a path.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规划一条路径。
- en: Avoid obstacles along the way.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路上避开障碍物。
- en: Align itself with the front of the toybox.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与玩具箱的前端对齐。
- en: Drive up to the toybox.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驶向玩具箱。
- en: Move the robot arm to clear the top.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将机器人手臂移动以清除顶部。
- en: Complete the reply form of the “knock-knock” joke, where the robot answers the
    user telling the joke. What do you think is the last step?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成回复“敲门”笑话的表格，其中机器人回答用户告诉的笑话。你认为最后一步是什么？
- en: It is to compliment the teller of the joke – the robot should say “That is very
    funny” or “I am sorry, I am unable to groan”. Yes, that is my opinion and not
    an official joke writer’s idea. What do you think?
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是为了补充讲笑话的人 – 机器人应该说“这非常有趣”或“我很抱歉，我无法呻吟”。是的，这是我的观点，而不是官方笑话创作者的想法。你怎么看？
- en: Look at the teleoperate operations. Would you add any more or does this look
    like a good list?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看远程操作操作。你会添加更多吗？或者这看起来像是一个很好的列表？
- en: The robot needs to send video back to the operator so that the operator can
    see where they are going.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器人需要将视频发送回操作员，以便操作员可以看到他们要去哪里。
- en: Write a specification for a sensor that uses distance measurement to prevent
    the robot from driving downstairs.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为使用距离测量来防止机器人驶下楼梯的传感器编写规范。
- en: The robot shall have a sensor capable of detecting negative obstacles in the
    floor (i.e., stairs going downward, balconies) at a distance of at least six inches
    from the robot along the robot’s driving direction.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器人应具有一种传感器，能够在至少六英寸的距离上检测到地面上的负障碍物（例如，向下走的楼梯，阳台）。
- en: At which distance can a camera with 320x200 pixels and a 30-degree **field of
    view** (**FOV**) vertically and horizontally see a 6” stuffed animal, assuming
    we need 35 pixels for recognition?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪个距离上，一个320x200像素、30度 **视野**（**FOV**）的摄像头可以垂直和水平地看到6英寸的填充动物玩具，假设我们需要35像素进行识别？
- en: 'To solve this problem, we first need to determine how many degrees per pixel
    we have and then use that to calculate the angular dimension of the target, which
    is 35 pixels tall:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们首先需要确定每像素有多少度，然后使用这个值来计算目标的角度尺寸，该目标高度为35像素：
- en: '*30 degrees / 320 pixels wide =* *0.0937 deg/pixel*'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*30 度 / 320 像素宽 =* *0.0937 度/像素*'
- en: 'To find the number of degrees per pixel, we can perform the following calculation:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要找到每像素的度数，我们可以进行以下计算：
- en: '*35 pixels* deg/pixel =* *3.28 degrees*'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*35 像素* 度/像素 =* *3.28 度*'
- en: This gives us an isosceles triangle, but we need a right triangle to do the
    math. Divide the base into two to make a right triangle; thus, the base of this
    triangle is now *3 inches*.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给我们一个等腰三角形，但我们需要一个直角三角形来进行数学计算。将底边分成两半以形成一个直角三角形；因此，这个三角形的底边现在是 *3 英寸*。
- en: 'We also divide the angle in half:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还将角度分成两半：
- en: '*3.28/2 =* *1.64 degrees*'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*3.28/2 =* *1.64 度*'
- en: 'Then, to calculate the perpendicular height, we divide the length of the base
    by the value of *tan*:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，为了计算垂直高度，我们将底边的长度除以 *tan* 的值：
- en: '*3 / tan(1.64) =* *104.78 inches*'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*3 / tan(1.64) =* *104.78 英寸*'
- en: This translates to 8.73 feet.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这相当于 8.73 英尺。
- en: 'This can be illustrated by the following diagram:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过以下图表说明：
- en: '![Figure 11.3 – Solving for pixels needed for recognition](img/B19846_11_3.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 计算识别所需的像素](img/B19846_11_3.jpg)'
- en: Figure 11.3 – Solving for pixels needed for recognition
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 计算识别所需的像素
- en: Thus, the required distance is 8.73 feet.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所需距离是 8.73 英尺。
- en: '[Chapter 4](B19846_04.xhtml#_idTextAnchor126)'
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 4 章](B19846_04.xhtml#_idTextAnchor126)'
- en: We went through a lot in this chapter. You can use the framework provided to
    investigate the properties of neural networks. Make adjustments to the learning
    rate, batch size, number of epochs, and loss functions.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在本章中学到了很多。你可以使用提供的框架来研究神经网络的特性。调整学习率、批量大小、训练轮数和损失函数。
- en: This is an exercise for the student. You should see different curves develop
    as these parameters are changed. Some will not produce an answer at all (which
    looks like random results – the curve stays at the same level as no learning is
    taking place). Some will learn faster or slower.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个学生的练习。你应该看到随着这些参数的变化，会出现不同的曲线。有些可能根本不会产生答案（看起来像随机结果——曲线保持在同一水平，因为没有发生学习）。有些会学得更快或更慢。
- en: Draw a diagram of an artificial neuron and label the parts. Look up a natural,
    human biological neuron and compare.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个人工神经元的图并标注各部分。查找一个自然的人类生物神经元并比较。
- en: See *Figure 4**.3* in the chapter. The artificial neuron has a number of inputs,
    a set of weights, one for each input, a bias, an activation, and a set of outputs.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参见章节中的*图4**.3*。人工神经元有几个输入，一组权重，每个输入一个，一个偏差，一个激活和一个输出集。
- en: Which features are the same in a real neuron and an artificial neuron?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真实神经元和人工神经元有哪些相同之处？
- en: 'Both have multiple inputs and multiple outputs and accept inputs, perform some
    processing, and then make an output. Both use some sort of activation function
    (the biological equivalent is the synapse) to determine when to *fire* or produce
    an output. Both are part of networks: it takes a lot of neurons to compose a neural
    network, and likewise an animal brain.'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两者都有多个输入和多个输出，接受输入，执行一些处理，然后输出。两者都使用某种激活函数（生物上的等效物是突触）来确定何时*触发*或产生输出。两者都是网络的一部分：组成一个神经网络需要很多神经元，同样，动物大脑也是如此。
- en: Which features of a real neuron and an artificial neuron are different?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真实神经元和人工神经元有哪些不同之处？
- en: The natural **neuron** is an analog device that can handle many levels or degrees
    of input, with no simple on/off binary representations like the computer neuron.
    Neurons use chemical paths that make pathways and connections easier the more
    they are used, which is the learning function of a neuron. This is simulated by
    the weights in an artificial neuron. The natural neuron has an axon, or connecting
    body, that extends out to the outputs that can be at a quite distance from the
    nerve inputs. Neurons are randomly connected to other neurons, while artificial
    neurons are connected in regular patterns. Some neural networks use **dropout
    layers** that randomly disconnect neurons, providing some randomness to the output
    that helps the network estimate non-linear solutions.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然**神经元**是一种模拟设备，它可以处理许多级别的输入，没有像计算机神经元那样的简单开/关二进制表示。神经元使用化学路径，这些路径和连接在使用过程中变得更加容易，这就是神经元的
    学习功能。这通过人工神经元中的权重来模拟。自然神经元有一个轴突，或连接体，它延伸到输出，这些输出可以距离神经输入相当远。神经元以随机方式连接到其他神经元，而人工神经元则以规则模式连接。一些神经网络使用**dropout层**，随机断开神经元，为输出提供一些随机性，这有助于网络估计非线性解。
- en: What relationship does the first layer of a neural network have to the input?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 神经网络的第几层与输入有什么关系？
- en: The first layer contains the number of inputs to the network. For instance,
    if you have five inputs, then the first layer must contain five neurons.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一层包含网络的输入数量。例如，如果你有五个输入，那么第一层必须包含五个神经元。
- en: What relationship does the last layer of a neural network have to the output?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 神经网络的最后一层与输出有什么关系？
- en: The last layer of an ANN is the output layer and has to have the same number
    of neurons as there are potential outputs.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ANN的最后一层是输出层，必须与潜在输出的数量相同。
- en: Look up three kinds of loss functions and describe how they work. Include mean
    square loss and the two kinds of cross-entropy loss.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找三种损失函数并描述它们的工作原理。包括均方损失和两种交叉熵损失。
- en: '**Loss functions** in ANNs are the error functions that compare the expected
    output of the neuron with the actual output. Let’s look at them in detail:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ANN中的**损失函数**是误差函数，它比较神经元的预期输出与实际输出。让我们详细看看它们：
- en: '**Mean square loss** (**MSL**): This is the most commonly used loss function.
    It is given by the sum of the squares of the distances between the output and
    the expected output. MSL amplifies the error the farther away from the desired
    solution it is.'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均方损失**（**MSL**）：这是最常用的损失函数。它由输出与期望输出之间距离的平方和给出。MSL会放大离期望解越远的错误。'
- en: '**Cross entropy** (**XE**): This is also called log loss and is used mostly
    for the classification of CNNs. As the predicted value approaches 1 (no error),
    XE slowly decreases. As the values diverge, XE increases rapidly. Two types of
    cross entropy are as follows:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉熵**（**XE**）：这也被称为对数损失，主要用于CNN的分类。随着预测值接近1（无错误），XE缓慢减少。随着值的发散，XE迅速增加。以下有两种类型的交叉熵：'
- en: Binary (on/off, used for yes/no questions)
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制（开/关，用于是/否问题）
- en: Sigmoid cross-entropy, which can handle multiple classes
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sigmoid交叉熵，可以处理多个类别
- en: What would you change if your network trained to 40% and got “stuck” or was
    unable to learn anything further?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的网络训练到40%并且“卡住”或无法进一步学习，你会改变什么？
- en: You are probably *overfitting* and have too small a sample size or your network
    is not wide or deep enough.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能**过度拟合**了，样本大小太小，或者你的网络不够宽或不够深。
- en: '[Chapter 5](B19846_05.xhtml#_idTextAnchor159)'
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第五章](B19846_05.xhtml#_idTextAnchor159)'
- en: In Q-learning, what does the Q stand for (you will have to research this on
    the internet)?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Q学习中，Q代表什么（你需要在互联网上查找这个答案）？
- en: The origin of **Q-learning** is the doctoral thesis of Christopher John Cornish
    Hellaby Watkins from King’s College, London, May, 1989 ([https://www.researchgate.net/publication/33784417_Learning_From_Delayed_Rewards](https://www.researchgate.net/publication/33784417_Learning_From_Delayed_Rewards)).
    Evidently, the Q just stands for *Quantity*.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Q学习**的起源是伦敦国王学院克里斯托弗·约翰·康尼什·赫拉比·沃特金斯博士的博士论文，1989年5月([https://www.researchgate.net/publication/33784417_Learning_From_Delayed_Rewards](https://www.researchgate.net/publication/33784417_Learning_From_Delayed_Rewards))。显然，Q只是代表*数量*。'
- en: What could we do to limit the number of states that the Q-learning algorithm
    must search through?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以做什么来限制Q学习算法必须搜索的状态数量？
- en: Only pick the Q-states that are relevant and are follow-ons to the current state.
    If one of the states is impossible to reach from the current position, or state,
    then don’t consider it.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只选择与当前状态相关且是后续状态的Q状态。如果某个状态从当前位置或状态无法达到，则不考虑它。
- en: What effect does changing the learning rate have on the learning process?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变学习率对学习过程有什么影响？
- en: If the learning rate is too small, the training can take a very long time. If
    the learning rate is too large, the system does not learn a path but instead overshoots
    and may miss the minimum or optimum solution. If the learning rate is too big,
    the solution may not converge or may suddenly drop off.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果学习率太小，训练可能需要非常长的时间。如果学习率太大，系统不会学习路径，而是过度估计，可能错过最小或最佳解决方案。如果学习率太大，解决方案可能不会收敛或可能突然下降。
- en: What function or parameter serves to penalize longer paths in the Q-learning
    equation? What effect does increasing or decreasing this function have?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Q学习方程中，哪个函数或参数用于惩罚较长的路径？增加或减少这个函数会有什么影响？
- en: The discount factor works by decreasing the reward as the path length gets longer.
    It is usually a value just short of 1.0, for example, 0.93\. Making the discount
    factor higher may cause the system to reject valid longer paths and not find a
    solution. If the discount is too small, then the paths may be very long.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 折扣因子通过随着路径长度的增加而减少奖励来工作。它通常是一个略小于1.0的值，例如，0.93。提高折扣因子可能导致系统拒绝有效的较长路径，找不到解决方案。如果折扣太小，则路径可能非常长。
- en: In the genetic algorithm, how would you go about penalizing longer paths so
    that shorter paths (fewer number of steps) would be preferred?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遗传算法中，你将如何惩罚较长的路径，以便更偏好较短的路径（步骤数较少）？
- en: You would adjust the fitness function to consider path length as a factor in
    the fitness calculation.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会调整适应度函数，将路径长度作为适应度计算的因子。
- en: What effect does changing the learning rate in the genetic algorithm change?
    What are the upper and lower bounds of the learning rate?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变遗传算法中的学习率会有什么影响？学习率的上限和下限是多少？
- en: Generally, increasing the learning rate shortens the learning time in generations,
    up to a limit where the path jumps out of the valid range. For our example program,
    the lowest learning rate that returns a valid solution is five, and the highest
    value is 15.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，增加学习率可以缩短每一代的学习时间，直到达到一个路径跳出有效范围的极限。对于我们的示例程序，返回有效解决方案的最低学习率是5，最高值是15。
- en: In the genetic algorithm, what effect does lowering the population cause?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遗传算法中，降低种群数量会有什么影响？
- en: It causes the simulation to run much faster but take many more generations to
    find a solution.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使得模拟运行得更快，但需要更多代才能找到解决方案。
- en: '[Chapter 6](B19846_06.xhtml#_idTextAnchor205)'
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第6章](B19846_06.xhtml#_idTextAnchor205)'
- en: Do some internet research on why an open source voice assistant was named Mycroft.
    How many stories did you find and which one did you like?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做一些互联网研究，了解为什么开源语音助手被命名为Mycroft。你找到了多少故事，哪一个你喜欢？
- en: I found at least three. My favorite is that Mycroft is Sherlock Holmes’ older,
    and some say smarter, brother. Sherlock Holmes is played on TV in the UK by Benedict
    Cumberbatch, who also played Alan Turing in the movie *The Imitation Game*, the
    original name of the Turing Test, a test of AI conversation, which is what Mycroft
    does.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我至少找到了三个。我最喜欢的是Mycroft是福尔摩斯的哥哥，有些人说更聪明。福尔摩斯在英国的电视上由本尼迪克特·康伯巴奇扮演，他在电影《模仿游戏》中扮演了艾伦·图灵，这是图灵测试的原名，是一种AI对话测试，这正是Mycroft所做的事情。
- en: In the discussion of intent, how would you design a neural network to predict
    command intent from natural language sentences?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在意图的讨论中，你会如何设计一个神经网络来从自然语言句子中预测命令意图？
- en: One approach would be to gather a selection of commands, label the intent of
    the command, use the commands as input in a neural network, and use intent as
    the output label for the training.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种方法可能是收集一系列命令，标注命令的意图，将命令作为神经网络的输入，并将意图作为训练的输出标签。
- en: Rewrite the “receive knock-knock jokes” program to remember the jokes told to
    the robot by adding them to the joke database used by the “tell knock-knock jokes”
    program. Is this machine learning?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“接收敲门笑话”程序重写为记住机器人被告诉的笑话，通过将其添加到“讲敲门笑话”程序使用的笑话数据库中。这是机器学习吗？
- en: It is fairly simple to add a program to just write to the knock-knock joke program
    database. You’ll find a version of this in the GitHub Repository. Is this machine
    learning? I would say definitely! The machine has a capability that it did not
    have before. It did not have to be reprogrammed to have the new capability, so
    it learned.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将程序添加到仅向“敲门笑话”程序数据库写入是非常简单的。你可以在GitHub仓库中找到这个版本的程序。这是机器学习吗？我会说绝对是！这台机器有了它以前没有的能力。它不需要重新编程来获得新的能力，所以它是通过学习获得的。
- en: Modify `KnockKnock` (the program that tells knock-knock jokes) to play sounds
    from a `WAV` file, such as a music clip, as well as do text-to-speech.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`KnockKnock`（讲敲门笑话的程序）以播放`WAV`文件中的声音，例如音乐片段，以及进行文本到语音转换。
- en: 'Add these lines to the `KnockKnock` program:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这些行添加到`KnockKnock`程序中：
- en: '[PRE0]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can use this to play the audio. You can also add a tag to the joke file
    that indicates a `WAV` file `<groan.wav>`. Then, if you see this tag, call the
    `play_wav_cmdline` function above.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以用这个来播放音频。你还可以给笑话文件添加一个标签，表示一个`WAV`文件`<groan.wav>`。然后，如果你看到这个标签，就调用上面的`play_wav_cmdline`函数。
- en: The sentence structure used in this chapter is all based on English grammar.
    Other languages, such as French and Japanese, have different structures. How does
    that change the parsing of sentences? Would the program we wrote be able to understand
    Yoda?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章使用的句子结构都是基于英语语法的。其他语言，如法语和日语，有不同的结构。这会如何改变句子的解析？我们编写的程序能否理解Yoda？
- en: In other languages, the object or the subject appears in a different order,
    just as in Yoda’s speech patterns. “Backwards, I talk,” Yoda would say. This does
    require us to change or add new sentence patterns to our `.``voc` files.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在其他语言中，宾语或主语的出现顺序不同，就像在Yoda的说话模式中一样。“我倒着说，”Yoda会说。这确实要求我们更改或添加新的句子模式到我们的`.voc`文件中。
- en: You can follow Mycroft’s instructions for changing the engine to understand
    French at [https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/customizations/languages](https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/customizations/languages).
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以遵循Mycroft的说明，在[https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/customizations/languages](https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/customizations/languages)中将引擎更改为理解法语。
- en: Do you think that Mycroft’s Intent Engine is actually understanding intent or
    just pulling out keywords?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为Mycroft的意图引擎实际上是在理解意图，还是只是在提取关键词？
- en: I do not place Mycroft in the category of construction AI chatbots, but it is
    rather a referential type that looks up answers in a database, which makes it
    more of an expert system than an AI program. It does use AI neural networks in
    the speech-to-text section.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我并不将Mycroft归类为建筑AI聊天机器人，而更是一种参考类型，它在数据库中查找答案，这使得它更像是一个专家系统，而不是一个AI程序。它在语音转文本部分确实使用了AI神经网络。
- en: Describe the voice commands necessary to instruct the robot to drive to an object
    and pick it up without the robot being able to recognize the object. How many
    commands do you need?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述必要的语音命令，以指导机器人前往一个物体并拾取它，而机器人无法识别该物体。你需要多少个命令？
- en: 'We need two commands:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要两个命令：
- en: '*Can you see* *any objects?*'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你能看到* *任何物体吗？*'
- en: '*Drive to the* *closest object*'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前往最近的物体*'
- en: From *Question 7*, work to minimize the number of commands. How many can you
    eliminate or combine?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**问题7**中，努力减少命令的数量。你可以消除或合并多少个？
- en: 'The following are the voice commands to tell the robot to drive to the nearest
    object:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是将机器人驱动到最近物体的语音命令：
- en: '*Hey, Albert*'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嘿，阿尔伯特*'
- en: '*Drive to the* *nearest object*'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前往最近的物体*'
- en: From *Question 7*, how many unique keywords are involved? How many non-unique
    keywords?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**问题7**中，涉及了多少个独特的关键词？有多少个非独特的关键词？
- en: The four keywords are **see**, **objects**, **drive**, and **closest**.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 四个关键词是**看到**、**物体**、**前往**和**最近**。
- en: All of the words are unique except **objects**, so there are three unique words.
    They have not been otherwise defined in the Mycroft word database.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有的词都是唯一的，除了**物体**，所以有三个独特的单词。它们在Mycroft单词数据库中未作其他定义。
- en: '[Chapter 7](B19846_07.xhtml#_idTextAnchor221)'
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第7章](B19846_07.xhtml#_idTextAnchor221)'
- en: Regarding SLAM, what sensor is most used to create the data that SLAM needs
    to make a map?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于SLAM，哪种传感器最常用于创建SLAM制作地图所需的数据？
- en: '**Light detection and ranging** (**LiDAR**) sensors are the most common SLAM
    sensors used by a wide margin. The 3D data that LiDAR provides is perfect for
    SLAM’s mapping function.'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**光探测与测距**（**LiDAR**）传感器是最常用的SLAM传感器，远远超过其他传感器。LiDAR提供的3D数据非常适合SLAM的映射功能。'
- en: Why does SLAM work better with wheel odometer data available?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么SLAM在有轮式里程计数据的情况下工作得更好？
- en: The wheel odometers reduce the search space that the SLAM algorithm needs to
    look for the possible locations of the robot after moving. Thus, it increases
    information and reduces uncertainty in the map. How does it do this? By giving
    extra measurements about where the robot is located (how far it moved), we can
    then reduce our search to match where we are against our sensor readings.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轮式里程计减少了SLAM算法在移动后寻找机器人可能位置所需搜索的空间。因此，它增加了地图中的信息并减少了不确定性。它是如何做到这一点的？通过提供额外的关于机器人位置（移动了多远）的测量，然后我们可以将搜索范围缩小到与我们的传感器读数匹配的位置。
- en: In the Floor Finder algorithm, what does the Gaussian blur function do to improve
    the results?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Floor Finder算法中，高斯模糊函数是如何改善结果的？
- en: The **Gaussian blur function** reduces noise and gets rid of stray single pixels
    in the image, making for a smoother result.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**高斯模糊函数**减少噪声并去除图像中的散乱的单个像素，从而得到更平滑的结果。'
- en: The final step in Floor Finder is to trace upwards from the robot’s position
    to the first red pixel. In what other way can this step be accomplished (referring
    to *Figure 7**.3*)?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Floor Finder的最后一步是从机器人的位置向上追踪到第一个红色像素。这个步骤还可以用其他什么方式完成（参考**图7**.3）？
- en: Instead of using radial red lines, the program can just draw upwards from the
    bottom of the screen in a series of vertical lines.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是使用径向红色线条，程序可以直接从屏幕底部向上绘制一系列垂直线条。
- en: Why did we cut the image in half horizontally before doing our neural network
    processing?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在进行神经网络处理之前将图像水平切半？
- en: We just want to use the upper half of the room to train the network because
    the lower half has the toys on it and is subject to change. The upper half of
    the room does not change with the addition of toys.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只想使用房间上半部分来训练网络，因为下半部分有玩具，并且可能会发生变化。房间上半部分不会因为玩具的增加而改变。
- en: What advantages does using the neural network approach provide that a technique
    such as SLAM does not?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用神经网络方法相较于SLAM技术有哪些优势？
- en: We don’t have to have a map to successfully navigate the room. We are providing
    labeling of our training set by just driving the robot around and taking pictures
    at regular intervals. This approach is also far more resilient to changes in the
    room, such as the furniture being in slightly different positions. Please also
    see [https://hackaday.com/2021/10/25/fast-indoor-robot-watches-ceiling-lights-instead-of-the-road/](https://hackaday.com/2021/10/25/fast-indoor-robot-watches-ceiling-lights-instead-of-the-road/)
    for someone else’s implementation of this idea, used for indoor car racing.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不需要地图就能成功导航房间。我们只是通过驾驶机器人并在固定间隔拍照来提供训练集的标记。这种方法对房间中的变化（如家具位置略有不同）也更具弹性。请参阅[https://hackaday.com/2021/10/25/fast-indoor-robot-watches-ceiling-lights-instead-of-the-road/](https://hackaday.com/2021/10/25/fast-indoor-robot-watches-ceiling-lights-instead-of-the-road/)，了解其他人实现这一想法的示例，用于室内赛车。
- en: If we used just a random driving function (where you make random turns at random
    times) instead of the neural network, what new program or function would we have
    to add to the robot to achieve the same results?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只使用随机驾驶功能（在随机时间进行随机转弯）而不是神经网络，我们还需要在机器人上添加什么新程序或功能才能达到相同的结果？
- en: We would need to have a navigation function that determined where in the room
    we were at – this would probably mean a SLAM algorithm. We would also need something
    to detect the stairs.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要一个导航功能来确定我们在房间中的位置——这很可能意味着一个SLAM算法。我们还需要某种东西来检测楼梯。
- en: How did we end up avoiding the stairs in the approach presented in the chapter?
    Do you feel that this is adequate? Would you suggest any other means to accomplish
    this task?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是如何在章节中提出的方法中避免楼梯的？你认为这足够吗？你会建议其他方法来完成这项任务吗？
- en: We trained the robot to navigate by looking at the upper part of the room. We
    only drove the robot in safe areas and used that information to allow the robot
    to predict its next driving command based on where it was in the room. Since we
    did not drive the robot down the stairs in this process, the robot will never
    get a command to drive toward the stairs. If there is a toy near the stairs, the
    robot will still go pick it up but will drive away from the stairs afterward when
    it goes back to navigation mode. We have to be careful to get a good training
    result before letting the robot loose, however. I used a baby gate to block the
    stairs for early testing. As an additional safety measure, we can add a lookdown
    sensor to detect stairs. I would use an **infrared proximity detector** (**IRPD**)
    for this purpose.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们训练机器人通过观察房间的上半部分来导航。我们只在安全区域驾驶机器人，并使用这些信息让机器人根据它在房间中的位置预测其下一个行驶命令。由于我们没有在这个过程中让机器人沿着楼梯行驶，机器人将永远不会收到向楼梯行驶的命令。如果楼梯附近有一个玩具，机器人仍然会去捡起它，但在返回导航模式后会避开楼梯行驶。然而，我们必须在让机器人自由行动之前小心地获得良好的训练结果。我使用婴儿门来阻挡楼梯进行早期测试。作为额外的安全措施，我们可以添加一个向下看的传感器来检测楼梯。我会使用**红外接近探测器**（**IRPD**）来完成这个目的。
- en: '[Chapter 8](B19846_08.xhtml#_idTextAnchor235)'
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第8章](B19846_08.xhtml#_idTextAnchor235)'
- en: What are the three ways to traverse a decision tree?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历决策树的三种方式是什么？
- en: From beginning to end (start to goal); from goal to start; and from both ends
    at once to meet in the middle.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从开始到结束（起点到目标）；从目标到开始；以及同时从两端出发在中途相遇。
- en: In the fishbone diagram example, how do you go about pruning the branches of
    the decision tree?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在鱼骨图示例中，你是如何剪掉决策树的分支的？
- en: By eliminating the effect of the item on a branch. For example, using our “robot
    does not move” fault, if the branch says “Arduino-no power” and you check to see
    if the Arduino has power and it does, you can prune that branch. If the branch
    is “motor stuck”, the effect of having a motor stuck is that the robot will drive
    in circles. As the robot is not driving in circles – it is not driving at all
    – you can prune that branch.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过消除分支上项目的影响。例如，使用我们的“机器人不移动”故障，如果分支说“Arduino无电源”并且你检查Arduino是否有电源并且它确实有，你可以剪掉那个分支。如果分支是“电机卡住”，电机卡住的影响是机器人会绕圈行驶。由于机器人没有绕圈行驶——它根本就没有行驶——你可以剪掉那个分支。
- en: What is the role of the Gini coefficient in creating a classification?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gini系数在创建分类中扮演什么角色？
- en: It determines the amount of *impurity* in the sample or pool. When the Gini
    coefficient = 0, all of the members of the class have the same attributes, and
    no further subdivision is possible. This minimizes misclassification. The Gini
    coefficient is given by one minus the sum of the square of the probability of
    an item being in that class.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它决定了样本或池中的 *不纯度*。当基尼系数 = 0 时，该类别的所有成员具有相同的属性，并且无法进一步细分。这最小化了误分类。基尼系数由 1 减去一个项目属于该类别的概率的平方和给出。
- en: In the toy classifier example using the Gini coefficient, which attributes of
    the toy were not used by the decision tree? Why not?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用基尼系数的玩具分类器示例中，哪些玩具属性没有被决策树使用？为什么？
- en: Color, Noise, Soft, and Material were not useful for dividing the categories
    by labels as the labels and the items did not correlate. It does make sense that
    color is not useful for dividing toys by type.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 颜色、噪声、柔软和材料对于通过标签划分类别没有用，因为标签和项目之间没有相关性。颜色对于通过类型划分玩具没有用是有意义的。
- en: Which color for the toys was used as a criterion by one of the classification
    techniques we tried?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试的其中一个分类技术将哪种颜色用于玩具作为标准？
- en: The color white was used by the decision tree that used the Gini index and one
    hot encoding to separate the stuffed animals.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用基尼指数和独热编码来分离填充玩具的决策树使用了白色。
- en: Give an example of label encoding and one hot encoding for menu items at a restaurant.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请给出餐厅菜单项的标签编码和独热编码的例子。
- en: 'Let’s have three types of menu items: appetizer, entrée, and dessert. Label
    encoding would substitute 0 for appetizer, 1 for entrée, and 2 for dessert. One
    hot encoding would use 1 0 0 for appetizer, 0 1 0 for entrée, and 0 0 1 for dessert.'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们有三类菜单项：开胃菜、主菜和甜点。标签编码将开胃菜替换为 0，主菜替换为 1，甜点替换为 2。独热编码将开胃菜表示为 1 0 0，主菜表示为 0
    1 0，甜点表示为 0 0 1。
- en: In the A* algorithm, discuss the different ways that `G()` and `H()` are computed.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 A* 算法中，讨论 `G()` 和 `H()` 的不同计算方式。
- en: The `G()` function is the distance along the path from the current position
    to the start. `H()` is the distance from the current position directly to the
    goal (the Euclidean distance). Note that `G()` follows the path and `H()` is the
    straight-line distance to the goal since we have not computed a path to the goal
    yet.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`G()` 函数是从当前位置到起点的路径距离。`H()` 是从当前位置直接到目标（欧几里得距离）。请注意，`G()` 沿路径计算，而 `H()` 是到目标点的直线距离，因为我们还没有计算到目标点的路径。'
- en: In the A* algorithm, why is `H()` considered heuristic and `G()` not? In the
    D* algorithm, heuristics are not used. Why not?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 A* 算法中，为什么 `H()` 被认为是启发式，而 `G()` 不是？在 D* 算法中，不使用启发式。为什么？
- en: '`H()` – the direct line distance to the goal – is an estimate and ignores any
    obstacles, it can’t be used directly but is just a way to compare one position
    to another. A major difference between D* and A* is that D* starts at the goal
    and works backward toward the start. This allows D* to know the exact cost to
    the target – it is using the actual path distance to the goal from the current
    position and not a heuristic approach or an estimate of the distance to go, as
    A* did.'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`H()` – 到目标点的直接线距离 – 是一个估计值，忽略了任何障碍物，不能直接使用，只是比较一个位置到另一个位置的一种方式。D* 和 A* 之间的一个主要区别是
    D* 从目标点开始，反向工作到起点。这允许 D* 知道到目标的确切成本 – 它使用从当前位置到目标点的实际路径距离，而不是像 A* 那样使用启发式方法或距离估计。'
- en: In the D* algorithm, why is there a `RAISED` and a `LOWERED` tag and not just
    a `CHANGED` flag?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 D* 算法中，为什么有 `RAISED` 和 `LOWERED` 标签而不是仅仅一个 `CHANGED` 标志？
- en: The `RAISED` squares or points are eliminated from consideration. The `LOWERED`
    squares may be added back into the queue for consideration to be a path. Keep
    in mind that lowering scores due to new sensor readings ripples through the path
    planner.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RAISED` 的方块或点被排除在考虑之外。`LOWERED` 的方块可能被添加回队列以考虑作为路径。记住，由于新的传感器读数而降低分数会在路径规划器中产生涟漪效应。'
- en: '[Chapter 9](B19846_09.xhtml#_idTextAnchor294)'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 9 章](B19846_09.xhtml#_idTextAnchor294)'
- en: What is your favorite movie robot? How would you describe its personality?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你最喜欢的电影机器人是什么？你会如何描述它的个性？
- en: This is, of course, a subjective question. I’m a big R2D2 fan. R2 is feisty,
    determined, and stubborn as well as being a faithful companion and helper. R2
    will get you out of a jam, fix your starfighter, provide cover from hostile fire,
    and hack Imperial computers. He is a Swiss army knife on wheels.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这当然是一个主观问题。我是一个大R2D2粉丝。R2既活泼、坚定、固执，又是一个忠诚的伴侣和助手。R2能帮你摆脱困境，修理你的星际战斗机，提供对抗敌对火力的掩护，还能破解帝国的电脑。他就像一个轮子上的瑞士军刀。
- en: What techniques did the movie-makers use to express R2D2’s personality (body
    language, sounds, etc.)?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电影制作者使用了哪些技巧来表达R2D2的性格（肢体语言、声音等）？
- en: R2D2 owes his personality to a combination of his emotional beeps and squawks
    (provided by Ben Burtt) and his body movements provided by having a person inside
    his chassis (Kenny Baker). They were stuck with the not-very versatile chassis
    designed for the first *Star Wars* movie, which only has a head that moves. Most
    of R2’s persona comes through in his sounds, including his famous scream.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R2D2的性格得益于他情感的哔哔声和尖叫声（由本·伯特提供）以及他底盘内的身体动作（肯尼·贝克提供）。他们被固定在为第一部**《星球大战》**电影设计的并不非常灵活的底盘上，这个底盘只有一个可以移动的头。R2的大部分个性都体现在他的声音上，包括他著名的尖叫声。
- en: What are the two types of chatbots? List some of the strengths and weaknesses
    of each.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种聊天机器人？列出每种的一些优点和缺点。
- en: 'The two types of chatbots are as follows:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两种类型的聊天机器人如下：
- en: '**Retrieval-based chatbots**: Retrieval-based chatbots look up responses in
    lists of scripts and choose from a number of phrases that are written in advance
    by humans. The strengths of these chatbots are that they are easy to program,
    allow more control over the outputs, and are much smaller and faster programs.
    The weaknesses are that they have limited responses and the use of keywords gives
    them a small vocabulary.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于检索的聊天机器人**：基于检索的聊天机器人会在脚本列表中查找响应，并从人类预先编写的一系列短语中选择。这些聊天机器人的优点是编程简单，可以更好地控制输出，并且程序更小、更快。缺点是响应有限，使用关键词使它们的词汇量很小。'
- en: '**Generative chatbots**: Generative chatbots use the rules of grammar and models
    of sentences to create new sentences with proper meaning, are more flexible, and
    can handle a wider range of topics, but they are much harder to program and are
    complex and slow (comparatively speaking). Generative chatbots have now taken
    over, given the success of ChatGPT and other generative AI models.'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成式聊天机器人**：生成式聊天机器人使用语法规则和句子模型来创建具有适当意义的新句子，它们更加灵活，可以处理更广泛的主题，但它们编程起来更困难，且复杂且慢（相对而言）。鉴于ChatGPT和其他生成式AI模型的成功，生成式聊天机器人现在已经占据了主导地位。'
- en: In *Figure 9**.2*, the illustration on modeling custom distributions (the airport
    example), the lower picture shows two standard distributions and two uniform distributions.
    Why don’t the curves go all the way to the top of the graph?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图9.2**中，建模自定义分布（机场示例）的插图，下面的图片显示了两个标准分布和两个均匀分布。为什么曲线没有延伸到图表的顶部？
- en: The two distributions will add together – the standard distributions sit *on
    top* of the uniform distributions, and the two combined go to the top of the graph.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个分布将相加——标准分布位于**顶部**的均匀分布之上，两者结合后达到图表的顶部。
- en: 'Design your own robot emotions: Pick six contrasting emotions that can express
    the entire range of your robot’s personality. Why did you pick those?'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你自己的机器人情感：挑选六种对比鲜明的情感，以表达你机器人性格的整个范围。你为什么选择这些情感？
- en: This is another subjective question. My answers are in the text. I picked emotions
    that represented the range of capability of my robot and the situations it would
    be in. I kept to a friendly type of robot so that the only negative emotion was
    sadness – there was no anger, for instance.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这又是一个主观问题。我的答案在文本中。我选择了代表我的机器人能力和它将遇到的情况的情感。我保持了一个友好的机器人类型，所以唯一的负面情感是悲伤——例如，没有愤怒。
- en: If you were designing a robot to have the personality of an annoying little
    boy (think Bart Simpson, Cartman, or Dennis the Menace if you are that old), what
    traits would it have?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你设计一个机器人，让它拥有一个讨厌的小男孩的性格（如果你足够老，想想巴特·辛普森、卡特曼或丹尼斯·麻烦），它会有哪些特点？
- en: A small boy would be mischievous, have a short attention span, constantly change
    the subject, keep trying to bring up the same topic over and over, and repeat
    variations of the same questions. How might we represent mischievous? Perhaps
    by ignoring directives and generating random events or distractions that get the
    robot’s attention away from the task at hand.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个小男孩可能会顽皮，注意力不集中，经常改变话题，不断试图重复同一个话题，并重复相同问题的变体。我们如何表示顽皮呢？或许是通过忽略指令，生成随机事件或干扰，让机器人将注意力从手头的任务上转移开。
- en: Why is it important for the robot to have a backstory or biography?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么机器人拥有背景故事或传记很重要？
- en: To provide consistent answers to personal questions, such as “How old are you?”
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了提供对个人问题的连贯答案，例如“你多大了？”
- en: For the following questions, pick a persona from my list to model (from *Integrating*
    *Artificial Personality*).
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于以下问题，从我的列表中挑选一个角色来模拟（来自《整合*人工智能*个性》）。
- en: Write six lines of dialogue for the robot to ask a human where they last went
    on vacation.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为机器人写六行对话，询问人类他们上次度假去了哪里。
- en: So, where did you go on vacation last?
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，你上次度假去了哪里？
- en: Summertime is coming up. Where did you go on vacation last year? Do you like
    to travel? Where have you been?
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 夏天即将来临。你去年去哪里度假了？你喜欢旅行吗？你去过哪里？
- en: I never get to go on vacation. Where did you go last?
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我从未去过度假。你上次去哪里了？
- en: I have heard of this concept called vacation. Where do you like to go? Have
    you been to the beach?
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我听说过这个叫做度假的概念。你喜欢去哪里？你去过海滩吗？
- en: Write six ways for the robot to express that it is tired and needs to recharge
    without sounding like a robot.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出六种方法，让机器人表达它感到疲倦并需要充电，同时听起来不像机器人。
- en: I’m tired – have you seen my recharger?
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我累了——你看到我的充电器了吗？
- en: Wow, it is getting late. I’ve been at this for a long time.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哇，时间不早了。我已经做这个很久了。
- en: Well, my battery is getting low. Must be about quitting time. I am starting
    to feel a bit run down.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哎，我的电池快没电了。应该是下班时间了。我开始感到有点疲惫。
- en: Well, look at the time! My battery needs attending to. I’m getting hungry in
    here. Can I go charge now?
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哎，看看时间！我的电池需要充电了。我这里开始饿了。我现在可以去充电吗？
- en: '[Chapter 10](B19846_10.xhtml#_idTextAnchor366)'
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第10章](B19846_10.xhtml#_idTextAnchor366)'
- en: Given that we started the chapter with knock-knock jokes and ended up talking
    about robot phobia and addressing philosophical questions about existence, do
    you feel that AI is a threat? Why or why not?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们以敲门笑话开始这一章，最后却讨论了机器人恐惧症，并探讨了关于存在的哲学问题，你感觉人工智能是一种威胁吗？为什么或为什么不呢？
- en: I do not feel that robots or AI are a threat in any way because the necessary
    and sufficient conditions for robots to be a threat do not exist, which is to
    say that the robots have to *want* to take over the world and must have a *need*
    to take over. Currently, robots and AI have no such wants or needs.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我不认为机器人或人工智能在任何方面都是一种威胁，因为机器人成为威胁的必要和充分条件不存在，也就是说，机器人必须*想要*统治世界，并且必须*需要*统治。目前，机器人和人工智能没有这样的欲望或需求。
- en: List any five professions that would be necessary to turn our Albert robot into
    a product.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出五个必要的职业，将我们的Albert机器人转变为产品。
- en: We would need project managers, packaging designers, advertising and marketing
    experts, salespeople, engineers, technicians, artists, package designers, machinists,
    electricians, accountants, lawyers, a psychologist, and support staff, among others.
    You can select any five from among these options.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要项目经理、包装设计师、广告和营销专家、销售人员、工程师、技术人员、艺术家、包装设计师、机械师、电工、会计师、律师、心理学家以及支持人员等。你可以从这些选项中选出任何五个。
- en: Why would we need a psychologist in our imaginary company that manufactures
    robots?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在我们的想象中制造机器人的公司需要心理学家？
- en: Psychologists study normal and abnormal mental states and cognitive processes,
    which is exactly what we are trying to simulate in an artificial personality.
    We want the robot to not trigger bad responses in people. I once had a robot with
    flashing red eyes that caused small children to have panic attacks. Psychologists
    would help avoid such errors.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 心理学家研究正常和异常的心理状态以及认知过程，这正是我们试图在人工个性中模拟的内容。我们希望机器人不会在人们身上引发不良反应。我曾经有一个眼睛闪烁着红色的机器人，这让小孩子产生了恐慌症。心理学家会帮助避免这样的错误。
- en: What components found in cell phones or smartphones are also found in quadcopters?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手机或智能手机中发现的哪些组件也出现在四旋翼飞行器中？
- en: GPS receivers, radios, Wi-Fi, Bluetooth, accelerometers, gyroscopes, and, these
    days, applications, or apps.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GPS接收器、收音机、Wi-Fi、蓝牙、加速度计、陀螺仪，以及如今的应用程序或应用。
- en: Why are artificial intelligence systems, specifically artificial neural networks,
    naturally non-deterministic in both result and time?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么人工智能系统，特别是人工神经网络，在结果和时间上都是自然非确定性的？
- en: They are universal approximation systems that work in probabilities and averages,
    not in discrete numbers and logic. Artificial neural networks can take a different
    amount of time because a particular bit of data may take different paths at different
    times, going through a different number of neurons and thus not taking the same
    amount of time to process. It is true that if you provide the exact same input
    to a neural network, it will give you the exact same answer every time. In the
    real world that robots live in, however, the case that two inputs are identical
    in every way can be very rare.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们是通用的近似系统，在概率和平均值上工作，而不是在离散数字和逻辑上。人工神经网络可以花费不同的时间，因为特定的数据可能在不同时间采取不同的路径，通过不同数量的神经元，因此处理所需的时间不同。确实，如果你向神经网络提供完全相同的输入，它每次都会给出完全相同的答案。然而，在机器人生活的现实世界中，两个输入在所有方面都完全相同的情况可能非常罕见。
- en: What might be a practical application of an AI system that made predictable
    mistakes?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个会犯可预测错误的AI系统的实际应用可能是什么？
- en: You can use a neural network-based system to model a bad human operator for
    a driving simulation to help teach other drivers (and self-driving cars) how to
    avoid bad drivers. The desired state is an unpredictable driver, so just train
    the neural network to 60% or so. Now the network will come up with the wrong answer
    40% of the time, i.e., be statistically predictable. I actually did this on a
    project for the Navy that wanted a simulation of imperfect people misusing a system
    at a predictable level, so they could create a responsive control system that
    could handle those mistakes.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用基于神经网络的系统来模拟一个糟糕的人类操作员进行驾驶模拟，以帮助其他驾驶员（和自动驾驶汽车）学习如何避免糟糕的驾驶员。理想状态是难以预测的驾驶员，所以只需训练神经网络到大约60%。现在，网络将有40%的时间给出错误的答案，即统计上可预测。我实际上在一个海军项目的这个项目上做了这件事，海军想要一个模拟不完美的人以可预测的水平误用系统的模拟，这样他们就可以创建一个能够处理这些错误的响应控制系统。
- en: If an AI system was picking stocks for you and predicted winning stock 43% of
    the time and you had a second AI system that was 80% accurate at determining when
    the first AI had *not* picked good stock, what percent of the time would the AI
    combination pick profitable stock?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个AI系统为你挑选股票，43%的时间预测股票是赢家，而你有一个第二个AI系统，它在确定第一个AI没有选择好股票时80%准确，那么AI组合在多少时间内会选择盈利的股票？
- en: We have 100 stocks picked by our AI program. Of that set, an indeterminate number
    are winners and losers. There is a 43% chance the stock is correctly predicted
    to be a winner and a 57% chance it is predictably a loser. We have no way of judging
    the stocks as being winners or losers except by investing our money, which is
    what we are trying to avoid – investing in bad stocks. A 43% chance of winning
    is not good.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有100只由我们的AI程序挑选的股票。在这个集合中，不确定的数量是赢家和输家。有43%的概率正确预测股票是赢家，有57%的概率它是有预测性的输家。我们没有其他方法来判断股票是赢家还是输家，除非投资我们的钱，这正是我们试图避免的——投资坏股票。43%的赢率并不好。
- en: The second AI has an 80% chance of telling you that the first AI chose bad stock.
    Eighty times out of 100, you will know that the stock was not a winner. You are
    left with an 80% chance of correctly identifying one of the 57 bad stocks, which
    eliminates 45 stocks. That leaves you with 55 stocks, of which 43 are winners
    (on average), which raises your odds to 78%.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个AI有80%的概率告诉你第一个AI选择了不好的股票。在100次中有80次，你会知道股票不是赢家。你剩下80%的概率正确地识别出57只坏股票中的一只，这消除了45只股票。这让你剩下55只股票，其中43只是赢家（平均而言），这提高了你的胜率到78%。
- en: 'Bayes'' theorem shows the combination of two independent probabilities (probability
    of *x* occurring given *c* has occurred):'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 贝叶斯定理显示了两个独立概率的组合（在发生c的情况下x发生的概率）：
- en: '*px* = probability of *x*, and *pc* = probability of *c*)'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*px* = x的概率，*pc* = c的概率）'
- en: '*p(x|c) = (px* pc) / (**px*pc)+(1-px)(1-pc)*'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*p(x|c) = (px* pc) / (**px*pc)+(1-px)(1-pc)*'
- en: Using this theorem, I recomputed the combined probabilities as 75.1%, so I’ll
    take either answer.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个定理，我重新计算了联合概率为75.1%，所以我会接受任何一个答案。
- en: Appendix
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: '**Robotic Operating System** (**ROS**) was a framework designed to enable the
    development of software for complex robots and was developed by a company called
    *Willow Garage*, specifically for the control of the PR2 robot. The PR2 was a
    human-sized robot with two **7-degree of freedom** (**7DOF**) arms and an entire
    array of sensors. Controlling this very complex robot required the interaction
    of a multitude of sensors, motors, and communications. The ROS framework allowed
    the development of robot components to be done independently. While not an operation
    system in the traditional sense of the word, it is a **Modular Open Source** **Architecture**
    (**MOSA**).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器人操作系统**（**ROS**）是一个旨在使复杂机器人软件的开发成为可能的框架，由一家名为*Willow Garage*的公司开发，专门用于控制PR2机器人。PR2是一个人形机器人，有两个**7自由度**（**7DOF**）的臂和一套完整的传感器。控制这个非常复杂的机器人需要众多传感器、电机和通信的交互。ROS框架允许独立开发机器人组件。虽然它不是一个传统意义上的操作系统，但它是一个**模块化开源架构**（**MOSA**）。'
- en: The primary tool of ROS is a robust *publish-subscribe* service that makes talking
    between processes — that is, **Inter-Process Communications** (**IPC**) — easy
    and flexible. It also standardized a lot of the interfaces between sensors, motors,
    and controls for robots.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ROS的主要工具是一个强大的**发布-订阅**服务，它使得进程间的通信——即**进程间通信**（**IPC**）——变得简单和灵活。它还标准化了机器人传感器、电机和控制之间的许多接口。
- en: We will be using ROS 2 throughout this book. ROS 2 is a new version of ROS.
    In this *Appendix*, we will discuss how to install ROS 2, use it to communicate,
    and briefly introduce some of the tools ROS provides. We will provide an in-depth
    introduction to ROS 2 and describe some of the hardware involved in the design
    of our toy-collecting robot, Albert. We will also cover some of the hardware referenced
    in the book when creating Albert as our example for this book. Albert V2, the
    robot in this second edition of this book, is my 30th or so robot design.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用ROS 2。ROS 2是ROS的新版本。在本*附录*中，我们将讨论如何安装ROS 2，使用它进行通信，并简要介绍ROS提供的一些工具。我们将深入介绍ROS
    2，并描述我们玩具收集机器人Albert设计中所涉及的硬件。我们还将介绍在创建Albert作为本书示例时，书中提到的部分硬件。本书第二版的机器人Albert
    V2，是我大约第30个机器人设计。
- en: 'The topics covered in the appendix include the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 附录中涵盖的主题包括以下内容：
- en: Introducing MOSA
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MOSA
- en: A brief overview of ROS 2
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要概述ROS 2
- en: Software requirements for the robot
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人软件需求
- en: Introducing the hardware for the robot
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍机器人的硬件
- en: Robot safety tips
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人安全提示
- en: Introducing MOSA
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MOSA
- en: ROS is an example of a MOSA. Why is this important? Imagine if every electrical
    appliance in your house had its own plug, a different voltage, and a different
    wire. It would make life very difficult for you. But all your electrical plugs
    are the same shape and put out the same voltage. They are standardized interfaces
    that allow you to plug many different types of appliances into them. A MOSA acts
    like that for software, standardizing interfaces and allowing *plug-and-play*
    compatibility.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ROS是一个MOSA的例子。为什么这很重要？想象一下，如果你的家里的每个电器都有自己的插头，不同的电压，不同的电线，那会给你生活带来很大的困难。但所有的电器插头形状相同，输出相同的电压。它们是标准化的接口，允许你将许多不同类型的电器插入其中。MOSA对软件来说就像这样，标准化接口，允许*即插即用*的兼容性。
- en: 'The following are its advantages:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其优势：
- en: A MOSA system architecture allows modularity – the ability to create software
    in sections or modules that can be developed, debugged, and operated independently.
    Before ROS, I created one major executable that ran everything on my robot. The
    problem with this is, first of all, that I could not take advantage of the multi-core
    nature of my **Single Board Computer** (**SBC**), which was the robot’s brain.
    I had all my code in one thread, in one program, and splitting out functions to
    run independently was difficult.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOSA系统架构允许模块化——即能够以部分或模块的形式创建软件，这些模块可以独立开发、调试和运行。在ROS之前，我创建了一个主要的可执行文件，它在我的机器人上运行所有功能。这个问题首先在于，我无法利用我的**单板计算机**（**SBC**）的多核特性，这是机器人的大脑。我所有的代码都在一个线程、一个程序中，将函数分割出来独立运行是困难的。
- en: Then there were the interactions. If I changed the timing on my motor driver,
    it messed up the sensor timing for the camera. If I changed the path planner,
    then the steering needed adjusting. This sort of interaction is typical in a **unitary
    architecture**. However, in a MOSA, each section of the robot, for example, the
    robot arm controller, is independent and runs in its own program. They can be
    developed and debugged independently, and interactions are limited to the interfaces
    we create in those programs. This frees us from a lot of problems we would otherwise
    have.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是交互。如果我改变了电机驱动器的时序，它就会搞乱摄像头的传感器时序。如果我改变了路径规划器，那么转向就需要调整。这种交互在 **单元架构** 中很典型。然而，在
    MOSA 中，机器人的每个部分，例如机器人手臂控制器，都是独立的，并运行在自己的程序中。它们可以独立开发和调试，交互仅限于我们在那些程序中创建的接口。这使我们摆脱了许多我们本会遇到的问题。
- en: The other feature we can take advantage of is the very large library of standard,
    already-created interfaces and programs that ROS provides. We don’t need to create
    a steering interface; ROS has one (the `Twist` command). We don’t need to create
    data types for camera imagery data; ROS has several to choose from. ROS also has
    USB camera drivers and viewers that we can use without writing any code at all.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用的另一个特性是 ROS 提供的非常庞大的标准、已创建的接口和程序库。我们不需要创建控制接口；ROS 已经有一个（`Twist` 命令）。我们也不需要为摄像头图像数据创建数据类型；ROS
    提供了多种选择。ROS 还提供了我们可以使用的 USB 摄像头驱动器和查看器，而无需编写任何代码。
- en: Now let’s talk a bit about how ROS 2 works.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简单谈谈 ROS 2 的工作原理。
- en: A brief overview of ROS 2
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 2 的简要概述
- en: As mentioned earlier, ROS 2 is the latest version of ROS, a widely used framework
    for developing robot applications. I’ve been using ROS for some time now and appreciate
    how much simpler it makes the integration of various components, sensors, and
    capabilities into my robots. I resisted moving to ROS for some time, but now that
    I have invested the time to learn what it can do, I can’t imagine developing a
    robot without it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ROS 2 是 ROS 的最新版本，ROS 是一个广泛使用的用于开发机器人应用的框架。我已经使用 ROS 一段时间了，并欣赏它如何使各种组件、传感器和功能集成到我的机器人中变得更加简单。我一度抵制转向
    ROS，但现在我已经投入时间学习它能做什么，我无法想象在没有它的帮助下开发机器人。
- en: In this section, we will discuss some concepts that are foundational for our
    understanding of ROS 2, how to install ROS 2, and some basic commands that we
    can use with it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些对我们理解 ROS 2 基础概念至关重要的概念，如何安装 ROS 2，以及我们可以与之一起使用的某些基本命令。
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please use whatever is the latest version of ROS 2.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用 ROS 2 的最新版本。
- en: Understanding the basic concepts
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基本概念
- en: 'ROS 2 works a bit differently than other programming paradigms. ROS is based
    on a publish/subscribe mechanism that allows different programs or processes to
    pass information from one to another without having to know in advance who is
    receiving the data. Let’s look at how this process works:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2 的工作方式与其他编程范式略有不同。ROS 基于发布/订阅机制，允许不同的程序或进程在事先不知道接收者是谁的情况下相互传递信息。让我们看看这个过程是如何工作的：
- en: Each program or code that communicates in ROS is called a **node**. Nodes each
    have names that uniquely identify them to the system.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ROS 中进行通信的每个程序或代码都称为 **节点**。每个节点都有自己的名称，该名称唯一地标识了它在系统中的身份。
- en: Nodes publish data on **topics**, which represent an interface for messages.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点在 **主题** 上发布数据，这些主题代表消息的接口。
- en: '**Messages** are interfaces that have data types (string, float, fixed, array,
    etc.).'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**是具有数据类型（字符串、浮点数、固定点、数组等）的接口。'
- en: For example, a joystick interface node publishes to the commanded velocity (`cmd_vel`)
    topic with a `Twist` message. On the receiver end of the message, the motor control
    interface subscribes to the `cmd_vel` topic to receive Twist messages that have
    speed and turn information for the robot.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个操纵杆接口节点通过 `Twist` 消息发布到命令速度 (`cmd_vel`) 主题。在消息的接收端，电机控制接口订阅 `cmd_vel` 主题以接收包含速度和转向信息的
    Twist 消息。
- en: Note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Why is it called a Twist message? The reason for using the term “twist” is conceptual.
    Think of a robot’s movement as a combination of straightforward (linear) motion
    and rotation (twisting or turning). By combining linear and angular velocities,
    a Twist message effectively describes how the robot “twists” through space, which
    includes both translation (moving from one place to another) and rotation (changing
    orientation).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么叫它“Twist”消息？使用“twist”这个术语的原因是概念性的。想象一下机器人的运动是直线（线性）运动和旋转（扭曲或转动）的组合。通过结合线性和角速度，Twist
    消息有效地描述了机器人如何在空间中“扭曲”，这包括平移（从一个地方移动到另一个地方）和旋转（改变方向）。
- en: 'ROS has a few other useful features:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 还有一些其他有用的特性：
- en: There is a systemwide `DEBUG`, `INFO`, `WARN`, `ERROR`, or `FATAL`. Log messages
    are automatically displayed on the local output (usually the command line). They
    are collected centrally, and you can parse through log messages to debug problems.
    Periodically, you do need to purge old log files, as they do tend to pile up.
    Logs are put into the `~/.``log` directory.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个系统级的 `DEBUG`、`INFO`、`WARN`、`ERROR` 或 `FATAL`。日志消息会自动显示在本地输出（通常是命令行）上。它们被集中收集，你可以解析日志消息来调试问题。定期，你确实需要清除旧日志文件，因为它们确实会堆积起来。日志被放入
    `~/.log` 目录中。
- en: One of my personal favorite features is **parameters**. These are external data
    values that can be created independently of source code and can be used to turn
    features on or off, or to set critical settings, such as image size, resolution,
    range, and other features. The ability to have external parameters goes a long
    way to make ROS portable and the interfaces reusable. Parameters can be specified
    in launch files, which are ways of starting multiple programs (nodes) all at once.
    Albert has five major subsystems (control, motor drive, arm control, vision, and
    speech), all of which have to be started together.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我个人最喜欢的一个特性是 **参数**。这些是独立于源代码创建的外部数据值，可以用来开启或关闭功能，或者设置关键设置，例如图像大小、分辨率、范围和其他功能。拥有外部参数的能力在很大程度上使得
    ROS 可移植并且接口可重用。参数可以在启动文件中指定，这是一种同时启动多个程序（节点）的方法。Albert 有五个主要子系统（控制、电机驱动、手臂控制、视觉和语音），所有这些子系统都必须一起启动。
- en: Comparing ROS 2 and ROS
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 ROS 2 和 ROS
- en: 'ROS 2 introduced some very significant improvements over the original ROS.
    Some of them are as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2 在原始 ROS 的基础上引入了一些非常显著的改进。其中一些如下：
- en: The most notable improvement is the absence of the **roscore** *traffic cop*
    application. This central program acted as the Master node in any ROS implementation
    and directed the other nodes on where to communicate via sockets. It directed
    all the traffic on the network. Therefore, every node had to communicate with
    roscore to know where it was running. If roscore died, or was turned off, then
    the entire ROS set of applications stopped. Instead, ROS 2 uses **Data Distribution
    Services** (**DDS**) as its *middleware layer*. DDS is a standard for high-performance,
    scalable, and real-time data exchange, created by the **Object Management Group**
    (**OMG**) and managed by the DDS Foundation. It provides a decentralized discovery
    mechanism for nodes to find each other without needing a central master such as
    roscore. When a node starts, it advertises its presence to other nodes and also
    discovers existing nodes and topics. This process is managed by the underlying
    DDS implementation.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最显著的改进是 **roscore** *交通警察* 应用程序的缺失。这个中央程序在任何 ROS 实现中充当主节点，并指导其他节点通过套接字进行通信。它指导网络上的所有流量。因此，每个节点都必须与
    roscore 通信以了解其运行位置。如果 roscore 死亡或被关闭，那么整个 ROS 应用程序集都将停止。相反，ROS 2 使用 **数据分发服务**（**DDS**）作为其
    *中间件层*。DDS 是一个由 **对象管理组**（**OMG**）创建并由 DDS 基金会管理的用于高性能、可扩展和实时数据交换的标准。它为节点提供了一个去中心化的发现机制，以便它们可以找到彼此，而无需一个像
    roscore 这样的中央主节点。当一个节点启动时，它会向其他节点宣布其存在，并发现现有的节点和主题。这个过程由底层的 DDS 实现管理。
- en: ROS 2 has more features for **real-time processing**, and does not have the
    weird workaround that ROS had, where we had to do things such as post-dating messages
    into the future. These features include using DDS (which is intended for real-time
    systems, the ability to work with **real-time operating systems** (**RTOSs**),
    and to use pre-emption to control processes.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 2 具有更多针对 **实时处理** 的功能，并且没有 ROS 那样的奇怪解决方案，例如将消息向后推迟到未来。这些功能包括使用 DDS（旨在用于实时系统，能够与
    **实时操作系统**（**RTOSs**）协同工作，并使用抢占来控制进程）。
- en: One big improvement is that ROS 2 will **run natively on Windows** for the first
    time. You don’t need virtual machines to run ROS on Windows – you can build your
    own control panels and interfaces directly in Windows.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重大改进是ROS 2将首次**原生运行在Windows上**。你不需要虚拟机就可以在Windows上运行ROS - 你可以直接在Windows中构建自己的控制面板和界面。
- en: ROS 2 also improves **discovery** (the process of finding nodes on the network)
    and has some enhancements for cyber security.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 2还改进了**发现**（在网络中查找节点的过程）并有一些针对网络安全的增强。
- en: So, all in all, ROS 2 was well worth taking the time to upgrade, and I feel
    that it is far less fiddly than the old ROS, easier to set up on both Windows
    and Linux, and easier to manage.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，ROS 2值得花时间升级，我感觉它比旧的ROS更简单，更容易在Windows和Linux上设置，也更容易管理。
- en: Let’s look at software requirements next.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看软件需求。
- en: Software requirements for the robot
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人的软件需求
- en: In this section, we will discuss the software requirements for the robot and
    how to install them on the robot’s CPU.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论机器人的软件需求以及如何在机器人的CPU上安装它们。
- en: Installing ROS 2
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装ROS 2
- en: The version of ROS 2 I installed on Albert currently is *Foxy*. Please feel
    free to use the latest version of ROS 2\. Jetson tends to run behind Ubuntu upgrades
    and is several releases behind. We use the Jetson Nano because it has the required
    power and the **Graphics Processing Units** (**GPUs**) to run neural network software.
    My version of the Nano is running Ubuntu 20.04, but you should also be able to
    get it working with Ubuntu version 18.04.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Albert上安装的ROS 2版本是*Foxy*。请随意使用ROS 2的最新版本。Jetson通常落后于Ubuntu升级，并且落后几个版本。我们使用Jetson
    Nano是因为它具有运行神经网络软件所需的**图形处理单元**（**GPU**）。我的Nano版本正在运行Ubuntu 20.04，但你也应该能够使用Ubuntu版本18.04使其工作。
- en: I used the standard ROS 2 installation script that can be found at [https://github.com/jetsonhacks/installROS2](https://github.com/jetsonhacks/installROS2).
    This is a script that contains all of the steps found on the regular ROS 2 installation
    page at [https://docs.ros.org/en/foxy/Installation/Alternatives/Ubuntu-Development-Setup.html](https://docs.ros.org/en/foxy/Installation/Alternatives/Ubuntu-Development-Setup.html).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了可以在[https://github.com/jetsonhacks/installROS2](https://github.com/jetsonhacks/installROS2)找到的标准ROS
    2安装脚本。这是一个包含在常规ROS 2安装页面[https://docs.ros.org/en/foxy/Installation/Alternatives/Ubuntu-Development-Setup.html](https://docs.ros.org/en/foxy/Installation/Alternatives/Ubuntu-Development-Setup.html)上找到的所有步骤的脚本。
- en: Note that we are doing an *Install from Source* setup since many of the programs
    need to be recompiled to run on the Jetson Nano’s ARM-based architecture. For
    me, this process took about 4 hours, so it does take some patience.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在进行一个*从源安装*的设置，因为许多程序需要重新编译才能在Jetson Nano的ARM架构上运行。对我来说，这个过程大约需要4个小时，所以需要一些耐心。
- en: Installing other packages
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装其他包
- en: 'You will also need to install the following Python packages: **Scientific Python**
    (**SciPy**), **Numeric Python** (**NumPy**), **scikit-learn**, **Open Computer
    Vision** (**OpenCV**), and **PyTorch**. Let’s look at the commands needed to install
    these packages:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装以下Python包：**科学Python**（**SciPy**）、**数值Python**（**NumPy**）、**scikit-learn**、**开放计算机视觉**（**OpenCV**）和**PyTorch**。让我们看看安装这些包所需的命令：
- en: 'SciPy:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SciPy:'
- en: '[PRE1]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'NumPy:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NumPy:'
- en: '[PRE2]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'scikit-learn:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'scikit-learn:'
- en: '[PRE3]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'OpenCV:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenCV:'
- en: '[PRE4]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more details on OpenCV, you can refer to [https://docs.opencv.org/3.4/d6/d00/tutorial_py_root.html](https://docs.opencv.org/3.4/d6/d00/tutorial_py_root.html)
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于OpenCV的更多详细信息，你可以参考[https://docs.opencv.org/3.4/d6/d00/tutorial_py_root.html](https://docs.opencv.org/3.4/d6/d00/tutorial_py_root.html)
- en: 'PyTorch:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PyTorch:'
- en: '[PRE5]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let’s look at how we can get started with ROS 2.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何开始使用ROS 2。
- en: Basic ROS 2 commands
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本ROS 2命令
- en: 'The following commands relate to starting, controlling, and monitoring nodes
    in ROS 2:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令与在ROS 2中启动、控制和监控节点相关：
- en: 'To start executing a package in ROS 2, use the following command:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在ROS 2中启动执行一个包，请使用以下命令：
- en: '[PRE6]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To check that this node is running, we type the following:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查这个节点是否正在运行，我们输入以下命令：
- en: '[PRE7]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives us a list of currently running nodes:'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将列出当前正在运行的节点列表：
- en: '[PRE8]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can get more information about the node by typing this command:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令来获取更多关于节点的信息：
- en: '[PRE9]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This results in the following:'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE10]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we can note the following key points:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以注意以下关键点：
- en: The `turtlesim` publishes `parameter_events` (which happen when you change parameter
    values), it has a logging interface to `/rosout`, and it publishes the color of
    the turtle robot and its position (pose)
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`turtlesim` 发布 `parameter_events`（当更改参数值时发生），它有一个到 `/rosout` 的日志接口，并发布海龟机器人的颜色及其位置（姿态）'
- en: For input, it subscribes to `cmd_vel`, which uses the `Twist` command to move
    the turtle, and to `parameter_events`, which allows the program to receive parameter
    changes
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入，它订阅 `cmd_vel`，使用 `Twist` 命令移动海龟，并订阅 `parameter_events`，允许程序接收参数更改
- en: 'The command for looking at topics is as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 查看主题的命令如下：
- en: '[PRE11]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This shows topics that are active. For our `turtlesim` example, we get the
    following output:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了活动的主题。对于我们的 `turtlesim` 示例，我们得到以下输出：
- en: '[PRE12]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you add `-t` to the end of that command, you also get the topic message
    type:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在该命令末尾添加 `-t`，你还可以获得主题消息类型：
- en: '[PRE13]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can find more details and the full tutorial at [https://ros2-industrial-workshop.readthedocs.io/en/latest/_source/navigation/ROS2-Turtlebot.html](https://ros2-industrial-workshop.readthedocs.io/en/latest/_source/navigation/ROS2-Turtlebot.html).
    Also, I recommend that you refer to the topic list in the tutorials available
    from the ROS 2 website: [https://docs.ros.org/en/foxy/Tutorials.html](https://docs.ros.org/en/foxy/Tutorials.html).
    This will give a more robust introduction to ROS 2\. The rest of what you need
    to run the programs in this book is in the text.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://ros2-industrial-workshop.readthedocs.io/en/latest/_source/navigation/ROS2-Turtlebot.html](https://ros2-industrial-workshop.readthedocs.io/en/latest/_source/navigation/ROS2-Turtlebot.html)
    找到更多细节和完整教程。此外，我建议你参考ROS 2网站提供的教程中的主题列表：[https://docs.ros.org/en/foxy/Tutorials.html](https://docs.ros.org/en/foxy/Tutorials.html)。这将为你提供一个更全面的ROS
    2介绍。本书中运行程序所需的其他内容将在文本中提供。
- en: Now, let’s look at the hardware that makes up Albert the Robot.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构成阿尔伯特机器人的硬件。
- en: Introducing the hardware for the robot
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍机器人的硬件
- en: 'I designed Albert the Robot to perform one manual task – picking up toys. As
    such, I chose a set of motors, a speaker, and a robot arm as effectors, and a
    camera and microphone as sensors. Here is a labeled diagram of what Albert looks
    like:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我设计了阿尔伯特机器人来执行一项手动任务 – 拿起玩具。因此，我选择了一套电机、一个扬声器和机械臂作为效能部件，以及一个摄像头和麦克风作为传感器。以下是阿尔伯特的外观图示：
- en: '![Figure 12.1 – Albert the Robot](img/B19846_12_1.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 阿尔伯特机器人](img/B19846_12_1.jpg)'
- en: Figure 12.1 – Albert the Robot
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 阿尔伯特机器人
- en: In the following sections, we will look at how I put Albert together.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨我是如何组装阿尔伯特的。
- en: Effectors – base, motors, and wheels
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效能部件 – 基座、电机和轮子
- en: The robot base is a two-layer aluminum allow frame that I purchased at [https://www.amazon.com/gp/product/B093WDD9N5](https://www.amazon.com/gp/product/B093WDD9N5).
    This base uses **Mecanum** wheels, which have the unique ability to move the chassis
    not just forward and back, but sideways and at any angle. For video game fans,
    this sideways movement is sometimes called **strafing**. You will note that the
    wheels have smaller rollers mounted at 45-degree angles. These convert various
    inputs into multiple directions. Moving all four motors forward, not surprisingly,
    results in the platform moving forward. Moving the right wheels forward and the
    left wheels backward results in turning in place to the right.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人基座是一个两层铝合金框架，我在 [https://www.amazon.com/gp/product/B093WDD9N5](https://www.amazon.com/gp/product/B093WDD9N5)
    购买了这个基座。这个基座使用 **Mecanum** 轮子，它们具有独特的功能，不仅可以向前和向后移动底盘，还可以向侧面和任何角度移动。对于游戏玩家来说，这种侧向移动有时被称为
    **侧滑**。你会注意到轮子上安装了45度角的小滚轮。这些将各种输入转换为多个方向。将所有四个电机向前移动，不出所料，平台就会向前移动。将右轮向前移动，左轮向后移动，就会原地向右转动。
- en: When we move the left wheels away from each other and the right wheels towards
    each other (left front forward, right front backward, left rear backward, and
    right rear forward), the vehicle moves sideways – strafes – to the right. Reverse
    these directions and you strafe to the left. These are the motions we need to
    complete the exercises in the book.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将左轮相互远离，右轮相互靠近时（左前轮向前，右前轮向后，左后轮向后，右后轮向前），车辆就会向侧面 – 侧滑 – 向右移动。反转这些方向，你就可以向左侧滑。这些是我们完成书中练习所需完成的活动。
- en: 'I made some modifications to the base: I cut off the little white connectors
    to the four motors so I could wire them to the motor controller.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我对基座进行了一些修改：我切掉了连接到四个电机的白色小连接器，以便我可以将它们连接到电机控制器。
- en: Battery
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电池
- en: 'I have used a 4,200 mAh **Nickel Metal Hydride** (**NiMH**) battery– no lithium
    battery here, so there’s less risk of fire. The output is 7.2 V. This should provide
    several hours of runtime to our robot, and it fits in the chassis. You can use
    any drone-type battery with the same specs. A larger battery won’t fit in the
    chassis, which is quite small. This battery is adequate for our needs. Here is
    an example of a battery you can get for your robot: [https://www.amazon.com/gp/product/B08KXYY53G](https://www.amazon.com/gp/product/B08KXYY53G).'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一块4200mAh的**镍氢电池**（**NiMH**）——这里没有锂电池，所以火灾风险更小。输出电压为7.2V。这应该能为我们的机器人提供数小时的运行时间，并且它可以安装在底盘上。你可以使用任何具有相同规格的无人机电池。更大的电池无法安装在底盘上，因为底盘相当小。这块电池完全符合我们的需求。以下是你可以为你的机器人购买的电池示例：[https://www.amazon.com/gp/product/B08KXYY53G](https://www.amazon.com/gp/product/B08KXYY53G)。
- en: DC/DC power supply
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DC/DC电源供应
- en: 'One of my favorite bits of kit is this DROK DC/DC adjustable power supply.
    This board provides the 5 V power to the main computer and the Arduino. You adjust
    the voltage level to 5 V with a small screwdriver. I really like to have this
    display on the robot to show that everything is working. Here is a link to the
    one I used: [https://www.amazon.com/Converter-DROK-Adjustable-Stabilizer-Protective/dp/B01FQH4M82?th=1](https://www.amazon.com/Converter-DROK-Adjustable-Stabilizer-Protective/dp/B01FQH4M82?th=1).'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的配件之一是这款DROK DC/DC可调电源。这块板子为主计算机和Arduino提供5V电源。你可以用一个小螺丝刀调整电压到5V。我真的很喜欢在机器人上显示这个，以表明一切正常。这是我使用的链接：[https://www.amazon.com/Converter-DROK-Adjustable-Stabilizer-Protective/dp/B01FQH4M82?th=1](https://www.amazon.com/Converter-DROK-Adjustable-Stabilizer-Protective/dp/B01FQH4M82?th=1)。
- en: CPU – the brains of the outfit
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU - 设备的大脑
- en: 'As we’ve mentioned throughout the book, the main computer for Albert is the
    **Nvidia Jetson Nano**. This is a rugged little single-board computer with a big
    heat sink. This CPU is specifically designed to run AI code, with 128 **graphics
    processing units** (**GPUs**) and four Arm A57 **central processing units** (**CPUs**)
    running at 1.43 GHz, and packed with peripheral ports and external I/O capability.
    This is an ideal board for our needs for running a robot with perception and decision-making
    abilities. The Jetson sits on a development board, which provides an interface
    to all of its capabilities. Any of the other members of the Jetson family (TX2,
    Xavier, and AGX) will also work, but I’ve sized the code in the book to fit on
    the Nano specifically. This is a link to purchase the Jetson Nano computer: [https://developer.nvidia.com/embedded/jetson-nano-developer-kit](https://developer.nvidia.com/embedded/jetson-nano-developer-kit).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中提到的，阿尔伯特的主要计算机是**Nvidia Jetson Nano**。这是一款坚固的小型单板计算机，带有大散热片。这款CPU专门设计用于运行AI代码，拥有128个**图形处理单元**（**GPUs**）和四个运行在1.43
    GHz的Arm A57 **中央处理单元**（**CPUs**），并配备了外围端口和外部I/O功能。这是一块非常适合我们运行具有感知和决策能力的机器人的板子。Jetson安装在开发板上，它提供了对其所有功能的接口。Jetson家族中的任何其他成员（TX2、Xavier和AGX）也可以使用，但我将书中代码的大小调整到了Nano上。这是购买Jetson
    Nano计算机的链接：[https://developer.nvidia.com/embedded/jetson-nano-developer-kit](https://developer.nvidia.com/embedded/jetson-nano-developer-kit)。
- en: 'I’ve added a Wi-Fi card, which is mounted underneath the CPU. This is the one
    I used: [https://www.amazon.com/gp/product/B07SGDRG34](https://www.amazon.com/gp/product/B07SGDRG34).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经添加了一张Wi-Fi网卡，它安装在CPU下方。这是我使用的这张：[https://www.amazon.com/gp/product/B07SGDRG34](https://www.amazon.com/gp/product/B07SGDRG34)。
- en: Effectors – robot arm
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行器 - 机器人手臂
- en: 'I can’t say enough about how much of an upgrade the digital servo arm used
    in this book ([https://www.hiwonder.com.cn/store/learn/42.html](https://www.hiwonder.com.cn/store/learn/42.html))
    is over the previous analog servo arm I used in the first edition of the book.
    Some of the advantages of this arm are as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法过多地称赞这本书中使用的数字伺服手臂（[https://www.hiwonder.com.cn/store/learn/42.html](https://www.hiwonder.com.cn/store/learn/42.html)）相较于我在第一版书中使用的先前模拟伺服手臂的升级有多大。这款手臂的一些优点如下：
- en: This arm uses **digital servos**, and this simplifies the wiring of the arm,
    since we just plug one servo into the next in a series. Rather than being controlled
    by analog signals, these servos have a digital serial interface that gives us
    not just fine control, but the ability to determine where the motors actually
    are, rather than where they were commanded to be. Why is this important? If the
    arm hits something and can’t continue to move, it will stop. This is not a surprise,
    but then when you ask for the motor position, it tells you where it stopped. This
    means you can use the arm itself as a sensor! To determine where the floor is,
    you command the arm to a downward position, let it stop when it hits the floor,
    and read the motor positions to see where the floor actually is relative to the
    arm.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个机械臂使用**数字伺服电机**，这简化了机械臂的布线，因为我们只需将一个伺服电机插入到下一个串联的伺服电机中。这些伺服电机不是由模拟信号控制，而是具有数字串行接口，它不仅提供了精细的控制，而且能够确定电机实际的位置，而不仅仅是它们被命令到的位置。这为什么很重要？如果机械臂碰到东西而无法继续移动，它将停止。这不是一个惊喜，但当你要求电机位置时，它会告诉你它停止的位置。这意味着你可以使用机械臂本身作为传感器！为了确定地板的位置，你命令机械臂向下移动，当它碰到地板时停止，然后读取电机位置以查看地板相对于机械臂的实际位置。
- en: This arm also lets you move the arm manually – with your hands – and then read
    the position of the arm, which is very useful when designing poses.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个机械臂还允许你手动移动机械臂——用你的手——然后读取机械臂的位置，这在设计姿态时非常有用。
- en: Another useful feature is the **self-programming mode**. You can put the arm
    in *program* mode using the relevant button, then move the arm and push the other
    button (labeled *run*), and the program moves into the arm without the computer.
    Then you can push *program* again to store these moves, and then hit *run* and
    it will play back what you did. This is useful for testing out moves. I used it
    to prototype grasping positions for picking up toys.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个有用的功能是**自编程模式**。你可以使用相关按钮将机械臂置于**程序**模式，然后移动机械臂并按下另一个按钮（标记为**运行**），程序就会进入机械臂而无需电脑。然后你可以再次按下**程序**来存储这些动作，然后按下**运行**，它将回放你所做的一切。这对于测试动作非常有用。我使用它来原型化抓取玩具的位置。
- en: If you would like to control a simulated robot arm instead of a real one, there
    is a tutorial at [https://community.arm.com/arm-research/b/articles/posts/do-you-want-to-build-a-robot](https://community.arm.com/arm-research/b/articles/posts/do-you-want-to-build-a-robot).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要控制一个模拟的机械臂而不是真实的机械臂，可以在[https://community.arm.com/arm-research/b/articles/posts/do-you-want-to-build-a-robot](https://community.arm.com/arm-research/b/articles/posts/do-you-want-to-build-a-robot)找到教程。
- en: Arm controller
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机械臂控制器
- en: There is an important note on wiring up the arm – the arm draws far more electrical
    power than the USB is capable of supporting. Do *not* run the arm without a power
    supply connected to the power port. The arm will run with the power straight from
    the battery, without using the DC/DC converter. I added a master power switch
    to the robot so I can turn it on and off safely. Without the power switch, the
    only way to shut down the robot is by physically unplugging the battery, which
    is problematic.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接机械臂的注意事项中非常重要——机械臂消耗的电力远超过USB所能支持的。**不要**在没有连接到电源端口电源的情况下运行机械臂。机械臂可以直接从电池获取电力运行，而不使用DC/DC转换器。我在机器人上添加了一个主电源开关，这样我可以安全地打开和关闭它。如果没有电源开关，唯一关闭机器人的方法就是物理上拔掉电池，这很麻烦。
- en: Arduino microcontroller and motor controller
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino 微控制器和电机控制器
- en: 'The Arduino UNO is integrated into the motor controller, which is plugged into
    the Arduino’s **General Purpose Input/Output** (**GPIO**) ports. This is the simplest
    way to create a computer interface to the four motors that drive the base of the
    robot. The motor controller has to have power from the batteries (again without
    going through the DC/DC converter). The Arduino uses **Pulse Width Modulation**
    (**PWM**) to control the four brushed DC motors in the drive base. The motor controller
    is from Adafruit, and is available at this website: [https://www.adafruit.com/product/1438](https://www.adafruit.com/product/1438).'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino UNO集成在电机控制器中，该控制器插在Arduino的**通用输入/输出**（**GPIO**）端口上。这是创建与驱动机器人底座的四个电机计算机接口的最简单方法。电机控制器必须从电池获取电力（同样不经过DC/DC转换器）。Arduino使用**脉冲宽度调制**（**PWM**）来控制驱动底座的四个刷式直流电机。电机控制器来自Adafruit，可在以下网站找到：[https://www.adafruit.com/product/1438](https://www.adafruit.com/product/1438)。
- en: Sensor – USB camera
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传感器 - USB 摄像头
- en: The main sensor of Albert is the wide **field-of-view** (**FOV**) camera that
    has a USB interface. Any number of cameras will fill this need, including many
    webcams. My camera has a 170-degree FOV and a resolution of 1,024x768 pixels.
    You can use a camera with higher resolution but make the USB ROS camera driver
    downsample the image to 1,024x768 so that we know that the rest of the software
    can handle the bandwidth. I used a color camera with an RGB (three-color) output.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Albert 的主要传感器是具有 USB 接口的宽 **视场**（**FOV**）相机。任何数量的相机都可以满足这一需求，包括许多网络摄像头。我的相机具有
    170 度的视场和 1,024x768 像素的分辨率。你可以使用分辨率更高的相机，但请确保 USB ROS 相机驱动程序将图像下采样到 1,024x768，这样我们就可以知道其余的软件可以处理带宽。我使用了一个具有
    RGB（三种颜色）输出的彩色相机。
- en: Sensor and effector – audio interface
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传感器和执行器 – 音频接口
- en: I bought a USB audio card ([https://www.amazon.com/gp/product/B08R95XJW8](https://www.amazon.com/gp/product/B08R95XJW8))
    to support the voice input and output on the robot. This audio interface has both
    a microphone and some small speakers. This unit makes our interface to the voice
    interface for speech recognition and text-to-speech output. This unit is well
    constructed and sturdy and it does a good job with music as well.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我购买了一张 USB 音频卡（[https://www.amazon.com/gp/product/B08R95XJW8](https://www.amazon.com/gp/product/B08R95XJW8)）来支持机器人的语音输入和输出。这个音频接口有一个麦克风和一些小型扬声器。这个单元使我们能够与语音接口进行语音识别和文本到语音输出的接口。这个单元结构坚固，而且音乐播放效果也很好。
- en: 'Here is a handy wiring diagram of how Albert goes together:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Albert 组装的一个实用的接线图：
- en: '![Figure 12.2 – Block wiring diagram of Albert the Robot](img/B19846_12_2.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – Albert 机器人的模块化接线图](img/B19846_12_2.jpg)'
- en: Figure 12.2 – Block wiring diagram of Albert the Robot
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – Albert 机器人的模块化接线图
- en: Now that we have Albert the Robot assembled, we can use it for the examples
    in the book. Albert’s a very versatile platform with a lot of capability, as you
    will see.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经组装好了 Albert 机器人，我们可以用它来演示书中的例子。Albert 是一个非常通用的平台，功能强大，你很快就会看到。
- en: Robot safety tips
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人安全提示
- en: 'Let’s quickly look at some safety tips related to working around robots:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下与机器人操作相关的安全提示：
- en: We are using fairly high-current batteries and drive systems. Be very careful
    with wiring and look out for shorts, where the positive and negative wires are
    touching. It is not a bad idea to put a fuse between the battery and the power
    supply of about 10 Amps to protect against accidental shorts.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的是相当高电流的电池和驱动系统。请务必小心接线，并注意短路，即正负电线接触的地方。在电池和电源之间放置一个大约 10 安培的保险丝以防止意外短路是个不错的主意。
- en: Be careful when the robot is operating. It may suddenly change direction or
    get stuck. I have a policy of not sitting down, having my hands in my pockets,
    or using a cell phone when the robot’s motor drives are activated. You need to
    be paying attention.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当机器人运行时，要小心。它可能会突然改变方向或卡住。我有一个政策，当机器人的电机驱动器激活时，我不会坐下、把手放在口袋里或使用手机。你需要保持注意力集中。
- en: Beware of the pinch points in the robot arm – you can get a finger caught in
    them quite easily (as I have learned). Don’t put your fingers inside the joints
    with the power turned on.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意机器人手臂中的夹紧点——你很容易将手指夹在其中（正如我所学到的）。不要在电源开启时将手指放入关节中。
- en: Have a checklist for setting up the robot, starting all the software, and turning
    on the hardware. This will stop you worrying that you have forgotten a step.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置机器人、启动所有软件和打开硬件时，请有一个清单。这将防止你担心遗漏了某个步骤。
- en: In general, here are the steps you should be following. Turn on the robot’s
    power. Wait for the computer to boot up. Connect to the onboard computer from
    your laptop or desktop using **Virtual Network Computing** (**VNC**). Start the
    onboard software, and then start giving commands.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，你应该遵循以下步骤。打开机器人的电源。等待计算机启动。使用 **虚拟网络计算**（**VNC**）从你的笔记本电脑或台式机连接到机载计算机。启动机载软件，然后开始发送命令。
- en: Beware when charging lithium batteries; they can catch fire. It is best to charge
    them inside a metal box. I used NiCad batteries in my Albert prototype for this
    reason – no fire hazard. Lithium batteries are lighter and stronger, but they
    have their downsides as well, such as catching fire, being a hazardous chemical,
    and permanently losing charge when frozen.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在充电锂离子电池时要小心；它们可能会起火。最好在金属箱内充电。我之所以在 Albert 原型中使用 NiCad 电池，就是这个原因——没有火灾隐患。锂离子电池更轻、更强，但它们也有自己的缺点，比如起火、成为危险化学物质以及冻结时永久失去电荷。
