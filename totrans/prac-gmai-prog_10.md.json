["```py\nvoid OnTriggerEnter (Collider other) {\n\n if(other.gameObject.tag == \"Player\")\n {\n Debug.Log(\"Player Detected\");\n } } \n```", "```py\n public GameObject rabbit;\n public Transform startPosition;\n public bool isOut;\n\n void Start ()\n {\n isOut = false;\n }\n void OnTriggerEnter (Collider other)\n {\n\n if(other.gameObject.tag == \"Player\" && isOut == false)\n {\n isOut = true;\n Instantiate(rabbit, startPosition.position,\n startPosition.rotation);\n }\n }\n```", "```py\nvoid OnTriggerStay (Collider other) {\n\n if(other.gameObject.tag == \"Player\")\n {\n Debug.Log(\"I can see the player\");\n }\n } \n```", "```py\nvoid OnTriggerStay (Collider other) {\n\n if(other.gameObject.tag == \"Player\")\n {\n Debug.Log(\"I can see the player\");\n }\n }\n\n void OnTriggerExit (Collider other){\n\n if(other.gameObject.tag == \"Player\")\n {\n Debug.Log(\"I've lost the player\");\n }\n } \n```", "```py\nvoid OnTriggerEnter (Collider other) {\n\n if(other.gameObject.tag == \"Player\")\n {\n Debug.Log(\"I can see the player\");\n }\n }\n\n void OnTriggerStay (Collider other){\n\n if(other.gameObject.tag == \"Player\")\n {\n Debug.Log(\"I can see the player\");\n }\n }\n\n void OnTriggerExit (Collider other){\n\n if(other.gameObject.tag == \"Player\")\n {\n Debug.Log(\"I've lost the player\");\n }\n } \n```", "```py\n public float moveSpeed = 6;\n\n Rigidbody myRigidbody;\n Camera viewCamera;\n Vector3 velocity;\n\n void Start ()\n{\n myRigidbody = GetComponent<Rigidbody> ();\n viewCamera = Camera.main;\n }\n\n void Update ()\n{\n Vector3 mousePos = viewCamera.ScreenToWorldPoint(new\n     Vector3(Input.mousePosition.x, Input.mousePosition.y,\n     viewCamera.transform.position.y));\n transform.LookAt (mousePos + Vector3.up * transform.position.y);\n velocity = new Vector3 (Input.GetAxisRaw (\"Horizontal\"), 0,\n     Input.GetAxisRaw (\"Vertical\")).normalized * moveSpeed;\n }\n\n void FixedUpdate()\n{\n myRigidbody.MovePosition (myRigidbody.position + velocity *\n Time.fixedDeltaTime);\n}\n```", "```py\npublic float viewRadius;\n public float viewAngle; public Vector3 DirFromAngle(float \n    angleInDegrees) \n{\n } \n```", "```py\n public float viewRadius;\n public float viewAngle; public Vector3 DirFromAngle(float\n    angleInDegrees)\n { \n   return new Vector3(Mathf.Sin(angleInDegrees *\n   Mathf.Deg2Rad), 0,\n   Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));\n } \n```", "```py\n using UnityEngine;\n using System.Collections;\n using UnityEditor; \n```", "```py\n using UnityEngine;\n using System.Collections;\n using UnityEditor;\n\n [CustomEditor (typeof (FieldOfView))] \n```", "```py\n using UnityEngine;\n using System.Collections;\n using UnityEditor;\n\n [CustomEditor (typeof (FieldOfView))]\n public class FieldOfViewEditor : Editor{\n\n void OnSceneGUI(){\n FieldOfView fow = (FieldOfView)target; } } \n```", "```py\n using UnityEngine;\n using System.Collections;\n using UnityEditor;\n\n [CustomEditor (typeof (FieldOfView))]\n public class FieldOfViewEditor : Editor{\n\n void OnSceneGUI(){\n FieldOfView fow = (FieldOfView)target; Handles.color = color.white; } } \n```", "```py\n using UnityEngine;\n using System.Collections;\n using UnityEditor;\n\n [CustomEditor (typeof (FieldOfView))]\n public class FieldOfViewEditor : Editor{\n\n void OnSceneGUI(){\n FieldOfView fow = (FieldOfView)target; Handles.color = color.white;\n Handles.DrawWireArc (fow.transform.position, Vector3.up,\n Vector3.forward, 360, fow.viewRadius); } } \n```", "```py\npublic float viewRadius;\n[Range(0,360)]\npublic float viewAngle;\npublic Vector3 DirFromAngle(float angleInDegrees, bool angleIsGlobal)\n { \n  if(!angleIsGlobal)\n { \n  angleInDegrees += transform.eulerAngles.y;\n }\n  return new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0,\n  Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));\n } \n```", "```py\n using UnityEngine;\n using System.Collections;\n using UnityEditor;\n\n [CustomEditor (typeof (FieldOfView))]\n public class FieldOfViewEditor : Editor\n{\n void OnSceneGUI()\n {\n  FieldOfView fow = (FieldOfView)target;\n  Handles.color = color.white;\n  Handles.DrawWireArc (fow.transform.position, Vector3.up,\n  Vector3.forward, 360, fow.viewRadius);\n  Vector3 viewAngleA =\n  fow.DirFromAngle(-fow.viewAngle/2, false);\n  Handles.DrawLine(fow.transform.position, fow.transform.position +\n  viewAngleA * fow.viewRadius);\n  Handles.DrawLine(fow.transform.position,\n  fow.transform.position +\n  viewAngleB * fow.viewRadius);\n }\n } \n```", "```py\npublic float viewRadius;\n[Range(0,360)]\npublic float viewAngle;\npublic LayerMask targetMask;\npublic LayerMask obstacleMask;\npublic List<Transform> visibleTargets = new List<Transform>();\nvoid FindVisibleTargets ()\n {\n  visibleTargets.Clear ();\n  Collider[] targetInViewRadius =\n  Physics.OverlapSphere(transform.position, viewRadius, targetMask);      \n   for (int i = 0; i < targetsInViewRadius.Length; i++)\n   {\n   Transform target = targetInViewRadius [i].transform; Vector3\n    dirToTarget = (target.position - transform.position).normalized;\n   if (Vector3.Angle (transform.forward, dirToTarget) < viewAngle / 2)\n    {\n      float dstToTarget = Vector3.Distance (transform.position,\n       target.position); \n      if (!Physics.Raycast(transform.position,\n       dirToTarget, dstToTarget, obstacleMask))\n           { \n             visibleTargets.Add (target);\n            } \n   }\n }\n public Vector3 DirFromAngle(float angleInDegrees, bool angleIsGlobal) {\n  if(!angleIsGlobal) \n     { \n       angleInDegrees += transform.eulerAngles.y;\n     }  \n  return new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0,\n     Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));\n} \n```", "```py\npublic float viewRadius; [Range(0,360)]\npublic float viewAngle; public LayerMask targetMask; \npublic LayerMask obstacleMask; \n[HideInInspector] public List<Transform> visibleTargets = new List<Transform>(); \nvoid Start () \n    { \n     StartCoroutine(\"FindTargetsWithDelay\", .2f); \n    } \nIEnumerator FindTargetsWithDelay(float delay) \n{ \nwhile (true) {\n yield return new WaitForSeconds (delay);\n FindVisibleTargets ();\n } \n} \nvoid FindVisibleTargets ()\n { \n visibleTargets.Clear ();\n Collider[] targetInViewRadius\n =Physics.OverlapSphere(transform.position,viewRadius, targetMask);\n\nfor (int i = 0; i < targetsInViewRadius.Length; i++) \n{\n Transform target = targetInViewRadius [i].transform; Vector3 dirToTarget = (target.position - transform.position).normalized;\n if (Vector3.Angle (transform.forward, dirToTarget) < viewAngle / 2) { float dstToTarget = Vector3.Distance (transform.position, target.position);\n if (!Physics.Raycast(transform.position, dirToTarget, dstToTarget,\n     obstacleMask))\n {\n  visibleTargets.Add (target);\n }\n }\n }\n public Vector3 DirFromAngle(float angleInDegrees, bool angleIsGlobal)         { \nif(!angleIsGlobal)\n {\n angleInDegrees += transform.eulerAngles.y;\n }\n return new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0,\n Mathf.Cos(angleInDegrees * Mathf.Deg2Rad)); } \n```", "```py\n using UnityEngine;\n using System.Collections;\n using UnityEditor;\n\n [CustomEditor (typeof (FieldOfView))]\n public class FieldOfViewEditor : Editor{\n\n void OnSceneGUI(){\n FieldOfView fow = (FieldOfView)target;\n Handles.color = color.white; Handles.DrawWireArc\n (fow.transform.position, Vector3.up,\n Vector3.forward, 360, fow.viewRadius); Vector3 viewAngleA =\n fow.DirFromAngle(-fow.viewAngle/2, false);\n\n Handles.DrawLine(fow.transform.position, fow.transform.position +\n viewAngleA * fow.viewRadius);\n Handles.DrawLine(fow.transform.position,fow.transform.position +\n viewAngleB * fow.viewRadius); Handles.color = Color.red;\n Foreach (Transform visibleTarget in fow.visibleTargets)\n { \n Handles.DrawLine(fow.transform.position, visibleTarget.position);\n }\n }\n } \n```", "```py\npublic float viewRadius; [Range(0,360)]\npublic float viewAngle; public LayerMask targetMask; public LayerMask obstacleMask; [HideInInspector] public List<Transform> visibleTargets = new List<Transform>(); public float meshResolution; \n```", "```py\nvoid DrawFieldOfView() {\n int stepCount = Mathf.RoundToInt(viewAngle * meshResolution);\n float stepAngleSize = viewAngle / stepCount;\n for (int i = 0; i <= stepCount; i++) {\n float angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;Debug.DrawLine (transform.position, transform.position + DirFromAngle (angle, true) * viewRadius, Color.red);\n }\n }\n```", "```py\n void LateUpdate() {\n DrawFieldOfView ();\n } \n```", "```py\n public struct ViewCastInfo {\n public bool hit;\n public Vector3 point;\n public float dst;\n public float angle;\n\n public ViewCastInfo(bool _hit, Vector3 _point, float _dst, float\n _angle) {\n hit = _hit;\n point = _point;\n dst = _dst;\n angle = _angle;\n } } \n```", "```py\n void DrawFieldOfView() {\n int stepCount = Mathf.RoundToInt(viewAngle * meshResolution);\n float stepAngleSize = viewAngle / stepCount;\n List<Vector3> viewPoints = new List<Vector3>();\n for (int i = 0; i <= stepCount; i++)\n {\n  float angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize\n  * i;\n  ViewCastInfo newViewCast = ViewCast(angle);\n  Debug.DrawLine(transform.position, transform.position +\n  DirFromAngle(angle, true) * \n  viewRadius, Color.red);\n  viewPoints.Add(newViewCast.point); \n }\n }\n```", "```py\nvoid DrawFieldOfView() {\nint stepCount = Mathf.RoundToInt(viewAngle * meshResolution);\nfloat stepAngleSize = viewAngle / stepCount;\n List<Vector3> viewPoints = new List<Vector3> ();\n ViewCastInfo oldViewCast = new ViewCastInfo ();\nfor (int i = 0; i <= stepCount; i++) {\nfloat angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;\n ViewCastInfo newViewCast = ViewCast (angle);\n Debug.DrawLine(transform.position, transform.position + DirFromAngle(angle, true) * viewRadius, Color.red);\n viewPoints.Add (newViewCast.point);\n }\n\nint vertexCount = viewPoints.Count + 1;\n Vector3[] vertices = new Vector3[vertexCount];\nint[] triangles = newint[(vertexCount-2) * 3];\n\n vertices [0] = Vector3.zero;\nfor (int i = 0; i < vertexCount - 1; i++) {\n vertices [i + 1] = viewPoints [i];\n\nif (i < vertexCount - 2) {\n triangles [i * 3] = 0;\n triangles [i * 3 + 1] = i + 1;\n triangles [i * 3 + 2] = i + 2;\n }\n } } \n```", "```py\npublicfloat viewRadius;\n [Range(0,360)]\npublicfloat viewAngle;\n\npublic LayerMask targetMask;\npublic LayerMask obstacleMask;\n\n [HideInInspector]\npublic List<Transform> visibleTargets = new List<Transform>();\n\npublicfloat meshResolution;\n\npublic MeshFilter viewMeshFilter;\n Mesh viewMesh; \n```", "```py\n void Start() {\n viewMesh = new Mesh ();\n viewMesh.name = \"View Mesh\";\n viewMeshFilter.mesh = viewMesh;\n\n StartCoroutine (\"FindTargetsWithDelay\", .2f);\n } \n```", "```py\nvoid DrawFieldOfView() {\nint stepCount = Mathf.RoundToInt(viewAngle * meshResolution);\nfloat stepAngleSize = viewAngle / stepCount;\n List<Vector3> viewPoints = new List<Vector3> ();\n ViewCastInfo oldViewCast = new ViewCastInfo ();\nfor (int i = 0; i <= stepCount; i++) {\nfloat angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;\n ViewCastInfo newViewCast = ViewCast (angle);\n viewPoints.Add (newViewCast.point);\n }\n\nint vertexCount = viewPoints.Count + 1;\n Vector3[] vertices = new Vector3[vertexCount];\nint[] triangles = newint[(vertexCount-2) * 3];\n\n vertices [0] = Vector3.zero;\nfor (int i = 0; i < vertexCount - 1; i++) {\n vertices [i + 1] = viewPoints [i];\n\nif (i < vertexCount - 2) {\n triangles [i * 3] = 0;\n triangles [i * 3 + 1] = i + 1;\n triangles [i * 3 + 2] = i + 2;\n }\n }\n\n viewMesh.Clear ();\n\n viewMesh.vertices = vertices;\n viewMesh.triangles = triangles;\n viewMesh.RecalculateNormals ();\n } \n```", "```py\nvoid DrawFieldOfView() {\nint stepCount = Mathf.RoundToInt(viewAngle * meshResolution);\nfloat stepAngleSize = viewAngle / stepCount;\n List<Vector3> viewPoints = new List<Vector3> ();\n ViewCastInfo oldViewCast = new ViewCastInfo ();\nfor (int i = 0; i <= stepCount; i++) {\nfloat angle = transform.eulerAngles.y - viewAngle / 2 + stepAngleSize * i;\n ViewCastInfo newViewCast = ViewCast (angle);\n viewPoints.Add (newViewCast.point);\n }\n\nint vertexCount = viewPoints.Count + 1;\n Vector3[] vertices = new Vector3[vertexCount];\nint[] triangles = newint[(vertexCount-2) * 3];\n\n vertices [0] = Vector3.zero;\nfor (int i = 0; i < vertexCount - 1; i++) {\n vertices [i + 1] = transform.InverseTransformPoint(viewPoints [i]) + Vector3.forward * maskCutawayDst;\n\nif (i < vertexCount - 2) {\n triangles [i * 3] = 0;\n triangles [i * 3 + 1] = i + 1;\n triangles [i * 3 + 2] = i + 2;\n }\n }\n\n viewMesh.Clear ();\n\n viewMesh.vertices = vertices;\n viewMesh.triangles = triangles;\n viewMesh.RecalculateNormals (); } \n```", "```py\n void LateUpdate() {\n DrawFieldOfView ();\n } \n```"]