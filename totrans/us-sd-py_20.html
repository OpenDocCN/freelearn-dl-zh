<html><head></head><body>
		<div><h1 id="_idParaDest-232" class="chapter-number"><a id="_idTextAnchor387"/>20</h1>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor388"/>Creating Interactive User Interfaces</h1>
			<p>In previous chapters, we used only Python code and Jupyter Notebook to achieve various tasks using Stable Diffusion. In some scenarios, we need an interactive user interface not only for easier testing but also for a better user experience.</p>
			<p>Imagine we have built an application using Stable Diffusion. How can we publish it to the public or non-technical users to try it out? In this chapter, we are going to use an open sourced interactive UI framework, Gradio [1], to encapsulate diffusers code and provide a web-based UI, using only Python.</p>
			<p>This chapter won't delve into every aspect of Gradio usage. Instead, we'll focus on giving you a high-level overview of its fundamental building blocks, all with a specific goal in mind: demonstrating how to construct a Stable Diffusion text-to-image pipeline using Gradio.</p>
			<p>In this chapter, we will cover these topics:</p>
			<ul>
				<li>Introducing Gradio</li>
				<li>Gradio fundamentals</li>
				<li>Building a Stable Diffusion text-to-image pipeline with Gradio</li>
			</ul>
			<p>Let’s start.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor389"/>Introducing Gradio</h1>
			<p>Gradio<a id="_idIndexMarker589"/> is a Python library that makes it easy to build beautiful, interactive web interfaces for machine learning models and data science workflows. It is a high-level library that abstracts away the details of web development so you can focus on building your model and interface.</p>
			<p>The A1111 Stable Diffusion Web UI that we mentioned several times in previous chapters uses Gradio as the user interface, and many researchers use this framework for a quick demo of their most recent work. Here are some reasons why Gradio is the prevailing user interface:</p>
			<ul>
				<li><strong class="bold">Easy to use</strong>: Gradio’s <a id="_idIndexMarker590"/>simple API makes it easy to create interactive web interfaces in just a few lines of code</li>
				<li><strong class="bold">Flexible</strong>: Gradio can be used to create a wide variety of interactive web interfaces, from simple sliders to complex chatbots</li>
				<li><strong class="bold">Extensible</strong>: Gradio is extensible, so you can customize the look and feel of your interfaces or add new features</li>
				<li><strong class="bold">Open source</strong>: Gradio is open source, so you can contribute to the project or use it in your projects</li>
			</ul>
			<p>Another feature of Gradio that doesn’t exist in other similar frameworks is that Gradio interfaces can be embedded in Python notebooks or presented as standalone web pages (you will find out why this notebook embedding feature is cool when you see it).</p>
			<p>If you have been running Stable Diffusion using diffusers, your Python environment should be ready for Gradio. In case this is the first chapter of your reading journey, make sure you have Python 3.8 or a higher version installed on your machine.</p>
			<p>Now that we know what Gradio is, let’s learn how to set it up<a id="_idTextAnchor390"/>.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor391"/>Getting started with Gradio</h1>
			<p>In this section, we will learn about the bare minimum setup needed to spin up a Gradio application:</p>
			<ol>
				<li>Install<a id="_idIndexMarker591"/> Gradio using <code>pip</code>:<pre class="source-code">
pip install gradio</pre><p class="list-inset">Please also ensure you update the following two packages to the newest version: <code>click</code> and <code>uvicorn</code>:</p><pre class="source-code">
pip install -U click</pre><pre class="source-code">
pip install -U uvicorn</pre></li>
				<li>Create a Jupyter Notebook cell and write or copy the following code in the cell:<pre class="source-code">
import gradio</pre><pre class="source-code">
def greet(name):</pre><pre class="source-code">
    return "Hello " + name + "!"</pre><pre class="source-code">
demo = gradio.Interface(</pre><pre class="source-code">
    fn = greet,</pre><pre class="source-code">
    inputs = "text",</pre><pre class="source-code">
    outputs = "text"</pre><pre class="source-code">
)</pre><pre class="source-code">
demo.launch()</pre></li>
			</ol>
			<p>Executing it will not<a id="_idIndexMarker592"/> pop out a new web browser window. Instead, the UI will be embedded inside the Jupyter Notebook result panel.</p>
			<p>Of course, you can copy and paste the local URL – <code>http: //127.0.0 .1:78 60</code> – to any local browser to view it.</p>
			<p>Be aware that the next time you execute the code in another Jupyter Notebook's cell, a new server port will be allocated, such as <code>7861</code>. Gradio won’t take back the assigned server port automatically. We can use one additional line of code – <code>gr.close_all()</code> – to ensure all liveports are released before the launch. Update the code as shown here:</p>
			<pre class="source-code">
import gradio
def greet(name):
    return "Hello " + name + "!"
demo = gradio.Interface(
    fn = greet,
    inputs = "text",
    outputs = "text"
)
gradio.close_all()
demo.launch(
    server_port = 7860
)</pre>
			<p>Both the code and the<a id="_idIndexMarker593"/> embedded Gradio interface will be shown in <em class="italic">Figure 20</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B21263_20_01.jpg" alt="Figure 20.1: Gradio UI embedded in Jupyter Notebook cell"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.1: Gradio UI embedded in Jupyter Notebook cell</p>
			<p>Note that the Jupyter Notebook is running in Visual Studio Code. It also works in Google Colab or independently installed Jupyter Notebook.</p>
			<p>Alternatively, we can start a<a id="_idIndexMarker594"/> Gradio application from the terminal.</p>
			<p>Starting a web application in Jupyter Notebook is good for testing and proof of concept demonstration. When deploying an application, we’d better start it from the terminal.</p>
			<p>Create a new file called <code>gradio_app.py</code>, and use the same code we used in <em class="italic">step 2</em>. Use a new port number, such as <code>7861</code>, to avoid conflict with the already used <code>7860</code>. Then launch the application from the terminal:</p>
			<pre class="source-code">
python gradio_app.py</pre>
			<p>That is all set. Next, let’s gain some familiarity with the fundamental building blocks of Gra<a id="_idTextAnchor392"/>dio.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor393"/>Gradio fundamentals</h1>
			<p>The preceding sample code is reformed from the Gradio official quick start tutorial. When we look at the code, lots of details are hidden. We don’t know where the <code>Clear</code> button is, we don’t specify the <code>Submit</code> button, and we don’t know what the <code>Flag</code> button is.</p>
			<p>Before using Gradio for any serious applications, we need to understand every line of code and ensure every element is under control.</p>
			<p>Instead of using the <code>Interface</code> function to automatically provide the layout, <code>Blocks</code> may provide a better way for us to add interface elements with explicit declarat<a id="_idTextAnchor394"/>ion.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor395"/>Gradio Blocks</h2>
			<p>The <code>Interface</code> function provides <a id="_idIndexMarker595"/>an abstraction level to easily create quick demos, but there is an abstraction layer. Easy comes with a price. <code>Blocks</code>, on the other hand, is a low-level approach to lay out elements and define data flows. With the help of <code>Blocks</code>, we can precisely control the following:</p>
			<ul>
				<li>The layout of components</li>
				<li>The events that trigger actions</li>
				<li>The direction of the data flow</li>
			</ul>
			<p>An example will explain it better:</p>
			<pre class="source-code">
import gradio
gradio.close_all()
def greet(name):
    return f"hello {name} !"
with gradio.Blocks() as demo:
    name_input = gradio.Textbox(label = "Name")
    output = gradio.Textbox(label = "output box")
    diffusion_btn = gradio.Button("Generate")
    diffusion_btn.click(
        fn = greet,
        inputs = name_input,
        outputs = output
    )
demo.launch(server_port = 7860)</pre>
			<p>The preceding code will <a id="_idIndexMarker596"/>produce an interface as shown in <em class="italic">Figure 20</em><em class="italic">.2</em>:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B21263_20_02.jpg" alt="Figure 20.2: Stack Gradio UI using Blocks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.2: Stack Gradio UI using Blocks</p>
			<p>All elements under <code>Blocks</code> will be shown in the UI. The text for the UI elements is defined by us too. In the <code>click</code> event, we defined the <code>fn</code> event function, <code>inputs</code>, and <code>outputs</code>. Finally, launch<a id="_idIndexMarker597"/> the application using <code>demo.launch(server_port = </code><code>7860)</code>.</p>
			<p>In line with one of Python’s guiding principles: “<em class="italic">Explicit is better than implicit</em>”, we strive for clarity and simplicity in our<a id="_idTextAnchor396"/> code.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor397"/>Inputs and outputs</h2>
			<p>The code in the <em class="italic">Gradio Blocks</em> section uses <a id="_idIndexMarker598"/>only one input and one output. We can provide multiple inputs and outputs, as shown in the following code:</p>
			<pre class="source-code">
import gradio
gradio.close_all()
def greet(name, age):
    return f"hello {name} !", f"You age is {age}"
with gradio.Blocks() as demo:
    name_input = gradio.Textbox(label = "Name")
    age_input = gradio.Slider(minimum =0,maximum =100,
        label ="age slider")
    name_output = gradio.Textbox(label = "name output box")
    age_output = gradio.Textbox(label = "age output")
    diffusion_btn = gradio.Button("Generate")
    diffusion_btn.click(
        fn = greet,
        inputs = [name_input, age_input],
        outputs = [name_output, age_output]
    )
demo.launch(server_port = 7860)</pre>
			<p>The<a id="_idIndexMarker599"/> result is shown in <em class="italic">Figure 20</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/B21263_20_03.jpg" alt="Figure 20.3: Gradio UI with multiple inputs and outputs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.3: Gradio UI with multiple inputs and outputs</p>
			<p>Simply stack the element under <code>with gradio.Blocks() as demo:</code> and provide inputs and outputs in <code>list</code>. Gradio will automatically take the values from the inputs and forward them to the <code>greet</code> bind function. The outputs will take the return tuple value from the associated function.</p>
			<p>Next, replace the elements with a prompt and output image components. This approach can be applied to build a web-based Stable Diffusion pipeline. However, before proceeding, we need to explore how to integrate a progress bar into our interface.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor398"/>Building a progress bar</h2>
			<p>To use a <a id="_idIndexMarker600"/>progress bar in Gradio, we can add a <code>progress</code> argument to the associated event function. The <code>Progress</code> object will be used to track the progress of the function, and it will be displayed to the user as a progress bar.</p>
			<p>Here is an example of how to use a progress bar in Gradio.</p>
			<pre class="source-code">
import gradio, time
gradio.close_all()
def my_function(text, progress=gradio.Progress()):
    for i in range(10):
        time.sleep(1)
        progress(i/10, desc=f"{i}")
    return text
with gradio.Blocks() as demo:
    input = gradio.Textbox()
    output = gradio.Textbox()
    btn = gradio.Button()
    btn.click(
        fn = my_function,
        inputs = input,
        outputs = output
    )
demo.queue().launch(server_port=7860)</pre>
			<p>In the preceding code, we manually<a id="_idIndexMarker601"/> update the progress bar with <code>progress(i/10, desc=f"{i}")</code>. After each sleep, the progress bar will move forward 10%.</p>
			<p>After clicking the <strong class="bold">Run</strong> button, the progress bar will appear in the position of the output textbox. We will use a similar approach to apply the progress bar for the Stable Diffusion pipeline in the next<a id="_idTextAnchor399"/> section.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor400"/>Building a Stable Diffusion text-to-image pipeline with Gradio</h1>
			<p>With<a id="_idIndexMarker602"/> all preparations ready, now let’s build <a id="_idIndexMarker603"/>a Stable Diffusion text-to-image pipeline with Gradio. The UI interface will include the following:</p>
			<ul>
				<li>A prompt input box</li>
				<li>A negative prompt input box</li>
				<li>A button with the <code>Generate</code> label</li>
				<li>A progress bar when the <code>Generate</code> button is clicked</li>
				<li>An output image</li>
			</ul>
			<p>Here is the code that implements these five elements:</p>
			<pre class="source-code">
import gradio
gradio.close_all(verbose = True)
import torch
from diffusers import StableDiffusionPipeline
text2img_pipe = StableDiffusionPipeline.from_pretrained(
    "stablediffusionapi/deliberate-v2",
    torch_dtype = torch.float16,
    safety_checker = None
).to("cuda:0")
def text2img(
    prompt:str,
    neg_prompt:str,
    progress_bar = gradio.Progress()
):
    return text2img_pipe(
        prompt = prompt,
        negative_prompt = neg_prompt,
        callback = (
            lambda step,
            timestep,
            latents: progress_bar(step/50,desc="denoising")
        )
    ).images[0]
with gradio.Blocks(
    theme = gradio.themes.Monochrome()
) as sd_app:
    gradio.Markdown("# Stable Diffusion in Gradio")
    prompt = gradio.Textbox(label="Prompt", lines = 4)
    neg_prompt = gradio.Textbox(label="Negative Prompt", lines = 2)
    sd_gen_btn = gradio.Button("Generate Image")
    output_image = gradio.Image()
    sd_gen_btn.click(
        fn = text2img,
        inputs = [prompt, neg_prompt],
        outputs = output_image
    )
sd_app.queue().launch(server_port = 7861)</pre>
			<p>In the <a id="_idIndexMarker604"/>preceding code, we first launch <a id="_idIndexMarker605"/>the <code>text2img_pipe</code> pipeline to VRAM, followed by creating a <code>text2img</code> function, which will be called by the Gradio event button. Note the <code>lambda</code> expression:</p>
			<pre class="source-code">
callback = (
    lambda step, timestep, latents:
        progress_bar(step/50, desc="denoising")
)</pre>
			<p>We will pass the progress bar into the diffusers denoising loop. Each denoising step will then update the progress bar.</p>
			<p>The last part of the code is the Gradio elements <code>Block</code> stack. The code also gives Gradio a new theme:</p>
			<pre class="source-code">
...
with gradio.Blocks(
    theme = gradio.themes.Monochrome()
) as sd_app:
...</pre>
			<p>Now you should be able to run the code and generate some images in both Jupyter Notebook and any local web browser.</p>
			<p>The <a id="_idIndexMarker606"/>progress bar and the result are <a id="_idIndexMarker607"/>shown in <em class="italic">Figure 20</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/B21263_20_04.jpg" alt="Figure 20.4: Gradio UI with progress bar"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.4: Gradio UI with progress bar</p>
			<p>You can add more elements and features to this sampl<a id="_idTextAnchor401"/>e application.</p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor402"/>Summary</h1>
			<p>At the time of writing this chapter (December 2023), there isn’t much information or sample code to help us get started using diffusers with Gradio. We wrote this chapter to help quickly build up a Stable Diffusion application in Web UI so that we can share the result with others in minutes without touching one line of HTML, CSS, or JavaScript, using pure Python throughout the building process.</p>
			<p>This chapter introduced Gradio, what it can do, and why it is popular. We didn’t touch on every bit of Gradio; we believe that its official document [1] does this job better. Instead, we used a simple example to explain the backbone of Gradio and what we need to prepare to build a Stable Diffusion Web UI with Gradio.</p>
			<p>Finally, we introduced <code>Blocks</code>, <code>inputs</code>, <code>outputs</code>, the progress bar, and event bindings all together and built up a tiny but fully functioning Stable Diffusion pipeline in Gradio.</p>
			<p>In the next chapter, we will delve into a relatively complex topic: model fine-tuning and <a id="_idTextAnchor403"/>LoRA training.</p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor404"/>References</h1>
			<ol>
				<li>Gradio: Build Machine Learning Web Apps — in Python: <a href="https://github.com/gradio-app/gradio">https://github.com/gradio-app/gradio</a></li>
				<li>Gradio QuickStart: <a href="https://www.gradio.app/guides/quickstart">https://www.gradio.app/guides/quickstart</a></li>
			</ol>
		</div>
	</body></html>