- en: Using Fuzzy Logic to Make Your AI Seem Alive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fuzzy logic is a fantastic way to represent the rules of your game in a more
    nuanced way. Perhaps more so than other concepts in this book, fuzzy logic is
    a very math-heavy topic. Most of the information can be represented purely in
    mathematical functions. For the sake of teaching the important concepts as they
    apply to Unity, most of the math has been simplified and implemented using Unity''s
    built-in features. Of course, if you are the type who loves math, this is a somewhat
    deep topic in that regard, so feel free to take the concepts covered in this book
    and run with them! In this chapter, we''ll learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What fuzzy logic is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where fuzzy logic is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement fuzzy logic controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the other creative uses for fuzzy logic concepts are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining fuzzy logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to define fuzzy logic is by comparison to binary logic. In
    the previous chapters, we looked at transition rules as true or false or 0 or
    1 values. Is something visible? Is it at least a certain distance away? Even in
    instances where multiple values were being evaluated, all of the values had exactly
    two outcomes; thus, they were binary. In contrast, fuzzy values represent a much
    richer range of possibilities, where each value is represented as a float rather
    than an integer. We stop looking at values as 0 or 1, and we start looking at
    them as 0 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: A common example used to describe fuzzy logic is temperature. Fuzzy logic allows
    us to make decisions based on non-specific data. I can step outside on a sunny
    Californian summer's day and ascertain that it is warm, without knowing the temperature
    precisely. Conversely, if I were to find myself in Alaska during the winter, I
    would know that it is cold, again, without knowing the exact temperature. These
    concepts of cold, cool, warm, and hot are fuzzy ones. There is a good amount of
    ambiguity as to at what point we go from warm to hot. Fuzzy logic allows us to
    model these concepts as sets and determine their validity or truth by using a
    set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'When people make decisions, people have some gray areas. That is to say, it''s
    not always black and white. The same concept applies to agents that rely on fuzzy
    logic. Say you hadn''t eaten in a few hours, and you were starting to feel a little
    hungry. At which point were you hungry enough to go grab a snack? You could look
    at the time right after a meal as 0, and 1 would be the point where you approached
    starvation. The following figure illustrates this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cbfd7ea-ab8e-4c55-b672-4a68d65ad2c6.png)'
  prefs: []
  type: TYPE_IMG
- en: When making decisions, there are many factors that determine the ultimate choice.
    This leads into another aspect of fuzzy logic controllers—they can take into account
    as much data as necessary. Let's continue to look at our "should I eat?" example.
    We've only considered one value for making that decision, which is the time since
    the last time you ate. However, there are other factors that can affect this decision,
    such as how much energy you're expending and how lazy you are at that particular
    moment. Or am I the only one to use that as a deciding factor? Either way, you
    can see how multiple input values can affect the output, which we can think of
    as the "likeliness to have another meal."
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic systems can be very flexible due to their generic nature. You provide
    input, the fuzzy logic provides an output. What that output means to your game
    is entirely up to you. We've primarily looked at how the inputs would affect a
    decision, which, in reality, is taking the output and using it in a way the computer,
    our agent, can understand. However, the output can also be used to determine how
    much of something to do, how fast something happens, or for how long something
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine your agent is a car in a sci-fi racing game that has a
    "nitro-boost" ability that lets it expend a resource to go faster. Our 0 to 1
    value can represent a normalized amount of time for it to use that boost or perhaps
    a normalized amount of fuel to use.
  prefs: []
  type: TYPE_NORMAL
- en: Picking fuzzy systems over binary systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the previous systems we covered in this book, and with most things in
    game programming, we must evaluate the requirements of our game and the technology
    and hardware limitations when deciding on the best way to tackle a problem.
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, there is a performance cost associated with going from
    a simple yes/no system to a more nuanced fuzzy logic one, which is one of the
    reasons we may opt out of using it. Of course, being a more complex system doesn't
    necessarily always mean it's a better one. There will be times when you just want
    the simplicity and predictability of a binary system because it may fit your game
    better.
  prefs: []
  type: TYPE_NORMAL
- en: While there is some truth to the old adage, "the simpler, the better", one should
    also take into account the saying, "everything should be made as simple as possible,
    but not simpler". Though the quote is widely attributed to Albert Einstein, the
    father of relativity, it's not entirely clear who said it. The important thing
    to consider is the meaning of the quote itself. You should make your AI as simple
    as your game needs it to be, but not simpler. Pac-Man's AI works perfectly for
    the game–it's simple enough. However, rules say that simple would be out of place
    in a modern shooter or strategy game.
  prefs: []
  type: TYPE_NORMAL
- en: Take the knowledge and examples in this book and find what works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Using fuzzy logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you understand the simple concepts behind fuzzy logic, it's easy to start
    thinking of the many, many ways in which it can be useful. In reality, it's just
    another tool in our belt, and each job requires different tools.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic is great at taking some data, evaluating it in a similar way to
    how a human would (albeit in a much simpler way), and then translating the data
    back to information that is usable by the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fuzzy logic controllers have several real-world use cases. Some are more obvious
    than others, and while these are by no means one-to-one comparisons to our usage
    in game AI, they serve to illustrate a point:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Heating ventilation and air conditioning (HVAC) systems**: The temperature
    example when talking about fuzzy logic is not only a good theoretical approach
    to explaining fuzzy logic, but also a very common real-world example of fuzzy
    logic controllers in action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automobiles**: Modern automobiles come equipped with very sophisticated computerized
    systems, from the air conditioning system (again), to fuel delivery, to automated
    braking systems. In fact, putting computers in automobiles has resulted in far
    more efficient systems than the old binary systems that were sometimes used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Your smartphone**: Ever notice how your screen dims and brightens depending
    on how much ambient light there is? Modern smartphone operating systems look at
    ambient light, the color of the data being displayed, and the current battery
    life to optimize screen brightness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Washing machines**: Not my washing machine necessarily, as it''s quite old,
    but most modern washers (from the last 20 years) make some use of fuzzy logic.
    Load size, water dirtiness, temperature, and other factors are taken into account
    from cycle to cycle to optimize water use, energy consumption, and time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you take a look around your house, there is a good chance you'll find a few
    interesting uses of fuzzy logic, and I mean besides your computer, of course.
    While these are neat uses of the concept, they're not particularly exciting or
    game-related. I'm partial to games involving wizards, magic, and monsters, so
    let's look at a more relevant example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple fuzzy logic system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we're going to use my good friend, Bob, the wizard. Bob lives
    in an RPG world, and he has some very powerful healing magic at his disposal.
    Bob has to decide when to cast this magic on himself based on his remaining **health
    points** (**HPs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a binary system, Bob''s decision-making process might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that Bob''s health can be in one of two states—above 50, or not. Nothing
    wrong with that, but let''s have a look at what the fuzzy version of this same
    scenario might look like, starting with determining Bob''s health status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36e6c128-2a3f-413d-8117-4fd0da005f8e.png)'
  prefs: []
  type: TYPE_IMG
- en: A typical function representing fuzzy values
  prefs: []
  type: TYPE_NORMAL
- en: Before the panic sets in upon seeing charts and values that may not quite mean
    anything to you right away, let's dissect what we're looking at. Our first impulse
    might be to try to map the probability that Bob will cast a healing spell to how
    much health he is missing. That would, in simple terms, just be a linear function.
    Nothing really fuzzy about that—it's a linear relationship, and while it is a
    step above a binary decision in terms of complexity, it's still not truly fuzzy.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the concept of a membership function. It's key to our system, as it allows
    us to determine how true a statement is. In this example, we're not simply looking
    at raw values to determine whether or not Bob should cast his spell; instead,
    we're breaking it up into logical chunks of information for Bob to use in order
    to determine what his course of action should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''re comparing three statements and evaluating not only
    how true each one is, but which is the most true:'
  prefs: []
  type: TYPE_NORMAL
- en: Bob is in a critical condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob is hurt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob is healthy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're into official terminology, we call this determining the degree of
    membership to a set. Once we have this information, our agent can determine what
    to do with it next.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a glance, you''ll notice it''s possible for two statements to be true at
    a time. Bob can be in a critical condition and hurt. He can also be somewhat hurt
    and a little bit healthy. You''re free to pick the thresholds for each, but, in
    this example, let''s evaluate these statements as per the preceding graph. The
    vertical value represents the degree of truth of a statement as a normalized float
    (0 to 1):'
  prefs: []
  type: TYPE_NORMAL
- en: At 0 percent health, we can see that the critical statement evaluates to 1\.
    It is absolutely true that Bob is critical when his health is gone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At 40 percent health, Bob is hurt, and that is the truest statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At 100 percent health, the truest statement is that Bob is healthy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anything outside of these absolutely true statements is squarely in fuzzy territory.
    For example, let''s say Bob''s health is at 65 percent. In that same chart, we
    can visualize it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b2444bf-13f2-4f1a-b513-bf959709fbef.png)'
  prefs: []
  type: TYPE_IMG
- en: Bob's health at 65 percent
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertical line drawn through the chart at **65** represents Bob''s health.
    As we can see, it intersects both sets, which means that Bob is a little bit hurt,
    but he''s also kind of healthy. At a glance, we can tell, however, that the vertical
    line intercepts the **Hurt** set at a higher point in the graph. We can take this
    to mean that Bob is more hurt than he is healthy. To be specific, Bob is 37.5
    percent hurt, 12.5 percent healthy, and 0 percent critical. Let''s take a look
    at this in code; open up our `FuzzySample` scene in Unity. The hierarchy will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/273f2b9b-6011-429b-a282-43ef9f409313.png)'
  prefs: []
  type: TYPE_IMG
- en: The hierarchy setup in our sample scene
  prefs: []
  type: TYPE_NORMAL
- en: The important game object to look at is `Fuzzy Example`. This contains the logic
    that we'll be looking at. In addition to that, we have our `Canvas` containing
    all of the labels and the input field and button that make this example work.
    Lastly, there's the Unity-generated `EventSystem` and `Main Camera`, which we
    can disregard. There isn't anything special going on with the setup for the scene,
    but it's a good idea to become familiar with it, and you are encouraged to poke
    around and tweak it to your heart's content after we've looked at why everything
    is there and what it all does.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Fuzzy Example` game object selected, the inspector will look similar
    to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99f298ae-67ba-4700-8b35-c04b5a6d9a5a.png)'
  prefs: []
  type: TYPE_IMG
- en: The Fuzzy Example game object inspector
  prefs: []
  type: TYPE_NORMAL
- en: Our sample implementation is not necessarily something you'll take and implement
    in your game as it is, but it is meant to illustrate the previous points in a
    clear manner. We use Unity's `AnimationCurve` for each different set. It's a quick
    and easy way to visualize the very same lines in our earlier graph.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there is no straightforward way to plot all the lines in the
    same graph, so we use a separate `AnimationCurve` for each set. In the preceding
    screenshot, they are labeled Critical, Hurt, and Healthy. The neat thing about
    these curves is that they come with a built-in method to evaluate them at a given
    point (*t*). For us, *t* does not represent time, but rather the amount of health
    Bob has.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the preceding graph, the Unity example looks at a HP range of 0 to 100\.
    These curves also provide a simple user interface for editing the values. You
    can simply click on the curve in the inspector. That opens up the curve editing
    window. You can add points, move points, change tangents, and so on, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbabf929-7f69-43f3-83de-64f47f94abcc.png)'
  prefs: []
  type: TYPE_IMG
- en: Unity's curve editor window
  prefs: []
  type: TYPE_NORMAL
- en: Our example focuses on triangle-shaped sets. That is, linear graphs for each
    set. You are by no means restricted to this shape, though it is the most common.
    You could use a bell curve or a trapezoid, for that matter. To keep things simple,
    we'll stick to the triangle.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Unity's `AnimationCurve` editor at [http://docs.unity3d.com/ScriptReference/AnimationCurve.html](http://docs.unity3d.com/ScriptReference/AnimationCurve.html).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the fields are just references to the different UI elements used
    in code that we'll be looking at later in this chapter. The names of these variables
    are fairly self-explanatory, however, so there isn't much guesswork to be done
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can take a look at how the scene is set up. If you play the scene,
    the game view will look something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a87ffea-f5f4-4297-995a-0613906c6a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple UI to demonstrate fuzzy values
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we have three distinct groups, representing each question from
    the "Bob, the wizard" example. How healthy is Bob, how hurt is Bob, and how critical
    is Bob? For each set, upon evaluation, the value that starts off as **0 true** will
    dynamically adjust to represent the actual degree of membership.
  prefs: []
  type: TYPE_NORMAL
- en: There is an input box in which you can type a percentage of health to use for
    the test. No fancy controls are in place for this, so be sure to enter a value
    from 0 to 100\. For the sake of consistency, let's enter a value of `65` into
    the box and then press the Evaluate! button.
  prefs: []
  type: TYPE_NORMAL
- en: This will run some code, look at the curves, and yield the exact same results
    we saw in our graph earlier. While this shouldn't come as a surprise (the math
    is what it is, after all), there are fewer things more important in game programming
    than testing your assumptions, and sure enough, we've tested and verified our
    earlier statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the test by hitting the Evaluate! button, the game scene will
    look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86fd988c-3061-4cf3-9de0-9aec4b0238ca.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how Bob is doing at 65 percent health
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the values turn out to be 0.125 (or 12.5 percent) healthy and 0.375
    (or 37.5 percent) hurt. At this point, we''re still not doing anything with this
    data, but let''s take a look at the code that''s handling everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start off by declaring some variables. The `labelText` is simply a constant
    we use to plug into our label. We replace `{0}` with the real value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the three `AnimationCurve` variables that we mentioned earlier.
    Making these public or otherwise accessible from the inspector is key to being
    able to edit them visually (though it is possible to construct curves by code),
    which is the whole point of using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following four variables are just references to UI elements that we saw
    earlier in the screenshot of our inspector, and the last three variables are the
    actual float values that our curves will evaluate into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Start()` method doesn't require much explanation. We simply update our
    labels here so that they initialize to something other than the default text.
    The `EvaluateStatements()` method is much more interesting. We first do some simple
    null checking for our input string. We don't want to try and parse an empty string,
    so we return out of the function if it is empty. As mentioned earlier, there is
    no check in place to validate that you've input a numerical value, so be sure
    not to accidentally input a non-numerical value or you'll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the `AnimationCurve` variables, we call the `Evaluate(float t)`
    method, where we replace `t` with the parsed value we get from the input field.
    In the example we ran, that value would be `65`. Then, we update our labels once
    again to display the values we got. The code looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We simply take each label and replace the text with a formatted version of our
    `labelText` constant that replaces the `{0}` with the real value.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed this topic in detail earlier, and it's important to understand
    that the values that make up the sets in our example are unique to Bob and his
    pain threshold. Let's say we have a second wizard, Jim, who's a bit more reckless.
    For him, critical might be below 20 percent, rather than 40 percent as it is for
    Bob. This is what I like to call a "happy bonus" from using fuzzy logic. Each
    agent in the game can have different rules that define their sets, but the system
    doesn't care. You could predefine these rules or have some degree of randomness
    determine the limits, and every single agent would behave uniquely and respond
    to things in their own way.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there is no reason to limit our sets to just three. Why not four
    or five? To the fuzzy logic controller, all that matters is that you determine
    what truth you're trying to arrive at, and how you get there; it doesn't care
    how many different sets or possibilities exist in that system.
  prefs: []
  type: TYPE_NORMAL
- en: Defuzzifying the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes, that''s a real (sort of) word. We''ve started with some crisp rules, which,
    in the context of fuzzy logic, means clear-cut, hard-defined data, which we then
    fuzzified (again, a sort of real word) by assigning membership functions to sets.
    The last step of the process is to defuzzify the data and make a decision. For
    this, we use simple Boolean operations, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, at this point, you may be saying, "Hold on a second. That looks an awful
    lot like a binary controller," and you'd be correct. So why go through all the
    trouble? Remember what we said earlier about ambiguous information? Without a
    fuzzy controller, how does our agent understand what it means to be critical,
    hurt, or healthy, for that matter? These are abstract concepts that mean very
    little on their own to a computer.
  prefs: []
  type: TYPE_NORMAL
- en: By using fuzzy logic, we're now able to use these vague terms, infer something
    from them, and do concrete things; in this case, cast a healing spell. Furthermore,
    we're able to allow each agent to determine what these vague terms mean to them
    on an individual level, allowing us not only to achieve unpredictability on an
    individual level, but even amongst several similar agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is described best in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14a3760b-32ab-4a26-915e-0f61eaf16387.png)'
  prefs: []
  type: TYPE_IMG
- en: The fuzzy logic controller flow
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the day, they are still computers, so we''re bound to the most
    basic thing computers understand, 0s and 1s:'
  prefs: []
  type: TYPE_NORMAL
- en: We start with crisp data, that is, concrete, hard values that tell us something
    very specific.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fuzzification step is where we get to decide the abstract or ambiguous data
    that our agent will need to make a decision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the inference step, our agent gets to decide what that data means. The
    agent gets to determine what is "true" based on a provided set of rules, meant
    to mimic the nuance of human decision-making.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defuzzification step takes this human-friendly data and converts it into
    simple, computer-friendly information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We end with crisp data, ready for our wizard agent to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the resulting crisp data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data output from a fuzzy controller can then be plugged into a behavior
    tree or a finite state machine. Of course, we can also combine multiple controllers''
    output to make decisions. In fact, we can take a whole bunch of them to achieve
    the most realistic or interesting result (as realistic as a magic-using wizard
    can be, anyway). The following figure illustrates a potential set of fuzzy logic
    controllers it can be used to determine whether or not to cast the heal spell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/588bc666-d963-4120-8115-78fee8c5bd42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve looked at the health question already, but what about the rest? We have
    another set of questions that really don''t mean much to our agent on their own:'
  prefs: []
  type: TYPE_NORMAL
- en: Do you have enough mana? Well, you can have a little bit of mana, some mana,
    or a lot of mana. It would not be uncommon for a human player to ask this question
    as they choose to cast a magic spell in a game or use an ability. "Enough" may
    literally be a binary amount, but more likely, it would be "enough to cast heal,
    and have some left for other spells." We start with a straightforward crisp value–the
    amount of mana the agent has available that we then stick to our fuzzy logic controller
    and get some crisp data at the other end.
  prefs: []
  type: TYPE_NORMAL
- en: What about the enemy's strength? He could be weak, average, strong, or unbeatable.
    You can get creative with the input for your fuzzy logic controllers. You could,
    for example, just take a raw "strength" value from your enemy, but you could also
    take the difference between your "defensive" stat and the enemy's "attack power,"
    and plug that into your fuzzy logic controller. Remember, there is no restriction
    on how you process the data before it goes into the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Are my allies close? As we saw in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml),
    *Finite State Machines and You*, a simple distance check can do wonders for a
    simple design, but, at times, you may need more than just that. You may need to
    take into account obstacles along the way—is that an ally behind a locked gate,
    making him unable to reach the agent? These types of questions could even be a
    nested set of statements that we need to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we were to take that last question with the nested controllers, it
    might start to look a little familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caf246da-3954-4a5a-90fe-6ffffd5e77e2.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure is quite tree-like, isn't it? Sure enough, there is no
    reason why you couldn't build a behavior tree using fuzzy logic to evaluate each
    node. We end up with a very flexible, powerful, and nuanced AI system by combining
    these two concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Using a simpler approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you choose to stick with a simple evaluation of the crisp output, in other
    words, not specifically a tree or an FSM, you can use more Boolean operators to
    decide what your agent is going to do. The pseudo code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check for conditions that are not true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also string multiple conditions together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By looking at these simplified statements, you will have noticed yet another
    "happy bonus" of using fuzzy logic—the crisp output abstracts much of the decision-making
    conditionals and combines them into simplified data.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having to parse through all the possibilities in your `if/else`
    statements and ending up with a bazillion of them or a gazillion switch statements,
    you can neatly bundle pockets of logic into fewer, more meaningful chunks of data.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, you don't have to nest all the statements in a procedural way
    that is hard to read and difficult to reuse. As a design pattern, abstracting
    data via a fuzzy logic controller ends up being much more object-oriented and
    friendlier.
  prefs: []
  type: TYPE_NORMAL
- en: The morality meter example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The faction/morality meter example for this chapter covers a slightly different
    approach to implementing fuzzy logic via Unity. We build upon the implementation
    we covered in the basic fuzzy logic example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create a simple dialogue sequence, where the player is presented
    a series of scenarios, or questions, that they can then answer according to their
    morality. For simplicity's sake, we've included a "good," "neutral," and "evil"
    answer for each question. Let's take a look at the code to understand this a bit
    better.
  prefs: []
  type: TYPE_NORMAL
- en: The question and answer classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Question` and `Answer` classes are very simple, and are used as data containers. 
    Let''s look at the `Question.cs` class first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the `Question` class does not derive from `MonoBehaviour`.
    It is a plain ol' vanilla C# class. As such, Unity will not serialize it by default,
    and it won't show up in the inspector. To let Unity know you want this class to
    be serialized, use the `System.Serializable` attribute at the top of the class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it''s only a few lines of code. The first field, `questionText`,
    will be edited via the inspector in a later step. It is the display text for the
    question/scenario we are presenting the user. The `answers` field is an array
    of `Answer` types. The `Answer.cs` code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, you'll notice this class is very simple. `answerText` is the text to
    display in the response button for the player, and the `moralityValue` field is
    a hidden value we use to calculate the player's morality alignment later on. For
    this example, we assume that each question has three answers and that the morality
    values are 0, 50, and 100 for each one.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the conversation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `ConversationManager.cs` class is where all the heavy lifting happens for
    this sample. It manages the UI for our conversation, handles events, and calculates
    the results for us. For the first part, we initialize our question array and then
    handle the UI. We set up some variables at the top of the class, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be able to see the UI elements these variables correspond to up ahead,
    but note that we explicitly expect a set number of answers, as we only provide
    three answer buttons for the UI. Of course, you can modify this to be more flexible
    or to fit your needs, but keep in mind that if you want to use more or fewer answers,
    you''ll need to make those changes here as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to our previous example, we use Unity''s `AnimationCurve` to specify
    our fuzzy values. We assume a few things with this setup:'
  prefs: []
  type: TYPE_NORMAL
- en: At *t=0*, our "good" value is at 1, and goes down to 0 from there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At *t=50*, our "neutral" value is at 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At *t=100*, our "evil" rating is at 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values can be tweaked to your liking, but the current setup works well
    for the example. The following screenshot shows the curves set in the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc9d157d-69f7-4fcd-9c74-66ce63711e98.png)'
  prefs: []
  type: TYPE_IMG
- en: Fuzzy curves for our morality gradient
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the values shown here correspond to our earlier assumption that
    our "good" answer gives a value of 0, our "neutral" answer has a value of 50,
    and our "evil" answer has a value of 100.
  prefs: []
  type: TYPE_NORMAL
- en: Loading up the questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We provide a simple method named `LoadQuestion` to pull the values from our
    data classes into the UI and display them to the player. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `LoadQuestion` method takes in a question index, which corresponds to the
    index of the question in the array `questions[]`. We first check that our index
    is in bounds, and end the conversation by calling `EndConversation()` if it isn't.
    If we are in bounds, we just populate the question text and the answer text for
    each answer button.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The event that gets called when the user presses an answer button on the UI
    is `OnAnswerSubmitted`. The method is quite simple and is only a few lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The method does a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: It aggregates the answer value to the answer total. We'll look at how these
    values are assigned up ahead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increments the question index value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it calls `LoadQuestion` with the incremented index value from the previous
    bullet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have the `EndConversation` method, which, as we saw, gets called
    when we have answered all the questions (and the question index is out of bounds,
    based on our `questions[]` array length).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line simply disables the panel game object containing the question
    UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The calculations are in the next block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We calculate the average of all of our answers by taking the `answerTotal` value
    (the sum of all the answers) and dividing it by the number of questions. We then
    individually evaluate each curve for good, neutral, and evil ratings using the
    average value we just calculated. We use the average as our *t* value in the evaluation
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use some simple `if`logic to determine which rating is higher, as
    seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code, we have a little bit of a branching conditional
    structure to determine the highest value, from which we set the `alignmentText`
    value accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '`if` blocks can get a bit complex if you start to add too many conditions.
    In this case, you may want to consider placing the ratings into an array or dictionary,
    then sorting them, and/or using LINQ to get the highest value from it. For more
    on sorting dictionaries, check out Dot Net Perls:[ https://www.dotnetperls.com/sort-dictionary](https://www.dotnetperls.com/sort-dictionary)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we display the results to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply enable the results panel, and then append `alignmentText` to the
    `"Your morality alignment is:"` message, which would look like this in play mode
    (if you have a "good" rating):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6c093f2-75a5-4ace-a2cb-88f5f86d0af4.png)'
  prefs: []
  type: TYPE_IMG
- en: The game screen when you earn a "good" rating
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we can take a look at our scene setup, and how all of our values get
    initialized for the sample project.
  prefs: []
  type: TYPE_NORMAL
- en: Scene setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you first open the `FactionScene` example scene, you''ll notice a UI that
    looks like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a408ae35-dfa6-4a9c-955a-2f2132d845e9.png)'
  prefs: []
  type: TYPE_IMG
- en: The sample scene UI setup
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, the UI comprises several different
    panels, and the text components have been initialized with some sample text to
    help organize everything nicely. The hierarchy for the scene is shown in this
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae2bba4a-1f71-4bf3-8260-f70818273260.png)'
  prefs: []
  type: TYPE_IMG
- en: The FactionScene hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our canvas has two main panels at the root level—the QuestionPanel and
    a ResultPanel, which is disabled by default. This is because, as you may remember,
    we set that panel to `enabled` via code in our `EndConversation` method. At the
    bottom of the list, we have our ConversationManager game object, which contains
    our `ConversationManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select it, you''ll see that the inspector looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47ab095e-b278-4db0-a55e-a51a37187a69.png)'
  prefs: []
  type: TYPE_IMG
- en: The inspector for our Conversation Manager with all the values assigned
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the amount of information here may seem daunting, but let's
    take a look at each step, and you'll realize we've covered all of this already.
  prefs: []
  type: TYPE_NORMAL
- en: We first have our serialized array of questions. In this case, we have three
    questions (feel free to add more!). Each question then contains an array of (exactly)
    three answers, and the question text we saw earlier. For each answer, we have
    the answer text and morality value we saw earlier as well. Note that the order
    of the questions or answers doesn't necessarily matter, so long as your morality
    value corresponds to good, neutral, or evil.
  prefs: []
  type: TYPE_NORMAL
- en: We then have the UI section, in which we assign all the necessary elements.
    Everything in the hierarchy is named appropriately to make it easy to ensure that
    each field is populated with the correct game object.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have the morality curves that we saw previously. Again, feel free
    to tweak these to your heart's content!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All that's left is to test the example! Hit play, and select some answers. The
    scenario provided puts you in the shoes of an adventurer heading into town. On
    his way, he encounters a goblin, a banker, and a knight. What would you do in
    each scenario? Feel free to play around with the wording, and add your own moral
    dilemmas!
  prefs: []
  type: TYPE_NORMAL
- en: Finding other uses for fuzzy logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzzy data is very peculiar and interesting in that it can be used in tandem
    with all of the major concepts we have introduced in this book. We saw how a series
    of fuzzy logic controllers can easily fit into a behavior tree structure, and
    it's not terribly difficult to imagine how it could be used with an FSM.
  prefs: []
  type: TYPE_NORMAL
- en: Merging with other concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sensory systems also tend to make use of fuzzy logic. While seeing something
    can be a binary condition, in low-light or low-contrast environments, we can suddenly
    see how fuzzy the condition can become. You''ve probably experienced it at night:
    seeing an odd shape, dark in the distance, in the shadows, thinking "is that a
    cat?". It then turns out to be a trash bag, some other animal, or perhaps even
    your imagination. The same can be applied to sounds and smells.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to pathfinding, we run into the cost of traversing certain areas
    of a grid, which a fuzzy logic controller can easily help to fuzzify and make
    more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Should Bob cross the bridge and fight his way through the guards, or risk crossing
    the river and fighting the current? Well, if he's a good swimmer and a poor fighter,
    the choice is clear, right?
  prefs: []
  type: TYPE_NORMAL
- en: Creating a truly unique experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our agents can use fuzzy logic to mimic personalities. Some agents may be more
    "brave" than others. Suddenly, their personal characteristics—how fast they are,
    how far they can run, their size, and so on—can be leveraged to arrive at the
    decisions that are unique to that agent.
  prefs: []
  type: TYPE_NORMAL
- en: Personalities can be applied to enemies, allies and friends, NPCs, or even to
    the rules of the game. The game can take in crisp data from the player's progress,
    style of play, or level of progression, and dynamically adjust the difficulty
    to provide a more unique and personalized challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic can even be used to dole out the technical game rules, such as the
    number of players in a given multiplayer lobby, the type of data to display to
    the player, and even how players are matched against other players. Taking the
    player's statistics and plugging those into a matchmaking system can help keep
    the player engaged by pitting them against the players that either match their
    style of play in a cooperative environment or players of a similar skill level
    in a competitive environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm glad to see that you've made it to the end of the chapter. Fuzzy logic tends
    to become far less fuzzy once you understand the basic concepts. Being one of
    the more pure math concepts in the book, it can be a little daunting if you're
    not familiar with the lingo, but when presented in a familiar context, the mystery
    fades away, and you're left with a very powerful tool to use in your game.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how fuzzy logic is used in the real world, and how it can help illustrate
    vague concepts in a way that binary systems cannot. We also learned how to implement
    our own fuzzy logic controllers using the concepts of member functions, degrees
    of membership, and fuzzy sets. In addition to this, we also played around with
    a faction/morality system to further illustrate the concept of fuzzy logic in
    the context of a choose-your-own-adventure-style interaction. Lastly, we explored
    the various ways in which we can use the resulting data, and how it can help make
    our agents more unique.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we will look at several of the concepts introduced in
    this book working together.
  prefs: []
  type: TYPE_NORMAL
