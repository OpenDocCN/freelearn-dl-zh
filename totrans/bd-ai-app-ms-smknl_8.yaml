- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Real-World Use Case – Making Your Application Available on ChatGPT
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用案例 – 在ChatGPT上使你的应用程序可用
- en: In earlier chapters, we learned quite a lot. We learned how to create and optimize
    prompts, how to create semantic and native functions and put them in Semantic
    Kernel, and how to use a planner to automatically decide which functions of the
    kernel to use to solve a user problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学到了很多。我们学习了如何创建和优化提示，如何创建语义和本地函数并将它们放入Semantic Kernel，以及如何使用规划器自动决定使用内核的哪些功能来解决用户问题。
- en: In the previous two chapters, we learned how to augment our kernel with **memories**,
    including memories built from external data, which allows us to build more personalized
    applications and use data that is recent and that we have control over to generate
    answers, instead of using only the data that was used to train the LLM, which
    is frequently not public.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了如何通过包括从外部数据构建的内存来增强我们的内核，这使我们能够构建更个性化的应用程序，并使用最新且受我们控制的 数据来生成答案，而不是仅使用训练LLM时使用的数据，这些数据通常不是公开的。
- en: In this final chapter, we will change gears. Instead of creating new functionality,
    we will learn how to make the functionality we have already created available
    for many more users. We will use the home automation application that we wrote
    in [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106) and make it available through
    the OpenAI custom **GPT Store**, making it available to the hundreds of millions
    of users that already use ChatGPT, and use ChatGPT as the UI of our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将转换方向。我们将学习如何使我们已经创建的功能对更多的用户可用。我们将使用我们在[*第5章*](B21826_05.xhtml#_idTextAnchor106)中编写的家庭自动化应用程序，并通过OpenAI自定义**GPT商店**使其可用，使其对已经使用ChatGPT的数亿用户开放，并使用ChatGPT作为我们应用程序的用户界面。
- en: Besides the obvious benefits of quickly being able to make an application available
    to hundreds of thousands of users, another benefit is that you don’t even need
    to build a **user interface** (**UI**) for your application. You can build the
    main functionality and use ChatGPT as the UI. Of course, this has limitations.
    The AI is text based and you have little control over it, but on the other hand,
    you can test and deploy your application a lot faster, and build a dedicated UI
    later.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够快速将应用程序提供给数十万用户这一明显的好处之外，另一个好处是，你甚至不需要为你的应用程序构建**用户界面**（**UI**）。你可以构建主要功能，并使用ChatGPT作为UI。当然，这也有局限性。AI是基于文本的，你对它的控制很少，但另一方面，你可以更快地测试和部署你的应用程序，并在以后构建专门的UI。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a custom GPT in the OpenAI store
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenAI商店中创建自定义GPT
- en: Creating a web API wrapper for an application developed with Semantic Kernel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为使用Semantic Kernel开发的程序创建一个Web API包装器
- en: Connecting the custom GPT with the OpenAI store through the web API wrapper
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Web API包装器将自定义GPT连接到OpenAI商店
- en: By the end of the chapter, you will have an application that is available to
    all ChatGPT users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个对所有ChatGPT用户都开放的应用程序。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need to have a recent, supported version
    of your preferred Python or C# development environment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要拥有你首选的Python或C#开发环境的最新、受支持的版本：
- en: For Python, the minimum supported version is Python 3.10, and the recommended
    version is Python 3.11
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Python，最低支持的版本是Python 3.10，推荐版本是Python 3.11
- en: For C#, the minimum supported version is .NET 8
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于C#，最低支持的版本是.NET 8
- en: In this chapter, we will call OpenAI services. Given the amount that companies
    spend on training these LLMs, it’s no surprise that using these services is not
    free. You will need an **OpenAI API** key, obtained either directly through **OpenAI**
    or **Microsoft**, via the **Azure** **OpenAI** service.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将调用OpenAI服务。鉴于公司在这类LLM训练上的投入，使用这些服务不是免费的也就不足为奇了。你需要一个**OpenAI API**密钥，可以通过**OpenAI**或**Microsoft**直接获得，或者通过**Azure**
    **OpenAI**服务。
- en: If you are using .NET, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch8](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch8).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用.NET，本章的代码位于[https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch8](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch8)。
- en: If you are using Python, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch8](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch8).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Python，本章的代码位于 [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch8](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch8)。
- en: To create your custom GPT, you will need an account with OpenAI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的自定义 GPT，你需要一个 OpenAI 账户。
- en: 'You can install the required packages by going to the GitHub repository and
    using the following: `pip install -``r requirements.txt`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 GitHub 仓库并使用以下命令安装所需的包：`pip install -r requirements.txt`。
- en: Custom GPT agents
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 GPT 代理
- en: On November 6, 2023, OpenAI introduced functionality that allows users to create
    custom, personalized versions of ChatGPT. These custom GPTs created by users can
    be shared with other users through OpenAI’s GPT Store. This allows users without
    programming experience to add functionality to ChatGPT by simply writing instructions
    in natural language, and it also allows users with programming experience to connect
    ChatGPT to their applications, making such applications available to hundreds
    of millions of users.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 2023 年 11 月 6 日，OpenAI 推出了一种功能，允许用户创建自定义的、个性化的 ChatGPT 版本。这些由用户创建的自定义 GPT 可以通过
    OpenAI 的 GPT 商店与其他用户共享。这使得没有编程经验的用户可以通过简单地用自然语言编写指令来向 ChatGPT 添加功能，同时也允许有编程经验的用户将
    ChatGPT 连接到他们的应用程序，使这些应用程序可供数亿用户使用。
- en: Initially, these were called “custom GPTs,” but now they are simply called GPTs.
    That may be confusing since the transformer technology used in most AI models
    is called **generative pre-trained transformer** (**GPT**), and the OpenAI implementation
    of these models is also called GPT with a version, such as GPT-3.5 or GPT 4.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这些被称为“自定义 GPT”，但现在它们简单地被称为 GPT。这可能有些令人困惑，因为大多数 AI 模型中使用的 Transformer 技术被称为
    **生成式预训练 Transformer**（**GPT**），而 OpenAI 对这些模型的实现也被称为 GPT，带有版本号，如 GPT-3.5 或 GPT
    4。
- en: In this section, when we use the name “GPT,” unless otherwise noted, it means
    the custom GPTs that you can create inside of ChatGPT.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，当我们使用“GPT”这个名字时，除非另有说明，它指的是你可以在 ChatGPT 内部创建的自定义 GPT。
- en: These GPTs can use custom prompts, such as the ones we use in semantic functions,
    and additional data, such as what we use in RAG models. You can add custom prompts
    and documents to your custom GPT by using a web interface, which we will show
    in the next subsection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 GPT 可以使用自定义提示，例如我们在语义函数中使用的提示，以及额外的数据，例如我们在 RAG 模型中使用的。你可以通过使用 Web 界面将自定义提示和文档添加到你的自定义
    GPT 中，我们将在下一小节中展示。
- en: In addition, you can also allow your GPT to call external functions through
    a web API. Many companies created these interfaces and connected them to custom
    GPTs, such as Wolfram (the creators of the scientific software Mathematica), design
    companies such as Canva and Adobe, and many others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以允许你的 GPT 通过 Web API 调用外部函数。许多公司创建了这些接口并将它们连接到自定义 GPT，例如 Wolfram（科学软件
    Mathematica 的创造者）、设计公司如 Canva 和 Adobe，以及其他许多公司。
- en: In this section, as we did [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106),
    imagine you work for a home automation company that has a product that allows
    someone to control their home through a device in their house, and now you want
    to allow them to do it with ChatGPT. We created the native function for this in
    [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106), and in this chapter, we are going
    to use Microsoft Semantic Kernel tools to make that functionality available for
    ChatGPT users.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，正如我们在 [*第五章*](B21826_05.xhtml#_idTextAnchor106) 中所做的那样，想象你为一家智能家居公司工作，该公司有一种产品允许某人通过他们家里的设备控制他们的家，现在你想要让他们通过
    ChatGPT 来实现这一点。我们在 [*第五章*](B21826_05.xhtml#_idTextAnchor106) 中为这个功能创建了原生函数，在本章中，我们将使用
    Microsoft Semantic Kernel 工具使该功能对 ChatGPT 用户可用。
- en: Before we start that more complex example, let’s first create a simpler custom
    GPT just to familiarize ourselves with the process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更复杂的示例之前，让我们先创建一个更简单的自定义 GPT，以便熟悉这个过程。
- en: Creating a custom GPT
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义 GPT
- en: To create a GPT, you can navigate to [https://chat.openai.com/gpts/](https://chat.openai.com/gpts/)
    and click the **Create** button on the top-right corner, or navigate directly
    to [https://chat.openai.com/gpts/editor](https://chat.openai.com/gpts/editor).
    This will open a web interface that allows you to create a GPT. As you’d expect,
    you can create the GPT simply by chatting with ChatGPT. You can add custom instructions,
    specify the tone of the answers, and much more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个GPT，您可以导航到[https://chat.openai.com/gpts/](https://chat.openai.com/gpts/)并点击右上角的**创建**按钮，或者直接导航到[https://chat.openai.com/gpts/editor](https://chat.openai.com/gpts/editor)。这将打开一个网络界面，允许您创建一个GPT。正如您所期望的，您可以通过与ChatGPT聊天来简单地创建GPT。您可以添加自定义指令，指定答案的语气，等等。
- en: '![Figure 8.1 – Creating a GPT using the OpenAI editor](img/B21826_08_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 使用OpenAI编辑器创建GPT](img/B21826_08_1.jpg)'
- en: Figure 8.1 – Creating a GPT using the OpenAI editor
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 使用OpenAI编辑器创建GPT
- en: 'The **Configure** tab is where you will give your GPT a name and description,
    and where you can add custom actions that connect your GPT with external APIs:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置**标签页是您为您的GPT命名和描述的地方，您还可以在此处添加自定义操作，以将您的GPT与外部API连接：'
- en: '![Figure 8.2 – The OpenAI UI to configure your GPT](img/B21826_08_2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – OpenAI配置您的GPT的用户界面](img/B21826_08_2.jpg)'
- en: Figure 8.2 – The OpenAI UI to configure your GPT
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – OpenAI配置您的GPT的用户界面
- en: You can use the `I want to make a GPT that answers questions about Sherlock
    Holmes` and it answered back with `How about naming it Detective Guide? Does that
    sound good to you?`. I answered back with `Yes`, and the configuration was updated,
    adding `Detective Guide` as the name. Without asking, ChatGPT also automatically
    generated an appropriate profile picture for my GPT.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用“我想创建一个回答关于夏洛克·福尔摩斯问题的GPT”并得到它回答“给它起个侦探指南的名字怎么样？这对你来说听起来好吗？”的回复。我回答“是的”，配置被更新，添加了“侦探指南”作为名称。ChatGPT没有询问，也自动为我的GPT生成了一张合适的头像。
- en: 'I did a few more configuration steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我还进行了几个额外的配置步骤：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I also uploaded the text files with the contents of the books, which you can
    find online and also in `/data/sherlock_holmes/`, and added this additional configuration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我还上传了包含书籍内容的文本文件，这些文件您可以在网上找到，也可以在`/data/sherlock_holmes/`中找到，并添加了以下附加配置：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After every configuration step, ChatGPT asks me if there’s anything more I
    want to add. At this point, I said `no`, which enabled the **Create** button on
    the top-right corner again. Once I pressed it, I got the option to share my GPT:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每完成一个配置步骤后，ChatGPT都会问我是否还有其他想要添加的内容。在这个时候，我说“没有”，这再次启用了右上角的**创建**按钮。一旦我按下它，我就有了分享我的GPT的选项：
- en: '![Figure 8.3 – Sharing your GPT in the GPT Store](img/B21826_08_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 在GPT商店中分享您的GPT](img/B21826_08_3.jpg)'
- en: Figure 8.3 – Sharing your GPT in the GPT Store
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 在GPT商店中分享您的GPT
- en: I chose **Publish to GPT Store**, which will make it available to all ChatGPT
    users. The completed version, created only with the preceding minimal instructions,
    can be accessed at [https://chat.openai.com/g/g-yJvyO2vHq-detective-guide](https://chat.openai.com/g/g-yJvyO2vHq-detective-guide).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了**发布到GPT商店**，这将使它对所有ChatGPT用户可用。仅使用前面的最小指令创建的完整版本可以在[https://chat.openai.com/g/g-yJvyO2vHq-detective-guide](https://chat.openai.com/g/g-yJvyO2vHq-detective-guide)访问。
- en: 'This is what it looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '![Figure 8.4 – The initial version of the Sherlock Holmes GPT, Detective Guide](img/B21826_08_4.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 夏洛克·福尔摩斯GPT的初始版本，侦探指南](img/B21826_08_4.jpg)'
- en: Figure 8.4 – The initial version of the Sherlock Holmes GPT, Detective Guide
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 夏洛克·福尔摩斯GPT的初始版本，侦探指南
- en: One thing to notice is what little configuration I had to perform. I uploaded
    a few text files with the text of the books and wrote a few hundred words of configuration
    in natural language.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，我需要进行的配置非常少。我只上传了几本书的文字文本文件，并用自然语言编写了几百字的配置。
- en: 'To test it, I asked `What''s Holmes attic theory?`, and its answer, shown in
    the following, answers the question and correctly identifies the book it comes
    from:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我问“福尔摩斯的阁楼理论是什么？”以下是其回答，正确地回答了问题并指出了它来自哪本书：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition, because I asked the GPT to not answer questions outside of its
    knowledge domain, it tries to keep things on topic, as the following dialogue
    exemplifies:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我要求GPT不要回答其知识领域之外的问题，它试图保持话题相关，以下对话就是一个例子：
- en: '![Figure 8.5 – Asking the GPT about astronomy and Sherlock Holmes’ astronomy
    knowledge](img/B21826_08_5.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 向GPT询问天文学和夏洛克·福尔摩斯的天文学知识](img/B21826_08_5.jpg)'
- en: Figure 8.5 – Asking the GPT about astronomy and Sherlock Holmes’ astronomy knowledge
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 向GPT询问天文学和福尔摩斯的天文学知识
- en: If it’s so easy to create a custom GPT, why write any code?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建一个自定义的GPT如此简单，为什么还要编写任何代码呢？
- en: When GPT models started to become mainstream, several entrepreneurs created
    applications that were nothing more than GPT-3.5 with a few additional instructions.
    These apps were released on the web, like what we just did with the Detective
    Guide.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当GPT模型开始变得主流时，几位企业家创建了应用程序，这些应用程序不过是添加了一些额外说明的GPT-3.5。这些应用程序在网上发布，就像我们刚才做的侦探指南一样。
- en: 'If the functionality of your application can be replicated by adding a few
    additional instructions to ChatGPT, creating a custom GPT may be a good option
    for you. If you try to release it as a separate app and charge users, it’s possible
    for a competitor to replicate your success by simply creating a custom GPT and
    offering it to all ChatGPT users. Monetization for these GPTs is still unclear,
    but apparently, it will work in the same way as Spotify or Kindle Unlimited: GPTs
    that get enough users receive a fraction of the money paid by subscribers.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序的功能可以通过向ChatGPT添加一些额外说明来复制，那么创建一个自定义GPT可能对你来说是一个好选择。如果你尝试将其作为独立应用程序发布并收费，竞争对手可能只需创建一个自定义GPT并将其提供给所有ChatGPT用户，就能复制你的成功。这些GPT的货币化方式尚不明确，但显然，它们将以Spotify或Kindle
    Unlimited相同的方式工作：获得足够用户的GPT将获得订阅者支付的一部分费用。
- en: 'There are a few cases in which these custom GPTs in ChatGPT don’t work at all.
    For example, you can’t use it to add AI functionality to your existing application.
    You also don’t have a lot of control: custom GPTs don’t allow you to fine-tune
    your prompts, process the inputs and outputs of functions, monitor usage, change
    the sensitivity of search when retrieving documents, and so on, so you have a
    lot less control over the user experience.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，ChatGPT中的这些自定义GPT根本不起作用。例如，你不能用它来给你的现有应用程序添加AI功能。你也没有太多的控制权：自定义GPT不允许你微调你的提示，处理函数的输入和输出，监控使用情况，在检索文档时更改搜索的敏感性等等，因此你对用户体验的控制要少得多。
- en: Now that we have created a simple version of a custom GPT, let’s create one
    that supports actions. We are going to use the home automation native plugin that
    we created in [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106) and pretend that
    we have a company that allows users to automate some functions in their house,
    such as turning the lights on and off and turning on the TV. We’re going to create
    a custom GPT that allows users to use ChatGPT to control the functionality of
    their house.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个简单的自定义GPT版本，让我们创建一个支持操作的自定义GPT。我们将使用我们在[*第5章*](B21826_05.xhtml#_idTextAnchor106)中创建的智能家居原生插件，并假设我们有一家公司允许用户自动化他们家中的一些功能，例如开关灯和打开电视。我们将创建一个自定义GPT，允许用户使用ChatGPT控制他们家的功能。
- en: Creating a custom GPT that supports actions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建支持操作的自定义GPT
- en: Like what we have done in the previous subsection, we start by navigating to
    [https://chat.openai.com/gpts/](https://chat.openai.com/gpts/) and clicking the
    **Create** button in the top-right corner, or navigating directly to [https://chat.openai.com/gpts/editor](https://chat.openai.com/gpts/editor).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的子节中做的那样，我们首先导航到[https://chat.openai.com/gpts/](https://chat.openai.com/gpts/)并点击右上角的**创建**按钮，或者直接导航到[https://chat.openai.com/gpts/editor](https://chat.openai.com/gpts/editor)。
- en: 'Instead of using the chat interface to create this custom GPT, I went directly
    to the **Configure** tab and added the following instructions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有使用聊天界面来创建这个自定义GPT，而是直接转到**配置**选项卡，并添加了以下说明：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I also named my GPT `SKB Home Automation Example`, where **SKB** stands for
    **Semantic Kernel Book**. You can leave most other options as their defaults,
    although you likely want to uncheck **Web Browsing** and **DALL-E Image Generation**
    under **Capabilities**, as these won’t be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我还给我的GPT命名为`SKB智能家居示例`，其中**SKB**代表**语义内核书**。你可以将大多数其他选项保留为默认设置，尽管你可能希望取消选中**能力**下的**网络浏览**和**DALL-E图像生成**，因为这些将不会使用。
- en: Once you are done, you can click **Create** on the top-right side of the screen,
    and this will create a custom GPT, which you can choose to keep to yourself, share
    with a link, or share in the GPT Store.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以在屏幕右上角点击**创建**，这将创建一个自定义GPT，你可以选择保留给自己，通过链接分享，或者在GPT商店分享。
- en: 'Whatever you choose, now you can send requests to the GPT. Note that we have
    not connected our native plugin to the GPT yet, so if you ask the GPT to perform
    something, such as `open the garage door`, it will immediately hallucinate, as
    shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择什么，现在你都可以向GPT发送请求。请注意，我们还没有将我们的原生插件连接到GPT，所以如果你要求GPT执行某些操作，比如`打开车库门`，它将立即产生幻觉，如下所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'ChatGPT makes up several things in this answer: an API, a `curl` command, an
    authentication method, whether you can send commands to an IP address, and so
    on. None of those things are true; it’s just trying its best to provide an answer.
    This problem will be solved when we connect ChatGPT with our real API, which we
    are going to do in the next section.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT在这个答案中假设了几件事情：一个API、一个`curl`命令、一个认证方法、是否可以向IP地址发送命令等等。这些都不是真的；它只是在尽力提供答案。当我们把ChatGPT与我们的真实API连接起来时，这个问题就会得到解决，我们将在下一节中这样做。
- en: A note about security
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全性的说明
- en: When you share your GPT and your API with hundreds of millions of users, there’s
    a real possibility that some of them will use it in ways that you have not thought
    about. We will not cover security in detail in this book, but this doesn’t mean
    that you should not think about it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将你的GPT和API与数亿用户分享时，确实有可能有些人会以你未曾想到的方式使用它。在这本书中，我们不会详细讨论安全问题，但这并不意味着你不应该考虑它。
- en: In the next section, we will connect an API to ChatGPT without any authentication,
    but for a production application, you should add authentication to the connection
    between GPT and your API. Most importantly, you should add monitoring to your
    API, so you can see if usage patterns are changing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将连接一个API到ChatGPT而不进行任何认证，但对于生产应用程序，你应该在GPT和你的API之间添加认证。最重要的是，你应该对你的API添加监控，这样你就可以看到使用模式是否在变化。
- en: Even the most basic monitoring that just counts how many calls you have had
    per minute is likely sufficient to prevent the worst forms of abuse. Once you
    have monitoring, you can also add rate limiting, to prevent malicious users from
    overwhelming your API with repeated calls.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最基本的监控，比如每分钟统计你接收了多少次调用，也可能足以防止最严重的滥用行为。一旦你有了监控，你还可以添加速率限制，以防止恶意用户通过重复调用压倒你的API。
- en: Creating a web API wrapper for the native function
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为原生函数创建网络API包装器
- en: 'First, let’s define our native function. This is the same function I used in
    [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106), but I used only `OperateLight`
    and `OperateGarageDoor` for brevity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的原生函数。这是我用在[*第五章*](B21826_05.xhtml#_idTextAnchor106)中的同一个函数，但我只使用了`OperateLight`和`OperateGarageDoor`以简化：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we need to build a web API to make that function callable from the web
    by ChatGPT.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要构建一个网络API，以便ChatGPT可以从网络上调用该函数。
- en: Creating a web API wrapper in Python
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中创建网络API包装器
- en: 'In Python, we are going to use the Flask library. In Flask, we’re going to
    create two routes: `operate_light` and `operate_garage_door`. First, we create
    an app:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们将使用Flask库。在Flask中，我们将创建两个路由：`operate_light`和`operate_garage_door`。首先，我们创建一个应用程序：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating the app is simple, requiring just the calling of the `Flask` constructor
    and setting a `secret_key` property that can be used to sign cookies coming from
    your app. This app will not have cookies, so the secret key can be anything, including
    a random string.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序很简单，只需要调用`Flask`构造函数并设置一个`secret_key`属性，该属性可以用来签名来自应用程序的cookie。这个应用程序将不会有cookie，所以密钥可以是任何东西，包括一个随机字符串。
- en: 'Now, we will define the routes for our API:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义API的路由：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The structure of each route is the same: we create a kernel, add a GPT service
    to it, import the `HomeAutomation` plugin, and invoke the appropriate function,
    returning its answer.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由的结构都是相同的：我们创建一个内核，向其中添加一个GPT服务，导入`HomeAutomation`插件，并调用适当的函数，返回其答案。
- en: 'You can add these two lines of code to the application to allow for local testing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这两行代码添加到应用程序中，以便进行本地测试：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To test the application locally, go to a command line and type the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地测试应用程序，请打开命令行并输入以下内容：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create a local web server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个本地网络服务器：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, you can send commands to the local web server using `curl` if you are
    using bash, or `Invoke-RestMethod` if you are using PowerShell. Here, we are invoking
    the `operate_light` route with `"action": "on"` and `"``location": "bedroom"`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，如果你使用bash，你可以使用`curl`向本地网络服务器发送命令；如果你使用PowerShell，你可以使用`Invoke-RestMethod`。在这里，我们正在调用`operate_light`路由，参数为`"action":
    "on"`和`"location": "bedroom"`：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result, as expected, is that the application responds successfully:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，正如预期的那样，应用程序成功响应：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we verified that the web application is working, we can deploy it on
    the web.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了 Web 应用程序正在工作，我们可以在 Web 上部署它。
- en: Creating a web API wrapper in C#
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 C# 中创建 Web API 包装器
- en: '.NET makes it easy to create a boilerplate web API application. You can use
    the following command and it will create a web API under the `SkHomeAutomation`
    directory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 使得创建模板化的 Web API 应用程序变得简单。你可以使用以下命令，它将在 `SkHomeAutomation` 目录下创建一个 Web
    API：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Don’t forget to install the `Microsoft.SemanticKernel` package, too:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记安装 `Microsoft.SemanticKernel` 包：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `dotnet new webapi` command helpfully generates the code for a weather
    forecasting web application that provides a web API. One of the files it generates
    is a module called `WeatherForecast.cs`. You can delete this file, as we will
    replace it with our own functionality. To do so, copy the `HomeAutomation.cs`
    file from [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106) to the root of this
    project. To make our life easier, add the following line to the beginning of the
    file, which will allow you to reference the `HomeAutomation` object more easily:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet new webapi` 命令有助于生成一个提供 Web API 的天气预报 Web 应用程序的代码。它生成的其中一个文件是一个名为 `WeatherForecast.cs`
    的模块。你可以删除此文件，因为我们将会用我们自己的功能替换它。为此，将 `HomeAutomation.cs` 文件从 [*第 5 章*](B21826_05.xhtml#_idTextAnchor106)
    复制到本项目的根目录。为了使我们的工作更简单，在文件开头添加以下行，这将允许你更容易地引用 `HomeAutomation` 对象：'
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last thing you need to do is to go into the `Controllers` directory. It
    will contain a `WeatherForecastController.cs` file. You can delete this file and
    replace it with the `HomeAutomationController.cs` file, which is here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是进入 `Controllers` 目录。它将包含一个 `WeatherForecastController.cs` 文件。你可以删除此文件，并用这里的
    `HomeAutomationController.cs` 文件替换它，如下所示：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`HomeAutomationController` exposes the `operate_light` and `operate_garage_door`
    web API paths, and when those are called, it routes the request to the corresponding
    method of the `HomeAutomation` class that we created in [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106),
    essentially exposing our Semantic Kernel application to the web, once it’s deployed.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomeAutomationController` 暴露了 `operate_light` 和 `operate_garage_door` Web
    API 路径，当调用这些路径时，它将请求路由到我们在 [*第 5 章*](B21826_05.xhtml#_idTextAnchor106) 中创建的 `HomeAutomation`
    类的相应方法，本质上在部署后向 Web 暴露我们的语义内核应用程序。'
- en: The next step, whether you created the application in C# or Python, is to deploy
    the application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个步骤，无论你是用 C# 还是 Python 创建的应用程序，都是部署应用程序。
- en: Deploying your application to an Azure Web App
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将你的应用程序部署到 Azure Web App
- en: To deploy your application on the web, you need to have an Azure account. Go
    to the Azure portal at [https://portal.azure.com](https://portal.azure.com), and
    from the home page, click **Create a Resource** and then **Create a Web App**.
    As you will see here, we can use the free tier for our test, but if you plan to
    deploy something like this for a real application, you should choose a different
    plan.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Web 上部署你的应用程序，你需要一个 Azure 账户。访问 Azure 门户 [https://portal.azure.com](https://portal.azure.com)，然后从主页点击
    **Create a Resource**，然后点击 **Create a Web App**。正如你将看到的，我们可以为测试使用免费层，但如果你计划为真实应用程序部署类似的应用程序，你应该选择不同的计划。
- en: 'In *Figure 8**.6*, I show how I created mine: I created a new resource group
    called `skb-rg`, named my application `skb-home-automation`, which gives it the
    `skb-home-automation.azurewebsites.net` URL, and chose Python 3.11 (Python) or
    .NET 8 LTS (C#) for its runtime stack.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.6* 中，我展示了我是如何创建的：我创建了一个名为 `skb-rg` 的新资源组，将我的应用程序命名为 `skb-home-automation`，这给了它
    `skb-home-automation.azurewebsites.net` 的 URL，并为其选择了 Python 3.11 (Python) 或 .NET
    8 LTS (C#) 作为其运行时堆栈。
- en: 'Under `skb-sp`, and chose the **Free F1** pricing plan. Once these configurations
    are done, click **Review + create** and your web application will be deployed
    in a few minutes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `skb-sp` 下，选择 **Free F1** 定价计划。一旦完成这些配置，点击 **Review + create**，你的 Web 应用程序将在几分钟内部署：
- en: '![Figure 8.6 – Creating a free web app to host our API](img/B21826_08_6.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 创建一个免费的 Web 应用程序以托管我们的 API](img/B21826_08_6.jpg)'
- en: Figure 8.6 – Creating a free web app to host our API
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 创建一个免费的 Web 应用程序以托管我们的 API
- en: The simplest way to deploy your API to the web application is through GitHub.
    To do so, we need to create a new, clean GitHub repository for this web API and
    copy the contents of [https://github.com/PacktPublishing/Microsoft-Semantic-Kernel/tree/main/python/ch8](https://github.com/PacktPublishing/Microsoft-Semantic-Kernel/tree/main/python/ch8)
    to it. This needs to be a separate repository because you need to deploy the full
    repository to the web application. For example, you can put your copy at an address
    such as `https://github.com/<your-github-username>/skb-home-automation`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的API部署到Web应用程序的最简单方法是使用GitHub。为此，我们需要为这个Web API创建一个新的、干净的GitHub仓库，并将[https://github.com/PacktPublishing/Microsoft-Semantic-Kernel/tree/main/python/ch8](https://github.com/PacktPublishing/Microsoft-Semantic-Kernel/tree/main/python/ch8)的内容复制到其中。这需要是一个单独的仓库，因为您需要将整个仓库部署到Web应用程序中。例如，您可以将您的副本放在如`https://github.com/<your-github-username>/skb-home-automation`这样的地址上。请注意，我的API版本对您不可用；您必须部署自己的。
- en: In your web application, go to **Deployment Center**, and select **GitHub**
    as the source. In **Organization**, select your username. Choose the repository.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Web应用程序中，转到**部署中心**，选择**GitHub**作为源。在**组织**中，选择您的用户名。选择仓库。
- en: This will create and deploy the web API under your own account.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您自己的账户下创建和部署Web API。
- en: '![Figure 8.7 – Deploying the web API using GitHub](img/B21826_08_7.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 使用GitHub部署Web API](img/B21826_08_7.jpg)'
- en: Figure 8.7 – Deploying the web API using GitHub
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 使用GitHub部署Web API
- en: Once the web API is deployed, you can test it using `curl` or `Invoke-RestApi`.
    The only change is that instead of using localhost as the endpoint, you need to
    change it to the endpoint you deployed to. In my case, I chose `skb-home-automation.azurewebsites.net`
    (your case will be different). Please note that my version of the API will not
    be available for you; you must deploy your own.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Web API部署完成，您可以使用`curl`或`Invoke-RestApi`对其进行测试。唯一的变化是，您需要将端点从localhost更改为您部署的端点。在我的情况下，我选择了`skb-home-automation.azurewebsites.net`（您的情况将不同）。请注意，我的API版本对您不可用；您必须部署自己的。
- en: 'Therefore, we can submit the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以提交以下内容：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result will be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have a web API that is working, we need to connect the API with
    ChatGPT.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个正在工作的Web API，我们需要将API与ChatGPT连接起来。
- en: Connecting the custom GPT with your custom GPT action
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将定制GPT与您的定制GPT操作连接
- en: To connect our web API with our custom GPT, we need to give it an OpenAPI specification.
    ChatGPT makes it very easy to generate one.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的Web API与我们的定制GPT连接，我们需要给它一个OpenAPI规范。ChatGPT使生成一个变得非常简单。
- en: 'First, go to our custom GPT, select the dropdown from its name, and select
    **Edit GPT**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到我们的定制GPT，从其名称中选择下拉菜单，并选择**编辑GPT**：
- en: '![Figure 8.8 – Editing our GPT](img/B21826_08_8.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 编辑我们的GPT](img/B21826_08_8.jpg)'
- en: Figure 8.8 – Editing our GPT
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 编辑我们的GPT
- en: 'On the bottom of the **Configuration** tab, click on **Create new action**,
    under **Actions**. This will bring up the **Add** **actions** UI:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在**配置**选项卡的底部，点击**动作**下的**创建新操作**。这将打开**添加动作**UI：
- en: '![Figure 8.9 –  Adding actions to our GPT](img/B21826_08_9.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 向我们的GPT添加操作](img/B21826_08_9.jpg)'
- en: Figure 8.9 – Adding actions to our GPT
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 向我们的GPT添加操作
- en: 'To add actions, you need to specify a schema using a language called **OpenAPI**.
    ChatGPT makes this extremely easy: clicking on **Get help from ActionGPT** will
    open a chat dialog with another custom GPT that can help you create OpenAPI specifications:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加操作，您需要使用名为**OpenAPI**的语言指定一个模式。ChatGPT使这变得极其简单：点击**从ActionGPT获取帮助**将打开一个与另一个可以帮您创建OpenAPI规范的定制GPT的聊天对话框：
- en: '![Figure 8.10 – Using ActionsGPT](img/B21826_08_10.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 使用ActionsGPT](img/B21826_08_10.jpg)'
- en: Figure 8.10 – Using ActionsGPT
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 使用ActionsGPT
- en: 'In ActionsGPT, all you need to do is paste the code of our web API, and it
    will automatically generate the OpenAPI specification. What was automatically
    generated is in the following, but we’ll need to make a couple of changes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在ActionsGPT中，您需要做的只是粘贴我们Web API的代码，它将自动生成OpenAPI规范。自动生成的内容如下，但我们需要做一些修改：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notably, it doesn’t know the name of my server or the restrictions of the places
    where lights are installed. It also tries to guess the commands. Therefore, we
    must add the correct restrictions to the specification. Another detail to note
    is that I have the `x-openai-isConsequential: false` parameter for all endpoints.
    When that parameter is `true` or blank, ChatGPT will ask for confirmation for
    each command that is issued. For our purposes, we don’t need that, but your use
    case might require it, for example, when a user decides to make a payment.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '值得注意的是，它不知道我的服务器的名称或灯光安装地点的限制。它还试图猜测命令。因此，我们必须在规范中添加正确的限制。另一个需要注意的细节是，我所有的端点都有
    `x-openai-isConsequential: false` 参数。当该参数为 `true` 或空白时，ChatGPT 将对每个发出的命令请求确认。对于我们的目的，我们不需要这个，但您的用例可能需要它，例如，当用户决定进行支付时。'
- en: 'The fixed version is here, with the changes highlighted in bold:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修正后的版本，更改内容以粗体突出显示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can paste this corrected version into the **Schema** box and click **Update**
    in the top-right corner. This will deploy the custom GPT with the connection to
    the native application you developed with Semantic Kernel.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这个修正后的版本粘贴到**模式**框中，并在右上角点击**更新**。这将部署与您使用语义内核开发的本地应用程序连接的自定义 GPT。
- en: 'Here, you will see an example of a real dialog with our custom GPT, where I
    ask it to operate several devices:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到一个与我们的自定义 GPT 的真实对话示例，其中我要求它操作几个设备：
- en: '![Figure 8.11 – Using our SKB Home Automation custom GPT](img/B21826_08_11.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 使用我们的 SKB 家居自动化自定义 GPT](img/B21826_08_11.jpg)'
- en: Figure 8.11 – Using our SKB Home Automation custom GPT
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 使用我们的 SKB 家居自动化自定义 GPT
- en: '![Figure 8.12 – Using our SKB Home Automation custom GPT](img/B21826_08_12.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 使用我们的 SKB 家居自动化自定义 GPT](img/B21826_08_12.jpg)'
- en: Figure 8.12 – Using our SKB Home Automation custom GPT
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 使用我们的 SKB 家居自动化自定义 GPT
- en: 'First, I asked the GPT to open my garage door. It correctly called the API
    with the appropriate command. Next, I asked it a complex command: to close my
    garage door and turn off all the lights. As you can see from *Figure 8**.12*,
    it issued five commands. Looking at the log of the web API, you would be able
    to see that the commands were correctly sent:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要求 GPT 打开我的车库门。它正确地使用适当的命令调用了 API。接下来，我要求它执行一个复杂的命令：关闭我的车库门并关闭所有灯光。如*图 8**.12
    所示，它发出了五个命令。查看 Web API 的日志，您将能够看到命令被正确发送：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If I ask for a command that it cannot execute, it also correctly responds with
    what it can do:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要求一个它无法执行的命令，它也会正确地回应它能做什么：
- en: '![Figure 8.13 – Issuing an invalid command to the custom GPT](img/B21826_08_13.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 向自定义 GPT 发出无效命令](img/B21826_08_13.jpg)'
- en: Figure 8.13 – Issuing an invalid command to the custom GPT
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 向自定义 GPT 发出无效命令
- en: 'The two main consequences of connecting an application with a custom GPT are
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序与自定义 GPT 连接的两个主要后果如下：
- en: '`turn off all my lights`, and ChatGPT will parse them and send them to your
    application. If users ask for functions that are not available in your application,
    ChatGPT tells them what can and cannot be done.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`关闭我所有的灯`，ChatGPT 将解析它们并将它们发送到您的应用程序。如果用户请求应用程序中不可用的功能，ChatGPT 会告诉他们可以做什么和不能做什么。'
- en: '**Your application gets wide distribution and access to all UI facilities provided
    by ChatGPT**: Everyone with access to ChatGPT can use your application, even from
    their phones. They can also use the application with their voices because ChatGPT
    supports voice commands.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您的应用程序获得广泛的分布和访问 ChatGPT 提供的所有 UI 设施的权限**：任何可以访问 ChatGPT 的人都可以使用您的应用程序，甚至可以从他们的手机上使用。他们还可以使用语音来使用该应用程序，因为
    ChatGPT 支持语音命令。'
- en: In this section, we have seen how to connect an app we wrote with ChatGPT, enabling
    it to be used by the hundreds of millions of ChatGPT users.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何将我们编写的应用程序与 ChatGPT 连接起来，使其能够被数亿 ChatGPT 用户使用。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we connected an application with OpenAI’s ChatGPT by developing
    a custom GPT and adding custom actions to it. This can enable applications to
    get access to a planner that is based on the latest model available to ChatGPT
    users, which is usually a very advanced model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过开发自定义 GPT 并向其添加自定义操作，将应用程序与 OpenAI 的 ChatGPT 连接起来。这可以使应用程序获得访问基于 ChatGPT
    用户最新模型的规划器的权限，这通常是一个非常先进的模型。
- en: In addition, what we have learned allows you to deploy your application to hundreds
    of millions of users with minimal effort and get access to several new features
    available to ChatGPT users, such as natural language requests and voice requests.
    It also allows you to deploy your application to users more quickly, as you don’t
    have to develop a UI yourself – you can use ChatGPT as the UI as you develop and
    grow your application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们所学到的东西让你可以以最小的努力将你的应用程序部署给数亿用户，并获得ChatGPT用户可用的几个新功能，例如自然语言请求和语音请求。这也允许你更快地将你的应用程序部署给用户，因为你不必自己开发UI——你可以在开发并扩展你的应用程序时使用ChatGPT作为UI。
- en: If you are a Python programmer, Microsoft Semantic Kernel provides a few additional
    features over what is already provided by the default OpenAI Python API. Among
    other things, you get the separation between prompt and code, native functions,
    planners, core plugins, and interfaces with memory. All of this can cut the time
    you will spend creating and maintaining your code. With the amount of change happening
    in AI these days, it’s great to be able to save some time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名Python程序员，Microsoft Semantic Kernel在默认的OpenAI Python API提供的基础上增加了几个额外功能。其中，你得到了提示和代码之间的分离、原生函数、规划器、核心插件以及与内存的接口。所有这些都可以缩短你创建和维护代码所需的时间。鉴于目前AI领域的变化量，能够节省一些时间是件好事。
- en: If you are a C# developer, in addition to getting the benefits that the Python
    programmers get, you will also find that Microsoft Semantic Kernel is the best
    way of connecting a C# application to OpenAI models, as OpenAI does not provide
    a C# API. You can do a lot with REST APIs, as we have shown when we created DALL-E
    3 images in [*Chapter 4*](B21826_04.xhtml#_idTextAnchor086), but REST APIs are
    cumbersome and have changed in the last year. Using the Microsoft Semantic Kernel
    greatly simplifies things, and when changes happen, it’s likely that they will
    be incorporated in a future release.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名C#开发者，除了可以获得Python程序员所获得的好处之外，你还会发现，与OpenAI不提供C# API相比，Microsoft Semantic
    Kernel是将C#应用程序连接到OpenAI模型的最佳方式。你可以用REST API做很多事情，正如我们在创建DALL-E 3图像时在[*第4章*](B21826_04.xhtml#_idTextAnchor086)中展示的那样，但REST
    API使用起来繁琐，并且在过去一年中有所变化。使用Microsoft Semantic Kernel大大简化了这些事情，并且当发生变化时，它们很可能会在未来版本中集成。
- en: For now, this concludes our journey with Microsoft Semantic Kernel. As a parting
    thought, Semantic Kernel and AI models are just tools. Your impact on the world
    depends on how you use these tools. In my career, I have been fortunate to be
    able to use technology, and lately, AI, for social good. I hope you can do the
    same.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们与Microsoft Semantic Kernel的旅程告一段落。作为一个临别思考，Semantic Kernel和AI模型只是工具。你对世界的影响取决于你如何使用这些工具。在我的职业生涯中，我很幸运能够使用技术，最近则是AI，为社会做出贡献。我希望你也能做到同样的事情。
