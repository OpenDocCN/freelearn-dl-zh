<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-268">
    <a id="_idTextAnchor270">
    </a>
    
     14
    
   </h1>
   <h1 id="_idParaDest-269">
    <a id="_idTextAnchor271">
    </a>
    
     Implementing Interactable Elements with Smart Objects
    
   </h1>
   <p>
    
     In Unreal Engine,
    
    <strong class="bold">
     
      Smart Objects
     
    </strong>
    
     represent
    
    <a id="_idIndexMarker732">
    </a>
    
     an advanced system implemented to help developers create interactive and context-aware elements within a game.
    
    
     Smart Objects are designed to enhance gameplay by allowing characters – be they player characters or AI agents – to interact with the environment in a more meaningful way through a reservation system.
    
    
     Learning how to use Smart Objects will let you, the developer, create dynamic and interactive environments that enhance gameplay and improve AI behavior for a more immersive
    
    
     
      player experience.
     
    
   </p>
   <p>
    
     In this chapter, you will learn the basics of Smart Objects interactivity.
    
    
     We will visit a simple example of how to make AI agents interact with a
    
    
     
      smart object.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing
     
     
      
       Smart Objects
      
     
    </li>
    <li>
     
      Creating a Smart Object Definition
     
     
      
       data asset
      
     
    </li>
    <li>
     
      Implementing Smart
     
     
      
       Object logic
      
     
    </li>
    <li>
     
      Interacting with
     
     
      
       Smart Objects
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-270">
    <a id="_idTextAnchor272">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow the topics presented in this chapter, you should have completed all the chapters from
    
    <em class="italic">
     
      Part 3
     
    </em>
    
     ,
    
    <em class="italic">
     
      Working with Decision Making
     
    </em>
    
     , and understood their content.
    
    
     In particular, we will be using part of the code implemented up until
    
    <a href="B31016_11.xhtml#_idTextAnchor218">
     
      <em class="italic">
       
        Chapter 11
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Understanding the Environment
     
    </em>
    
     <em class="italic">
      
       Query System
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the
    
    <strong class="source-inline">
     
      .zip
     
    </strong>
    
     project files provided in the project
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5">
     
      
       https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5
      
     
    </a>
   </p>
   <p>
    
     To download the files from the end of the last chapter, click the
    
    <strong class="source-inline">
     
      Unreal Agility Arena –
     
    </strong>
    
     <strong class="source-inline">
      
       Chapter 11
      
     </strong>
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     <strong class="source-inline">
      
       End
      
     </strong>
    
    
     
      link.
     
    
   </p>
   <h1 id="_idParaDest-271">
    <a id="_idTextAnchor273">
    </a>
    
     Introducing Smart Objects
    
   </h1>
   <p>
    
     Smart objects are
    
    <a id="_idIndexMarker733">
    </a>
    
     elements placed within a level that can be interacted with by both AI agents and players.
    
    
     These objects do not contain any execution logic but hold all the necessary information for interactions; additionally, they can be queried at runtime with different methods, such as
    
    
     
      environment queries.
     
    
   </p>
   <p>
    
     Smart objects represent a set of activities within a level that can be accessed through a reservation system; if a smart object slot has been claimed by an AI agent, no other agent will be able to use it until it
    
    
     
      is released.
     
    
   </p>
   <h2 id="_idParaDest-272">
    <a id="_idTextAnchor274">
    </a>
    
     Presenting the main elements of the Smart Objects framework
    
   </h2>
   <p>
    
     Like all Unreal Engine
    
    <a id="_idIndexMarker734">
    </a>
    
     plugins, smart objects are organized into a series of elements, each responsible for a
    
    
     
      specific task.
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      SmartObject subsystem
     
    </strong>
    
     is responsible
    
    <a id="_idIndexMarker735">
    </a>
    
     for monitoring all available smart objects within the level and is automatically instantiated in the world when the Smart Objects plugin is enabled.
    
    
     Smart objects are automatically registered with the subsystem for easy access
    
    
     
      and tracking.
     
    
   </p>
   <p>
    
     A
    
    <strong class="bold">
     
      Smart Object Definition
     
    </strong>
    
     is a data asset
    
    <a id="_idIndexMarker736">
    </a>
    
     that holds immutable data shared among multiple runtime instances of smart objects.
    
    
     It contains filtering information such as user-required tags, activity tags, object activation tags, and a default set of behavior definitions used to interact with a smart object.
    
    
     Additionally, a Smart Object Definition features one or more
    
    <strong class="bold">
     
      slots
     
    </strong>
    
     that
    
    <a id="_idIndexMarker737">
    </a>
    
     can be claimed by players or AI agents to use that specific smart object.
    
    
     Each slot can be positioned relative to its parent, allowing you to define different slots in different positions for the
    
    
     
      same actor.
     
    
   </p>
   <p>
    
     To designate an actor as a smart object, you will be using
    
    <strong class="source-inline">
     
      SmartObjectComponent
     
    </strong>
    
     ; this component will reference a Smart Object
    
    
     
      Definition asset.
     
    
   </p>
   <p>
    
     Smart Object Definitions can include one or
    
    <a id="_idIndexMarker738">
    </a>
    
     more
    
    <strong class="bold">
     
      activity tags
     
    </strong>
    
     that describe the object.
    
    
     They may also
    
    <a id="_idIndexMarker739">
    </a>
    
     feature a
    
    <strong class="bold">
     
      tag query
     
    </strong>
    
     , which consists of a list of desired tags.
    
    
     This tag query serves as an expression to assess whether the user requesting access to the smart object is permitted to interact with it.
    
    
     As an example, a Smart Object Definition may require a
    
    <strong class="source-inline">
     
      charging plug
     
    </strong>
    
     tag that will be usable only by an AI agent that has that
    
    
     
      exact tag.
     
    
   </p>
   <p>
    
     Now that you have a quick introduction to the Smart Objects framework, you’re all set to dive into your project and start creating your very own
    
    
     
      smart object.
     
    
   </p>
   <p>
    
     Starting from the next section, we will be presenting you the basics of using Smart Objects inside Unreal Engine; we won’t cover all aspects of the framework as it can be used in many different ways – standalone, or with behavior trees, state trees, and even with Mass.
    
    
     However, by
    
    <a id="_idIndexMarker740">
    </a>
    
     the end of the chapter, you should have a clear understanding of what you can achieve
    
    
     
      with it.
     
    
   </p>
   <p>
    
     Time to roll up our sleeves and dive into
    
    
     
      some code!
     
    
   </p>
   <h1 id="_idParaDest-273">
    <a id="_idTextAnchor275">
    </a>
    
     Creating a Smart Object Definition data asset
    
   </h1>
   <p>
    <em class="italic">
     
      Dr.
     
     
      Markus leaned back in his chair, a satisfied grin spreading across his face as he surveyed the cluttered lab.
     
     
      Tools were scattered everywhere, and the faint hum of machinery filled the air.
     
     
      Across the room, Professor Viktoria was hunched over one of their AI dummy puppets, her brow furrowed in
     
    </em>
    
     <em class="italic">
      
       deep concentration.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      As the two of them immersed themselves in their work, the idea of upgrading the puppets took shape.
     
     
      The goal was clear: to create puppets capable of not only performing tasks but also fixing themselves when something went awry.
     
     
      This innovation promised to
     
    </em>
    
     <em class="italic">
      
       be revolutionary.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      With renewed focus, Dr.
     
     
      Markus’s fingers danced over the keyboard, typing lines of code that would breathe life into their vision.
     
     
      Each keystroke brought them closer to a breakthrough, and Professor Viktoria’s eyes sparkled with excitement as they discussed the potential of
     
    </em>
    
     <em class="italic">
      
       their project.
      
     </em>
    
   </p>
   <p>
    
     In this section, and in
    
    <a id="_idIndexMarker741">
    </a>
    
     the subsequent ones, you will be creating a gym where AI agents will use a smart object when needed; we will be using the
    
    <strong class="bold">
     
      BP_GunnerDummyCharacter
     
    </strong>
    
     Blueprint we implemented in
    
    <a href="B31016_09.xhtml#_idTextAnchor170">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Extending Behavior Trees
     
    </em>
    
     , by changing its AI logic.
    
    
     The gunner character will walk randomly, shoot around, and, when the gun jams, try to find a workbench in the level to fix
    
    
     
      the gun.
     
    
   </p>
   <p>
    
     To start using the
    
    <a id="_idIndexMarker742">
    </a>
    
     Smart Objects framework, the first thing we need to do is enable
    
    
     
      the plugins.
     
    
   </p>
   <h2 id="_idParaDest-274">
    <a id="_idTextAnchor276">
    </a>
    
     Enabling the plugins
    
   </h2>
   <p>
    
     To enable the
    
    <a id="_idIndexMarker743">
    </a>
    
     Smart Objects framework, open the
    
    <strong class="bold">
     
      Plugins
     
    </strong>
    
     window, look for
    
    <strong class="bold">
     
      SmartObjects
     
    </strong>
    
     and
    
    <strong class="bold">
     
      GameplayBehaviorSmartObjects
     
    </strong>
    
     , and enable both.
    
    
     You will get a warning as the second plugin is still marked as experimental; go on and restart the Unreal
    
    
     
      Engine Editor.
     
    
   </p>
   <p>
    
     Once the plugins are enabled, you will be ready to create your first
    
    
     
      smart object.
     
    
   </p>
   <h2 id="_idParaDest-275">
    <a id="_idTextAnchor277">
    </a>
    
     Creating the workbench definition asset
    
   </h2>
   <p>
    
     We will now be creating
    
    <a id="_idIndexMarker744">
    </a>
    
     the Smart Object Definition that, as previously mentioned, won’t contain any code logic; it will just serve to define the data that will make your soon-to-be-created actor a smart object.
    
    
     To do so, open the
    
    <strong class="source-inline">
     
      AI
     
    </strong>
    
     folder and do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Right-click and select
     
     <strong class="bold">
      
       Artificial Intelligence
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        SmartObject Definition
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the newly created asset
     
     <strong class="source-inline">
      
       SOD_Workbench
      
     </strong>
     
      and double-click to
     
     
      
       open it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Default Behavior Definitions
      
     </strong>
     
      array attribute and click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to add
     
     
      
       an element.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Index[0]
      
     </strong>
     
      element to
     
     <strong class="bold">
      
       Gameplay Behavior Smart Object
      
     </strong>
     
      <strong class="bold">
       
        Behavior Definition
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.1 – Smart Object behavior definition" src="img/Figure_14.1_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.1 – Smart Object behavior definition
    
   </p>
   <p>
    
     As previously stated, a Smart Object Definition contains filtering data that will be used by the system.
    
    
     As we won’t be implementing anything complex, we don’t need a custom definition, and we will just be using the
    
    
     
      base one.
     
    
   </p>
   <p>
    
     It’s now time to add
    
    <a id="_idIndexMarker745">
    </a>
    
     a slot, so do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Slots
      
     </strong>
     
      section and click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to add a new slot.
     
     
      Expand the newly
     
     
      
       created slot.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Name
      
     </strong>
     
      property,
     
     
      
       insert
      
     
     
      <strong class="source-inline">
       
        WorkingPlace
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Shape
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        Rectangle
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Size
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        120.0
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Offset
      
     </strong>
     
      property to
     
     <strong class="source-inline">
      
       (50.0,
      
     </strong>
     
      <strong class="source-inline">
       
        0.0, 0.0)
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.2 – Slot definition" src="img/Figure_14.2_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.2 – Slot definition
    
   </p>
   <p class="list-inset">
    
     This slot will be the location that can be claimed by the AI agent to fix the gun once it jams and should look like the one in
    
    
     <em class="italic">
      
       Figure 14
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 14.3 – Slot" src="img/Figure_14.3_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.3 – Slot
    
   </p>
   <p class="list-inset">
    
     Keep in mind that you can add as many slots as you deem appropriate.
    
    
     For example, a larger workbench may have more working places or even different ones – for instance, one for fixing guns and one for
    
    
     
      recharging batteries.
     
    
   </p>
   <p>
    
     In this section, we have created the Smart Object Definition we will be using to create a Smart Object actor.
    
    
     As
    
    <a id="_idIndexMarker746">
    </a>
    
     you can see, there’s no logic involved here because it’s handled by the Blueprint we’ll be creating in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-276">
    <a id="_idTextAnchor278">
    </a>
    
     Implementing smart object logic
    
   </h1>
   <p>
    
     We are now ready to
    
    <a id="_idIndexMarker747">
    </a>
    
     create the Blueprint that will contain the Smart Object definition, making it a fully functional Smart Object.
    
    
     To do so, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder and create a new Blueprint extending from
     
     <strong class="bold">
      
       Actor
      
     </strong>
     
      .
     
     
      Call it
     
     <strong class="source-inline">
      
       BP_Workbench
      
     </strong>
     
      .
     
     
      Double-click on the newly created asset to
     
     
      
       open it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Components
      
     </strong>
     
      panel, add a
     
     <strong class="bold">
      
       StaticMesh
      
     </strong>
     
      component and
     
     
      
       select it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Rotation
      
     </strong>
     
      property to
     
     <strong class="source-inline">
      
       (0.0, 0.0, -90.0)
      
     </strong>
     
      and the
     
     <strong class="bold">
      
       Static Mesh
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        Workbench_Decorated_Workbench_Decorated
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Components
      
     </strong>
     
      panel, add a
     
     <strong class="bold">
      
       SmartObject
      
     </strong>
     
      component and
     
     
      
       select it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Smart Object
      
     </strong>
     
      category and set the
     
     <strong class="bold">
      
       Smart Object Definition
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       SOD_Workbench
      
     </strong>
     
      .
     
     
      The viewport should now look like the one shown in
     
     
      <em class="italic">
       
        Figure 14
       
      </em>
     
     
      <em class="italic">
       
        .4
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.4 – Viewport" src="img/Figure_14.4_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.4 – Viewport
    
   </p>
   <p class="list-inset">
    
     Now, open the
    
    <strong class="bold">
     
      Event Graph
     
    </strong>
    
     panel and do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="6">
     
      Add an
     
     
      <strong class="bold">
       
        OnSmartObjectEvent
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       Event Data
      
     </strong>
     
      pin to a
     
     <strong class="bold">
      
       Break
      
     </strong>
     
      <strong class="bold">
       
        SmartObjectEventData
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       Reason
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Break SmartObjectEventData
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Switch on ESmartObjectChangeReason
      
     </strong>
     
      node and click the
     
     <strong class="bold">
      
       Expand
      
     </strong>
     
      button to show all the
     
     <a id="_idIndexMarker748">
     </a>
     
      switch cases.
     
     
      The graph so far should look like
     
     
      <em class="italic">
       
        Figure 14
       
      </em>
     
     
      <em class="italic">
       
        .5
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.5 – Starting graph" src="img/Figure_14.5_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.5 – Starting graph
    
   </p>
   <p class="list-inset">
    
     What we are doing here is quite simple; every time we get an event from the smart object, we check what has caused the event.
    
    
     This will serve us to respond to any interaction from the AI agent.
    
    
     Let’s continue the code logic by doing the
    
    
     
      following steps.
     
    
   </p>
   <ol>
    <li value="9">
     
      Connect the
     
     <strong class="bold">
      
       Interactor
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       OnSmartObject Event
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Get
      
     </strong>
     
      <strong class="bold">
       
        AIController
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect
     
     <strong class="bold">
      
       Return Value
      
     </strong>
     
      of the
     
     <strong class="bold">
      
       Get AIController
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Get
      
     </strong>
     
      <strong class="bold">
       
        Blackboard
       
      </strong>
     
     
      
       node.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.6 – Retrieve Blackboard" src="img/Figure_14.6_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.6 – Retrieve Blackboard
    
   </p>
   <ol>
    <li value="11">
     
      Connect
     
     <a id="_idIndexMarker749">
     </a>
     
      the
     
     <strong class="bold">
      
       Return Value
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Get Blackboard
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Set Value as
      
     </strong>
     
      <strong class="bold">
       
        Bool
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       On Released
      
     </strong>
     
      outgoing execution pin of the
     
     <strong class="bold">
      
       Switch on ESmartObjectChangeReason
      
     </strong>
     
      node to the incoming execution pin of the
     
     <strong class="bold">
      
       Set Value as
      
     </strong>
     
      <strong class="bold">
       
        Bool
       
      </strong>
     
     
      
       node.
      
     
     <p class="list-inset">
      
       Click and drag from the
      
      <strong class="bold">
       
        Key Name
       
      </strong>
      
       pin of the
      
      <strong class="bold">
       
        Set Value as Bool
       
      </strong>
      
       node.
      
      
       Release and, from the pop-up menu, select
      
      <strong class="bold">
       
        Promote to variable
       
      </strong>
      
       to create a new variable.
      
      
       In the
      
      <strong class="bold">
       
        Variables
       
      </strong>
      
       panel, name the newly created variable
      
      <strong class="source-inline">
       
        NeedsReloadKeyName
       
      </strong>
      
       , so that the node in the graph will show a
      
      <strong class="bold">
       
        Needs Reloading Key Name
       
      </strong>
      
       label.
      
      
       This part of the graph is shown in
      
      
       <em class="italic">
        
         Figure 14
        
       </em>
      
      
       <em class="italic">
        
         .7
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 14.7 – Set Blackboard key" src="img/Figure_14.7_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.7 – Set Blackboard key
    
   </p>
   <ol>
    <li value="13">
     
      Compile the Blueprint and set the variable
     
     <strong class="bold">
      
       Default Value
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        WeaponJammed
       
      </strong>
     
     
      
       .
      
     
     <p class="list-inset">
      
       In this last part of the graph, we set a Blackboard key value of the AI agent that is interacting with the smart object.
      
      
       We are doing this at the
      
      <strong class="bold">
       
        On Released
       
      </strong>
      
       event, that is, when the smart object has been claimed, interacted with, and then released to be claimable again.
      
      
       This means we will fix the jammed gun once the AI agent has finished interacting with the
      
      
       
        smart object.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     The Blackboard, and
    
    <a id="_idIndexMarker750">
    </a>
    
     consequently, the
    
    <strong class="bold">
     
      WeaponJammed
     
    </strong>
    
     key, haven’t been implemented yet.
    
    
     In the next section, we will be working on the Blackboard itself and its related behavior tree in order to implement the
    
    
     
      AI agent.
     
    
   </p>
   <h1 id="_idParaDest-277">
    <a id="_idTextAnchor279">
    </a>
    
     Interacting with smart objects
    
   </h1>
   <p>
    
     In this section, we will
    
    <a id="_idIndexMarker751">
    </a>
    
     finalize the smart object system by creating an AI agent that will make good use of the previously created workbench Blueprint.
    
    
     As stated before, the AI agent will move around and shoot at random; from time to time, the gun will jam, and so the gunner will need to get to the workbench to fix it.
    
    
     The AI behavior will be handled by a behavior tree, and it will be quite straightforward, but it will help us understand how to interact with
    
    
     
      smart objects.
     
    
   </p>
   <p>
    
     Let’s start by creating a helpful task we will be using in the
    
    
     
      behavior tree.
     
    
   </p>
   <h2 id="_idParaDest-278">
    <a id="_idTextAnchor280">
    </a>
    
     Creating the toss coin task
    
   </h2>
   <p>
    
     We are now going to
    
    <a id="_idIndexMarker752">
    </a>
    
     create a task that will simulate the gun
    
    <a id="_idIndexMarker753">
    </a>
    
     jamming.
    
    
     This task will be some sort of weighted coin toss and will return a
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     value – that is, a head or tails result.
    
    
     The weight of the toss will help us in defining how much the gun is prone to jamming.
    
    
     You should already be familiar with behavior tree tasks but, for a quick refresher, you can check
    
    <a href="B31016_08.xhtml#_idTextAnchor148">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a
     
    </em>
    
     <em class="italic">
      
       Behavior Tree
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     To implement this task, start by creating a new C++ class extending
    
    <strong class="source-inline">
     
      BTTaskNode
     
    </strong>
    
     and call it
    
    <strong class="source-inline">
     
      BTTask_TossCoin
     
    </strong>
    
     .
    
    
     Then, open the
    
    <strong class="source-inline">
     
      BTTask_TossCoin.h
     
    </strong>
    
     file and add the following block
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
public:
    UBTTask_TossCoin();
    UPROPERTY(EditAnywhere, Category="Blackboard")
    FBlackboardKeySelector BlackboardKey;
   UPROPERTY(EditAnywhere, Category="Task")
    float TrueProbability = 0.5f;
    virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp,
      uint8* NodeMemory) override;</pre>
   <p>
    
     The only thing worth mentioning here is the
    
    <strong class="source-inline">
     
      TrueProbability
     
    </strong>
    
     property, which will let us weight the result – in our case, the probability of jamming the gun.
    
    
     Now, open the
    
    <strong class="source-inline">
     
      BTTask_TossCoin.cpp
     
    </strong>
    
     file and add the following declaration at the top
    
    
     
      of it:
     
    
   </p>
   <pre class="source-code">
#include "BehaviorTree/BlackboardComponent.h"</pre>
   <p>
    
     The constructor is
    
    <a id="_idIndexMarker754">
    </a>
    
     going to be really simple as it will just give a
    
    <a id="_idIndexMarker755">
    </a>
    
     meaningful name to the node.
    
    
     Add the following code to your
    
    
     
      class implementation:
     
    
   </p>
   <pre class="source-code">
UBTTask_TossCoin::UBTTask_TossCoin()
{
    NodeName = "Toss Coin";
}</pre>
   <p>
    
     All the code logic is going to be placed inside the
    
    <strong class="source-inline">
     
      ExecuteTask()
     
    </strong>
    
     function.
    
    
     Let’s add this block
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
EBTNodeResult::Type UBTTask_TossCoin::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)
{
    const auto BlackboardComp = OwnerComp.GetBlackboardComponent();
    if (BlackboardComp == nullptr)
      { return EBTNodeResult::Failed; }
    const auto RandomNumber = FMath::RandRange(0.0f, 1.0f);
    BlackboardComp-&gt;
      SetValueAsBool(BlackboardKey.SelectedKeyName,
        RandomNumber &lt; TrueProbability);
    return EBTNodeResult::Succeeded;
}</pre>
   <p>
    
     As you can see, once we have retrieved the Blackboard component, we randomize a
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     result and set a key value inside the
    
    
     
      Blackboard itself.
     
    
   </p>
   <p>
    
     With this class
    
    <a id="_idIndexMarker756">
    </a>
    
     complete, we can now focus on a couple of environment
    
    <a id="_idIndexMarker757">
    </a>
    
     queries that we will need inside the
    
    
     
      behavior tree.
     
    
   </p>
   <h2 id="_idParaDest-279">
    <a id="_idTextAnchor281">
    </a>
    
     Creating environment queries
    
   </h2>
   <p>
    
     To implement the
    
    <a id="_idIndexMarker758">
    </a>
    
     gunner behavior tree, we will need a couple of environment queries: one for generating a random location for the gunner to reach and one for finding the workbench smart object.
    
    
     Let’s start with the
    
    
     
      first one.
     
    
   </p>
   <h3>
    
     Creating the FindShootLocation environment query
    
   </h3>
   <p>
    
     This query will be in
    
    <a id="_idIndexMarker759">
    </a>
    
     charge of generating a set of random locations on
    
    <a id="_idIndexMarker760">
    </a>
    
     the
    
    <strong class="bold">
     
      Nav Mesh
     
    </strong>
    
     level; basically, we will create a grid of points and later select one of these points as a shooting spot.
    
    
     To do so, open the
    
    <strong class="source-inline">
     
      AI
     
    </strong>
    
     folder and create an environment query by going to
    
    <strong class="bold">
     
      Artificial Intelligence
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Environment Query
     
    </strong>
    
     .
    
    
     Name it
    
    <strong class="source-inline">
     
      EQS_FindShootLocation
     
    </strong>
    
     .
    
    
     Open it and do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Inside the graph, connect the
     
     <strong class="bold">
      
       ROOT
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Points:
      
     </strong>
     
      <strong class="bold">
       
        Grid
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Select the newly created node and set the
     
     <strong class="bold">
      
       GridHalfSize
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        2500.0
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Double-check that the
     
     <strong class="bold">
      
       Projection Data
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Trace Node
      
     </strong>
     
      is set
     
     
      
       to
      
     
     
      <strong class="bold">
       
        Navigation
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.8 – FindShootLocation query" src="img/Figure_14.8_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.8 – FindShootLocation query
    
   </p>
   <p>
    
     As you can see, we are
    
    <a id="_idIndexMarker761">
    </a>
    
     using the nav mesh to look for a
    
    <a id="_idIndexMarker762">
    </a>
    
     location; this will ensure that our agent will be capable of reaching the
    
    
     
      selected point.
     
    
   </p>
   <h3>
    
     Creating the FindWorkbenchLocation environment query
    
   </h3>
   <p>
    
     This second
    
    <a id="_idIndexMarker763">
    </a>
    
     query will be a search for smart objects inside a predefined area.
    
    
     Let’s start by creating an environment query (
    
    <strong class="bold">
     
      Artificial Intelligence
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Environment Query
     
    </strong>
    
     ) and naming it
    
    <strong class="source-inline">
     
      EQS_FindWorkbench
     
    </strong>
    
     .
    
    
     Open it and do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Inside the graph, connect the
     
     <strong class="bold">
      
       ROOT
      
     </strong>
     
      node to a
     
     
      <strong class="bold">
       
        SmartObjects
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Add an item in the
     
     <strong class="bold">
      
       Behavior Definition Classes
      
     </strong>
     
      array property by clicking the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      
       button.
      
     
    </li>
    <li>
     
      Set the item at
     
     <strong class="bold">
      
       Index[0]
      
     </strong>
     
      
       to
      
     
     
      <strong class="bold">
       
        GameplayBehaviorSmartObjectBehaviorDefinition
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Query Box Extent
      
     </strong>
     
      to
     
     <strong class="source-inline">
      
       (5000.0,
      
     </strong>
     
      <strong class="source-inline">
       
        5000.0, 500.0)
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.9 – FindWorkbench query" src="img/Figure_14.9_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.9 – FindWorkbench query
    
   </p>
   <p>
    
     This query will look for any smart object with a behavior definition set to
    
    <strong class="bold">
     
      GameplayBehaviorSmartObjectBehaviorDefinition
     
    </strong>
    
     ; this is the default definition, and it is the one we used inside the
    
    <strong class="bold">
     
      SOD_Workbench
     
    </strong>
    
     asset.
    
    
     It should be noted that, for the sake of simplicity, we kept things at a very basic level here.
    
    
     I highly encourage you to try implementing a filtering system by using tag filters or by extending your own behavior definition for the workbench or any other smart object you will be adding to
    
    
     
      the level.
     
    
   </p>
   <p>
    
     With environment
    
    <a id="_idIndexMarker764">
    </a>
    
     queries finished, we can start
    
    <a id="_idIndexMarker765">
    </a>
    
     implementing the behavior trees, starting from
    
    
     
      the Blackboard.
     
    
   </p>
   <h2 id="_idParaDest-280">
    <a id="_idTextAnchor282">
    </a>
    
     Creating the Blackboard
    
   </h2>
   <p>
    
     The Blackboard
    
    <a id="_idIndexMarker766">
    </a>
    
     for our
    
    <a id="_idIndexMarker767">
    </a>
    
     AI agent will need to store two locations: one for the shooting target and another for the workbench.
    
    
     Additionally, there should be a flag to indicate whether the gun is jammed.
    
    
     Let’s begin by creating a Blackboard and naming it
    
    <strong class="source-inline">
     
      BB_Tinkerer
     
    </strong>
    
     to clearly reflect the capabilities of our AI agent.
    
    
     Then, add the
    
    
     
      following keys:
     
    
   </p>
   <ul>
    <li>
     
      A
     
     <strong class="bold">
      
       Vector
      
     </strong>
     
      
       named
      
     
     
      <strong class="source-inline">
       
        WorkbenchLocation
       
      </strong>
     
    </li>
    <li>
     
      A
     
     <strong class="bold">
      
       Vector
      
     </strong>
     
      
       named
      
     
     
      <strong class="source-inline">
       
        ShootLocation
       
      </strong>
     
    </li>
    <li>
     
      A
     
     <strong class="bold">
      
       Bool
      
     </strong>
     
      
       named
      
     
     
      <strong class="source-inline">
       
        WeaponJammed
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     With the
    
    <a id="_idIndexMarker768">
    </a>
    
     Blackboard
    
    <a id="_idIndexMarker769">
    </a>
    
     finalized, we are ready to create the
    
    
     
      behavior tree.
     
    
   </p>
   <h2 id="_idParaDest-281">
    <a id="_idTextAnchor283">
    </a>
    
     Creating the behavior tree
    
   </h2>
   <p>
    
     The behavior
    
    <a id="_idIndexMarker770">
    </a>
    
     tree is
    
    <a id="_idIndexMarker771">
    </a>
    
     going to have two main subbranches that will handle the case when the gun is jammed and when it is not.
    
    
     Let’s start by creating a new behavior tree and calling it
    
    <strong class="source-inline">
     
      BT_Tinkerer
     
    </strong>
    
     .
    
    
     Open it and set the
    
    <strong class="bold">
     
      Blackboard Asset
     
    </strong>
    
     property to
    
    <strong class="bold">
     
      BB_Tinkerer
     
    </strong>
    
     .
    
    
     Then, do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       ROOT
      
     </strong>
     
      node to a
     
     <strong class="bold">
      
       Selector
      
     </strong>
     
      node; call it
     
     
      <strong class="source-inline">
       
        Root Selector
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add two
     
     <strong class="bold">
      
       Sequence
      
     </strong>
     
      nodes to the
     
     <strong class="bold">
      
       Root Selector
      
     </strong>
     
      node.
     
     
      Call the left one
     
     <strong class="source-inline">
      
       Shoot Sequence
      
     </strong>
     
      and the right one
     
     
      <strong class="source-inline">
       
        Fix Sequence
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Blackboard Decorator
      
     </strong>
     
      to the
     
     <strong class="bold">
      
       Shoot Sequence
      
     </strong>
     
      node and
     
     
      
       select it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Notify Observer
        
       </strong>
       
        property to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          Value Change
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Key Query
        
       </strong>
       
        property to
       
       <strong class="bold">
        
         Is
        
       </strong>
       
        <strong class="bold">
         
          Not Set
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Blackboard Key
        
       </strong>
       
        
         to
        
       
       
        <strong class="bold">
         
          WeaponJammed
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       The graph so far should look like the one shown in
      
      
       <em class="italic">
        
         Figure 14
        
       </em>
      
      
       <em class="italic">
        
         .10
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 14.10 – Sequences" src="img/Figure_14.10_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.10 – Sequences
    
   </p>
   <p>
    
     Let’s now focus on the
    
    <strong class="bold">
     
      Shoot Sequence
     
    </strong>
    
     section of the graph.
    
    
     Start by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Move To
      
     </strong>
     
      task, name it
     
     <strong class="source-inline">
      
       Move to Shoot Location
      
     </strong>
     
      , and set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        ShootLocation
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       PlayMontage
      
     </strong>
     
      task to the right of the
     
     <strong class="bold">
      
       Move to Shoot Location
      
     </strong>
     
      task, name it
     
     <strong class="source-inline">
      
       Play Shoot Montage
      
     </strong>
     
      , and set the
     
     <strong class="bold">
      
       Anim Montage
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        AM_1H_Shoot
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      task to the right of the
     
     <strong class="bold">
      
       Play Shoot Montage
      
     </strong>
     
      task.
     
     
      Set the
     
     <strong class="bold">
      
       Wait Time
      
     </strong>
     
      property to
     
     <strong class="source-inline">
      
       3.0
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Random Deviation
      
     </strong>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        0.5
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       TossCoin
      
     </strong>
     
      task to the right of the
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      task, name it
     
     <strong class="source-inline">
      
       Randomize Jam
      
     </strong>
     
      , set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       WeaponJammed
      
     </strong>
     
      , and set the
     
     <strong class="bold">
      
       True Probability
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        0.35
       
      </strong>
     
     
      
       .
      
     
     <p class="list-inset">
      
       The
      
      <strong class="bold">
       
        Shoot Sequence
       
      </strong>
      
       section
      
      <a id="_idIndexMarker772">
      </a>
      
       of the graph should look
      
      <a id="_idIndexMarker773">
      </a>
      
       like the one depicted in
      
      
       <em class="italic">
        
         Figure 14
        
       </em>
      
      
       <em class="italic">
        
         .11
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 14.11 – Shoot Sequence" src="img/Figure_14.11_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.11 – Shoot Sequence
    
   </p>
   <p class="list-inset">
    
     This portion of the graph will move the AI agent to a selected location, start the shooting sequence, wait a short time, and check whether the gun is jammed.
    
    
     However, we need to add a service to make it fully functional.
    
    
     Let’s start by selecting
    
    <strong class="bold">
     
      Move to Shoot Location
     
    </strong>
    
     and adding a
    
    <strong class="bold">
     
      Run EQSQuery
     
    </strong>
    
     node.
    
    
     Select the query service and, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li value="5">
     
      Name it
     
     <strong class="source-inline">
      
       Find
      
     </strong>
     
      <strong class="source-inline">
       
        Shoot Location
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Query Template
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        EQS_FindShootLocation
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set
     
     <strong class="bold">
      
       Run Mode
      
     </strong>
     
      to
     
     <strong class="bold">
      
       Single Random Item from
      
     </strong>
     
      <strong class="bold">
       
        Best 25%
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       ShootLocation
      
     </strong>
     
      .
     
     
      <em class="italic">
       
        Figure 14
       
      </em>
     
     <em class="italic">
      
       .12
      
     </em>
     
      shows the finalized
     
     <strong class="bold">
      
       Shoot Sequence
      
     </strong>
     
      section of
     
     
      
       the graph:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.12 – Finalized ShootSequence" src="img/Figure_14.12_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.12 – Finalized ShootSequence
    
   </p>
   <p class="list-inset">
    
     This service will execute the environment query that will select one random item from the generated locations, assigning it to the
    
    
     <strong class="bold">
      
       ShootLocation
      
     </strong>
    
    
     
      property.
     
    
   </p>
   <p>
    
     With this portion of the
    
    <a id="_idIndexMarker774">
    </a>
    
     behavior tree complete, we can focus
    
    <a id="_idIndexMarker775">
    </a>
    
     on the
    
    <strong class="bold">
     
      Fix Sequence
     
    </strong>
    
     section of the graph.
    
    
     Follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Move To
      
     </strong>
     
      task, name it
     
     <strong class="source-inline">
      
       Move to Workbench Location
      
     </strong>
     
      , and set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        WorkbenchLocation
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       PlayMontage
      
     </strong>
     
      task to the right of the
     
     <strong class="bold">
      
       Move to Workbench Location
      
     </strong>
     
      task, name it
     
     <strong class="source-inline">
      
       Play Reload Montage
      
     </strong>
     
      , and set the
     
     <strong class="bold">
      
       Anim Montage
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        AM_1H_Reload
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      task to the right of the
     
     <strong class="bold">
      
       Play Shoot Montage
      
     </strong>
     
      task.
     
     
      Set the
     
     <strong class="bold">
      
       Wait Time
      
     </strong>
     
      property to
     
     <strong class="source-inline">
      
       3.0
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Random Deviation
      
     </strong>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        0.5
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       FindAndUseGameplayBehaviorSmartObject
      
     </strong>
     
      task to the right of the
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      task, name it
     
     <strong class="source-inline">
      
       Use Workbench
      
     </strong>
     
      , set the
     
     <strong class="bold">
      
       Query Template
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       EQS_FindWorkbench
      
     </strong>
     
      , and set the
     
     <strong class="bold">
      
       RunMode
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       Single Best Item
      
     </strong>
     
      .
     
     
      The
     
     <strong class="bold">
      
       Fix Sequence
      
     </strong>
     
      should look like the one depicted in
     
     
      <em class="italic">
       
        Figure 14
       
      </em>
     
     
      <em class="italic">
       
        .13
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.13 – Fix Sequence" src="img/Figure_14.13_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.13 – Fix Sequence
    
   </p>
   <p>
    
     You are already familiar with most of the graph, but the last task needs some explanation as it is the most important one.
    
    
     It will find a suitable smart object, claim it, and use it.
    
    
     Then it will release the resource.
    
    
     Although you don’t have full control of each of the phases of the smart object as they are executed one after the other, it is quite handy when implementing simple behaviors such as the one
    
    
     
      we created.
     
    
   </p>
   <p>
    
     The last thing we need to add is a service that will find the workbench in the level.
    
    
     To implement this, select the
    
    <strong class="bold">
     
      Move to Workbench Location
     
    </strong>
    
     task and add a
    
    <strong class="bold">
     
      Run EQSQuery
     
    </strong>
    
     node.
    
    
     Select
    
    <a id="_idIndexMarker776">
    </a>
    
     the query service and, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, do
    
    <a id="_idIndexMarker777">
    </a>
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Name it
     
     <strong class="source-inline">
      
       Find
      
     </strong>
     
      <strong class="source-inline">
       
        Workbench Location
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Query Template
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        EQS_FindWorkbench
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Run Mode
      
     </strong>
     
      attribute to
     
     <strong class="bold">
      
       Single
      
     </strong>
     
      <strong class="bold">
       
        Best Item
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      property to
     
     <strong class="bold">
      
       WorkbenchLocation
      
     </strong>
     
      .
     
     
      <em class="italic">
       
        Figure 14
       
      </em>
     
     <em class="italic">
      
       .14
      
     </em>
     
      shows the finalized
     
     <strong class="bold">
      
       FixSequence
      
     </strong>
     
      section of
     
     
      
       the graph:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 14.14 – Finalized FixSequence" src="img/Figure_14.14_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.14 – Finalized FixSequence
    
   </p>
   <p>
    
     The behavior tree is
    
    <a id="_idIndexMarker778">
    </a>
    
     now complete; we just need to integrate it into
    
    <a id="_idIndexMarker779">
    </a>
    
     an AI agent and observe
    
    
     
      its behavior.
     
    
   </p>
   <h2 id="_idParaDest-282">
    <a id="_idTextAnchor284">
    </a>
    
     Creating the character Blueprints
    
   </h2>
   <p>
    
     To finalize our AI
    
    <a id="_idIndexMarker780">
    </a>
    
     agent, we need to create the AI controller
    
    <a id="_idIndexMarker781">
    </a>
    
     and the character Blueprints.
    
    
     Luckily, we have already implemented the necessary classes, and we just need to
    
    
     
      extend them.
     
    
   </p>
   <p>
    
     Let’s start with the AI controller by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder, create a new Blueprint class extending
     
     
      
       from
      
     
     
      <strong class="bold">
       
        BaseDummyAIController
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name it
     
     <strong class="source-inline">
      
       AITikererDummyController
      
     </strong>
     
      and
     
     
      
       open it.
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Behavior Tree
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        BT_Tinkerer
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     It’s now time to create the character, so do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder, right-click on
     
     <strong class="bold">
      
       BP_GunnerDummyCharacter
      
     </strong>
     
      and select
     
     <strong class="bold">
      
       Create Child
      
     </strong>
     
      <strong class="bold">
       
        Blueprint Class
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the newly created asset
     
     <strong class="source-inline">
      
       BP_TinkererDummyCharacter
      
     </strong>
     
      and
     
     
      
       open it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       AI Controller Class
      
     </strong>
     
      property
     
     
      
       to
      
     
     
      <strong class="bold">
       
        AITinkererDummyController
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     We are now ready to test things out in
    
    
     
      a gym.
     
    
   </p>
   <h2 id="_idParaDest-283">
    <a id="_idTextAnchor285">
    </a>
    
     Testing smart objects in a gym
    
   </h2>
   <p>
    
     By now, you
    
    <a id="_idIndexMarker782">
    </a>
    
     should be familiar with the process of creating and testing a
    
    <a id="_idIndexMarker783">
    </a>
    
     gym, so just create a new level of your choice with a
    
    <strong class="bold">
     
      NavMeshBoundsVolume
     
    </strong>
    
     actor in order to make your AI agent move through the pathfinding system.
    
    
     Then, add a
    
    <strong class="bold">
     
      BP_Tinkerer
     
    </strong>
    
     instance and a
    
    <strong class="bold">
     
      BP_Workbench
     
    </strong>
    
     instance to the level and start
    
    
     
      the simulation.
     
    
   </p>
   <p>
    
     You should observe the AI agent moving around and shooting.
    
    
     Occasionally, the weapon will jam, prompting the agent to search for a workbench to repair it before returning to its
    
    
     
      shooting activities.
     
    
   </p>
   <div><div><img alt="Figure 14.15 – Finalized fix sequence" src="img/Figure_14.15_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 14.15 – Finalized fix sequence
    
   </p>
   <p>
    
     In this section, we created an introductory yet fully functional gym that effectively uses smart objects.
    
    
     I highly encourage you to experiment with things a bit by adjusting the jam probability or adding
    
    <a id="_idIndexMarker784">
    </a>
    
     more
    
    <a id="_idIndexMarker785">
    </a>
    
     workbenches and gunners to observe how these changes affect the
    
    
     
      overall behavior.
     
    
   </p>
   <h1 id="_idParaDest-284">
    <a id="_idTextAnchor286">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this final chapter, we learned about Smart Objects, an advanced framework created to assist developers in building interactive and context-aware elements in a game.
    
    
     Smart Objects aim to enrich gameplay by enabling player characters and AI agents to engage with the environment more meaningfully through a reservation system, as we learned in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     As a developer, you will benefit from using Smart Objects by creating more immersive and interactive gameplay experiences, as environment objects will enable complex behaviors and context-sensitive interactions within the game world.
    
    
     By leveraging this technology, your games will become increasingly captivating and engaging for
    
    
     
      your players.
     
    
   </p>
   <h1 id="_idParaDest-285">
    <a id="_idTextAnchor287">
    </a>
    
     Epilogue
    
   </h1>
   <p>
    <em class="italic">
     
      In their secret laboratory, Dr.
     
     
      Markus and Professor Viktoria watched as their AI dummy puppets prepared for an epic battle, armed with colorful
     
    </em>
    
     <em class="italic">
      
       Nerf guns.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      Markus laughed as a bold puppet dashed from behind a lab table, launching foam darts.
     
     
      “We’ve created the world’s first AI Nerf combat league!”
     
     
      He
     
    </em>
    
     <em class="italic">
      
       proudly exclaimed.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      Viktoria grinned, delighted by their creations’ enthusiasm.
     
     
      “Who knew they’d embrace battle
     
    </em>
    
     <em class="italic">
      
       so eagerly?”
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      With the glow of monitors casting light across the lab, Markus suggested, “What’s next?
     
     
      A
     
    </em>
    
     <em class="italic">
      
       championship tournament?”
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      “Absolutely!”
     
     
      Viktoria replied, her
     
    </em>
    
     <em class="italic">
      
       excitement infectious.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      In that hidden haven of innovation, they realized they had built something extraordinary – a whimsical world of creativity and friendly competition, bursting with
     
    </em>
    
     <em class="italic">
      
       endless possibilities.
      
     </em>
    
   </p>
   <p>
    
     So, this is the end of this book; I hope you enjoyed it as much as I enjoyed
    
    
     
      writing it!
     
    
   </p>
   <p>
    
     This is just the start of your exciting journey into the amazing world of artificial intelligence development in Unreal Engine!
    
    
     You might be asking yourself, “
    
    <em class="italic">
     
      What’s next?
     
    </em>
    
     ”.
    
    
     I totally understand that it can feel a bit overwhelming with all the plugins, frameworks, and technologies I presented.
    
    
     To help you out, I’ve put together a fun new task for you!
    
    
     In the project template, you will find a level called
    
    <strong class="bold">
     
      CaptureTheFlag
     
    </strong>
    
     .
    
    
     Feel free to dive in and create your very own
    
    <em class="italic">
     
      Capture the Flag
     
    </em>
    
     game featuring the dummy puppets as main characters.
    
    
     Try to combine everything you’ve learned so far to develop your own
    
    
     
      AI agents.
     
    
   </p>
   <p>
    
     Dive into this with all the enthusiasm you can muster and don’t be afraid to experiment and play around.
    
    
     Remember, the best experiences often come from letting loose and having a great time, so go ahead and make it
    
    
     
      your own.
     
    
   </p>
   <p>
    
     Have
    
    
     
      a blast!
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-286">
    <a id="_idTextAnchor288">
    </a>
    
     Appendix – Understanding C++ in Unreal Engine
    
   </h1>
   <p>
    
     This appendix has been written to provide you with additional insights, resources, and practical information to enhance your understanding of C++ programming within the Unreal Engine framework.
    
    
     This will help you as a refresher or as a reference throughout the book, just in case you need some help when following the
    
    
     
      presented code.
     
    
   </p>
   <p>
    
     This appendix serves as a valuable reference that complements the main content of the book, providing you with the tools and information needed to successfully navigate the exciting world of C++ in Unreal Engine.
    
    
     Whether you’re a mid-experienced developer looking to refine your skills or a proficient C++ programmer with little Unreal Engine experience, I hope this appendix will enrich your
    
    
     
      learning experience!
     
    
   </p>
   <p>
    
     We will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing
     
     
      
       basic concepts
      
     
    </li>
    <li>
     
      Explaining
     
     
      
       advanced features
      
     
    </li>
    <li>
     
      Exploring
     
     
      
       core mechanics
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-287">
    <a id="_idTextAnchor289">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow the topics presented in this chapter, you should have some good knowledge about programming, particularly some basic understanding of the C++ language.
    
    
     Additionally, you will need a good understanding of the
    
    
     
      Unreal Engine.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     This chapter will provide a gentle introduction to the main topics related to using C++ in Unreal Engine.
    
    
     For a more comprehensive exploration of programming in C++ with Unreal Engine, I recommend checking out Zhenyu George Li’s book titled
    
    <em class="italic">
     
      Unreal Engine 5 Game Development with C++ Scripting
     
    </em>
    
     , published
    
    
     
      by Packt.
     
    
   </p>
   <h1 id="_idParaDest-288">
    <a id="_idTextAnchor290">
    </a>
    
     Introducing basic concepts
    
   </h1>
   <p>
    
     If you share my passion for game development and programming, you’ll probably agree that writing C++ code in Unreal Engine is both enjoyable and surprisingly accessible.
    
    
     Epic Games has done an excellent job of incorporating features that simplify C++ usage for nearly
    
    
     
      every programmer.
     
    
   </p>
   <p>
    
     While it is indeed possible to write standard C++ code in Unreal Engine, leveraging the engine’s most widely used features – such as the built-in garbage collector and reflection system – will help you achieve better performance in
    
    
     
      your games.
     
    
   </p>
   <p>
    
     In this section, I’ll be covering the basic principles behind Unreal Engine
    
    
     
      C++ features.
     
    
   </p>
   <h2 id="_idParaDest-289">
    <a id="_idTextAnchor291">
    </a>
    
     Understanding C++ classes
    
   </h2>
   <p>
    
     Unsurprisingly enough, an Unreal Engine
    
    <a id="_idIndexMarker786">
    </a>
    
     C++ class is essentially a standard C++ class!
    
    
     If you already have a solid understanding of object-oriented programming in C++, you’ll find the environment quite familiar.
    
    
     The process of creating a new C++ class starts by determining the type of object you want to represent, such as an actor or a
    
    <a id="_idIndexMarker787">
    </a>
    
     component.
    
    
     After defining the type, you declare variables and methods in the
    
    <strong class="bold">
     
      header file
     
    </strong>
    
     (which uses the
    
    <strong class="source-inline">
     
      .h
     
    </strong>
    
     extension) and implement the logic in
    
    <a id="_idIndexMarker788">
    </a>
    
     the
    
    <strong class="bold">
     
      source file
     
    </strong>
    
     (which uses the
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       cpp
      
     </strong>
    
    
     
      extension).
     
    
   </p>
   <p>
    
     The source file works just like any regular C++ file, but the header file allows you to specify additional information for variables and functions that will be accessible to Blueprints inheriting from your class.
    
    
     This also simplifies runtime memory management, as I will
    
    
     
      explain later.
     
    
   </p>
   <p>
    
     Let’s start by presenting the base types used by the Unreal
    
    
     
      Engine framework.
     
    
   </p>
   <h3>
    
     The base types
    
   </h3>
   <p>
    
     In UE, there are three
    
    <a id="_idIndexMarker789">
    </a>
    
     primary class types that you’ll be deriving from
    
    
     
      during development:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       UObject
      
     </strong>
     
      : This is the base class of Unreal Engine, providing core features such as networking support and reflection of properties
     
     
      
       and methods
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       AActor
      
     </strong>
     
      : This is a
     
     <strong class="source-inline">
      
       UObject
      
     </strong>
     
      type that can be added to a game level, either through the Editor or
     
     
      
       at runtime
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       UActorComponent
      
     </strong>
     
      : This is the fundamental class for defining components that can be attached to
     
     <a id="_idIndexMarker790">
     </a>
     
      an actor, or another component belonging to the
     
     
      
       same actor
      
     
    </li>
   </ul>
   <p>
    
     Additionally, UE provides the
    
    <a id="_idIndexMarker791">
    </a>
    
     
      following entities:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       UStruct
      
     </strong>
     
      : This is used to create simple
     
     
      
       data structures
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       UEnum
      
     </strong>
     
      : This is used to represent enumerations
     
     
      
       of elements
      
     
    </li>
   </ul>
   <h3>
    
     Unreal Engine prefixes
    
   </h3>
   <p>
    
     Unreal Engine class names begin with
    
    <a id="_idIndexMarker792">
    </a>
    
     specific letters; these prefixes are used to indicate the class type.
    
    
     The main prefixes used are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       U
      
     </strong>
     
      : This is used for generic objects that derive from
     
     <strong class="source-inline">
      
       UObject
      
     </strong>
     
      , such as components.
     
     
      A good example is the
     
     
      <strong class="source-inline">
       
        UStaticMeshComponent
       
      </strong>
     
     
      
       class.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       A
      
     </strong>
     
      : This is used for objects that derive from an actor – that is, the
     
     <strong class="source-inline">
      
       AActor
      
     </strong>
     
      class – and that can be added to
     
     
      
       a level.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       F
      
     </strong>
     
      : This is used for generic classes and structures, such as the
     
     
      <strong class="source-inline">
       
        FColor
       
      </strong>
     
     
      
       structure.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       T
      
     </strong>
     
      : This is used for templates, such as
     
     <strong class="source-inline">
      
       TArray
      
     </strong>
     
      
       or
      
     
     
      <strong class="source-inline">
       
        TMap
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       I
      
     </strong>
     
      : This is used for interfaces, such
     
     
      
       as
      
     
     
      <strong class="source-inline">
       
        IGameplayTaskOwnerInterface
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       E
      
     </strong>
     
      : This is used for enums, such
     
     
      
       as
      
     
     
      <strong class="source-inline">
       
        EActorBeginPlayState
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ul>
   <p>
    
     Note that these prefixes are mandatory; if you attempt to name a class that derives from
    
    <strong class="source-inline">
     
      AActor
     
    </strong>
    
     without the
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     prefix, you will encounter an error at compile time.
    
    
     This rule applies exclusively to C++ classes; Blueprints can be named without these prefixes.
    
    
     Unreal Engine will hide the C++ prefix once you are in
    
    
     
      the Editor.
     
    
   </p>
   <h2 id="_idParaDest-290">
    <a id="_idTextAnchor292">
    </a>
    
     Properties
    
   </h2>
   <p>
    
     As you may already know, in programming
    
    <a id="_idIndexMarker793">
    </a>
    
     languages, a
    
    <strong class="bold">
     
      property
     
    </strong>
    
     refers to a variable that is declared within a class.
    
    
     Adding properties to a C++ class requires some extra attention – specifically, we need to consider whether the code we write should be visible or hidden from the Blueprints that will inherit from
    
    
     
      our class.
     
    
   </p>
   <h3>
    
     Declaring a property
    
   </h3>
   <p>
    
     A property is
    
    <a id="_idIndexMarker794">
    </a>
    
     declared using the standard C++ syntax for variable declaration, preceded by the
    
    <strong class="source-inline">
     
      UPROPERTY()
     
    </strong>
    
     macro, which specifies various attributes – such as visibility in Blueprints – and any relevant metadata.
    
    
     As an example, consider the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
UPROPERTY(VisibleAnywhere, Category="Damage")
float Damage;</pre>
   <p>
    
     In the preceding example, setting the
    
    <strong class="source-inline">
     
      Damage
     
    </strong>
    
     variable as
    
    <strong class="source-inline">
     
      VisibleAnywhere
     
    </strong>
    
     will make the property visible to a Blueprint, but not modifiable.
    
    
     Additionally, it will be logically grouped under the
    
    <strong class="bold">
     
      Damage
     
    </strong>
    
     category in the
    
    
     <strong class="bold">
      
       Details
      
     </strong>
    
    
     
      panel.
     
    
   </p>
   <h3>
    
     Property specifiers
    
   </h3>
   <p>
    
     As you have already noticed, the
    
    <strong class="source-inline">
     
      UPROPERTY()
     
    </strong>
    
     can include a list of parameters, called
    
    <strong class="bold">
     
      property specifiers
     
    </strong>
    
     , that will
    
    <a id="_idIndexMarker795">
    </a>
    
     add additional functionality to a property.
    
    
     Some of them are
    
    
     
      listed here:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       VisibleAnywhere
      
     </strong>
     
      : The property is displayed but cannot be modified in the
     
     
      <strong class="bold">
       
        Details
       
      </strong>
     
     
      
       panel
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       EditAnywhere
      
     </strong>
     
      : The property can be modified in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel for both Blueprints and instances placed in
     
     
      
       the level
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       EditDefaultsOnly
      
     </strong>
     
      : The property can be modified in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel of the Blueprint but not in instances placed in
     
     
      
       the level
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       EditInstanceOnly
      
     </strong>
     
      : The property can be modified in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel of instances placed in the level but not in
     
     
      
       the Blueprint
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       BlueprintReadOnly
      
     </strong>
     
      : The property can be read within the Blueprint but cannot
     
     
      
       be assigned
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       BlueprintReadWrite
      
     </strong>
     
      : The property can be both read and assigned within
     
     
      
       the Blueprint
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-291">
    <a id="_idTextAnchor293">
    </a>
    
     Functions
    
   </h2>
   <p>
    
     Functions
    
    <a id="_idIndexMarker796">
    </a>
    
     work just like regular C++ functions.
    
    
     Additionally, just like properties, you can decorate them with a macro – in this case,
    
    <strong class="source-inline">
     
      UFUNCTION()
     
    </strong>
    
     – that can contain proper specifiers.
    
    
     As an example, consider the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
UFUNCTION(BlueprintCallable)
void Heal(float Amount);</pre>
   <p>
    
     In this case, the function can be called from a child Blueprint, as it has been decorated with the
    
    
     <strong class="source-inline">
      
       BlueprintCallable
      
     </strong>
    
    
     
      specifier.
     
    
   </p>
   <p>
    
     For a full list of
    
    <a id="_idIndexMarker797">
    </a>
    
     property and function specifiers, visit the official
    
    
     
      documentation:
     
    
    <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine">
     
      
       https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-292">
    <a id="_idTextAnchor294">
    </a>
    
     The C++ Header Preview
    
   </h2>
   <p>
    
     Unreal Engine comes packed with an
    
    <a id="_idIndexMarker798">
    </a>
    
     incredible inspection tool called the
    
    <strong class="bold">
     
      C++ Header Preview
     
    </strong>
    
     , which enables you to examine your Blueprint classes as if they were written in C++.
    
    
     To activate this tool, simply navigate to the main menu and select
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      C++ Header Preview
     
    </strong>
    
     , and then choose your desired class.
    
    
     For example,
    
    <em class="italic">
     
      Figure A.1
     
    </em>
    
     displays the header file of
    
    <strong class="bold">
     
      BP_Scrambler
     
    </strong>
    
     from this
    
    
     
      book project:
     
    
   </p>
   <div><div><img alt="img" role="presentation" src="img/Figure_A.1_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Figure">
    
     Figure A.1 – The C++ Header Preview tool
    
   </p>
   <p>
    
     This is an amazing tool if already have some Blueprint knowledge and want to be gently introduced to
    
    
     
      C++ programming.
     
    
   </p>
   <p>
    
     In this section, I have introduced you to some of the most basic features of C++ in Unreal Engine; in the next section, I will introduce some more advanced features that you may already be familiar with in C++ but that are handled somewhat differently in
    
    
     
      Unreal Engine.
     
    
   </p>
   <h1 id="_idParaDest-293">
    <a id="_idTextAnchor295">
    </a>
    
     Explaining advanced features
    
   </h1>
   <p>
    
     In this section, we are going to explore how Unreal Engine copes with some of the common features of C++, such as casting
    
    
     
      and delegates.
     
    
   </p>
   <h2 id="_idParaDest-294">
    <a id="_idTextAnchor296">
    </a>
    
     Casting
    
   </h2>
   <p>
    
     In C++ – and other programming
    
    <a id="_idIndexMarker799">
    </a>
    
     languages,
    
    <strong class="bold">
     
      casting
     
    </strong>
    
     is the process of converting a variable from one data type to another.
    
    
     It allows you to treat an object as a different type, which can be useful in various situations, such as when working with inheritance or interfacing with APIs.
    
    
     To cast in Unreal Engine, you use the
    
    <strong class="source-inline">
     
      Cast&lt;T&gt;()
     
    </strong>
    
     method.
    
    
     As an example, take a look at the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
APlayerCharacter* PlayerCharacter =
    Cast&lt;APlayerCharacter&gt;(Actor);</pre>
   <p>
    
     As you can see, we are trying to cast an
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     pointer to an
    
    
     <strong class="source-inline">
      
       APlayerCharacter
      
     </strong>
    
    
     
      type.
     
    
   </p>
   <p>
    
     In Unreal Engine, the
    
    <strong class="source-inline">
     
      Cast&lt;T&gt;()
     
    </strong>
    
     function is a safe way to cast pointers to a specific class type, as your code will return
    
    <strong class="source-inline">
     
      nullptr
     
    </strong>
    
     instead of crashing when the cast
    
    
     
      itself fails.
     
    
   </p>
   <p>
    
     Casting in Unreal Engine should be approached with caution for several reasons.
    
    
     First, it can introduce performance overhead; this can slow down your game if used frequently.
    
    
     Additionally, excessive casting can complicate code readability and understanding.
    
    
     It may obscure the relationships between classes, making it harder for developers to grasp the structure of the code base.
    
    
     One effective way to reduce class dependencies is by
    
    
     
      using interfaces.
     
    
   </p>
   <h2 id="_idParaDest-295">
    <a id="_idTextAnchor297">
    </a>
    
     Interfaces
    
   </h2>
   <p>
    
     In many programming languages,
    
    <strong class="bold">
     
      interfaces
     
    </strong>
    
     provide
    
    <a id="_idIndexMarker800">
    </a>
    
     a way to define functions for multiple classes without requiring any specific implementation.
    
    
     For example, your player character might activate different items in different ways.
    
    
     By defining an interface that declares an
    
    <strong class="source-inline">
     
      Activate()
     
    </strong>
    
     method, each item implementing the interface will define its own
    
    
     
      personal logic.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In Unreal Engine, interfaces differ from traditional programming interfaces, as you are not required to provide an implementation for
    
    
     
      declared functions.
     
    
   </p>
   <p>
    
     In Unreal Engine, interfaces will need the
    
    <strong class="source-inline">
     
      UINTERFACE()
     
    </strong>
    
     macro declaration and two class declarations (in the same file), with two different prefixes.
    
    
     As an example, an
    
    <strong class="source-inline">
     
      Activatable
     
    </strong>
    
     interface, with the
    
    <strong class="source-inline">
     
      Activate()
     
    </strong>
    
     function, will be written more or less like the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
UINTERFACE(MinimalAPI)
class UActivatable : public UInterface
{
    GENERATED_BODY()
};
class IActivatable
{
    GENERATED_BODY()
    void Activate();
public:
    UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
    void Activate();
};</pre>
   <p>
    
     In this example, the
    
    <strong class="source-inline">
     
      UActivatable
     
    </strong>
    
     class declaration is a
    
    <strong class="source-inline">
     
      UObject
     
    </strong>
    
     class that contains all the reflection information related to the interface.
    
    
     Being a
    
    <strong class="source-inline">
     
      UObject
     
    </strong>
    
     class, it possesses all the features you would normally expect, such as having a name, the ability to be serialized, and
    
    <a id="_idIndexMarker801">
    </a>
    
     support
    
    
     
      for reflection.
     
    
   </p>
   <p>
    
     Conversely, the
    
    <strong class="source-inline">
     
      IActivatable
     
    </strong>
    
     class declaration is the actual native class used by the compiler to inject virtual functions into
    
    
     
      your class.
     
    
   </p>
   <h2 id="_idParaDest-296">
    <a id="_idTextAnchor298">
    </a>
    
     Delegates
    
   </h2>
   <p>
    
     In C++, a
    
    <strong class="bold">
     
      delegate
     
    </strong>
    
     is a type
    
    <a id="_idIndexMarker802">
    </a>
    
     that lets you reference a function, enabling you to call that function indirectly.
    
    
     Delegates are often used for event handling and callback mechanisms, allowing different parts of a program to communicate in a decoupled way.
    
    
     In Unreal Engine, delegates are specifically designed for use with the engine’s event system.
    
    
     They allow you to bind functions to events so that when the event occurs, the bound functions are
    
    
     
      called automatically.
     
    
   </p>
   <p>
    
     In Unreal Engine, there are several types
    
    
     
      of delegates:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Single-cast
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker803">
     </a>
     
      delegates only allow one function to be bound to the
     
     <a id="_idIndexMarker804">
     </a>
     
      delegate at a time.
     
     
      They are ideal for scenarios where you want to ensure that only one event handler responds to
     
     
      
       an event.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Multicast
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker805">
     </a>
     
      delegates can have multiple functions bound to
     
     <a id="_idIndexMarker806">
     </a>
     
      them, allowing multiple event handlers to respond to the same event.
     
     
      They are suitable for scenarios where several components or classes need to listen to the same event and
     
     
      
       respond accordingly.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Dynamic
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker807">
     </a>
     
      delegates are a type of delegate that can be
     
     <a id="_idIndexMarker808">
     </a>
     
      serialized and are compatible with Unreal Engine’s reflection system.
     
     
      They allow you to bind and unbind functions at runtime and can be easily exposed to Blueprints, making them
     
     
      
       very versatile.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Dynamic multicast
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker809">
     </a>
     
      delegates combine both dynamic and
     
     <a id="_idIndexMarker810">
     </a>
     
      
       multicast delegates.
      
     
    </li>
   </ul>
   <p>
    
     If you work in a hybrid Blueprint/C++ project, chances are that you’ll be mostly working with dynamic multicast delegates; this will let you expose delegates to Blueprints and bind multiple functions to them.
    
    
     Just keep in mind that, although highly flexible and powerful, using them might impact performance due to
    
    
     
      runtime binding.
     
    
   </p>
   <h3>
    
     Declaring a delegate
    
   </h3>
   <p>
    
     Whenever you declare a
    
    <a id="_idIndexMarker811">
    </a>
    
     delegate, you will use a macro starting with the
    
    <strong class="source-inline">
     
      DECLARE_
     
    </strong>
    
     prefix.
    
    
     For example, to declare a dynamic multicast delegate with a single parameter, you will use the
    
    
     
      following syntax:
     
    
   </p>
   <pre class="source-code">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(OnDamageTakenSignature, float, Amount);</pre>
   <p>
    
     As you can see, the delegate declaration defines the delegate name, the parameter type, and the
    
    
     
      parameter name.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     For a full
    
    <a id="_idIndexMarker812">
    </a>
    
     list of the available delegate declarations, check out the official
    
    
     
      documentation:
     
    
    <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine">
     
      
       https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine
      
     
    </a>
    
     
      .
     
    
   </p>
   <h3>
    
     Creating a variable of a delegate type
    
   </h3>
   <p>
    
     To
    
    <a id="_idIndexMarker813">
    </a>
    
     create a variable
    
    <a id="_idIndexMarker814">
    </a>
    
     out of a delegate type, you will use the
    
    
     
      following syntax:
     
    
   </p>
   <pre class="source-code">
UPROPERTY(BlueprintAssignable)
OnDamageTakenSignature OnDamageTaken;</pre>
   <p>
    
     Note the use of the
    
    <strong class="source-inline">
     
      BlueprintAssignable
     
    </strong>
    
     specifier that will make this property accessible
    
    
     
      to Blueprints.
     
    
   </p>
   <h3>
    
     Subscribing to a delegate
    
   </h3>
   <p>
    
     Subscribing to a
    
    <a id="_idIndexMarker815">
    </a>
    
     delegate varies, depending on whether it is multicast or not, as well as whether it is dynamic or non-dynamic.
    
    
     In our example, the delegate is dynamic and multicast, so we will use the
    
    
     
      following syntax:
     
    
   </p>
   <pre class="source-code">
OnDamageTaken.AddDynamic(this, &amp;ClassName::HandleDamage);</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      HandleDamage()
     
    </strong>
    
     function will be similar to the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
void HandleDamage(float Amount)
{ /** Function implementation **/ }</pre>
   <h3>
    
     Calling a delegate
    
   </h3>
   <p>
    
     Calling a
    
    <a id="_idIndexMarker816">
    </a>
    
     delegate is quite straightforward, as you will use the
    
    <strong class="source-inline">
     
      Broadcast()
     
    </strong>
    
     function for multicast delegates and the
    
    <strong class="source-inline">
     
      Execute()
     
    </strong>
    
     function otherwise.
    
    
     Calling a delegate from our example will look like the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
OnDamageTaken.Broadcast(30.f);</pre>
   <p>
    
     Here,
    
    <strong class="source-inline">
     
      30.f
     
    </strong>
    
     is the damage taken by the
    
    
     
      listening object.
     
    
   </p>
   <p>
    
     In this section, I have presented some of the key features that distinguish Unreal Engine C++ from standard C++ programming.
    
    
     In the next section, we are going to delve deep into some of the most important inner features of
    
    
     
      Unreal Engine.
     
    
   </p>
   <h1 id="_idParaDest-297">
    <a id="_idTextAnchor299">
    </a>
    
     Exploring core mechanics
    
   </h1>
   <p>
    
     In this section, we will delve into more sophisticated features, such as memory management and reflection, and explain how Unreal Engine copes
    
    
     
      with them.
     
    
   </p>
   <h2 id="_idParaDest-298">
    <a id="_idTextAnchor300">
    </a>
    
     Garbage collection
    
   </h2>
   <p>
    
     As you may already know,
    
    <strong class="bold">
     
      garbage collection
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GC
     
    </strong>
    
     ) is a
    
    <a id="_idIndexMarker817">
    </a>
    
     way to automatically manage memory.
    
    
     In a GC-managed system, once an object is no longer used, it will be automatically removed from memory to free space.
    
    
     This allows you to create a new object and use it, and when you’re finished using it, you will simply be good to go.
    
    
     This system is managed by
    
    <a id="_idIndexMarker818">
    </a>
    
     the
    
    <strong class="bold">
     
      garbage collector
     
    </strong>
    
     , which constantly monitors which objects are still in use.
    
    
     When an object is no longer needed, the garbage collector automatically frees up the
    
    
     
      associated memory.
     
    
   </p>
   <p>
    
     While
    
    <a id="_idIndexMarker819">
    </a>
    
     GC is used by many modern programming languages – such as C# and Python – lower-level languages such as C and C++ do not include a garbage collector by default.
    
    
     As a result, programmers must manually track memory usage and free it when it’s no longer needed.
    
    
     This process can be error-prone and more challenging for developers to manage.
    
    
     To address this issue, Unreal Engine has implemented its own
    
    
     
      GC system.
     
    
   </p>
   <h3>
    
     How is GC used by Unreal Engine?
    
   </h3>
   <p>
    
     When an object derived from the
    
    <strong class="source-inline">
     
      UObject
     
    </strong>
    
     class is instantiated, it will be registered with Unreal Engine’s GC system.
    
    
     This system automatically runs at predefined time intervals – about 30 to 60 seconds – to identify and remove any objects that are no longer
    
    
     
      in use.
     
    
   </p>
   <p>
    
     The GC system keeps a set of root objects that are defined to remain alive indefinitely.
    
    
     Additionally, it uses reflection – something that C++ lacks but that Unreal Engine has natively – to examine the properties of an object.
    
    
     This allows the GC system to follow references to other objects and
    
    
     
      their properties.
     
    
   </p>
   <p>
    
     If an object is
    
    <a id="_idIndexMarker820">
    </a>
    
     discovered while traversing other objects, and one of those objects is part of the root set, then the object is deemed reachable and remains alive.
    
    
     Once all objects are examined, and if there is no way to reach an object in the root set via references, that object is considered unreachable and marked to
    
    
     
      be garbage-collected.
     
    
   </p>
   <p>
    
     When an object is garbage-collected, the memory it occupies is freed and returned to the system; any pointers that referenced this object will be set
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       null
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     It should be noted that manual memory management – the one you should be used to if you come from a pure C++ background – is still an option in Unreal Engine, but it cannot be used on any
    
    <strong class="source-inline">
     
      UObject
     
    </strong>
    
     
      derived classes.
     
    
   </p>
   <h3>
    
     Using GC in Unreal Engine
    
   </h3>
   <p>
    
     If you have a pointer
    
    <a id="_idIndexMarker821">
    </a>
    
     within a function, you don’t need to be concerned about the GC, as pointers inside functions behave like standard C/C++ pointers and do not require
    
    
     
      any modifications.
     
    
   </p>
   <p>
    
     Conversely, if you want to have a pointer to an object that you need to persist across frames, you will need to add some small additional code; the pointer needs to be stored as a member variable in your class, and you must add the
    
    <strong class="source-inline">
     
      UPROPERTY()
     
    </strong>
    
     macro before it.
    
    
     That’s all you need to do to have the reference that follows be considered by the
    
    
     
      GC system.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      UPROPERTY()
     
    </strong>
    
     macro can only be used inside classes that derive from
    
    <strong class="source-inline">
     
      UObject
     
    </strong>
    
     ; otherwise, you will have to handle
    
    
     
      memory manually.
     
    
   </p>
   <h2 id="_idParaDest-299">
    <a id="_idTextAnchor301">
    </a>
    
     The reflection system
    
   </h2>
   <p>
    
     The term
    
    <strong class="bold">
     
      reflection
     
    </strong>
    
     refers
    
    <a id="_idIndexMarker822">
    </a>
    
     to the ability of a program to inspect its own structure at runtime; this feature is extremely valuable and one of the core technologies used by Unreal Engine, supporting various systems such as the
    
    <strong class="bold">
     
      Detail
     
    </strong>
    
     panel in the Editor, serialization, GC, and communication between Blueprint
    
    
     
      and C++.
     
    
   </p>
   <p>
    
     Since there is no native support for reflection in C++, Epic Games has created its own system to gather, examine, and modify data related to C++ classes, structs, and more within
    
    
     
      the engine.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     The reflection system also empowers all the Editor’s panels, making Unreal Engine’s UI
    
    
     
      highly customizable.
     
    
   </p>
   <p>
    
     In order to let the system use reflection, you will need to annotate any type or property that you want to expose to the system.
    
    
     This annotation will use macros such as
    
    <strong class="source-inline">
     
      UCLASS()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      UFUNCTION()
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      UPROPERTY()
     
    </strong>
    
     .
    
    
     Finally, to enable these annotations, you will need to add the
    
    <strong class="source-inline">
     
      #include "AClassName.generated.h"
     
    </strong>
    
     declaration.
    
    
     This declaration is automatically generated when you create a class from the Unreal Engine Editor, so you won’t need to worry
    
    
     
      about it.
     
    
   </p>
   <p>
    
     As an example, consider
    
    <a id="_idIndexMarker823">
    </a>
    
     the following block of code from the
    
    <strong class="source-inline">
     
      BaseSecurityCam.h
     
    </strong>
    
     file you created in this
    
    
     
      book project:
     
    
   </p>
   <pre class="source-code">
#pragma once
#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "BaseSecurityCam.generated.h"
class UAIPerceptionComponent;
UCLASS(Blueprintable)
class UNREALAGILITYARENA_API ABaseSecurityCam :
    public APawn
{
    GENERATED_BODY()
    UPROPERTY(VisibleAnywhere,
              BlueprintReadOnly,
              Category="Security Cam",
              meta=(AllowPrivateAccess="true"))
    UStaticMeshComponent* SupportMeshComponent;
    UPROPERTY(VisibleAnywhere,
              BlueprintReadOnly,
              Category="Security Cam",
              meta=(AllowPrivateAccess="true"))
    UStaticMeshComponent* CamMeshComponent;
public:
    ABaseSecurityCam();
};</pre>
   <p>
    
     You will have noticed the presence of the
    
    <strong class="source-inline">
     
      #include "BaseSecurityCam.generated.h"
     
    </strong>
    
     declaration and the use of the
    
    <strong class="source-inline">
     
      UPROPERTY()
     
    </strong>
    
     macro for the
    
    
     
      components’ declarations.
     
    
   </p>
   <p>
    
     The following list outlines the fundamental markup elements available within the
    
    
     
      reflection system:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       UCLASS()
      
     </strong>
     
      : Generates reflection data for a class that derives
     
     
      
       from
      
     
     
      <strong class="source-inline">
       
        UObject
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       USTRUCT()
      
     </strong>
     
      : Generates reflection data for
     
     
      
       a struct
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       GENERATED_BODY()
      
     </strong>
     
      : Will be replaced with all the necessary boilerplate code for the
     
     
      
       class type
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       UPROPERTY()
      
     </strong>
     
      : Informs the engine that the associated member variable will have additional features, such as
     
     
      
       Blueprint accessibility
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       UFUNCTION()
      
     </strong>
     
      : Allows, among other things, us to call the decorated function from an extending
     
     <a id="_idIndexMarker824">
     </a>
     
      Blueprint class or override the function from the
     
     
      
       Blueprint itself
      
     
    </li>
   </ul>
   <p>
    
     The reflection system is also used by the garbage collector, so you won’t need to worry about memory management, as explained in the
    
    
     
      GC subsection.
     
    
   </p>
   <h1 id="_idParaDest-300">
    <a id="_idTextAnchor302">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this appendix, I provided an overview of how C++ is used within Unreal Engine, highlighting its unique features and functionalities.
    
    
     We explored the integration of C++ with the engine’s architecture, some of the differences between Unreal Engine C++ and standard C++, and the benefits of using C++ inside the engine itself.
    
    
     We also discussed key concepts such as delegates and memory management, emphasizing their most important peculiarities and features.
    
    
     Additionally, we introduced the C++ Header Preview tool; such an instrument is a must-have if you don’t have much experience with C++ for Unreal Engine and you want to make the transition
    
    
     
      from Blueprints.
     
    
   </p>
  </div>
 </body></html>