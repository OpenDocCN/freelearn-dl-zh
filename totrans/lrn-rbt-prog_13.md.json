["```py\n    from robot import Robot\n    import time\n    import logging\n    ...\n    ```", "```py\n    ...\n    from gpiozero import DigitalInputDevice\n    logger = logging.getLogger(\"test_encoders\")\n    ...\n    ```", "```py\n    ...\n    class EncoderCounter(object):\n        def __init__(self, pin_number):\n            self.pulse_count = 0\n            ...\n    ```", "```py\n          ...\n          self.device = DigitalInputDevice(pin=pin_number)\n          self.device.pin.when_changed = self.when_changed\n      ...\n    ```", "```py\n        ...\n        def when_changed(self, _, state):\n            self.pulse_count += 1\n    ...\n    ```", "```py\n    ...\n    bot = Robot()\n    left_encoder = EncoderCounter(4)\n    right_encoder = EncoderCounter(26)\n    ...\n    ```", "```py\n    ...\n    stop_at_time = time.time() + 1\n    logging.basicConfig(level=logging.INFO)\n    bot.set_left(90)\n    bot.set_right(90)\n    while time.time() < stop_at_time:\n        ...\n    ```", "```py\n    f prefix lets us format variables into a string.\n    ```", "```py\npi@myrobot:~ $ python3 test_encoders.py\nINFO:test_encoders:Left: 0 Right: 0\nINFO:test_encoders:Left: 0 Right: 1\nINFO:test_encoders:Left: 2 Right: 2\nINFO:test_encoders:Left: 3 Right: 4\nINFO:test_encoders:Left: 5 Right: 7\nINFO:test_encoders:Left: 8 Right: 10\nINFO:test_encoders:Left: 10 Right: 14\n...\nINFO:test_encoders:Left: 56 Right: 74\n```", "```py\n    from gpiozero import DigitalInputDevice\n    class EncoderCounter:\n        def __init__(self, pin_number):\n            self.pulse_count = 0\n    ```", "```py\n            self.direction = 1\n    ```", "```py\n          self.device = DigitalInputDevice(pin=pin_number)\n          self.device.pin.when_changed = self.when_changed\n    ```", "```py\n        def when_changed(self, time_ticks, state):\n            self.pulse_count += self.direction\n    ```", "```py\n        def set_direction(self, direction):\n            \"\"\"This should be -1 or 1.\"\"\"\n            assert abs(direction)==1, \"Direction %s should be 1 or -1\" % direction\n            self.direction = direction\n    ```", "```py\n        def reset(self):\n            self.pulse_count = 0\n    ```", "```py\n        def stop(self):\n            self.device.close()\n    ```", "```py\n    ...\n    import leds_led_shim\n    from servos import Servos\n    from encoder_counter import EncoderCounter\n    ...\n    ```", "```py\n            ...\n            # Setup The Distance Sensors\n    self.left_distance_sensor = DistanceSensor(echo=17, trigger=27, queue_len=2)\n            self.right_distance_sensor = DistanceSensor(echo=5, trigger=6, queue_len=2)\n            # Setup the Encoders\n            self.left_encoder = EncoderCounter(4)\n            self.right_encoder = EncoderCounter(26)\n            ...\n    ```", "```py\n            ...\n            # Clear the display\n            self.leds.clear()\n            self.leds.show()\n            # Clear any sensor handlers\n            self.left_encoder.stop()\n            self.right_encoder.stop()\n            ...\n    ```", "```py\n    from robot import Robot\n    import time\n    import math\n    import logging\n    logger = logging.getLogger(\"test_distance_travelled\")\n    ...\n    ```", "```py\n    ...\n    wheel_diameter_mm = 70.0\n    ticks_per_revolution = 40.0\n    ...\n    ```", "```py\n    ...\n    ticks_to_mm_const = (math.pi / ticks_per_revolution) * wheel_diameter_mm\n    def ticks_to_mm(ticks):\n        return int(ticks_to_mm_const * ticks)\n    ...\n    ```", "```py\n    ...\n    bot = Robot()\n    stop_at_time = time.time() + 1\n    logging.basicConfig(level=logging.INFO)\n    bot.set_left(90)\n    bot.set_right(90)\n    ...\n    ```", "```py\n    ...\n    while time.time() < stop_at_time:\n        logger.info(\"Left: {} Right: {}\".format(\n            ticks_to_mm(bot.left_encoder.pulse_count),\n            ticks_to_mm(bot.right_encoder.pulse_count)))    time.sleep(0.05)\n    ```", "```py\npi@myrobot:~ $ python3 test_distance_travelled.py\nINFO:test_distance_travelled:Left: 0 Right: 0\nINFO:test_distance_travelled:Left: 5 Right: 0\nINFO:test_distance_travelled:Left: 16 Right: 10\nINFO:test_distance_travelled:Left: 32 Right: 21\n...\n...\nINFO:test_distance_travelled:Left: 368 Right: 384\nINFO:test_distance_travelled:Left: 395 Right: 417\n```", "```py\n...\nintegral_sum = integral_sum  + error\nright_motor_speed = speed + (error * proportional_constant) + (integral_sum * integral_constant)\n...\n```", "```py\n    ...\n        def handle_proportional(self, error):\n            return self.proportional_constant * error\n        def handle_integral(self, error):\n            self.integral_sum += error\n            return self.integral_constant * self.integral_sum\n    ...\n    ```", "```py\n    p and i; since we log these values, we can configure logging to show them when debugging and tuning the controller.\n    ```", "```py\n    from robot import Robot\n    from pid_controller import PIController\n    import time\n    import logging\n    logger = logging.getLogger(\"straight_line \")\n    logging.basicConfig(level=logging.INFO)\n    logging.getLogger(\"pid_controller\").setLevel(logging.DEBUG)\n    ```", "```py\n    bot = Robot()\n    stop_at_time = time.time() + 15\n    ...\n    ```", "```py\n    ...\n    speed = 80\n    bot.set_left(speed)\n    bot.set_right(speed)\n    ...\n    ```", "```py\n    ...\n    pid = PIController(proportional_constant=5, integral_constant=0.3)\n    ...\n    ```", "```py\n    ...\n    while time.time() < stop_at_time:\n        time.sleep(0.01)\n        # Calculate the error\n        left = bot.left_encoder.pulse_count\n        right = bot.right_encoder.pulse_count\n        error = left - right\n        ...\n    ```", "```py\n        ...\n        # Get the speed\n        adjustment = pid.get_value(error)\n        right_speed = int(speed + adjustment)\n        left_speed = int(speed - adjustment)\n        ...\n    ```", "```py\n        ...\n        logger.debug(f\"error: {error} adjustment: {adjustment:.2f}\")\n        logger.info(f\"left: {left} right: {right}, left_speed: {left_speed} right_speed: {right_speed}\")\n        ...\n    ```", "```py\n        ...\n        bot.set_left(left_speed)\n        bot.set_right(right_speed)\n    ```", "```py\npi@myrobot:~ $ python3 straight_line_drive.py\nDEBUG:pid_controller:P: 0, I: 0.00\nINFO:straight_line:left: 3 right: 3, left_speed: 80 right_speed: 80\nDEBUG:pid_controller:P: 0, I: 0.00\nINFO:straight_line:left: 5 right: 5, left_speed: 80 right_speed: 80\nDEBUG:pid_controller:P: -4, I: -0.20\nINFO:straight_line:left: 5 right: 6, left_speed: 84 right_speed: 75\nDEBUG:pid_controller:P: 0, I: -0.20\n...\nINFO:straight_line:left: 13 right: 15, left_speed: 89 right_speed: 71\nDEBUG:pid_controller:P: -8, I: -1.40\nINFO:straight_line:left: 15 right: 17, left_speed: 89 right_speed: 70\nDEBUG:pid_controller:P: -8, I: -1.80\nINFO:straight_line:left: 17 right: 19, left_speed: 89 right_speed: 70\nDEBUG:pid_controller:P: -8, I: -2.20\nINFO:straight_line:left: 19 right: 21, left_speed: 90 right_speed: 69\n...\nDEBUG:pid_controller:P: 0, I: 0.60\nINFO:straight_line:left: 217 right: 217, left_speed: 79 right_speed: 80\nDEBUG:pid_controller:P: 0, I: 0.60\nINFO:straight_line:left: 219 right: 219, left_speed: 79 right_speed: 80\nDEBUG:pid_controller:P: 0, I: 0.60\nINFO:straight_line:left: 221 right: 221, left_speed: 79 right_speed: 80\nDEBUG:pid_controller:P: 0, I: 0.60\nINFO:straight_line:left: 223 right: 223, left_speed: 79 right_speed: 80\n```", "```py\n    from gpiozero import DigitalInputDevice\n    import math\n    ...\n    ```", "```py\n    ...\n    class EncoderCounter:\n        ticks_to_mm_const = None # you must set this up before using distance methods\n         ...\n    ```", "```py\n    ticks_to_mm_const from the class and not self (the instance). \n    ```", "```py\n        ...\n        @staticmethod\n        def mm_to_ticks(mm):\n            return mm / EncoderCounter.ticks_to_mm_const\n        ...\n    ```", "```py\n        ...\n        @staticmethod\n     def set_constants(wheel_diameter_mm, ticks_per_revolution):\n         EncoderCounter.ticks_to_mm_const = (math.pi / ticks_per_revolution) * wheel_diameter_mm\n        ...\n    ```", "```py\n    ...\n    class Robot:\n        wheel_diameter_mm = 70.0\n        ticks_per_revolution = 40.0\n        wheel_distance_mm = 140.0\n        def __init__(self, motorhat_addr=0x6f):\n            ...\n    ```", "```py\n            ...\n            # Setup the Encoders\n            EncoderCounter.set_constants(self.wheel_diameter_mm, self.ticks_per_revolution)\n            self.left_encoder = EncoderCounter(4)\n            self.right_encoder = EncoderCounter(26)\n            ....\n    ```", "```py\n    from robot import Robot, EncoderCounter\n    from pid_controller import PIController\n    import time\n    import logging\n    logger = logging.getLogger(\"drive_distance\")\n    ...\n    ```", "```py\n    set_left and set_right functions in variables – we can just call the variables like functions. \n    ```", "```py\n        ...\n        controller = PIController(proportional_constant=5, integral_constant=0.3)\n        # start the motors and start the loop\n        set_primary(speed)\n        set_secondary(speed)\n        ...\n    ```", "```py\n        ...\n        while primary_encoder.pulse_count < distance or secondary_encoder.pulse_count < distance:\n            time.sleep(0.01)\n            ...\n    ```", "```py\n            ...\n            # How far off are we?\n            error = primary_encoder.pulse_count - secondary_encoder.pulse_count\n            adjustment = controller.get_value(error)\n            ...\n    ```", "```py\n    ... \n            # How fast should the motor move to get there?\n            set_primary(int(speed - adjustment))\n            set_secondary(int(speed + adjustment))\n            # Some debug\n    logger.debug(f\"Encoders: primary: {primary_encoder.pulse_count}, secondary: {secondary_encoder.pulse_count},\" \n                        f\"e:{error} adjustment: {adjustment:.2f}\")\n            logger.info(f\"Distances: primary: {primary_encoder.distance_in_mm()} mm, secondary: {econdary_encoder.distance_in_mm()} mm\")\n    ...\n    ```", "```py\n    ...\n    logging.basicConfig(level=logging.INFO)\n    bot = Robot()\n    distance_to_drive = 1000 # in mm - this is a meter\n    distance_in_ticks = EncoderCounter.mm_to_ticks(distance_to_drive)\n    drive_distance(bot, distance_in_ticks)\n    ```", "```py\nINFO:drive_distance:Distances: primary: 997 mm, secondary: 991 mm\nINFO:drive_distance:Distances: primary: 1002 mm, secondary: 1002 mm\n```", "```py\n    from robot import Robot, EncoderCounter\n    from pid_controller import PIController\n    import time\n    import math\n    import logging\n    logger = logging.getLogger(\"drive_square\")\n    ...\n    ```", "```py\n    ...\n    bot = Robot()\n    distance_to_drive = 300 # in mm\n    distance_in_ticks = EncoderCounter.mm_to_ticks(distance_to_drive)\n    radius = bot.wheel_distance_mm + 100 # in mm\n    radius_in_ticks = EncoderCounter.mm_to_ticks(radius)\n    ...\n    ```", "```py\n    ...\n    for n in range(4):\n        drive_distances(bot, distance_in_ticks, distance_in_ticks)\n        drive_arc(bot, 90, radius_in_ticks, speed=50)\n    ```", "```py\n    ...\n    def drive_distances(bot, left_distance, right_distance, speed=80):\n        ...\n    ```", "```py\n    abs, the absolute value, to decide, because a longer distance in reverse should *still* be the primary motor. So, to determine how far the secondary wheel should go, we compute a ratio – to multiply with speed now, and later the primary encoder output. \n    ```", "```py\n        ...\n        primary_encoder.reset()\n        secondary_encoder.reset()\n\n        controller = PIController(proportional_constant=5, integral_constant=0.2)\n        ...\n    ```", "```py\n    ...\n        # Ensure that the encoder knows which way it is going\n        primary_encoder.set_direction(math.copysign(1, speed))\n        secondary_encoder.set_direction(math.copysign(1, secondary_speed))\n        # start the motors, and start the loop\n        set_primary(speed)\n        set_secondary(int(secondary_speed))\n    ...\n    ```", "```py\n    ...\n        while abs(primary_encoder.pulse_count) < abs(primary_distance) or abs(secondary_encoder.pulse_count) < abs(secondary_distance):\n            time.sleep(0.01)\n    ...\n    ```", "```py\n    ...\n            # How far off are we?\n            secondary_target = primary_encoder.pulse_count * primary_to_secondary_ratio\n            error = secondary_target - secondary_encoder.pulse_count\n            adjustment = controller.get_value(error)\n            ...\n    ```", "```py\n          ...\n          # How fast should the motors move to get there?\n          set_secondary(int(secondary_speed + adjustment))\n          secondary_encoder.set_direction(math.copysign(1, secondary_speed+adjustment))\n          # Some debug\n          logger.debug(f\"Encoders: primary: {primary_encoder.pulse_count}, secondary: {secondary_encoder.pulse_count}, e:{error} adjustment: {adjustment:.2f}\")\n          logger.info(f\"Distances: primary: {primary_encoder.distance_in_mm()} mm, secondary: {secondary_encoder.distance_in_mm()} mm\")\n          ...\n    ```", "```py\n            ...\n            # Stop the primary if we need to\n            if abs(primary_encoder.pulse_count) >= abs(primary_distance):\n                logger.info(\"primary stop\")\n                set_primary(0)\n                secondary_speed = 0\n            ...\n    ```", "```py\n    ...\n    def drive_arc(bot, turn_in_degrees, radius, speed=80):\n        \"\"\" Turn is based on change in heading. \"\"\"\n        ...\n    ```", "```py\n        ...\n        # Get the bot width in ticks\n        half_width_ticks = EncoderCounter.mm_to_ticks(bot.wheel_distance_mm/2.0)\n        if turn_in_degrees < 0:\n            left_radius = radius - half_width_ticks\n            right_radius = radius + half_width_ticks\n        else:\n            left_radius = radius + half_width_ticks\n            right_radius = radius - half_width_ticks\n        logger.info(f\"Arc left radius {left_radius:.2f}, right_radius {right_radius:.2f}\")\n        ...\n    ```", "```py\n        ...\n        radians = math.radians(abs(turn_in_degrees))\n        left_distance = int(left_radius * radians)\n        right_distance = int(right_radius * radians)\n        logger.info(f\"Arc left distance {left_distance}, right_distance {right_distance}\")\n        ...\n    ```", "```py\n        ...\n        drive_distances(bot, left_distance, right_distance, speed=speed)\n    ...\n    ```"]