<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using Fuzzy Logic to Make Your AI Seem Alive</h1>
                </header>
            
            <article>
                
<p>Fuzzy logic is a fantastic way to represent the rules of your game in a more nuanced way. Perhaps more so than other concepts in this book, fuzzy logic is a very math-heavy topic. Most of the information can be represented purely in mathematical functions. For the sake of teaching the important concepts as they apply to Unity, most of the math has been simplified and implemented using Unity's built-in features. Of course, if you are the type who loves math, this is a somewhat deep topic in that regard, so feel free to take the concepts covered in this book and run with them! In this chapter, we'll learn the following:</p>
<ul>
<li>What fuzzy logic is</li>
<li>Where fuzzy logic is used</li>
<li>How to implement fuzzy logic controllers</li>
<li>What the other creative uses for fuzzy logic concepts are</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining fuzzy logic</h1>
                </header>
            
            <article>
                
<p>The simplest way to define fuzzy logic is by comparison to binary logic. In the previous chapters, we looked at transition rules as true or false or 0 or 1 values. Is something visible? Is it at least a certain distance away? Even in instances where multiple values were being evaluated, all of the values had exactly two outcomes; thus, they were binary. In contrast, fuzzy values represent a much richer range of possibilities, where each value is represented as a float rather than an integer. We stop looking at values as 0 or 1, and we start looking at them as 0 to 1.</p>
<p>A common example used to describe fuzzy logic is temperature. Fuzzy logic allows us to make decisions based on non-specific data. I can step outside on a sunny Californian summer's day and ascertain that it is warm, without knowing the temperature precisely. Conversely, if I were to find myself in Alaska during the winter, I would know that it is cold, again, without knowing the exact temperature. These concepts of cold, cool, warm, and hot are fuzzy ones. There is a good amount of ambiguity as to at what point we go from warm to hot. Fuzzy logic allows us to model these concepts as sets and determine their validity or truth by using a set of rules.</p>
<p>When people make decisions, people have some gray areas. That is to say, it's not always black and white. The same concept applies to agents that rely on fuzzy logic. Say you hadn't eaten in a few hours, and you were starting to feel a little hungry. At which point were you hungry enough to go grab a snack? You could look at the time right after a meal as 0, and 1 would be the point where you approached starvation. The following figure illustrates this point:</p>
<div class="CDPAlignCenter CDPAlign"><img height="116" width="175" src="assets/1cbfd7ea-ab8e-4c55-b672-4a68d65ad2c6.png"/></div>
<p>When making decisions, there are many factors that determine the ultimate choice. This leads into another aspect of fuzzy logic controllers—they can take into account as much data as necessary. Let's continue to look at our "should I eat?" example. We've only considered one value for making that decision, which is the time since the last time you ate. However, there are other factors that can affect this decision, such as how much energy you're expending and how lazy you are at that particular moment. Or am I the only one to use that as a deciding factor? Either way, you can see how multiple input values can affect the output, which we can think of as the "likeliness to have another meal."</p>
<p>Fuzzy logic systems can be very flexible due to their generic nature. You provide input, the fuzzy logic provides an output. What that output means to your game is entirely up to you. We've primarily looked at how the inputs would affect a decision, which, in reality, is taking the output and using it in a way the computer, our agent, can understand. However, the output can also be used to determine how much of something to do, how fast something happens, or for how long something happens.</p>
<p>For example, imagine your agent is a car in a sci-fi racing game that has a "nitro-boost" ability that lets it expend a resource to go faster. Our 0 to 1 value can represent a normalized amount of time for it to use that boost or perhaps a normalized amount of fuel to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Picking fuzzy systems over binary systems</h1>
                </header>
            
            <article>
                
<p>As with the previous systems we covered in this book, and with most things in game programming, we must evaluate the requirements of our game and the technology and hardware limitations when deciding on the best way to tackle a problem.</p>
<p>As you might imagine, there is a performance cost associated with going from a simple yes/no system to a more nuanced fuzzy logic one, which is one of the reasons we may opt out of using it. Of course, being a more complex system doesn't necessarily always mean it's a better one. There will be times when you just want the simplicity and predictability of a binary system because it may fit your game better.</p>
<p>While there is some truth to the old adage, "the simpler, the better", one should also take into account the saying, "everything should be made as simple as possible, but not simpler". Though the quote is widely attributed to Albert Einstein, the father of relativity, it's not entirely clear who said it. The important thing to consider is the meaning of the quote itself. You should make your AI as simple as your game needs it to be, but not simpler. Pac-Man's AI works perfectly for the game–it's simple enough. However, rules say that simple would be out of place in a modern shooter or strategy game.</p>
<p>Take the knowledge and examples in this book and find what works best for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using fuzzy logic</h1>
                </header>
            
            <article>
                
<p>Once you understand the simple concepts behind fuzzy logic, it's easy to start thinking of the many, many ways in which it can be useful. In reality, it's just another tool in our belt, and each job requires different tools.</p>
<p>Fuzzy logic is great at taking some data, evaluating it in a similar <span>way</span><span> </span><span>to how a human would (albeit in a much simpler way), and then translating the data back to information that is usable by the system.</span></p>
<p>Fuzzy logic controllers have several real-world use cases. Some are more obvious than others, and while these are by no means one-to-one comparisons to our usage in game AI, they serve to illustrate a point:</p>
<ul>
<li><strong>Heating ventilation and air conditioning (HVAC) systems</strong>: The temperature example when talking about fuzzy logic is not only a good theoretical approach to explaining fuzzy logic, but also a very common real-world example of fuzzy logic controllers in action.</li>
<li><strong>Automobiles</strong>: Modern automobiles come equipped with very sophisticated computerized systems, from the air conditioning system (again), to fuel delivery, to automated braking systems. In fact, putting computers in automobiles has resulted in far more efficient systems than the old binary systems that were sometimes used.</li>
<li><strong>Your smartphone</strong>: Ever notice how your screen dims and brightens depending on how much ambient light there is? Modern smartphone operating systems look at ambient light, the color of the data being displayed, and the current battery life to optimize screen brightness.</li>
<li><strong>Washing machines</strong>: Not my washing machine necessarily, as it's quite old, but most modern washers (from the last 20 years) make some use of fuzzy logic. Load size, water dirtiness, temperature, and other factors are taken into account from cycle to cycle to optimize water use, energy consumption, and time.</li>
</ul>
<p>If you take a look around your house, there is a good chance you'll find a few interesting uses of fuzzy logic, and I mean besides your computer, of course. While these are neat uses of the concept, they're not particularly exciting or game-related. I'm partial to games involving wizards, magic, and monsters, so let's look at a more relevant example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a simple fuzzy logic system</h1>
                </header>
            
            <article>
                
<p>For this example, we're going to use my good friend, Bob, the wizard. Bob lives in an RPG world, and he has some very powerful healing magic at his disposal. Bob has to decide when to cast this magic on himself based on his remaining <strong>health points</strong> (<strong>HPs</strong>).</p>
<p>In a binary system, Bob's decision-making process might look like this:</p>
<pre>if(healthPoints &lt;= 50)  
{ 
  CastHealingSpell(me); 
}</pre>
<p>We see that Bob's health can be in one of two states—above 50, or not. Nothing wrong with that, but let's have a look at what the fuzzy version of this same scenario might look like, starting with determining Bob's health status:</p>
<div class="CDPAlignCenter CDPAlign"><img height="224" width="387" src="assets/36e6c128-2a3f-413d-8117-4fd0da005f8e.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A typical function representing fuzzy values</div>
<p>Before the panic sets in upon seeing charts and values that may not quite mean anything to you right away, let's dissect what we're looking at. Our first impulse might be to try to map the probability that Bob will cast a healing spell to how much health he is missing. That would, in simple terms, just be a linear function. Nothing really fuzzy about that—it's a linear relationship, and while it is a step above a binary decision in terms of complexity, it's still not truly fuzzy.</p>
<p>Enter the concept of a membership function. It's key to our system, as it allows us to determine how true a statement is. In this example, we're not simply looking at raw values to determine whether or not Bob should cast his spell; instead, we're breaking it up into logical chunks of information for Bob to use in order to determine what his course of action should be.</p>
<p>In this example, we're comparing three statements and evaluating not only how true each one is, but which is the most true:</p>
<ul>
<li>Bob is in a critical condition</li>
<li>Bob is hurt</li>
<li>Bob is healthy</li>
</ul>
<p>If you're into official terminology, we call this determining the degree of membership to a set. Once we have this information, our agent can determine what to do with it next.</p>
<p>At a glance, you'll notice it's possible for two statements to be true at a time. Bob can be in a critical condition and hurt. He can also be somewhat hurt and a little bit healthy. You're free to pick the thresholds for each, but, in this example, let's evaluate these statements as per the preceding graph. The vertical value represents the degree of truth of a statement as a normalized float (0 to 1):</p>
<ul>
<li>At 0 percent health, we can see that the critical statement evaluates to 1. It is absolutely true that Bob is critical when his health is gone.</li>
<li>At 40 percent health, Bob is hurt, and that is the truest statement.</li>
<li>At 100 percent health, the truest statement is that Bob is healthy.</li>
</ul>
<p>Anything outside of these absolutely true statements is squarely in fuzzy territory. For example, let's say Bob's health is at 65 percent. In that same chart, we can visualize it like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="268" width="406" src="assets/4b2444bf-13f2-4f1a-b513-bf959709fbef.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Bob's health at 65 percent</div>
<p>The vertical line drawn through the chart at <strong>65</strong> represents Bob's health. As we can see, it intersects both sets, which means that Bob is a little bit hurt, but he's also kind of healthy. At a glance, we can tell, however, that the vertical line intercepts the <strong>Hurt</strong> set at a higher point in the graph. We can take this to mean that Bob is more hurt than he is healthy. To be specific, Bob is 37.5 percent hurt, 12.5 percent healthy, and 0 percent critical. Let's take a look at this in code; open up our <kbd>FuzzySample</kbd> scene in Unity. The hierarchy will look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="306" width="239" src="assets/273f2b9b-6011-429b-a282-43ef9f409313.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The hierarchy setup in our sample scene</div>
<p>The important game object to look at is <kbd>Fuzzy Example</kbd>. This contains the logic that we'll be looking at. In addition to that, we have our <kbd>Canvas</kbd> containing all of the labels and the input field and button that make this example work. Lastly, there's the Unity-generated <kbd>EventSystem</kbd> and <kbd>Main Camera</kbd>, which we can disregard. There isn't anything special going on with the setup for the scene, but it's a good idea to become familiar with it, and you are encouraged to poke around and tweak it to your heart's content after we've looked at why everything is there and what it all does.</p>
<p>With the <kbd>Fuzzy Example</kbd> game object selected, the inspector will look similar to the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img height="262" width="317" src="assets/99f298ae-67ba-4700-8b35-c04b5a6d9a5a.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The Fuzzy Example game object inspector</div>
<p>Our sample implementation is not necessarily something you'll take and implement in your game <span>as it is</span>, but it is meant to illustrate the previous points in a clear manner. We use Unity's <kbd>AnimationCurve</kbd> for each different set. It's a quick and easy way to visualize the very same lines in our earlier graph.</p>
<p>Unfortunately, there is no straightforward way to plot all the lines in the same graph, so we use a separate <kbd>AnimationCurve</kbd> for each set. In the preceding screenshot, they are labeled <span class="packt_screen">Critical</span>, <span class="packt_screen">Hurt</span>, and <span class="packt_screen">Healthy</span>. The neat thing about these curves is that they come with a built-in method to evaluate them at a given point (<em>t</em>). For us, <em>t</em> does not represent time, but rather the amount of health Bob has.</p>
<p>As in the preceding graph, the Unity example looks at a HP range of 0 to 100. These curves also provide a simple user interface for editing the values. You can simply click on the curve in the inspector. That opens up the curve editing window. You can add points, move points, change tangents, and so on, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="325" width="542" src="assets/dbabf929-7f69-43f3-83de-64f47f94abcc.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Unity's curve editor window</div>
<p>Our example focuses on triangle-shaped sets. That is, linear graphs for each set. You are by no means restricted to this shape, though it is the most common. You could use a bell curve or a trapezoid, for that matter. To keep things simple, we'll stick to the triangle.</p>
<div class="packt_infobox">You can learn more about Unity's <kbd>AnimationCurve</kbd> editor at <a href="http://docs.unity3d.com/ScriptReference/AnimationCurve.html"><span class="URLPACKT">http://docs.unity3d.com/ScriptReference/AnimationCurve.html</span></a>.</div>
<p>The rest of the fields are just references to the different UI elements used in code that we'll be looking at later in this chapter. The names of these variables are fairly self-explanatory, however, so there isn't much guesswork to be done here.</p>
<p>Next, we can take a look at how the scene is set up. If you play the scene, the game view will look something similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="197" width="265" src="assets/3a87ffea-f5f4-4297-995a-0613906c6a3b.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A simple UI to demonstrate fuzzy values</div>
<p>We can see that we have three distinct groups, representing each question from the "Bob, the wizard" example. How healthy is Bob, how hurt is Bob, and how critical is Bob? For each set, upon evaluation, the value that starts off as <strong>0 true</strong> will dynamically adjust to represent the actual degree of membership.</p>
<p>There is an input box in which you can type a percentage of health to use for the test. No fancy controls are in place for this, so be sure to enter a value from 0 to 100. For the sake of consistency, let's enter a value of <kbd>65</kbd> into the box and then press the <span class="packt_screen">Evaluate!</span> button.</p>
<p>This will run some code, look at the curves, and yield the exact same results we saw in our graph earlier. While this shouldn't come as a surprise (the math is what it is, after all), there are fewer things more important in game programming than testing your assumptions, and sure enough, we've tested and verified our earlier statement.</p>
<p>After running the test by hitting the <span class="packt_screen">Evaluate!</span> button, the game scene will look similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="94" width="319" src="assets/86fd988c-3061-4cf3-9de0-9aec4b0238ca.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">This is how Bob is doing at 65 percent health</div>
<p>Again, the values turn out to be 0.125 (or 12.5 percent) healthy and 0.375 (or 37.5 percent) hurt. At this point, we're still not doing anything with this data, but let's take a look at the code that's handling everything:</p>
<pre>using UnityEngine; 
using UnityEngine.UI; 
using System.Collections; 
 
public class FuzzySample1 : MonoBehaviour { 
    private const string labelText = "{0} true"; 
    public AnimationCurve critical; 
    public AnimationCurve hurt; 
    public AnimationCurve healthy; 
 
    public InputField healthInput; 
 
    public Text healthyLabel; 
    public Text hurtLabel; 
    public Text criticalLabel; 
 
    private float criticalValue = 0f; 
    private float hurtValue = 0f; 
    private float healthyValue = 0f; </pre>
<p>We start off by declaring some variables. The <kbd>labelText</kbd> is simply a constant we use to plug into our label. We replace <kbd>{0}</kbd> with the real value.</p>
<p>Next, we declare the three <kbd>AnimationCurve</kbd> variables that we mentioned earlier. Making these public or otherwise accessible from the inspector is key to being able to edit them visually (though it is possible to construct curves by code), which is the whole point of using them.</p>
<p>The following four variables are just references to UI elements that we saw earlier in the screenshot of our inspector, and the last three variables are the actual float values that our curves will evaluate into:</p>
<pre>    private void Start () { 
        SetLabels(); 
    } 
 
    /* 
     * Evaluates all the curves and returns float values 
     */ 
    public void EvaluateStatements() { 
        if (string.IsNullOrEmpty(healthInput.text)) { 
            return; 
        } 
        float inputValue = float.Parse(healthInput.text); 
         
        healthyValue = healthy.Evaluate(inputValue); 
        hurtValue = hurt.Evaluate(inputValue); 
        criticalValue = critical.Evaluate(inputValue); 
 
        SetLabels(); 
    } </pre>
<p>The <kbd>Start()</kbd> method doesn't require much explanation. We simply update our labels here so that they initialize to something other than the default text. The <kbd>EvaluateStatements()</kbd> method is much more interesting. We first do some simple null checking for our input string. We don't want to try and parse an empty string, so we return out of the function if it is empty. As mentioned earlier, there is no check in place to validate that you've input a numerical value, so be sure not to accidentally input a non-numerical value or you'll get an error.</p>
<p>For each of the <kbd>AnimationCurve</kbd> variables, we call the <kbd>Evaluate(float t)</kbd> method, where we replace <kbd>t</kbd> with the parsed value we get from the input field. In the example we ran, that value would be <kbd>65</kbd>. Then, we update our labels once again to display the values we got. The code looks similar to this:</p>
<pre>    /* 
     * Updates the GUI with the evluated values based 
     * on the health percentage entered by the 
     * user. 
     */ 
    private void SetLabels() { 
        healthyLabel.text = string.Format(labelText, healthyValue); 
        hurtLabel.text = string.Format(labelText, hurtValue); 
        criticalLabel.text = string.Format(labelText, criticalValue);         
    } 
} </pre>
<p>We simply take each label and replace the text with a formatted version of our <kbd>labelText</kbd> constant that replaces the <kbd>{0}</kbd> with the real value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Expanding the sets</h1>
                </header>
            
            <article>
                
<p>We discussed this topic in detail earlier, and it's important to understand that the values that make up the sets in our example are unique to Bob and his pain threshold. Let's say we have a second wizard, Jim, who's a bit more reckless. For him, critical might be below 20 percent, rather than 40 percent as it is for Bob. This is what I like to call a "happy bonus" from using fuzzy logic. Each agent in the game can have different rules that define their sets, but the system doesn't care. You could predefine these rules or have some degree of randomness determine the limits, and every single agent would behave uniquely and respond to things in their own way.</p>
<p>In addition, there is no reason to limit our sets to just three. Why not four or five? To the fuzzy logic controller, all that matters is that you determine what truth you're trying to arrive at, and how you get there; it doesn't care how many different sets or possibilities exist in that system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defuzzifying the data</h1>
                </header>
            
            <article>
                
<p>Yes, that's a real (sort of) word. We've started with some crisp rules, which, in the context of fuzzy logic, means clear-cut, hard-defined data, which we then fuzzified (again, a sort of real word) by assigning membership functions to sets. The last step of the process is to defuzzify the data and make a decision. For this, we use simple Boolean operations, such as the following:</p>
<pre>IF health IS critical THEN cast healing spell </pre>
<p>Now, at this point, you may be saying, "Hold on a second. That looks an awful lot like a binary controller," and you'd be correct. So why go through all the trouble? Remember what we said earlier about ambiguous information? Without a fuzzy controller, how does our agent understand what it means to be critical, hurt, or healthy, for that matter? These are abstract concepts that mean very little on their own to a computer.</p>
<p>By using fuzzy logic, we're now able to use these vague terms, infer something from them, and do concrete things; in this case, cast a healing spell. Furthermore, we're able to allow each agent to determine what these vague terms mean to them on an individual level, allowing us not only to achieve unpredictability on an individual level, but even amongst several similar agents.</p>
<p>The process is described best in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="139" width="210" src="assets/14a3760b-32ab-4a26-915e-0f61eaf16387.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The fuzzy logic controller flow</div>
<p>At the end of the day, they are still computers, so we're bound to the most basic thing computers understand, 0s and 1s:</p>
<ul>
<li>We start with crisp data, that is, concrete, hard values that tell us something very specific.</li>
<li>The fuzzification step is where we get to decide the abstract or ambiguous data that our agent will need to make a decision.</li>
<li>During the inference step, our agent gets to decide what that data means. The agent gets to determine what is "true" based on a provided set of rules, meant to mimic the nuance of human decision-making.</li>
<li>The defuzzification step takes this human-friendly data and converts it into simple, computer-friendly information.</li>
<li>We end with crisp data, ready for our wizard agent to use.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the resulting crisp data</h1>
                </header>
            
            <article>
                
<p>The data output from a fuzzy controller can then be plugged into a behavior tree or a finite state machine. Of course, we can also combine multiple controllers' output to make decisions. In fact, we can take a whole bunch of them to achieve the most realistic or interesting result (as realistic as a magic-using wizard can be, anyway). The following figure illustrates a potential set of fuzzy logic controllers it can be used to determine whether or not to cast the heal spell:</p>
<div class="CDPAlignCenter CDPAlign"><img height="159" width="324" class="aligncenter size-full wp-image-416 image-border" src="assets/588bc666-d963-4120-8115-78fee8c5bd42.png"/></div>
<p>We've looked at the health question already, but what about the rest? We have another set of questions that really don't mean much to our agent on their own:</p>
<p>Do you have enough mana? Well, you can have a little bit of mana, some mana, or a lot of mana. It would not be uncommon for a human player to ask this question as they choose to cast a magic spell in a game or use an ability. "Enough" may literally be a binary amount, but more likely, it would be "enough to cast heal, and have some left for other spells." We start with a straightforward crisp value–the amount of mana the agent has available that we then stick to our fuzzy logic controller and get some crisp data at the other end.</p>
<p>What about the enemy's strength? He could be weak, average, strong, or unbeatable. You can get creative with the input for your fuzzy logic controllers. You could, for example, just take a raw "strength" value from your enemy, but you could also take the difference between your "defensive" stat and the enemy's "attack power," and plug that into your fuzzy logic controller. Remember, there is no restriction on how you process the data before it goes into the controller.</p>
<p>Are my allies close? As we saw in <a href="9e338555-162c-4ed0-a519-035cfcea94ce.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Finite State Machines and You</em>, a simple distance check can do wonders for a simple design, but, at times, you may need more than just that. You may need to take into account obstacles along the way—is that an ally behind a locked gate, making him unable to reach the agent? These types of questions could even be a nested set of statements that we need to evaluate.</p>
<p>Now, if we were to take that last question with the nested controllers, it might start to look a little familiar:</p>
<div class="CDPAlignCenter CDPAlign"><img height="207" width="320" class="aligncenter size-full wp-image-417 image-border" src="assets/caf246da-3954-4a5a-90fe-6ffffd5e77e2.png"/></div>
<p>The preceding figure is quite tree-like, isn't it? Sure enough, there is no reason why you couldn't build a behavior tree using fuzzy logic to evaluate each node. We end up with a very flexible, powerful, and nuanced AI system by combining these two concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a simpler approach</h1>
                </header>
            
            <article>
                
<p>If you choose to stick with a simple evaluation of the crisp output, in other words, not specifically a tree or an FSM, you can use more Boolean operators to decide what your agent is going to do. The pseudo code would look like this:</p>
<pre>IF health IS critical AND mana IS plenty THEN cast heal </pre>
<p>We can check for conditions that are not true:</p>
<pre>IF health IS critical AND allies ARE NOT close THEN cast heal </pre>
<p>We can also string multiple conditions together:</p>
<pre>IF health IS critical AND mana IS NOT depleted AND enemy IS very strong THEN cast heal </pre>
<p>By looking at these simplified statements, you will have noticed yet another "happy bonus" of using fuzzy logic—the crisp output abstracts much of the decision-making conditionals and combines them into simplified data.</p>
<p>Rather than having to parse through all the possibilities in your <kbd>if/else</kbd> statements and ending up with a bazillion of them or a gazillion switch statements, you can neatly bundle pockets of logic into fewer, more meaningful chunks of data.</p>
<p>In other words, you don't have to nest all the statements in a procedural way that is hard to read and difficult to reuse. As a design pattern, abstracting data via a fuzzy logic controller ends up being much more object-oriented and friendlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The morality meter example</h1>
                </header>
            
            <article>
                
<p>The faction/morality meter example for this chapter covers a slightly different approach to implementing fuzzy logic via Unity. We build upon the implementation we covered in the basic fuzzy logic example.</p>
<p>In this example, we create a simple dialogue sequence, where the player is presented a series of scenarios, or questions, that they can then answer according to their morality. For simplicity's sake, we've included a "good," "neutral," and "evil" answer for each question. Let's take a look at the code to understand this a bit better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The question and answer classes</h1>
                </header>
            
            <article>
                
<p>The <kbd>Question</kbd> and <kbd>Answer</kbd> classes are very simple, and are used as data containers.  Let's look at the <kbd>Question.cs</kbd> class first:</p>
<pre>[System.Serializable]<br/>public class Question { <br/>    public string questionText; <br/>    public Answer[] answers;<br/>}</pre>
<div class="packt_tip">You may have noticed that the <kbd>Question</kbd> class does not derive from <kbd>MonoBehaviour</kbd>. It is a plain ol' vanilla C# class. As such, Unity will not serialize it by default, and it won't show up in the inspector. To let Unity know you want this class to be serialized, use the <kbd>System.Serializable</kbd> attribute at the top of the class definition.</div>
<p>As you can see, it's only a few lines of code. The first field, <kbd>questionText</kbd>, will be edited via the inspector in a later step. It is the display text for the question/scenario we are presenting the user. The <kbd>answers</kbd> field is an array of <kbd>Answer</kbd> types. The <kbd>Answer.cs</kbd> code looks like this:</p>
<pre>[System.Serializable]<br/>public class Answer {<br/>    public string answerText; <br/>    public float moralityValue;<br/>}</pre>
<p>Again, you'll notice this class is very simple. <kbd>answerText</kbd> is the text to display in the response button for the player, and the <kbd>moralityValue</kbd> field is a hidden value we use to calculate the player's morality alignment later on. For this example, we assume that each question has three answers and that the morality values are 0, 50, and 100 for each one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the conversation</h1>
                </header>
            
            <article>
                
<p>Our <kbd>ConversationManager.cs</kbd> class is where all the heavy lifting happens for this sample. It manages the UI for our conversation, handles events, and calculates the results for us. For the first part, we initialize our question array and then handle the UI. We set up some variables at the top of the class, which looks like this:</p>
<pre>    [Header("UI")]<br/>    [SerializeField]<br/>    private GameObject questionPanel;<br/>    [SerializeField]<br/>    private GameObject resultPanel;<br/>    [SerializeField]<br/>    private Text resultText;<br/>    [SerializeField]<br/>    private Text questionText;<br/>    [SerializeField]<br/>    private Button firstAnswerButton;<br/>    [SerializeField]<br/>    private Button secondAnswerButton;<br/>    [SerializeField]<br/>    private Button thirdAnswerButton;</pre>
<p>We'll be able to see the UI elements these variables correspond to up ahead, but note that we explicitly expect a set number of answers, as we only provide three answer buttons for the UI. Of course, you can modify this to be more flexible or to fit your needs, but keep in mind that if you want to use more or fewer answers, you'll need to make those changes here as well:</p>
<pre>[Header("Morality Gradient")]<br/>[SerializeField]<br/>private AnimationCurve good;<br/>[SerializeField]<br/>private AnimationCurve neutral;<br/>[SerializeField]<br/>private AnimationCurve evil;</pre>
<p>Similar to our previous example, we use Unity's <kbd>AnimationCurve</kbd> to specify our fuzzy values. We assume a few things with this setup: </p>
<ul>
<li>At <em>t=0</em>, our "good" value is at 1, and goes down to 0 from there</li>
<li>At <em>t=50</em>, our "neutral" value is at 1</li>
<li>At <em>t=100</em>, our "evil" rating is at 1</li>
</ul>
<p>These values can be tweaked to your liking, but the current setup works well for the example. The following screenshot shows the curves set in the inspector:</p>
<div class="CDPAlignCenter CDPAlign"><img height="65" width="411" src="assets/cc9d157d-69f7-4fcd-9c74-66ce63711e98.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Fuzzy curves for our morality gradient</div>
<p>Notice that the values shown here correspond to our earlier assumption that our "good" answer gives a value of 0, our "neutral" answer has a value of 50, and our "evil" answer has a value of 100.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading up the questions</h1>
                </header>
            
            <article>
                
<p>We provide a simple method named <kbd>LoadQuestion</kbd> to pull the values from our data classes into the UI and display them to the player. The code looks like this:</p>
<pre>private void LoadQuestion(int index) <br/>{<br/>    if (index &lt; questions.Length) <br/>    {<br/>        questionText.text = questions[index].questionText;<br/>        firstAnswerButton.GetComponentInChildren&lt;Text&gt;().text = questions[index].answers[0].answerText;<br/>        secondAnswerButton.GetComponentInChildren&lt;Text&gt;().text = questions[index].answers[1].answerText;<br/>        thirdAnswerButton.GetComponentInChildren&lt;Text&gt;().text = questions[index].answers[2].answerText;<br/>    } <br/>    else <br/>    {<br/>        EndConversation();<br/>    }<br/>}</pre>
<p>The <kbd>LoadQuestion</kbd> method takes in a question index, which corresponds to the index of the question in the array <kbd>questions[]</kbd>. We first check that our index is in bounds, and end the conversation by calling <kbd>EndConversation()</kbd> if it isn't. If we are in bounds, we just populate the question text and the answer text for each answer button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling user input</h1>
                </header>
            
            <article>
                
<p>The event that gets called when the user presses an answer button on the UI is <kbd>OnAnswerSubmitted</kbd>. The method is quite simple and is only a few lines of code:</p>
<pre>public void OnAnswerSubmitted(int answerIndex) <br/>{<br/>    answerTotal += questions[questionIndex].answers[answerIndex].moralityValue;<br/>    questionIndex++;<br/>    LoadQuestion(questionIndex);<br/>}</pre>
<p>The method does a few things:</p>
<ul>
<li>It aggregates the answer value to the answer total. We'll look at how these values are assigned up ahead.</li>
<li>It increments the question index value.</li>
<li>Finally, it calls <kbd>LoadQuestion</kbd> with the incremented index value from the previous bullet.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calculating the results</h1>
                </header>
            
            <article>
                
<p>Finally, we have the <kbd>EndConversation</kbd> method, which, as we saw, gets called when we have answered all the questions (and the question index is out of bounds, based on our <kbd>questions[]</kbd> array length).</p>
<p>The first line simply disables the panel game object containing the question UI:</p>
<pre>questionPanel.SetActive(false);</pre>
<p>The calculations are in the next block of code:</p>
<pre> float average = answerTotal / questions.Length;<br/> float goodRating = good.Evaluate(average);<br/> float neutralRating = neutral.Evaluate(average);<br/> float evilRating = evil.Evaluate(average);</pre>
<p>We calculate the average of all of our answers by taking the <kbd>answerTotal</kbd> value (the sum of all the answers) and dividing it by the number of questions. We then individually evaluate each curve for good, neutral, and evil ratings using the average value we just calculated. We use the average as our <em>t</em> value in the evaluation method.</p>
<p>Next, we use some simple <kbd>if</kbd><em> </em>logic to determine which rating is higher, as seen in the following snippet:</p>
<pre>if(goodRating &gt; neutralRating) <br/>        {<br/>            if(goodRating &gt; evilRating) <br/>            {<br/>                //good wins<br/>                alignmentText = "GOOD";<br/>            }<br/>            else <br/>            {<br/>                //evil wins<br/>                alignmentText = "EVIL";<br/>            }<br/>        }<br/>        else <br/>        {<br/>            if(neutralRating &gt; evilRating) <br/>            {<br/>                //neutral wins<br/>                alignmentText = "NEUTRAL";<br/>            }<br/>            else <br/>            {<br/>                //evil win<br/>                alignmentText = "EVIL";<br/>            }<br/>        }</pre>
<p>As you can see in the previous code, we have a little bit of a branching conditional structure to determine the highest value, from which we set the <kbd>alignmentText</kbd> value accordingly. </p>
<div class="packt_tip"><kbd>if</kbd> blocks can get a bit complex if you start to add too many conditions. In this case, you may want to consider placing the ratings into an array or dictionary, then sorting them, and/or using LINQ to get the highest value from it. For more on sorting dictionaries, check out Dot Net Perls:<a href="https://www.dotnetperls.com/sort-dictionary"> https://www.dotnetperls.com/sort-dictionary</a></div>
<p>Lastly, we display the results to the user:</p>
<pre>resultPanel.SetActive(true);<br/>resultText.text = "Your morality alignment is: " + alignmentText;</pre>
<p>We simply enable the results panel, and then append <kbd>alignmentText</kbd> to the <kbd>"Your morality alignment is:"</kbd><span> message</span><span>, which would look like this in play mode (if you have a "good" rating):</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="190" width="251" src="assets/c6c093f2-75a5-4ace-a2cb-88f5f86d0af4.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The game screen when you earn a "good" rating</div>
<p>Next up, we can take a look at our scene setup, and how all of our values get initialized for the sample project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scene setup</h1>
                </header>
            
            <article>
                
<p>When you first open the <kbd>FactionScene</kbd> example scene, you'll notice a UI that looks like this screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="232" width="301" src="assets/a408ae35-dfa6-4a9c-955a-2f2132d845e9.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The sample scene UI setup</div>
<p>As you can see in the preceding screenshot, the UI comprises several different panels, and the text components have been initialized with some sample text to help organize everything nicely. The hierarchy for the scene is shown in this screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="247" width="395" class="aligncenter size-full wp-image-418 image-border" src="assets/ae2bba4a-1f71-4bf3-8260-f70818273260.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The FactionScene hierarchy</div>
<p>As you can see, our canvas has two main panels at the root level—the <span class="packt_screen">QuestionPanel</span> and a <span class="packt_screen">ResultPanel</span>, which is disabled by default. This is because, as you may remember, we set that panel to <kbd>enabled</kbd> via code in our <kbd>EndConversation</kbd> method. At the bottom of the list, we have our <span class="packt_screen">ConversationManager</span> game object, which contains our <kbd>ConversationManager</kbd> script.</p>
<p>If you select it, you'll see that the inspector looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="601" width="331" src="assets/47ab095e-b278-4db0-a55e-a51a37187a69.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The inspector for our Conversation Manager with all the values assigned</div>
<p>At first glance, the amount of information here may seem daunting, but let's take a look at each step, and you'll realize we've covered all of this already.</p>
<p>We first have our serialized array of questions. In this case, we have three questions (feel free to add more!). Each question then contains an array of (exactly) three answers, and the question text we saw earlier. For each answer, we have the answer text and morality value we saw earlier as well. Note that the order of the questions or answers doesn't necessarily matter, so long as your morality value corresponds to good, neutral, or evil.</p>
<p>We then have the UI section, in which we assign all the necessary elements. Everything in the hierarchy is named appropriately to make it easy to ensure that each field is populated with the correct game object. </p>
<p>Lastly, we have the morality curves that we saw previously. Again, feel free to tweak these to your heart's content!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the example</h1>
                </header>
            
            <article>
                
<p>All that's left is to test the example! Hit play, and select some answers. The scenario provided puts you in the shoes of an adventurer heading into town. On his way, he encounters a goblin, a banker, and a knight. What would you do in each scenario? Feel free to play around with the wording, and add your own moral dilemmas!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding other uses for fuzzy logic</h1>
                </header>
            
            <article>
                
<p>Fuzzy data is very peculiar and interesting in that it can be used in tandem with all of the major concepts we have introduced in this book. We saw how a series of fuzzy logic controllers can easily fit into a behavior tree structure, and it's not terribly difficult to imagine how it could be used with an FSM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging with other concepts</h1>
                </header>
            
            <article>
                
<p>Sensory systems also tend to make use of fuzzy logic. While seeing something can be a binary condition, in low-light or low-contrast environments, we can suddenly see how fuzzy the condition can become. You've probably experienced it at night: seeing an odd shape, dark in the distance, in the shadows, thinking "is that a cat?". It then turns out to be a trash bag, some other animal, or perhaps even your imagination. The same can be applied to sounds and smells.</p>
<p>When it comes to pathfinding, we run into the cost of traversing certain areas of a grid, which a fuzzy logic controller can easily help to fuzzify and make more interesting.</p>
<p>Should Bob cross the bridge and fight his way through the guards, or risk crossing the river and fighting the current? Well, if he's a good swimmer and a poor fighter, the choice is clear, right?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a truly unique experience</h1>
                </header>
            
            <article>
                
<p>Our agents can use fuzzy logic to mimic personalities. Some agents may be more "brave" than others. Suddenly, their personal characteristics—how fast they are, how far they can run, their size, and so on—can be leveraged to arrive at the decisions that are unique to that agent.</p>
<p>Personalities can be applied to enemies, allies and friends, NPCs, or even to the rules of the game. The game can take in crisp data from the player's progress, style of play, or level of progression, and dynamically adjust the difficulty to provide a more unique and personalized challenge.</p>
<p>Fuzzy logic can even be used to dole out the technical game rules, such as the number of players in a given multiplayer lobby, the type of data to display to the player, and even how players are matched against other players. Taking the player's statistics and plugging those into a matchmaking system can help keep the player engaged by pitting them against the players that either match their style of play in a cooperative environment or players of a similar skill level in a competitive environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>I'm glad to see that you've made it to the end of the chapter. Fuzzy logic tends to become far less fuzzy once you understand the basic concepts. Being one of the more <span>pure </span><span>math concepts in the book, it can be a little daunting if you're not familiar with the lingo, but when presented in a familiar context, the mystery fades away, and you're left with a very powerful tool to use in your game.</span></p>
<p>We learned how fuzzy logic is used in the real world, and how it can help illustrate vague concepts in a way that binary systems cannot. We also learned how to implement our own fuzzy logic controllers using the concepts of member functions, degrees of membership, and fuzzy sets. In addition to this, we also played around with a faction/morality system to further illustrate the concept of fuzzy logic in the context of a choose-your-own-adventure-style interaction. Lastly, we explored the various ways in which we can use the resulting data, and how it can help make our agents more unique.</p>
<p>In the final chapter, we will look at several of the concepts introduced in this book working together.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>