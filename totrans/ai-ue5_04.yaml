- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up a Navigation Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m pretty confident that, by now, you are aware that a pivotal element in AI
    game development is establishing a fully functional nav mesh. This entity acts
    as the cornerstone for directing AI-controlled agents through the game world with
    accuracy and effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will begin to put this understanding into practice by initiating
    a new project. By the conclusion of the chapter, you will have hands-on experience
    in developing and refining a navigation system within your own project.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge will serve as a crucial milestone in shaping your path as an
    AI programmer, propelling you toward the creation of groundbreaking games that
    will revolutionize the gaming industry!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unreal Agility Arena
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an AI agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a basic level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding navigation modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with navigation link proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this chapter, you should have set up Visual Studio (or
    JetBrains Rider) with all Unreal dependencies, as explained in [*Chapter 1*](B31016_01.xhtml#_idTextAnchor015)
    , *Getting Started with AI* *Game Development* .
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be using some starter content that’s available in this book’s companion
    repository at [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    . Through this link, locate the section for this chapter and download the following
    **.zip** file: **Unreal Agility Arena –** **Starter Content** .'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you somehow get lost while going through this chapter, in the repository,
    you will also find the up-to-date project files here: **Unreal Agility Arena –**
    **Chapter 04** **End** . Also, to fully understand this chapter, it is necessary
    to have some basic knowledge about Blueprint visual scripting while I guide you
    through the key characteristics of setting up an AI agent.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unreal Agility Arena
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick off a successful project, it’s essential to have a solid foundation.
    Imagine diving into a short novel starting like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In a secret underground lab hidden beneath a nondescript building, an eccentric
    scientist named Dr. Markus toiled away on his latest invention: AI dummy puppets.
    These puppets were no ordinary puppets; they were equipped with advanced AI technology
    that made them capable of interacting with the environment in the most* *unexpected
    ways.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dr. Markus was known for his quirky personality and wild ideas. He believed
    that these puppets held the key to understanding human behavior and improving
    social interactions. With his trusty sidekick, Professor Viktoria, by his side,
    he embarked on a series of* *hilarious experiments.*'
  prefs: []
  type: TYPE_NORMAL
- en: Well, it looks like you’ve stumbled upon the perfect starting point for creating
    the next big hit in the video game industry, and your task is to craft mind-blowingly
    awesome AI agents that will rock the world of gaming by seamlessly interacting
    with their virtual surroundings!
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the project brief
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project you’ll be working on will be a set of **gym** levels, where you
    will be creating different behaviors for your AI agents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In game development, a gym typically refers to a training environment where
    developers can test and train their AI algorithms and models. This term is also
    commonly used in the context of reinforcement learning, where AI agents learn
    to play games through trial and error in simulated environments. For the purpose
    of this book, we will stick to the first definition.
  prefs: []
  type: TYPE_NORMAL
- en: In my personal opinion, working on a gym is one of the most entertaining parts
    of the prototyping phase of a game because you don’t need to worry a lot about
    things working perfectly; you can experiment with all sort of things, and – in
    the end – you will most probably come up with creative and unconventional solutions!
  prefs: []
  type: TYPE_NORMAL
- en: So, to start with, I have provided a project template – called Unreal Agility
    Arena – that you will be using during the rest of this book. After downloading
    and opening it in Unreal Engine, our main focus will be on creating self-contained
    levels to experiment with the knowledge acquired thus far. This will involve addressing
    small tasks and resolving them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Once you reach [*Chapter 7*](B31016_07.xhtml#_idTextAnchor132) , *Introducing
    Behavior Trees* , you will be ready for something more challenging, and things
    will get a bit tougher, but also – I promise you – much more engaging and interesting!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As this book is about AI game programming rather than game design, balancing
    game mechanics will not be a primary focus of gameplay. Instead, the focus will
    be on making things work effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The very first step involves cracking open the project and diving into the delicious
    assets I’ve served up for you. So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Starting the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the project will mainly focus on gym levels, we aim for a visually appealing,
    or – as we game developers like to say – *juicy* look and feel. I understand that
    many of you may not have a background in 3D modeling (and neither do I!). That’s
    why we will be using some fantastic assets by Kay Lousberg ( [https://kaylousberg.com/](https://kaylousberg.com/)
    ) that are available for personal and commercial purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Kay Lousberg’s website](img/B31016_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Kay Lousberg’s website
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this project, I have mainly used the **Prototypes Bits Extra** package that
    is freely distributable once you have bought a license. If you are thinking about
    using the models for a commercial project, please consider buying a license from
    Kay’s website as well.
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the file from the link provided at the start of this chapter,
    unzip it and open the project by double-clicking the **UnrealAgilityArena.uproject**
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is open, please check what’s inside the **Content** folder.
    You will see these subfolders:'
  prefs: []
  type: TYPE_NORMAL
- en: A **_GENERATED** folder that has some additional models I have created with
    the Unreal Engine **modeling tools**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **KayKit** folder that includes all models from Kay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Maps** folder that includes some pre-made levels that are ready for use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Materials** folder that contains some materials needed by the project assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Textures** folder that contains some textures used by the project materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Vfx** folder that contains some Niagara effects that we will be using later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all these resources at our disposal, we are prepared to begin creating
    elements for the project, starting with an agent that will navigate through our
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AI agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the first step in testing the pathfinding system, we are going to create
    an agent whose sole aim is to reach a target actor inside the level; it won’t
    be anything fancy, just an actor that will be able to reach a target point in
    the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new folder inside **Content Drawer** and calling
    it **Blueprints** . Double-click on the newly created folder to open it and perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on **Content Drawer** and, from the menu that opens, select **Blueprint
    Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Pick Parent Class** window that will open, select **Character**
    , as depicted in *Figure 4* *.2* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Character creation](img/B31016_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Character creation
  prefs: []
  type: TYPE_NORMAL
- en: Name the newly created asset **BP_NavMeshAgent** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you probably already know, the **Character** class refers to a specific type
    of pawn that is designed to represent players or AI agents in a vertically oriented
    manner, allowing them to walk, jump, fly, and swim through the game world.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by giving it a visual representation and setting up the main values.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the **Blueprint** class opened and the **Viewport** tab selected, locate
    the **Details** panel and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Skeletal Mesh Asset** property dropdown and select the **Dummy**
    asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Anim Class** property dropdown and select the **ABP_Dummy** asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Character Movement (Rotation Settings)** category, locate the **Max
    Walk Speed** property and set the value to **500.0 cm/s** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Character Movement (Rotation Settings)** category, locate the **Rotation
    Rate** property and set the **Z** value to **640.0°** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same category, check the **Orient Rotation to** **Movement** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Shape** category, set the **Capsule Half Height** property to **120.0**
    and the **Capsule Radius** property to **50.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Pawn** category, uncheck the **Use Controller Rotation** **Yaw** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The previous steps are quite straightforward, and they will just set up the
    character mesh, assign an animation Blueprint – that has already been created
    for you – and, finally, set the capsule component size and the movement rotation
    settings. The final result for the agent is shown in *Figure 4* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The agent Blueprint](img/B31016_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The agent Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: The agent is almost ready, we just need to add some simple code logic in order
    to make it reach a target in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the navigation logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the **Event Graph** tab and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Get AIController** node in the graph and connect its incoming **Controlled
    Actor** pin to a **Reference to** **Self** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the outgoing **Return Value** pin of the **Get AIController**
    node and add a **Move to Actor** node to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Event BeginPlay** node to the incoming
    execution pin of the **Move to** **Actor** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the incoming **Goal** pin of the **Move to Actor** , click and drag and,
    once released, select the **Promote to variable** option; name the newly created
    variable **TargetActor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **My Blueprint** tab, select the **TargetActor** variable and, in its
    **Detail** panel, check the **Instance** **Editable** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is pretty simple; at the start of the game, the agent will try to navigate
    to a target actor; setting a variable to **Instance Editable** will make it visible
    in the level, in order to pick up the agent destination. The visual scripting
    code you have just created is shown in *Figure 4* *.4* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Blueprint graph](img/B31016_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The Blueprint graph
  prefs: []
  type: TYPE_NORMAL
- en: Our maybe not-so-clever agent is now fully equipped to navigate toward its designated
    target position. In the upcoming section, we will create a suitable environment
    for the agent to freely move around and explore.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to create our first level and start testing the pathfinding
    system for the agent. The project template has some prefabs I created for you,
    particularly a set of **Packed Level Actors** for quickly prototyping your maps
    and a **Level Instance** for setting up the lighting system. You are more than
    welcome to create your own game levels, but during this phase, my advice is to
    follow along with what I will be doing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, a Level Instance allows you to create reusable instances of
    a level or a portion of a level; this way, you can efficiently duplicate and reuse
    parts of your level design without having to recreate them from scratch. A Packed
    Level Actor is a type of Level Instance that is optimized for rendering and can
    only contain static meshes. Level Instances and Packed Level Actors are particularly
    useful when you have complex or repetitive elements in your level that you want
    to reuse multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create our first gym, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select **File** | **New Level** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/LevelInstances** folder and drag an instance of **LI_Lighting**
    inside your level; set its transform **Location** to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/PackedLevelActors** folder and drag an instance of **PLA_Lab_01**
    inside your level; set its transform **Location** to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **KayKit/PrototypeBits/Models** folder, drag some obstacles into the
    level just to make things a bit more engaging for your agent; my level is shown
    in *Figure 4* *.5* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The base level](img/B31016_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The base level
  prefs: []
  type: TYPE_NORMAL
- en: Save the level in the **Maps** folder and name it **Gym_NavMesh_01** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the nav mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are now ready to add the nav mesh on the level:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Quickly add to the project** button in the toolbar, select **Nav
    Mesh Bounds Volume** and drag an instance in the level; a **Recast Nav Mesh**
    actor will be automatically added along with the volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Location** for the volume to **(0, 0, 0)** and **Scale** to **(20,** **20,
    1)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click inside the level and hit the *P* key on your keyboard to show the generated
    nav mesh, as depicted in *Figure 4* *.6* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The nav mesh](img/B31016_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The nav mesh
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the obstacles you have added will carve the nav mesh and make
    things more interesting for the soon-to-be-added agent.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a last step, we need to add the agent and a target point to be reached.
    So, let’s start by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Vfx** folder, drag an instance of the **NS_Target** Niagara system
    and place it anywhere on the nav mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Blueprints** folder, drag an instance of the **BP_NavMeshAgent**
    Blueprint and place it on the blue-colored tile of the level; the **Location**
    value should be approximately **(-1650,** **30, 180)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the agent selected, locate the **Target Actor** property in the **Details**
    panel and, from the dropdown menu, set its value to **NS_Target** , which is the
    previously added Niagara system. The final level should be similar to *Figure
    4* *.7* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The final level](img/B31016_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The final level
  prefs: []
  type: TYPE_NORMAL
- en: Now that the level is complete, we can start testing it out.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the gym is finished, you can start testing your agent to see how it
    behaves in the level.
  prefs: []
  type: TYPE_NORMAL
- en: You can simply hit the **Play** button in the toolbar, or you can use the **Simulate**
    button that will not enter play mode but will show a simulation of how the level
    works. In this context, I personally prefer this second option as it will keep
    the nav mesh visible.
  prefs: []
  type: TYPE_NORMAL
- en: Once the simulation starts, you will see the agent reaching the target actor
    by taking the shortest route possible. You are free to experiment with obstacles
    to check how the agent behaves in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have begun to experiment hands-on with how the pathfinding
    system operates. You achieved this by creating an agent and a simple gym environment
    for your agent to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be adding modifiers to the nav mesh to give your
    agent a bit more of a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Adding navigation modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create another gym that will let us test nav
    mesh modifiers – actors that can be used to define areas where the cost to enter
    an area is different than the regular nav mesh.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating the level and then by adding the modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create our second gym, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select **File** | **New Level** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/LevelInstances** folder and drag an instance of **LI_Lighting**
    inside your level; set its transform **Location** to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/PackedLevelActors** folder and drag an instance of **PLA_Lab_04**
    inside your level; set its transform **Location** to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the level in the **Maps** folder and name it **Gym_NavMesh_02** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, repeat the same steps you have done for the previous gym by doing the
    following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the **Nav Mesh Bounds Volume** actor and set its boundaries so they cover
    the full walkable area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **NS_Target** Niagara System on the opposite side of the level in relation
    to the blue tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the **BP_NavMeshAgent** Blueprint on the blue tile and set the **Target
    Actor** property value to **NS_Target** . The level should now look like *Figure
    4* *.8* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The updated nav mesh](img/B31016_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The updated nav mesh
  prefs: []
  type: TYPE_NORMAL
- en: So far, everything is quite similar to the previous gym; we are now going to
    insert a modifier and see how it behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating a modifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to change the way the pathfinding system behaves by adding
    a modifier. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Quickly add to the project** button in the toolbar, select **Nav
    Modifier Volume** and drag an instance in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Location** for the volume to **(0, 0, 0)** and **Scale** to **(5,** **20,
    1)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that the nav mesh has now been modified and that it has been
    carved where the brown – let’s say muddy – tiles are placed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The level with the modifier added to it](img/B31016_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – The level with the modifier added to it
  prefs: []
  type: TYPE_NORMAL
- en: If you test the level now, you will see the agent moving toward the target point
    but stopping next to the muddy terrain; this is happening because the modifier
    volume has changed the nav mesh and now there’s no way for the agent to reach
    its target.
  prefs: []
  type: TYPE_NORMAL
- en: By selecting the **Nav Modifier Volume** actor and checking the **Area Class**
    attribute in the **Details** panel, you will notice that it has been set to a
    value equal to **NavArea_Null** . This value applies an infinite cost to the area
    it is applied to, making it impossible for the agent to traverse it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The Area Class attribute](img/B31016_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The Area Class attribute
  prefs: []
  type: TYPE_NORMAL
- en: If you try setting this value to **NavArea_Default** , you will notice that
    the nav mesh will behave as it would without any modifier in it, and that’s exactly
    what it does for this value; the cost for traversing this section is the same
    as that for the regular mesh. By testing the gym now, you will notice that the
    agent will walk through the muddy terrain and get to the target point.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to check the cost for traversing each polygon in your nav mesh,
    you can do it by selecting the **Recast Nav Mesh** actor and – from the **Details**
    panel – checking the **Draw Polygon Cost** attribute. *Figure 4* *.11* shows the
    cost visualization in the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – The nav mesh traversal costs](img/B31016_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – The nav mesh traversal costs
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make the level a bit more interesting and add some custom-made modifier
    volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now create a safe path for our agent so it doesn’t get its feet dirty
    in the muddy area. We will create a passage through it by using some additional
    models. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **KayKit/PrototypeBits/Models** folder, locate the **Pallet_Large_Pallet_Large**
    model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag three instances of this model in the level in order to create a passage
    through the muddy area, as depicted in *Figure 4* *.12* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The bridge](img/B31016_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The bridge
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to add another modifier for the bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the size of the previously added **Nav Modifier Volume** actor in the
    level so that it covers the muddy passage on the left of the river.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another **Nav Modifier Volume** actor to the level so that it covers the
    muddy passage on the right of the river.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a third **Nav Modifier Volume** actor to the level and place it so it creates
    an area covering the whole bridge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unreal Engine, a **Nav Modifier Volume** is an actor that is used to change
    the way the nav mesh is generated and that can be added to the level to specify
    certain areas of the nav mesh itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have a totally impassable zone, created by three modifiers,
    as shown in *Figure 4* *.13* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – The bridge with the modifiers](img/B31016_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – The bridge with the modifiers
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added a safe passage, we are going to create custom modifiers
    in order to experiment with different settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A modifier is a Blueprint extending the **NavArea** class; this means that you
    can create your own modifiers by subclassing this type and setting your own parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to create one for the muddy surface and one for the bridge.
    Let’s start with the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Content Drawer** and, in the **Blueprints** folder, right-click and choose
    **Blueprint Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **ALL CLASSES** dropdown list, select the **NavArea** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset **NavArea_Mud** and double-click on it to open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change its values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **Default Cost** to **10.0** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change **Fixed Area Entering Cost** to **2.0** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change **Draw Color** to a recognizable color of your choice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.14 – The cost settings for the muddy nav area](img/B31016_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – The cost settings for the muddy nav area
  prefs: []
  type: TYPE_NORMAL
- en: While the **Draw Color** value is almost self-explanatory – it will be used
    to color the nav mesh area covered by the volume – **Default Cost** is a multiplier
    applied to the overall cost for traversing the area. This means that the pathfinding
    system will compute the traversal cost multiplied by the value of **Default Cost**
    . **Fixed Area Entering Cost** , on the other hand, is a cost that is applied
    only once – when the agent enters the area covered by the volume. In this case,
    we have opted for a fixed cost for entering the muddy area and a high cost for
    traversing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s do the same steps for the bridge area:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Content Drawer** and, in the **Blueprints** folder, right-click and choose
    **Blueprint Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **ALL CLASSES** dropdown list, select the **NavArea** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset **NavArea_Bridge** and double-click on it to open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change its values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **Default Cost** to **5.0** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change **Fixed Area Entering Cost** to **0.0** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change **Draw Color** to a recognizable color of your choice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.15 – The cost settings for the bridge nav area](img/B31016_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – The cost settings for the bridge nav area
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we want to create an easier path for the agent, so we have set
    the fixed cost to **0.0** and the traversal cost to a lower value.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to apply these classes to the modifiers in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the custom modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to get the newly created classes and apply them to the level
    modifiers. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the two mud **Nav Modifier Volumes** and, in the **Area Class** property
    dropdown of the **Details** panel, select **NavArea_Mud** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the bridge **Nav Modifier Volume** and, in the **Area Class** property
    dropdown of the **Details** panel, select **NavArea_Bridge** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The nav mesh should be updated and should look like the one shown in *Figure
    4* *.16* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – The modified nav mesh area](img/B31016_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – The modified nav mesh area
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you created your bridge, you may have a less regular modifier
    area than mine; additionally, the nav mesh may be generated so that it is not
    fully walkable. To solve these issues, you will need to play a bit with the pallet
    model’s **Z** value and the size of your modifier.
  prefs: []
  type: TYPE_NORMAL
- en: We are finally ready to test this level.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test your gym, simply start the level simulation; you should see your agent
    going toward the bridge, crossing it, and reaching the target point. Although
    the muddy terrain is walkable, passing through it has a higher cost than traversing
    the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To double-check it, add some impassable obstacles on the bridge, just like
    I did in *Figure 4* *.17* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – The obstructed bridge](img/B31016_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – The obstructed bridge
  prefs: []
  type: TYPE_NORMAL
- en: If you start the simulation, you will see the agent going straight to the target
    point; although the muddy terrain has a high traversal cost, there is no other
    viable solution so the agent will opt for it.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this section, where you learned about how modifiers work. In
    the next section, I will show you another method to modify your nav meshes using
    link proxies.
  prefs: []
  type: TYPE_NORMAL
- en: Working with navigation link proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in [*Chapter 3*](B31016_03.xhtml#_idTextAnchor058) ,
    *Presenting the Unreal Engine Navigation System* , a **Nav Link Proxy** is an
    actor used to define specific areas where agents can navigate even if a portion
    of the level cannot be traversed. A **Nav Link Proxy** is placed in the game world
    to mark a start point and an endpoint, creating a navigation link. This link will
    provide a connection – which can be mono- or bi-directional – between two areas
    that may not be directly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: To check how this link works, we’ll be creating a new gym.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create this new gym, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select **File** | **New Level** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/LevelInstances** folder and drag an instance of **LI_Lighting**
    inside your level; set its transform **Location** to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Maps/PackedLevelActors** folder and drag an instance of **PLA_Lab_03**
    inside your level; set its transform **Location** to **(0,** **0, 0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the level in the **Maps** folder and name it **Gym_NavMesh_03** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This gym has a wide water channel in the middle of it, along with a bridge,
    as depicted in *Figure 4* *.18* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – The gym](img/B31016_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – The gym
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a few nav meshes – one for each walkable area – along with the
    agent and the target point:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two **Nav Mesh Bounds Volume** actors and set their boundaries so that they
    cover the walkable areas on each side of the river.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **NS_Target** Niagara System on the opposite side of the level from
    the blue tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the **BP_NavMeshAgent** Blueprint on the blue tile and set the **Target
    Actor** property value to **NS_Target** . The level should now look like *Figure
    4* *.19* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19 – The gym with the nav mesh](img/B31016_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – The gym with the nav mesh
  prefs: []
  type: TYPE_NORMAL
- en: If you test your gym right now, you will notice your agent walking toward the
    target point but stopping near the channel. Well, I guess that’s about as unexpected
    as a penguin wearing a tuxedo to a fancy party – there is no connection, so there
    can be no successful pathfinding!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now allow the agent to walk through the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Nav Link Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a link that will connect the two sides of the channel, do the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Quickly add to the project** button in the toolbar, select **Nav
    Link Proxy** and drag an instance in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that this actor has a couple of diamond-shaped gizmos called,
    respectively, **PointLinks[0].Left** and **PointLinks[0].Right** ; those are the
    connection points that will shape your link proxy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.20 – One of the two point links](img/B31016_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – One of the two point links
  prefs: []
  type: TYPE_NORMAL
- en: 'Select each of the point links and move them so that they are placed on each
    side of the bridge, as depicted in *Figure 4* *.21* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.21 – A nav mesh proxy](img/B31016_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – A nav mesh proxy
  prefs: []
  type: TYPE_NORMAL
- en: The **Point Links** attribute is a list of elements that can be used to create
    connections between unreachable locations. By default, there is just one, but
    you can add as many as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that also this gym is finished, you can test it to see how your agent behaves.
    Once the simulation starts, you will see the agent reach the target point by traversing
    the bridge as if a nav mesh existed on it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you try placing some obstacles on the bridge, you will notice your agent
    running straight on them and stopping; this happens because there is no actual
    nav mesh on the bridge, but a straight link. This means that Nav Link Proxies
    are a powerful tool, but they need to be used wisely.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have seen how to use Nav Link Proxies to connect unreachable
    sections of your nav mesh; with this new knowledge, you’re all set to make your
    AI friends do some epic cliff dives and pull off all sorts of wacky tricks!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you started working with the Navigation System; by starting
    from a simple navigable area, you added some obstacles and checked how the agent
    behaves. Next, you learned how to modify your walkable areas by adding non-traversable
    zones or difficult terrain. Lastly, you gained some understanding of how to link
    disconnected parts of the nav mesh.
  prefs: []
  type: TYPE_NORMAL
- en: All this knowledge is crucial because it helps your AI agents figure out where
    they can go without bumping into walls or getting stuck in a maze of confusion.
    You can think of the nav mesh as the GPS for your digital pals, ensuring they
    don’t end up lost in the virtual wilderness!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get deeper into the realm of the nav mesh; get
    ready to create some more advanced and fascinating stuff in Unreal Engine!
  prefs: []
  type: TYPE_NORMAL
