- en: Debugging Methods for AI - The Gameplay Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to face a powerful debugging tool. It is so powerful
    that it was worth having a separate chapter for it, and it is the best friend
    of any AI developer within Unreal. Actually, it's the best friend of any developer
    in Unreal, since it can have different uses, especially when it comes to covering
    *Gameplay* (although it has been mainly used for AI so far).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to explore the ***Gameplay Debugger*** (as it is referred to in
    the official documentation), but sometimes people or books use ***Visual Debugger***
    to refer to it. I presume that the reason it is called *Gameplay Debugger* is
    due to the fact that the tool has a **great level of abstraction to debug any
    gameplay aspects (including AI)**. However, the built-in categories of the *Gameplay
    Debugger* are AI-related, and this is the reason why it is included in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse the Visual Logger with the Visual Debugger, which is the ***Gameplay
    Debugger***!!
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the ***anatomy of the Gameplay Debugger***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the ***Extensions and Categories*** of the Gameplay Debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what kind of ***information each Category displays***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom module by ***creating a new plugin*** (we need this to extend
    the *Gameplay Debugger*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Extend the Gameplay Debugger*** by adding a new ***Category***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Extend the Gameplay Debugger*** by adding a new ***Extension***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the last technical part of this book before the last chapter, in which
    we will explore *Game AI* in broader terms. Thus, without further ado, let's dive
    in!
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of the Gameplay Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the game is running, you can open the ***Gameplay Debugger*** (or *Visual
    Debugger*) by pressing the " ' " (apostrophe) key.
  prefs: []
  type: TYPE_NORMAL
- en: All the key bindings of the visual debugger can be changed/customized. We will
    see how we can change them in the *Project Settings* section, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ***Gameplay Debugger*** is divided into two: ***Extensions*** and ***Categories***:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Extensions*** are specific key bindings (toggles) that trigger a specific
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Categories*** are *toggleable* pieces of information that appear on the
    screen (and also in 3D spaces) in regards to a specific system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On-screen, the ***Gameplay Debugger*** is visually divided into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eac0d6f8-2ba6-4375-a614-4748009c59fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The top section is the control section and shows which options are available.
    In particular, it displays which *Extensions* are available and highlights the
    active *Categories* that are displayed in the bottom part:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6273680f-db3c-4af6-b1d0-a19bdbb454fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The bottom section, instead, displays different information for each of the
    selected *Categories. *Here is an example with some Categories showing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaf51a68-f423-4c6a-820c-6f120fac26c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Gameplay Debugger Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Gameplay Debugger* has only two default ***Extensions*** and a built-in
    one, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae6b7938-cc4c-4fe4-b391-975943aa49ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The two default Extensions and a built-in one are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ***Spectator Extension*** allows you (at runtime, while the game is playing)
    to detach the control from the *Player Character* and control a *Spectator Pawn* so
    that you are free to fly over the level and have an external point of view. At
    any time, you can gain back control of the *Player Character* by toggling the *Spectator
    Extension* or by closing the *Gameplay Debugger*. The default key to toggle the
    *Spectator Extension* is the *Tab* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ***HUD Extensions*** allows you to toggle the *HUD* on and off (in particular,
    the *HUD* class contained in the *Game Mode* instance). The default key to toggle
    the *HUD Extension* is *Ctrl + Tilde*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***DebugMessages*** is the *built-in Extension*, and as its name suggests,
    it toggles the debug messages. The default key is *Ctrl* + *Tab*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gameplay Debugger categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Gameplay Debugger* is divided into different categories, which can be enabled
    and disabled (with the use of the *Keypad (or Numpad)*, not just the numbers of
    your keyboard).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a *Keypad/Numpad* (e.g. you are using a small laptop), later
    in this chapter, you will find the settings of the *Gameplay Debugger* in which
    you can change the key binding to something that your keyboard has.
  prefs: []
  type: TYPE_NORMAL
- en: The number next to the ***Category*** indicates its default position (and the
    number to press on the *Keypad* to activate it). However, this can be changed
    in the settings later.
  prefs: []
  type: TYPE_NORMAL
- en: To explore the *Categories*, I have created a simple test map, in which there
    should be a bit of everything so that we can see all the *Gameplay Debugger *categories in
    action. This test map is available in the project files associated with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Category 0 – Navmesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first category is ***Navmesh***, which is assigned to the "***0***" key
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Once you toggle it, you will be able to see the ***Navmesh*** directly on the
    map – simple as that. This is very useful when you need to check the *Nav Mesh*
    in real time, especially if you have dynamic obstacles so that the *Nav Mesh*
    is rebuilt at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it appears when this category is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/759cd92d-e20d-4238-bcb6-314cd2861dd9.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: Category 1 – AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This category, once enabled, shows a lot of information about the selected AI. By
    default, it is assign to the "***1***" key.
  prefs: []
  type: TYPE_NORMAL
- en: If no actor is selected, no information will be shown in this category. However,
    it will highlight the available AIs with their affiliation (in a 3D space).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the category is toggled (and a *Debug Actor* is selected), it looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2c2b600-3516-48e3-938f-567cbab90595.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: In this category, all of the AIs on the map are displayed with their affiliation
    (in a 3D space), and the selected *Debug Actor* also has the name of the controller
    (always in a 3D space). However, the information that's displayed directly on
    the screen is of the single *Debug Actor*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the kind of information that this category displays (with
    a close-up of *Categories Information*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6784d451-7bc6-4e6f-a208-53f93dbb998b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Controller Name**: This displays the name of the *AI Controller* that possesses
    this *Pawn*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn Name**: This displays the name of the *Pawn* that is currently possessed
    by the *AI*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movement Mode**: If there is a *Character Movement Component* attached to
    the Pawn, then this displays the current movement mode (e.g. walking, running,
    swimming, flying, falling, etc…)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base**: If there is a *Character Movement Component* attached to the Pawn,
    this displays on the base that the character is grounded on. In the case of walking
    or running, this is the mesh of the piece of floor where the AI is currently walking
    or running. In the case of falling, this is "*none*".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NavData**: This displays that *NavData* that the AI is currently using. Most
    likely, the value will be "*Default*", unless you gave a specific *NavData* to
    the AI character by using C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path following**: This displays the state of the Path to follow when the
    AI character is moving. Information such as the *Dot-Product*, the *2D-Distance*,
    and the *Z**-Distance* are displayed as well. Here is an example when the character
    is moving:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/88fd83f8-f69e-4d22-b63d-ce588b0fa5e2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Behavior**: This indicates whether there is a behavior running or not (e.g.
    is a *Behavior Tree* running on this *AI Controller*?).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree**: This indicates which *Behavior Tree* the AI is currently running
    (if a *Behavior* is running).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active Task**: This indicates which *Behavior Tree Task* is currently executing,
    along with the *Task number* (the number that that Task is ordered in the Tree).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information aregarding the current task in the *Behavior Tree Category*,
    see the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gameplay Tasks**: This displays how many *Gameplay Tasks* are currently assigned
    to this AI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Montage**: This displays the current montage that the Character is playing
    (if any).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we didn't touch on this topic in this book, syncing AI actions with
    Animations is an in-between land for AI programmers and Animators.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that if the AI is moving, even if the *Navmesh* category
    is not toggling, it will show the piece of the *Nav Mesh* that the AI is currently
    using to navigate, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99c4e67d-eb87-4eb6-98d5-63dbf3f82bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: Category 2 – Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This category displays information about the ***Behavior Tree*** that's currently
    running on the AI. By default, it is assigned to the "***2***" key.
  prefs: []
  type: TYPE_NORMAL
- en: If no *Behavior Tree* is running, this section will not display anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'When activated, the ***Behavior Tree Category*** looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c165e2c-858c-41a2-9391-d541ced483d7.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: 'This category only displays information on the screen (so nothing in the 3D
    space). In particular, it shows the following information on the left-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14c31c9a-95cf-42be-84e6-45afbc491993.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Brain Component**: This shows which kind of *Brain Component* the *AI Controller*
    is currently using, which will be of the *BTComponent* type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Unreal is developed with *modularity* in mind, a *Brain Component* is
    anything that can hold AI logic. At the time of writing, the only built-in *Brain
    Component* is the *Behavior Tree* (*BTComponent*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior Tree**: This is the name of the *Behavior Tree* that the AI is using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task Tree**: After the *Behavior Tree* property, there is the all branch
    of the task that is currently being executed. This is the path from the root (with
    all the node names and their respective numbers) to the *Task* the AI is executing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very useful when you need to understand why a determined tasks has been
    chosen, rather than another, by following the path along the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right, instead, the name of the *Blackboard* asset that''s being used
    by the *Behavior Tree *is displayed. Below this, there''s the keys of the *Blackboard* that''s
    being used, along with their current value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b302a24-3789-4cc8-9c7e-abddea763d45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows just two *Blackboard keys*, *Destination* and *Self
    Actor*. Try to test the *Gameplay Debugger* in the *Designing Behavior Tree Project* to
    see more and get a better feeling of what it is going on, since you have been
    building these structures from scratch. Here is a sneak peek of what you will
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95f453a5-856d-478e-b700-c087d7dc1ba5.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is very useful when you want to test that the right values in
    the *Blackboard* are set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one more example, showing the character moving:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e3c0028-6f79-4a16-b55e-c5d854738d36.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: Category 3 – EQS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This category displays the ***Environmental Queries*** that the AI is currently
    performing. By default, it is assigned to the "***3***" key.
  prefs: []
  type: TYPE_NORMAL
- en: If the AI is not performing any *Environment Query*, than this category will
    just show that the number of queries is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the ***EQS Category*** is activated, we get the following output on-screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f803fa22-0174-4306-82c2-49b63ee1bcda.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see that this *Category* highlights the
    different points that are generated by the query, along with their score. Depending
    on the *Run Mode* of the query, it is possible to see which of these points is
    the winner (it has the highest score and its color is a brighter green than the
    other colors).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, a red arrow on top of a point means that it has been selected (which
    means that it is the closest that you are looking at). This is useful because,
    in the information displayed on the side, it is possible to check at which place
    of the scoreboard that specific point has been ranked.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the side, you will find some extra information about the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e62bce3-9199-42b6-8a7b-84e5840f83f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In particular, the following information is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Queries***: This is the number of queries that the *Debug Actor* is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Query Name(s) and Run Mode***: This displays which *Query* has been (or
    currently is being) executed. Then, after an underscore, it displays the *Run
    Mode* (in the preceding screenshot, it is *Single Result*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Time Stamp***: This is the timestamp of when the *Query* was executed, along
    with how long ago this occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Options***: This displays which the *Generator* for the Query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Selected Item***: This displays the *position/rank* of the selected item
    in the scoreboard. In the preceding screenshot, the item we have selected is 11th
    on the scoreboard (from the full-screen screenshot, you can see that it has a
    score of *1.31*, against the winner point, which has a score of *2.00*). This
    is very useful for checking how the point you are looking at is ranked, since
    it gives you a quick idea of the relative score among the points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep in mind that when a point is ranked, ***the rank starts from zero***,
    and so the ***Winner Point is ranked 0th***. So, in the preceding screenshot,
    "*Selected Item: 11*" means that it is 11th on the scoreboard, but it is the 12th
    point in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For your convenience, here is another example, in which the Selected Point
    is the Winner Point (notice that its rank is 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b522b6a7-9697-4c93-b3dd-399d46e2db8c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: Category 4 – Perception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This category displays information regarding the *Perception* of the *AI agent*
    that has been selected. By default, it is assigned to the "***4***" key, that
    is, unless the "*NavGrid*" *Category* is enabled; in that case, the default key
    is "***5***".
  prefs: []
  type: TYPE_NORMAL
- en: This category doesn't show anything if no Actor has been selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'When activated, the ***Perception Category*** appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b5dc888-a378-4179-8091-90ebff80a652.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: 'On-screen, this category displays all the senses that have been implemented,
    along with their debug colors. Then, each sense can show additional information,
    depending on the implementation of their `DescribeSelfToGameplayDebugger()` function.
    For instance, in the case of Sight, there is the debug colors for **RangeIn**
    and **RangeOut**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4d34e3f-1add-42da-a61e-472c9db23f62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the level, you will be able to see the stimuli of a given sense as a sphere
    (along with the name of the sense, the stimulus strength, and the age of the stimulus,
    which is zero when on sight). Then, there is a line connecting the AI Pawn to
    each of the *stimuli*, and a line connecting the single *stimulus* to the target
    (e.g. the *Player*) if the target is not on sight. This is how it appears in the
    case of Sight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80a36625-4a65-4ada-b8ec-c611589d9167.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: 'To show off how it appears when the target (e.g. the *Player*) is not in sight,
    and thus the *stimulus* has an age greater than zero and it is possible to see
    the black line connecting the *stimulus* to the target, here is another screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfbf37ae-765e-4eea-ac49-d42aaaf832ae.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to add the sense of *Hearing* as well, this is what it would look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efe1d48d-7a23-488e-9639-8bf79fd89551.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the *Hearing Sense* (in yellow) is displayed on a different
    level (z-axis) of the *Sight Sense*. As a result, even if we have the same value,
    like in the preceding screenshot where both have a range of 1500, they stack up
    nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the information on the side gives you more information about the
    debug colors that are being displayed in the game world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a36caf58-f35a-4e1f-8a4d-5fbda4337fe1.png)'
  prefs: []
  type: TYPE_IMG
- en: The Nav Grid Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your settings, you might have enabled the ***Nav Grid*** Category,
    which is different from the *NavMesh* *Category*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This *Category* should deal with grid movement, which we haven''t covered in
    this book. However, if you activate this *Category* in our example map, it will
    just show that the number of sources is equal to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03d08b2d-a625-4230-85f7-d5d07d986498.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple Categories on-screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how each of the categories behave individually. However, just
    to be clear, it is possible to have as many categories as you like on display.
    This means that you can have multiple categories showing up at the same time.
    Actually, often, you will need to see more that one system at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c225cd5-5cd2-472e-846a-2431722e573b.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: One thing that I personally like about the *Gameplay Debugger* is that once
    you get the hang of it, even with so many *Categories* open, the information is
    not overwhelming the screen, and is nicely displayed.
  prefs: []
  type: TYPE_NORMAL
- en: More Categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it seems that we went through all the different *Categories*, we haven't.
    In fact, there are some extra *Gameplay Debugger Categories* built into the Engine,
    for instance, the ones related to *HTN Planner* or the *Ability System*.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, they are outside the scope of this book, but you can search for
    them in C++. You can start your research by searching for ***GameplayDebuggerCategory***
    in the *Engine Source* to find out more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay Debugger settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, it is possible to configure the *Gameplay Debugger*
    by changing its settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you navigate to the ***Project Settings***, it is possible to find a whole
    section dedicated to the *Gameplay Debugger*, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ad92e61-6ce9-4210-b806-483089824dfb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The ***Input*** tab allows you to override the default keys for opening and
    closing the *Gameplay Debugger* (the default is the " ''" apostrophe key) and
    for triggering the different categories (by default, the numbers from 0 to 9 on
    the *keypad/numpad*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9233b8de-3eaa-4e05-be1d-2d6f3044e823.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The ***Display*** tab allows you to define some padding on so that you can
    show information about the *Gameplay Debugger*. By doing this, you don''t have
    it attached to the screen. The default values are all *10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a23ddea7-5951-4410-ba59-a9f82225a3d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The ***Add-Ons tab***,allows you to configure the single settings for both
    ***Categories*** (when a category is enabled by default, and which key/number
    it is associated with) and ***Extension*** (to override their input key):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30aa8ce0-bd0e-41ef-8c2c-27fb89871255.png)'
  prefs: []
  type: TYPE_IMG
- en: A value of "-1" for a *Category* means that the *number/position/key* of the
    *Category* has been assigned by the Editor, since this *Category* doesn't have
    a "*preference*" of its position on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Gameplay Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how all the different categories of the ***Gameplay Debugger***
    can help us understand how our *AI Character* is behaving. However, wouldn't it
    be awesome if we could have our own category so that we can visualize the data
    of a custom (sub-)system we have developed for our game?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes, and this section explains how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the tool is called ***Gameplay Debugger***, so you can extend
    it not only for AI, but for anything in your game, especially related to *Gameplay*
    (since it is a real-time tool to visualize information). So far, it has been extensively
    used for AI, but it has the potential to be used for anything else!
  prefs: []
  type: TYPE_NORMAL
- en: As we already have seen, the ***Gameplay Debugger*** is divided into ***Categories***
    and ***Extensions***.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will explore how to create a ***Custom Category*** in more detail,
    starting from creating a separate module for it, along with all the dependencies
    and compiler directives that we need. We will see how we can create the class
    that controls the ***Category***, and how we can register it to the *Gameplay
    Debugger*. As a result, we will have a fully functioning ***Gameplay Debugger
    Category*** that will print the location of our *Debug Actor* on-screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce1c0b50-9055-4ae5-bd70-002540853491.png)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, we will look at how to create a ***Custom Extension*** for the ***Gameplay
    Debugger***, which will be able to print the Player's location when a specific
    key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: With this being said, let's get into creating a new *plugin*!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module with the use of a new plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To extend the *Gameplay Debugger* with a new ***Category***, you will need a
    new module in your game. In fact, the engine is a collection of different modules,
    and your game is as well (usually, the game is just one module, especially if
    the game is small; it is created with only one module when you start a fresh project
    in C++, so you will need to add more if need be).
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways in which we can create a module, and I'm not going
    to go into the details of how module works, and how to create one for your project.
    Rather, I will guide you on how to set up a custom module for running a new ***Gameplay
    Debugger Category***.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to create another module is to create a plugin. As a result,
    the code is separated from the rest of our game, which has good and bad implications.
    However, we aren't going to discuss this in this section. Instead, I will show
    you how to create a custom ***Gameplay Debugger Category*** that you will then
    adapt to your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by opening the ***Plugins*** menu, from the ***Settings*** menu
    button on top of the *Viewport*, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c5abd63-5d1b-4331-bfdd-377d2c35cd64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the ***Plugins*** windows is open, you will need to click on the New Plugin
    button in the bottom right-corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f12b9f5f-92d1-4f3b-9853-bf473a1a5982.png)'
  prefs: []
  type: TYPE_IMG
- en: It is not the only way to create a *Plugin*, but this is the fastest, since
    Unreal contains a simple Wizard to create different templates of *Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we will open the ***New Plugin*** windows, which is a wizard for
    creating new plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe4c4f83-bb82-49b4-821e-be8b8ebc99c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to select the Blank template (since we just want a bare-bones a module
    to load). Then, we can fill in the *Name*, which in our case is ***GameplayDebugger_Locator***.
    Next, there are input fields to fill for your plugin: *Author* and *Description*.
    I put myself as *Author*, and for the description, I inserted "*A custom Gameplay
    Debugger Category for visualizing the position of an Actor*". This is what the
    screen should look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89d7ba34-cb35-404f-8b1c-d901cabeac10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Press Create Plugin and our plugin will be created. It might take some time
    to process, so be patient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d16dad0-59c8-4ad8-91a2-158654eb4513.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it has compiled, you will have the basic structure and code of the *Plugin*
    as a single module. You can check it out in *Visual Studio*. Under the *Plugins*
    folder, you should have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fe85ef2-02b3-41cc-b163-a4c27600dd8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, if you go back to the *Plugin* window, you will be able to see our *Plugin*
    (and ensure that it is enabled):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51dcf318-369b-4c70-aeb7-e135ce1534eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, you are free to "*edit*" the *Plugin*, for instance, to change its
    icon or the category.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the module to work with the Gameplay Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we add the code for a new category of our *Gameplay Debugger*, there
    are some considerations to make.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the *Gameplay Debugger* is, as its name suggests, a Debug tool.
    This means that it shouldn't be shipped with the game. As such, we need a way
    to strip away all the code related to the *Gameplay Debugger* if we are compiling
    a shipping version of the game. Of course, the *Plugin* we are creating only includes
    code for the *Gameplay Debugger*, but in your game, it is more likely that it
    lives in a broader context.
  prefs: []
  type: TYPE_NORMAL
- en: To strip away the code, you need to defy a compilation variable that can be
    used with compilation macros; however, we only want to define this variable as
    true (value equal to one) if the game is not being shipped. To achieve this, we
    need to navigate to our Plugin ***.build.cs*** file. In our case, it is called ***GameplayDebugger_Locator.build.cs***,
    and you can find it within the hierarchy of files of our *Plugin* in *Visual Studio*
    (or the code editor of your choice). In fact, Unreal runs some tools before compiling
    (e.g. to generate reflection code and replace the macro in the C++ code), and
    these tools are written in C#. Therefore, we can modify their behavior with a
    piece of C# code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you open the file, you will find one function, which defines the different
    dependencies of the module. At the end of this function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is an if statement that checks whether ***BuildDeveloperTools*** is true
    OR the Target Configuration (the configuration we are going to compile the C++
    code with) is different from ***Shipping*** or ***Test***. If this condition is
    verified, then we add a ***Private Dependency*** for this module, that is, the
    ***GameplayDebugger*** module, and define the `WITH_GAMEPLAY_DEBUGGER` variable
    as true (for compiling C++ code). Otherwise, we just declare the `WITH_GAMEPLAY_DEBUGGER` variable
    false.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we are able to use the `WITH_GAMEPLAY_DEBUGGER` variable in our
    compiler directives to include of exclude (depending which kind of configuration
    we are building) specific code related to the ***Gameplay Debugger***. So, from
    now on, when we write code for our ***Gameplay Debugger*** category, let''s not
    forget to wrap it in the following compile directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new Gameplay Debugger Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to create a new class for our ***Gameplay Debugger Category***.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we can create a new C++ class, but this time, we will select ***None***
    as the Parent class (we will write the class on our own and manually make the
    inheritance):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd081aec-e7ce-4e66-a6e5-ec7836f47da8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can rename it ***GameplayDebuggerCategory_Locator*** (which follows
    the convention of starting the class name with *GameplayDebuggerCategory_*, followed
    by the *Category Name*). Now, be careful and select the right module; next to
    the module''s name, you can choose the module that the class belongs to. So far,
    we have always worked with one module, so we didn''t have this problem. You need
    to select the ***GameplayDebugger_Locator (Runtime)*** module, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37aedcf6-5206-409b-838b-66cb6b51c07a.png)'
  prefs: []
  type: TYPE_IMG
- en: Create the class, and wait until it is added to our *Plug**in*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to actively start creating our class. Go into the header (`.h`)
    file of our newly created class and remove everything. We will start by including
    the engine minimal core, and then within the `#if WITH_GAMEPLAY_DEBUGGER` compiler
    directive, we will also include the `GameplayDebuggerCategory.h` file, since it
    will be our Parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create the class itself. By following conventions, we can
    rename the class so it has the same name as the file, ***FGameplayDebuggerCategory_Locator***,
    and make it inherit from ***FGameplayDebuggerCategory***:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Gameplay Debugger* is a powerful tool, and as such it as many functionalities.
    One of those is its ability to support replication. As a result, we need to set
    up a structure that supports that. If you open the source files (from the Engine)
    of the other *Gameplay Debugger Categories*, you will see that they follow the
    convention of declaring a protected structure named ***FRepData***. Within this
    structure, we declare all the variables that we need in order to visualize the
    category. In our case, we just need a string, which we will call ***ActorLocationString***.
    It is also important that this structure has a way to be serialized, so we need
    to add the `void Serialize(FArchive& Ar)` function, or at least its declaration.
    Finally, we can create (always under "*protected*") a variable of the ***FRepData*** type
    named ***DataPack***, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to override some public functions to make our category to
    work. These functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Constructor***: This sets the initial parameter of the class, and will set
    the data replication for the *DataPack*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***MakeInstance()***: This creates an instance of this category (using a shared
    reference). This is required from the *Gameplay Debugger* when we register our
    category at a later date (meaning that we will add it to the editor).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***CollectData()***: This collects and stores the data that we would like to
    show, which we then store in the *DataPack* (which can be replicated). It is given
    in input (so that we can use it), the *Player Controller*, and the ***DebugActor***
    (if available), which is the Actor we have set the focus on in the *Gameplay Debugger*
    (remember that we selected a specific Character when we were analyzing its behavior;
    here, under the hood, it is passed as a parameter to the `CollectData()` function).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***DrawData()***: This displays the data on-screen; we will use the *DataPack*
    variable to retrieve the data that was collected in the `CollectData()` function.
    It is given in input (so that we can use it), the *Player Controller*, and the
    ***CanvasContext***, which is what we will use to actually display the data on-screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can declare them in our header (`.h`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes what we need in the header (`.h`) file. For your convenience,
    here is the whole code for the header (`.h`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to write the implementation. So, open the `.cpp` file and wipe
    everything off (if you haven't already) so that you can start clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we need to include some headers. Of course, we need to include
    the header file of our class itself (the header file we just edited). Then, under
    the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive, we need to include the *Actor*
    class, since we will need to retrieve the position of an *Actor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start implementing all of our functions. We will start from our
    ***Constructor*** of the main class. Here, we can set the default parameters of
    the *Gameplay Debugger Category*.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we can set **bShowOnlyWithDebugActor** to ***false***, which,
    as its name suggests, allows this category to be displayed, even if we haven't
    selected a *Debug Actor*. In fact, even if our *Category* will need the *DebugActor*
    to show its location, we can still print other information (in our case, we will
    do a simple print). Of course, when you create your category, you can decide whether
    this bool will be true or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is more important to set our ***DataPack*** variable for replication
    through the `SetDataPackReplication<FRepData>(&DataPack)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement our `Serialize()` function for our ***RepData***
    structure. Since we just have a String, its implementation is quite straightforward;
    we just need to insert the *String* in the *Archive*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To register this *Category* to the *Gameplay Debugger*, we have to implement
    the `MakeInstance()` function, which will return a shared reference to an instance
    of this *Category*. Hence, here, the code is quite straightforward as well; just
    create a new instance of this class as a shared reference and return the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have two more functions to implement. The former collects the data, while
    the latter displays it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CollectData()` function already has the *DebugActor* passed as a parameter.
    Thus, after we have verified that the reference is valid, we can retrieve the
    *DebugActor''s* position and assign it within the ***ActorLocationString*** variable
    inside the *FRepData* structure that''s contained in the ***DataPack*** variable.
    It''s easier to show this than explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, within the `CollectData()` function, you can run any logic to retrieve
    your own data. Just remember to store it within the ***DataPack*** variable, which
    is the pointer to the ***FRepData*** structure, which can be as complex as you
    like (and remember to serialize that as well).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `DrawData()` function is responsible for actually displaying the
    information we have collected. In particular, we have a reference to the ***Canvas
    Context***, which we will use to "*print*" the information. We even have some
    formatting options, such as coloring the text by prefixing it with "*{color}*".
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will print some text, and then print the location of the *DebugActor*
    (if available). We will use colors too, so let''s learn about how to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This was the last function for our implementation (`.cpp`) file. For your convenience,
    here is the whole file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have our *Gameplay Debugger Category*, but we need to "***register***"
    it to make it appear in the *Gameplay Debugger*. So, without further ado, let's
    jump into the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the Gameplay Debugger Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a *Gameplay Debugger Category*, but now
    we need to "***register***" it to the *Gameplay Debugger*.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this is by registering the category inside the `StartupModule()`
    function of our module, so let's open the `GameplayDebugger_Locator.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is include the *Gameplay Debugger Module*, along
    with the *Gameplay Debugger Category* we have created. We need to surround the
    `#include` statements with the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive,
    as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `StartupModule()` function, we need to check whether the *Gameplay
    Debugger Module* is available, and if so, retrieve a reference to it. Then, we
    can use this reference to register our category with the `RegisterCategory()`
    function, which takes three parameters (the name of the *Category*, a reference
    to the function to create an instance of the category, and some options as enum).
    Finally, we need to notify the changes. Of course, once again, this code is wrapped
    up by the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good, but when we register something in a module, we also need to
    "***unregister***" when the module shuts down. Thus, in the `ShutdownModule()`
    function, we need to follow the same steps as before, but this time *unregister*
    the category. First, we need to check the validity of the *Gameplay Debugger Module*,
    and then we retrieve it, *unregister* the category, and notify the changes. Once
    again, the code is wrapped up by the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For your convenience, here is the full code of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Compile, and our code is ready to go. Also, ensure that the *Plugin* is activated,
    and then close and reopen the editor (sothat we are sure that our module has been
    loaded properly).
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how what we have created works in Unreal.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the custom Gameplay Debugger Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have restarted the editor, our *Plugin* will be loaded as well, which
    means that our ***Gameplay Debugger Category*** has been loaded as well. To check
    this, we can navigate to the *Project Settings*, under the *Gameplay Debugger
    Section*. Here, we have all the options to configure the *Gameplay Debugger*,
    including the categories that have been loaded. Thus, if we scroll down, we should
    be able to find our ***Locator Category***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4440423-5ce9-43cb-aeb3-ce5bd4005b19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, all the options are set to "***Use Default***", which we set
    when we passed the third parameter for registering the category. However, you
    can also override them here (for instance, by ensuring that it is always enabled).
    Optionally, you can change the key that this category is triggered on, or just
    leave the default settings as is if you don''t have any preference. The *Editor*
    will assign one for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f04e8f4-1bc4-42ee-99c2-37ecd57ac1ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are having trouble making the plugin load with the Gameplay Debugger
    available, you should navigate from the top menu of Unreal to ***Window | Developer
    Tools | Modules***. From here, search for our Locator Module, and then press on
    Reload, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f89065e7-18f5-4883-bc99-5220d10f9b86.png)'
  prefs: []
  type: TYPE_IMG
- en: You may need to do this every time you load the editor in order to use your
    Categories and/or Extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we press play and activate the *Gameplay Debugger*, we will see our
    category listed (it may be active or not by default, depending on the settings
    you set previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06bb15b5-bc3b-4080-a203-bdd4e42e18e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we select another Actor, we will be able to see that the ***Locator Category***
    will display its position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12f908b1-44e9-4c9e-909f-1ebbc4d4eda7.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a close-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/726e566f-1b8c-4476-bd90-b08be70dd47d.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes our discussion on creating a ***Custom Gameplay Debugger Category***.
    Of course, it was a very simple example, but you can easily imagine the potential
    of such a tool and how this can be used in your project workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this chapter, as we mentioned previously, let's have a look
    at how we could extend the *Gameplay Debugger* by adding an *Extension*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Extension for the Gameplay Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, the *Gameplay Debugger* is composed of *Categories* (we
    have already seen how to create a custom one) and ***Extensions***. Once again,
    creating an ***Extension*** is only available in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Like the *Gameplay Debugger Category*, an *Extension* needs to live on a *Custom
    Module*, but it can be the same one as the *Category* (or *Categories*). Thus,
    I'm going to use the same plugin we just developed.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we are going to create a simple extension that, when we press
    a specific key, prints the position of the Player in the output log.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create a new C++ class and inherit from ***GameplayDebuggerExtension*** (by
    starting from an empty class, like we did when extending the Categories, and then
    build on that). The naming convention that we''ll be using here is "*GameplayDebuggerExtension_Name*"
    (however, keep in mind that there might be a limit of *32* characters for the
    file name). In our case, we will go for ***GameplayDebuggerExtension_Player***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75791a25-7329-4479-b293-3ed45354e0e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The structure of a *Gameplay Debugger Extension* is quite straightforward,
    since we will need to implement and/or override the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Constructor***: This sets the default value for the extensions, including
    settings. More importantly, it sets the key binding for the extension (and passes
    a reference to the function you wish to bind).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***MakeInstance()***: This creates an instance of the *Gameplay Debugger Extension*
    as a shared reference. This function is required when the *Extension* is registered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***OnActivated()***: This performs initialization when the *Extension* is activated
    (e.g. the *Gameplay Debugger* opens).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***OnDeactivated()***: This cleans up when the *Extension* is deactivated (e.g.
    the *Gameplay Debugger* closes). For instance, the Spectator extension uses this
    function to destroy the spectator controller (if it exists) and return control
    to the *Player Controller* that was there before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***GetDescription()***: This describes the *Extension* to the *Gameplay Debugger*.
    This means that this function returns a *String* that''s used to display the text
    in the Gameplay Debugger; the usual format with the color is allowed. Moreover,
    you are able to use *`FGameplayDebuggerCanvasStrings::ColorNameEnabled`* and `*FGameplayDebuggerCanvasStrings::ColorNameDisabled*`
    for the String that describes the colors of enabled or disabled for the extension,
    respectively. This is very useful if your *Extension* uses a toggle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Action Function***: This performs the action that you want your *Extension*
    to do, so here, it can be whatever you want. This function will be passed to the
    Input Binding in the *Constructor*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Extension class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, we don''t need all the functions we just looked at. In our case,
    we can start by declaring the `Constructor`, `GetDescription()`, and `MakeInstance()`
    functions in the header (`.h`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need a protected function, which we will bind to a specific input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will need some protected variables: a boolean variable to check if
    an input has been binded, another boolean variable to see if the description has
    been cached, and a third variable that contains the cached description itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For performance reasons, it is always good practice to cache the description
    of a *Gameplay Debugger Extension*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, don''t forget to enclose the whole class within the conditional
    compiler directive and the `*WITH_GAMEPLAY_DEBUGGER*` macro. This is what the
    header (`.h`) file should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For the implementation, we can start by adding the following `#include` statements,
    since we will need to have access to the Player Controller and its Pawn to retrieve
    the Player''s location. Also, we will need to bind inputs, so we need to include
    the *Input Core Types* as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will implement our Constructor. Here is where we bind the input to
    a specific key. In our case, we can bind it to the *P* key. Of course, we will
    need a delegate, and we can pass our `PrintPlayerLocation()` function to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, if you can, cache your description so that your
    *Extension* gains some performance. Here is the code structure for caching our
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to get the Description. In this case, it can just be the Input
    Handler (so that we remember which key this Extension is bound to, and the word
    "Player" to remember that this is the Extension that retrieves the Player''s location.
    As for the colors, the Gameplay Debugger Extension provides some shortcuts for
    accessing specific colors (for instance, for toggling different kinds of Extensions,
    the color can changed based on whether it is toggled or not). We won''t pay much
    attention to colors at the moment, and we will use the default ones, assuming
    that everything is always enabled. As a result, this is the `GetDescription()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MakeInstance()` function, on the other hand, is pretty straightforward
    and very similar to the one we used for the *Gameplay Debugger Categories*; it
    just needs to return a shared reference to this Extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our `PrintPlayerPosition()` function, we can just use a *UE_LOG*
    to print the Player''s location. However, in a *Gameplay Debugger Extension*,
    its in these kind of functions (which are bound to the input) that the real magic
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once again, don't forget to wrap your C++ class with the compiler directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, this is the `.cpp` file of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Registering the Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like we did for *Gameplay Debugger Categories*, we need to register the
    *Extensions* as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we do that, if we try to compile, we will get an error. In
    fact, since we handle inputs for the *Extension*, the module in which the *Extension*
    lives requires the ***Public Dependency*** to the "***InputCore***". Add the following
    line to your `.build.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifically, for our Locator Module, this is how you should insert this dependency
    in the `GameplayDebugger_Locator.build.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you compile after this modification, you shouldn't get any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to register the Extension and notify the *Gameplay Debugger* of
    this change. We need to use specific functions to do so. Thus, in our `StartupModule()`
    function (in the `GameplayDebugger_Locatot.cpp` file), we need to add the following
    bold lines of code so that we can register and notify the *Gameplay Debugger*
    accordingly (note that we need to do this for both *Extensions* and *Categories*,
    since they are two different functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for unregistering the *Extension* when the module shuts down.
    Here is the code we need to add in the `ShutdownModule()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Compile the code, and your plugin will be ready. You might need to restart the
    editor for the effects to take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are still having trouble making the plugin load with the Gameplay Debugger
    available, navigate from the top menu of Unreal to ***Window -> Developer Tools
    | Modules***. From here, search for our Locator Module and then press on Reload,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bd100ac-6a94-4806-b7e3-c32ef8201dca.png)'
  prefs: []
  type: TYPE_IMG
- en: You may need to do this every time you load the editor in order to use your
    Categories and/or Extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go into the *Gameplay Debugger Settings*, you will find our *Extension*
    listed (and you will be able to change the key bind if you wish):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b1c68ab-fd44-4a62-8245-4f52a0a8c966.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how it will appear in-game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/380779c3-7e34-4d76-aef5-663bf986a9a2.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a close-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c311ca72-1515-4acd-a8ce-155eeba46ee8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you press *P*, then the Extension will produce the following result in the
    *Output Log*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02166dd5-76dc-41a0-970f-fdf03147d002.png)'
  prefs: []
  type: TYPE_IMG
- en: For more information about *Gameplay Debugger Extensions*, you should have a
    look at the classes contained in `GameplayDebuggerExtension.h` (the vase class
    to create an *Extension* of the *Gameplay Debugger*) and `GameplayDebuggerExtension_Spectator.h` (an
    implementation of an *Extension*, with an example of *Input Binding* and *Cached
    Description* as well).
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our adventure into extending the *Gameplay Debugger*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we look at how to take advantage of the ***Gameplay Debugger***
    for testing our AI systems. In particular, we looked at the default ***Categories
    and Extensions*** of the *Gameplay Debugger*, how they work, and which kind of
    information they display.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we saw how it is possible to ***extend the Gameplay Debugger*** by ***creating
    a new Category*** and a ***new Extension*** within a ***Plugin***. As a result,
    we unlocked great potential for debugging our own systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore ***AI in Games*** further, and see what's
    beyond.
  prefs: []
  type: TYPE_NORMAL
