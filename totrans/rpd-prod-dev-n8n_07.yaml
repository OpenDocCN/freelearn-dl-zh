- en: '*Chapter 5*: Building Your First API Endpoints'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：构建您的第一个API端点'
- en: Communication is at the core of all relationships. Good or bad relationships
    are often defined by how well two individuals can convey their thoughts, feelings,
    and ideas. Communication needs to be clear, accurate, and trusted.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 沟通是所有关系的基础。良好或糟糕的关系通常由两个人传达他们的思想、感受和想法的能力来定义。沟通需要清晰、准确和值得信赖。
- en: Sharing information appropriately is also critical for computer applications.
    Having a standard way of sending and receiving data between two different applications
    is critical for many programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 适当地共享信息对于计算机应用程序也是至关重要的。在两个不同的应用程序之间有标准的方式来发送和接收数据对于许多程序至关重要。
- en: One of these standards is referred to as an **API**, which stands for **application
    programming interface**. We are working specifically with the REST API architecture
    style. It was designed to quickly provide information and perform actions based
    on standard HTTP methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个标准被称为**API**，代表**应用程序编程接口**。我们正在专门使用REST API架构风格。它被设计为快速提供信息并根据标准HTTP方法执行操作。
- en: Because of this well-known and understood standard, in this chapter, we will
    show you how to plan and build an API using n8n. We will help you plan your API
    by understanding the core concepts of APIs and thinking about what you want the
    final product to perform. You will also understand how to use n8n to build, secure,
    and test the API that you designed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个众所周知且理解的标准，在本章中，我们将向您展示如何使用n8n规划和构建API。我们将通过理解API的核心概念，并思考您希望最终产品执行的功能来帮助您规划API。您还将了解如何使用n8n构建、保护和测试您设计的API。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Planning your project's API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划您项目的API
- en: Configuring the Webhook node to handle requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Webhook节点以处理请求
- en: Building the API in n8n
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在n8n中构建API
- en: Securing your API endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护您的API端点
- en: Testing your API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的API
- en: 'By the end of the chapter, you will be able to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够完成以下任务：
- en: Create blueprints for an API endpoint so that there's minimal friction when
    building the API.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API端点创建蓝图，以便在构建API时减少摩擦。
- en: Configure the Webhook node so that it can handle requests that are sent to our
    API and reply to them.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Webhook节点，使其能够处理发送到我们的API的请求并对其进行回复。
- en: Build an API endpoint in n8n based on the blueprints that we created.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于我们创建的蓝图，在n8n中构建一个API端点。
- en: Secure your API endpoints by using the different authentication methods available
    in the Webhook node.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Webhook节点中可用的不同身份验证方法来确保您的API端点安全。
- en: Test your API to make sure that all the functionalities that we have implemented
    work as expected.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的API以确保我们已实现的全部功能按预期工作。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章节的技术要求：
- en: A working version of n8n.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n8n的一个工作版本。
- en: A web browser.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络浏览器。
- en: 'Access to this book''s GitHub repository: [https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n).
    Another useful tool is the Insomnia API tool, which can be found at [https://insomnia.rest/](https://insomnia.rest/).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问本书的GitHub仓库：[https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n)。另一个有用的工具是Insomnia
    API工具，可在[https://insomnia.rest/](https://insomnia.rest/)找到。
- en: Planning your project's API
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划您项目的API
- en: Before you start building out your API, you must have a solid roadmap. This
    plan allows you to create the API quicker and ensure the design is consistent
    and accurate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始构建API之前，您必须有一个稳固的路线图。此计划允许您更快地创建API，并确保设计一致且准确。
- en: There are several different dimensions to consider when you are planning out
    your API. For an example of good API design, see the OpenAPI Specification at
    [https://swagger.io/specification/](https://swagger.io/specification/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您规划API时，需要考虑几个不同的维度。例如，良好的API设计，请参阅[https://swagger.io/specification/](https://swagger.io/specification/)上的OpenAPI规范。
- en: Easy to understand
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 易于理解
- en: How an API works should be almost obvious to a developer using it. The API should
    have terms that are consistent with similar APIs and adequately describe the information
    it is using and the action it is performing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用API的开发者来说，API的工作原理应该是几乎显而易见的。API应该有与类似API一致的术语，并充分描述它使用的信息和执行的操作。
- en: Output data in JSON
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以JSON格式输出数据
- en: While several different data formats are available to use, such as XML, YAML,
    and SOAP, REST APIs most often output their data in JSON format. To maintain consistency,
    it is recommended that all of your APIs, at the very least, be able to output
    their data in JSON.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种不同的数据格式可供使用，例如 XML、YAML 和 SOAP，但 REST API 最常以 JSON 格式输出数据。为了保持一致性，建议所有
    API 至少能够以 JSON 格式输出数据。
- en: Using the GET, HEAD, and POST HTTP methods
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GET、HEAD 和 POST HTTP 方法
- en: 'n8n supports three different HTTP methods (you can think of HTTP methods like
    action verbs that tell the system what to do with the request it has received):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: n8n 支持三种不同的 HTTP 方法（你可以将 HTTP 方法视为动作动词，告诉系统如何处理它接收到的请求）：
- en: '`GET`'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`HEAD`'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HEAD`'
- en: '`POST`'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`DELETE`'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: '`PATCH`'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: '`PUT`'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: While several other HTTP methods are available, such as `UPDATE`, at the time
    of writing this book, n8n does not support them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种其他的 HTTP 方法可用，例如 `UPDATE`，但在撰写本书时，n8n 不支持它们。
- en: The two most commonly used HTTP methods are `GET` and `POST`, each of which
    provides a specific action.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的两个 HTTP 方法是 `GET` 和 `POST`，每个都提供特定的操作。
- en: The `GET` method is generally used when we're attempting to retrieve (or get)
    information from the API. It should not be used to pass sensitive information
    to the API. It is common for the query parameters to be passed along in a URL
    format that is human readable and often stored in web browser history.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 方法通常用于尝试从 API 中检索（或获取）信息。它不应用于向 API 传递敏感信息。查询参数通常以人类可读的 URL 格式传递，并且经常存储在网页浏览器的历史记录中。'
- en: However, the flip side of this method is that it is straightforward to create
    a website URL that specifies all the information being requested by the user in
    a simple link.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的一个缺点是，当提交给服务器时，它不会在 URL 中显示所请求的所有信息。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This assumes that no security has been applied to the API that needs to be passed
    in the headers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设在 API 的头信息中没有应用任何安全措施。
- en: The `POST` HTTP method is usually used to create or add a new record to the
    system providing the API. In n8n, it is also often used to change a record since
    there is no `UPDATE` HTTP method support.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` HTTP 方法通常用于向提供 API 的系统创建或添加新的记录。在 n8n 中，它也常用于更改记录，因为目前没有 `UPDATE` HTTP
    方法支持。'
- en: One of the advantages of using the `POST` HTTP method is that it does not show
    up in the URL when it is submitted to the server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `POST` HTTP 方法的优点之一是，当提交给服务器时，它不会在 URL 中显示。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about response codes, check out the *HTTP methods* subsection
    of the *HTTP Request node – talk to any API* section of [*Chapter 3*](B17493_03_Final_PD_ePub.xhtml#_idTextAnchor039)*,
    Diving into Core Nodes and Data in n8n*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有关响应代码的更多信息，请参阅 *HTTP 方法* 子节，位于 *HTTP 请求节点 – 与任何 API 交谈* 部分，见 [*第 3 章*](B17493_03_Final_PD_ePub.xhtml#_idTextAnchor039)*，深入了解
    n8n 的核心节点和数据*。
- en: Knowing what your API will do
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解你的 API 将做什么
- en: It is critical to know precisely what your API is meant to do, not only in terms
    of the capabilities of the API but also inside the system. A simple API call can
    efficiently perform many different actions behind the scenes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 精确了解你的 API 意在做什么至关重要，这不仅涉及 API 的功能，还涉及系统内部。一个简单的 API 调用可以在幕后高效地执行许多不同的操作。
- en: Plan out what each API call does in detail once the system receives the API
    request. This should be very detailed and documented exceptionally well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统接收到 API 请求，就详细规划每个 API 调用的具体操作。这应该非常详细，并且要很好地记录。
- en: Having meaningful and consistent response codes
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有意义且一致的响应代码
- en: Several different response codes can be used in response to an API call. Still,
    it is generally recommended that you limit yourself to the `2xx` and `4xx` codes
    since most other codes are handled by other systems, such as the web server (although
    we have an exception for this).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应 API 调用时，可以使用几种不同的响应代码。然而，通常建议你限制自己使用 `2xx` 和 `4xx` 代码，因为大多数其他代码由其他系统处理，例如
    web 服务器（尽管对此有一个例外）。
- en: 'In general, it is recommended that you use the following code for each stated
    purpose:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，建议你为每个声明的目的使用以下代码：
- en: '`200 (OK)`: All the data has been received, processed, and returned correctly.
    No further actions are required.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 (OK)`: 所有数据都已接收、处理并正确返回。无需进一步操作。'
- en: '`201 (Created)`: Often used with `POST` requests, this indicates that the request
    has resulted in creating a new resource and that the information for the resource
    has been returned in the results.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201 (已创建)`: 通常与`POST`请求一起使用，这表示请求已导致创建新的资源，并且资源的信息已包含在结果中。'
- en: '`202 (Accepted)`: When information is processed asynchronously, the system
    may have been received but is not yet active in the system, so the API could return
    a `202` code. This lets the requester know that the information made it to its
    destination, but that it cannot be accessed yet.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`202 (已接受)`: 当信息异步处理时，系统可能已经接收到了信息，但尚未在系统中激活，因此API可以返回一个`202`代码。这会让请求者知道信息已经到达目的地，但还不能访问。'
- en: '`203 (Non-Authoritative Information)`: If you are caching local data to reduce
    the number of calls to a remote data source, your API can respond with a `203`
    response code to let the user know that the information they received was accurate
    the last time it pulled a copy of the information, though this could have changed
    in the interim.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`203 (非权威信息)`: 如果您正在缓存本地数据以减少对远程数据源的调用次数，您的API可以返回一个`203`响应代码，让用户知道他们接收到的信息是准确的，因为上次它拉取信息副本时是这样的，尽管在此期间可能已经发生了变化。'
- en: '`204 (No Content)`: Sometimes, a request for information is made to an API,
    but there is nothing to return to the user. For example, if an API references
    a list of animals (for example, cat, dog, and horse) and the user has requested
    a list of all reptiles, there would be no animals in the results. This is when
    the API would respond with a `204` response code so that the user knows that the
    API meant to send back no information and that there wasn''t some error returning
    no results from the API.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204 (无内容)`: 有时，向API发出信息请求，但没有内容可以返回给用户。例如，如果API引用了一个动物列表（例如，猫、狗和马）并且用户请求了所有爬行动物的列表，结果中就不会有动物。这时，API会以`204`响应代码响应，让用户知道API打算发送回没有信息，并且没有错误导致API没有返回结果。'
- en: '`206 (Partial Content)`: It is not uncommon for an API `GET` request to generate
    several thousands of records. Returning all of these records can be very taxing
    on both the server hosting the API and the client receiving the data. There can
    also be a considerable amount of bandwidth used when transmitting large amounts
    of data.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`206 (部分内容)`: API的`GET`请求生成数千条记录并不罕见。返回所有这些记录可能会对托管API的服务器和接收数据的客户端造成很大负担。在传输大量数据时，也可能会有相当大的带宽使用。'
- en: The API only sends out a portion of the records (often referred to as pagination)
    to the requestor to alleviate this issue. It includes a `206` response code to
    let us know that there is more information to be received.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API只向请求者发送部分记录（通常称为分页）以减轻这个问题。它包括一个`206`响应代码，让我们知道还有更多信息要接收。
- en: '`400 (Bad Request)`: It is straightforward to miswrite an API request, and
    it is important to let the requester know that they made a mistake. For example,
    if a requester was searching for a user by email address but asked the system
    to look for the information in the first name field, then a `400` response would
    be warranted.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 (错误请求)`: 错误地编写API请求很简单，并且重要的是要让请求者知道他们犯了错误。例如，如果请求者通过电子邮件地址搜索用户，但要求系统在名字字段中查找信息，那么应该返回一个`400`响应。'
- en: '`401 (Unauthorized)`: You should secure your API with some sort of authentication
    scheme. When someone provides the wrong authentication information, a `401` response
    code should be generated and returned to the user.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 (未授权)`: 您应该使用某种类型的身份验证方案来保护您的API。当有人提供错误的身份验证信息时，应该生成并返回一个`401`响应代码给用户。'
- en: '`403 (Forbidden)`: Sometimes, people attempt to access information that they
    shouldn''t, regardless of whether or not they are properly authenticated to the
    system. In this instance, a `403` response code would be returned to the user.
    I often use this response code when I have my API set up to only be accessed from
    a specific IP address and the IP addresses do not match.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403 (禁止访问)`: 有时，人们试图访问他们不应该访问的信息，无论他们是否已正确认证到系统中。在这种情况下，系统会向用户返回一个`403`响应代码。我经常在我将API设置为只能从特定的IP地址访问时使用这个响应代码，而IP地址不匹配。'
- en: '`404` (`Not Found`): It is not uncommon for users to accidentally enter the
    wrong information for a URL or for a resource to move. When that happens, the
    user making the request will automatically get a 404 error.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404` (`未找到`): 用户不小心输入错误的URL信息或资源移动的情况并不少见。当这种情况发生时，发起请求的用户将自动收到一个404错误。'
- en: Note
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about response codes, see the *Response codes* section
    of [*Chapter 3*](B17493_03_Final_PD_ePub.xhtml#_idTextAnchor039), *Diving into
    Core Nodes and Data in n8n*.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于响应代码的信息，请参阅[*第3章*](B17493_03_Final_PD_ePub.xhtml#_idTextAnchor039)的*响应代码*部分，*深入n8n的核心节点和数据*。
- en: Consistent noun/verb design
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致的主语/动词设计
- en: One very common way of laying out an API is by using a **noun/verb** architecture.
    The idea behind this design is that the requestor starts with an object or item
    that is directly followed by an action to be performed in that object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常常见的API布局方式是使用**名词/动词**架构。这种设计背后的理念是，请求者从一个对象或项目开始，紧接着是对该对象执行的操作。
- en: 'For example, if we were to create an API that would change the name of a device
    in its database, the request path may look something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们创建一个会更改数据库中设备名称的API，请求路径可能看起来像这样：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, if we were to remove that device from the database, the API call
    path might look something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们从数据库中删除该设备，API调用路径可能看起来像这样：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Submitting data
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交数据
- en: 'There are several different ways to submit data to an API. It is entirely up
    to you how you want your users to send information to your API:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 向API提交数据有几种不同的方式。完全取决于你希望用户如何将信息发送到你的API：
- en: '**Body**: The body of the API request is a common place to place information.
    This is most often used in POST HTTP requests.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**: API请求的主体是放置信息的一个常见位置。这通常用于POST HTTP请求。'
- en: '`/record/237/delete` to accomplish this task.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/record/237/delete`来完成这项任务。'
- en: '`GET` HTTP method as it is used to ask for specific information. A query is
    often represented by a URL and is even displayed that way. For example, if you
    were to request record 237 from the system using a query, the URL path may look
    something like [`https://api.example.com/record/display?recordID=237`](https://api.example.com/record/display?recordID=237).
    The `?` character separates the API path and the query. `recordID` is the data
    key to be searched for, while `237` is the value of the key the system is looking
    for. You can also have multiple key/value pairs in a query by concatenating the
    queries together with a `&` character; for example, `recordID=237&fname=Tim`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` HTTP方法，因为它用于请求特定信息。查询通常由URL表示，甚至以这种方式显示。例如，如果你要使用查询从系统中请求第237条记录，URL路径可能看起来像这样：[`https://api.example.com/record/display?recordID=237`](https://api.example.com/record/display?recordID=237)。`?`字符将API路径和查询分开。`recordID`是要搜索的数据键，而`237`是系统正在寻找的键的值。你还可以通过使用`&`字符将查询连接起来，在查询中包含多个键/值对；例如，`recordID=237&fname=Tim`。'
- en: '**Header**: You can also send information as a part of the headers in the request.
    This is often done when you''re sending authentication information such as an
    API token to the API.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**: 你也可以在请求中将信息作为头部的一部分发送。这通常发生在你发送认证信息，如API令牌到API时。'
- en: Versioning your API
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API版本控制
- en: It is not uncommon that, as your system changes and matures, you may want to
    make changes to your API. The problem with modifying how your API works is that
    the changes can suddenly make a large number of user programs and scripts fail.
    This quickly leads to several upset and disgruntled customers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的系统发生变化和成熟时，你可能想要修改你的API。修改API工作方式的问题在于，这些更改可能会突然导致大量用户程序和脚本失败。这很快就会导致几个不满的客户。
- en: One easy way around this is to create multiple versions of your API. This way,
    people can continue to use their scripts with previous versions of the API while
    new users can automatically move to the new version.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决这个问题的简单方法是为你的API创建多个版本。这样，人们可以继续使用他们之前的API版本的脚本，而新用户可以自动迁移到新版本。
- en: However, there is an issue with creating multiple versions of your API. As the
    number of versions grows, so does the effort required to maintain the system and
    all of its versions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建API的多个版本存在问题。随着版本数量的增加，维护整个系统和所有版本所需的工作量也会增加。
- en: To avoid this ever-growing effort, it is recommended that you maintain no more
    than two versions of an API at any given time. When a new version of the API is
    released, clearly communicate to the users that the previous version has been
    replaced and that the old version will be decommissioned in a reasonable amount
    of time ("**reasonable**" depends on the audience, where it could be a couple
    of weeks, or several years).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种不断增长的努力，建议您在任何时候维护不超过两个版本的API。当API的新版本发布时，应明确通知用户，旧版本已被替换，并且将在合理的时间内停用（“合理”取决于受众，可能是几周或几年）。
- en: Documenting your API
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录您的API
- en: One of the most important parts of the design process is documenting the API
    so that others can use it properly. This can also help you figure out what you
    did when you come to troubleshoot it 2 years later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设计过程中最重要的部分之一是记录API文档，以便其他人能够正确地使用它。这也有助于你在两年后回过头来排查问题时，能够弄清楚自己当时做了什么。
- en: The OpenAPI Specification
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenAPI规范
- en: One of the more common forms of documentation is the OpenAPI Specification ([https://github.com/OAI/OpenAPI-Specification](https://github.com/OAI/OpenAPI-Specification)).
    This specification only takes a couple of hours to learn and can be used in conjunction
    with other tools to automatically create an API testing platform and all user
    documentation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 较常见的文档形式之一是OpenAPI规范([https://github.com/OAI/OpenAPI-Specification](https://github.com/OAI/OpenAPI-Specification))。学习这个规范只需要几个小时，并且可以与其他工具结合使用，以自动创建API测试平台和所有用户文档。
- en: The specification uses either a JSON or YAML file to outline how your API behaves
    and how to create the documentation for the specification.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范使用JSON或YAML文件来概述API的行为以及如何为规范创建文档。
- en: 'The following is a simple JSON OpenAPI Specification file''s contents:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容是一个简单的JSON OpenAPI规范文件的详细内容：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is only a small piece of the API that we are going to be building in the
    next few sections of this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们将在本章接下来的几节中构建的API的一小部分。
- en: 'The following screenshot shows the documentation that is generated from this
    specification file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了从该规范文件生成的文档：
- en: '![Figure 5.1 – Generated documentation from the OpenAPI Specification file'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 从OpenAPI规范文件生成的文档'
- en: '](img/Figure_5.01_B17493.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B17493.jpg)'
- en: Figure 5.1 – Generated documentation from the OpenAPI Specification file
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 从OpenAPI规范文件生成的文档
- en: 'We have created a full API definition for this, which you can find here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为这个创建了完整的API定义，您可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/tree/main/Chapter%205](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/tree/main/Chapter%205)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/tree/main/Chapter%205](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/tree/main/Chapter%205)'
- en: Now that we know how to design APIs, it is time to dive into n8n and start the
    basic setup for creating our API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何设计API，是时候深入n8n并开始创建我们的API的基本设置了。
- en: Configuring the Webhook node to handle requests
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Webhook节点以处理请求
- en: The core node for building an API in n8n is the Webhook node. While this may
    seem a bit strange on the surface, it makes a lot of sense when you start to think
    of it in the correct frame of mind.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在n8n中构建API的核心节点是Webhook节点。虽然这表面上可能看起来有些奇怪，但当你以正确的思维方式去思考时，它就变得非常有意义。
- en: 'Webhooks are web services that are sitting on a system, waiting to be called
    upon to perform some action. Meanwhile, an API is a service that a client uses
    to perform actions on a remote server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Webhooks是一种位于系统上的网络服务，等待被调用以执行某些操作。与此同时，API是客户端用来在远程服务器上执行操作的服务的：
- en: '![Figure 5.2 – The Webhook node'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – Webhook节点'
- en: '](img/Figure_5.02_B17493.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B17493.jpg)'
- en: Figure 5.2 – The Webhook node
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – Webhook节点
- en: So, what is seen as an API from the client's perspective is the same as a Webhook
    from the server's perspective! And this is why we use a Webhook to create an API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从客户端的角度看，API与从服务器的角度看Webhook是相同的！这就是为什么我们使用Webhook来创建API的原因。
- en: The Webhook node is a trigger node that executes a workflow when it receives
    a remote connection. It collects the information that it receives and performs
    actions based on that information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook节点是一个触发节点，当它接收到远程连接时执行工作流程。它收集接收到的信息，并根据这些信息执行操作。
- en: Parameters
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: The Webhook node is configured by setting the parameters in the node itself.
    Each of these parameters modifies the behavior of the Webhook and some parameters,
    such as the **Authentication** and **HTTP Method** parameters, enable even more
    options for the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 节点通过在节点本身设置参数进行配置。这些参数中的每一个都会修改 Webhook 的行为，一些参数，如**认证**和**HTTP 方法**参数，甚至为用户提供了更多选项。
- en: Webhook URLs
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Webhook URLs
- en: If you click on the text in the Webhook node that reads **Webhook URLs**, it
    will open up a small panel below it. You will see two buttons, one reading **Production**
    and the other reading **Test**. These are the two different types of Webhook URLs
    that are available to use.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 Webhook 节点上显示为**Webhook URLs**的文本，它将在其下方打开一个小面板。你会看到两个按钮，一个上写着**生产**，另一个上写着**测试**。这些是可用的两种不同类型的
    Webhook URL。
- en: 'These URLs in n8n cloud are built by combining the n8n protocol (`https://`),
    the hostname (`tephlon.app.n8n.cloud/`), the Webhook root (`webhook` for production
    and `webhook-test` for test), and the Webhook path (`f929fdc9-b62a-4661-913e-b5648c407edd`).
    This creates the two Webhook paths of `https://tephlon.app.n8n.cloud/webhook/f929fdc9-b62a-4661-913e-b5648c407edd`
    for **Production** and [https://tephlon.app.n8n.cloud/webhook-test/f929fdc9-b62a-4661-913e-b5648c407edd](https://tephlon.app.n8n.cloud/webhook-test/f929fdc9-b62a-4661-913e-b5648c407edd)
    for **Test**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: n8n 云中的这些 URL 通过组合 n8n 协议（`https://`）、主机名（`tephlon.app.n8n.cloud/`）、Webhook
    根（生产为 `webhook`，测试为 `webhook-test`）和 Webhook 路径（`f929fdc9-b62a-4661-913e-b5648c407edd`）来构建。这创建了两个
    Webhook 路径：`https://tephlon.app.n8n.cloud/webhook/f929fdc9-b62a-4661-913e-b5648c407edd`
    用于**生产**，以及 [https://tephlon.app.n8n.cloud/webhook-test/f929fdc9-b62a-4661-913e-b5648c407edd](https://tephlon.app.n8n.cloud/webhook-test/f929fdc9-b62a-4661-913e-b5648c407edd)
    用于**测试**：
- en: '![Figure 5.3 – Initial Webhook properties'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.3 – Initial Webhook properties'
- en: '](img/Figure_5.03_B17493.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.03 – Initial Webhook properties](img/Figure_5.03_B17493.jpg)'
- en: Figure 5.3 – Initial Webhook properties
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.3 – Initial Webhook properties
- en: 'You can modify the Webhook''s endpoint locations by changing the `f929fdc9-b62a-4661-913e-b5648c407edd`
    to `api/v1/user/add`, then the Webhook paths would change to [`https://tephlon.app.n8n.cloud/webhook/api/v1/user`](https://tephlon.app.n8n.cloud/webhook/api/v1/user)
    for `https://tephlon.app.n8n.cloud/webhook-test/api/v1/user/add` for **Test**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `f929fdc9-b62a-4661-913e-b5648c407edd` 更改为 `api/v1/user/add` 来修改 Webhook
    的端点位置，然后 Webhook 路径将更改为 [https://tephlon.app.n8n.cloud/webhook/api/v1/user](https://tephlon.app.n8n.cloud/webhook/api/v1/user)
    用于 `https://tephlon.app.n8n.cloud/webhook-test/api/v1/user/add` 的**测试**：
- en: '![Figure 5.4 – Changing the Webhook paths'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.4 – 修改 Webhook 路径](img/Figure_5.04_B17493.jpg)'
- en: '](img/Figure_5.04_B17493.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.04 – Initial Webhook properties](img/Figure_5.04_B17493.jpg)'
- en: Figure 5.4 – Changing the Webhook paths
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.4 – 修改 Webhook 路径
- en: The two different types of Webhook URLs – **Production** and **Test** – serve
    two different purposes. The **Production** URL is used when your workflow has
    been saved and set to **Active**. The Webhook will then respond even when the
    Editor UI is not open. It is designed to be available and work completely on its
    own.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同的 Webhook URL 类型 – **生产**和**测试** – 用于不同的目的。**生产** URL 在你的工作流程已保存并设置为**活动**时使用。即使编辑器
    UI 未打开，Webhook 也会响应。它旨在独立可用并完全自主工作。
- en: 'The **Test** URL is designed to be used when you are building and troubleshooting
    your API. It still requires that your workflow be saved to register the Webhook
    URL but it will only be active when one of the following conditions has been met:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试** URL 设计用于在构建和调试你的 API 时使用。它仍然需要将你的工作流程保存以注册 Webhook URL，但它只有在满足以下条件之一时才会激活：'
- en: You press the **Execute Workflow** button in the Editor UI.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在编辑器 UI 中按下**执行工作流程**按钮。
- en: You press the **Execute Node** button in an open node that is either the Webhook
    node or a child node to the Webhook node with no cached information available
    to be processed.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在一个开放的节点上按下**执行节点**按钮时，这个节点要么是 Webhook 节点，要么是 Webhook 节点的子节点，并且没有可处理的信息缓存。
- en: 'The **Test** URL is available until one of the following actions occurs:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试** URL 在以下任一操作发生之前都可用：'
- en: A connection attempt is made.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行连接尝试。
- en: The **Stop** button is pressed in the Editor UI.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑器 UI 中按下**停止**按钮。
- en: 120 seconds have passed since the Webhook was initiated.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自 Webhook 启动以来已过去 120 秒。
- en: Once this happens, the Webhook URL will unregister and the workflow will stop.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生这种情况，Webhook URL 将注销，工作流程将停止。
- en: The purpose of the **Test** URL is to provide an easy way to see what is happening
    in each node when a request is made and troubleshoot the workflow for development.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试** URL 的目的是提供一个简单的方法来查看在请求时每个节点发生了什么，并调试开发中的工作流程。'
- en: Authentication
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: Since APIs are a very common way for people to programmatically access pure
    data from a system, there is a good chance that you may want to secure that data.
    Even if your API is going to be publicly available to everyone, it can be a good
    idea to set up registration and authentication for your API so that you can track
    who is using (or abusing) your API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API是人们以编程方式从系统中访问纯数据的一种非常常见的方式，因此您很可能希望保护这些数据。即使您的API将公开对每个人可用，设置API的注册和认证也是一个好主意，这样您可以跟踪谁在使用（或滥用）您的API。
- en: While there are many different aspects of securing your API (many of which will
    be covered a bit later in this chapter), we want to take a quick look at authentication
    for your API. This can be accomplished using the **Authentication** parameter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多不同的方面可以保护您的API（其中许多将在本章稍后部分介绍），但我们想快速查看您的API认证。这可以通过使用**认证**参数来完成。
- en: 'The Authentication parameter has three different options:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 认证参数有三个不同的选项：
- en: None
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无
- en: Basic Auth
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: Header Auth
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部认证
- en: 'Selecting **None** for the **Authentication** parameter is self-explanatory:
    the Webhook will not look for any form of authentication before executing the
    workflow or returning information. While there are valid use cases for not using
    any authentication for your API (for example, you want to use the Webhook like
    a web server and display web content), it is generally frowned upon as a practice.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**无**作为**认证**参数是显而易见的：Webhook在执行工作流或返回信息之前不会寻找任何形式的认证。虽然不使用任何认证的API有有效的用例（例如，您希望将Webhook用作Web服务器并显示网页内容），但通常这种做法是不受欢迎的。
- en: '**Basic Auth** is the simplest form of authentication that n8n can use. It
    essentially sends a Base64 calculated version of a username and a password to
    n8n and compares it to the password information that it has on record.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本认证**是n8n可以使用的最简单的认证形式。它本质上发送一个基于Base64计算的用户名和密码版本到n8n，并将其与它记录在案的密码信息进行比较。'
- en: For example, if we were to use Basic Auth for our API and the username and password
    required are `jim.nasium` and `123456`, the API client would calculate the Base64
    version of `jim.nasium:123456` (which is `amltLm5hc2l1bToxMjM0NTY=`) and send
    it in the header request.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们为我们的API使用基本认证，并且所需的用户名和密码是`jim.nasium`和`123456`，API客户端将计算`jim.nasium:123456`的Base64版本（即`amltLm5hc2l1bToxMjM0NTY=`），并将其发送在头部请求中。
- en: Calculating the Base64 Value
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 计算Base64值
- en: 'If you ever find yourself in need of generating the Base64 value for a `Function`
    node, you can use the following code to do this for you. Simply replace the values
    of the username and password:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为`函数`节点生成Base64值，您可以使用以下代码为您完成。只需替换用户名和密码的值即可：
- en: '`var username = "jim.nasium";`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`var username = "jim.nasium";`'
- en: '`var password = "123456";`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`var password = "123456";`'
- en: '`var encoded = Buffer.from(username + ":" + password).toString(''base64'');`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`var encoded = Buffer.from(username + ":" + password).toString(''base64'');`'
- en: While this is better than no authentication at all, it isn't all that great.
    Since Base64-encoded text is really easy to reverse engineer, it is recommended
    that the API is secured properly by complimentary means such as SSL/TLS certificates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这比完全没有认证要好，但它并不算很好。由于Base64编码的文本很容易逆向工程，建议通过SSL/TLS证书等补充手段正确地保护API。
- en: '**Header Auth** is similar to **Basic Auth** in that it sends a value in the
    header of the API request. However, the difference is that it is just a random
    string of characters that is very difficult to memorize.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**头部认证**与**基本认证**类似，因为它在API请求的头部发送一个值。然而，不同之处在于它只是一个非常难以记忆的随机字符序列。'
- en: In both the **Basic** and **Header Auth** scenarios, you are required to create
    credentials that hold the information that's required for users to access the
    API. Without these credentials, you users will not be able to use the API.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在**基本**和**头部认证**场景中，您需要创建凭证，这些凭证包含用户访问API所需的信息。没有这些凭证，您的用户将无法使用API。
- en: HTTP methods
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP方法
- en: 'As we mentioned earlier in this chapter, the n8n Webhook node supports three
    different HTTP methods:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面提到的，n8n Webhook节点支持三种不同的HTTP方法：
- en: '`GET`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`HEAD`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`'
- en: '`POST`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: Depending on the HTTP method that you select, different options become available
    to you.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的HTTP方法，不同的选项将可供您使用。
- en: General options
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一般选项
- en: 'Four options are available for all the methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法都提供了四种选项：
- en: Response Content-Type
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应内容类型
- en: Response Headers
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头
- en: Property Name
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名称
- en: Raw Body
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始正文
- en: '`/`") character.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`")字符。'
- en: For example, if your API is returning JSON data, you would set `text/json`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的API返回JSON数据，您将设置`text/json`。
- en: For an official list of all the media types that are available, visit the **Internet
    Assigned Numbers Authority** (**IANA**) *Media Types* web page at [https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用媒体类型的官方列表，请访问[https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml)上的**互联网数字分配机构**（**IANA**）**媒体类型**网页。
- en: The **Response Headers** option allows you to add additional key/value pairs
    to the headers to provide extra metadata to the response. This is information
    about the data that the user is receiving from the API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应头**选项允许您向头部添加额外的键值对，以提供额外的元数据给响应。这是关于用户从API接收的数据的信息。'
- en: It is often used to confirm that the data is accurate and has not been tampered
    with between the sender and the receiver. It could contain a hash algorithm that
    the receiver could calculate to determine that the information is accurate or
    a timestamp to indicate when the information was received.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常用于确认数据在发送者和接收者之间准确无误且未被篡改。它可能包含接收者可以计算以确定信息准确性的哈希算法，或表示接收信息的时间戳。
- en: The **Property Name** option allows you to return just the value of a specific
    value/key pair.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性名称**选项允许您仅返回特定值/键对的值。'
- en: 'For example, let''s assume that you have a Webhook set up that outputs the
    following JSON object:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您已设置一个Webhook，输出以下JSON对象：
- en: '[PRE3]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if we were to modify that Webhook and add the **Property Name** option
    with a value of **status**, our output would be as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们修改该Webhook并添加**属性名称**选项，其值为**状态**，我们的输出将如下所示：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is useful if you have HTML in a key-value pair and you just want to output
    the HTML to display a web page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在键值对中有HTML，并且只想输出HTML以显示网页，这很有用。
- en: The final option is **Raw Body**. The **Raw Body** option is a binary (off or
    on) value that indicates the information coming into the Webhook is in a raw format,
    such as XML or JSON.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是**原始体**。**原始体**选项是一个二进制（开或关）值，表示进入Webhook的信息是以原始格式，如XML或JSON。
- en: Additional POST option
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外的POST选项
- en: When you select **Post** for the HTTP method, there is one extra option available.
    This is the **Binary Data** option. This option is used to indicate that the API
    is expecting that there will be binary data attached to the request. This is handy
    when you are uploading files to the system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择HTTP方法的**POST**时，将有一个额外的选项可用。这是**二进制数据**选项。此选项用于指示API期望请求中附加二进制数据。当您向系统上传文件时，这很有用。
- en: Response Code
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应代码
- en: The **Response Code** parameter is used to reply to the sender with a quick
    response, letting the requester know the results of their request.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应代码**参数用于向发送者发送快速响应，让请求者知道其请求的结果。'
- en: We went through response codes in detail earlier in this chapter, so I'm not
    going to go over them again, but make sure that you reference the code and reply
    with the appropriate response.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经详细介绍了响应代码，所以我不打算再次讲解它们，但请确保您参考代码并回复适当的响应。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The response code that you are selecting is going to be sent when everything
    goes well. Other failure response codes (for example, `404`) will be sent by the
    system and do not need to be programmed here.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切顺利时，您选择的响应代码将被发送。其他失败响应代码（例如，`404`）将由系统发送，此处不需要编程。
- en: Response Mode
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应模式
- en: 'The **Response Mode** option controls how the Webhook responds to the request.
    Two options can be set for the Response Mode option:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应模式**选项控制Webhook如何响应请求。可以为响应模式选项设置两个选项：'
- en: On Received
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收时
- en: Last Node
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个节点
- en: In general, if you are not passing data back to the requester, you will want
    to use the **On Received** option. Otherwise, if you are sending information back
    via the API, you should use the **Last Node** option.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您不向请求者返回数据，您将想要使用**接收时**选项。否则，如果您通过API发送信息，您应使用**最后一个节点**选项。
- en: The **On Received** option will immediately send the value of the **Response
    Code** option back to the sender. It does not wait for the workflow to complete
    before returning this code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收时**选项将立即将**响应代码**选项的值发送回发送者。它不会等待工作流程完成再返回此代码。'
- en: Things get a little bit more interesting with the **Last Node** option. When
    you want to return information to the requester, this option will initiate a workflow
    and then the results (or part of the results) of the last executed node will be
    returned to the requester as JSON.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **最后一个节点** 选项相比，事情变得更有趣。当你想向请求者返回信息时，此选项将启动一个工作流程，然后最后执行节点的结果（或部分结果）将以 JSON
    格式返回给请求者。
- en: Response Data options
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应数据选项
- en: 'When you select the **Last Node** option for **Response Mode**, this enables
    a new parameter called **Response Data**. The three options for **Response Data**
    are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择 **响应模式** 中的 **最后一个节点** 选项时，这将启用一个名为 **响应数据** 的新参数。**响应数据** 的三个选项如下：
- en: All Entries
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有条目
- en: First Entry JSON
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首条条目 JSON
- en: First Entry Binary
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首条目二进制
- en: 'To understand how this option works, we will look at an example. Let''s assume
    that we have a workflow with the final node outputting the following JSON array:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解此选项如何工作，我们将查看一个示例。假设我们有一个工作流程，其最终节点输出以下 JSON 数组：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Also, for each JSON object in the array, there is a binary file attached to
    the object; `CV - Jim Nasium.pdf` for the first one and `Resume - Kris P. Bayken.pdf`
    for the second one.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于数组中的每个 JSON 对象，都有一个与对象关联的二进制文件；第一个是 `CV - Jim Nasium.pdf`，第二个是 `Resume
    - Kris P. Bayken.pdf`。
- en: If we set the **Response Data** parameter to **All Entries**, the requester
    will receive the entire array contents but none of the files.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 **响应数据** 参数设置为 **所有条目**，请求者将收到整个数组内容，但没有任何文件。
- en: 'When we change **Response Data** to **First Entry JSON**, the receiver will
    receive the following JSON object:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 **响应数据** 更改为 **首条目 JSON** 时，接收者将收到以下 JSON 对象：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, if we use the `CV - Jim Nasium.pdf` file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们使用 `CV - Jim Nasium.pdf` 文件。
- en: Now that we have gone through the Webhook node in great detail, it is time to
    start building out our API in n8n.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经详细地了解了 Webhook 节点，现在是时候开始在 n8n 中构建我们的 API 了。
- en: Building the API in n8n
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 n8n 中构建 API
- en: We are finally ready to start building in n8n! Let's start by outlining our
    project.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好开始在 n8n 中构建了！让我们先概述我们的项目。
- en: API project specifications
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 项目规范
- en: For our project, we are going to build a simple user management API that will
    modify the user information in an Airtable database. Most of the workflow that
    we will be building isn't important to the API itself. All we have to be aware
    of is the result of each API.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将构建一个简单的用户管理 API，该 API 将修改 Airtable 数据库中的用户信息。我们将构建的大部分工作流程对 API 本身并不重要。我们只需要关注每个
    API 的结果。
- en: 'Our API is going to have five endpoints:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 API 将有五个端点：
- en: '`POST /api/v1/user/add`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /api/v1/user/add`'
- en: '`GET /api/v1/user/list`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/v1/user/list`'
- en: '`GET /api/v1/user/search`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/v1/user/search`'
- en: '`POST /api/v1/user/delete`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /api/v1/user/delete`'
- en: '`POST /api/v1/user/changepw`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /api/v1/user/changepw`'
- en: The base URL for our API will be [https://tephlon.app.n8n.cloud/webhook](https://tephlon.app.n8n.cloud/webhook)
    since that is the Webhook URL for my n8n cloud instance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 API 的基本 URL 将是 [https://tephlon.app.n8n.cloud/webhook](https://tephlon.app.n8n.cloud/webhook)，因为那是我的
    n8n 云实例的 Webhook URL。
- en: Our API will also use header authentication with a bearer token value of `675tryfhgui89765tyrfghjui89765uyr4thfgjuio`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 API 还将使用带有 `675tryfhgui89765tyrfghjui89765uyr4thfgjuio` 认证令牌值的头认证。
- en: 'The Airtable database will store the following information:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Airtable 数据库将存储以下信息：
- en: '**First Name**: The user''s first name'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名字**：用户的名字'
- en: '**Last Name**: The user''s last name'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**姓氏**：用户的姓氏'
- en: '**Email**: The user''s email address'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件**：用户的电子邮件地址'
- en: '**Password Hash**: A calculated value representing the user''s password'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码哈希**：表示用户密码的计算值'
- en: Note
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The reason that we do not store the user's password is for security. If the
    data table were to become compromised, the user's password would be out in the
    wild. By storing a calculated value based on the user's password, the same calculation
    can be performed each time the password is supplied to n8n, and the calculated
    value is compared to the stored value.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不存储用户密码的原因是为了安全。如果数据表遭到破坏，用户的密码就会泄露。通过存储基于用户密码的计算值，每次向 n8n 提供密码时都可以执行相同的计算，并将计算值与存储值进行比较。
- en: Creating credentials
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建凭证
- en: 'The first step will be to create the header authentication:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是创建头认证：
- en: In the n8n Editor UI, click on the "^" icon and click on **New**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 n8n 编辑器 UI 中，点击 "^" 图标，然后点击 **新建**。
- en: When prompted, select **Header Auth** for **Credential type**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，选择 **头认证** 作为 **凭证类型**。
- en: In the `Header Authentication`
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Header Authentication`
- en: '`Auth`'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Auth`'
- en: '`Bearer 675tryfhgui89765tyrfghjui89765uyr4thfgjuio`'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Webhook`'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final credentials form should look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Header Auth credentials'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17493.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Header Auth credentials
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create** button to complete this process.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Webhooks
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s create the Webhooks in n8n:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Create five new Webhook nodes and name them like so:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Add`'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Search`'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delete`'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChangePW`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure each of the Webhooks based on the following table:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Table_5.1_B17493.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: That should complete the initial Webhook creation. Make sure to save and activate
    the workflow.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the workflow
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the rest of the workflow is important for generating the proper outcomes
    for the API, it has very little to do with the API itself.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the whole workflow here: [https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/blob/main/Chapter%205/User_Management_API.json](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/blob/main/Chapter%205/User_Management_API.json).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built the API in n8n, let's look at how to add further security
    to your API endpoints.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Securing your API endpoints
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we talked about using Webhook authorization to help
    secure your API. This is an important first step but that does not mean that your
    API is secure. There are several extra actions that you can take to secure your
    API.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Using SSL/TLS security
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSL and its younger brother, TLS, are common security standards on the internet.
    Any time you see `https` in front of a website address, this means that one of
    these systems is at work.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of SSL/TLS is to encrypt the communication between the client software
    (for example, the web browser, n8n, and API client) and the web server that is
    hosting the API. This way, if someone were to set themselves up between you and
    the API server, all they would get is jibberish instead of the API tokens and
    passwords that are used to access that information.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Limiting where users come from
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of reducing the probability of being taken down by a malicious actor
    is to limit who can access your API based on where they are coming from. For example,
    if all your clients who use your API are from Germany, then there is no point
    in allowing people from Canada to access the API.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: While this is not a perfect solution, since it is relatively easy to get around
    by using a VPN, this means that people who are out to cause trouble need to jump
    through yet another hoop.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: If you want to take this option to the next level, you can even limit access
    to a single IP address so that only people from a specific office can use your
    API.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Proxying your API
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Putting your API behind a proxy is one of the smartest things that you can
    do. Here are some of the benefits of doing this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: It prevents people from directly accessing your API server.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It hides other potentially dangerous open ports.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can reduce calls to your API and other tools by caching requests and returning
    results without having to talk to the API server.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过缓存请求并在不与API服务器通信的情况下返回结果来减少对API和其他工具的调用。
- en: It can distribute requests across several servers.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以将请求分散到多个服务器。
- en: With all of these advantages from the proxy, it is well worth looking into setting
    up a proxy.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代理提供了所有这些优势，因此深入研究设置代理是值得的。
- en: Rotating security tokens
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮换安全令牌
- en: With security breaches happening daily, it is well worth changing the API tokens
    regularly as well. There are several different ways to do this but you need to
    find a way that works for you.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每天都有安全漏洞发生，定期更改API令牌也是非常值得的。有几种不同的方法可以做到这一点，但你需要找到适合你的方法。
- en: One of the best ways to do this is to have a token expire after a certain period.
    At that point, the user would be required to get a new token. This can be automated
    so that as soon as the token times out, the system knows to reach out and request
    a new one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的最好方法之一是在一定期限后使令牌过期。到那时，用户将需要获取一个新的令牌。这可以自动化，以便在令牌过期后，系统知道去请求一个新的。
- en: This way, even if your token were to get out and someone on the internet were
    to start using it, they would only have access for a short period before the token
    would expire and then require a new token to be generated.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，即使你的令牌泄露，互联网上的人开始使用它，他们也只有短暂的访问权限，然后令牌会过期，需要生成新的令牌。
- en: Tracking and limiting the number of requests
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪和限制请求数量
- en: 'It is important to record every single connection attempt that occurs on your
    API server. This provides you with two advantages:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 记录你API服务器上发生的每一个连接尝试非常重要。这为你提供了两个优势：
- en: You can identify if there is any strange behavior occurring on your API server.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以识别你的API服务器上是否有任何异常行为发生。
- en: You can prevent one person or organization from abusing the API server.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以防止某个人或组织滥用API服务器。
- en: Users (as identified by their token) and organizations (as identified by their
    IP address) should have the number of calls they make throttled to a reasonable
    speed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 用户（通过他们的令牌识别）和组织（通过他们的IP地址识别）应该将他们发出的调用数量限制在合理的速度。
- en: Providing metadata in your API responses
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的API响应中提供元数据
- en: 'Embedding useful metadata in the information that you provide to your users
    is a great way to allow the end user to verify the information that they are receiving
    is accurate. Some examples of good metadata are as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在你提供给用户的信息中嵌入有用的元数据是允许最终用户验证他们接收到的信息是否准确的好方法。以下是一些好的元数据示例：
- en: Providing an **MD5** sum value when downloading a file for the user
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户下载文件时提供**MD5**校验和值
- en: Indicating the record count being returned from a query
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示查询返回的记录数
- en: Performing a GeoIP lookup of the city the user is coming from so that they can
    confirm the request is legitimate
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用户来源的城市执行GeoIP查找，以便他们可以确认请求是合法的
- en: Returning the length of the results in a certain number of characters
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一定数量的字符返回结果的长度
- en: Once your API is secure, it is time to start testing its robustness.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的API安全，就是时候开始测试其健壮性了。
- en: Testing your API
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的API
- en: Creating a testing plan for your API is an important part of the design and
    rollout process. If you do not test your API properly, there is no telling what
    results your clients will get.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的API创建一个测试计划是设计和推出过程中的一个重要部分。如果你没有正确测试你的API，你无法预测你的客户将得到什么结果。
- en: Because of its importance, let's look at some recommendations for API testing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其重要性，让我们看看一些API测试的建议。
- en: Use a testing platform
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试平台
- en: While you may be able to manually test some small or simple APIs, the bigger
    they become, the harder they are to test. Not only does this allow you to do more
    for testing, but it also allows you to easily retest after you make changes, knowing
    that the test is the same as it was the previous time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能能够手动测试一些小型或简单的API，但它们越大，测试就越困难。这不仅允许你进行更多的测试，而且在你做出更改后，你可以轻松地重新测试，知道测试与上一次相同。
- en: If you don't have a testing platform, you can easily create several testing
    scripts using the cURL command-line tool or use something such as the documentation
    and testing tool built into Insomnia (`https://insomnia.rest`).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有测试平台，你可以轻松地使用cURL命令行工具创建几个测试脚本，或者使用内置在Insomnia（`https://insomnia.rest`）中的文档和测试工具。
- en: Follow the documentation
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循文档
- en: The documentation that you have created or been provided with is very important.
    Make sure you can do everything that the documentation says that it can do and
    none of the things that it doesn't say you can do.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建或收到的文档非常重要。请确保您可以做文档所说的每一件事，而不会做它没有说您可以做的事情。
- en: You should be able to do absolutely everything that is in the documentation
    without fail.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够毫无例外地完成文档中提到的每一件事。
- en: Try to break it
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试破坏它
- en: 'This is the part of the testing process that you can have a lot of fun with.
    Here are some ideas I''ve had success with in the past:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试过程中您可以玩得很开心的部分。以下是我过去成功尝试的一些想法：
- en: Send information in different character sets.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的字符集发送信息。
- en: Enter SQL commands as usernames or passwords and see if the commands execute
    on the server.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SQL命令作为用户名或密码输入，并查看这些命令是否在服务器上执行。
- en: Overload the server by making thousands of calls per second.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过每秒成千上万次的调用来超载服务器。
- en: Try to get access to the information you shouldn't be able to on the server.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试获取服务器上您不应能够访问的信息。
- en: Confirm the data
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认数据
- en: When you are testing the API, make sure that the data you are expecting to receive
    is the data you are receiving. It is really easy to look at one or two samples
    and then extrapolate over the entire dataset that the information being returned
    is accurate.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当您测试API时，请确保您期望接收的数据就是您实际接收到的数据。查看一两个样本然后推断整个数据集返回的信息是准确的，这真的很简单。
- en: Ongoing testing
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续测试
- en: Just like data backups should be tested regularly to ensure that the data is
    recoverable, it is also important to continue testing your API regularly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如数据备份应该定期测试以确保数据可恢复一样，定期测试您的API也同样重要。
- en: 'As the environment that the API is running in changes, so can the performance
    of your API. Some environmental changes that could cause your API to begin behaving
    poorly include the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 随着API运行的环境的改变，您的API的性能也会改变。以下是一些可能导致您的API开始表现不佳的环境变化：
- en: A sudden increase in the number of users
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数量突然增加
- en: Increased database size
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库大小增加
- en: Larger and more frequent data requests
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更大且更频繁的数据请求
- en: A poorly designed proxy
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计不佳的代理
- en: Changes to the work schedules
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作时间表的变化
- en: By continually testing and upgrading the API, you can continue to ensure that
    the API performs as expected and continues to keep your clients happy.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续测试和升级API，您可以确保API按预期运行，并继续让您的客户满意。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed you how to plan out your API and build it in n8n
    using Webhooks. We also covered how to test and secure your API so that it functions
    properly when it is in production.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何规划您的API并在n8n中使用Webhooks构建它。我们还介绍了如何测试和确保您的API在生产中正常工作。
- en: While it may feel as though we have covered a lot about APIs, there are still
    considerable amounts for us to go through.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可能已经讨论了很多关于API的内容，但我们还有大量的内容需要探讨。
- en: One of the aspects of APIs that I did not go into very much detail about was
    manipulating the data that's sent and received by APIs in the workflows. If APIs
    are a language that computer systems use to communicate with each other, then
    the data manipulation that occurs inside an n8n workflow is the translation of
    that API language so that two or more different systems can communicate, even
    when they don't know each other's language.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有详细讨论的一个API方面是，在n8n工作流程中操作API发送和接收的数据。如果API是计算机系统之间用来相互通信的语言，那么在n8n工作流程中发生的数据操作就是将那种API语言翻译成，以便两个或更多不同的系统可以通信，即使它们不知道彼此的语言。
- en: We are going to be talking about this data manipulation in more depth in the
    next chapter as it is not just an important topic – it is a critical one.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更深入地讨论这种数据操作，因为它不仅是一个重要的主题，而且是一个关键的主题。
