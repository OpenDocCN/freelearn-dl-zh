- en: '*Chapter 5*: Building Your First API Endpoints'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication is at the core of all relationships. Good or bad relationships
    are often defined by how well two individuals can convey their thoughts, feelings,
    and ideas. Communication needs to be clear, accurate, and trusted.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing information appropriately is also critical for computer applications.
    Having a standard way of sending and receiving data between two different applications
    is critical for many programs.
  prefs: []
  type: TYPE_NORMAL
- en: One of these standards is referred to as an **API**, which stands for **application
    programming interface**. We are working specifically with the REST API architecture
    style. It was designed to quickly provide information and perform actions based
    on standard HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this well-known and understood standard, in this chapter, we will
    show you how to plan and build an API using n8n. We will help you plan your API
    by understanding the core concepts of APIs and thinking about what you want the
    final product to perform. You will also understand how to use n8n to build, secure,
    and test the API that you designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning your project's API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Webhook node to handle requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the API in n8n
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your API endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create blueprints for an API endpoint so that there's minimal friction when
    building the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the Webhook node so that it can handle requests that are sent to our
    API and reply to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an API endpoint in n8n based on the blueprints that we created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure your API endpoints by using the different authentication methods available
    in the Webhook node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your API to make sure that all the functionalities that we have implemented
    work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A working version of n8n.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to this book''s GitHub repository: [https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n).
    Another useful tool is the Insomnia API tool, which can be found at [https://insomnia.rest/](https://insomnia.rest/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning your project's API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start building out your API, you must have a solid roadmap. This
    plan allows you to create the API quicker and ensure the design is consistent
    and accurate.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different dimensions to consider when you are planning out
    your API. For an example of good API design, see the OpenAPI Specification at
    [https://swagger.io/specification/](https://swagger.io/specification/).
  prefs: []
  type: TYPE_NORMAL
- en: Easy to understand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How an API works should be almost obvious to a developer using it. The API should
    have terms that are consistent with similar APIs and adequately describe the information
    it is using and the action it is performing.
  prefs: []
  type: TYPE_NORMAL
- en: Output data in JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While several different data formats are available to use, such as XML, YAML,
    and SOAP, REST APIs most often output their data in JSON format. To maintain consistency,
    it is recommended that all of your APIs, at the very least, be able to output
    their data in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GET, HEAD, and POST HTTP methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'n8n supports three different HTTP methods (you can think of HTTP methods like
    action verbs that tell the system what to do with the request it has received):'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HEAD`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While several other HTTP methods are available, such as `UPDATE`, at the time
    of writing this book, n8n does not support them.
  prefs: []
  type: TYPE_NORMAL
- en: The two most commonly used HTTP methods are `GET` and `POST`, each of which
    provides a specific action.
  prefs: []
  type: TYPE_NORMAL
- en: The `GET` method is generally used when we're attempting to retrieve (or get)
    information from the API. It should not be used to pass sensitive information
    to the API. It is common for the query parameters to be passed along in a URL
    format that is human readable and often stored in web browser history.
  prefs: []
  type: TYPE_NORMAL
- en: However, the flip side of this method is that it is straightforward to create
    a website URL that specifies all the information being requested by the user in
    a simple link.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This assumes that no security has been applied to the API that needs to be passed
    in the headers.
  prefs: []
  type: TYPE_NORMAL
- en: The `POST` HTTP method is usually used to create or add a new record to the
    system providing the API. In n8n, it is also often used to change a record since
    there is no `UPDATE` HTTP method support.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using the `POST` HTTP method is that it does not show
    up in the URL when it is submitted to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about response codes, check out the *HTTP methods* subsection
    of the *HTTP Request node – talk to any API* section of [*Chapter 3*](B17493_03_Final_PD_ePub.xhtml#_idTextAnchor039)*,
    Diving into Core Nodes and Data in n8n*.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what your API will do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is critical to know precisely what your API is meant to do, not only in terms
    of the capabilities of the API but also inside the system. A simple API call can
    efficiently perform many different actions behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Plan out what each API call does in detail once the system receives the API
    request. This should be very detailed and documented exceptionally well.
  prefs: []
  type: TYPE_NORMAL
- en: Having meaningful and consistent response codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several different response codes can be used in response to an API call. Still,
    it is generally recommended that you limit yourself to the `2xx` and `4xx` codes
    since most other codes are handled by other systems, such as the web server (although
    we have an exception for this).
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, it is recommended that you use the following code for each stated
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200 (OK)`: All the data has been received, processed, and returned correctly.
    No further actions are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201 (Created)`: Often used with `POST` requests, this indicates that the request
    has resulted in creating a new resource and that the information for the resource
    has been returned in the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`202 (Accepted)`: When information is processed asynchronously, the system
    may have been received but is not yet active in the system, so the API could return
    a `202` code. This lets the requester know that the information made it to its
    destination, but that it cannot be accessed yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`203 (Non-Authoritative Information)`: If you are caching local data to reduce
    the number of calls to a remote data source, your API can respond with a `203`
    response code to let the user know that the information they received was accurate
    the last time it pulled a copy of the information, though this could have changed
    in the interim.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204 (No Content)`: Sometimes, a request for information is made to an API,
    but there is nothing to return to the user. For example, if an API references
    a list of animals (for example, cat, dog, and horse) and the user has requested
    a list of all reptiles, there would be no animals in the results. This is when
    the API would respond with a `204` response code so that the user knows that the
    API meant to send back no information and that there wasn''t some error returning
    no results from the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`206 (Partial Content)`: It is not uncommon for an API `GET` request to generate
    several thousands of records. Returning all of these records can be very taxing
    on both the server hosting the API and the client receiving the data. There can
    also be a considerable amount of bandwidth used when transmitting large amounts
    of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API only sends out a portion of the records (often referred to as pagination)
    to the requestor to alleviate this issue. It includes a `206` response code to
    let us know that there is more information to be received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400 (Bad Request)`: It is straightforward to miswrite an API request, and
    it is important to let the requester know that they made a mistake. For example,
    if a requester was searching for a user by email address but asked the system
    to look for the information in the first name field, then a `400` response would
    be warranted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401 (Unauthorized)`: You should secure your API with some sort of authentication
    scheme. When someone provides the wrong authentication information, a `401` response
    code should be generated and returned to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403 (Forbidden)`: Sometimes, people attempt to access information that they
    shouldn''t, regardless of whether or not they are properly authenticated to the
    system. In this instance, a `403` response code would be returned to the user.
    I often use this response code when I have my API set up to only be accessed from
    a specific IP address and the IP addresses do not match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404` (`Not Found`): It is not uncommon for users to accidentally enter the
    wrong information for a URL or for a resource to move. When that happens, the
    user making the request will automatically get a 404 error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information about response codes, see the *Response codes* section
    of [*Chapter 3*](B17493_03_Final_PD_ePub.xhtml#_idTextAnchor039), *Diving into
    Core Nodes and Data in n8n*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consistent noun/verb design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One very common way of laying out an API is by using a **noun/verb** architecture.
    The idea behind this design is that the requestor starts with an object or item
    that is directly followed by an action to be performed in that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we were to create an API that would change the name of a device
    in its database, the request path may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if we were to remove that device from the database, the API call
    path might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Submitting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several different ways to submit data to an API. It is entirely up
    to you how you want your users to send information to your API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Body**: The body of the API request is a common place to place information.
    This is most often used in POST HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/record/237/delete` to accomplish this task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` HTTP method as it is used to ask for specific information. A query is
    often represented by a URL and is even displayed that way. For example, if you
    were to request record 237 from the system using a query, the URL path may look
    something like [`https://api.example.com/record/display?recordID=237`](https://api.example.com/record/display?recordID=237).
    The `?` character separates the API path and the query. `recordID` is the data
    key to be searched for, while `237` is the value of the key the system is looking
    for. You can also have multiple key/value pairs in a query by concatenating the
    queries together with a `&` character; for example, `recordID=237&fname=Tim`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header**: You can also send information as a part of the headers in the request.
    This is often done when you''re sending authentication information such as an
    API token to the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning your API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not uncommon that, as your system changes and matures, you may want to
    make changes to your API. The problem with modifying how your API works is that
    the changes can suddenly make a large number of user programs and scripts fail.
    This quickly leads to several upset and disgruntled customers.
  prefs: []
  type: TYPE_NORMAL
- en: One easy way around this is to create multiple versions of your API. This way,
    people can continue to use their scripts with previous versions of the API while
    new users can automatically move to the new version.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is an issue with creating multiple versions of your API. As the
    number of versions grows, so does the effort required to maintain the system and
    all of its versions.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this ever-growing effort, it is recommended that you maintain no more
    than two versions of an API at any given time. When a new version of the API is
    released, clearly communicate to the users that the previous version has been
    replaced and that the old version will be decommissioned in a reasonable amount
    of time ("**reasonable**" depends on the audience, where it could be a couple
    of weeks, or several years).
  prefs: []
  type: TYPE_NORMAL
- en: Documenting your API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important parts of the design process is documenting the API
    so that others can use it properly. This can also help you figure out what you
    did when you come to troubleshoot it 2 years later.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI Specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the more common forms of documentation is the OpenAPI Specification ([https://github.com/OAI/OpenAPI-Specification](https://github.com/OAI/OpenAPI-Specification)).
    This specification only takes a couple of hours to learn and can be used in conjunction
    with other tools to automatically create an API testing platform and all user
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The specification uses either a JSON or YAML file to outline how your API behaves
    and how to create the documentation for the specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple JSON OpenAPI Specification file''s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is only a small piece of the API that we are going to be building in the
    next few sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the documentation that is generated from this
    specification file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Generated documentation from the OpenAPI Specification file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Generated documentation from the OpenAPI Specification file
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a full API definition for this, which you can find here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/tree/main/Chapter%205](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/tree/main/Chapter%205)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to design APIs, it is time to dive into n8n and start the
    basic setup for creating our API.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Webhook node to handle requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core node for building an API in n8n is the Webhook node. While this may
    seem a bit strange on the surface, it makes a lot of sense when you start to think
    of it in the correct frame of mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webhooks are web services that are sitting on a system, waiting to be called
    upon to perform some action. Meanwhile, an API is a service that a client uses
    to perform actions on a remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The Webhook node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The Webhook node
  prefs: []
  type: TYPE_NORMAL
- en: So, what is seen as an API from the client's perspective is the same as a Webhook
    from the server's perspective! And this is why we use a Webhook to create an API.
  prefs: []
  type: TYPE_NORMAL
- en: The Webhook node is a trigger node that executes a workflow when it receives
    a remote connection. It collects the information that it receives and performs
    actions based on that information.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Webhook node is configured by setting the parameters in the node itself.
    Each of these parameters modifies the behavior of the Webhook and some parameters,
    such as the **Authentication** and **HTTP Method** parameters, enable even more
    options for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Webhook URLs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you click on the text in the Webhook node that reads **Webhook URLs**, it
    will open up a small panel below it. You will see two buttons, one reading **Production**
    and the other reading **Test**. These are the two different types of Webhook URLs
    that are available to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'These URLs in n8n cloud are built by combining the n8n protocol (`https://`),
    the hostname (`tephlon.app.n8n.cloud/`), the Webhook root (`webhook` for production
    and `webhook-test` for test), and the Webhook path (`f929fdc9-b62a-4661-913e-b5648c407edd`).
    This creates the two Webhook paths of `https://tephlon.app.n8n.cloud/webhook/f929fdc9-b62a-4661-913e-b5648c407edd`
    for **Production** and [https://tephlon.app.n8n.cloud/webhook-test/f929fdc9-b62a-4661-913e-b5648c407edd](https://tephlon.app.n8n.cloud/webhook-test/f929fdc9-b62a-4661-913e-b5648c407edd)
    for **Test**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Initial Webhook properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Initial Webhook properties
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify the Webhook''s endpoint locations by changing the `f929fdc9-b62a-4661-913e-b5648c407edd`
    to `api/v1/user/add`, then the Webhook paths would change to [`https://tephlon.app.n8n.cloud/webhook/api/v1/user`](https://tephlon.app.n8n.cloud/webhook/api/v1/user)
    for `https://tephlon.app.n8n.cloud/webhook-test/api/v1/user/add` for **Test**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Changing the Webhook paths'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Changing the Webhook paths
  prefs: []
  type: TYPE_NORMAL
- en: The two different types of Webhook URLs – **Production** and **Test** – serve
    two different purposes. The **Production** URL is used when your workflow has
    been saved and set to **Active**. The Webhook will then respond even when the
    Editor UI is not open. It is designed to be available and work completely on its
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Test** URL is designed to be used when you are building and troubleshooting
    your API. It still requires that your workflow be saved to register the Webhook
    URL but it will only be active when one of the following conditions has been met:'
  prefs: []
  type: TYPE_NORMAL
- en: You press the **Execute Workflow** button in the Editor UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You press the **Execute Node** button in an open node that is either the Webhook
    node or a child node to the Webhook node with no cached information available
    to be processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Test** URL is available until one of the following actions occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: A connection attempt is made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Stop** button is pressed in the Editor UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 120 seconds have passed since the Webhook was initiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this happens, the Webhook URL will unregister and the workflow will stop.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the **Test** URL is to provide an easy way to see what is happening
    in each node when a request is made and troubleshoot the workflow for development.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since APIs are a very common way for people to programmatically access pure
    data from a system, there is a good chance that you may want to secure that data.
    Even if your API is going to be publicly available to everyone, it can be a good
    idea to set up registration and authentication for your API so that you can track
    who is using (or abusing) your API.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many different aspects of securing your API (many of which will
    be covered a bit later in this chapter), we want to take a quick look at authentication
    for your API. This can be accomplished using the **Authentication** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Authentication parameter has three different options:'
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Auth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header Auth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selecting **None** for the **Authentication** parameter is self-explanatory:
    the Webhook will not look for any form of authentication before executing the
    workflow or returning information. While there are valid use cases for not using
    any authentication for your API (for example, you want to use the Webhook like
    a web server and display web content), it is generally frowned upon as a practice.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Auth** is the simplest form of authentication that n8n can use. It
    essentially sends a Base64 calculated version of a username and a password to
    n8n and compares it to the password information that it has on record.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we were to use Basic Auth for our API and the username and password
    required are `jim.nasium` and `123456`, the API client would calculate the Base64
    version of `jim.nasium:123456` (which is `amltLm5hc2l1bToxMjM0NTY=`) and send
    it in the header request.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Base64 Value
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever find yourself in need of generating the Base64 value for a `Function`
    node, you can use the following code to do this for you. Simply replace the values
    of the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var username = "jim.nasium";`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var password = "123456";`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var encoded = Buffer.from(username + ":" + password).toString(''base64'');`'
  prefs: []
  type: TYPE_NORMAL
- en: While this is better than no authentication at all, it isn't all that great.
    Since Base64-encoded text is really easy to reverse engineer, it is recommended
    that the API is secured properly by complimentary means such as SSL/TLS certificates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Header Auth** is similar to **Basic Auth** in that it sends a value in the
    header of the API request. However, the difference is that it is just a random
    string of characters that is very difficult to memorize.'
  prefs: []
  type: TYPE_NORMAL
- en: In both the **Basic** and **Header Auth** scenarios, you are required to create
    credentials that hold the information that's required for users to access the
    API. Without these credentials, you users will not be able to use the API.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned earlier in this chapter, the n8n Webhook node supports three
    different HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the HTTP method that you select, different options become available
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: General options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Four options are available for all the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Response Content-Type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw Body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`") character.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your API is returning JSON data, you would set `text/json`.
  prefs: []
  type: TYPE_NORMAL
- en: For an official list of all the media types that are available, visit the **Internet
    Assigned Numbers Authority** (**IANA**) *Media Types* web page at [https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The **Response Headers** option allows you to add additional key/value pairs
    to the headers to provide extra metadata to the response. This is information
    about the data that the user is receiving from the API.
  prefs: []
  type: TYPE_NORMAL
- en: It is often used to confirm that the data is accurate and has not been tampered
    with between the sender and the receiver. It could contain a hash algorithm that
    the receiver could calculate to determine that the information is accurate or
    a timestamp to indicate when the information was received.
  prefs: []
  type: TYPE_NORMAL
- en: The **Property Name** option allows you to return just the value of a specific
    value/key pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume that you have a Webhook set up that outputs the
    following JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to modify that Webhook and add the **Property Name** option
    with a value of **status**, our output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is useful if you have HTML in a key-value pair and you just want to output
    the HTML to display a web page.
  prefs: []
  type: TYPE_NORMAL
- en: The final option is **Raw Body**. The **Raw Body** option is a binary (off or
    on) value that indicates the information coming into the Webhook is in a raw format,
    such as XML or JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Additional POST option
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you select **Post** for the HTTP method, there is one extra option available.
    This is the **Binary Data** option. This option is used to indicate that the API
    is expecting that there will be binary data attached to the request. This is handy
    when you are uploading files to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Response Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Response Code** parameter is used to reply to the sender with a quick
    response, letting the requester know the results of their request.
  prefs: []
  type: TYPE_NORMAL
- en: We went through response codes in detail earlier in this chapter, so I'm not
    going to go over them again, but make sure that you reference the code and reply
    with the appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The response code that you are selecting is going to be sent when everything
    goes well. Other failure response codes (for example, `404`) will be sent by the
    system and do not need to be programmed here.
  prefs: []
  type: TYPE_NORMAL
- en: Response Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Response Mode** option controls how the Webhook responds to the request.
    Two options can be set for the Response Mode option:'
  prefs: []
  type: TYPE_NORMAL
- en: On Received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last Node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, if you are not passing data back to the requester, you will want
    to use the **On Received** option. Otherwise, if you are sending information back
    via the API, you should use the **Last Node** option.
  prefs: []
  type: TYPE_NORMAL
- en: The **On Received** option will immediately send the value of the **Response
    Code** option back to the sender. It does not wait for the workflow to complete
    before returning this code.
  prefs: []
  type: TYPE_NORMAL
- en: Things get a little bit more interesting with the **Last Node** option. When
    you want to return information to the requester, this option will initiate a workflow
    and then the results (or part of the results) of the last executed node will be
    returned to the requester as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Response Data options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you select the **Last Node** option for **Response Mode**, this enables
    a new parameter called **Response Data**. The three options for **Response Data**
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All Entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First Entry JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First Entry Binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how this option works, we will look at an example. Let''s assume
    that we have a workflow with the final node outputting the following JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Also, for each JSON object in the array, there is a binary file attached to
    the object; `CV - Jim Nasium.pdf` for the first one and `Resume - Kris P. Bayken.pdf`
    for the second one.
  prefs: []
  type: TYPE_NORMAL
- en: If we set the **Response Data** parameter to **All Entries**, the requester
    will receive the entire array contents but none of the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we change **Response Data** to **First Entry JSON**, the receiver will
    receive the following JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if we use the `CV - Jim Nasium.pdf` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through the Webhook node in great detail, it is time to
    start building out our API in n8n.
  prefs: []
  type: TYPE_NORMAL
- en: Building the API in n8n
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are finally ready to start building in n8n! Let's start by outlining our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: API project specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our project, we are going to build a simple user management API that will
    modify the user information in an Airtable database. Most of the workflow that
    we will be building isn't important to the API itself. All we have to be aware
    of is the result of each API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our API is going to have five endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /api/v1/user/add`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/v1/user/list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/v1/user/search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/v1/user/delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/v1/user/changepw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base URL for our API will be [https://tephlon.app.n8n.cloud/webhook](https://tephlon.app.n8n.cloud/webhook)
    since that is the Webhook URL for my n8n cloud instance.
  prefs: []
  type: TYPE_NORMAL
- en: Our API will also use header authentication with a bearer token value of `675tryfhgui89765tyrfghjui89765uyr4thfgjuio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Airtable database will store the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First Name**: The user''s first name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last Name**: The user''s last name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Email**: The user''s email address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password Hash**: A calculated value representing the user''s password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reason that we do not store the user's password is for security. If the
    data table were to become compromised, the user's password would be out in the
    wild. By storing a calculated value based on the user's password, the same calculation
    can be performed each time the password is supplied to n8n, and the calculated
    value is compared to the stored value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step will be to create the header authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: In the n8n Editor UI, click on the "^" icon and click on **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, select **Header Auth** for **Credential type**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Header Authentication`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Auth`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Bearer 675tryfhgui89765tyrfghjui89765uyr4thfgjuio`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Webhook`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final credentials form should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Header Auth credentials'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Header Auth credentials
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create** button to complete this process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s create the Webhooks in n8n:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create five new Webhook nodes and name them like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Add`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Search`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delete`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChangePW`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure each of the Webhooks based on the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Table_5.1_B17493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That should complete the initial Webhook creation. Make sure to save and activate
    the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the rest of the workflow is important for generating the proper outcomes
    for the API, it has very little to do with the API itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the whole workflow here: [https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/blob/main/Chapter%205/User_Management_API.json](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n/blob/main/Chapter%205/User_Management_API.json).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built the API in n8n, let's look at how to add further security
    to your API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we talked about using Webhook authorization to help
    secure your API. This is an important first step but that does not mean that your
    API is secure. There are several extra actions that you can take to secure your
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Using SSL/TLS security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSL and its younger brother, TLS, are common security standards on the internet.
    Any time you see `https` in front of a website address, this means that one of
    these systems is at work.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of SSL/TLS is to encrypt the communication between the client software
    (for example, the web browser, n8n, and API client) and the web server that is
    hosting the API. This way, if someone were to set themselves up between you and
    the API server, all they would get is jibberish instead of the API tokens and
    passwords that are used to access that information.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting where users come from
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of reducing the probability of being taken down by a malicious actor
    is to limit who can access your API based on where they are coming from. For example,
    if all your clients who use your API are from Germany, then there is no point
    in allowing people from Canada to access the API.
  prefs: []
  type: TYPE_NORMAL
- en: While this is not a perfect solution, since it is relatively easy to get around
    by using a VPN, this means that people who are out to cause trouble need to jump
    through yet another hoop.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to take this option to the next level, you can even limit access
    to a single IP address so that only people from a specific office can use your
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying your API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Putting your API behind a proxy is one of the smartest things that you can
    do. Here are some of the benefits of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: It prevents people from directly accessing your API server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It hides other potentially dangerous open ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can reduce calls to your API and other tools by caching requests and returning
    results without having to talk to the API server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can distribute requests across several servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of these advantages from the proxy, it is well worth looking into setting
    up a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating security tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With security breaches happening daily, it is well worth changing the API tokens
    regularly as well. There are several different ways to do this but you need to
    find a way that works for you.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to do this is to have a token expire after a certain period.
    At that point, the user would be required to get a new token. This can be automated
    so that as soon as the token times out, the system knows to reach out and request
    a new one.
  prefs: []
  type: TYPE_NORMAL
- en: This way, even if your token were to get out and someone on the internet were
    to start using it, they would only have access for a short period before the token
    would expire and then require a new token to be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking and limiting the number of requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to record every single connection attempt that occurs on your
    API server. This provides you with two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You can identify if there is any strange behavior occurring on your API server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can prevent one person or organization from abusing the API server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users (as identified by their token) and organizations (as identified by their
    IP address) should have the number of calls they make throttled to a reasonable
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: Providing metadata in your API responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Embedding useful metadata in the information that you provide to your users
    is a great way to allow the end user to verify the information that they are receiving
    is accurate. Some examples of good metadata are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing an **MD5** sum value when downloading a file for the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicating the record count being returned from a query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a GeoIP lookup of the city the user is coming from so that they can
    confirm the request is legitimate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning the length of the results in a certain number of characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once your API is secure, it is time to start testing its robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a testing plan for your API is an important part of the design and
    rollout process. If you do not test your API properly, there is no telling what
    results your clients will get.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its importance, let's look at some recommendations for API testing.
  prefs: []
  type: TYPE_NORMAL
- en: Use a testing platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you may be able to manually test some small or simple APIs, the bigger
    they become, the harder they are to test. Not only does this allow you to do more
    for testing, but it also allows you to easily retest after you make changes, knowing
    that the test is the same as it was the previous time.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a testing platform, you can easily create several testing
    scripts using the cURL command-line tool or use something such as the documentation
    and testing tool built into Insomnia (`https://insomnia.rest`).
  prefs: []
  type: TYPE_NORMAL
- en: Follow the documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation that you have created or been provided with is very important.
    Make sure you can do everything that the documentation says that it can do and
    none of the things that it doesn't say you can do.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to do absolutely everything that is in the documentation
    without fail.
  prefs: []
  type: TYPE_NORMAL
- en: Try to break it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the part of the testing process that you can have a lot of fun with.
    Here are some ideas I''ve had success with in the past:'
  prefs: []
  type: TYPE_NORMAL
- en: Send information in different character sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter SQL commands as usernames or passwords and see if the commands execute
    on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overload the server by making thousands of calls per second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to get access to the information you shouldn't be able to on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are testing the API, make sure that the data you are expecting to receive
    is the data you are receiving. It is really easy to look at one or two samples
    and then extrapolate over the entire dataset that the information being returned
    is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Ongoing testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like data backups should be tested regularly to ensure that the data is
    recoverable, it is also important to continue testing your API regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the environment that the API is running in changes, so can the performance
    of your API. Some environmental changes that could cause your API to begin behaving
    poorly include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A sudden increase in the number of users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased database size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Larger and more frequent data requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A poorly designed proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to the work schedules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By continually testing and upgrading the API, you can continue to ensure that
    the API performs as expected and continues to keep your clients happy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to plan out your API and build it in n8n
    using Webhooks. We also covered how to test and secure your API so that it functions
    properly when it is in production.
  prefs: []
  type: TYPE_NORMAL
- en: While it may feel as though we have covered a lot about APIs, there are still
    considerable amounts for us to go through.
  prefs: []
  type: TYPE_NORMAL
- en: One of the aspects of APIs that I did not go into very much detail about was
    manipulating the data that's sent and received by APIs in the workflows. If APIs
    are a language that computer systems use to communicate with each other, then
    the data manipulation that occurs inside an n8n workflow is the translation of
    that API language so that two or more different systems can communicate, even
    when they don't know each other's language.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be talking about this data manipulation in more depth in the
    next chapter as it is not just an important topic – it is a critical one.
  prefs: []
  type: TYPE_NORMAL
