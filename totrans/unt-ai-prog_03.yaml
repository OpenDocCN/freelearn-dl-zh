- en: '*Chapter 2*: Finite State Machines'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to implement a **Finite State Machine** (**FSM**)
    in a Unity3D game by studying the simple tank game-mechanic example that comes
    with this book.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, the player controls a tank. The enemy tanks move around the scene,
    following four waypoints. Once the player's tank enters the vision range of the
    enemy tanks, they start chasing it; then, once they are close enough to attack,
    they'll start shooting at our player's tank.
  prefs: []
  type: TYPE_NORMAL
- en: To control the AI of our enemy tanks, we use an FSM. First, we'll use simple
    `switch` statements to implement our tank AI states. Then, we'll use a more complex
    and engineered FSM framework that will allow us greater flexibility in designing
    the character's FSM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will be covering in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the player's tank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a bullet class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up waypoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the abstract FSM class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a simple FSM for the enemy tank AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an FSM framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 2` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the player's tank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before writing the script for our player's tank, let's look at how we set up
    the `Rigidbody` and `Box Collider` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `controller` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Our tank entity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Our tank entity
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerTankController` class controls the player's tank. We use the *W*,
    *A*, *S*, and *D* keys to move and steer the tank and the left mouse button to
    aim and shoot from the **Turret** object.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we assume that you are using a *QWERTY* keyboard and a two-button
    mouse, with the left mouse button set as the primary mouse button. If you are
    using a different keyboard, all you have to do is pretend that you are using a
    *QWERTY* keyboard or try to modify the code to adapt it to your keyboard layout.
    It is pretty easy!
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Tank object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start creating the `PlayerTankController` class by setting up the `Start`
    function and the `Update` function in the `PlayerTankController.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the hierarchy that the **PlayerTank** game object has one child
    called **Turret**, and in turn, the first child of the **Turret** object is called
    **SpawnPoint**. To set up the controller, we need to link (by dragging and dropping)
    **Turret** and **SpawnPoint** into the corresponding fields in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Player Tank Controller component in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – The Player Tank Controller component in the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: Later, after creating the `Bullet` variable using the Inspector. Then, finally,
    the `Update` function calls the `UpdateControl` and `UpdateWeapon` functions.
    We will discuss the content of these functions in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting the bullet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mechanism for shooting the bullet is simple. Whenever the player clicks
    the left mouse button, we check whether the total elapsed time since the last
    fire is greater than the weapon's fire rate. If it is, then we create a new `bulletSpawnPoint`
    transform's position. This check prevents the player from shooting a continuous
    stream of bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we add the following function to the `PlayerTankController.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can attach this controller script to the **PlayerTank** object. If we
    run the game, we should be able to shoot from our tanks. Now, it is time to implement
    the tank's movement controls.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the tank
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The player can rotate the `UpdateControl` function to the `PlayerTankController.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We use raycasting to determine the turning direction by finding the `mousePosition`
    coordinates on the battlefield:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Raycast to aim with the mouse'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Raycast to aim with the mouse
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: '**Raycasting** is a tool provided by default in the Unity physics engine. It
    allows us to find the intersection point between an imaginary line (the *ray*)
    and a collider in the scene. Imagine this as a laser pointer: we can fire our
    laser in a direction and see the point where it hits. However, this is a relatively
    expensive operation. While, in general, you can confidently handle 100–200 raycasts
    per frame, their performance is greatly affected by the length of the ray and
    the number and types of colliders in the scene. So, as a quick tip, try not to
    use a lot of raycasts with mesh colliders and use layer masks to filter out unnecessary
    colliders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a plane that intersects with the player tank with an upward normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shoot a ray from screen space with the mouse position (in the preceding diagram,
    we assume that we're looking down at the tank).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the point where the ray intersects the plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, find the rotation from the current position to that intersection point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we check for the key-pressed input and move or rotate the tank accordingly.
    We add the following code at the end of the `UpdateControl` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code represents the classic *WASD* control scheme. The tank rotates
    with the *A* and *D* keys, and moves forward and backward with *W* and *S*.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your level of Unity expertise, you may wonder what about the `Lerp`
    and `Time.deltaTime` multiplications. It may be worth a slight digression. First,
    `Lerp` function to smoothly spread the velocity changes over multiple frames so
    that the tank's movement doesn't look like it's accelerating and decelerating
    instantaneously. The `7.0f` value is just a *smoothing factor*, and you can play
    with it to find your favorite value (the bigger the value, the greater the tank's
    acceleration).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we multiply everything by `Time.deltaTime`. This value represents the
    time in seconds between now and the last frame, and we use it to make our velocity
    independent from the frame rate. For more info, refer to [https://learn.unity.com/tutorial/delta-time](https://learn.unity.com/tutorial/delta-time).
  prefs: []
  type: TYPE_NORMAL
- en: Next, it is time to implement the projectiles fired by the player and enemy
    tanks.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Bullet class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we set up our **Bullet** prefab with two orthogonal planes and a box
    collider, using a laser-like material and a **Particles/Additive-Layer** property
    in the **Shader** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Our Bullet prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Our Bullet prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the `Bullet.cs` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bullet` class has three properties: `damage`, `Speed`, and `Lifetime`
    – the latter so that the bullet is automatically destroyed after a certain amount
    of time. Note that we use `[SerializeField]` to show the private fields in the
    Inspector; by default, in fact, Unity only shows public fields. It is a good practice
    to set fields that we need to access from other classes as public-only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `Explosion` property of the bullet is linked to the `ParticleExplosion`
    prefab, which we''re not going to discuss in detail. This prefab is in the `ParticleEffects`
    folder, so we drop it into the `OnCollisionEnter` method. The `ParticleExplosion`
    prefab uses the `AutoDestruct` script to automatically destroy the `Explosion`
    object after a small amount of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `AutoDestruct` script is small but convenient. It just destroys the attached
    object after a certain number of seconds. Many Unity games use a similar script
    almost every time for many situations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a tank that can fire and move, we can set up a simple patrolling
    path for the enemy tanks.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up waypoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the enemy tanks will patrol the game arena. To implement this behavior,
    we need to specify first the patrolling path. We will explore path following thoroughly
    in [*Chapter 6*](B17984_06_Epub.xhtml#_idTextAnchor375), *Path Following and Steering
    Behaviors*. For now, we limit ourselves to a simple *waypoints path*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement it, we put four `WanderPoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – WanderPoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – WanderPoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what our **WanderPoint** objects look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The WanderPoint properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – The WanderPoint properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we need to tag these points with a tag called **WanderPoint**. Later,
    we will use this tag when we try to find the waypoints from our tank AI. As you
    can see in its properties, a waypoint is just a **Cube** game object with the
    **Mesh Renderer** checkbox disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The gizmo selection panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – The gizmo selection panel
  prefs: []
  type: TYPE_NORMAL
- en: To show these points in the editor (but not in the game), we use an empty object
    with a gizmo icon, since all we need from a waypoint is its position and the transformation
    data. To do that, click the small triangle near the object icon in the Inspector,
    as shown in *Figure 2.7*.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to give life to the enemy tanks with the power of the FSM.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the abstract FSM class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we implement a generic abstract class to define the enemy tank AI class's
    methods. This abstract class will be the skeleton of our AI and represent a high-level
    view of what an enemy tank should do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the code of this class in the `FSM.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The enemy tanks need only to know the position of the player's tank, their next
    destination point, and the list of waypoints to choose from while they're patrolling.
    Once the player tank is in range, they rotate their turret object and start shooting
    from the bullet spawn point at their fire rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we explained before, we will extend this class in two ways: using a simple
    *if-then-else*-based FSM (the `SimpleFSM` class) and a more engineered but more
    flexible FSM (`AdvancedFSM`). These two FSM implementations will inherit the `FSM`
    abstract class, and they will implement the three abstract methods: `Initialize`,
    `FSMUpdate`, and `FSMFixedUpdate`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see the two different ways to implement these three methods in the next
    sections. For now, let's start with the basic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Using a simple FSM for the enemy tank AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the actual code for our AI tanks. First, let's create a new class,
    called `SimpleFSM`, which inherits from our FSM abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code in the `SimpleFSM.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare a few variables. Our tank AI has four different states: **Patrol**,
    **Chase**, **Attack**, and **Dead**. We are implementing the FSM that we described
    as an example in [*Chapter 1*](B17984_01_Epub.xhtml#_idTextAnchor015), *Introduction
    to AI*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The enemy tank AI''s FSM'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – The enemy tank AI's FSM
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Initialize` method, we set up our AI tank''s properties with default
    values. Then, we store the positions of waypoints in our local variable. We get
    those waypoints from our scene using the `FindGameObjectsWithTag` method, trying
    to find those objects with the **WandarPoint** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Update` method that gets called every frame looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We check the current state and then call the appropriate state method. Once
    the health object has a value of zero or less, we set the tank to the `Dead` state.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Private Variables
  prefs: []
  type: TYPE_NORMAL
- en: 'A public variable in the Inspector is not only useful because we can quickly
    experiment with different values but also because we can quickly look at a glance
    at their value when debugging. For this reason, you may even be tempted to make
    public (or expose to the Inspector) variables that should not be changed by the
    component''s user. Don''t worry – there is a solution: you can show the Inspector
    in **Debug** mode. In **Debug** mode, the Inspector also shows private fields.
    To enable Debug mode, click on the three dots at the top right and then click
    on **Debug**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Unity''s Inspector in Debug mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Unity's Inspector in Debug mode
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to implement each state one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The Patrol state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Patrol** state is the state in which the tank moves from waypoint to
    waypoint, looking for the player. The **Patrol** state''s code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While our tank is in the `FindNextPoint` method. This method simply chooses
    a random point from among the waypoints we defined before.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the tank has not reached its destination point, it checks
    the distance to the player's tank. If the player's tank is in range (which, in
    this example, we choose to be `300` units), the AI switches to the `UpdatePatrolState`
    function to rotate the tank and move it toward the next waypoint.
  prefs: []
  type: TYPE_NORMAL
- en: The Chase state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the **Chase** state, the tank actively tries to get near the player''s tank.
    In simple terms, the destination point becomes the player''s tank itself. The
    **Chase** state implementation code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this state, we first set the destination point as the player. Then, we continue
    checking the player's distance from the tank. If the player is close enough, the
    AI switches to the **Attack** state. On the other hand, if the player's tank manages
    to escape and goes too far, the AI goes back to the **Patrol** state.
  prefs: []
  type: TYPE_NORMAL
- en: The Attack state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Attack** state is precisely what you expect: the enemy tank aims and
    shoots at the player. The following code block is the implementation code for
    the **Attack** state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we still set the destination point to the player's position.
    After all, even when attacking, we need to keep a close distance from the player.
    Then, if the player tank is close enough, the AI tank rotates the `turret` object
    in the direction of the player tank and then starts shooting. Finally, if the
    player's tank goes out of range, the tank goes back to the **Patrol** state.
  prefs: []
  type: TYPE_NORMAL
- en: The Dead state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Dead** state is the final state. Once a tank is in the **Dead** state,
    it explodes and gets uninstantiated. The following is the code for the **Dead**
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code is straightforward – if the tank has reached the **Dead**
    state, we make it explode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here's a small function that gives a nice explosion effect. We apply a random
    `ExplosionForce` function to the tank's `Rigidbody` component. If everything is
    correct, you should see the tank flying in the air in a random direction for the
    player's amusement.
  prefs: []
  type: TYPE_NORMAL
- en: Taking damage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete the demo, we need to add another small detail: we need the tanks
    to take damage when they get hit by a bullet. Every time a bullet enters the collision
    area of the tank, the `health` property''s value decreases, according to the `Bullet`
    object''s `damage` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can open the `SimpleFSM.scene` file in Unity; you should see the AI tanks
    patrolling, chasing, and attacking the player. Our player's tank doesn't take
    damage from AI tanks yet, so it never gets destroyed. But the AI tanks have the
    health property and take damage from the player's bullets, so you'll see them
    explode once their health property reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your demo doesn''t work, try playing with different values in the Inspector
    for the **SimpleFSM** components. After all, the values may change, depending
    on the scale of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – The AI tanks in action'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – The AI tanks in action
  prefs: []
  type: TYPE_NORMAL
- en: In this demo, we used a very simple FSM, but now it's time to step up the challenge
    and implement a complete FSM framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using an FSM framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FSM framework we're going to use here is adapted from the `Chapter02` folder
    of the book repository ([https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition)).
    In particular, we will look at the **AdvancedFSM** scene.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will study how the framework works and how we can use this
    to implement our tank AI. `AdvancedFSM` and `FSMState` are the two main classes
    of our framework. So, let's take a look at them first.
  prefs: []
  type: TYPE_NORMAL
- en: The AdvancedFSM class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AdvancedFSM` class manages all the `FSMState` classes we've implemented
    and keeps them updated with the transitions and the current state. So, the first
    thing to do before using our framework is to declare the transitions and states
    that we plan to implement for our AI tanks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating `AdvancedFSM.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define two enumerations, one for the set of states and one for the
    set of transitions. Then, we add a list object to store the `FSMState` objects
    and two local variables to store the current ID of the `FSMState` class and the
    current `FSMState` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddFSMState` and `DeleteState` methods add and delete the instances of
    the `FSMState` class in our list respectively. When the `PerformTransition` method
    gets called, it updates the `CurrentState` variable with the new state, according
    to the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that the data part of the class is ready, we can proceed with the internal
    logic of the FSM framework.
  prefs: []
  type: TYPE_NORMAL
- en: The FSMState class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`FSMState` manages the transitions to other states. It has a dictionary object
    called `map` in which we store the key-value pairs of transitions and states.
    So, for example, the `SawPlayer` transition maps to the `Chasing` state, `LostPlayer`
    maps to the `Patrolling` state, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `FSMState.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `AddTransition` and `DeleteTransition` methods add and delete transitions
    from their state-transition dictionary `map` object. The `GetOutputState` method
    looks up from the `map` object and returns the state based on the input transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FSMState` class also declares two abstract methods that its child classes
    need to implement. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `CheckTransitionRules` method has to check whether the state should carry
    out the transition to another state. Instead, the `RunState` method does the actual
    execution of the tasks for the `currentState` variable, such as moving toward
    a destination point and chasing or attacking the player. Both methods require
    transformed data from the player and the **Non Playable Character** (**NPC**)
    entity obtained using this class.
  prefs: []
  type: TYPE_NORMAL
- en: The state classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the previous `SimpleFSM` example, we write the states for our tank AI
    in separate classes that inherit from the `FSMState` class, such as `AttackState`,
    `ChaseState`, `DeadState`, and `PatrolState`. All of them implement the `CheckTransitionRules`
    and `RunState` methods. Let's take a look at the `PatrolState` class as an example.
  prefs: []
  type: TYPE_NORMAL
- en: The PatrolState class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class has three methods: a constructor, `CheckTransitionRules`, and `RunState`.
    Let''s create the `PatrolState` class in the `PatrolState.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `constructor` method takes the `waypoints` array, stores them in a local
    array, and then initializes properties such as movement and rotation speed. The
    `Reason` method checks the distance between itself (the AI tank) and the player
    tank. If the player tank is in range, it sets the transition ID to the `SawPlayer`
    transition using the `SetTransition` method of the `NPCTankController` class,
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function is just a wrapper method that calls the `PerformTransition`
    method of the `AdvanceFSM` class. In turn, that method updates the `CurrentState`
    variable with the one responsible for this transition, using the `Transition`
    object and the state-transition dictionary map object from the `FSMState` class.
    The `Act` method updates the AI tank's destination point, rotates the tank in
    that direction, and moves it forward.
  prefs: []
  type: TYPE_NORMAL
- en: Other state classes also follow this template with different reasoning and acting
    procedures. We've already seen them in our previous simple FSM examples, and therefore,
    we won't describe them again here. See whether you can figure out how to set up
    these classes on your own. If you get stuck, the assets that come with this book
    contain the code for you to look at.
  prefs: []
  type: TYPE_NORMAL
- en: The NPCTankController class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the tank AI, we set up the states for our NPC by using the `NPCTankController`
    class. This class inherits from `AdvanceFSM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the beauty of using our FSM framework: since the states are self-managed
    within their respective classes, our `NPCTankController` class only needs to call
    the `Reason` and `Act` methods of the currently active state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This fact eliminates the need to write a long list of the `if`/`else` and `switch`
    statements. Instead, our states are now nicely packaged in classes of their own,
    which makes the code more manageable, as the number of states and transitions
    between them grows more and more in larger projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The main steps to use this framework can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the transitions and states in the `AdvanceFSM` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the state classes inherited from the `FSMState` class, and then implement
    the `Reason` and `Act` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the custom NPC AI class inherited from `AdvanceFSM`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create states from the state classes, and then add transition and state pairs
    using the `AddTransition` method of the `FSMState` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add those states into the state list of the `AdvanceFSM` class, using the `AddFSMState`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `CurrentState` variable's `Reason` and `Act` methods in the game update
    cycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can play around with the `AdvancedFSM` scene in Unity. It'll run the same
    way as our previous `SimpleFSM` example, but the code is now more organized and
    manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement state machines in Unity3D based
    on a simple tank game. We first looked at how to implement FSM by using `switch`
    statements. Then, we studied how to use a framework to make AI implementation
    easier to manage and extend.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at randomness and probability and see how
    we can use them to make the outcome of our games more unpredictable.
  prefs: []
  type: TYPE_NORMAL
