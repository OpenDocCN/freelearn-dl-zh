- en: '*Chapter 2*: Finite State Machines'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：有限状态机'
- en: In this chapter, we'll learn how to implement a **Finite State Machine** (**FSM**)
    in a Unity3D game by studying the simple tank game-mechanic example that comes
    with this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过研究本书附带的一个简单的坦克游戏机制示例，学习如何在Unity3D游戏中实现**有限状态机**（**FSM**）。
- en: In our game, the player controls a tank. The enemy tanks move around the scene,
    following four waypoints. Once the player's tank enters the vision range of the
    enemy tanks, they start chasing it; then, once they are close enough to attack,
    they'll start shooting at our player's tank.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，玩家控制一辆坦克。敌方坦克在场景中移动，遵循四个航点。一旦玩家的坦克进入敌方坦克的视野范围，它们就开始追逐它；然后，一旦它们足够接近可以攻击，它们就会开始向我们的玩家坦克射击。
- en: To control the AI of our enemy tanks, we use an FSM. First, we'll use simple
    `switch` statements to implement our tank AI states. Then, we'll use a more complex
    and engineered FSM framework that will allow us greater flexibility in designing
    the character's FSM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们的敌方坦克的AI，我们使用FSM。首先，我们将使用简单的`switch`语句来实现我们的坦克AI状态。然后，我们将使用一个更复杂且经过工程设计的FSM框架，这将使我们能够更灵活地设计角色的FSM。
- en: 'The topics we will be covering in this chapter are the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Implementing the player's tank
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现玩家的坦克
- en: Implementing a bullet class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现子弹类
- en: Setting up waypoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置航点
- en: Creating the abstract FSM class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建抽象FSM类
- en: Using a simple FSM for the enemy tank AI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的FSM实现敌方坦克AI
- en: Using an FSM framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FSM框架
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 2` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您只需要Unity3D 2022。您可以在本书仓库的`Chapter 2`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02)。
- en: Implementing the player's tank
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现玩家的坦克
- en: Before writing the script for our player's tank, let's look at how we set up
    the `Rigidbody` and `Box Collider` components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的玩家坦克编写脚本之前，让我们看看我们是如何设置`Rigidbody`和`Box Collider`组件的。
- en: 'The `controller` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`controller`类：'
- en: '![Figure 2.1 – Our tank entity'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – Our tank entity'
- en: '](img/B17984_02_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_02_1.jpg]'
- en: Figure 2.1 – Our tank entity
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 我们的坦克实体
- en: The `PlayerTankController` class controls the player's tank. We use the *W*,
    *A*, *S*, and *D* keys to move and steer the tank and the left mouse button to
    aim and shoot from the **Turret** object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerTankController`类控制玩家的坦克。我们使用*W*、*A*、*S*和*D*键来移动和转向坦克，并使用左鼠标按钮从**Turret**对象瞄准和射击。'
- en: Information
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In this book, we assume that you are using a *QWERTY* keyboard and a two-button
    mouse, with the left mouse button set as the primary mouse button. If you are
    using a different keyboard, all you have to do is pretend that you are using a
    *QWERTY* keyboard or try to modify the code to adapt it to your keyboard layout.
    It is pretty easy!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们假设您正在使用一个*QWERTY*键盘和两个按钮的鼠标，其中左鼠标按钮被设置为主要的鼠标按钮。如果您使用的是不同的键盘，您只需假装您正在使用一个*QWERTY*键盘，或者尝试修改代码以适应您的键盘布局。这相当简单！
- en: Initializing the Tank object
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化坦克对象
- en: 'Let''s start creating the `PlayerTankController` class by setting up the `Start`
    function and the `Update` function in the `PlayerTankController.cs` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`PlayerTankController.cs`文件中设置`Start`函数和`Update`函数开始创建`PlayerTankController`类：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can see in the hierarchy that the **PlayerTank** game object has one child
    called **Turret**, and in turn, the first child of the **Turret** object is called
    **SpawnPoint**. To set up the controller, we need to link (by dragging and dropping)
    **Turret** and **SpawnPoint** into the corresponding fields in the Inspector:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在层次结构中看到，**PlayerTank**游戏对象有一个名为**Turret**的子对象，而**Turret**对象的第一个子对象被称为**SpawnPoint**。为了设置控制器，我们需要将**Turret**和**SpawnPoint**拖放到检查器中相应的字段：
- en: '![Figure 2.2 – The Player Tank Controller component in the Inspector'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2 – The Player Tank Controller component in the Inspector'
- en: '](img/B17984_02_2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_02_2.jpg]'
- en: Figure 2.2 – The Player Tank Controller component in the Inspector
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.2 – The Player Tank Controller component in the Inspector
- en: Later, after creating the `Bullet` variable using the Inspector. Then, finally,
    the `Update` function calls the `UpdateControl` and `UpdateWeapon` functions.
    We will discuss the content of these functions in the following section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在创建 `Bullet` 变量后，最后，`Update` 函数调用 `UpdateControl` 和 `UpdateWeapon` 函数。我们将在下一节讨论这些函数的内容。
- en: Shooting the bullet
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击子弹
- en: The mechanism for shooting the bullet is simple. Whenever the player clicks
    the left mouse button, we check whether the total elapsed time since the last
    fire is greater than the weapon's fire rate. If it is, then we create a new `bulletSpawnPoint`
    transform's position. This check prevents the player from shooting a continuous
    stream of bullets.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 射击子弹的机制很简单。每当玩家点击鼠标左键时，我们检查自上次射击以来经过的总时间是否大于武器的射击速率。如果是，则创建一个新的 `bulletSpawnPoint`
    变换的位置。这个检查防止玩家连续射击子弹流。
- en: 'For this, we add the following function to the `PlayerTankController.cs` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 `PlayerTankController.cs` 文件中添加以下函数：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we can attach this controller script to the **PlayerTank** object. If we
    run the game, we should be able to shoot from our tanks. Now, it is time to implement
    the tank's movement controls.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将此控制器脚本附加到 **PlayerTank** 对象上。如果我们运行游戏，我们应该能够从我们的坦克中射击。现在，是时候实现坦克的移动控制了。
- en: Controlling the tank
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制坦克
- en: 'The player can rotate the `UpdateControl` function to the `PlayerTankController.cs`
    file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以将 `UpdateControl` 函数旋转到 `PlayerTankController.cs` 文件中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use raycasting to determine the turning direction by finding the `mousePosition`
    coordinates on the battlefield:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用射线投射来确定转向方向，通过找到战场上的 `mousePosition` 坐标：
- en: '![Figure 2.3 – Raycast to aim with the mouse'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 使用鼠标射线瞄准'
- en: '](img/B17984_02_3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_3.jpg)'
- en: Figure 2.3 – Raycast to aim with the mouse
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 使用鼠标射线瞄准
- en: Information
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: '**Raycasting** is a tool provided by default in the Unity physics engine. It
    allows us to find the intersection point between an imaginary line (the *ray*)
    and a collider in the scene. Imagine this as a laser pointer: we can fire our
    laser in a direction and see the point where it hits. However, this is a relatively
    expensive operation. While, in general, you can confidently handle 100–200 raycasts
    per frame, their performance is greatly affected by the length of the ray and
    the number and types of colliders in the scene. So, as a quick tip, try not to
    use a lot of raycasts with mesh colliders and use layer masks to filter out unnecessary
    colliders.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**射线投射** 是 Unity 物理引擎默认提供的一个工具。它允许我们在场景中找到一条假想线（射线）与碰撞器之间的交点。想象一下这是一个激光笔：我们可以向一个方向发射激光，并看到它击中的点。然而，这是一个相对昂贵的操作。虽然一般来说，你可以自信地处理每帧
    100-200 次射线投射，但它们的性能会受到射线长度和场景中碰撞器的数量和类型的影响很大。所以，作为一个快速提示，尽量不要使用大量的射线投射与网格碰撞器，并使用层掩码来过滤掉不必要的碰撞器。'
- en: 'This is how it works:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: Set up a plane that intersects with the player tank with an upward normal.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个与玩家坦克相交且法线向上的平面。
- en: Shoot a ray from screen space with the mouse position (in the preceding diagram,
    we assume that we're looking down at the tank).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从屏幕空间中用鼠标位置（在先前的图中，我们假设我们正在向下看坦克）射出射线。
- en: Find the point where the ray intersects the plane.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到射线与平面的交点。
- en: Finally, find the rotation from the current position to that intersection point.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，找到从当前位置到该交点的旋转。
- en: 'Then, we check for the key-pressed input and move or rotate the tank accordingly.
    We add the following code at the end of the `UpdateControl` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查按键输入并相应地移动或旋转坦克。我们在 `UpdateControl` 函数的末尾添加以下代码：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code represents the classic *WASD* control scheme. The tank rotates
    with the *A* and *D* keys, and moves forward and backward with *W* and *S*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表示经典的 *WASD* 控制方案。坦克通过 *A* 和 *D* 键旋转，通过 *W* 和 *S* 键前进和后退。
- en: Information
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Depending on your level of Unity expertise, you may wonder what about the `Lerp`
    and `Time.deltaTime` multiplications. It may be worth a slight digression. First,
    `Lerp` function to smoothly spread the velocity changes over multiple frames so
    that the tank's movement doesn't look like it's accelerating and decelerating
    instantaneously. The `7.0f` value is just a *smoothing factor*, and you can play
    with it to find your favorite value (the bigger the value, the greater the tank's
    acceleration).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你对 Unity 的熟练程度，你可能想知道关于 `Lerp` 和 `Time.deltaTime` 乘法的细节。这可能值得稍作解释。首先，`Lerp`
    函数用于在多个帧上平滑地传播速度变化，这样坦克的运动就不会看起来是瞬间加速和减速的。`7.0f` 的值只是一个 *平滑因子*，你可以玩弄它以找到你喜欢的值（值越大，坦克的加速度就越大）。
- en: Then, we multiply everything by `Time.deltaTime`. This value represents the
    time in seconds between now and the last frame, and we use it to make our velocity
    independent from the frame rate. For more info, refer to [https://learn.unity.com/tutorial/delta-time](https://learn.unity.com/tutorial/delta-time).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将所有内容乘以 `Time.deltaTime`。这个值表示从现在到上一帧之间的秒数，我们使用它来使速度独立于帧率。更多信息，请参阅[https://learn.unity.com/tutorial/delta-time](https://learn.unity.com/tutorial/delta-time)。
- en: Next, it is time to implement the projectiles fired by the player and enemy
    tanks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候实现玩家和敌方坦克发射的弹丸了。
- en: Implementing a Bullet class
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Bullet 类
- en: 'Next, we set up our **Bullet** prefab with two orthogonal planes and a box
    collider, using a laser-like material and a **Particles/Additive-Layer** property
    in the **Shader** field:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用两个正交平面和一个盒子碰撞器设置我们的 **Bullet** 预制体，在 **Shader** 字段中使用类似激光的材料和 **Particles/Additive-Layer**
    属性：
- en: '![Figure 2.4 – Our Bullet prefab'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 我们的子弹预制体'
- en: '](img/B17984_02_4.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_4.jpg)'
- en: Figure 2.4 – Our Bullet prefab
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 我们的子弹预制体
- en: 'The code in the `Bullet.cs` file is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet.cs` 文件中的代码如下：'
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Bullet` class has three properties: `damage`, `Speed`, and `Lifetime`
    – the latter so that the bullet is automatically destroyed after a certain amount
    of time. Note that we use `[SerializeField]` to show the private fields in the
    Inspector; by default, in fact, Unity only shows public fields. It is a good practice
    to set fields that we need to access from other classes as public-only.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet` 类有三个属性：`damage`、`Speed` 和 `Lifetime` – 后者使得子弹在一段时间后自动销毁。请注意，我们使用 `[SerializeField]`
    来在检查器中显示私有字段；实际上，Unity 默认只显示公共字段。将我们需要从其他类访问的字段设置为公共字段是一个好习惯。'
- en: 'As you can see, the `Explosion` property of the bullet is linked to the `ParticleExplosion`
    prefab, which we''re not going to discuss in detail. This prefab is in the `ParticleEffects`
    folder, so we drop it into the `OnCollisionEnter` method. The `ParticleExplosion`
    prefab uses the `AutoDestruct` script to automatically destroy the `Explosion`
    object after a small amount of time:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，子弹的 `Explosion` 属性链接到 `ParticleExplosion` 预制体，我们不会详细讨论。这个预制体在 `ParticleEffects`
    文件夹中，所以我们将其放入 `OnCollisionEnter` 方法中。`ParticleExplosion` 预制体使用 `AutoDestruct`
    脚本来自动在一段时间后销毁 `Explosion` 对象：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `AutoDestruct` script is small but convenient. It just destroys the attached
    object after a certain number of seconds. Many Unity games use a similar script
    almost every time for many situations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoDestruct` 脚本虽小但方便。它只需经过一定时间后就会销毁附加的对象。许多 Unity 游戏几乎在每种情况下都会使用类似的脚本。'
- en: Now that we have a tank that can fire and move, we can set up a simple patrolling
    path for the enemy tanks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以发射和移动的坦克，我们可以为敌方坦克设置一个简单的巡逻路径。
- en: Setting up waypoints
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置航点
- en: By default, the enemy tanks will patrol the game arena. To implement this behavior,
    we need to specify first the patrolling path. We will explore path following thoroughly
    in [*Chapter 6*](B17984_06_Epub.xhtml#_idTextAnchor375), *Path Following and Steering
    Behaviors*. For now, we limit ourselves to a simple *waypoints path*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，敌方坦克将在游戏竞技场巡逻。要实现这种行为，我们首先需要指定巡逻路径。我们将在 [*第 6 章*](B17984_06_Epub.xhtml#_idTextAnchor375)
    中彻底探讨路径跟随，*路径跟随和转向行为*。现在，我们只限于一个简单的 *航点路径*。
- en: 'To implement it, we put four `WanderPoint`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现它，我们放置了四个 `WanderPoint`：
- en: '![Figure 2.5 – WanderPoint'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – WanderPoint'
- en: '](img/B17984_02_5.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_5.jpg)'
- en: Figure 2.5 – WanderPoint
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – WanderPoint
- en: 'Here is what our **WanderPoint** objects look like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们 **WanderPoint** 对象的外观：
- en: '![Figure 2.6 – The WanderPoint properties'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – WanderPoint 属性'
- en: '](img/B17984_02_6.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_6.jpg)'
- en: Figure 2.6 – The WanderPoint properties
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – WanderPoint 属性
- en: 'Note that we need to tag these points with a tag called **WanderPoint**. Later,
    we will use this tag when we try to find the waypoints from our tank AI. As you
    can see in its properties, a waypoint is just a **Cube** game object with the
    **Mesh Renderer** checkbox disabled:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要将这些点标记为名为 **WanderPoint** 的标签。稍后，当我们尝试从我们的坦克 AI 中找到航点时，我们将使用这个标签。如你所见，在其属性中，航点只是一个带有
    **Mesh Renderer** 复选框禁用的 **Cube** 游戏对象：
- en: '![Figure 2.7 – The gizmo selection panel'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – 工具选择面板'
- en: '](img/B17984_02_7.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_7.jpg)'
- en: Figure 2.7 – The gizmo selection panel
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 工具选择面板
- en: To show these points in the editor (but not in the game), we use an empty object
    with a gizmo icon, since all we need from a waypoint is its position and the transformation
    data. To do that, click the small triangle near the object icon in the Inspector,
    as shown in *Figure 2.7*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在编辑器中显示这些点（但不在游戏中），我们使用一个带有工具图标的无内容对象，因为我们从航点中需要的只是其位置和变换数据。为此，请点击检查器中对象图标附近的小三角形，如图
    *图 2.7* 所示。
- en: We are now ready to give life to the enemy tanks with the power of the FSM.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备利用有限状态机 (FSM) 的力量让敌方坦克获得生命。
- en: Creating the abstract FSM class
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建抽象 FSM 类
- en: Next, we implement a generic abstract class to define the enemy tank AI class's
    methods. This abstract class will be the skeleton of our AI and represent a high-level
    view of what an enemy tank should do.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现一个通用的抽象类来定义敌方坦克 AI 类的方法。这个抽象类将是我们的 AI 的骨架，并代表敌方坦克应该做什么的高级视图。
- en: 'We can see the code of this class in the `FSM.cs` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `FSM.cs` 文件中看到这个类的代码：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The enemy tanks need only to know the position of the player's tank, their next
    destination point, and the list of waypoints to choose from while they're patrolling.
    Once the player tank is in range, they rotate their turret object and start shooting
    from the bullet spawn point at their fire rate.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方坦克只需要知道玩家坦克的位置、它们的下一个目的地以及巡逻时可以选择的航点列表。一旦玩家坦克进入射程，它们就会旋转炮塔对象，并以它们的射击速率从子弹发射点开始射击。
- en: 'As we explained before, we will extend this class in two ways: using a simple
    *if-then-else*-based FSM (the `SimpleFSM` class) and a more engineered but more
    flexible FSM (`AdvancedFSM`). These two FSM implementations will inherit the `FSM`
    abstract class, and they will implement the three abstract methods: `Initialize`,
    `FSMUpdate`, and `FSMFixedUpdate`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，我们将以两种方式扩展这个类：使用基于简单 *if-then-else* 的 FSM（`SimpleFSM` 类）和更工程化但更灵活的
    FSM（`AdvancedFSM`）。这两个 FSM 实现将继承 `FSM` 抽象类，并将实现三个抽象方法：`Initialize`、`FSMUpdate`
    和 `FSMFixedUpdate`。
- en: We will see the two different ways to implement these three methods in the next
    sections. For now, let's start with the basic implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到实现这三种方法的不同方式。现在，让我们从基本实现开始。
- en: Using a simple FSM for the enemy tank AI
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单的 FSM 为敌方坦克 AI 实现
- en: Let's look at the actual code for our AI tanks. First, let's create a new class,
    called `SimpleFSM`, which inherits from our FSM abstract class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们 AI 坦克的实际代码。首先，让我们创建一个新的类，称为 `SimpleFSM`，它继承自我们的 FSM 抽象类。
- en: 'You can find the source code in the `SimpleFSM.cs` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `SimpleFSM.cs` 文件中找到源代码：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we declare a few variables. Our tank AI has four different states: **Patrol**,
    **Chase**, **Attack**, and **Dead**. We are implementing the FSM that we described
    as an example in [*Chapter 1*](B17984_01_Epub.xhtml#_idTextAnchor015), *Introduction
    to AI*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一些变量。我们的坦克 AI 有四种不同的状态：**巡逻**、**追逐**、**攻击**和**死亡**。我们正在实现我们在 [*第 1
    章*](B17984_01_Epub.xhtml#_idTextAnchor015) 中描述的 FSM，即 *人工智能简介*：
- en: '![Figure 2.8 – The enemy tank AI''s FSM'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 敌方坦克 AI 的有限状态机 (FSM)'
- en: '](img/B17984_02_8.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_8.jpg)'
- en: Figure 2.8 – The enemy tank AI's FSM
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 敌方坦克 AI 的有限状态机 (FSM)
- en: 'In our `Initialize` method, we set up our AI tank''s properties with default
    values. Then, we store the positions of waypoints in our local variable. We get
    those waypoints from our scene using the `FindGameObjectsWithTag` method, trying
    to find those objects with the **WandarPoint** tag:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Initialize` 方法中，我们使用默认值设置我们的 AI 坦克的属性。然后，我们将航点的位置存储在我们的局部变量中。我们使用 `FindGameObjectsWithTag`
    方法从场景中获取这些航点，尝试找到带有 **WandarPoint** 标签的对象：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Update` method that gets called every frame looks like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧被调用的 `Update` 方法看起来如下：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We check the current state and then call the appropriate state method. Once
    the health object has a value of zero or less, we set the tank to the `Dead` state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查当前状态，然后调用适当的状态方法。一旦健康对象的价值为零或更少，我们将坦克设置为 `Dead` 状态。
- en: Debugging Private Variables
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 调试私有变量
- en: 'A public variable in the Inspector is not only useful because we can quickly
    experiment with different values but also because we can quickly look at a glance
    at their value when debugging. For this reason, you may even be tempted to make
    public (or expose to the Inspector) variables that should not be changed by the
    component''s user. Don''t worry – there is a solution: you can show the Inspector
    in **Debug** mode. In **Debug** mode, the Inspector also shows private fields.
    To enable Debug mode, click on the three dots at the top right and then click
    on **Debug**:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器中的公共变量不仅因为我们可以快速尝试不同的值而有用，还因为我们可以在调试时快速查看它们的值。因此，你甚至可能会想将不应由组件用户更改的变量设置为公共（或暴露给检查器）。不用担心——有一个解决方案：你可以在**调试**模式下显示检查器。在**调试**模式下，检查器也会显示私有字段。要启用调试模式，点击右上角的三个点，然后点击**调试**：
- en: '![Figure 2.9 – Unity''s Inspector in Debug mode'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – Unity的调试模式下的检查器'
- en: '](img/B17984_02_9.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_9.jpg)'
- en: Figure 2.9 – Unity's Inspector in Debug mode
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – Unity的调试模式下的检查器
- en: Now, let's see how to implement each state one by one.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一看看如何实现每个状态。
- en: The Patrol state
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**巡逻**状态'
- en: 'The **Patrol** state is the state in which the tank moves from waypoint to
    waypoint, looking for the player. The **Patrol** state''s code is shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**巡逻**状态是坦克在从路标到路标之间移动，寻找玩家的状态。**巡逻**状态的代码如下所示：'
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While our tank is in the `FindNextPoint` method. This method simply chooses
    a random point from among the waypoints we defined before.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的坦克在`FindNextPoint`方法中时。这个方法只是简单地从我们之前定义的路标中选择一个随机点。
- en: On the other hand, if the tank has not reached its destination point, it checks
    the distance to the player's tank. If the player's tank is in range (which, in
    this example, we choose to be `300` units), the AI switches to the `UpdatePatrolState`
    function to rotate the tank and move it toward the next waypoint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果坦克尚未到达其目标点，它将检查与玩家坦克的距离。如果玩家坦克在范围内（在这个例子中，我们选择为`300`单位），AI将切换到`UpdatePatrolState`函数来旋转坦克并移动到下一个路标。
- en: The Chase state
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**追逐**状态'
- en: 'In the **Chase** state, the tank actively tries to get near the player''s tank.
    In simple terms, the destination point becomes the player''s tank itself. The
    **Chase** state implementation code is shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在**追逐**状态下，坦克积极尝试靠近玩家的坦克。简单来说，目标点变成了玩家的坦克本身。**追逐**状态的实施代码如下所示：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this state, we first set the destination point as the player. Then, we continue
    checking the player's distance from the tank. If the player is close enough, the
    AI switches to the **Attack** state. On the other hand, if the player's tank manages
    to escape and goes too far, the AI goes back to the **Patrol** state.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个状态下，我们首先将目标点设置为玩家。然后，我们继续检查玩家与坦克的距离。如果玩家足够近，AI将切换到**攻击**状态。另一方面，如果玩家坦克设法逃脱并走得太远，AI将回到**巡逻**状态。
- en: The Attack state
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**攻击**状态'
- en: 'The **Attack** state is precisely what you expect: the enemy tank aims and
    shoots at the player. The following code block is the implementation code for
    the **Attack** state:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击**状态正是你所期待的：敌方坦克瞄准并射击玩家。以下代码块是**攻击**状态的实施代码：'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first line, we still set the destination point to the player's position.
    After all, even when attacking, we need to keep a close distance from the player.
    Then, if the player tank is close enough, the AI tank rotates the `turret` object
    in the direction of the player tank and then starts shooting. Finally, if the
    player's tank goes out of range, the tank goes back to the **Patrol** state.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们仍然将目标点设置为玩家的位置。毕竟，即使在攻击时，我们也需要保持与玩家保持较近的距离。然后，如果玩家坦克足够近，AI坦克将`turret`对象旋转到玩家坦克的方向，并开始射击。最后，如果玩家的坦克超出范围，坦克将回到**巡逻**状态。
- en: The Dead state
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**死亡**状态'
- en: 'The **Dead** state is the final state. Once a tank is in the **Dead** state,
    it explodes and gets uninstantiated. The following is the code for the **Dead**
    state:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**死亡**状态是最终状态。一旦坦克进入**死亡**状态，它就会爆炸并消失。以下是**死亡**状态的代码：'
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, the code is straightforward – if the tank has reached the **Dead**
    state, we make it explode:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码很简单——如果坦克达到了**死亡**状态，我们让它爆炸：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here's a small function that gives a nice explosion effect. We apply a random
    `ExplosionForce` function to the tank's `Rigidbody` component. If everything is
    correct, you should see the tank flying in the air in a random direction for the
    player's amusement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小函数，它提供了一个很好的爆炸效果。我们给坦克的 `Rigidbody` 组件应用一个随机的 `ExplosionForce` 函数。如果一切正常，你应该会看到坦克在空中以随机方向飞起，供玩家娱乐。
- en: Taking damage
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受伤
- en: 'To complete the demo, we need to add another small detail: we need the tanks
    to take damage when they get hit by a bullet. Every time a bullet enters the collision
    area of the tank, the `health` property''s value decreases, according to the `Bullet`
    object''s `damage` value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个演示，我们需要添加另一个小细节：当坦克被子弹击中时，它们需要受到伤害。每次子弹进入坦克的碰撞区域，`health` 属性的值就会根据 `Bullet`
    对象的 `damage` 值减少：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can open the `SimpleFSM.scene` file in Unity; you should see the AI tanks
    patrolling, chasing, and attacking the player. Our player's tank doesn't take
    damage from AI tanks yet, so it never gets destroyed. But the AI tanks have the
    health property and take damage from the player's bullets, so you'll see them
    explode once their health property reaches zero.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Unity 中打开 `SimpleFSM.scene` 文件；你应该能看到 AI 坦克正在巡逻、追逐和攻击玩家。我们的玩家坦克目前还没有受到
    AI 坦克的伤害，所以它永远不会被摧毁。但是 AI 坦克有生命属性，会受到玩家子弹的伤害，所以你会看到它们的生命属性达到零时爆炸。
- en: 'If your demo doesn''t work, try playing with different values in the Inspector
    for the **SimpleFSM** components. After all, the values may change, depending
    on the scale of your project:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的演示不起作用，请尝试在检查器中调整 **SimpleFSM** 组件的不同值。毕竟，这些值可能会根据你项目的规模而变化：
- en: '![Figure 2.10 – The AI tanks in action'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – AI 坦克在行动'
- en: '](img/B17984_02_10.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_02_10.jpg)'
- en: Figure 2.10 – The AI tanks in action
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – AI 坦克在行动
- en: In this demo, we used a very simple FSM, but now it's time to step up the challenge
    and implement a complete FSM framework.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们使用了一个非常简单的有限状态机（FSM），但现在是我们提高挑战并实现一个完整的 FSM 框架的时候了。
- en: Using an FSM framework
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FSM 框架
- en: The FSM framework we're going to use here is adapted from the `Chapter02` folder
    of the book repository ([https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition)).
    In particular, we will look at the **AdvancedFSM** scene.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的 FSM 框架是从书籍仓库的 `Chapter02` 文件夹中改编的（[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition)）。特别是，我们将查看
    **AdvancedFSM** 场景。
- en: In this section, we will study how the framework works and how we can use this
    to implement our tank AI. `AdvancedFSM` and `FSMState` are the two main classes
    of our framework. So, let's take a look at them first.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究框架的工作原理以及我们如何使用它来实现我们的坦克 AI。`AdvancedFSM` 和 `FSMState` 是我们框架的两个主要类。所以，让我们先看看它们。
- en: The AdvancedFSM class
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AdvancedFSM 类
- en: The `AdvancedFSM` class manages all the `FSMState` classes we've implemented
    and keeps them updated with the transitions and the current state. So, the first
    thing to do before using our framework is to declare the transitions and states
    that we plan to implement for our AI tanks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdvancedFSM` 类管理我们实现的所有 `FSMState` 类，并保持它们通过转换和当前状态更新。因此，在使用我们的框架之前，我们首先要声明我们计划为我们的
    AI 坦克实现的转换和状态。'
- en: 'Let''s start by creating `AdvancedFSM.cs`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建 `AdvancedFSM.cs` 开始：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we define two enumerations, one for the set of states and one for the
    set of transitions. Then, we add a list object to store the `FSMState` objects
    and two local variables to store the current ID of the `FSMState` class and the
    current `FSMState` itself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个枚举，一个用于状态集合，另一个用于转换集合。然后，我们添加了一个列表对象来存储 `FSMState` 对象，以及两个局部变量来存储
    `FSMState` 类的当前 ID 和当前的 `FSMState` 本身。
- en: 'The `AddFSMState` and `DeleteState` methods add and delete the instances of
    the `FSMState` class in our list respectively. When the `PerformTransition` method
    gets called, it updates the `CurrentState` variable with the new state, according
    to the transition:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddFSMState` 和 `DeleteState` 方法分别在我们的列表中添加和删除 `FSMState` 类的实例。当 `PerformTransition`
    方法被调用时，它会根据转换更新 `CurrentState` 变量：'
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that the data part of the class is ready, we can proceed with the internal
    logic of the FSM framework.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类的数据部分已经准备好了，我们可以继续实现 FSM 框架的内部逻辑。
- en: The FSMState class
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FSMState 类
- en: '`FSMState` manages the transitions to other states. It has a dictionary object
    called `map` in which we store the key-value pairs of transitions and states.
    So, for example, the `SawPlayer` transition maps to the `Chasing` state, `LostPlayer`
    maps to the `Patrolling` state, and so on.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSMState`管理到其他状态的转换。它有一个名为`map`的字典对象，其中我们存储转换和状态的键值对。例如，`SawPlayer`转换映射到`Chasing`状态，`LostPlayer`映射到`Patrolling`状态，等等。'
- en: 'Let''s create an `FSMState.cs` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`FSMState.cs`文件：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `AddTransition` and `DeleteTransition` methods add and delete transitions
    from their state-transition dictionary `map` object. The `GetOutputState` method
    looks up from the `map` object and returns the state based on the input transition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddTransition`和`DeleteTransition`方法向它们的状态转换字典映射对象中添加和删除转换。`GetOutputState`方法从映射对象中查找，并根据输入转换返回状态。'
- en: 'The `FSMState` class also declares two abstract methods that its child classes
    need to implement. They are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSMState`类还声明了两个抽象方法，其子类需要实现。它们如下：'
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `CheckTransitionRules` method has to check whether the state should carry
    out the transition to another state. Instead, the `RunState` method does the actual
    execution of the tasks for the `currentState` variable, such as moving toward
    a destination point and chasing or attacking the player. Both methods require
    transformed data from the player and the **Non Playable Character** (**NPC**)
    entity obtained using this class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckTransitionRules`方法必须检查状态是否应该执行到另一个状态的转换。相反，`RunState`方法执行`currentState`变量的实际任务，例如向目标点移动和追逐或攻击玩家。这两个方法都需要使用此类从玩家和**不可玩角色**（**NPC**）实体获得的转换数据。'
- en: The state classes
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态类
- en: Unlike the previous `SimpleFSM` example, we write the states for our tank AI
    in separate classes that inherit from the `FSMState` class, such as `AttackState`,
    `ChaseState`, `DeadState`, and `PatrolState`. All of them implement the `CheckTransitionRules`
    and `RunState` methods. Let's take a look at the `PatrolState` class as an example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`SimpleFSM`示例不同，我们为我们的坦克AI在继承自`FSMState`类的单独类中编写状态，例如`AttackState`、`ChaseState`、`DeadState`和`PatrolState`。所有这些类都实现了`CheckTransitionRules`和`RunState`方法。让我们以`PatrolState`类为例进行查看。
- en: The PatrolState class
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PatrolState`类'
- en: 'This class has three methods: a constructor, `CheckTransitionRules`, and `RunState`.
    Let''s create the `PatrolState` class in the `PatrolState.cs` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有三个方法：构造函数、`CheckTransitionRules`和`RunState`。让我们在`PatrolState.cs`文件中创建`PatrolState`类：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `constructor` method takes the `waypoints` array, stores them in a local
    array, and then initializes properties such as movement and rotation speed. The
    `Reason` method checks the distance between itself (the AI tank) and the player
    tank. If the player tank is in range, it sets the transition ID to the `SawPlayer`
    transition using the `SetTransition` method of the `NPCTankController` class,
    which looks as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor`方法接受`waypoints`数组，将其存储在本地数组中，然后初始化如移动和旋转速度等属性。`Reason`方法检查自身（AI坦克）和玩家坦克之间的距离。如果玩家坦克在范围内，它使用`NPCTankController`类的`SetTransition`方法将转换ID设置为`SawPlayer`转换，该方法如下所示：'
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding function is just a wrapper method that calls the `PerformTransition`
    method of the `AdvanceFSM` class. In turn, that method updates the `CurrentState`
    variable with the one responsible for this transition, using the `Transition`
    object and the state-transition dictionary map object from the `FSMState` class.
    The `Act` method updates the AI tank's destination point, rotates the tank in
    that direction, and moves it forward.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数只是一个包装方法，它调用`AdvanceFSM`类的`PerformTransition`方法。反过来，该方法使用`Transition`对象和来自`FSMState`类的状态转换字典映射对象来更新`CurrentState`变量，以负责这个转换。`Act`方法更新AI坦克的目标点，将坦克旋转到那个方向，并向前移动。
- en: Other state classes also follow this template with different reasoning and acting
    procedures. We've already seen them in our previous simple FSM examples, and therefore,
    we won't describe them again here. See whether you can figure out how to set up
    these classes on your own. If you get stuck, the assets that come with this book
    contain the code for you to look at.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其他状态类也遵循这个模板，具有不同的推理和行动程序。我们已经在之前的简单有限状态机（FSM）示例中见过它们，因此在这里不再描述。看看你是否能自己找出如何设置这些类。如果你卡住了，这本书附带的内容中包含了你可以查看的代码。
- en: The NPCTankController class
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`NPCTankController`类'
- en: 'For the tank AI, we set up the states for our NPC by using the `NPCTankController`
    class. This class inherits from `AdvanceFSM`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于坦克AI，我们通过使用`NPCTankController`类为我们的NPC设置状态。这个类从`AdvanceFSM`继承：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s the beauty of using our FSM framework: since the states are self-managed
    within their respective classes, our `NPCTankController` class only needs to call
    the `Reason` and `Act` methods of the currently active state.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用我们的FSM框架的美丽之处：由于状态在其各自的类中自我管理，我们的`NPCTankController`类只需要调用当前活动状态的`Reason`和`Act`方法。
- en: 'This fact eliminates the need to write a long list of the `if`/`else` and `switch`
    statements. Instead, our states are now nicely packaged in classes of their own,
    which makes the code more manageable, as the number of states and transitions
    between them grows more and more in larger projects:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这一事实消除了编写长串的`if`/`else`和`switch`语句的需求。相反，我们的状态现在被很好地封装在自己的类中，这使得代码更加易于管理，因为在大型项目中，状态的数量以及它们之间的转换越来越多：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The main steps to use this framework can be summarized as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此框架的主要步骤可以总结如下：
- en: Declare the transitions and states in the `AdvanceFSM` class.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AdvanceFSM`类中声明转换和状态。
- en: Write the state classes inherited from the `FSMState` class, and then implement
    the `Reason` and `Act` methods.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写从`FSMState`类继承的状态类，然后实现`Reason`和`Act`方法。
- en: Write the custom NPC AI class inherited from `AdvanceFSM`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写从`AdvanceFSM`继承的自定义NPC AI类。
- en: Create states from the state classes, and then add transition and state pairs
    using the `AddTransition` method of the `FSMState` class.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从状态类创建状态，然后使用`FSMState`类的`AddTransition`方法添加转换和状态对。
- en: Add those states into the state list of the `AdvanceFSM` class, using the `AddFSMState`
    method.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AddFSMState`方法将这些状态添加到`AdvanceFSM`类的状态列表中。
- en: Call the `CurrentState` variable's `Reason` and `Act` methods in the game update
    cycle.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏更新周期中调用`CurrentState`变量的`Reason`和`Act`方法。
- en: You can play around with the `AdvancedFSM` scene in Unity. It'll run the same
    way as our previous `SimpleFSM` example, but the code is now more organized and
    manageable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Unity中尝试`AdvancedFSM`场景。它将以与我们之前的`SimpleFSM`示例相同的方式运行，但现在代码更加有序和易于管理。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement state machines in Unity3D based
    on a simple tank game. We first looked at how to implement FSM by using `switch`
    statements. Then, we studied how to use a framework to make AI implementation
    easier to manage and extend.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Unity3D中根据简单的坦克游戏实现状态机。我们首先探讨了如何通过使用`switch`语句来实现有限状态机（FSM）。然后，我们研究了如何使用框架使AI实现更容易管理和扩展。
- en: In the next chapter, we will look at randomness and probability and see how
    we can use them to make the outcome of our games more unpredictable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨随机性和概率，并看看我们如何利用它们使游戏的结果更加不可预测。
