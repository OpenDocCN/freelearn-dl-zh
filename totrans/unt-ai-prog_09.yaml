- en: '*Chapter 7*: A* Pathfinding'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*：A* 路径查找'
- en: In this chapter, we will implement the **A* algorithm** in Unity3D using C#.
    The A* pathfinding algorithm is widely used in games and interactive applications
    because of its simplicity and effectiveness. We talked about this algorithm previously
    in *Chapter 1*, *Introduction to AI*. However, here, we'll review the algorithm
    again, this time from an implementation perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 C# 在 Unity3D 中实现 **A* 算法**。A* 路径查找算法因其简单性和有效性而在游戏和交互式应用中得到广泛应用。我们之前在
    *第一章*，*人工智能简介* 中讨论了此算法。然而，在这里，我们将再次回顾该算法，这次是从实现的角度。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Revisiting the A* algorithm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视 A* 算法
- en: Implementing the A* algorithm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 A* 算法
- en: Setting up the scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置场景
- en: Testing the pathfinder
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试路径查找器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 7` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要 Unity3D 2022\. 你可以在本书仓库的 `Chapter 7` 文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07)。
- en: Revisiting the A* algorithm
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视 A* 算法
- en: Let's review the A* algorithm before we proceed to implement it in the next
    section. The foundation of any pathfinding algorithm is a representation of the
    world. Pathfinding algorithms cannot search over the noisy structure of polygons
    in the game map; instead, we need to provide them with a simplified version of
    the world. Using this simplified structure, we can identify the locations that
    an agent can traverse, as well as the inaccessible ones.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节实现 A* 算法之前，让我们回顾一下 A* 算法。任何路径查找算法的基础是对世界的表示。路径查找算法不能在游戏地图中多边形的嘈杂结构中进行搜索；相反，我们需要为他们提供一个简化的世界版本。使用这个简化的结构，我们可以识别出代理可以穿越的位置，以及不可到达的位置。
- en: 'There are many ways of doing this; however, for this example, we use one of
    the most straightforward solutions: a 2D grid. Therefore, we implement the `GridManager`
    class to convert the "real" map into a 2D tile representation. The `GridManager`
    class keeps a list of `Node` objects representing a single tile in the 2D grid.
    First, of course, we need to implement the `Node` class too: this class stores
    node information such as its position, whether it''s a traversable node or an
    obstacle, the cost to pass through, and the cost to reach the target node.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以做到这一点；然而，在这个例子中，我们使用最直接的一种解决方案：2D 网格。因此，我们实现了 `GridManager` 类，将“真实”地图转换为
    2D 地砖表示。`GridManager` 类保持一个表示 2D 网格中单个地砖的 `Node` 对象列表。当然，我们首先需要实现 `Node` 类：这个类存储节点信息，例如其位置、是否为可穿越节点或障碍物、通过的成本以及到达目标节点的成本。
- en: Once we have a world representation, we implement an `AStar` class for the actual
    A* pathfinding algorithm. The class is elementary; the `FindPath` method includes
    all the work. The class has two variables to keep track of the already visited
    nodes and the nodes that will be explored. We call these variables the `PriorityQueue`
    class because we want to get `Node` with the lowest score as fast as possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了世界表示，我们就实现一个 `AStar` 类来表示实际的 A* 路径查找算法。这个类很简单；`FindPath` 方法包含了所有的工作。这个类有两个变量来跟踪已经访问过的节点和将要探索的节点。我们称这些变量为
    `PriorityQueue` 类，因为我们希望尽快获取得分最低的 `Node`。
- en: 'Instead, the closed list wants a data structure that allows us to efficiently
    check whether it contains a specific `Node`: usually, a data structure called
    a **set** is a good choice.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，关闭列表需要一个允许我们高效检查是否包含特定 `Node` 的数据结构：通常，一个称为 **集合** 的数据结构是一个不错的选择。
- en: 'Finally, the A* pseudocode is outlined here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，A* 的伪代码如下：
- en: First, the algorithm takes the starting node and puts it in the open list.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，算法将起始节点放入开放列表中。
- en: As long as the open list is not empty, the algorithm proceeds to perform the
    following steps.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要开放列表不为空，算法就会继续执行以下步骤。
- en: It picks the first node from the open list and defines it as the current node
    (of course, we are assuming that we are using PriorityQueues for the open list).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从开放列表中选取第一个节点并将其定义为当前节点（当然，我们假设我们正在使用优先队列作为开放列表）。
- en: Then, it gets the neighboring nodes of this current node, excluding obstacle
    types (such as a wall or canyon that can't be passed through). This step is usually
    called expansion.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它获取当前节点的相邻节点，排除障碍物类型（例如无法通过的墙壁或峡谷）。这一步通常被称为扩展。
- en: 'For each neighbor node in step 4, it checks whether it is already in the closed
    list. If not, it calculates the total cost (*F*) for this neighbor node using
    the following formula:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤4中，对于每个相邻节点，它检查它是否已经在关闭列表中。如果没有，它使用以下公式计算这个相邻节点的总成本（*F*）：
- en: '![](img/Formula_011.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_011.png)'
- en: Here, *G* is the total cost from the starting node to this node (usually computed
    by adding the cost of moving from parent to neighbor to the *G* value of the parent
    node), and *H* is the estimated total cost from this node to the final target
    node. We will go over the problem of estimating the cost in later sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*G*是从起始节点到该节点的总成本（通常通过将从父节点移动到相邻节点的成本添加到父节点的*G*值来计算），而*H*是从该节点到最终目标节点的估计总成本。我们将在后面的章节中讨论估计成本的问题。
- en: The algorithm stores that cost data in the neighbor `node` object, and it assigns
    the current node as the neighbor's parent node. Later, we use this parent node
    data to trace back the starting node from the end node, thus reconstructing the
    actual path.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该算法将成本数据存储在相邻的`node`对象中，并将当前节点指定为相邻节点的父节点。稍后，我们使用这些父节点数据从终点节点追踪回起始节点，从而重建实际路径。
- en: It puts this neighbor node in the open list. The open list is a priority queue
    ordered by the *F* value; therefore, the first node in the open list is always
    the one with the lowest *F* value.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将这个相邻节点放入开放列表中。开放列表是一个按*F*值排序的优先队列；因此，开放列表中的第一个节点总是具有最低的*F*值。
- en: If there are no more neighbor nodes to process, the algorithm puts the current
    node in the closed list and removes it from the open list.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有更多的相邻节点需要处理，算法将当前节点放入关闭列表中，并从开放列表中移除。
- en: The algorithm goes back to step 2.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法回到步骤2。
- en: Once you have completed this algorithm, if there's an obstacle-free path to
    reach the target node from the start node, your current node is precisely at the
    target node position. Otherwise, this means that there's no available path to
    the target node from the current node position.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个算法，如果从起始节点到目标节点有一条无障碍路径，那么当前节点就精确地位于目标节点位置。否则，这意味着从当前节点位置到目标节点没有可用的路径。
- en: When we get a valid path, we have to trace back from the current node using
    the parent pointer until we reach the start node again. This procedure gives us
    a path listing all the nodes we chose during our pathfinding process, ordered
    from the target node to the start node. As a final step, we just reverse this
    path list and get the path in the proper order.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们得到一条有效路径时，我们必须使用父指针从当前节点追踪回，直到再次达到起始节点。这个过程给我们一个路径列表，列出了我们在路径查找过程中选择的节点，从目标节点到起始节点排序。作为最后一步，我们只需反转这个路径列表，就可以得到正确的路径顺序。
- en: Next, we will implement A* in Unity3D using C#. So, let's get started.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用C#在Unity3D中实现A*算法。那么，让我们开始吧。
- en: Implementing the A* algorithm
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现A*算法
- en: First, we implement the basic classes that we introduced before, such as the
    `Node` class, the `GridManager` class, and the `PriorityQueue` class. Then, we
    use them in the main `AStar` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实现之前介绍的基本类，例如`Node`类、`GridManager`类和`PriorityQueue`类。然后，我们在主要的`AStar`类中使用它们。
- en: Node
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点
- en: 'The `Node` class represents each tile object in the 2D grid. Its code is shown
    in the `Node.cs` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`类代表2D网格中的每个瓦片对象。其代码在`Node.cs`文件中显示：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Node` class stores every valuable property we need for finding a path.
    We are talking about properties such as the cost from the starting point (`costSoFar`),
    the total estimated cost from start to end (`fScore`), a flag to mark whether
    it is an obstacle, its positions, and its parent node. `costSoFar` is *G*, which
    is the movement cost value from the starting node to this node so far, and `fScore`
    is obviously *F*, which is the total estimated cost from the start to the target
    node. We also have two simple constructor methods and a wrapper method to set,
    depending on whether this node is an obstacle or not. Then, we implement the `Equals`
    and `GetHashCode` methods, as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node` 类存储了我们寻找路径所需的所有有价值属性。我们谈论的是诸如从起点到当前位置的成本 (`costSoFar`)、从起点到终点的总估计成本
    (`fScore`)、一个标记是否为障碍物的标志、其位置以及其父节点等属性。`costSoFar` 是 *G*，即从起点节点到当前位置的移动成本值，而 `fScore`
    显然是 *F*，即从起点到目标节点的总估计成本。我们还有两个简单的构造方法和一个包装方法来设置，根据这个节点是否为障碍物。然后，我们实现了 `Equals`
    和 `GetHashCode` 方法，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These methods are important. In fact, even if the `Node` class has multiple
    attributes, two nodes that represent the same position should be considered equal
    as far as the search algorithm is concerned. The way to do that is to override
    the default `Equals` and `GetHashCode` methods, as in the preceding example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法很重要。实际上，即使 `Node` 类有多个属性，代表相同位置的节点在搜索算法中应该被视为相等。要做到这一点，就像前面的例子中那样，我们需要重写默认的
    `Equals` 和 `GetHashCode` 方法。
- en: PriorityQueue
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PriorityQueue
- en: A **priority queue** is an ordered data structure designed so that the first
    element (the head) of the list is always the smallest or largest element (depending
    on the implementation). This data structure is the most efficient way to handle
    the nodes in the open list because, as we will see later, we need to quickly retrieve
    the node with the lowest *F* value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先队列**是一种有序数据结构，设计目的是使列表的第一个元素（头部）始终是最小或最大的元素（取决于实现方式）。这种数据结构是处理开放列表中节点最有效的方式，因为我们将在后面看到，我们需要快速检索具有最低
    *F* 值的节点。'
- en: 'Unfortunately, there is no easy out-of-the-box way to have a suitable priority
    queue (at least, until Unity supports .NET 6). The code we will use for this is
    shown in the following `NodePriorityQueue.cs` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有现成的合适优先队列的方法（至少，直到 Unity 支持 .NET 6）。我们将使用的代码如下面的 `NodePriorityQueue.cs`
    类所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This implementation is not particularly efficient because it relies on the `Sort`
    method to reorder the internal list of nodes after each insertion. This means
    that inserting a node becomes increasingly costly the more nodes we have in the
    queue. If you need better performance, you can find many priority queue implementations
    designed for A* and search algorithms (such as the one you can find at [https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp](https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现并不特别高效，因为它依赖于 `Sort` 方法在每次插入后重新排序节点的内部列表。这意味着随着队列中节点数量的增加，插入节点的成本会越来越高。如果你需要更好的性能，你可以找到许多为
    A* 和搜索算法（例如你可以在 [https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp](https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp)
    找到的那个）设计的优先队列实现。
- en: For now, though, our small `NodePriorityQueue` class will do its job nicely.
    The class is self-explanatory. The only thing you need to pay attention to is
    the `Enqueue` method. Before adding a new node, we need to check whether there
    is already a node with the same position but a lower F-score. If there is, we
    do nothing (we already have a *better* node in the queue). If not, this means
    that the new node we are adding is better than the old one. Therefore, we can
    remove the old one to ensure that we only have the best node possible for each
    position.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，尽管如此，我们的小型 `NodePriorityQueue` 类将很好地完成其工作。这个类是自我解释的。你唯一需要关注的是 `Enqueue` 方法。在添加新节点之前，我们需要检查是否已经存在一个具有相同位置但
    F 分数较低的节点。如果有，我们就不做任何事情（我们已经在队列中有一个 *更好* 的节点）。如果没有，这意味着我们正在添加的新节点比旧节点更好。因此，我们可以移除旧节点，以确保我们为每个位置只保留最佳节点。
- en: The GridManager class
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GridManager 类
- en: The `GridManager` class handles the 2D grid representation for the world map.
    We keep it as a singleton instance of the `GridManager` class, as we only need
    one object to represent the map. A singleton is a programming pattern that restricts
    the instantiation of a class to one object and, therefore, it makes the instance
    easily accessible from any point of the application. The code for setting up `GridManager`
    is shown in the `GridManager.cs` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridManager` 类处理世界地图的二维网格表示。我们将其保持为 `GridManager` 类的单例实例，因为我们只需要一个对象来表示地图。单例是一种编程模式，它限制一个类的实例化只能有一个对象，因此它使得实例在任何应用点都易于访问。设置
    `GridManager` 的代码显示在 `GridManager.cs` 文件中。'
- en: 'The first part of the class implements the `GridManager` object in the scene
    and, if we find it, we store it in the `staticInstance` static variable:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的第一个部分实现了场景中的 `GridManager` 对象，如果我们找到了它，我们就将其存储在 `staticInstance` 静态变量中：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, we declare all the variables that we need to represent our map. `numOfRows`
    and `numOfColumns` store the number of rows and columns of the grid. `gridCellSize`
    represents the size of each grid. `obstacleEpsilon` is the margin for the system
    we will use to detect obstacles (more on that later).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明所有需要用来表示地图的变量。`numOfRows` 和 `numOfColumns` 存储网格的行数和列数。`gridCellSize`
    表示每个网格的大小。`obstacleEpsilon` 是我们将用于检测障碍物的系统（稍后会有更多介绍）的边缘。
- en: 'Then we have two Boolean variables to enable or disable the debug visualization
    of the grid and obstacles. Finally, we have a grid of `nodes` representing the
    map itself. We also add two properties to get the grid''s origin in world coordinates
    (`Origin`) and the cost of moving from one tile to the other (`StepCost`). The
    final product is shown in the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有两个布尔变量来启用或禁用网格和障碍物的调试可视化。最后，我们有一个表示地图本身的 `nodes` 网格。我们还添加了两个属性来获取网格在全局坐标中的原点（`Origin`）和从一个瓦片移动到另一个瓦片的成本（`StepCost`）。最终产品如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we need to build the grid. For this, we use the `ComputeGrid` method that
    we call on `Awake`. The code is shown here:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要构建网格。为此，我们使用 `ComputeGrid` 方法，我们在 `Awake` 中调用它。代码如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ComputeGrid` function follows a simple algorithm. First, we just initialize
    the `nodes` grid. Then we start iterating over each square of the grid (represented
    by the coordinates `i` and `j`). For each square, we do as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ComputeGrid` 函数遵循一个简单的算法。首先，我们只是初始化 `nodes` 网格。然后我们开始遍历网格中的每个方块（由坐标 `i` 和
    `j` 表示）。对于每个方块，我们执行以下操作：'
- en: First, we create a new node positioned at the center of the square (in world
    coordinates).
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在方块中心（在全局坐标中）创建一个新的节点。
- en: Then, we check whether that square is occupied by an obstacle. We do this by
    using the `OverlapSphere` function. This `Physics` function returns all the colliders
    inside or intersecting the sphere defined in the parameters. In our case, we center
    the sphere at the center of the grid's cell (`cellPos`) and we define the sphere's
    radius as a bit less than the grid cell size. Note that we are only interested
    in colliders in the `Obstacles` layer, therefore we need to add the appropriate
    layer mask.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查该方块是否被障碍物占据。我们通过使用 `OverlapSphere` 函数来完成此操作。这个 `Physics` 函数返回所有位于或与参数中定义的球体相交的碰撞体。在我们的情况下，我们将球体中心放在网格单元格的中心（`cellPos`）上，并将球体的半径定义为略小于网格单元格大小。请注意，我们只对
    `Obstacles` 层中的碰撞体感兴趣，因此我们需要添加适当的层掩码。
- en: If the `OverlapSphere` function returns anything, this means that we have an
    obstacle inside the cell and, therefore, we define the entire cell as an obstacle.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `OverlapSphere` 函数返回任何内容，这意味着单元格内有一个障碍物，因此我们将整个单元格定义为障碍物。
- en: '`GridManager` also has several helper methods to traverse the grid and get
    the grid cell data. We show some of them in the following list, with a brief description
    of what they do. The implementation is simple:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridManager` 还有一些辅助方法来遍历网格并获取网格单元格数据。我们在以下列表中展示了其中一些，并简要描述了它们的功能。实现很简单：'
- en: 'The `GetGridCellCenter` method returns the position of the grid cell in world
    coordinates from the cell coordinates, as shown in the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetGridCellCenter` 方法根据单元格坐标返回网格单元格在全局坐标中的位置，如下面的代码所示：'
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `IsInBounds` method checks whether a certain position in the game falls
    inside the grid:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsInBounds` 方法检查游戏中的某个位置是否在网格内：'
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `IsTraversable` method checks whether a grid coordinate is traversable
    (that is, it is not an obstacle):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsTraversable` 方法检查一个网格坐标是否可穿越（即它不是一个障碍物）：'
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another important method is `GetNeighbours`, which is used by the `AStar` class
    to retrieve the neighboring nodes of a particular node. This is done by obtaining
    the grid coordinate of the node and then checking whether the four neighbors''
    coordinates (up, down, left, and right) are traversable:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个重要的方法是 `GetNeighbours`，它被 `AStar` 类用来检索特定节点的相邻节点。这是通过获取节点的网格坐标，然后检查四个相邻坐标（上、下、左、右）是否可穿越来完成的：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we have debug aid methods used to visualize the grid and obstacle
    blocks:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有用于可视化网格和障碍块的调试辅助方法：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Gizmos can be used to draw visual debugging and setup aids inside the editor
    scene view. `OnDrawGizmos` is called every frame by the engine. So, if the debug
    flags, `showGrid` and `showObstacleBlocks`, are checked, we just draw the grid
    with lines and the obstacle cube objects with cubes. We won't go through the `DebugDrawGrid`
    method, as it's pretty simple.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Gizmos 可以用来在编辑器场景视图中绘制可视化调试和设置辅助工具。`OnDrawGizmos` 由引擎每帧调用。因此，如果调试标志 `showGrid`
    和 `showObstacleBlocks` 被选中，我们就用线条绘制网格，并用立方体绘制障碍立方体对象。我们不会详细介绍 `DebugDrawGrid`
    方法，因为它相当简单。
- en: Info
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Info
- en: 'You can learn more about gizmos in the following Unity3D reference documentation:
    [https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 Unity3D 参考文档中了解更多关于 gizmos 的信息：[https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html)。
- en: The AStar class
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AStar 类
- en: 'The `AStar` class implements the pathfinding algorithm using the classes we
    have implemented so far. If you want a quick review of the A* algorithm, see the
    *Revisiting the A* algorithm* section earlier in this chapter. The steps for the
    implementation of `AStar` are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`AStar` 类使用我们迄今为止实现的类来实现路径查找算法。如果你想快速回顾 A* 算法，请参阅本章早些时候的 *重新审视 A* 算法* 部分。`AStar`
    的实现步骤如下：'
- en: 'We start by implementing a method called `HeuristicEstimateCost` to calculate
    the cost between the two nodes. The calculation is simple. We just find the direction
    vector between the two by subtracting one position vector from another. The magnitude
    of this resultant vector gives the straight-line distance from the current node
    to the target node:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先实现了一个名为 `HeuristicEstimateCost` 的方法来计算两个节点之间的成本。计算很简单。我们只需通过从一个位置向量减去另一个位置向量来找到两个节点之间的方向向量。这个结果向量的模长给出了从当前节点到目标节点的直线距离：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Info
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Info
- en: In theory, you can replace this function with any function, returning the distance
    between `curNode` and `goalNode`. However, for A* to return the shortest possible
    path, this function must be admissible. In short, an admissible heuristic function
    is a function that never overestimates the actual "real world" cost between `curNode`
    and `goalNode`. As an exercise, you can easily verify that the function we use
    in this demo is admissible. For more information on the math behind heuristic
    functions, you can visit [https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html](https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html).
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理论上，你可以用任何函数替换这个函数，返回 `curNode` 和 `goalNode` 之间的距离。然而，为了让 A* 返回可能的最短路径，这个函数必须是可接受的。简而言之，一个可接受的自适应启发式函数是一个永远不会高估
    `curNode` 和 `goalNode` 之间实际“真实世界”成本之间的函数。作为一个练习，你可以很容易地验证我们在这个演示中使用的是可接受的。有关启发式函数背后的数学信息，你可以访问
    [https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html](https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html)。
- en: 'Then, we have the main A* algorithm in the `FindPath` method. In the following
    snippet, we initialize the open and closed lists. Starting with the start node,
    we put it in our open list. Then, we start processing our open list:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 `FindPath` 方法中有主要的 A* 算法。在下面的代码片段中，我们初始化了开放和关闭列表。从起始节点开始，我们将其放入我们的开放列表中。然后，我们开始处理我们的开放列表：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we proceed with the main algorithm loop:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续进行主要的算法循环：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code implementation strictly follows the algorithm that we have
    discussed previously, so you can refer back to it if something is not clear:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码实现严格遵循我们之前讨论的算法，所以如果你对某些内容不清楚，可以参考它：
- en: Get the first node from our `openList`. Remember, `openList` is always sorted
    in increasing order. Therefore, the first node is always the node with the lowest
    *F* value.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的 `openList` 中获取第一个节点。记住，`openList` 总是按递增顺序排序。因此，第一个节点总是具有最低 *F* 值的节点。
- en: Check whether the current node is already at the target node. If so, exit the
    `while` loop and build the path array.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前节点是否已经到达目标节点。如果是，退出 `while` 循环并构建路径数组。
- en: Create an array list to store the neighboring nodes of the current node being
    processed. Then, use the `GetNeighbours` method to retrieve the neighbors from
    the grid.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For every node in the array of neighbors, we check whether it's already in `closedList`.
    If not, we calculate the cost values, update the node properties with the new
    cost values and the parent node data, and put it in `openList`.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the current node to `closedList` and remove it from `openList`.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to *step I*.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there are no more nodes in `openList`, the current node should be at the
    target node if there''s a valid path available:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we call the `CalculatePath` method with the current node parameter:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `CalculatePath` method traces through each node's parent `node` object and
    builds an array list. Since we want a path array from the start node to the target
    node, we just call the `Reverse` method.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we'll write a test script to test this and set up a demo scene.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The TestCode class
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TestCode` class uses the `AStar` class to find the path from the start
    node to the target node, as shown in the following code from the `TestCode.cs`
    file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we first set up the variables that we need to reference.
    The `pathArray` variable stores the nodes array that's returned from the `AStar`
    `FindPath` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we use the `Start` method to look for objects
    with the tags `Start` and `End` and initialize `pathArray`. We are trying to find
    a new path at every interval, specified by the `intervalTime` property, in case
    the positions of the start and end nodes have changed. Finally, we call the `FindPath`
    method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since we implemented our pathfinding algorithm in the `AStar` class, finding
    a path is much simpler. In the following snippet, we first take the positions
    of the start and end game objects. Then, we create new `Node` objects using the
    `GetGridIndex` helper methods in `GridManager` to calculate their respective row
    and column index positions inside the grid.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we call the `AStar.FindPath` method with the start node and target
    node, storing the returned array list in the local `pathArray` property. Finally,
    we implement the `OnDrawGizmos` method to draw and visualize the resulting path:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We look through our `pathArray` and use the `Debug.DrawLine` method to draw
    the lines, connecting the nodes in `pathArray`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we run and test our program, we should see a green line connecting the
    nodes from start to end.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the scene
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to set up a scene that looks like the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Our sample test scene with obstacles'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_1.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Our sample test scene with obstacles
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow a step-by-step procedure to do this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a directional light, the start and end game object, a few obstacle
    objects, a plane entity to be used as ground, and two empty game objects in which
    we put the `GridManager` and `TestAStar` scripts. After this step, our scene hierarchy
    should be like this:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个方向光、起点和终点游戏对象、几个障碍物对象、一个用作地面的平面实体，以及两个空的游戏对象，我们将 `GridManager` 和 `TestAStar`
    脚本放入其中。完成此步骤后，我们的场景层次结构应该如下所示：
- en: '![Figure 7.2 – The demo scene hierarchy'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 演示场景层次结构'
- en: '](img/B17984_07_2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_07_2.png)'
- en: Figure 7.2 – The demo scene hierarchy
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 演示场景层次结构
- en: 'We create a bunch of cube entities and add them to the `GridManager` looks
    for objects with this tag when it creates the grid world representation:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一组立方体实体并将它们添加到 `GridManager`，当它创建网格世界表示时查找具有此标签的对象：
- en: '![Figure 7.3 – The Obstacle nodes seen in the Inspector'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 在检查器中看到的障碍节点'
- en: '](img/B17984_07_3.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_07_3.jpg)'
- en: Figure 7.3 – The Obstacle nodes seen in the Inspector
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 在检查器中看到的障碍节点
- en: 'We then create a cube entity and tag it as **Start**:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个立方体实体并将其标记为 **起点**：
- en: '![Figure 7.4 – The Start node seen in the Inspector'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 在检查器中看到的起点节点'
- en: '](img/B17984_07_4.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_07_4.jpg)'
- en: Figure 7.4 – The Start node seen in the Inspector
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 在检查器中看到的起点节点
- en: 'Then, we create another cube entity and tag it as **End**:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建另一个立方体实体并将其标记为 **终点**：
- en: '![Figure 7.5 – The End node seen in the Inspector'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 在检查器中看到的终点节点'
- en: '](img/B17984_07_5.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_07_5.jpg)'
- en: Figure 7.5 – The End node seen in the Inspector
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 在检查器中看到的终点节点
- en: We create an empty game object, and we attach the `GridManager` script to it.
    We also set the name to `GridManager` because we use this name to look for the
    `GridManager` object from inside the other scripts.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个空的游戏对象，并将 `GridManager` 脚本附加到它上。我们还设置了名称为 `GridManager`，因为我们使用此名称从其他脚本中查找
    `GridManager` 对象。
- en: Then, we set up the number of rows and columns of the grid and the size of each
    tile.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置了网格的行数和列数以及每个瓦片的尺寸。
- en: '![Figure 7.6 – GridManager script'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – GridManager 脚本'
- en: '](img/B17984_07_6.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_07_6.jpg)'
- en: Figure 7.6 – GridManager script
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – GridManager 脚本
- en: Testing the pathfinder
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试寻路器
- en: 'Once we hit the **Play** button, we should see the A* pathfinding algorithm
    in action. By default, once you play the scene, Unity3D switches to the **Game**
    view. However, since our pathfinding visualization code draws in the debug editor
    view, to see the found path, you need to switch back to the **Scene** view or
    enable **Gizmos** visualization:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按下 **播放** 按钮，我们应该能看到 A* 寻路算法的实际运行。默认情况下，一旦播放场景，Unity3D 会切换到 **游戏** 视图。然而，由于我们的寻路可视化代码在调试编辑器视图中绘制，要看到找到的路径，您需要切换回
    **场景** 视图或启用 **Gizmos** 可视化：
- en: '![Figure 7.7 – The ﬁrst path found by the algorithm'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 算法找到的第一个路径'
- en: '](img/B17984_07_7.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_07_7.jpg)'
- en: Figure 7.7 – The ﬁrst path found by the algorithm
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 算法找到的第一个路径
- en: 'Now, try to move the start or end node around in the scene using the editor''s
    movement gizmo (not in the **Game** view, but the **Scene** view):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用编辑器的移动 Gizmo 在场景中移动起点或终点节点（不在 **游戏** 视图中，而是在 **场景** 视图中）：
- en: '![Figure 7.8 – A second path found by the algorithm'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 算法找到的第二个路径'
- en: '](img/B17984_07_8.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_07_8.jpg)'
- en: Figure 7.8 – A second path found by the algorithm
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 算法找到的第二个路径
- en: You should see that the path is updated dynamically in real time. On the other
    hand, if there is no available path, you get an error message in the console window
    instead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到路径在实时中动态更新。另一方面，如果没有可用的路径，您将在控制台窗口中收到错误消息。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement the A* pathfinding algorithm in
    Unity3D. First, we implemented our own A* pathfinding class, grid representation
    class, priority queue class, and node class. Finally, we used debug draw functionalities
    to visualize the grid and path information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 Unity3D 中实现 A* 寻路算法。首先，我们实现了自己的 A* 寻路类、网格表示类、优先队列类和节点类。最后，我们使用调试绘制功能来可视化网格和路径信息。
- en: In later chapters, we will see that thanks to Unity3D's **NavMesh** and **NavAgent**
    features, it may not be necessary for you to implement a custom pathfinding algorithm
    on your own.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将看到，由于 Unity3D 的 **NavMesh** 和 **NavAgent** 功能，您可能不需要自己实现自定义寻路算法。
- en: Nonetheless, understanding a basic pathfinding algorithm gives you a better
    foundation for getting to grips with many other advanced pathfinding techniques.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，理解基本寻路算法为您掌握许多其他高级寻路技术提供了更好的基础。
- en: 'In the next chapter, we will extend the idea behind the A* algorithm to a more
    complex world representation: navigation meshes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把A*算法背后的思想扩展到更复杂的场景表示：导航网格。
