- en: '*Chapter 7*: A* Pathfinding'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement the **A* algorithm** in Unity3D using C#.
    The A* pathfinding algorithm is widely used in games and interactive applications
    because of its simplicity and effectiveness. We talked about this algorithm previously
    in *Chapter 1*, *Introduction to AI*. However, here, we'll review the algorithm
    again, this time from an implementation perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the A* algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the A* algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the pathfinder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 7` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the A* algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's review the A* algorithm before we proceed to implement it in the next
    section. The foundation of any pathfinding algorithm is a representation of the
    world. Pathfinding algorithms cannot search over the noisy structure of polygons
    in the game map; instead, we need to provide them with a simplified version of
    the world. Using this simplified structure, we can identify the locations that
    an agent can traverse, as well as the inaccessible ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways of doing this; however, for this example, we use one of
    the most straightforward solutions: a 2D grid. Therefore, we implement the `GridManager`
    class to convert the "real" map into a 2D tile representation. The `GridManager`
    class keeps a list of `Node` objects representing a single tile in the 2D grid.
    First, of course, we need to implement the `Node` class too: this class stores
    node information such as its position, whether it''s a traversable node or an
    obstacle, the cost to pass through, and the cost to reach the target node.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a world representation, we implement an `AStar` class for the actual
    A* pathfinding algorithm. The class is elementary; the `FindPath` method includes
    all the work. The class has two variables to keep track of the already visited
    nodes and the nodes that will be explored. We call these variables the `PriorityQueue`
    class because we want to get `Node` with the lowest score as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the closed list wants a data structure that allows us to efficiently
    check whether it contains a specific `Node`: usually, a data structure called
    a **set** is a good choice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the A* pseudocode is outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the algorithm takes the starting node and puts it in the open list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As long as the open list is not empty, the algorithm proceeds to perform the
    following steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It picks the first node from the open list and defines it as the current node
    (of course, we are assuming that we are using PriorityQueues for the open list).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it gets the neighboring nodes of this current node, excluding obstacle
    types (such as a wall or canyon that can't be passed through). This step is usually
    called expansion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each neighbor node in step 4, it checks whether it is already in the closed
    list. If not, it calculates the total cost (*F*) for this neighbor node using
    the following formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_011.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *G* is the total cost from the starting node to this node (usually computed
    by adding the cost of moving from parent to neighbor to the *G* value of the parent
    node), and *H* is the estimated total cost from this node to the final target
    node. We will go over the problem of estimating the cost in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm stores that cost data in the neighbor `node` object, and it assigns
    the current node as the neighbor's parent node. Later, we use this parent node
    data to trace back the starting node from the end node, thus reconstructing the
    actual path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It puts this neighbor node in the open list. The open list is a priority queue
    ordered by the *F* value; therefore, the first node in the open list is always
    the one with the lowest *F* value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no more neighbor nodes to process, the algorithm puts the current
    node in the closed list and removes it from the open list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm goes back to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have completed this algorithm, if there's an obstacle-free path to
    reach the target node from the start node, your current node is precisely at the
    target node position. Otherwise, this means that there's no available path to
    the target node from the current node position.
  prefs: []
  type: TYPE_NORMAL
- en: When we get a valid path, we have to trace back from the current node using
    the parent pointer until we reach the start node again. This procedure gives us
    a path listing all the nodes we chose during our pathfinding process, ordered
    from the target node to the start node. As a final step, we just reverse this
    path list and get the path in the proper order.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will implement A* in Unity3D using C#. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the A* algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we implement the basic classes that we introduced before, such as the
    `Node` class, the `GridManager` class, and the `PriorityQueue` class. Then, we
    use them in the main `AStar` class.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Node` class represents each tile object in the 2D grid. Its code is shown
    in the `Node.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Node` class stores every valuable property we need for finding a path.
    We are talking about properties such as the cost from the starting point (`costSoFar`),
    the total estimated cost from start to end (`fScore`), a flag to mark whether
    it is an obstacle, its positions, and its parent node. `costSoFar` is *G*, which
    is the movement cost value from the starting node to this node so far, and `fScore`
    is obviously *F*, which is the total estimated cost from the start to the target
    node. We also have two simple constructor methods and a wrapper method to set,
    depending on whether this node is an obstacle or not. Then, we implement the `Equals`
    and `GetHashCode` methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These methods are important. In fact, even if the `Node` class has multiple
    attributes, two nodes that represent the same position should be considered equal
    as far as the search algorithm is concerned. The way to do that is to override
    the default `Equals` and `GetHashCode` methods, as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: PriorityQueue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **priority queue** is an ordered data structure designed so that the first
    element (the head) of the list is always the smallest or largest element (depending
    on the implementation). This data structure is the most efficient way to handle
    the nodes in the open list because, as we will see later, we need to quickly retrieve
    the node with the lowest *F* value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there is no easy out-of-the-box way to have a suitable priority
    queue (at least, until Unity supports .NET 6). The code we will use for this is
    shown in the following `NodePriorityQueue.cs` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is not particularly efficient because it relies on the `Sort`
    method to reorder the internal list of nodes after each insertion. This means
    that inserting a node becomes increasingly costly the more nodes we have in the
    queue. If you need better performance, you can find many priority queue implementations
    designed for A* and search algorithms (such as the one you can find at [https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp](https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp)).
  prefs: []
  type: TYPE_NORMAL
- en: For now, though, our small `NodePriorityQueue` class will do its job nicely.
    The class is self-explanatory. The only thing you need to pay attention to is
    the `Enqueue` method. Before adding a new node, we need to check whether there
    is already a node with the same position but a lower F-score. If there is, we
    do nothing (we already have a *better* node in the queue). If not, this means
    that the new node we are adding is better than the old one. Therefore, we can
    remove the old one to ensure that we only have the best node possible for each
    position.
  prefs: []
  type: TYPE_NORMAL
- en: The GridManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GridManager` class handles the 2D grid representation for the world map.
    We keep it as a singleton instance of the `GridManager` class, as we only need
    one object to represent the map. A singleton is a programming pattern that restricts
    the instantiation of a class to one object and, therefore, it makes the instance
    easily accessible from any point of the application. The code for setting up `GridManager`
    is shown in the `GridManager.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the class implements the `GridManager` object in the scene
    and, if we find it, we store it in the `staticInstance` static variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we declare all the variables that we need to represent our map. `numOfRows`
    and `numOfColumns` store the number of rows and columns of the grid. `gridCellSize`
    represents the size of each grid. `obstacleEpsilon` is the margin for the system
    we will use to detect obstacles (more on that later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we have two Boolean variables to enable or disable the debug visualization
    of the grid and obstacles. Finally, we have a grid of `nodes` representing the
    map itself. We also add two properties to get the grid''s origin in world coordinates
    (`Origin`) and the cost of moving from one tile to the other (`StepCost`). The
    final product is shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to build the grid. For this, we use the `ComputeGrid` method that
    we call on `Awake`. The code is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ComputeGrid` function follows a simple algorithm. First, we just initialize
    the `nodes` grid. Then we start iterating over each square of the grid (represented
    by the coordinates `i` and `j`). For each square, we do as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we create a new node positioned at the center of the square (in world
    coordinates).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we check whether that square is occupied by an obstacle. We do this by
    using the `OverlapSphere` function. This `Physics` function returns all the colliders
    inside or intersecting the sphere defined in the parameters. In our case, we center
    the sphere at the center of the grid's cell (`cellPos`) and we define the sphere's
    radius as a bit less than the grid cell size. Note that we are only interested
    in colliders in the `Obstacles` layer, therefore we need to add the appropriate
    layer mask.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `OverlapSphere` function returns anything, this means that we have an
    obstacle inside the cell and, therefore, we define the entire cell as an obstacle.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GridManager` also has several helper methods to traverse the grid and get
    the grid cell data. We show some of them in the following list, with a brief description
    of what they do. The implementation is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetGridCellCenter` method returns the position of the grid cell in world
    coordinates from the cell coordinates, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `IsInBounds` method checks whether a certain position in the game falls
    inside the grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `IsTraversable` method checks whether a grid coordinate is traversable
    (that is, it is not an obstacle):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another important method is `GetNeighbours`, which is used by the `AStar` class
    to retrieve the neighboring nodes of a particular node. This is done by obtaining
    the grid coordinate of the node and then checking whether the four neighbors''
    coordinates (up, down, left, and right) are traversable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have debug aid methods used to visualize the grid and obstacle
    blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Gizmos can be used to draw visual debugging and setup aids inside the editor
    scene view. `OnDrawGizmos` is called every frame by the engine. So, if the debug
    flags, `showGrid` and `showObstacleBlocks`, are checked, we just draw the grid
    with lines and the obstacle cube objects with cubes. We won't go through the `DebugDrawGrid`
    method, as it's pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about gizmos in the following Unity3D reference documentation:
    [https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The AStar class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AStar` class implements the pathfinding algorithm using the classes we
    have implemented so far. If you want a quick review of the A* algorithm, see the
    *Revisiting the A* algorithm* section earlier in this chapter. The steps for the
    implementation of `AStar` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by implementing a method called `HeuristicEstimateCost` to calculate
    the cost between the two nodes. The calculation is simple. We just find the direction
    vector between the two by subtracting one position vector from another. The magnitude
    of this resultant vector gives the straight-line distance from the current node
    to the target node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Info
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In theory, you can replace this function with any function, returning the distance
    between `curNode` and `goalNode`. However, for A* to return the shortest possible
    path, this function must be admissible. In short, an admissible heuristic function
    is a function that never overestimates the actual "real world" cost between `curNode`
    and `goalNode`. As an exercise, you can easily verify that the function we use
    in this demo is admissible. For more information on the math behind heuristic
    functions, you can visit [https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html](https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we have the main A* algorithm in the `FindPath` method. In the following
    snippet, we initialize the open and closed lists. Starting with the start node,
    we put it in our open list. Then, we start processing our open list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we proceed with the main algorithm loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code implementation strictly follows the algorithm that we have
    discussed previously, so you can refer back to it if something is not clear:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the first node from our `openList`. Remember, `openList` is always sorted
    in increasing order. Therefore, the first node is always the node with the lowest
    *F* value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the current node is already at the target node. If so, exit the
    `while` loop and build the path array.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array list to store the neighboring nodes of the current node being
    processed. Then, use the `GetNeighbours` method to retrieve the neighbors from
    the grid.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For every node in the array of neighbors, we check whether it's already in `closedList`.
    If not, we calculate the cost values, update the node properties with the new
    cost values and the parent node data, and put it in `openList`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the current node to `closedList` and remove it from `openList`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to *step I*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there are no more nodes in `openList`, the current node should be at the
    target node if there''s a valid path available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we call the `CalculatePath` method with the current node parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CalculatePath` method traces through each node's parent `node` object and
    builds an array list. Since we want a path array from the start node to the target
    node, we just call the `Reverse` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we'll write a test script to test this and set up a demo scene.
  prefs: []
  type: TYPE_NORMAL
- en: The TestCode class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TestCode` class uses the `AStar` class to find the path from the start
    node to the target node, as shown in the following code from the `TestCode.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we first set up the variables that we need to reference.
    The `pathArray` variable stores the nodes array that's returned from the `AStar`
    `FindPath` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we use the `Start` method to look for objects
    with the tags `Start` and `End` and initialize `pathArray`. We are trying to find
    a new path at every interval, specified by the `intervalTime` property, in case
    the positions of the start and end nodes have changed. Finally, we call the `FindPath`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since we implemented our pathfinding algorithm in the `AStar` class, finding
    a path is much simpler. In the following snippet, we first take the positions
    of the start and end game objects. Then, we create new `Node` objects using the
    `GetGridIndex` helper methods in `GridManager` to calculate their respective row
    and column index positions inside the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we call the `AStar.FindPath` method with the start node and target
    node, storing the returned array list in the local `pathArray` property. Finally,
    we implement the `OnDrawGizmos` method to draw and visualize the resulting path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We look through our `pathArray` and use the `Debug.DrawLine` method to draw
    the lines, connecting the nodes in `pathArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When we run and test our program, we should see a green line connecting the
    nodes from start to end.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to set up a scene that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Our sample test scene with obstacles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Our sample test scene with obstacles
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow a step-by-step procedure to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a directional light, the start and end game object, a few obstacle
    objects, a plane entity to be used as ground, and two empty game objects in which
    we put the `GridManager` and `TestAStar` scripts. After this step, our scene hierarchy
    should be like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The demo scene hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_2.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The demo scene hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a bunch of cube entities and add them to the `GridManager` looks
    for objects with this tag when it creates the grid world representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The Obstacle nodes seen in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – The Obstacle nodes seen in the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a cube entity and tag it as **Start**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The Start node seen in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The Start node seen in the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create another cube entity and tag it as **End**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The End node seen in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – The End node seen in the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: We create an empty game object, and we attach the `GridManager` script to it.
    We also set the name to `GridManager` because we use this name to look for the
    `GridManager` object from inside the other scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set up the number of rows and columns of the grid and the size of each
    tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – GridManager script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – GridManager script
  prefs: []
  type: TYPE_NORMAL
- en: Testing the pathfinder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we hit the **Play** button, we should see the A* pathfinding algorithm
    in action. By default, once you play the scene, Unity3D switches to the **Game**
    view. However, since our pathfinding visualization code draws in the debug editor
    view, to see the found path, you need to switch back to the **Scene** view or
    enable **Gizmos** visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The ﬁrst path found by the algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – The ﬁrst path found by the algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try to move the start or end node around in the scene using the editor''s
    movement gizmo (not in the **Game** view, but the **Scene** view):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – A second path found by the algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_07_8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – A second path found by the algorithm
  prefs: []
  type: TYPE_NORMAL
- en: You should see that the path is updated dynamically in real time. On the other
    hand, if there is no available path, you get an error message in the console window
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement the A* pathfinding algorithm in
    Unity3D. First, we implemented our own A* pathfinding class, grid representation
    class, priority queue class, and node class. Finally, we used debug draw functionalities
    to visualize the grid and path information.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will see that thanks to Unity3D's **NavMesh** and **NavAgent**
    features, it may not be necessary for you to implement a custom pathfinding algorithm
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, understanding a basic pathfinding algorithm gives you a better
    foundation for getting to grips with many other advanced pathfinding techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will extend the idea behind the A* algorithm to a more
    complex world representation: navigation meshes.'
  prefs: []
  type: TYPE_NORMAL
