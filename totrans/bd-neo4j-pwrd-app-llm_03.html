<html><head></head><body><div><div><p>&#13;
    <h1 class="chapterNumber"><a id="_idTextAnchor020"/>3</h1>&#13;
    <h1 id="_idParaDest-41" class="chapterTitle">Building a Foundational Understanding of Knowledge Graph for Intelligent Applications</h1>&#13;
    <p class="normal">In the previous chapter, we looked at what RAG is and at a few simple examples of how we can implement RAG flow, along with LLMs. In this chapter, we will take a look at what knowledge graphs <a id="_idIndexMarker114"/>are and how graphs can make <strong class="keyWord">Retrieval-Augmented Generation</strong> (<strong class="keyWord">RAG</strong>) more effective. We will explore how to model knowledge graphs and how Neo4j can be used for this purpose. We will look at how data modeling with the Neo4j data persistence approach can help build more powerful knowledge graphs. We will <a id="_idIndexMarker115"/>also look at data store persistence approaches, from <strong class="keyWord">Relational Database Management Systems</strong> (<strong class="keyWord">RDBMSs</strong>) to Neo4j knowledge graphs, to get a better understanding of data using various data models.</p>&#13;
    <p class="normal">We will embark on an exciting journey to understand how the fusion of RAG models and Neo4j’s robust graph database capabilities enables the creation of intelligent applications that leverage structured knowledge bases for enhanced performance and results.</p>&#13;
    <p class="normal">In this chapter, we are going to cover the following main topics:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Understanding the importance of graph data modeling</li>&#13;
      <li class="bulletList">Combining the power of RAG and Neo4j knowledge graphs with GraphRAG</li>&#13;
      <li class="bulletList">Enhancing knowledge graph</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-42" class="heading-1">Technical requirements</h1>&#13;
    <p class="normal">Before we dive into the practical aspects of building a knowledge graph for RAG integration with Neo4j, it is essential to set up the necessary tools and environments. Here are the technical requirements for this chapter:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Neo4j database</strong>: You can use Neo4j Desktop for a local setup or Neo4j Aura for a cloud-based <a id="_idIndexMarker116"/>solution. Download Neo4j Desktop from the Neo4j download center: <a href="https://neo4j.com/download/">https://neo4j.com/download/</a>. For Neo4j Aura, visit <a id="_idIndexMarker117"/>Neo4j Aura: <a href="https://neo4j.com/product/neo4j-graph-database/">https://neo4j.com/product/neo4j-graph-database/</a>. Neo4j offers two primary cloud-based services – AuraDB and AuraDS:<ul>&#13;
          <li class="bulletList"><strong class="screenText">AuraDB</strong> is a fully managed graph database service tailored for developers building intelligent applications. It supports flexible schemas, native storage of relationships, and efficient querying with the Cypher language. AuraDB offers <a id="_idIndexMarker118"/>a free tier, enabling users to explore graph data without incurring costs. Learn more about AuraDB at <a href="https://neo4j.com/product/auradb/">https://neo4j.com/product/auradb/</a>.</li>&#13;
          <li class="bulletList"><strong class="screenText">AuraDS</strong> is a fully <a id="_idIndexMarker119"/>managed Neo4j Graph Data Science instance that can be used to build data science applications. You can learn more about it at <a href="https://neo4j.com/docs/aura/graph-analytics/">https://neo4j.com/docs/aura/graph-analytics/</a>.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="bulletList"><strong class="screenText">DB Browser for SQLite</strong>: This tool is <a id="_idIndexMarker120"/>used to query SQLite databases easily <a href="https://sqlitebrowser.org/">https://sqlitebrowser.org/</a>.</li>&#13;
      <li class="bulletList"><strong class="screenText">Cypher query language</strong>: Before starting with this chapter, you will need to familiarize yourself with Cypher, Neo4j’s query language. Neo4j provides excellent Cypher tutorials. If you <a id="_idIndexMarker121"/>are unfamiliar with Cypher, Neo4j provides excellent tutorials and fundamental courses on GraphAcademy (<a href="https://graphacademy.neo4j.com/">https://graphacademy.neo4j.com/</a>) to help you get started. You can also<a id="_idIndexMarker122"/> read this book to learn about Cypher in detail: Graph Data Processing with Cypher (<a href="https://www.packtpub.com/en-us/product/graph-data-processing-with-cypher-9781804611074">https://www.packtpub.com/en-us/product/graph-data-processing-with-cypher-9781804611074</a>).</li>&#13;
      <li class="bulletList"><strong class="screenText">Python environment</strong>: Python 3.8 or higher is recommended. Ensure you have it installed. You <a id="_idIndexMarker123"/>can download it from the official Python website <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</li>&#13;
      <li class="bulletList"><strong class="screenText">Neo4j Python Driver</strong>: This allows you to <a id="_idIndexMarker124"/>interact with your Neo4j database from Python. Install it using <code class="inlineCode">pip</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code">pip install neo4j-driver&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList"><strong class="screenText">GitHub repository</strong>: All the code and resources for this chapter are available in the following GitHub repository: <a href="https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs">https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs</a>. Navigate to the <code class="inlineCode">ch3</code> folder for the specific content related to this chapter.</li>&#13;
    </ul>&#13;
    <p class="normal">Ensure you have all these tools and libraries installed and configured before proceeding. This setup will enable you to follow along with the examples and exercises seamlessly.</p>&#13;
    <h1 id="_idParaDest-43" class="heading-1">Understanding the importance of graph data modeling</h1>&#13;
    <p class="normal">Before we go ahead with looking at how <strong class="keyWord">GraphRAG flow</strong> works with Neo4j, let us take a step back and understand <a id="_idIndexMarker125"/>how we can model knowledge graphs. We will take some simple data and try to look at how we model that data in RDBMSs and graphs. We will also see how this modeling differs depending on how we see that data.</p>&#13;
    <p class="normal">Graphs force <a id="_idIndexMarker126"/>us to think in different ways and see the data from different perspectives depending on what we are trying to solve. While this might seem like a problem, it is actually opens a lot of doors. For a long time, we have been taught to think of the <a id="_idIndexMarker127"/>RDBMS storage approach in terms of <strong class="keyWord">Entity-Relationship</strong> (<strong class="keyWord">ER</strong>) diagrams. This approach was good for representing/persisting data when there were limitations in the technology, and storage costs were very high. With technologies evolving and hardware becoming cheaper, new avenues have opened and new approaches to model data are possible. Graphs are well suited to take advantage of this.</p>&#13;
    <p class="normal">To think about new ways of modeling data, we might have to unlearn some of the ways we are used to representing data using ER diagrams. While this seems simple, in reality, it might be a bit difficult. The learning and unlearning process is similar to in the neural plasticity prism goggles experiment, depicted in the following figure.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_1.png" alt="Figure 3.1 — Neural plasticity prism goggles experiment" width="455" height="483"/></figure>&#13;
    <p class="packt_figref">Figure 3.1 — Neural plasticity prism goggles experiment</p>&#13;
    <p class="normal">The experiment involves wearing prism goggles to perform a simple task. It takes some time for the mind to <a id="_idIndexMarker128"/>adjust to the shift in vision to perform the task correctly. When the participant takes off the goggles, it takes some time to be able to perform the same task again. It is the same with data modeling. We might have to unlearn a few of the approaches we used to rely on before we can build a better graph data model. You can read more about this experiment at <a href="https://sfa.cems.umn.edu/neural-plasticity-prism-goggle-experiment">https://sfa.cems.umn.edu/neural-plasticity-prism-goggle-experiment</a>.</p>&#13;
    <p class="normal">We will take a look at how we consume data in real life to understand whether there are any other approaches that can help us in building a good graph data model.</p>&#13;
    <p class="normal">For example, let us consider a library or a bookstore to understand how our data or information consumption drives how the books are laid out. In a library, the books are laid out by category and last name of the author. This is similar to how we leverage indexes to find data. But there may be other sections at the entrance of the library that highlight new releases and popular books. This is done to make sure people can find these quickly. Trying to model these aspects in an RDBMS is difficult. But the graph database approach in Neo4j makes it quite easy to do this by leveraging multiple labels. This enables graph databases to help us build a data model that helps with the easy and efficient consumption of data. With graphs, we might have to try and change our thought process and try a few different data modeling approaches. Our initial approaches may not be completely correct, but we need to keep adjusting the data models to get to an acceptable data model that works for us. With RDBMSs and other technologies, the data model is rigid, and not getting it right can have a huge impact. This is where Neo4j stands out. Its optional flexible schema approach helps us get started with a data model that might not be optimal in the beginning, but we can tune it incrementally without needing to start from scratch.</p>&#13;
    <p class="normal">We will take some small, simple data and look at data modeling with an RDBMS and graph. The data we will be trying to model looks as follows:</p>&#13;
    <ul>&#13;
      <li class="bulletList">A person with the following required details:&#13;
        <pre class="programlisting code"><code class="hljs-code">firstName&#13;
lastName&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">Five rentals the person has lived at, in the following format:&#13;
        <pre class="programlisting code"><code class="hljs-code">Address line 1&#13;
City&#13;
State&#13;
zipCode&#13;
fromTime&#13;
tillTime&#13;
</code></pre>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="normal">While this <a id="_idIndexMarker129"/>seems simple, it is enough for us to understand the nuances of how this data can be represented in an RDBMS and graph.</p>&#13;
    <p class="normal">These are the questions we would like to answer using this data:</p>&#13;
    <ul>&#13;
      <li class="bulletList">What is the latest address the person named <em class="italic">John Doe</em> is living at?</li>&#13;
      <li class="bulletList">What is the first address the person named <em class="italic">John Doe</em> lived at?</li>&#13;
      <li class="bulletList">What is the third address the person named <em class="italic">John Doe</em> lived at?</li>&#13;
    </ul>&#13;
    <p class="normal">Let’s take a look at how this data can be modeled in an RDBMS.</p>&#13;
    <h2 id="_idParaDest-44" class="heading-2">RDBMS data modeling</h2>&#13;
    <p class="normal">In this section, we will <a id="_idIndexMarker130"/>take a look at the RDBMS data <a id="_idIndexMarker131"/>modeling aspects of the sample data we defined previously. The following figure represents the data model as an ER diagram:</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_2.png" alt="Figure 3.2 — ER diagram" width="1021" height="259"/></figure>&#13;
    <p class="packt_figref">Figure 3.2 — ER diagram</p>&#13;
    <p class="normal">There are three tables in this data model. The <code class="inlineCode">Person</code> table contains the person details. The <code class="inlineCode">Address</code> table contains the address details. The <code class="inlineCode">Person_Address</code> table contains the rental details along with references to the <code class="inlineCode">Person</code> and <code class="inlineCode">Address</code> tables. We use this join table to represent the rental details, to avoid duplicating the data of <code class="inlineCode">Person</code> or <code class="inlineCode">Address</code> entities. We need to be extra <a id="_idIndexMarker132"/>sure of the details when we are building these data models, as changing them can be quite time-consuming, depending on how much we are changing. If we <a id="_idIndexMarker133"/>are splitting a table into multiple tables, then the data migration can be quite a task.</p>&#13;
    <p class="normal">You can use this tutorial to create the SQLite database: <a href="https://datacarpentry.org/sql-socialsci/02-db-browser.html">https://datacarpentry.org/sql-socialsci/02-db-browser.html</a>. We will use that SQLite database to load the data and validate queries to answer the questions we defined before.</p>&#13;
    <p class="normal">The following SQL script creates the tables:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">-- Person Table definition&#13;
<code style="font-weight: bold;" class="codeHighlighted">CREATE TABLE</code> IF NOT EXISTS <code style="font-weight: bold;" class="codeHighlighted">person</code> (&#13;
    <code style="font-weight: bold;" class="codeHighlighted">id</code> INTEGER PRIMARY KEY,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">name</code> varchar(100) NOT NULL,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">gender</code> varchar(20) ,&#13;
    UNIQUE(<code style="font-weight: bold;" class="codeHighlighted">id</code>)&#13;
) ;&#13;
-- Address table definition&#13;
<code style="font-weight: bold;" class="codeHighlighted">CREATE TABLE</code> IF NOT EXISTS <code style="font-weight: bold;" class="codeHighlighted">address</code> (&#13;
    <code style="font-weight: bold;" class="codeHighlighted">id</code> INTEGER PRIMARY KEY,&#13;
   <code style="font-weight: bold;" class="codeHighlighted">line1</code> varchar(100) NOT NULL,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">city</code> varchar(20) NOT NULL,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">state</code> varchar(20) NOT NULL,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">zip</code> varchar(20) NOT NULL,&#13;
    UNIQUE(<code style="font-weight: bold;" class="codeHighlighted">id</code>)&#13;
) ;&#13;
-- Person Address table definition&#13;
<code style="font-weight: bold;" class="codeHighlighted">CREATE TABLE</code> IF NOT EXISTS <code style="font-weight: bold;" class="codeHighlighted">person_address</code> (&#13;
    <code style="font-weight: bold;" class="codeHighlighted">person_id</code> INTEGER NOT NULL,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">address_id</code> INTEGER NOT NULL,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">start</code> varchar(20) NOT NULL,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">end</code> varchar(20) ,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">FOREIGN KEY</code> (<code style="font-weight: bold;" class="codeHighlighted">person_id</code>) REFERENCES person (<code style="font-weight: bold;" class="codeHighlighted">id</code>)&#13;
        ON DELETE CASCADE ON UPDATE NO ACTION,&#13;
    <code style="font-weight: bold;" class="codeHighlighted">FOREIGN KEY</code> (<code style="font-weight: bold;" class="codeHighlighted">address_id</code>) REFERENCES address (<code style="font-weight: bold;" class="codeHighlighted">id</code>)&#13;
        ON DELETE CASCADE ON UPDATE NO ACTION&#13;
) ;&#13;
</code></pre>&#13;
    <p class="normal">The next <a id="_idIndexMarker134"/>SQL script inserts the data into the <a id="_idIndexMarker135"/>tables:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">-- Insert Person Record&#13;
INSERT INTO person (id, name, gender) values <code style="font-weight: bold;" class="codeHighlighted">(1, 'John Doe', 'Male') ;</code>&#13;
-- Insert Address Records&#13;
INSERT INTO address (id, line1, city, state, zip) values<code style="font-weight: bold;" class="codeHighlighted"> (1, '1 first ln', 'Edison', 'NJ', '11111') ;</code>&#13;
INSERT INTO address (id, line1, city, state, zip) values <code style="font-weight: bold;" class="codeHighlighted">(2, '13 second ln', 'Edison', 'NJ', '11111') ;</code>&#13;
INSERT INTO address (id, line1, city, state, zip) values <code style="font-weight: bold;" class="codeHighlighted">(3, '13 third ln', 'Edison', 'NJ', '11111') ;</code>&#13;
INSERT INTO address (id, line1, city, state, zip) values <code style="font-weight: bold;" class="codeHighlighted">(4, '1 fourth ln', 'Edison', 'NJ', '11111') ;</code>&#13;
INSERT INTO address (id, line1, city, state, zip) values <code style="font-weight: bold;" class="codeHighlighted">(5, '5 other ln', 'Edison', 'NJ', '11111') ;</code>&#13;
-- Insert Person Address (Rental) Records&#13;
INSERT INTO person_address <code style="font-weight: bold;" class="codeHighlighted">(person_id, address_id, start, end) values (1,1,'2001-01-01', '2003-12-31') ;</code>&#13;
INSERT INTO person_address <code style="font-weight: bold;" class="codeHighlighted">(person_id, address_id, start, end) values (1,2,'2004-01-01', '2008-12-31') ;</code>&#13;
INSERT INTO person_address <code style="font-weight: bold;" class="codeHighlighted">(person_id, address_id, start, end) values (1,3,'2009-01-01', '2015-12-31') ;</code>&#13;
INSERT INTO person_address <code style="font-weight: bold;" class="codeHighlighted">(person_id, address_id, start, end) values (1,4,'2016-01-01', '2020-12-31') ;</code>&#13;
INSERT INTO person_address <code style="font-weight: bold;" class="codeHighlighted">(person_id, address_id, start, end) values (1,5,'2021-01-01', null) ;</code>&#13;
</code></pre>&#13;
    <p class="normal">Once we <a id="_idIndexMarker136"/>load the <a id="_idIndexMarker137"/>data, it will look like this.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_3.png" alt="Figure 3.3 — Data stored in an RDBMS" width="984" height="685"/></figure>&#13;
    <p class="packt_figref">Figure 3.3 — Data stored in an RDBMS</p>&#13;
    <p class="normal">We will now see how we can query data from the RDBMS:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 1 – Get the latest address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">Let’s take a look at the following SQL query to answer the first question:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">SELECT line1, city, state, zip from&#13;
person p, person_address pa, address a&#13;
WHERE p.name = <code style="font-weight: bold;" class="codeHighlighted">'John Doe'</code>&#13;
    and pa.person_id = p.id&#13;
    and pa.address_id = a.id&#13;
    and pa.end is <code style="font-weight: bold;" class="codeHighlighted">null</code>&#13;
</code></pre>&#13;
    <p class="normal">From the query, we can see that we are relying on the end column value to be null to determine which is the latest address. This is the logic to determine what the last address is in the SQL query.</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 2</strong><strong class="screenText"> </strong><strong class="screenText">– Get the first address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">We will take a look at the SQL query to answer the second question:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">SELECT line1, city, state, zip from&#13;
person p, person_address pa, address a&#13;
WHERE p.name = <code style="font-weight: bold;" class="codeHighlighted">'</code><code style="font-weight: bold;" class="codeHighlighted">John Doe'</code>&#13;
    and pa.person_id = p.id&#13;
    and pa.address_id = a.id&#13;
<code style="font-weight: bold;" class="codeHighlighted">ORDER BY pa.start ASC</code>&#13;
<code style="font-weight: bold;" class="codeHighlighted">LIMIT 1</code>&#13;
</code></pre>&#13;
    <p class="normal">From the <a id="_idIndexMarker138"/>query, we can see that we are <a id="_idIndexMarker139"/>relying on the search-sort-filter pattern to get to the data we want, with the logic in the SQL query.</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 3 – Get the third address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">We will take a look at SQL query to answer the third question:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">SELECT line1, city, state, zip from&#13;
person p, person_address pa, address a&#13;
WHERE p.name = 'John Doe'&#13;
    and pa.person_id = p.id&#13;
    and pa.address_id = a.id&#13;
<code style="font-weight: bold;" class="codeHighlighted">ORDER BY pa.start ASC</code>&#13;
<code style="font-weight: bold;" class="codeHighlighted">LIMIT 2, 1</code>&#13;
</code></pre>&#13;
    <p class="normal">Again, in this query also we can see that we are relying on the pattern <em class="italic">Search-Sort-Filter</em> to get to the data we wanted.</p>&#13;
    <p class="normal">We will now look at how this data can be modeled with graphs.</p>&#13;
    <h2 id="_idParaDest-45" class="heading-2">Graph data modeling: basic approach</h2>&#13;
    <p class="normal">For illustration <a id="_idIndexMarker140"/>purposes, we will use the most common and simplest way to model this data in a graph.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_4.png" alt="Figure 3.4 — Basic graph data model" width="1210" height="202"/></figure>&#13;
    <p class="packt_figref">Figure 3.4 — Basic graph data model</p>&#13;
    <p class="normal">This aligns with how we normally express the information in English:</p>&#13;
    <p class="normal"><strong class="screenText">Person</strong> <em class="italic">lives at</em> <strong class="screenText">Address</strong></p>&#13;
    <p class="normal">In this sentence, the <strong class="keyWord">nouns</strong> are represented as <strong class="keyWord">nodes</strong>, and the <strong class="keyWord">verb</strong> is represented as a <strong class="keyWord">relationship</strong>. This data model approach is pretty simple and almost resembles the ER diagram of the RDBMS data model. The only difference here is that the join table that represents the rental is modeled as a relationship. The advantage of this type of data persistence is that it reduces the <a id="_idIndexMarker141"/>index lookup cost. In RDBMSs, the biggest cost in terms of data retrieval is the join table’s index lookup cost. As the data size increases, that lookup cost keeps on increasing. We can reduce that cost with this approach.</p>&#13;
    <div>&#13;
      <p class="normal"> <strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">You can use this tutorial to create the Neo4j database if you are using Neo4j <br/>Desktop: <a href="https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/">https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/</a>.</p>&#13;
      <p class="normal">Alternatively, you can use this tutorial to create a database in the cloud: <a href="https://neo4j.com/docs/aura/auradb/getting-started/create-database/">https://neo4j.com/docs/aura/auradb/getting-started/create-database/</a>. There is a free option available. This would be optimal for those who may not or do not want to install Neo4j Desktop locally. Neo4j Aura is a fully managed graph-database-as-a-service solution.</p>&#13;
    </p>&#13;
    <p class="normal">Let’s look at the following graph queries to understand this.</p>&#13;
    <p class="normal">The following Cypher script sets up the indexes for faster data load and retrieval. This can be thought of as a schema:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CREATE CONSTRAINT person_id_idx FOR (n:Person) REQUIRE n.id IS UNIQUE ;&#13;
CREATE CONSTRAINT address_id_idx FOR (n:Address) REQUIRE n.id IS UNIQUE ;&#13;
CREATE INDEX person_name_idx FOR (n:Person) ON n.name ;&#13;
</code></pre>&#13;
    <p class="normal">This Cypher script creates two unique constraints to make sure we don’t have duplicate <strong class="screenText">Person</strong> and <strong class="screenText">Address</strong> nodes. We also added an index to speed up the person lookup using the name.</p>&#13;
    <p class="normal">Once the schema is set up, we can use this Cypher script to load the data into Neo4j:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CREATE (p:Person {<code style="font-weight: bold;" class="codeHighlighted">id:1, name:'John Doe', gender:'Male'</code>})&#13;
CREATE (a1:Address {<code style="font-weight: bold;" class="codeHighlighted">id:1, line1:'1 first ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (a2:Address {<code style="font-weight: bold;" class="codeHighlighted">id:2, line1:'13 second ln', city:'Edison', state:'NJ', </code><code style="font-weight: bold;" class="codeHighlighted"></code><code style="font-weight: bold;" class="codeHighlighted">zip:'11111'</code>})&#13;
CREATE (a3:Address {<code style="font-weight: bold;" class="codeHighlighted">id:3, line1:'13 third ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (a4:Address {<code style="font-weight: bold;" class="codeHighlighted">id:4, line1:'1 fourth ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (a5:Address {<code style="font-weight: bold;" class="codeHighlighted">id:5, line1:'5 other ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (p)-[:HAS_ADDRESS {<code style="font-weight: bold;" class="codeHighlighted">start:'2001-01-01', end:'2003-12-31'</code>}]-&gt;(a1)&#13;
CREATE (p)-[:HAS_ADDRESS {<code style="font-weight: bold;" class="codeHighlighted">start:'2004-01-01', end:'2008-12-31'</code>}]-&gt;(a2)&#13;
CREATE (p)-[:HAS_ADDRESS {<code style="font-weight: bold;" class="codeHighlighted">start:'2009-01-01', end:'2015-12-31'</code>}]-&gt;(a3)&#13;
CREATE (p)-[:HAS_ADDRESS {<code style="font-weight: bold;" class="codeHighlighted">start:'2016-01-01', end:'2020-12-31'</code>}]-&gt;(a4)&#13;
CREATE (p)-[:HAS_ADDRESS {<code style="font-weight: bold;" class="codeHighlighted">start:'2021-01-01'</code>}]-&gt;(a5)&#13;
</code></pre>&#13;
    <p class="normal">Once we <a id="_idIndexMarker142"/>load the data, it looks like this in the graph.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_5.png" alt="Figure 3.5 — Representation of Person Rentals using graph data modeling, basic approach" width="1210" height="1100"/></figure>&#13;
    <p class="packt_figref">Figure 3.5 — Representation of Person Rentals using graph data modeling, basic approach</p>&#13;
    <p class="normal">Now, we will <a id="_idIndexMarker143"/>create the Cypher queries analogous to the retrievals we performed  with the RDBMS queries in the previous section:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 1 – Get the latest address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">The following Cypher query gets us the latest address:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (p:Person {name:<code style="font-weight: bold;" class="codeHighlighted">'John Doe'</code>})-[r:HAS_ADDRESS]-&gt;(a)&#13;
WHERE r.end is <code style="font-weight: bold;" class="codeHighlighted">null</code>&#13;
RETURN a&#13;
</code></pre>&#13;
    <p class="normal">If we look at this query, it is much simpler than the SQL query we saw earlier. Still, the result depends on how we mark the last address, by not having the <code class="inlineCode">end</code> property set on the relationship. So, the logic to know what the last address is still part of the query, like in the SQL query. We can see that we are checking the values in the relationship and trying to use indexes, as shown in the following code, on the join table:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">and pa.person_id = p.id&#13;
and pa.address_id = a.id&#13;
</code></pre>&#13;
    <p class="normal">Just avoiding these indexes itself can get us better performance.</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 2 – Get the first address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">This Cypher fetches us the first address:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (p:Person {<code style="font-weight: bold;" class="codeHighlighted">name:'John Doe'</code>})-[r:HAS_ADDRESS]-&gt;(a)&#13;
WITH r, a&#13;
<code style="font-weight: bold;" class="codeHighlighted">ORDER BY r.start ASC</code>&#13;
WITH r,a&#13;
RETURN a&#13;
<code style="font-weight: bold;" class="codeHighlighted">LIMIT 1</code>&#13;
</code></pre>&#13;
    <p class="normal">From the query, we can <a id="_idIndexMarker144"/>see that we are relying on the search-sort-filter pattern to get to the data we want, similar to the SQL query. The logic to determine what the first address is part of the Cypher query.</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 3 – Get the third address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">This Cypher gets us the third address:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (p:Person {<code style="font-weight: bold;" class="codeHighlighted">name:'John Doe'</code>})-[r:HAS_ADDRESS]-&gt;(a)&#13;
WITH r, a&#13;
<code style="font-weight: bold;" class="codeHighlighted">ORDER BY r.start ASC</code>&#13;
WITH r,a&#13;
RETURN a&#13;
<code style="font-weight: bold;" class="codeHighlighted">SKIP 2</code>&#13;
<code style="font-weight: bold;" class="codeHighlighted">LIMIT 1</code>&#13;
</code></pre>&#13;
    <p class="normal">Similar to the previous query, we had to rely on search-sort-filter to get to the data we wanted. The logic to determine what the third address is part of the Cypher query.</p>&#13;
    <p class="normal">Next, we will dive into a more nuanced approach to graph data modeling.</p>&#13;
    <h2 id="_idParaDest-46" class="heading-2">Graph data modeling: advanced approach</h2>&#13;
    <p class="normal">We will look at this data differently and build a data model. This model is influenced by how we consume the data.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_6.png" alt="Figure 3.6 — Representation of Person Rentals using graph data modeling, consumption approach" width="1210" height="282"/></figure>&#13;
    <p class="packt_figref">Figure 3.6 — Representation of Person Rentals using graph data modeling, consumption approach</p>&#13;
    <p class="normal">At first look, this looks <a id="_idIndexMarker145"/>closer to the RDBMS ER diagram. We have <strong class="screenText">Person</strong>, <strong class="screenText">Address</strong>, and <strong class="screenText">Rental</strong> nodes. That’s where the similarity ends. We can see that <strong class="screenText">Person</strong> is connected to the <strong class="screenText">Rental</strong> node via a <strong class="screenText">FIRST</strong> or <strong class="screenText">LATEST</strong> relationship. <strong class="screenText">Rental</strong> may have a <strong class="screenText">NEXT</strong> relationship to another <strong class="screenText">Rental</strong> node. The <strong class="screenText">Rental</strong> node is connected to an <strong class="screenText">Address</strong>, too. The model might look a bit complex. Once we load the data and see how it is connected, it makes more sense.</p>&#13;
    <p class="normal">This Cypher script sets up the indexes for faster data load and retrieval:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CREATE CONSTRAINT person_id_idx FOR (n:Person) REQUIRE n.id IS UNIQUE ;&#13;
CREATE CONSTRAINT address_id_idx FOR (n:Address) REQUIRE n.id IS UNIQUE ;&#13;
CREATE INDEX person_name_idx FOR (n:Person) ON n.name ;&#13;
</code></pre>&#13;
    <p class="normal">We can see the indexes are the same as in the previous model. We have not added any indexes or constraints to the <strong class="screenText">Rental</strong> node.</p>&#13;
    <p class="normal">This Cypher script loads the data into Neo4j:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CREATE (p:Person {<code style="font-weight: bold;" class="codeHighlighted">id:1, name:'John Doe', gender:'Male'</code>})&#13;
CREATE (a1:Address {<code style="font-weight: bold;" class="codeHighlighted">id:1, line1:'1 first ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (a2:Address {<code style="font-weight: bold;" class="codeHighlighted">id:2, line1:'13 second ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (a3:Address {<code style="font-weight: bold;" class="codeHighlighted">id:3, line1:'13 third ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (a4:Address {<code style="font-weight: bold;" class="codeHighlighted">id:4, line1:'1 fourth ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (a5:Address {<code style="font-weight: bold;" class="codeHighlighted">id:5, line1:'5 other ln', city:'Edison', state:'NJ', zip:'11111'</code>})&#13;
CREATE (p)-[<code style="font-weight: bold;" class="codeHighlighted">:FIRST</code>]-&gt;(r1:Rental {<code style="font-weight: bold;" class="codeHighlighted">start:'2001-01-01', end:'2003-12-31'</code>})-[:HAS_ADDRESS]-&gt;(a1)&#13;
CREATE (r1)-[<code style="font-weight: bold;" class="codeHighlighted">:NEXT</code>]-&gt;(r2:Rental {<code style="font-weight: bold;" class="codeHighlighted">start:'2004-01-01', end:'2008-12-31'</code>})-[:HAS_ADDRESS]-&gt;(a2)&#13;
CREATE (r2)-[<code style="font-weight: bold;" class="codeHighlighted">:NEXT</code>]-&gt;(r3:Rental {<code style="font-weight: bold;" class="codeHighlighted">start:'2009-01-01', end:'2015-12-31'</code>})-[:HAS_ADDRESS]-&gt;(a3)&#13;
CREATE (r3)-[<code style="font-weight: bold;" class="codeHighlighted">:NEXT</code>]-&gt;(r4:Rental {<code style="font-weight: bold;" class="codeHighlighted">start:'2016-01-01', end:'2020-12-31'</code>})-[:HAS_ADDRESS]-&gt;(a4)&#13;
CREATE (r4)-[<code style="font-weight: bold;" class="codeHighlighted">:NEXT</code>]-&gt;(r5:Rental {<code style="font-weight: bold;" class="codeHighlighted">start:'2021-01-01'</code>})-[:HAS_ADDRESS]-&gt;(a5)&#13;
CREATE (p)-[<code style="font-weight: bold;" class="codeHighlighted">:LATEST</code>]-&gt;(r5)&#13;
</code></pre>&#13;
    <p class="normal">Once the <a id="_idIndexMarker146"/>data is loaded, it will look like this in the graph (<em class="italic">Figure 3.7</em>).</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_7.png" alt="Figure 3.7 — Representation of Person Rentals with a Rental sequence graph" width="1266" height="1182"/></figure>&#13;
    <p class="packt_figref">Figure 3.7 — Representation of Person Rentals with a Rental sequence graph</p>&#13;
    <p class="normal">We can see <a id="_idIndexMarker147"/>that the data stored in the graph is way different from before. <strong class="screenText">Person</strong> is connected to only the first and last rentals. Each of those rentals from first to last is connected via a <strong class="screenText">NEXT</strong> relationship:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 1 – Get the latest address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">This Cypher query gets us the latest address:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (p:Person {name:<code style="font-weight: bold;" class="codeHighlighted">'John Doe'</code>})-[:<code style="font-weight: bold;" class="codeHighlighted">LATEST</code>]-&gt;()-[:HAS_ADDRESS]-&gt;(a)&#13;
RETURN a&#13;
</code></pre>&#13;
    <p class="normal">We can see that this query is very different from the previous graph and SQL queries. In the previous <a id="_idIndexMarker148"/>graph model, the Cypher query was similar to the SQL query in determining what the last address is. Here, the query looks similar to a sentence in English (<em class="italic">Person’s latest address</em>).</p>&#13;
    <p class="normal">While the query looks simpler and easier to understand for most people, is it worth representing the data in this way? In this scenario, we will use more storage to be able to represent data in an elaborate manner. Let’s profile the queries from the initial graph data model to this data model and see whether there is any advantage.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_8.png" alt="Figure 3.8 — Basic graph model versus advanced graph model – query 1 profiles" width="685" height="933"/></figure>&#13;
    <p class="packt_figref">Figure 3.8 — Basic graph model versus advanced graph model – query 1 profiles</p>&#13;
    <p class="normal">From the <strong class="keyWord">query profiles</strong>, we can see the initial graph data model took 18 <strong class="screenText">db hits</strong> (accesses) and 312 bytes of memory to perform the operation. The current graph data model took 12 db hits and 312 bytes of memory to perform the operation. We can see the new data <a id="_idIndexMarker149"/>model is able to perform this query more optimally. As the data grows, the previous graph data model will take more time to perform the operation and the db hits will grow linearly with the number of relationships the person has. With the current data model, it would stay relatively constant.</p>&#13;
    <p class="normal">Now let us look at query 2.</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 2 – Get the first address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">This Cypher query gets us to the first address:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (p:Person {name:<code style="font-weight: bold;" class="codeHighlighted">'John Doe'</code>})-[:<code style="font-weight: bold;" class="codeHighlighted">FIRST</code>]-&gt;()-[:HAS_ADDRESS]-&gt;(a)&#13;
RETURN a&#13;
</code></pre>&#13;
    <p class="normal">We can see that this query looks exactly like the previous one, except for the relationship we are traversing. We are not using the <em class="italic">search-sort-filter</em> pattern anymore here. This is the biggest advantage of this data model. This model also makes it easy for us to use a graph as a structure to retrieve the data. Also, it means the logic to determine what data we are looking at is not coded into the query in the form of some property comparisons. Let us compare the query profiles to see whether this gives us any advantage.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_9.png" alt="Figure 3.9 — Basic graph model versus advanced graph model – query 2 profiles" width="686" height="1207"/></figure>&#13;
    <p class="packt_figref">Figure 3.9 — Basic graph model versus advanced graph model – query 2 profiles</p>&#13;
    <p class="normal">We can see the query execution plan for the initial graph data model is larger and more complex than the current data model. With the initial graph data model, it took 19 db hits and 1,020 bytes of memory to perform the operation. With the current data model, the plan is almost similar to query 1. It took 12 db hits and 312 bytes of memory. We can see that the ordering is causing us to use more memory and will consume more CPU cycles. As <strong class="screenText">Person</strong> is connected to more addresses, the initial graph data model <a id="_idIndexMarker150"/>will take more memory and db hits as performance will slowly degrade. With the current data model, the performance will remain relatively constant.</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Query 3 – Get the third address</strong></li>&#13;
    </ul>&#13;
    <p class="normal">This Cypher query gets us the third address:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (p:Person {name:<code style="font-weight: bold;" class="codeHighlighted">'John Doe'</code>})-[:<code style="font-weight: bold;" class="codeHighlighted">FIRST</code>]-&gt;()-[<code style="font-weight: bold;" class="codeHighlighted">:NEXT*2..2</code>]-&gt;()-[:HAS_ADDRESS]-&gt;(a)&#13;
RETURN a&#13;
</code></pre>&#13;
    <p class="normal">We can see from the query that the way it is written is to traverse to the first rental and skip the next rental to get to the third rental. This is how we normally look at data and it feels natural to express the query this way to retrieve the data. Again, we are not relying on the <em class="italic">search-sort-filter</em> pattern. Let us compare the query profiles to see whether this gives us any advantage.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_10.png" alt="Figure 3.10 — Basic graph model versus advanced graph model – query 3 profiles" width="698" height="1468"/></figure>&#13;
    <p class="packt_figref">Figure 3.10 — Basic graph model versus advanced graph model – query 3 profiles</p>&#13;
    <p class="normal">We can see from these profiles that the current data model query profile is a bit more involved than the previous queries. The initial graph data model took 19 db hits and 1,028 bytes to perform the operation. The current graph data model took 16 db hits and 336 bytes to perform the operation.</p>&#13;
    <p>&#13;
      <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
      <p class="normal"><strong class="keyWord">Query profiling</strong> is the <a id="_idIndexMarker151"/>best way to understand how the query works.  If we are not happy with the query performance, profiling helps us understand which areas of the query execution we want to improve or change for better performance. You can read more about this at <a href="https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/">https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/</a>.</p>&#13;
    </p>&#13;
    <p class="normal">From analyzing the queries and data models, we can see that taking a fresher look at how the data models are defined can have a huge impact in terms of performance and cost to perform the same operations.</p>&#13;
    <p class="normal">Another advantage <a id="_idIndexMarker152"/>of the current data model is that if we do want to track how the rentals are working from an address perspective, we can add just another relationship, say, <strong class="screenText">NEXT_RENTAL</strong>, between the rentals for the same address. This would give us a different perspective of the same data. Trying to represent the data like this in an RDBMS or other data persistence layers would be difficult. This is where Neo4j with its flexibility to be able to persist relationships to avoid the join index cost and optional schema is better suited to build knowledge graphs.</p>&#13;
    <p class="normal">A good graph data model makes the <strong class="keyWord">retriever in RAG flow</strong> more effective. It makes retrieving relevant data faster and easier, as we have explored here.</p>&#13;
    <p class="normal">We will take a look at how we can use knowledge graphs as part of RAG flow next.</p>&#13;
    <h1 id="_idParaDest-47" class="heading-1">Combining the power of RAG and Neo4j knowledge graphs with GraphRAG</h1>&#13;
    <p class="normal">In the previous chapter, we looked at the <strong class="keyWord">retriever</strong>, which is the heart of RAG flows. The retriever <a id="_idIndexMarker153"/>leverages data stores to retrieve relevant information to provide to LLMs to get the best response to our question. Retrievers can work with various data stores as needed. The data store capabilities can greatly determine how useful, quick, and effective the information retrieved is. This is where graphs play a great role. That’s how <strong class="keyWord">GraphRAG</strong> came into being.</p>&#13;
    <p>&#13;
      <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">You can read more about GraphRAG and how it is effective at <a href="https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/">https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/</a> and <a href="https://microsoft.github.io/graphrag/">https://microsoft.github.io/graphrag/</a>. For a comprehensive understanding of GraphRAG, you can refer to Microsoft’s research paper titled <em class="italic">From Local to Global: A Graph RAG Approach to Query-Focused Summarization</em> (<a href="https://arxiv.org/abs/2404.16130">https://arxiv.org/abs/2404.16130</a>). Additionally, Microsoft has made the GraphRAG project available on GitHub (<a href="https://github.com/microsoft/graphrag">https://github.com/microsoft/graphrag</a>), providing resources and tools for implementing this approach.</p>&#13;
    </p>&#13;
    <p class="normal">The Neo4j <a id="_idIndexMarker154"/>graph database excels at persisting the data as a property graph with nodes and relationships. This makes it easy to store and retrieve data in an intuitive manner and serves the data stores for RAG retrievers. This approach allows for more accurate, contextually aware, and reliable AI-driven applications.</p>&#13;
    <p class="normal">We will now build a GraphRAG flow that combines the power of RAG and knowledge graphs for improved LLM responses.</p>&#13;
    <h2 id="_idParaDest-48" class="heading-2">GraphRAG: enhancing RAG models with Neo4j</h2>&#13;
    <p class="normal">In the previous chapter, we discussed the flow of information in a chat application with a RAG model (refer to <em class="italic">Figure 3.5</em>).</p>&#13;
    <p class="normal">Now we <a id="_idIndexMarker155"/>will see how this workflow can be augmented to <a id="_idIndexMarker156"/>generate improved responses for the chat application. <em class="italic">Figure 3.11</em> shows the workflow of<a id="_idIndexMarker157"/> GraphRAG, where a user’s prompt is processed through an LLM API, retrieving relevant information from Neo4j, and then combined with the prompt before being sent to an LLM API.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_11.png" alt="Figure 3.11 — Workflow of GraphRAG" width="453" height="464"/></figure>&#13;
    <p class="packt_figref">Figure 3.11 — Workflow of GraphRAG</p>&#13;
    <p class="normal">The LLM <a id="_idIndexMarker158"/>API generates a response using both the prompt and <a id="_idIndexMarker159"/>the relevant information from the Neo4j knowledge graph, providing the user with accurate and contextually enriched results. By combining the capabilities of Neo4j and <a id="_idIndexMarker160"/>RAG models, GraphRAG enhances relevance with more domain context.</p>&#13;
    <p class="normal">Let us build a simple graph to showcase this GraphRAG flow.</p>&#13;
    <h2 id="_idParaDest-49" class="heading-2">Building a knowledge graph for RAG integration</h2>&#13;
    <p class="normal">For this <a id="_idIndexMarker161"/>example, we will use limited data <a id="_idIndexMarker162"/>for demonstration purposes to build the graph, focusing on movies and their plots.</p>&#13;
    <h3 id="_idParaDest-50" class="heading-3">Python code example: Setting up a knowledge graph in Neo4j</h3>&#13;
    <p class="normal">By following <a id="_idIndexMarker163"/>along with the provided code example, you will <a id="_idIndexMarker164"/>learn how to set up a Neo4j database, define nodes and relationships, and perform basic queries using Cypher:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1"><strong class="screenText">Set up the Neo4j database</strong>: Before running the code, ensure you have access to a Neo4j database. You can use either of the following:<ul>&#13;
          <li class="bulletList"><strong class="screenText">Neo4j Desktop</strong>: Install <a id="_idIndexMarker165"/>and run it locally (download Neo4j Desktop: <a href="https://neo4j.com/download/">https://neo4j.com/download/</a>)</li>&#13;
          <li class="bulletList"><strong class="screenText">Neo4j AuraDB</strong>: This is <a id="_idIndexMarker166"/>a cloud-hosted option (learn more about AuraDB at <a href="https://neo4j.com/product/auradb/">https://neo4j.com/product/auradb/</a>)</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numberedList">Start your database instance and note the connection credentials (e.g., URI, username, and password).</li>&#13;
      <li class="numberedList"><strong class="screenText">Install the necessary Python libraries</strong>: You will need the following Python libraries:<ul>&#13;
          <li class="bulletList"><strong class="screenText">Neo4j Python Driver</strong>: To interact with the database</li>&#13;
          <li class="bulletList"><strong class="screenText">Pandas</strong>: For handling data structures and analysis</li>&#13;
          <li class="bulletList">Install these libraries using the following command:&#13;
            <pre class="programlisting code"><code class="hljs-code">pip install neo4j pandas&#13;
</code></pre>&#13;
          </li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numberedList"><strong class="screenText">Connect to the database and set up the knowledge graph</strong>: Once your Neo4j database is running and the required Python libraries are installed, you can use the following Python script to set up a simple knowledge graph. In this example, we will create a graph for IMDb movies and their plots, with nodes representing movies and plots and relationships indicating which plot belongs to which movie.</li>&#13;
    </ol>&#13;
    <p>&#13;
      <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">We will not be using any external dataset, rather, we will be using a hardcoded data set to showcase the graph model and the GraphRAG flow. We will be exploring full-fledged data loading and the GraphRAG flow in <em class="italic">Chapters 4</em> and <em class="italic">5</em>. This example is to showcase the GraphRAG flow aspects only.</p>&#13;
    </p>&#13;
    <p class="normal">We will <a id="_idIndexMarker167"/>first build a simple graph. We will <a id="_idIndexMarker168"/>be using this simple graph to showcase where and how Neo4j fits in the GraphRAG flow:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Import the <code class="inlineCode">GraphDatabase</code> library and define Neo4j connectivity and credentials:&#13;
        <pre class="programlisting code"><code class="hljs-code">from neo4j import GraphDatabase&#13;
uri = "bolt://localhost:7687"  # Replace with your Neo4j URI&#13;
username = "neo4j"             # Replace with your Neo4j username&#13;
password = "password"          # Replace with your Neo4j password&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Let us create a few nodes:&#13;
        <pre class="programlisting code"><code class="hljs-code">def create_graph(tx):&#13;
    tx.run("CREATE (m:Movie {title: 'The Matrix', year: 1999})")&#13;
    ....&#13;
    # Create plot nodes&#13;
    tx.run("CREATE (p:Plot {description: 'A computer hacker learns from mysterious rebels about the true nature of his reality and his role in the war against its controllers.'})")&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">The next step is to create relationships:&#13;
        <pre class="programlisting code"><code class="hljs-code">    tx.run("""&#13;
    MATCH (m:Movie {title: 'The Matrix'}),&#13;
          (p:Plot {description: 'A computer hacker learns from mysterious rebels about the true nature of his reality and his role in the war against its controllers.'})&#13;
    CREATE (m)-[:HAS_PLOT]-&gt;(p)&#13;
    """)&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">If we visualize the data that we created, it would look as shown in <em class="italic">Figure 3.12</em>:&#13;
        <pre class="programlisting code"><code class="hljs-code">MATCH p=(:Movie)-[:HAS_PLOT]-&gt;()&#13;
RETURN p&#13;
LIMIT 5&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <figure class="mediaobject"><img src="img/B31107_03_12.png" alt="Figure 3.12 — Sample graph showing movies and plots" width="1650" height="833"/></figure>&#13;
    <p class="packt_figref">Figure 3.12 — Sample graph showing movies and plots</p>&#13;
    <p class="numberedList"><a id="_idTextAnchor021"/>5. We will <a id="_idIndexMarker169"/>now retrieve the data using a Cypher <a id="_idIndexMarker170"/>query:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">def query_graph(tx):&#13;
    # Query to retrieve movies and their plots&#13;
    result = tx.run("""&#13;
    MATCH (m:Movie)-[:HAS_PLOT]-&gt;(p:Plot)&#13;
    RETURN m.title AS movie, m.year AS year, p.description AS plot&#13;
    """)&#13;
    # Print the results&#13;
    for record in result:&#13;
        print(f"Movie: {record['movie']} ({record['year']}) - Plot: {record['plot']}")&#13;
</code></pre>&#13;
    <p class="numberedList"><a id="_idTextAnchor022"/>6. If we run this, we can see the output as shown here:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Movie: The Matrix (1999) - Plot: A computer hacker learns from mysterious rebels about the true nature of his reality and his role in the war against its controllers.&#13;
</code></pre>&#13;
    <p class="normal">You can find the complete code at <a href="https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/imdb_kg.py">https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/imdb_kg.py</a>.</p>&#13;
    <p class="normal">Now that we have built the basic graph, let us use it in the GraphRAG flow.</p>&#13;
    <h3 id="_idParaDest-51" class="heading-3">Integrating RAG with your Neo4j knowledge graph</h3>&#13;
    <p class="normal">To integrate RAG models with Neo4j, you need to configure the models to query the graph database. This <a id="_idIndexMarker171"/>typically involves setting up an API or a middleware layer that facilitates communication between the RAG models and Neo4j.</p>&#13;
    <p class="normal">An <a id="_idIndexMarker172"/>example integration workflow is provided here:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1"><strong class="screenText">User input:</strong> The user provides a prompt. In the following code example, the prompt is predefined in the script as an example (<code class="inlineCode">"The Matrix"</code>). Users can modify this to test other movies or prompts:&#13;
        <pre class="programlisting code"><code class="hljs-code">prompt = "The Matrix"&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList"><strong class="screenText">Query generation</strong>: The prompt is processed, and a Cypher query is generated to retrieve relevant information from Neo4j. For example, the query might fetch the plot of the movie mentioned in the prompt:&#13;
        <pre class="programlisting code"><code class="hljs-code">"""&#13;
    Fetch relevant data (plots) for movies that match the user's prompt.&#13;
    """&#13;
    query = f"""&#13;
    MATCH (m:Movie)-[:HAS_PLOT]-&gt;(p:Plot)&#13;
    WHERE m.title CONTAINS '{prompt}'&#13;
    RETURN m.title AS title, m.year AS year, p.description AS plot&#13;
    """&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList"><strong class="screenText">Data retrieval</strong>: The Cypher query is executed, and the relevant data (e.g., the plot of <em class="italic">The Matrix</em>) is fetched from the knowledge graph:&#13;
        <pre class="programlisting code"><code class="hljs-code">    with driver.session() as session:&#13;
        result = session.run(query)&#13;
        records = [&#13;
            {&#13;
                "title": record["title"],&#13;
                "year": record["year"],&#13;
                "plot": record["plot"],&#13;
            }&#13;
            for record in result if record["plot"] is not None&#13;
        ]&#13;
        print(f"Retrieved Records: {records}")  # Debugging line&#13;
        return records&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList"><strong class="screenText">RAG model processing</strong>: The retrieved data is combined with the original prompt and <a id="_idIndexMarker173"/>passed to the RAG model for further processing, allowing the model <a id="_idIndexMarker174"/>to generate a richer and context-aware response:&#13;
        <pre class="programlisting code"><code class="hljs-code">"""&#13;
    Combine the user's prompt with relevant data from the graph&#13;
    and generate a focused, non-repetitive response using the RAG model.&#13;
    """&#13;
    relevant_data = get_relevant_data(prompt)&#13;
    if not relevant_data:&#13;
        return "No relevant data found for the given prompt."&#13;
    # Combine dictionaries in relevant_data into a single string&#13;
    combined_input = (&#13;
      f"Provide detailed information about: {prompt}. " + &#13;
      " ".join([&#13;
          f"{data['title']} ({data['year']}): {data['plot']}" &#13;
          for data in relevant_data&#13;
    ])&#13;
    print(f"Combined Input: {combined_input}")&#13;
    if not combined_input.strip():&#13;
        return "No relevant data to process for this prompt."&#13;
    # Tokenize the combined input with truncation&#13;
    max_input_length = 512 - 50  # Leave space for output&#13;
    tokenized_input = tokenizer(combined_input, truncation=True, &#13;
        max_length=max_input_length, return_tensors="pt")&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList"><strong class="screenText">Response generation</strong>: The RAG model generates a response using the enriched prompt (e.g., “The plot of <em class="italic">The Matrix</em> is: ‘A computer hacker learns from mysterious rebels about the true nature of his reality and his role in the war against its controllers.’”):&#13;
        <pre class="programlisting code"><code class="hljs-code"># Generate response with tuned parameters&#13;
    outputs = model.generate(&#13;
        **tokenized_input,&#13;
        max_length=150,&#13;
        temperature=0.7,&#13;
        top_k=50,&#13;
        top_p=0.9,&#13;
        num_beams=5,&#13;
        no_repeat_ngram_size=3,&#13;
        early_stopping=True&#13;
    )&#13;
    # Decode the response with improved formatting&#13;
    response = tokenizer.decode(outputs[0], &#13;
        skip_special_tokens=True, &#13;
        clean_up_tokenization_spaces=True)&#13;
    return response&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">The <a id="_idIndexMarker175"/>following is a sample output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Prompt: The Matrix&#13;
Response: : the matrix ( 1999 ) : a computer hacker learns from mysterious rebels about the true nature of his reality and his role in the war against its controllers.&#13;
</code></pre>&#13;
    <p class="normal">The full version of the code in this chapter is placed at: <a href="https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/neo4j_rag.py">https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/neo4j_rag.py</a>.</p>&#13;
    <pre>numpy</code> versions &lt; <code class="inlineCode">2</code>. If you are running <code class="inlineCode">numpy</code> versions &gt; <code class="inlineCode">2</code>, use the following commands on the terminal to create a clean virtual environment to isolate the issue:</pre>&#13;
    <pre class="programlisting con"><code class="hljs-con">python3 -m venv my_env&#13;
source my_env/bin/activate&#13;
pip install numpy==1.26.4 neo4j transformers torch faiss-cpu datasets&#13;
</code></pre>&#13;
    <p class="normal">With an understanding of how to build and query a basic knowledge graph, as well as how to integrate RAG models with Neo4j, you are now equipped with the foundational skills needed to create intelligent, context-aware applications. Next, we will take a look at a few approaches to enhance knowledge graphs. We will just be introducing these concepts here and will be exploring them in more detail upcoming chapters for building intelligent applications.</p>&#13;
    <h1 id="_idParaDest-52" class="heading-1">Enhancing knowledge graphs</h1>&#13;
    <p class="normal">We looked at building a graph and GraphRAG flow in the previous section. What we have looked at <a id="_idIndexMarker177"/>is a simple graph. There are a few approaches we can follow to make knowledge graphs more effective. Let us take a look at these approaches. We will be using these approaches to enhance our knowledge graphs in the upcoming chapters:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="screenText">Ontology development</strong>: An ontology can define the structure and the content of the graph. By having the ontology persisted in the graph, we might be able to explain <a id="_idIndexMarker178"/>the data and its connectivity in a more intuitive way. This ensures that the graph follows best practices and <a id="_idIndexMarker179"/>aligns with your domain-specific needs. Ontologies also help in maintaining uniformity across different datasets and in extending the graph over time. In <a href="Chapter_05.xhtml#_idTextAnchor038"><em class="italic">Chapter 5</em></a>, we would be enhancing the simple movie knowledge graph we created <a id="_idIndexMarker180"/>in this chapter   If you want to learn more about ontologies, you can take a look at <a href="https://neo4j.com/blog/ontologies-in-neo4j-semantics-and-knowledge-graphs/">https://neo4j.com/blog/ontologies-in-neo4j-semantics-and-knowledge-graphs/</a>.</li>&#13;
      <li class="bulletList"> <strong class="screenText">Graph Data Science (GDS)</strong>: While data loaded as a graph can be effective as a knowledge graph, there are a few other approaches that can make this graph much <a id="_idIndexMarker181"/>more effective. For example, we can perform some link prediction or perform community <a id="_idIndexMarker182"/>detection to create additional relationships between nodes that are inferred based on the existing data in the graph. This can help us enhance the intelligence stored in the graph to give us better answers when querying. We will be leveraging the KNN similarity and community detection algorithms in <a href="Chapter_10.xhtml#_idTextAnchor066"><em class="italic">Chapter 10</em></a> to enhance the graph to get more intelligence.</li>&#13;
    </ul>&#13;
    <p class="normal">We have looked at a few approaches to enhance knowledge graphs. Let us now summarize our understanding of the concepts we have looked at.</p>&#13;
    <h1 id="_idParaDest-53" class="heading-1">Summary</h1>&#13;
    <p class="normal">In this chapter, we explored the foundational aspects of building a knowledge graph for RAG integration using Neo4j. We began by understanding the importance of Neo4j knowledge graphs and their role in GraphRAG. We also set up a Neo4j database, created nodes and relationships, and performed queries to retrieve relevant information.</p>&#13;
    <p class="normal">We also covered the integration workflow of RAG models with Neo4j. You are now ready to move on to <em class="italic">Part 2</em>, <em class="italic">Integrating Haystack with Neo4j: A Practical Guide to Building AI-Powered Search</em>. In the next part, we will build on the foundation laid in this chapter and explore how to integrate Haystack with Neo4j to create powerful, AI-driven search capabilities. This next step will naturally extend your knowledge and skills, enabling you to develop sophisticated search applications that leverage the strengths of both Haystack and Neo4j.</p>&#13;
  </div>&#13;
</div></div></body></html>