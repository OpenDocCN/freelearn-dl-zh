- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Using Hierarchical State Machines with State Trees
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态树中的层次状态机
- en: Unreal Engine provides a powerful framework for creating complex AI behaviors
    through **hierarchical state machines** called **state trees** . By defining various
    states and transitions, developers can design sophisticated AI logic that adapts
    to dynamic environments. State trees offer a structured approach to managing AI
    behavior, allowing for efficient decision-making and seamless integration with
    other systems in Unreal Engine. What’s more, with state trees, you can build clever
    AI agents that respond to environmental stimuli and interact with the game world
    in a natural and realistic manner. The purpose of the chapter is to introduce
    you to the state tree framework in Unreal Engine and to its basic concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎提供了一个强大的框架，通过称为**状态树**的层次状态机来创建复杂的AI行为。通过定义各种状态和转换，开发者可以设计复杂的AI逻辑，使其能够适应动态环境。状态树提供了一种结构化的方法来管理AI行为，允许高效决策并与其他虚幻引擎中的系统无缝集成。更重要的是，使用状态树，您可以构建聪明的AI代理，它们能够对环境刺激做出反应，并以自然和逼真的方式与游戏世界互动。本章的目的是向您介绍虚幻引擎中的状态树框架及其基本概念。
- en: In this chapter, we will have a quick introduction to the state tree system
    available in Unreal Engine and see how to implement state trees inside a project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍虚幻引擎中可用的状态树系统，并了解如何在项目中实现状态树。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing state trees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍状态树
- en: Creating and managing state trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和管理状态树
- en: Using advanced state tree features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级状态树功能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟进本章中介绍的主题，您应该已完成前面的章节并理解其内容。
- en: 'You’ll be using the starter content available in this book’s companion repository
    located at [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    . Through this link, locate the section for this chapter and download the following
    **.zip** file: **Unreal Agility Arena –** **Starter Content** .'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用本书配套仓库中可用的起始内容，该仓库位于[https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)。通过此链接，找到本章的相应部分，并下载以下**.zip**文件：**Unreal
    Agility Arena –** **起始内容**。
- en: Although not mandatory, you can use the code created so far or download the
    files that correspond to the end of the last chapter by clicking the **Unreal
    Agility Arena –** **Chapter 11** **-** **End** link.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是强制性的，但您可以使用到目前为止创建的代码或通过点击**Unreal Agility Arena –** **第11章** **-** **结束**链接下载与上一章结尾对应的文件。
- en: Introducing state trees
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍状态树
- en: 'It appeared inevitable that, sooner or later, someone would uncover Dr. Markus’
    secret experiments:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 很显然，迟早有人会揭露马克斯博士的秘密实验：
- en: '*Hidden in their secret laboratory, Dr. Markus and Professor Viktoria kept
    on with their groundbreaking experiments. However, news of their remarkable inventions
    began to spread like wildfire; paparazzi and curious individuals started flocking
    to the area, eager to uncover the secrets hidden within the* *laboratory’s walls.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*在他们的秘密实验室中，马克斯博士和维克托利亚教授继续进行他们的开创性实验。然而，他们非凡发明的消息开始像野火一样迅速传播；摄影师和好奇的人开始涌向该地区，渴望揭开实验室墙壁隐藏的秘密。*'
- en: '*Dr. Markus and Professor Viktoria realized they needed to take drastic measures
    to protect their precious research. With their expertise, the ingenious duo started
    enhancing their beloved AI dummy puppets with advanced algorithms and behavioral
    patterns. They programmed the puppets to detect and respond to unauthorized intrusions,
    trying to ensure the safety of their laboratory* *and research.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*马克斯博士和维克托利亚教授意识到他们需要采取极端措施来保护他们宝贵的研究。凭借他们的专业知识，这对天才组合开始用高级算法和行为模式增强他们钟爱的AI木偶。他们编程木偶以检测和响应未经授权的入侵，试图确保实验室*
    *和研究的* *安全。*'
- en: State trees are the Unreal Engine version of hierarchical state machines that
    merge selectors from behavior trees with state machines, enabling users to build
    efficient and well-organized logic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树是虚幻引擎中层次状态机的版本，它将行为树的选择器与状态机合并，使用户能够构建高效且井然有序的逻辑。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A hierarchical state machine is a design pattern used in software development
    to model complex systems with multiple states and transitions. It extends the
    concept of traditional finite-state machines by introducing the idea of hierarchically
    nested states. In a hierarchical state machine, states can be organized into a
    hierarchical structure, where higher-level states encapsulate and control lower-level
    states; this nesting allows for a more modular and organized representation of
    the system behavior. Each state can have its own set of substates, which can further
    have their own substates, forming a hierarchical tree-like structure. The main
    advantage of this pattern is that it provides a way to reuse behavior across multiple
    states. Instead of duplicating similar logic in different states, common behavior
    can be defined at higher-level states and inherited by their substates. This promotes
    code reusability, reduces redundancy, and simplifies the overall design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 层次状态机是一种在软件开发中用于模拟具有多个状态和转换的复杂系统的设计模式。它通过引入层次嵌套状态的概念扩展了传统有限状态机的概念。在层次状态机中，状态可以被组织成一个层次结构，其中高级状态封装并控制低级状态；这种嵌套允许对系统行为进行更模块化和组织化的表示。每个状态都可以有自己的子状态集，这些子状态还可以进一步拥有自己的子状态，形成一个层次树状结构。这种模式的主要优势是它提供了一种在多个状态之间重用行为的方法。而不是在不同的状态中重复类似的逻辑，可以在高级状态中定义共同的行为，并由其子状态继承。这促进了代码的重用性，减少了冗余，并简化了整体设计。
- en: A state tree is structured hierarchically, with the state selection process
    generally starting at the root. However, state selection can be initiated from
    any node within the tree.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树是按层次结构组织的，状态选择过程通常从根开始。然而，状态选择可以从树中的任何节点启动。
- en: When selecting a **state** , the system evaluates a set of **enter conditions**
    for the state itself; if conditions are met, the selection progresses to the child
    states. If no child states exist, it means a leaf has been reached and the current
    state is activated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择**状态**时，系统评估状态本身的**进入条件**集；如果条件满足，选择将进展到子状态。如果没有子状态存在，这意味着已经到达了叶节点，当前状态将被激活。
- en: Activating a state triggers all states from the root to the leaf state, with
    each of these states comprising **tasks** and **transitions** .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 激活一个状态将触发从根到叶状态的所有状态，其中每个状态都包含**任务**和**转换**。
- en: Upon selecting a state, the chosen state and all its parent states become active,
    executing tasks for all active states starting from the root down to the leaf
    state. All tasks in a state are executed concurrently, and the first task reaching
    completion will trigger a transition that may result in the selection of a new
    state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 选择状态后，所选状态及其所有父状态变为活动状态，从根到叶状态执行所有活动状态的任务。状态中的所有任务都是并发执行的，第一个完成任务将触发可能导致选择新状态的转换。
- en: 'Transitions can point to any state in the tree, and they are triggered by a
    set of **trigger conditions** that must be satisfied for the transition to proceed.
    *Figure 12* *.1* shows a typical example of a state tree (example taken from the
    **City Sample** project freely available in the Epic Games Marketplace):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 转换可以指向树中的任何状态，并且它们由必须满足以使转换继续的一系列**触发条件**触发。*图12.1*展示了状态树的典型示例（示例取自Epic Games
    Marketplace中免费提供的**城市样本**项目）：
- en: '![Figure 12.1 – State tree example](img/Figure_12.1_B31016.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 状态树示例](img/Figure_12.1_B31016.jpg)'
- en: Figure 12.1 – State tree example
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 状态树示例
- en: 'To sum it up, the main elements of a state tree are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，状态树的主要元素如下：
- en: '**Root** state: the first state selected when the state tree starts executing
    its logic'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根状态**：当状态树开始执行其逻辑时首先选择的状态'
- en: '**Selector** state: state with child states'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择器状态**：具有子状态的状态'
- en: '**State enter condition** : lists the conditions that decide if a state can
    be selected'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态进入条件**：列出决定状态是否可以被选择的条件'
- en: '**Task** : lists a set of actions that will be executed when a state is activated'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：列出当状态激活时将执行的一系列操作'
- en: '**Transition** : the conditions that will trigger the state selection process'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：将触发状态选择过程的条件'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In case you are wondering, state trees and behavior trees are both decision-making
    architectures used in AI, but they serve different purposes. State trees are structured
    around discrete states and transitions, focusing on the current state of an entity
    and how it changes in response to events. This makes them suitable for scenarios
    where clear, distinct states are necessary. In contrast, behavior trees are designed
    for more complex and fluid decision-making, allowing for modular and hierarchical
    task execution. They enable smoother transitions between tasks and can handle
    more intricate behaviors by combining simple actions into complex sequences.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感到好奇，状态树和行为树都是人工智能中使用的决策架构，但它们有不同的用途。状态树围绕离散状态和转换构建，关注实体的当前状态及其对事件的响应方式。这使得它们适用于需要明确、清晰状态的场景。相比之下，行为树旨在处理更复杂和流动的决策，允许模块化和分层任务执行。它们通过将简单动作组合成复杂序列，实现任务之间的平滑过渡，并能处理更复杂的行为。
- en: Now that you have a basic understanding of the main state tree terminology,
    we will show how to extend your own state trees.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对主要状态树术语有了基本的了解，我们将展示如何扩展您自己的状态树。
- en: Extending state trees
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展状态树
- en: 'A state tree can be created to be executed on an AI controller or directly
    from an actor. There are two different components available to handle a state
    tree:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建状态树以在AI控制器上执行或直接从演员执行。有两个不同的组件可用于处理状态树：
- en: '**StateTreeComponent** : This can be attached to any actor and be executed
    by the actor itself'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StateTreeComponent**：这可以附加到任何演员上并由演员本身执行'
- en: '**StateTreeAIComponent** : This can be attached to any AI controller and be
    executed by the AI controller itself'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StateTreeAIComponent**：这可以附加到任何AI控制器上并由AI控制器本身执行'
- en: 'Additionally, as you may have already guessed, the state tree system has been
    created with extensibility in mind, which means you can create your own tasks,
    evaluators, and conditions. Although you can create your own C++ structures, state
    trees have been implemented with Blueprint creation in mind. In particular, the
    main classes available are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如您可能已经猜到的，状态树系统是考虑到可扩展性而创建的，这意味着您可以创建自己的任务、评估器和条件。虽然您可以创建自己的C++结构，但状态树是考虑到蓝图创建而实现的。特别是，可用的主要类如下：
- en: '**StateTreeTaskBlueprintBase** : Used for implementing your own tasks'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StateTreeTaskBlueprintBase**：用于实现您自己的任务'
- en: '**StateTreeEvaluatorBlueprintBase** : Used for implementing your own evaluators'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StateTreeEvaluatorBlueprintBase**：用于实现您自己的评估器'
- en: '**StateTreeConditionBlueprintBase** : Used for implementing your own conditions'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StateTreeConditionBlueprintBase**：用于实现您自己的条件'
- en: When extending state trees, it’s advisable to implement your own node logic
    using Blueprints rather than C++. This approach can enhance flexibility and ease
    of use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展状态树时，建议使用蓝图而不是C++来实现您自己的节点逻辑，这样可以提高灵活性和易用性。
- en: Understanding the state tree flow
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解状态树流程
- en: 'State selection in a state tree starts from the tree root and continues down
    the tree by evaluating each enter conditions. The evaluation process follows these
    steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树中的状态选择从树根开始，通过评估每个进入条件沿着树向下进行。评估过程遵循以下步骤：
- en: If enter conditions are not satisfied, selection goes to the next sibling state
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进入条件不满足，选择将跳转到下一个兄弟状态
- en: If enter conditions are satisfied and the state is a leaf, it is selected as
    the new state
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进入条件满足且状态是叶子节点，则将其选为新的状态
- en: If enter conditions are satisfied but the state is not a leaf, the process is
    executed for the first child state
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进入条件满足但状态不是叶子节点，则对第一个子状态执行过程
- en: It should be noted that state selection is run dynamically, triggered by transitions.
    During the first tick, there is an implicit transition to the root state, which
    then determines the initial state to be executed. Subsequently, once this state
    is chosen, the transitions specify the conditions that trigger the selection logic,
    determining when and where it will be executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，状态选择是动态运行的，由转换触发。在第一次tick时，有一个隐式转换到根状态，然后确定要执行的初始状态。随后，一旦选择了这个状态，转换指定了触发选择逻辑的条件，确定何时以及在哪里执行。
- en: Once a state is selected, all its tasks are executed and will keep on executing
    until a transition triggers a new state selection process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了状态，所有其任务都会执行，并且会持续执行，直到转换触发新的状态选择过程。
- en: Data binding
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: In game programming, **data binding** refers to the process of connecting data
    between different parts of the game – such as the user interface and the game
    logic – and it involves creating a link that allows data to be synchronized and
    updated across various elements of the game. This helps in keeping the game elements
    consistent and up to date with the latest information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏编程中，**数据绑定**指的是连接游戏不同部分之间数据的过程——例如用户界面和游戏逻辑——它涉及创建一个链接，允许数据在游戏的各个元素之间同步和更新。这有助于保持游戏元素的一致性和与最新信息的更新。
- en: State trees use data binding for transferring data within the tree and to establish
    conditions or configure tasks for execution. Data binding allows access to data
    passed into the state tree or between nodes in a specified manner.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树使用数据绑定在树内传输数据以及为执行建立条件或配置任务。数据绑定允许以指定方式访问传递到状态树或节点之间的数据。
- en: 'State tree nodes have the following elements available to implement data binding:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树节点具有以下元素以实现数据绑定：
- en: '**Parameters** : These can be referenced during the tree’s execution'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这些可以在树的执行过程中引用。'
- en: '**Context data** : This represents predefined data available to the state tree'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文数据**：这表示状态树中可用的预定义数据。'
- en: '**Evaluators** : These are separate classes that can be executed at runtime
    and that expose data that could not be made available with parameters and context
    data'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估器**：这些是可以在运行时执行且可以公开数据的独立类，这些数据无法通过参数和上下文数据提供。'
- en: '**Global tasks** : These are executed before the root state and can be used
    when you need permanent data during state selection'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局任务**：这些在根状态之前执行，可以在你需要永久数据时在状态选择中使用。'
- en: 'It is also worth mentioning that nodes in a state tree share data among themselves
    and can bind data in three ways that have been previously mentioned:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，状态树中的节点可以在自己之间共享数据，并且可以以三种先前提到的方式绑定数据：
- en: State enter conditions
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态进入条件
- en: Transition conditions
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换条件
- en: Tasks
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务
- en: In this section, we introduced state trees and their key features. In the following
    section, we will delve into practical exercises by crafting our own state trees
    in order to use them effectively within a gym setting.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了状态树及其关键特性。在下一节中，我们将通过构建自己的状态树来深入实践，以便在健身房环境中有效地使用它们。
- en: Creating and managing state trees
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理状态树
- en: From this section onward, we will be creating a new gym based on a couple of
    AI agents using state trees instead of behavior trees. This will help us to understand
    the basic principles behind this new development pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们将基于几个AI代理使用状态树而不是行为树来创建一个新的健身房。这将帮助我们理解这种新开发模式背后的基本原理。
- en: 'To help us understand these principles, we’ll be doing the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解这些原理，我们将执行以下操作：
- en: Create/place an actor in the level who will periodically emit a noise by using
    a dedicated state tree
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在级别中创建/放置一个演员，该演员将使用专用状态树定期发出噪音
- en: 'Create/place a dummy character who will be managed by another state tree and
    will do the following:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建/放置一个虚拟角色，该角色将由另一个状态树管理，并将执行以下操作：
- en: Stay idle in its starting location
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其起始位置保持空闲
- en: Reach the noise location whenever a noise is perceived
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当感知到噪音时，到达噪音位置
- en: Get back to its starting location after a brief time investigating the location
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调查位置后不久返回其起始位置
- en: Although pretty simple, this logic can be used as a starting point for a guard
    AI agent that will investigate a level looking for intruders and responding to
    any suspicious noise around.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个逻辑相当简单，但它可以用作一个起始点，用于构建一个调查级别寻找入侵者并对周围任何可疑噪音做出反应的守护者AI代理。
- en: As the state trees feature is not enabled by default, the first thing to do
    will be to get to the **Plugins** window and enable it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态树功能默认未启用，首先需要做的事情就是进入 **插件** 窗口并启用它。
- en: Enabling state trees plugins
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用状态树插件
- en: 'To start working with state trees, you will need to enable a couple of dedicated
    plugins. In order to do so, follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用状态树，您需要启用一些专用插件。为此，请按照以下步骤操作：
- en: Open the **Plugin** window by selecting **Edit** | **Plugins** from the main
    menu.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从主菜单中选择 **编辑** | **插件** 来打开 **插件** 窗口。
- en: Search for the **GameplayStateTree** and **StateTree** plugins and enable them.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 **GameplayStateTree** 和 **StateTree** 插件并启用它们。
- en: Restart the Unreal Engine Editor to activate them.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动虚幻引擎编辑器以激活它们。
- en: '![Figure 12.2 – Plugin window](img/Figure_12.2_B31016.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 插件窗口](img/Figure_12.2_B31016.jpg)'
- en: Figure 12.2 – Plugin window
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 插件窗口
- en: If you plan to use state trees with C++ (and we do), you will need to add a
    module to the Unreal Engine build file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划使用C++中的状态树（我们确实如此），您需要将模块添加到Unreal Engine构建文件中。
- en: In our case, we will need to include the **GameplayStateTreeModule** dependency
    in the build, so that the module will be available to your C++ implementation.
    In order to do so, open your IDE and locate the **UnrealAgilityArena.build.cs**
    file in your project; it should be located in the **UnrealAgilityArena/Source**
    folder.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要在构建中包含**GameplayStateTreeModule**依赖项，以便该模块可以供您的C++实现使用。为此，打开您的IDE，并在您的项目中定位到**UnrealAgilityArena.build.cs**文件；它应该位于**UnrealAgilityArena/Source**文件夹中。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Unreal Engine **.build.cs** file is responsible for defining how the project
    is built, including options for defining module dependencies.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine的**.build.cs**文件负责定义项目的构建方式，包括定义模块依赖项的选项。
- en: 'Look for this line of code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 查找以下代码行：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Update it to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更新如下：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, once you declare this module, you will have all that’s needed to work with
    state trees in C++.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦您声明了这个模块，您将拥有在C++中处理状态树所需的所有内容。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, there seem to be some issues in declaring
    a **StateTreeAIComponent** class in C++, while the **StateTreeComponent** class
    is working just fine. Basically, the **StateTreeAIComponent** class seems to be
    unavailable in the module, and using this class won’t compile your project. To
    overcome this issue, we will be adding the **StateTreeAIComponent** class from
    Blueprint when needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，似乎在C++中声明**StateTreeAIComponent**类时存在一些问题，而**StateTreeComponent**类则运行良好。基本上，**StateTreeAIComponent**类似乎在模块中不可用，使用此类不会编译您的项目。为了克服这个问题，我们需要在需要时从Blueprint中添加**StateTreeAIComponent**类。
- en: 'Once the plugins have been activated, we can start implementing our first AI
    agent using a state tree: the noise emitter.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件被激活，我们就可以开始使用状态树实现我们的第一个AI代理：噪声发射器。
- en: Implementing a noise emitter actor
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现噪声发射器演员
- en: We will be now creating an actor whose sole aim will be to periodically emit
    a noise by means of the **Perception System** . This task is straightforward and
    can be implemented in any manner you find suitable. However, for this demonstration,
    we will use state trees to grasp the fundamental principles of this system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个演员，其唯一目的是通过**感知系统**定期发出噪声。这项任务很简单，可以以任何您认为合适的方式实现。然而，为了这个演示，我们将使用状态树来掌握这个系统的基本原理。
- en: Creating the noise emitter class
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建噪声发射器类
- en: We will be starting by creating the base class for the noise emitter; we will
    need to declare all the visual elements and, most importantly, the needed Perception
    System component and the state tree component. Moreover, we will include a function
    to generate the noise, without concerning ourselves with the logic that will manage
    it; this responsibility will be delegated to the state tree.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建噪声发射器的基类；我们需要声明所有视觉元素，最重要的是所需的感知系统组件和状态树组件。此外，我们将包含一个生成噪声的函数，而不关心将管理它的逻辑；这项责任将委托给状态树。
- en: 'Let’s start by creating a new C++ class extending **Actor** and call it **BaseNoiseEmitter**
    . Once the class has been created, open the **BaseNoiseEmitter.h** file and add
    the following forward declarations after the **#** **include** declarations:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的C++类开始，该类扩展**Actor**并命名为**BaseNoiseEmitter**。一旦创建了类，打开**BaseNoiseEmitter.h**文件，并在**#include**声明之后添加以下前置声明：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, make the class an acceptable base class for Blueprints by changing
    the **UCLASS()** macro into the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将类更改为Blueprint可接受的基类，通过将**UCLASS()**宏更改为以下内容：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Look for the **Tick()** declaration and remove it as we won’t be using it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查找**Tick()**声明并将其删除，因为我们不会使用它。
- en: 'Next, add the needed components just after the **GENERATED_BODY()** macro:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**GENERATED_BODY()**宏之后添加所需的组件：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see from the preceding code, we will be using a few static meshes,
    as well as the needed state tree and Perception System components.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们将使用一些静态网格，以及所需的状态树和感知系统组件。
- en: 'Now, just after the constructor declaration, add the following declarations:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就在构造函数声明之后，添加以下声明：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we are exposing some properties to customize our emitter instances
    in the level, and we are declaring an **EmitNoise()** function that we will be
    using to activate the noise emission when needed. Finally, the **NoiseTag** property
    will be used to tag the noise and be recognized by listening AI agents.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在公开一些属性以自定义级别中的发射器实例，并声明一个**EmitNoise()**函数，我们将使用它来在需要时激活噪音发射。最后，**NoiseTag**属性将用于标记噪音，并被监听智能体识别。
- en: 'It’s now time to open the **BaseNoiseEmitter.cpp** file and implement the methods.
    As a first step, remove the **Tick()** function and, in the constructor, modify
    this line of code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候打开**BaseNoiseEmitter.cpp**文件并实现方法了。作为第一步，移除**Tick()**函数，并在构造函数中修改以下代码行：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Modify it into this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将其修改为以下内容：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, add the needed **#include** declarations, so add this block of
    code at the top of the file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，添加所需的**#include**声明，所以将以下代码块添加到文件顶部：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s initialize the static mesh components inside the constructor by
    adding the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在构造函数中初始化静态网格组件，添加以下代码：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should be already familiar with all of this, so we can go on and declare
    the stimuli source for the Perception System and the state tree by adding this
    piece of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉所有这些，所以我们可以继续并声明感知系统的刺激源和状态树，添加以下代码：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we are just creating the needed components; additionally, we
    are registering the hearing sense as a stimuli source for the Perception System.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是在创建所需组件；此外，我们正在将听觉感知注册为感知系统的刺激源。
- en: 'Now, in the **BeginPlay()** function, add the following lines of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在**BeginPlay()**函数中，添加以下代码行：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are registering the Perception System, and we are starting the logic
    for the state tree. This means that as soon as the game starts, the state tree
    will begin executing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在注册感知系统，并开始状态树的逻辑。这意味着游戏开始后，状态树将开始执行。
- en: 'The last thing to do is implement the **EmitNoise()** function, so add this
    piece of code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是实现**EmitNoise()**函数，所以添加以下这段代码：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In [*Chapter 10*](B31016_10.xhtml#_idTextAnchor198) , *Improving Agents with
    the Perception System* , you already learned how to handle the sight sense. With
    the sense of hearing, things are slightly different; while being visible is a
    continuous occurrence, being heard only occurs when you make noise. This is why
    we randomize a noise range – based on the previously declared properties – and
    we use the **ReportNoiseEvent()** function to emit the actual noise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B31016_10.xhtml#_idTextAnchor198) ，*通过感知系统改进智能体*，你已经学习了如何处理视觉感知。在听觉方面，情况略有不同；虽然可见性是持续发生的，但只有当你发出噪音时才会被听到。这就是为什么我们随机化一个噪音范围——基于之前声明的属性——我们使用**ReportNoiseEvent()**函数来发出实际的噪音。
- en: 'This class is ready, and we can now focus on the actual state tree creation,
    starting from a custom task: something that will tell the actor to emit the noise.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类已经准备好了，我们现在可以专注于实际状态树的创建，从自定义任务开始：告诉演员发出噪音的东西。
- en: Creating the emit noise task
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建发出噪音的任务
- en: 'The state tree task we will be creating needs to just tell the **BaseNoiseEmitter**
    instance to execute the **EmitNoise()** function. This task will be created as
    a Blueprint class so, inside **Content Browser** of the Unreal Engine Editor,
    navigate to the **AI** folder and do the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的状态树任务只需要告诉**BaseNoiseEmitter**实例执行**EmitNoise()**函数。这个任务将作为一个蓝图类创建，所以，在虚幻引擎编辑器的**内容浏览器**中，导航到**AI**文件夹，执行以下操作：
- en: Create a new Blueprint class extending from **StateTreeTaskBlueprintBase** and
    name it **STT_EmitNoise** . Double-click on it to open it.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图类，从**StateTreeTaskBlueprintBase**扩展，命名为**STT_EmitNoise**。双击它以打开它。
- en: In the **My Blueprints** panel, hover over the **FUNCTIONS** section and click
    the **Override** dropdown menu that shows up.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**我的蓝图**面板中，悬停在**函数**部分，并点击出现的**覆盖**下拉菜单。
- en: 'Select the **Enter State** option, as depicted in *Figure 12* *.3* :'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**进入状态**选项，如图*图12* *.3* 所示：
- en: '![Figure 12.3 – Enter State function creation](img/Figure_12.3_B31016.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 创建进入状态函数](img/Figure_12.3_B31016.jpg)'
- en: Figure 12.3 – Enter State function creation
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 创建进入状态函数
- en: An **Event Enter State** node will be added to the Event Graph; this event will
    be executed when a new state in the state tree is entered and if the task is part
    of the active states.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将在事件图中添加一个**事件进入状态**节点；当状态树中的新状态被进入且任务是活动状态的一部分时，将执行此事件。
- en: 'For this state, we need a reference to the owning actor; as previously mentioned,
    state trees use data binding for communicating. Therefore, we will take advantage
    of this feature to create the reference. To do this, follow these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个状态，我们需要一个指向拥有演员的引用；如前所述，状态树使用数据绑定进行通信。因此，我们将利用这一特性来创建引用。为此，请按照以下步骤操作：
- en: Create a new variable that is an **Object Reference** of the **BaseNoiseEmitter**
    type and name it **Actor** .
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的变量，它是**BaseNoiseEmitter**类型的**对象引用**，并将其命名为**Actor**。
- en: 'Select the variable and, in the **Details** panel, locate the **Category**
    attribute and, in the **Input** field, type **Context** , as shown in *Figure
    12* *.4* :'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择变量，在**详细信息**面板中，找到**类别**属性，并在**输入**字段中键入**上下文**，如图*图12* *.4* 所示：
- en: '![Figure 12.4 – Context category](img/Figure_12.4_B31016.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 上下文类别](img/Figure_12.4_B31016.jpg)'
- en: Figure 12.4 – Context category
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 上下文类别
- en: While variable creation is self-explanatory, setting the category name to a
    value of **Context** needs some explanation; whenever you add a property to the
    **Context** category, the property itself will be exposed through data binding
    to the state tree the task will be executed in. This comes quite handy when you
    need to get information from the executing state tree and vice versa.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然变量的创建是显而易见的，但将类别名称设置为**上下文**的值需要一些解释；每次向**上下文**类别添加属性时，该属性本身将通过数据绑定暴露给将要执行的任务的状态树。当你需要从执行状态树获取信息或反之亦然时，这非常有用。
- en: 'With this new reference available, do the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个新参考后，执行以下步骤：
- en: From the **Variables** section, drag the **Actor** variable into the Event Graph
    and add a **Get** **Actor** node.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分，将**Actor**变量拖入事件图，并添加一个**获取** **Actor**节点。
- en: From the outgoing pin of the **Actor** node, connect an **Emit** **Noise** node.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Actor**节点的输出引脚，连接一个**发出** **噪声**节点。
- en: Connect the outgoing execution pin of the **Event Enter State** node with the
    incoming execution pin of the **Emit** **Noise** node.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Event Enter State**节点的输出执行引脚与**发出** **噪声**节点的输入执行引脚连接。
- en: From the outgoing execution pin of the **Emit Noise** node, connect a **Finish**
    **Task** node.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Emit Noise**节点的输出执行引脚，连接一个**完成** **任务**节点。
- en: 'Check the **Succeeded** checkbox of the **Finish Task** node. The final graph
    should look like the one depicted in *Figure 12* *.5* :'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Finish Task**节点的**成功**复选框。最终的图形应该看起来像*图12* *.5* 中所示的那样：
- en: '![Figure 12.5 – Emit Noise graph](img/Figure_12.5_B31016.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 发出噪声图](img/Figure_12.5_B31016.jpg)'
- en: Figure 12.5 – Emit Noise graph
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 发出噪声图
- en: The only thing worth mentioning here is the **Finish Task** node that will return
    a success value after emitting the noise. Now that this task is complete, we can
    finally start working on the state tree.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一值得提的是，在发出噪声后，**Finish Task**节点将返回一个成功值。现在这项任务已经完成，我们终于可以开始处理状态树了。
- en: Creating the noise emitter state tree
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建噪声发射状态树
- en: 'As previously stated, we will be executing the state tree from an actor; this
    means we will need something that can be used with the **StateTreeComponent**
    class. In order to do so, we will need to create an asset that follows the rules
    dictated by a **StateTreeComponentSchema** class that guarantees access to the
    actor executing the state tree. To create such an asset, do the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将从演员执行状态树；这意味着我们需要能够与**StateTreeComponent**类一起使用的东西。为了做到这一点，我们需要创建一个遵循由**StateTreeComponentSchema**类规定的规则的资产，该类确保可以访问执行状态树的演员。要创建此类资产，请按照以下步骤操作：
- en: In **Content Browser** , open the **AI** folder, right-click on it, and select
    **Artificial Intelligence** | **State Tree** .
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中，打开**AI**文件夹，右键单击它，选择**人工智能** | **状态树**。
- en: From the **Pick Schema for State Tree** pop-up window, select **StateTreeComponentSchema**
    .
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**为状态树选择模式**弹出窗口，选择**StateTreeComponentSchema**。
- en: '![Figure 12.6 – State tree creation](img/Figure_12.6_B31016.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 状态树创建](img/Figure_12.6_B31016.jpg)'
- en: Figure 12.6 – State tree creation
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 状态树创建
- en: Name the newly created asset **ST_NoiseEmitter** and double-click on it to open
    it.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产命名为**ST_NoiseEmitter**，双击它以打开它。
- en: 'Once the asset is opened, locate the **StateTree** tab to the left of the Editor
    and notice that there is a **Context Actor Class** property, as shown in *Figure
    12* *.7* :'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦打开资产，找到位于编辑器左侧的**StateTree**标签，并注意有一个**Context Actor Class**属性，如图*图12* *.7*
    所示：
- en: '![Figure 12.7 – State Tree context actor](img/Figure_12.7_B31016.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 状态树上下文演员](img/Figure_12.7_B31016.jpg)'
- en: Figure 12.7 – State Tree context actor
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 状态树上下文演员
- en: This is the reference to the owning actor; at the moment, it is set to a generic
    actor but we need to be more specific, so click on the dropdown menu and select
    an **Object Reference** of **BaseNoiseEmitter** . From now on, each node of the
    tree will be granted access to this reference.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有者演员的引用；目前，它设置为通用演员，但我们需要更具体一些，因此点击下拉菜单并选择**BaseNoiseEmitter**的**对象引用**。从现在起，树中的每个节点都将有权访问此引用。
- en: 'Now, let’s start implementing the state tree logic:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现状态树逻辑：
- en: Click the **Add State** button three times to create three states.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加状态**按钮三次以创建三个状态。
- en: 'Select each of them and, in the **Details** panel, name them **Random Delay**
    , **Debug Message** , and **Emit Noise** , respectively. Your state tree should
    be similar to the one depicted in *Figure 12* *.8* :'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个状态，并在**详细信息**面板中分别命名为**随机延迟**、**调试信息**和**发出噪声**。您的状态树应类似于*图 12* *.8* 中所示：
- en: '![Figure 12.8 – Initial states](img/Figure_12.8_B31016.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 初始状态](img/Figure_12.8_B31016.jpg)'
- en: Figure 12.8 – Initial states
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 初始状态
- en: As you can see, we have created the basis structure for the state tree with
    three main states that will wait for a random time, display a debug message, and
    finally emit the noise.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经创建了状态树的基础结构，包含三个主要状态，这些状态将等待随机时间，显示调试信息，并最终发出噪声。
- en: 'We now need to implement each of the states with their own tasks and transitions;
    let’s start from the first one. Select the **Random Delay** task and do the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要实现每个状态及其自己的任务和转换；让我们从第一个开始。选择**随机延迟**任务并执行以下操作：
- en: In the **Details** panel, locate the **Tasks** section and click the **+** button
    to add a new task.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，定位到**任务**部分，并点击**+**按钮添加一个新任务。
- en: From the newly created task, click the dropdown menu and select **Delay Task**
    .
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新创建的任务中，点击下拉菜单并选择**延迟任务**。
- en: Expand the task by clicking the tiny arrow icon next to the task name. Set the
    **Duration** attribute to **10.0** and the **Random Deviation** attribute to **3.0**
    .
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击任务名称旁边的微小箭头图标来扩展任务。将**持续时间**属性设置为**10.0**并将**随机偏差**属性设置为**3.0**。
- en: Locate the **Transitions** section and click the **+** button to create a new
    transition.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**转换**部分，并点击**+**按钮创建一个新的转换。
- en: 'You should see an item labeled **On State Transition Completed Go to State
    Root** . Click on the tiny arrow icon to expand it, and from the dropdown menu
    of the **Transition To** attribute, select **Next State** . This state should
    look like the one depicted in *Figure 12* *.9* :'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个标记为**在状态转换完成后转到状态根**的项目。点击微小的箭头图标以展开它，并从**转换到**属性的下拉菜单中选择**下一个状态**。此状态应类似于*图
    12* *.9* 中所示：
- en: '![Figure 12.9 – Random delay state](img/Figure_12.9_B31016.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 随机延迟状态](img/Figure_12.9_B31016.jpg)'
- en: Figure 12.9 – Random delay state
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 随机延迟状态
- en: 'We can now start working on the second state – that is, **Debug Message** –
    that is going to display an in-game message. This is obviously not mandatory for
    making our state tree work, but it serves the purpose of learning how things work.
    Select this state and do the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始处理第二个状态——即**调试信息**——它将显示游戏中的消息。这显然不是使我们的状态树工作所必需的，但它有助于学习事物是如何工作的。选择此状态并执行以下操作：
- en: In the **Details** panel, locate the **Tasks** section and click the **+** button
    to add a new task.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，定位到**任务**部分，并点击**+**按钮添加一个新任务。
- en: From the newly created task, click the dropdown menu and select **Debug** **Text
    Task** .
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新创建的任务中，点击下拉菜单并选择**调试文本任务**。
- en: Expand the task by clicking the tiny arrow icon next to the task name. Set the
    **Text** property value to **Emitting Noise!** and the **Text Color** property
    to a color of your choice – in my case, I opted for a bright yellow.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击任务名称旁边的微小箭头图标来扩展任务。将**文本**属性值设置为**发出噪声！**并将**文本颜色**属性设置为您的选择颜色——在我的情况下，我选择了明亮的黄色。
- en: Create another task; click the dropdown menu and select **Delay Task** .
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个任务；点击下拉菜单并选择**延迟任务**。
- en: Expand the task by clicking the tiny arrow icon next to the task name and set
    the **Duration** attribute to **0.5** .
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击任务名称旁边的微小箭头图标来扩展任务，并将**持续时间**属性设置为**0.5**。
- en: Locate the **Transitions** section and click the **+** button to create a new
    transition.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**转换**部分，并点击**+**按钮创建一个新的转换。
- en: 'You should see an item labeled **On State Transition Completed Go to State
    Root** ; click on the tiny arrow icon to expand it and, from the dropdown menu
    of the **Transition To** attribute, select **Next State** . This state should
    look like the one depicted in *Figure 12* *.10* :'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你应该看到一个标记为 **On State Transition Completed Go to State Root** 的项；点击小箭头图标展开它，并从
    **Transition To** 属性的下拉菜单中选择 **Next State** 。这个状态应该看起来像 *图 12.10* :'
- en: '![Figure 12.10 – Debug Message state](img/Figure_12.10_B31016.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 调试信息状态](img/Figure_12.10_B31016.jpg)'
- en: Figure 12.10 – Debug Message state
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 调试信息状态
- en: 'Now select the last state – that is, **Emit Noise** – and do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择最后一个状态——即 **Emit Noise** ——并执行以下操作：
- en: Add a new task, of the **STT Emit** **Noise** type.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新任务，类型为 **STT Emit Noise** 。
- en: Expand the task by clicking the tiny arrow icon; you should notice a property
    named **Actor** and labeled **CONTEXT** . On its far right, you should see a dropdown
    menu arrow. Click on it to open it and select **Actor** .
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击小箭头图标展开任务；你应该注意到一个名为 **Actor** 并标记为 **CONTEXT** 的属性。在其最右边，你应该看到一个下拉菜单箭头。点击它打开它并选择
    **Actor** 。
- en: '![Figure 12.11 – Binding](img/Figure_12.11_B31016.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 绑定](img/Figure_12.11_B31016.jpg)'
- en: Figure 12.11 – Binding
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 绑定
- en: This last action created the binding between the **Actor** property of the state
    tree and the **Actor** property we added when we created the **STT_EmitNoise**
    task. This last property has been exposed because in the task Blueprint; we set
    its category to **Context** .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个动作在状态树的 **Actor** 属性和我们创建 **STT_EmitNoise** 任务时添加的 **Actor** 属性之间建立了绑定。这个最后的属性已经被公开，因为在任务蓝图；我们将它的类别设置为
    **Context** 。
- en: 'This last state will look like the one shown in *Figure 12* *.12* :'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个状态将看起来像 *图 12.12* 中所示的那样：
- en: '![Figure 12.12 – Emit noise state](img/Figure_12.12_B31016.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 发出噪声状态](img/Figure_12.12_B31016.jpg)'
- en: Figure 12.12 – Emit noise state
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 发出噪声状态
- en: Please note that we didn’t add a transition for this task. The default behavior
    is to point to the **Root** node, and we want to create an infinite loop, so we
    simply leave the default behavior.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有为这个任务添加转换。默认行为是指向 **Root** 节点，我们想要创建一个无限循环，所以我们简单地保留了默认行为。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with data binding, things might appear a bit weird initially,
    but do not worry. As you become accustomed to it, things will become quite simple
    and easy to understand.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对数据绑定不熟悉，一开始事情可能看起来有点奇怪，但不要担心。随着你逐渐习惯，事情将会变得相当简单且易于理解。
- en: 'The state tree is finished and should look like *Figure 12* *.13* :'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '状态树已完成，应该看起来像 *图 12.13* :'
- en: '![Figure 12.13 – Finished state tree](img/Figure_12.13_B31016.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – 完成的状态树](img/Figure_12.13_B31016.jpg)'
- en: Figure 12.13 – Finished state tree
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 完成的状态树
- en: As you can see, it is quite easy to get what’s happening in each state and how
    the state tree flow will progress. It’s time to bring everything together and
    get the noise emitter up and running!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，了解每个状态及其状态树流程如何进展是非常容易的。现在是时候将所有东西整合起来，让噪声发射器运行起来！
- en: Creating the noise emitter Blueprint
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建噪声发射器蓝图
- en: 'Creating the Blueprint out of the **BaseNoiseEmitter** class is quite straightforward,
    so let’s do the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **BaseNoiseEmitter** 类创建蓝图相当直接，所以我们按照以下步骤进行：
- en: Create a new Blueprint class extending from **BaseNoiseEmitter** and name it
    **BP_NoiseEmitter** .
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图类，从 **BaseNoiseEmitter** 继承，并命名为 **BP_NoiseEmitter** 。
- en: Open it and locate the **State Tree** attribute in the **AI** section. From
    the dropdown menu, set its value to **ST_NoiseEmitter** .
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它，并在 **AI** 部分找到 **State Tree** 属性。从下拉菜单中，将其值设置为 **ST_NoiseEmitter** 。
- en: '![Figure 12.14 – Finished BP_NoiseEmitter](img/Figure_12.14_B31016.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 完成的 BP_NoiseEmitter](img/Figure_12.14_B31016.jpg)'
- en: Figure 12.14 – Finished BP_NoiseEmitter
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 完成的 BP_NoiseEmitter
- en: This is all you need to do to implement your noise emitter. It is important
    to note that what we have created is not technically an AI agent. This is the
    beauty of state trees; once you grasp the concept, you will be able to apply your
    logic to many different types of use cases.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你实现噪声发射器所需做的所有事情。重要的是要注意，我们所创建的从技术上讲不是一个 AI 代理。这是状态树的美丽之处；一旦你掌握了这个概念，你将能够将你的逻辑应用到许多不同类型的用例中。
- en: Now that the noise emitter is ready, it is time to test it out in a level.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在噪声发射器已经准备好了，是时候在一个关卡中测试它了。
- en: Testing the noise emitter
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试噪声发射器
- en: 'To test the noise emitter, you will just need to create a new gym and add some
    instances of **BP_NoiseEmitter** . To do that, start by doing the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试噪声发射器，您只需创建一个新的健身房并添加一些 **BP_NoiseEmitter** 实例。为此，请按照以下步骤操作：
- en: Create a new level, starting from the Level Instances and Packed Level Actors
    I provided in the project template.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的关卡，从我在项目模板中提供的 Level Instances 和 Packed Level Actors 开始。
- en: Add one or more instances of **BP_NoiseEmitter** to the level.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个或多个 **BP_NoiseEmitter** 实例添加到关卡中。
- en: Play the level.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the **Debug Text Task** message won’t be displayed if we hit
    the **Simulate** button. To show in-game messages, you will need to use the regular
    **Play** button.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们点击 **Simulate** 按钮，**Debug Text Task** 消息将不会显示。要显示游戏中的消息，您需要使用常规的 **Play**
    按钮。
- en: 'As the level is played, you will see each **BP_NoiseEmitter** instance showing
    debug messages at random times, as shown in *Figure 12* *.15* :'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当关卡播放时，您将看到每个 **BP_NoiseEmitter** 实例在随机时间显示调试消息，如图 *图 12* *.15* 所示：
- en: '![Figure 12.15 – Testing the gym](img/Figure_12.15_B31016.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – 测试健身房](img/Figure_12.15_B31016.jpg)'
- en: Figure 12.15 – Testing the gym
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – 测试健身房
- en: In this section, we saw how to implement a state tree inside an actor. Starting
    from creating a custom task that calls a method in the owning actor, we then created
    our first state tree that looped indefinitely, emitting noise signals for the
    Perception System.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何在演员内部实现状态树。从创建一个调用拥有者演员中方法的自定义任务开始，然后我们创建了我们的第一个无限循环的状态树，为感知系统发出噪声信号。
- en: In the following section, we will create a guard puppet that listens for noise
    events and responds accordingly. We will do this using state trees.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将创建一个守卫木偶，它将监听噪声事件并相应地做出反应。我们将使用状态树来完成这项工作。
- en: Using advanced state tree features
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级状态树功能
- en: In this section, we will once again extend the **BaseDummyCharacter** class
    to create an AI agent that listens for noise signals and moves to the location
    where the noise was generated. Once the location has been checked, the AI agent
    will return to its original position. We will start by creating an AI controller
    that will have hearing capabilities through the Perception System and will handle
    its AI logic through state trees. We are essentially developing a guard to protect
    a level from intruders. As usual, let’s start by creating our own base C++ class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将再次扩展 **BaseDummyCharacter** 类以创建一个能够监听噪声信号并移动到噪声发生位置的 AI 代理。一旦检查了位置，AI
    代理将返回到其原始位置。我们将首先创建一个 AI 控制器，它将通过感知系统获得听觉能力，并通过状态树处理其 AI 逻辑。我们实际上正在开发一个守卫来保护关卡免受入侵者。像往常一样，让我们首先创建我们自己的基础
    C++ 类。
- en: Creating the C++ AI controller
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 C++ AI 控制器
- en: 'The AI controller class will need to implement a hearing sense and execute
    state tree logic. As mentioned earlier, at the time of writing this book, there
    seems to be a bug in Unreal Engine that prevents us from declaring a **StateTreeAIComponent**
    class in C++ so, for the time being, we will be implementing just the hearing
    sense and adding the state tree component from Blueprints. Let’s create a new
    C++ class called **BaseGuardAIController** . Then, open the **BaseGuardAIController.h**
    file and add the following forward declaration after the **#** **include** declarations:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能控制器类需要实现听觉感知并执行状态树逻辑。如前所述，在撰写本书时，似乎存在一个 Unreal Engine 的错误，阻止我们在 C++ 中声明
    **StateTreeAIComponent** 类，因此，暂时我们将只实现听觉感知，并从蓝图添加状态树组件。让我们创建一个新的 C++ 类，称为 **BaseGuardAIController**。然后，打开
    **BaseGuardAIController.h** 文件，在 **#include** 声明之后添加以下前置声明：
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, add a **public** section with the following function declarations:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加一个 **public** 部分，包含以下函数声明：
- en: '[PRE14]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are already familiar with these function declarations but note that the
    **OnTargetPerceptionUpdate()** function has a **BlueprintImplementableEvent**
    specifier added; this will let us implement this function from an extending Blueprint
    instead of directly doing it from this class. This means we are leaving the responsibility
    of implementing this function to the Blueprint. Now, let’s open the **BaseGuardAIController.cpp**
    file to implement the functions. The needed **#include** declarations you should
    be adding are the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了这些函数声明，但请注意，**OnTargetPerceptionUpdate()** 函数添加了 **BlueprintImplementableEvent**
    指示符；这将使我们能够从扩展蓝图而不是直接从此类中实现此函数。这意味着我们将实现此函数的责任留给了蓝图。现在，让我们打开 **BaseGuardAIController.cpp**
    文件来实现函数。您应该添加的所需 **#include** 声明如下：
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add the constructor implementation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加构造函数实现：
- en: '[PRE16]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We already know how to configure an **AIPerceptionComponent** from [*Chapter
    10*](B31016_10.xhtml#_idTextAnchor198) , *Improving Agents with the Perception
    System* , so I will not bother you with extra details. Just pay attention to the
    final line of code, where we are registering the delegate that will manage the
    hearing stimuli.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何配置 **AIPerceptionComponent**，请参阅 [*第 10 章*](B31016_10.xhtml#_idTextAnchor198)
    ，*通过感知系统改进代理*，因此我不会在这里提供额外细节。只需注意代码的最后一行，其中我们注册了将管理听觉刺激的委托。
- en: You can now compile your project to make this class available to the Blueprint
    system as, in the next few steps, we will create the AI controller Blueprint.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以编译项目，使此类对蓝图系统可用，因为在接下来的几个步骤中，我们将创建 AI 控制器蓝图。
- en: Implementing the AI controller Blueprint
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现AI控制器蓝图
- en: 'Now that the base AI controller is ready, we can start implementing a Blueprint
    version that will also manage the state tree. To get started, in the **Blueprints**
    folder, create a new Blueprint class extending from **BaseGuardAIController**
    , call it **AIGuardController** , and open it. Then, do the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本 AI 控制器已准备就绪，我们可以开始实现一个将管理状态树的蓝图版本。要开始，在 **Blueprints** 文件夹中，创建一个从 **BaseGuardAIController**
    扩展的新蓝图类，命名为 **AIGuardController**，并打开它。然后，执行以下步骤：
- en: Create a new variable of the **Name** type and call it **NoiseTag** . Make it
    **Instance Editable** . After compiling this Blueprint, set the default value
    for this variable to **EmitterNoise** .
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **NoiseTag** 的新变量，并设置为 **Name** 类型；将其设置为 **Instance Editable**。编译此蓝图后，将此变量的默认值设置为
    **EmitterNoise**。
- en: Create another variable of the **Vector** type and name it **NoiseLocation**
    ; make it **Instance Editable** .
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 **NoiseLocation** 的 **Vector** 类型的变量；将其设置为 **Instance Editable**。
- en: Create a third variable of the **Vector** type and name it **StartLocation**
    ; make it **Instance Editable** .
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **StartLocation** 的 **Vector** 类型的第三个变量；将其设置为 **Instance Editable**。
- en: Now, let’s handle the state tree by following the steps that ensue.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们按照后续步骤处理状态树。
- en: Add a new component of the **StateTreeAI** type.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **StateTreeAI** 类型的组件。
- en: Drag the component into the Event Graph to add a reference to the component
    itself.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件拖入事件图以添加对该组件本身的引用。
- en: From the outgoing pin of the **State Tree AI** node, connect a **Start** **Logic**
    node.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **State Tree AI** 节点的输出插针连接一个 **Start Logic** 节点。
- en: 'Connect the outgoing execution pin of the **Event Begin Play** node to the
    incoming execution pin of the **Start Logic** node. The Event Graph should look
    like *Figure 12* *.16* :'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Event Begin Play** 节点的输出执行插针连接到 **Start Logic** 节点的输入执行插针。事件图应类似于 *图 12*
    *.16*：
- en: '![Figure 12.16 – Event Begin Play](img/Figure_12.16_B31016.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.16 – Event Begin Play](img/Figure_12.16_B31016.jpg)'
- en: Figure 12.16 – Event Begin Play
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – Event Begin Play
- en: This portion of the graph will start the execution of the state tree. Now, let’s
    store the AI character’s starting location. To do this, follow the steps that
    ensue.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分图将启动状态树的执行。现在，让我们存储 AI 角色的起始位置。为此，请按照以下步骤操作。
- en: From the **Variables** section, drag the **StartLocation** variable into the
    Event Graph and make it a setter node.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Variables** 部分将 **StartLocation** 变量拖入事件图，并将其设置为设置节点。
- en: Connect the outgoing execution pin of the **Start Logic** node to the incoming
    execution pin of the **Set Start** **Location** node.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Start Logic** 节点的输出执行插针连接到 **Set Start Location** 节点的输入执行插针。
- en: Add a **Get Actor Location** node and add its **Return Value** pin to the **Start
    Location** pin of the **Set Start** **Location** node.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **Get Actor Location** 节点，并将其 **Return Value** 插针连接到 **Set Start Location**
    节点的 **Start Location** 插针。
- en: 'Add a **Get Controller Pawn** node and connect its **Return Value** pin to
    the **Target** pin of the **Get Actor Location** node. This portion of the graph
    is depicted in *Figure 12* *.17* :'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **Get Controller Pawn** 节点，并将其 **Return Value** 插针连接到 **Get Actor Location**
    节点的 **Target** 插针。此部分图示在 *图 12* *.17* 中：
- en: '![Figure 12.17 – Store starting location](img/Figure_12.17_B31016.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – 存储起始位置](img/Figure_12.17_B31016.jpg)'
- en: Figure 12.17 – Store starting location
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – 存储起始位置
- en: 'The **Event BeginPlay** code logic has been completed, so we can start implementing
    the previously declared **OnTargetPerceptionUpdated()** function. To do this,
    follow these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**Event BeginPlay** 代码逻辑已完成，因此我们可以开始实现之前声明的 **OnTargetPerceptionUpdated()**
    函数。为此，请按照以下步骤操作：'
- en: Right-click in the Event Graph and add an **Event On Target Perception** **Update**
    node.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中右键单击并添加一个 **Event On Target Perception Update** 节点。
- en: Click and drag from the **Stimulus** outgoing pin and add a **Break** **AIStimulus**
    node.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Stimulus**输出引脚点击并拖动，添加一个**Break AIStimulus**节点。
- en: From the **Variables** panel, drag a getter node for the **NoiseTag** variable.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**面板，拖动**NoiseTag**变量的getter节点。
- en: From the outgoing pin of the **Noise Tag** node, add an **Equal (==)** node.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Noise Tag**节点的输出引脚，添加一个**Equal (==)**节点。
- en: Connect the **Tag** outgoing pin of the **Break AIStimulus** node to the second
    incoming pin of the **Equal (==)** node.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Break AIStimulus**节点的**Tag**输出引脚连接到**Equal (==)**节点的第二个输入引脚。
- en: Connect the outgoing execution pin of the **Event On Target Perception Update**
    node to a **Branch** node.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Event On Target Perception Update**节点的输出执行引脚连接到一个**Branch**节点。
- en: 'Connect the outgoing pin of the **Equal (==)** node to the **Condition** pin
    of the **Break** node. This portion of the graph is depicted in *Figure 12* *.18*
    :'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Equal (==)**节点的输出引脚连接到**Break**节点的**Condition**引脚。此部分图示见*图12* *.18*：
- en: '![Figure 12.18 – Check stimulus tag](img/Figure_12.18_B31016.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图12.18 – 检查刺激标签](img/Figure_12.18_B31016.jpg)'
- en: Figure 12.18 – Check stimulus tag
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 – 检查刺激标签
- en: 'We now need to store the location of the noise, so let’s do the following steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要存储噪声的位置，所以请按照以下步骤操作：
- en: From the **Variables** section, drag the **NoiseLocation** reference to create
    a **Set** node.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分，拖动**NoiseLocation**引用以创建一个**Set**节点。
- en: Connect the node’s incoming execution pin to the **True** execution pin of the
    **Branch** node.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点的输入执行引脚连接到**Branch**节点的**True**执行引脚。
- en: 'Connect the **Noise Location** pin of the **Set Noise Location** node to the
    **Stimulus Location** pin of the **Break AI Stimulus** node. This portion of the
    graph is shown in *Figure 12* *.19* :'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Set Noise Location**节点的**Noise Location**引脚连接到**Break AI Stimulus**节点的**Stimulus
    Location**引脚。此部分图示见*图12* *.19*：
- en: '![Figure 12.19 – Store noise location](img/Figure_12.19_B31016.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图12.19 – 存储噪声位置](img/Figure_12.19_B31016.jpg)'
- en: Figure 12.19 – Store noise location
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 – 存储噪声位置
- en: The last thing we need to do is to notify the state tree that a noise has been
    heard and that the AI agent needs to respond consequently. To do so, we will be
    using **Gameplay Tags** .
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是通知状态树已经听到了噪声，并且AI代理需要相应地做出反应。为此，我们将使用**Gameplay Tags**。
- en: Note
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Unreal Engine, the Gameplay Tag system is used to mark and categorize gameplay
    elements. Gameplay Tags are lightweight identifiers that can be easily attached
    to game entities (such as actors or components) to help organize and classify
    them in a flexible and efficient way. Learning how to work with Gameplay Tags
    is out of the scope of this book; we will be just learning the bare minimum to
    properly communicate with a state tree.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，游戏玩法标签系统用于标记和分类游戏元素。游戏玩法标签是轻量级的标识符，可以轻松地附加到游戏实体（如演员或组件）上，以灵活和高效的方式组织和分类它们。学习如何使用游戏玩法标签超出了本书的范围；我们将只学习最基本的内容，以便正确地与状态树通信。
- en: 'Let’s get on with our Event Graph implementation by doing the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行事件图的实现，按照以下步骤操作：
- en: Add a **Make StateTreeEvent** node to the graph.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中添加一个**Make StateTreeEvent**节点。
- en: Add a **Send State Tree Event** node to the graph.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中添加一个**Send State Tree Event**节点。
- en: Drag a reference of the **StateTreeAI** component into the graph.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**StateTreeAI**组件的引用拖入图中。
- en: Connect the outgoing execution pin of the **Set Noise Location** node to the
    incoming execution pin of the **Send State Tree** **Event** node.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Set Noise Location**节点的输出执行引脚连接到**Send State Tree Event**节点的输入执行引脚。
- en: Connect the **State Tree AI** node to the **Target** pin of the **Send State
    Tree** **Event** node.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**State Tree AI**节点连接到**Send State Tree Event**节点的**Target**引脚。
- en: Connect the outgoing pin of the **Make State Tree Event** node to the incoming
    **Event** pin of the **Send State Tree** **Event** node.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Make State Tree Event**节点的输出引脚连接到**Send State Tree Event**节点的输入**Event**引脚。
- en: 'In the **Origin** input field of the **Make StateTreeEvent** node, type **AI
    Controller** . This portion of the graph should look like *Figure 12* *.20* :'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Make StateTreeEvent**节点的**Origin**输入字段中，键入**AI Controller**。此部分图应类似于*图12*
    *.20*：
- en: '![Figure 12.20 – Send State Tree Event](img/Figure_12.20_B31016.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20 – 发送状态树事件](img/Figure_12.20_B31016.jpg)'
- en: Figure 12.20 – Send State Tree Event
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 – 发送状态树事件
- en: 'This portion of the code is responsible for communicating with the state tree
    by sending an event; the event will need to be tagged in order to be recognized
    by the state tree itself. To do so, we need to create a Gameplay Tag. You can
    do this by following these steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码负责通过发送事件与状态树通信；该事件需要被标记以便状态树本身能够识别。为此，我们需要创建一个游戏标签。您可以通过以下步骤完成此操作：
- en: In the **Make StateTreeEvent** node, click on the dropdown menu next to the
    **Tag** incoming pin. At the moment, it should be labeled as **None** .
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Make StateTreeEvent** 节点中，点击 **标签** 输入引脚旁边的下拉菜单。目前，它应标记为 **None**。
- en: You will get a list of available tags; click on the **Manage Gameplay Tags…**
    option to open the **Gameplay Tag** **Manager** window.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将获得一个可用标签列表；点击 **管理游戏标签…** 选项以打开 **游戏标签** **管理器** 窗口。
- en: '![Figure 12.21 – Manage Gameplay Tags… option](img/Figure_12.21_B31016.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.21 – 管理游戏标签…选项](img/Figure_12.21_B31016.jpg)'
- en: Figure 12.21 – Manage Gameplay Tags… option
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.21 – 管理游戏标签…选项
- en: Once the **Gameplay Tag Manager** window is open, click on the **+** button.
    In the **Name** input field, enter **UnrealAgilityArena.StateTree.HeardNoise**
    and, in the **Source** field, select **DefaultGameplayTags.ini** .
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 **游戏标签管理器** 窗口打开，点击 **+** 按钮。在 **名称** 输入字段中，输入 **UnrealAgilityArena.StateTree.HeardNoise**，并在
    **来源** 字段中选择 **DefaultGameplayTags.ini**。
- en: Click the **Add New Tag** button to confirm the creation of the new Gameplay
    Tag.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加新标签** 按钮以确认创建新的游戏标签。
- en: '![Figure 12.22 – Create Gameplay Tag](img/Figure_12.22_B31016.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.22 – 创建游戏标签](img/Figure_12.22_B31016.jpg)'
- en: Figure 12.22 – Create Gameplay Tag
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22 – 创建游戏标签
- en: In the **Make StateTreeEvent** node, click on the **Tag** dropdown menu and
    select the **HeardNoise** checkbox to select that gameplay tag.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Make StateTreeEvent** 节点中，点击 **标签** 下拉菜单并选择 **HeardNoise** 复选框以选择该游戏标签。
- en: '![Figure 12.23 – Select Gameplay Tag](img/Figure_12.23_B31016.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.23 – 选择游戏标签](img/Figure_12.23_B31016.jpg)'
- en: Figure 12.23 – Select Gameplay Tag
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23 – 选择游戏标签
- en: We’re almost done with the **AIGuardController** Blueprint; the only thing left
    is to include the state tree reference, but we have to create it first!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了 **AIGuardController** 蓝图的制作；唯一剩下的事情就是包含状态树引用，但我们必须先创建它！
- en: Implementing the state tree
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态树
- en: Now, we are going to implement the state tree. This time, we will be executing
    it from the **AIGuardController** Blueprint. That’s why we will need a subclass
    of the regular state tree – that is the state tree AI – that will have a reference
    to the owning AI controller.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现状态树。这次，我们将从 **AIGuardController** 蓝图中执行它。这就是为什么我们需要一个常规状态树的子类 – 那就是状态树AI
    – 它将有一个对拥有AI控制器的引用。
- en: 'The main states will be the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 主要状态如下：
- en: '**Idle** : The AI agent will stay at its starting location'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空闲**：AI代理将停留在其起始位置'
- en: '**Alerted** : The AI agent has been notified of a noise and it will go inspecting
    the location'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：AI代理已收到噪音通知，它将去检查位置'
- en: '**Return to Starting Location** : The AI agent will get back to its starting
    location'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回起始位置**：AI代理将返回其起始位置'
- en: 'So, let’s start by opening the **AI** folder and doing the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先打开 **AI** 文件夹并执行以下步骤：
- en: Right-click and select **Artificial Intelligence** | **State Tree** .
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并选择 **人工智能** | **状态树**。
- en: From the **Pick Schema for State Tree** pop-up window, select **StateTreeAIComponentSchema**
    and name the newly created asset **STAI_Guard** . Double-click on it to open it.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **选择状态树架构** 弹出窗口中，选择 **StateTreeAIComponentSchema** 并将新创建的资产命名为 **STAI_Guard**
    。双击它以打开它。
- en: In the **StateTree** left panel, set the **AIController Class** attribute to
    **AIGuardController** and the **Context Actor Class** attribute to **BP_Guard**
    .
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **状态树** 左侧面板中，将 **AI控制器类** 属性设置为 **AIGuardController**，将 **上下文演员类** 属性设置为
    **BP_Guard**。
- en: As we have already mentioned, the aforementioned steps will bind the state tree
    to the owning AI controller and actor; this way you will be granted access to
    their properties.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，上述步骤将状态树绑定到拥有AI控制器和演员；这样您将有权访问它们的属性。
- en: 'We are now going to implement the base states. To do so, carry out the following
    steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现基本状态。为此，执行以下步骤：
- en: Create three states and call them, **Idle** , **Warned** , **Resume** , respectively.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个状态，分别命名为 **Idle**、**Warned**、**Resume**。
- en: Select both the **Warned** and **Resume** states and, in the **Details** panel,
    set the **Type** attribute to **Group** .
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **警告** 和 **恢复** 状态，并在 **详细信息** 面板中，将 **类型** 属性设置为 **组**。
- en: We marked the **Warned** and **Resume** states as groups because they won’t
    contain tasks but will delegate them to child states. They basically function
    as state containers.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将**警告**和**恢复**状态标记为组，因为它们不会包含任务，而是将任务委托给子状态。它们基本上充当状态容器。
- en: 'As an extra option, the **State Tree** panel has a **Theme** section that will
    let you define state colors that can then be applied to each state – and its own
    children – in the **Details** panel. In my case, I have opted for the colors depicted
    in *Figure 12* *.24* :'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外选项，**状态树**面板有一个**主题**部分，它允许您定义可以应用于**详细信息**面板中每个状态及其子状态的州颜色。在我的情况下，我选择了*图12*
    *.24*中显示的颜色：
- en: '![Figure 12.24 – Base states](img/Figure_12.24_B31016.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图12.24 – 基础状态](img/Figure_12.24_B31016.jpg)'
- en: Figure 12.24 – Base states
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 – 基础状态
- en: Let’s now implement each state separately.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将分别实现每个状态。
- en: Implementing the Idle state
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现空闲状态
- en: 'The **Idle** state is going to be quite simple; we will make the AI agent wait
    in some sort of infinite loop until we get a noise notification. To implement
    this state, select it and do the following steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**空闲**状态将会非常简单；我们将让AI代理在一个无限循环中等待，直到我们收到噪声通知。要实现此状态，选择它并执行以下步骤：'
- en: Add a **Delay Task** with the **Duration** attribute set to **10.0** .
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有**持续时间**属性设置为**10.0**的**延迟任务**。
- en: 'Add a **Transition** with the following settings:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有以下设置的**过渡**：
- en: The **Trigger** attribute set to **On** **State Completed**
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发**属性设置为**在状态完成时**'
- en: The **Transition To** attribute set to **Idle**
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡到**属性设置为**空闲**'
- en: 'Add another **Transition** with the following settings:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个具有以下设置的**过渡**：
- en: The **Trigger** attribute set to **On Event**
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发**属性设置为**在事件发生时**'
- en: The **Event Tag** attribute set to **UnrealAgilityArena.StateTree.HeardNoise**
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件标签**属性设置为**UnrealAgilityArena.StateTree.HeardNoise**'
- en: The **Transition To** attribute set to **Alert**
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡到**属性设置为**警报**'
- en: The **Priority** attribute set to **High**
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**属性设置为**高**'
- en: '![Figure 12.25 – Idle state](img/Figure_12.25_B31016.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图12.25 – 空闲状态](img/Figure_12.25_B31016.jpg)'
- en: Figure 12.25 – Idle state
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 – 空闲状态
- en: As you can see, we will keep on looping inside this state until we get an event
    from the AI controller notifying us that a noise has been heard. In this case,
    we will transition to the **Alert** state.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将在这个状态内部持续循环，直到从AI控制器收到通知，表示已经听到噪声。在这种情况下，我们将过渡到**警报**状态。
- en: Implementing the Alert state
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现警报状态
- en: Once in the **Alert** state, the AI agent will try to move to the noise location.
    Once it reaches that point, will wait for some time before changing state; we
    will need two child states for this.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入**警报**状态，AI代理将尝试移动到噪声位置。一旦到达那个位置，它将等待一段时间后再改变状态；为此我们需要两个子状态。
- en: 'So, to create the first child state, do the following steps:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建第一个子状态，请执行以下步骤：
- en: Create a new state and call it **Move to** **Noise Location** .
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的状态并命名为**移动到** **噪声位置**。
- en: 'Add a task of the **Action** | **Move To** type and do the following steps
    with it:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**动作** | **移动到**类型的任务，并按照以下步骤进行操作：
- en: Bind the **AIController** attribute – labeled **CONTEXT** – to the owner AI
    controller by clicking the dropdown arrow and selecting **AIController** .
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击下拉箭头并选择**AIController**将**AIController**属性（标记为**上下文**）绑定到拥有者AI控制器。
- en: Locate the **Destination** attribute, click the dropdown arrow, and select **AIController**
    | **Noise Location** to bind this attribute to the **NoiseLocation** property
    of the AI controller owner.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**目标**属性，点击下拉箭头，选择**AIController** | **噪声位置**以将此属性绑定到AI控制器拥有者的**NoiseLocation**属性。
- en: 'Add a **Transition** with the following settings:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有以下设置的**过渡**：
- en: The **Trigger** attribute set to **On** **State Succeeded**
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发**属性设置为**在状态成功时**'
- en: The **Transition To** attribute set to **Next State**
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡到**属性设置为**下一个状态**'
- en: 'Add another **Transition** with the following settings:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个具有以下设置的**过渡**：
- en: The **Trigger** attribute set to **On** **State Failed**
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发**属性设置为**在状态失败时**'
- en: The **Transition To** attribute set to **Resume**
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡到**属性设置为**恢复**'
- en: '![Figure 12.26 – Move to Noise Location state](img/Figure_12.26_B31016.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图12.26 – 移动到噪声位置状态](img/Figure_12.26_B31016.jpg)'
- en: Figure 12.26 – Move to Noise Location state
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26 – 移动到噪声位置状态
- en: This portion of the state tree will move the AI agent to the location set inside
    the **NoiseLocation** attribute of the owning AI controller. Once successful,
    the next state will be executed. If the location cannot be reached, it will get
    back to its original position.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态树的这一部分将AI代理移动到拥有AI控制器内**噪声位置**属性中设置的位置。一旦成功，将执行下一个状态。如果位置无法到达，它将回到原始位置。
- en: 'Let’s now create the second child state for the **Alert** state by doing the
    following steps:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过以下步骤创建**警报**状态的第二个子状态：
- en: Create a new state and call it **Inspect** **Noise Location** .
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的状态，并将其命名为**检查** **噪声位置**。
- en: 'Add a task of the **Delay Task** type and do the following with it:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**延迟任务**类型的任务，并按照以下步骤操作：
- en: Set the **Duration** attribute to **3.0**
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**持续时间**属性设置为**3.0**
- en: Set the **Random Deviation** attribute to **1.0**
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**随机偏差**属性设置为**1.0**
- en: 'Add a **Transition** with the following settings:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有以下设置的**转换**：
- en: The **Trigger** attribute set to **On** **State Completed**
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**触发**属性设置为**在状态完成时**
- en: The **Transition To** attribute set to **Resume**
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**转换到**属性设置为**恢复**
- en: '![Figure 12.27 – Inspect Noise Location state](img/Figure_12.27_B31016.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图12.27 – 检查噪声位置状态](img/Figure_12.27_B31016.jpg)'
- en: Figure 12.27 – Inspect Noise Location state
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27 – 检查噪声位置状态
- en: This portion of the state tree will just make the AI agent wait for a bit, before
    it goes back to its original location. If the AI agent doesn’t find anything suspicious,
    it gets back to its guard location.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树的这一部分将使AI代理稍作等待，然后返回到其原始位置。如果AI代理没有发现任何可疑之处，它将返回到其警戒位置。
- en: Implementing the Resume state
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现恢复状态
- en: 'The **Resume** state will need to bring the AI agent back to its original position;
    additionally, at any time, this state should be interrupted if a new noise has
    been notified. So, to create the first child state, do the following steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**恢复**状态需要将AI代理带回到其原始位置；此外，在任何时候，如果通知了新的噪声，此状态应被中断。因此，要创建第一个子状态，请按照以下步骤操作：'
- en: Create a new state and call it **Move to** **Starting Location** .
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的状态，并将其命名为**移动到** **起始位置**。
- en: 'Add a task of the **Action** | **Move To** type and do the following steps
    with it:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**动作** | **移动到**类型的任务，并按照以下步骤操作：
- en: Bind the **AI Controller** attribute – labeled **CONTEXT** – to the owner AI
    controller by clicking the dropdown arrow and selecting **AI Controller** .
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击下拉箭头并选择**AI控制器**，将标记为**上下文**的**AI控制器**属性绑定到拥有AI控制器。
- en: Locate the **Destination** attribute, click the dropdown arrow, and select **AIController**
    | **Start Location** to bind this attribute to the **StartLocation** property
    of the AI controller owner.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**目标**属性，点击下拉箭头，选择**AI控制器** | **起始位置**以将此属性绑定到AI控制器所有者的**起始位置**属性。
- en: 'Add a **Transition** with the following settings:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有以下设置的**转换**：
- en: The **Trigger** attribute set to **On** **State Completed**
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**触发**属性设置为**在状态完成时**
- en: The **Transition To** attribute set to **Next State**
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**转换到**属性设置为**下一个状态**
- en: '![Figure 12.28 – Move to Start Location state](img/Figure_12.28_B31016.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图12.28 – 移动到起始位置状态](img/Figure_12.28_B31016.jpg)'
- en: Figure 12.28 – Move to Start Location state
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28 – 移动到起始位置状态
- en: This state is pretty similar to the **Move to Noise Location** one; the only
    difference is the **Destination** attribute that, in this case, is the original
    location of the AI agent.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此状态与**移动到噪声位置**类似；唯一的区别是**目标**属性，在这种情况下，是AI代理的原始位置。
- en: 'Let’s now create the second child state for the **Resume** state by doing the
    following steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过以下步骤创建**恢复**状态的第二个子状态：
- en: Create a new state and call it **Wait** .
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的状态，并将其命名为**等待**。
- en: 'Add a task of the **Delay Task** type and do the following with it:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**延迟任务**类型的任务，并按照以下步骤操作：
- en: Set the **Duration** attribute to **2.0**
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**持续时间**属性设置为**2.0**
- en: Set the **Random Deviation** attribute to **1.0**
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**随机偏差**属性设置为**1.0**
- en: 'Add a **Transition** with the following settings:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有以下设置的**转换**：
- en: The **Trigger** attribute set to **On** **State Completed**
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**触发**属性设置为**在状态完成时**
- en: The **Transition To** attribute set to **Idle**
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**转换到**属性设置为**空闲**
- en: '![Figure 12.29 – Wait state](img/Figure_12.29_B31016.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图12.29 – 等待状态](img/Figure_12.29_B31016.jpg)'
- en: Figure 12.29 – Wait state
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29 – 等待状态
- en: 'As a last step, we will need to interrupt the **Resume** state if a new noise
    has been heard, so select the **Resume** state and do the following steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，如果听到新的噪声，我们需要中断**Resume**状态，因此选择**Resume**状态并执行以下步骤：
- en: 'Add a **Transition** with the following settings:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下设置的**过渡**：
- en: The **Trigger** attribute set to **On Event**
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**触发**属性设置为**On Event**
- en: The **Event Tag** attribute set to **UnrealAgilityArena.StateTree.HeardNoise**
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**事件标签**属性设置为**UnrealAgilityArena.StateTree.HeardNoise**
- en: The **Transition** To attribute set to **Alert**
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**过渡**到属性设置为**Alert**
- en: The **Priority** attribute set to **High**
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**优先级**属性设置为**高**
- en: '![Figure 12.30 – Resume state](img/Figure_12.30_B31016.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图12.30 – Resume状态](img/Figure_12.30_B31016.jpg)'
- en: Figure 12.30 – Resume state
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30 – Resume状态
- en: 'The state tree is pretty complete, and it should look like the one shown in
    *Figure 12* *.31* :'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树相当完整，应该看起来像*图12* *.31* 中所示的那样：
- en: '![Figure 12.31 – Finished state tree](img/Figure_12.31_B31016.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图12.31 – 完成的状态树](img/Figure_12.31_B31016.jpg)'
- en: Figure 12.31 – Finished state tree
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31 – 完成的状态树
- en: Now that the state tree is ready, we will need to add it to the AI controller.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态树已准备就绪，我们需要将其添加到AI控制器中。
- en: Assigning the state tree to the AI controller
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将状态树分配给AI控制器
- en: Assigning the newly created state tree to the AI controller is pretty straightforward.
    Just open the **AIGuardController** Blueprint and, in the **Details** panel, locate
    the **AI** section. Set the **State Tree** property to **STAI_Guard** .
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 将新创建的状态树分配给AI控制器相当直接。只需打开**AIGuardController**蓝图，在**详细信息**面板中找到**AI**部分。将**状态树**属性设置为**STAI_Guard**。
- en: Once this is done, we can create the AI agent Blueprint.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以创建AI代理蓝图。
- en: Creating the guard Blueprint
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建守卫蓝图
- en: We will now create our guard Blueprint and assign the AI logic to it. To do
    this, open **Content Drawer** . In the **Blueprints** folder, create a new Blueprint
    extending from **Base Dummy Character** and call it **BP_Guard** .
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建我们的守卫蓝图并将AI逻辑分配给它。为此，打开**内容抽屉**。在**蓝图**文件夹中，创建一个从**Base Dummy Character**扩展的新蓝图，并将其命名为**BP_Guard**。
- en: Open the newly created Blueprint and, in the **Details** panel, set the **AI
    Controller Class** attribute to **AIGuardController** .
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新创建的蓝图，在**详细信息**面板中，将**AI控制器类**属性设置为**AIGuardController**。
- en: '![Figure 12.32 – Guard Blueprint](img/Figure_12.32_B31016.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图12.32 – 守卫蓝图](img/Figure_12.32_B31016.jpg)'
- en: Figure 12.32 – Guard Blueprint
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32 – 守卫蓝图
- en: The guard AI agent is now ready; we just need to test it out in a gym.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫AI代理现在已准备就绪；我们只需要在健身房中测试它。
- en: Testing in a gym
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在健身房中测试
- en: With the Blueprint class ready, it’s time to test it out. All you need to do
    is to add it to the previously created gym and play the level. Whenever a noise
    is emitted by a noise emitter actor, you should see the **BP_Guard** instance
    try to reach the noise location and, after a while, get back to its original position.
    Obviously, all of this will work if the AI agent is in range of the provoked noise
    location. You can obviously leverage your understanding of AI debugging tools
    to gain valuable insights into the hearing capabilities and range of the AI agent.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当蓝图类准备就绪时，是时候测试它了。你只需要将其添加到之前创建的健身房，并玩这个关卡。每当噪声发生器演员发出噪声时，你应该看到**BP_Guard**实例试图到达噪声位置，然后过一会儿回到其原始位置。显然，所有这些都会在AI代理在引起噪声的位置范围内时工作。你可以显然利用你对AI调试工具的理解来获得关于AI代理听觉能力和范围的宝贵见解。
- en: '![Figure 12.33 – Testing the gym](img/Figure_12.33_B31016.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图12.33 – 测试健身房](img/Figure_12.33_B31016.jpg)'
- en: Figure 12.33 – Testing the gym
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33 – 测试健身房
- en: In this quite lengthy section, you got more advanced information on how to implement
    your own state trees. Starting from an AI controller with some hearing capabilities,
    we learned how to control a state tree and bind important data between the state
    tree and the AI controller. Finally, we added the AI controller and, consequently,
    the state tree to an AI agent and tested its behaviors in a gym.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当长的部分中，你获得了更多关于如何实现自己的状态树的高级信息。从一个具有一些听觉能力的AI控制器开始，我们学习了如何控制状态树并在状态树和AI控制器之间绑定重要数据。最后，我们将AI控制器和状态树添加到AI代理中，并在健身房中测试其行为。
- en: The AI agent we have created sets the foundation for a complete AI guard agent.
    Currently, it simply checks for any suspicious noises and investigates their source.
    I highly recommend adding your own logic to introduce more actions, such as sounding
    an alarm when an enemy is detected or trying to attack the source of the noise.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的AI代理为完整的AI守卫代理奠定了基础。目前，它仅仅检查任何可疑的声音并调查其来源。我强烈建议添加你自己的逻辑来引入更多动作，例如在检测到敌人或试图攻击声音来源时发出警报。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: State trees in Unreal Engine are crucial in the AI framework as they help manage
    and organize the decision-making processes of AI agents efficiently. They offer
    a neat alternative to behavior trees depending on your design and development
    patterns.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，状态树对于AI框架至关重要，因为它们有助于高效地管理和组织AI代理的决策过程。它们根据你的设计和开发模式提供了一个整洁的替代方案，即行为树。
- en: In this chapter, we learned the basics of state trees, a hierarchical state
    machine framework implemented in Unreal Engine. Starting from its main concepts,
    such as how states are handled, we were introduced to the main elements involved
    – including tasks, transitions, and conditions. After that, we created our own
    actors, taking advantage of state trees.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了状态树的基础知识，这是在虚幻引擎中实现的一个分层状态机框架。从其主要概念开始，例如状态是如何处理的，我们被引入了涉及的主要元素——包括任务、转换和条件。之后，我们创建了我们的自己的演员，利用了状态树的优势。
- en: 'In the next chapter, we will be working on a totally different topic: how to
    manage huge numbers of objects within your level, treating them as a collective
    group for processing or simulation purposes.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理一个完全不同的主题：如何在你的关卡内管理大量对象，将它们作为一个集体组来处理或进行模拟。
