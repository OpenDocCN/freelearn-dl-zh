- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Hierarchical State Machines with State Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal Engine provides a powerful framework for creating complex AI behaviors
    through **hierarchical state machines** called **state trees** . By defining various
    states and transitions, developers can design sophisticated AI logic that adapts
    to dynamic environments. State trees offer a structured approach to managing AI
    behavior, allowing for efficient decision-making and seamless integration with
    other systems in Unreal Engine. What’s more, with state trees, you can build clever
    AI agents that respond to environmental stimuli and interact with the game world
    in a natural and realistic manner. The purpose of the chapter is to introduce
    you to the state tree framework in Unreal Engine and to its basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will have a quick introduction to the state tree system
    available in Unreal Engine and see how to implement state trees inside a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing state trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and managing state trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced state tree features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll be using the starter content available in this book’s companion repository
    located at [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    . Through this link, locate the section for this chapter and download the following
    **.zip** file: **Unreal Agility Arena –** **Starter Content** .'
  prefs: []
  type: TYPE_NORMAL
- en: Although not mandatory, you can use the code created so far or download the
    files that correspond to the end of the last chapter by clicking the **Unreal
    Agility Arena –** **Chapter 11** **-** **End** link.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing state trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It appeared inevitable that, sooner or later, someone would uncover Dr. Markus’
    secret experiments:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hidden in their secret laboratory, Dr. Markus and Professor Viktoria kept
    on with their groundbreaking experiments. However, news of their remarkable inventions
    began to spread like wildfire; paparazzi and curious individuals started flocking
    to the area, eager to uncover the secrets hidden within the* *laboratory’s walls.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dr. Markus and Professor Viktoria realized they needed to take drastic measures
    to protect their precious research. With their expertise, the ingenious duo started
    enhancing their beloved AI dummy puppets with advanced algorithms and behavioral
    patterns. They programmed the puppets to detect and respond to unauthorized intrusions,
    trying to ensure the safety of their laboratory* *and research.*'
  prefs: []
  type: TYPE_NORMAL
- en: State trees are the Unreal Engine version of hierarchical state machines that
    merge selectors from behavior trees with state machines, enabling users to build
    efficient and well-organized logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A hierarchical state machine is a design pattern used in software development
    to model complex systems with multiple states and transitions. It extends the
    concept of traditional finite-state machines by introducing the idea of hierarchically
    nested states. In a hierarchical state machine, states can be organized into a
    hierarchical structure, where higher-level states encapsulate and control lower-level
    states; this nesting allows for a more modular and organized representation of
    the system behavior. Each state can have its own set of substates, which can further
    have their own substates, forming a hierarchical tree-like structure. The main
    advantage of this pattern is that it provides a way to reuse behavior across multiple
    states. Instead of duplicating similar logic in different states, common behavior
    can be defined at higher-level states and inherited by their substates. This promotes
    code reusability, reduces redundancy, and simplifies the overall design.
  prefs: []
  type: TYPE_NORMAL
- en: A state tree is structured hierarchically, with the state selection process
    generally starting at the root. However, state selection can be initiated from
    any node within the tree.
  prefs: []
  type: TYPE_NORMAL
- en: When selecting a **state** , the system evaluates a set of **enter conditions**
    for the state itself; if conditions are met, the selection progresses to the child
    states. If no child states exist, it means a leaf has been reached and the current
    state is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Activating a state triggers all states from the root to the leaf state, with
    each of these states comprising **tasks** and **transitions** .
  prefs: []
  type: TYPE_NORMAL
- en: Upon selecting a state, the chosen state and all its parent states become active,
    executing tasks for all active states starting from the root down to the leaf
    state. All tasks in a state are executed concurrently, and the first task reaching
    completion will trigger a transition that may result in the selection of a new
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transitions can point to any state in the tree, and they are triggered by a
    set of **trigger conditions** that must be satisfied for the transition to proceed.
    *Figure 12* *.1* shows a typical example of a state tree (example taken from the
    **City Sample** project freely available in the Epic Games Marketplace):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – State tree example](img/Figure_12.1_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – State tree example
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum it up, the main elements of a state tree are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root** state: the first state selected when the state tree starts executing
    its logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selector** state: state with child states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State enter condition** : lists the conditions that decide if a state can
    be selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task** : lists a set of actions that will be executed when a state is activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transition** : the conditions that will trigger the state selection process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering, state trees and behavior trees are both decision-making
    architectures used in AI, but they serve different purposes. State trees are structured
    around discrete states and transitions, focusing on the current state of an entity
    and how it changes in response to events. This makes them suitable for scenarios
    where clear, distinct states are necessary. In contrast, behavior trees are designed
    for more complex and fluid decision-making, allowing for modular and hierarchical
    task execution. They enable smoother transitions between tasks and can handle
    more intricate behaviors by combining simple actions into complex sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of the main state tree terminology,
    we will show how to extend your own state trees.
  prefs: []
  type: TYPE_NORMAL
- en: Extending state trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A state tree can be created to be executed on an AI controller or directly
    from an actor. There are two different components available to handle a state
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**StateTreeComponent** : This can be attached to any actor and be executed
    by the actor itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StateTreeAIComponent** : This can be attached to any AI controller and be
    executed by the AI controller itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, as you may have already guessed, the state tree system has been
    created with extensibility in mind, which means you can create your own tasks,
    evaluators, and conditions. Although you can create your own C++ structures, state
    trees have been implemented with Blueprint creation in mind. In particular, the
    main classes available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**StateTreeTaskBlueprintBase** : Used for implementing your own tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StateTreeEvaluatorBlueprintBase** : Used for implementing your own evaluators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StateTreeConditionBlueprintBase** : Used for implementing your own conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When extending state trees, it’s advisable to implement your own node logic
    using Blueprints rather than C++. This approach can enhance flexibility and ease
    of use.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the state tree flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'State selection in a state tree starts from the tree root and continues down
    the tree by evaluating each enter conditions. The evaluation process follows these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If enter conditions are not satisfied, selection goes to the next sibling state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If enter conditions are satisfied and the state is a leaf, it is selected as
    the new state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If enter conditions are satisfied but the state is not a leaf, the process is
    executed for the first child state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that state selection is run dynamically, triggered by transitions.
    During the first tick, there is an implicit transition to the root state, which
    then determines the initial state to be executed. Subsequently, once this state
    is chosen, the transitions specify the conditions that trigger the selection logic,
    determining when and where it will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Once a state is selected, all its tasks are executed and will keep on executing
    until a transition triggers a new state selection process.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In game programming, **data binding** refers to the process of connecting data
    between different parts of the game – such as the user interface and the game
    logic – and it involves creating a link that allows data to be synchronized and
    updated across various elements of the game. This helps in keeping the game elements
    consistent and up to date with the latest information.
  prefs: []
  type: TYPE_NORMAL
- en: State trees use data binding for transferring data within the tree and to establish
    conditions or configure tasks for execution. Data binding allows access to data
    passed into the state tree or between nodes in a specified manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'State tree nodes have the following elements available to implement data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameters** : These can be referenced during the tree’s execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context data** : This represents predefined data available to the state tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluators** : These are separate classes that can be executed at runtime
    and that expose data that could not be made available with parameters and context
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global tasks** : These are executed before the root state and can be used
    when you need permanent data during state selection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also worth mentioning that nodes in a state tree share data among themselves
    and can bind data in three ways that have been previously mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: State enter conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transition conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we introduced state trees and their key features. In the following
    section, we will delve into practical exercises by crafting our own state trees
    in order to use them effectively within a gym setting.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing state trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this section onward, we will be creating a new gym based on a couple of
    AI agents using state trees instead of behavior trees. This will help us to understand
    the basic principles behind this new development pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us understand these principles, we’ll be doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create/place an actor in the level who will periodically emit a noise by using
    a dedicated state tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create/place a dummy character who will be managed by another state tree and
    will do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stay idle in its starting location
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reach the noise location whenever a noise is perceived
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get back to its starting location after a brief time investigating the location
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Although pretty simple, this logic can be used as a starting point for a guard
    AI agent that will investigate a level looking for intruders and responding to
    any suspicious noise around.
  prefs: []
  type: TYPE_NORMAL
- en: As the state trees feature is not enabled by default, the first thing to do
    will be to get to the **Plugins** window and enable it.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling state trees plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start working with state trees, you will need to enable a couple of dedicated
    plugins. In order to do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Plugin** window by selecting **Edit** | **Plugins** from the main
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the **GameplayStateTree** and **StateTree** plugins and enable them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the Unreal Engine Editor to activate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Plugin window](img/Figure_12.2_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Plugin window
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to use state trees with C++ (and we do), you will need to add a
    module to the Unreal Engine build file.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will need to include the **GameplayStateTreeModule** dependency
    in the build, so that the module will be available to your C++ implementation.
    In order to do so, open your IDE and locate the **UnrealAgilityArena.build.cs**
    file in your project; it should be located in the **UnrealAgilityArena/Source**
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Unreal Engine **.build.cs** file is responsible for defining how the project
    is built, including options for defining module dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Update it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, once you declare this module, you will have all that’s needed to work with
    state trees in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, there seem to be some issues in declaring
    a **StateTreeAIComponent** class in C++, while the **StateTreeComponent** class
    is working just fine. Basically, the **StateTreeAIComponent** class seems to be
    unavailable in the module, and using this class won’t compile your project. To
    overcome this issue, we will be adding the **StateTreeAIComponent** class from
    Blueprint when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the plugins have been activated, we can start implementing our first AI
    agent using a state tree: the noise emitter.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a noise emitter actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be now creating an actor whose sole aim will be to periodically emit
    a noise by means of the **Perception System** . This task is straightforward and
    can be implemented in any manner you find suitable. However, for this demonstration,
    we will use state trees to grasp the fundamental principles of this system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the noise emitter class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be starting by creating the base class for the noise emitter; we will
    need to declare all the visual elements and, most importantly, the needed Perception
    System component and the state tree component. Moreover, we will include a function
    to generate the noise, without concerning ourselves with the logic that will manage
    it; this responsibility will be delegated to the state tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new C++ class extending **Actor** and call it **BaseNoiseEmitter**
    . Once the class has been created, open the **BaseNoiseEmitter.h** file and add
    the following forward declarations after the **#** **include** declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, make the class an acceptable base class for Blueprints by changing
    the **UCLASS()** macro into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Look for the **Tick()** declaration and remove it as we won’t be using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the needed components just after the **GENERATED_BODY()** macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we will be using a few static meshes,
    as well as the needed state tree and Perception System components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just after the constructor declaration, add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are exposing some properties to customize our emitter instances
    in the level, and we are declaring an **EmitNoise()** function that we will be
    using to activate the noise emission when needed. Finally, the **NoiseTag** property
    will be used to tag the noise and be recognized by listening AI agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s now time to open the **BaseNoiseEmitter.cpp** file and implement the methods.
    As a first step, remove the **Tick()** function and, in the constructor, modify
    this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify it into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the needed **#include** declarations, so add this block of
    code at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s initialize the static mesh components inside the constructor by
    adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be already familiar with all of this, so we can go on and declare
    the stimuli source for the Perception System and the state tree by adding this
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are just creating the needed components; additionally, we
    are registering the hearing sense as a stimuli source for the Perception System.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the **BeginPlay()** function, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are registering the Perception System, and we are starting the logic
    for the state tree. This means that as soon as the game starts, the state tree
    will begin executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is implement the **EmitNoise()** function, so add this
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 10*](B31016_10.xhtml#_idTextAnchor198) , *Improving Agents with
    the Perception System* , you already learned how to handle the sight sense. With
    the sense of hearing, things are slightly different; while being visible is a
    continuous occurrence, being heard only occurs when you make noise. This is why
    we randomize a noise range – based on the previously declared properties – and
    we use the **ReportNoiseEvent()** function to emit the actual noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is ready, and we can now focus on the actual state tree creation,
    starting from a custom task: something that will tell the actor to emit the noise.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the emit noise task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The state tree task we will be creating needs to just tell the **BaseNoiseEmitter**
    instance to execute the **EmitNoise()** function. This task will be created as
    a Blueprint class so, inside **Content Browser** of the Unreal Engine Editor,
    navigate to the **AI** folder and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint class extending from **StateTreeTaskBlueprintBase** and
    name it **STT_EmitNoise** . Double-click on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **My Blueprints** panel, hover over the **FUNCTIONS** section and click
    the **Override** dropdown menu that shows up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Enter State** option, as depicted in *Figure 12* *.3* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Enter State function creation](img/Figure_12.3_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Enter State function creation
  prefs: []
  type: TYPE_NORMAL
- en: An **Event Enter State** node will be added to the Event Graph; this event will
    be executed when a new state in the state tree is entered and if the task is part
    of the active states.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this state, we need a reference to the owning actor; as previously mentioned,
    state trees use data binding for communicating. Therefore, we will take advantage
    of this feature to create the reference. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable that is an **Object Reference** of the **BaseNoiseEmitter**
    type and name it **Actor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the variable and, in the **Details** panel, locate the **Category**
    attribute and, in the **Input** field, type **Context** , as shown in *Figure
    12* *.4* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Context category](img/Figure_12.4_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Context category
  prefs: []
  type: TYPE_NORMAL
- en: While variable creation is self-explanatory, setting the category name to a
    value of **Context** needs some explanation; whenever you add a property to the
    **Context** category, the property itself will be exposed through data binding
    to the state tree the task will be executed in. This comes quite handy when you
    need to get information from the executing state tree and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new reference available, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Variables** section, drag the **Actor** variable into the Event Graph
    and add a **Get** **Actor** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing pin of the **Actor** node, connect an **Emit** **Noise** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Event Enter State** node with the
    incoming execution pin of the **Emit** **Noise** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing execution pin of the **Emit Noise** node, connect a **Finish**
    **Task** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the **Succeeded** checkbox of the **Finish Task** node. The final graph
    should look like the one depicted in *Figure 12* *.5* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Emit Noise graph](img/Figure_12.5_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Emit Noise graph
  prefs: []
  type: TYPE_NORMAL
- en: The only thing worth mentioning here is the **Finish Task** node that will return
    a success value after emitting the noise. Now that this task is complete, we can
    finally start working on the state tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the noise emitter state tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As previously stated, we will be executing the state tree from an actor; this
    means we will need something that can be used with the **StateTreeComponent**
    class. In order to do so, we will need to create an asset that follows the rules
    dictated by a **StateTreeComponentSchema** class that guarantees access to the
    actor executing the state tree. To create such an asset, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Content Browser** , open the **AI** folder, right-click on it, and select
    **Artificial Intelligence** | **State Tree** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Pick Schema for State Tree** pop-up window, select **StateTreeComponentSchema**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – State tree creation](img/Figure_12.6_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – State tree creation
  prefs: []
  type: TYPE_NORMAL
- en: Name the newly created asset **ST_NoiseEmitter** and double-click on it to open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the asset is opened, locate the **StateTree** tab to the left of the Editor
    and notice that there is a **Context Actor Class** property, as shown in *Figure
    12* *.7* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.7 – State Tree context actor](img/Figure_12.7_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – State Tree context actor
  prefs: []
  type: TYPE_NORMAL
- en: This is the reference to the owning actor; at the moment, it is set to a generic
    actor but we need to be more specific, so click on the dropdown menu and select
    an **Object Reference** of **BaseNoiseEmitter** . From now on, each node of the
    tree will be granted access to this reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start implementing the state tree logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Add State** button three times to create three states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select each of them and, in the **Details** panel, name them **Random Delay**
    , **Debug Message** , and **Emit Noise** , respectively. Your state tree should
    be similar to the one depicted in *Figure 12* *.8* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Initial states](img/Figure_12.8_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Initial states
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have created the basis structure for the state tree with
    three main states that will wait for a random time, display a debug message, and
    finally emit the noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to implement each of the states with their own tasks and transitions;
    let’s start from the first one. Select the **Random Delay** task and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Details** panel, locate the **Tasks** section and click the **+** button
    to add a new task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the newly created task, click the dropdown menu and select **Delay Task**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the task by clicking the tiny arrow icon next to the task name. Set the
    **Duration** attribute to **10.0** and the **Random Deviation** attribute to **3.0**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **Transitions** section and click the **+** button to create a new
    transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see an item labeled **On State Transition Completed Go to State
    Root** . Click on the tiny arrow icon to expand it, and from the dropdown menu
    of the **Transition To** attribute, select **Next State** . This state should
    look like the one depicted in *Figure 12* *.9* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Random delay state](img/Figure_12.9_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Random delay state
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start working on the second state – that is, **Debug Message** –
    that is going to display an in-game message. This is obviously not mandatory for
    making our state tree work, but it serves the purpose of learning how things work.
    Select this state and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Details** panel, locate the **Tasks** section and click the **+** button
    to add a new task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the newly created task, click the dropdown menu and select **Debug** **Text
    Task** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the task by clicking the tiny arrow icon next to the task name. Set the
    **Text** property value to **Emitting Noise!** and the **Text Color** property
    to a color of your choice – in my case, I opted for a bright yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another task; click the dropdown menu and select **Delay Task** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the task by clicking the tiny arrow icon next to the task name and set
    the **Duration** attribute to **0.5** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **Transitions** section and click the **+** button to create a new
    transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see an item labeled **On State Transition Completed Go to State
    Root** ; click on the tiny arrow icon to expand it and, from the dropdown menu
    of the **Transition To** attribute, select **Next State** . This state should
    look like the one depicted in *Figure 12* *.10* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Debug Message state](img/Figure_12.10_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Debug Message state
  prefs: []
  type: TYPE_NORMAL
- en: 'Now select the last state – that is, **Emit Noise** – and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new task, of the **STT Emit** **Noise** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the task by clicking the tiny arrow icon; you should notice a property
    named **Actor** and labeled **CONTEXT** . On its far right, you should see a dropdown
    menu arrow. Click on it to open it and select **Actor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Binding](img/Figure_12.11_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Binding
  prefs: []
  type: TYPE_NORMAL
- en: This last action created the binding between the **Actor** property of the state
    tree and the **Actor** property we added when we created the **STT_EmitNoise**
    task. This last property has been exposed because in the task Blueprint; we set
    its category to **Context** .
  prefs: []
  type: TYPE_NORMAL
- en: 'This last state will look like the one shown in *Figure 12* *.12* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Emit noise state](img/Figure_12.12_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Emit noise state
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we didn’t add a transition for this task. The default behavior
    is to point to the **Root** node, and we want to create an infinite loop, so we
    simply leave the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with data binding, things might appear a bit weird initially,
    but do not worry. As you become accustomed to it, things will become quite simple
    and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state tree is finished and should look like *Figure 12* *.13* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Finished state tree](img/Figure_12.13_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Finished state tree
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is quite easy to get what’s happening in each state and how
    the state tree flow will progress. It’s time to bring everything together and
    get the noise emitter up and running!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the noise emitter Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating the Blueprint out of the **BaseNoiseEmitter** class is quite straightforward,
    so let’s do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint class extending from **BaseNoiseEmitter** and name it
    **BP_NoiseEmitter** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it and locate the **State Tree** attribute in the **AI** section. From
    the dropdown menu, set its value to **ST_NoiseEmitter** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Finished BP_NoiseEmitter](img/Figure_12.14_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Finished BP_NoiseEmitter
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to do to implement your noise emitter. It is important
    to note that what we have created is not technically an AI agent. This is the
    beauty of state trees; once you grasp the concept, you will be able to apply your
    logic to many different types of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the noise emitter is ready, it is time to test it out in a level.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the noise emitter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test the noise emitter, you will just need to create a new gym and add some
    instances of **BP_NoiseEmitter** . To do that, start by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new level, starting from the Level Instances and Packed Level Actors
    I provided in the project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or more instances of **BP_NoiseEmitter** to the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the **Debug Text Task** message won’t be displayed if we hit
    the **Simulate** button. To show in-game messages, you will need to use the regular
    **Play** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the level is played, you will see each **BP_NoiseEmitter** instance showing
    debug messages at random times, as shown in *Figure 12* *.15* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Testing the gym](img/Figure_12.15_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – Testing the gym
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to implement a state tree inside an actor. Starting
    from creating a custom task that calls a method in the owning actor, we then created
    our first state tree that looped indefinitely, emitting noise signals for the
    Perception System.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will create a guard puppet that listens for noise
    events and responds accordingly. We will do this using state trees.
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced state tree features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will once again extend the **BaseDummyCharacter** class
    to create an AI agent that listens for noise signals and moves to the location
    where the noise was generated. Once the location has been checked, the AI agent
    will return to its original position. We will start by creating an AI controller
    that will have hearing capabilities through the Perception System and will handle
    its AI logic through state trees. We are essentially developing a guard to protect
    a level from intruders. As usual, let’s start by creating our own base C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the C++ AI controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AI controller class will need to implement a hearing sense and execute
    state tree logic. As mentioned earlier, at the time of writing this book, there
    seems to be a bug in Unreal Engine that prevents us from declaring a **StateTreeAIComponent**
    class in C++ so, for the time being, we will be implementing just the hearing
    sense and adding the state tree component from Blueprints. Let’s create a new
    C++ class called **BaseGuardAIController** . Then, open the **BaseGuardAIController.h**
    file and add the following forward declaration after the **#** **include** declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a **public** section with the following function declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are already familiar with these function declarations but note that the
    **OnTargetPerceptionUpdate()** function has a **BlueprintImplementableEvent**
    specifier added; this will let us implement this function from an extending Blueprint
    instead of directly doing it from this class. This means we are leaving the responsibility
    of implementing this function to the Blueprint. Now, let’s open the **BaseGuardAIController.cpp**
    file to implement the functions. The needed **#include** declarations you should
    be adding are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the constructor implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We already know how to configure an **AIPerceptionComponent** from [*Chapter
    10*](B31016_10.xhtml#_idTextAnchor198) , *Improving Agents with the Perception
    System* , so I will not bother you with extra details. Just pay attention to the
    final line of code, where we are registering the delegate that will manage the
    hearing stimuli.
  prefs: []
  type: TYPE_NORMAL
- en: You can now compile your project to make this class available to the Blueprint
    system as, in the next few steps, we will create the AI controller Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the AI controller Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the base AI controller is ready, we can start implementing a Blueprint
    version that will also manage the state tree. To get started, in the **Blueprints**
    folder, create a new Blueprint class extending from **BaseGuardAIController**
    , call it **AIGuardController** , and open it. Then, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable of the **Name** type and call it **NoiseTag** . Make it
    **Instance Editable** . After compiling this Blueprint, set the default value
    for this variable to **EmitterNoise** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another variable of the **Vector** type and name it **NoiseLocation**
    ; make it **Instance Editable** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a third variable of the **Vector** type and name it **StartLocation**
    ; make it **Instance Editable** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s handle the state tree by following the steps that ensue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a new component of the **StateTreeAI** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the component into the Event Graph to add a reference to the component
    itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing pin of the **State Tree AI** node, connect a **Start** **Logic**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the outgoing execution pin of the **Event Begin Play** node to the
    incoming execution pin of the **Start Logic** node. The Event Graph should look
    like *Figure 12* *.16* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Event Begin Play](img/Figure_12.16_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – Event Begin Play
  prefs: []
  type: TYPE_NORMAL
- en: This portion of the graph will start the execution of the state tree. Now, let’s
    store the AI character’s starting location. To do this, follow the steps that
    ensue.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Variables** section, drag the **StartLocation** variable into the
    Event Graph and make it a setter node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Start Logic** node to the incoming
    execution pin of the **Set Start** **Location** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Get Actor Location** node and add its **Return Value** pin to the **Start
    Location** pin of the **Set Start** **Location** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Get Controller Pawn** node and connect its **Return Value** pin to
    the **Target** pin of the **Get Actor Location** node. This portion of the graph
    is depicted in *Figure 12* *.17* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Store starting location](img/Figure_12.17_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Store starting location
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Event BeginPlay** code logic has been completed, so we can start implementing
    the previously declared **OnTargetPerceptionUpdated()** function. To do this,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Event Graph and add an **Event On Target Perception** **Update**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the **Stimulus** outgoing pin and add a **Break** **AIStimulus**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** panel, drag a getter node for the **NoiseTag** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing pin of the **Noise Tag** node, add an **Equal (==)** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Tag** outgoing pin of the **Break AIStimulus** node to the second
    incoming pin of the **Equal (==)** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Event On Target Perception Update**
    node to a **Branch** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the outgoing pin of the **Equal (==)** node to the **Condition** pin
    of the **Break** node. This portion of the graph is depicted in *Figure 12* *.18*
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Check stimulus tag](img/Figure_12.18_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 – Check stimulus tag
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to store the location of the noise, so let’s do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Variables** section, drag the **NoiseLocation** reference to create
    a **Set** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the node’s incoming execution pin to the **True** execution pin of the
    **Branch** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **Noise Location** pin of the **Set Noise Location** node to the
    **Stimulus Location** pin of the **Break AI Stimulus** node. This portion of the
    graph is shown in *Figure 12* *.19* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.19 – Store noise location](img/Figure_12.19_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – Store noise location
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is to notify the state tree that a noise has been
    heard and that the AI agent needs to respond consequently. To do so, we will be
    using **Gameplay Tags** .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, the Gameplay Tag system is used to mark and categorize gameplay
    elements. Gameplay Tags are lightweight identifiers that can be easily attached
    to game entities (such as actors or components) to help organize and classify
    them in a flexible and efficient way. Learning how to work with Gameplay Tags
    is out of the scope of this book; we will be just learning the bare minimum to
    properly communicate with a state tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get on with our Event Graph implementation by doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Make StateTreeEvent** node to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Send State Tree Event** node to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference of the **StateTreeAI** component into the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Set Noise Location** node to the
    incoming execution pin of the **Send State Tree** **Event** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **State Tree AI** node to the **Target** pin of the **Send State
    Tree** **Event** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing pin of the **Make State Tree Event** node to the incoming
    **Event** pin of the **Send State Tree** **Event** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Origin** input field of the **Make StateTreeEvent** node, type **AI
    Controller** . This portion of the graph should look like *Figure 12* *.20* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.20 – Send State Tree Event](img/Figure_12.20_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – Send State Tree Event
  prefs: []
  type: TYPE_NORMAL
- en: 'This portion of the code is responsible for communicating with the state tree
    by sending an event; the event will need to be tagged in order to be recognized
    by the state tree itself. To do so, we need to create a Gameplay Tag. You can
    do this by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Make StateTreeEvent** node, click on the dropdown menu next to the
    **Tag** incoming pin. At the moment, it should be labeled as **None** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get a list of available tags; click on the **Manage Gameplay Tags…**
    option to open the **Gameplay Tag** **Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.21 – Manage Gameplay Tags… option](img/Figure_12.21_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – Manage Gameplay Tags… option
  prefs: []
  type: TYPE_NORMAL
- en: Once the **Gameplay Tag Manager** window is open, click on the **+** button.
    In the **Name** input field, enter **UnrealAgilityArena.StateTree.HeardNoise**
    and, in the **Source** field, select **DefaultGameplayTags.ini** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add New Tag** button to confirm the creation of the new Gameplay
    Tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.22 – Create Gameplay Tag](img/Figure_12.22_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.22 – Create Gameplay Tag
  prefs: []
  type: TYPE_NORMAL
- en: In the **Make StateTreeEvent** node, click on the **Tag** dropdown menu and
    select the **HeardNoise** checkbox to select that gameplay tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.23 – Select Gameplay Tag](img/Figure_12.23_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.23 – Select Gameplay Tag
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost done with the **AIGuardController** Blueprint; the only thing left
    is to include the state tree reference, but we have to create it first!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the state tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are going to implement the state tree. This time, we will be executing
    it from the **AIGuardController** Blueprint. That’s why we will need a subclass
    of the regular state tree – that is the state tree AI – that will have a reference
    to the owning AI controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main states will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Idle** : The AI agent will stay at its starting location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alerted** : The AI agent has been notified of a noise and it will go inspecting
    the location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return to Starting Location** : The AI agent will get back to its starting
    location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let’s start by opening the **AI** folder and doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and select **Artificial Intelligence** | **State Tree** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Pick Schema for State Tree** pop-up window, select **StateTreeAIComponentSchema**
    and name the newly created asset **STAI_Guard** . Double-click on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **StateTree** left panel, set the **AIController Class** attribute to
    **AIGuardController** and the **Context Actor Class** attribute to **BP_Guard**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we have already mentioned, the aforementioned steps will bind the state tree
    to the owning AI controller and actor; this way you will be granted access to
    their properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to implement the base states. To do so, carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create three states and call them, **Idle** , **Warned** , **Resume** , respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select both the **Warned** and **Resume** states and, in the **Details** panel,
    set the **Type** attribute to **Group** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We marked the **Warned** and **Resume** states as groups because they won’t
    contain tasks but will delegate them to child states. They basically function
    as state containers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As an extra option, the **State Tree** panel has a **Theme** section that will
    let you define state colors that can then be applied to each state – and its own
    children – in the **Details** panel. In my case, I have opted for the colors depicted
    in *Figure 12* *.24* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24 – Base states](img/Figure_12.24_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.24 – Base states
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now implement each state separately.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Idle state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Idle** state is going to be quite simple; we will make the AI agent wait
    in some sort of infinite loop until we get a noise notification. To implement
    this state, select it and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Delay Task** with the **Duration** attribute set to **10.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On** **State Completed**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition To** attribute set to **Idle**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add another **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On Event**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Event Tag** attribute set to **UnrealAgilityArena.StateTree.HeardNoise**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition To** attribute set to **Alert**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Priority** attribute set to **High**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.25 – Idle state](img/Figure_12.25_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.25 – Idle state
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we will keep on looping inside this state until we get an event
    from the AI controller notifying us that a noise has been heard. In this case,
    we will transition to the **Alert** state.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Alert state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once in the **Alert** state, the AI agent will try to move to the noise location.
    Once it reaches that point, will wait for some time before changing state; we
    will need two child states for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create the first child state, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new state and call it **Move to** **Noise Location** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a task of the **Action** | **Move To** type and do the following steps
    with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the **AIController** attribute – labeled **CONTEXT** – to the owner AI
    controller by clicking the dropdown arrow and selecting **AIController** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **Destination** attribute, click the dropdown arrow, and select **AIController**
    | **Noise Location** to bind this attribute to the **NoiseLocation** property
    of the AI controller owner.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On** **State Succeeded**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition To** attribute set to **Next State**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add another **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On** **State Failed**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition To** attribute set to **Resume**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.26 – Move to Noise Location state](img/Figure_12.26_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.26 – Move to Noise Location state
  prefs: []
  type: TYPE_NORMAL
- en: This portion of the state tree will move the AI agent to the location set inside
    the **NoiseLocation** attribute of the owning AI controller. Once successful,
    the next state will be executed. If the location cannot be reached, it will get
    back to its original position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s now create the second child state for the **Alert** state by doing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new state and call it **Inspect** **Noise Location** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a task of the **Delay Task** type and do the following with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Duration** attribute to **3.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Random Deviation** attribute to **1.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On** **State Completed**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition To** attribute set to **Resume**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.27 – Inspect Noise Location state](img/Figure_12.27_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.27 – Inspect Noise Location state
  prefs: []
  type: TYPE_NORMAL
- en: This portion of the state tree will just make the AI agent wait for a bit, before
    it goes back to its original location. If the AI agent doesn’t find anything suspicious,
    it gets back to its guard location.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Resume state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Resume** state will need to bring the AI agent back to its original position;
    additionally, at any time, this state should be interrupted if a new noise has
    been notified. So, to create the first child state, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new state and call it **Move to** **Starting Location** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a task of the **Action** | **Move To** type and do the following steps
    with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the **AI Controller** attribute – labeled **CONTEXT** – to the owner AI
    controller by clicking the dropdown arrow and selecting **AI Controller** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **Destination** attribute, click the dropdown arrow, and select **AIController**
    | **Start Location** to bind this attribute to the **StartLocation** property
    of the AI controller owner.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On** **State Completed**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition To** attribute set to **Next State**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.28 – Move to Start Location state](img/Figure_12.28_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.28 – Move to Start Location state
  prefs: []
  type: TYPE_NORMAL
- en: This state is pretty similar to the **Move to Noise Location** one; the only
    difference is the **Destination** attribute that, in this case, is the original
    location of the AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create the second child state for the **Resume** state by doing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new state and call it **Wait** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a task of the **Delay Task** type and do the following with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Duration** attribute to **2.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Random Deviation** attribute to **1.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On** **State Completed**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition To** attribute set to **Idle**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.29 – Wait state](img/Figure_12.29_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.29 – Wait state
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, we will need to interrupt the **Resume** state if a new noise
    has been heard, so select the **Resume** state and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a **Transition** with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Trigger** attribute set to **On Event**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Event Tag** attribute set to **UnrealAgilityArena.StateTree.HeardNoise**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition** To attribute set to **Alert**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Priority** attribute set to **High**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.30 – Resume state](img/Figure_12.30_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.30 – Resume state
  prefs: []
  type: TYPE_NORMAL
- en: 'The state tree is pretty complete, and it should look like the one shown in
    *Figure 12* *.31* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.31 – Finished state tree](img/Figure_12.31_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.31 – Finished state tree
  prefs: []
  type: TYPE_NORMAL
- en: Now that the state tree is ready, we will need to add it to the AI controller.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the state tree to the AI controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assigning the newly created state tree to the AI controller is pretty straightforward.
    Just open the **AIGuardController** Blueprint and, in the **Details** panel, locate
    the **AI** section. Set the **State Tree** property to **STAI_Guard** .
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we can create the AI agent Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the guard Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now create our guard Blueprint and assign the AI logic to it. To do
    this, open **Content Drawer** . In the **Blueprints** folder, create a new Blueprint
    extending from **Base Dummy Character** and call it **BP_Guard** .
  prefs: []
  type: TYPE_NORMAL
- en: Open the newly created Blueprint and, in the **Details** panel, set the **AI
    Controller Class** attribute to **AIGuardController** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.32 – Guard Blueprint](img/Figure_12.32_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.32 – Guard Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: The guard AI agent is now ready; we just need to test it out in a gym.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in a gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Blueprint class ready, it’s time to test it out. All you need to do
    is to add it to the previously created gym and play the level. Whenever a noise
    is emitted by a noise emitter actor, you should see the **BP_Guard** instance
    try to reach the noise location and, after a while, get back to its original position.
    Obviously, all of this will work if the AI agent is in range of the provoked noise
    location. You can obviously leverage your understanding of AI debugging tools
    to gain valuable insights into the hearing capabilities and range of the AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.33 – Testing the gym](img/Figure_12.33_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.33 – Testing the gym
  prefs: []
  type: TYPE_NORMAL
- en: In this quite lengthy section, you got more advanced information on how to implement
    your own state trees. Starting from an AI controller with some hearing capabilities,
    we learned how to control a state tree and bind important data between the state
    tree and the AI controller. Finally, we added the AI controller and, consequently,
    the state tree to an AI agent and tested its behaviors in a gym.
  prefs: []
  type: TYPE_NORMAL
- en: The AI agent we have created sets the foundation for a complete AI guard agent.
    Currently, it simply checks for any suspicious noises and investigates their source.
    I highly recommend adding your own logic to introduce more actions, such as sounding
    an alarm when an enemy is detected or trying to attack the source of the noise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State trees in Unreal Engine are crucial in the AI framework as they help manage
    and organize the decision-making processes of AI agents efficiently. They offer
    a neat alternative to behavior trees depending on your design and development
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of state trees, a hierarchical state
    machine framework implemented in Unreal Engine. Starting from its main concepts,
    such as how states are handled, we were introduced to the main elements involved
    – including tasks, transitions, and conditions. After that, we created our own
    actors, taking advantage of state trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will be working on a totally different topic: how to
    manage huge numbers of objects within your level, treating them as a collective
    group for processing or simulation purposes.'
  prefs: []
  type: TYPE_NORMAL
