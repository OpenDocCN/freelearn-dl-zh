["```py\n     public float Speed;\n     public float facingLeft;\n     public float facingRight;\n     public float facingBack;\n     public static bool availableLeft;\n     public static bool availableRight;\n\n     public bool aLeft;\n     public bool aRight;\n\n     void Start ()\n     {\n\n     }\n\n     void Update ()\n     {\n\n         aLeft = availableLeft;\n         aRight = availableRight;\n\n         transform.Translate(Vector2.up * Time.deltaTime * Speed);\n\n         if(facingLeft > 270)\n         {\n             facingLeft = 0;\n         }\n\n         if(facingRight < -270)\n         {\n             facingRight = 0;\n         }\n\n     }\n\n     void OnTriggerEnter2D(Collider2D other)\n     {\n\n         if(other.gameObject.tag == \"BlackCube\")\n         {\n             if(availableLeft == true && availableRight == false)\n             {\n                 turnLeft();\n             }\n\n             if(availableRight == true && availableLeft == false)\n             {\n                 turnRight();\n             }\n\n             if(availableRight == true && availableLeft == true)\n             {\n                 turnRight();\n             }\n\n             if(availableRight == false && availableLeft == false)\n             {\n                 turnBack();\n             }\n         }\n     }\n\n     void turnLeft ()\n     {\n         facingLeft = transform.rotation.eulerAngles.z + 90;\n         transform.localRotation = Quaternion.Euler(0, 0, facingLeft);\n     }\n\n     void turnRight ()\n     {\n         facingRight = transform.rotation.eulerAngles.z - 90;\n         transform.localRotation = Quaternion.Euler(0, 0, facingRight);\n     }\n\n     void turnBack ()\n     {\n         facingBack = transform.rotation.eulerAngles.z + 180;\n         transform.localRotation = Quaternion.Euler(0, 0, facingBack);\n     } \n```", "```py\n   public bool leftSide; \n   public bool rightSide; \n\n   void Start () \n   { \n\n        if(leftSide == true)\n        { \n            rightSide = false; \n        } \n\n        if(rightSide == true)\n        { \n            leftSide = false; \n        } \n   } \n\n   void Update () { \n\n   } \n\n    void OnTriggerStay2D(Collider2D other) \n    { \n\n        if(other.gameObject.tag == \"BlackCube\") \n        { \n            if(leftSide == true && rightSide == false) \n            { \n                Character.availableLeft = false; \n            } \n\n            if(rightSide == true && leftSide == false) \n            { \n                Character.availableRight = false; \n            } \n        } \n    } \n\n    void OnTriggerExit2D(Collider2D other) \n    { \n\n        if(other.gameObject.tag == \"BlackCube\") \n        { \n            if(leftSide == true) \n            { \n                Character.availableLeft = true; \n            } \n\n            if(rightSide == true) \n            { \n                Character.availableRight = true; \n            } \n        } \n} \n\n```", "```py\n   public float Speed;\n   public float facingLeft;\n   public float facingRight;\n   public float facingBack;\n   public static bool availableLeft;\n   public static bool availableRight;\n\n   public static int probabilityTurnLeft;\n   public static int probabilityTurnRight;public int probabilitySides;\n\n   public bool forwardBlocked;\n\n   public bool aLeft;\n   public bool aRight;\n```", "```py\n   void Start ()\n   {\n       availableLeft = false;\n       availableRight = false;\n       probabilityTurnLeft = 0;\n       probabilityTurnRight = 0;\n   }\n```", "```py\n   void Update ()\n   {\n       aLeft = availableLeft;\n       aRight = availableRight;\n\n       transform.Translate(Vector2.up * Time.deltaTime * Speed);\n\n       if(facingLeft > 270)\n       {\n           facingLeft = 0;\n       }\n\n       if(facingRight < -270)\n       {\n           facingRight = 0;\n       }\n\n       if (forwardBlocked == false)\n       {\n           if (availableLeft == true && availableRight == false)\n           {\n              if (probabilityTurnLeft > 10)\n              {\n                   turnLeft();\n              }\n           }\n\n           if (availableLeft == false && availableRight == true)\n           {\n              if (probabilityTurnRight > 10)\n              {\n                  turnRight();\n              }\n           }\n\n           if (availableLeft == true && availableRight == true)\n           {\n              probabilityTurnLeft = 0;\n              probabilityTurnRight = 0;\n           }\n       }\n\n   }\n```", "```py\n   void OnTriggerEnter2D(Collider2D other)\n   {\n\n       if(other.gameObject.tag == \"BlackCube\")\n       {\n           forwardBlocked = true;\n\n           if(availableLeft == true && availableRight == false)\n           {\n                turnLeft();\n           }\n\n           if(availableRight == true && availableLeft == false)\n           {\n               turnRight();\n           }\n\n           if(availableRight == true && availableLeft == true)\n           {\n               probabilitySides = Random.Range(0, 1);\n               if(probabilitySides == 0)\n               {\n                   turnLeft();\n               }\n\n               if(probabilitySides == 1)\n               {\n                   turnRight();\n               }\n\n           }\n\n           if(availableRight == false && availableLeft == false)\n           {\n               turnBack();\n           }\n       }\n   }\n\n   void OnTriggerExit2D(Collider2D other)\n   {\n       forwardBlocked = false;\n   }\n\n   void  turnLeft ()\n   {\n       probabilityTurnLeft = 0;\n       facingLeft = transform.rotation.eulerAngles.z + 90;\n       transform.localRotation = Quaternion.Euler(0, 0, facingLeft);\n   }\n\n   void turnRight ()\n   {\n       probabilityTurnRight = 0;\n       facingRight = transform.rotation.eulerAngles.z - 90;\n       transform.localRotation = Quaternion.Euler(0, 0, facingRight);\n   }\n\n   void turnBack ()\n   {\n       facingBack = transform.rotation.eulerAngles.z + 180;\n       transform.localRotation = Quaternion.Euler(0, 0, facingBack);\n   } \n```", "```py\n   public bool leftSide;\n   public bool rightSide;\n   public int probabilityTurn;\n\n   void Start () \n   {\n       if(leftSide == true)\n      {\n          rightSide = false;\n       }\n\n       if(rightSide == true)\n       {\n          leftSide = false;\n       }\n    }\n\n    void Update () \n    {\n\n    }\n\n    void OnTriggerEnter2D(Collider2D other)\n    {\n       if(other.gameObject.tag == \"BlackCube\")\n       {\n           if(leftSide == true && rightSide == false)\n           {\n               Character.availableLeft = false;\n               probabilityTurn = 0;\n               Character.probabilityTurnLeft = probabilityTurn;\n           }\n\n           if(rightSide == true && leftSide == false)\n           {\n               Character.availableRight = false;\n               probabilityTurn = 0;\n               Character.probabilityTurnRight = probabilityTurn;\n           }\n        }\n     }\n\n     void OnTriggerStay2D(Collider2D other)\n     {\n\n           if(other.gameObject.tag == \"BlackCube\")\n           {\n               if(leftSide == true && rightSide == false)\n               {\n                   Character.availableLeft = false;\n                   probabilityTurn = 0;\n                   Character.probabilityTurnLeft = probabilityTurn;\n               }\n\n               if(rightSide == true && leftSide == false)\n               {\n                   Character.availableRight = false;\n                   probabilityTurn = 0;\n                   Character.probabilityTurnRight = probabilityTurn;\n               }\n           }\n       }\n\n       void OnTriggerExit2D(Collider2D other)\n       {\n\n           if(other.gameObject.tag == \"BlackCube\")\n           {\n               if(leftSide == true)\n               {\n                   probabilityTurn = Random.Range(0, 100);\n                   Character.probabilityTurnLeft = probabilityTurn;\n                   Character.availableLeft = true;\n               }\n\n               if(rightSide == true)\n               {\n                   probabilityTurn = Random.Range(0, 100);\n                   Character.probabilityTurnRight = probabilityTurn;\n                   Character.availableRight = true;\n               }\n           }\n        } \n```", "```py\n   public static Transform[] points;\n\n   void Awake () \n   {\n        points = new Transform[transform.childCount];\n        for (int i = 0; i < points.Length; i++)\n        {\n             points[i] = transform.GetChild(i); \n         }\n   }\n```", "```py\n public float speed;\n public int health;\n\n private Transform target;\n private int wavepointIndex = 0; \n```", "```py\n public float speed;\n public int health;\n\n private Transform target;\n private int wavepointIndex = 0;\n\n void Start ()\n {\n      target = waypoints.points[0];  speed = 10f;\n }\n\n void Update ()\n {\n      Vector3 dir = target.position - transform.position;\n      transform.Translate(dir.normalized * speed * Time.deltaTime, \n         Space.World);\n\n      if(Vector3.Distance(transform.position, target.position) <= 0.4f)\n      {\n          GetNextWaypoint();\n      }\n }\n\n void GetNextWaypoint()\n {\n      if(wavepointIndex >= waypoints.points.Length - 1)\n      {\n          Destroy(gameObject);\n          return;\n      }\n\n      wavepointIndex++;\n      target = waypoints.points[wavepointIndex];\n } \n```", "```py\n public Transform enemyPrefab;\n public float timeBetweenWaves = 3f;\n public Transform spawnPoint;\n\n private float countdown = 1f;\n private int waveNumber = 1;\n\n void Update ()\n {\n      if(countdown <= 0f)\n      {\n          StartCoroutine(SpawnWave());\n          countdown = timeBetweenWaves;\n      }\n\n      countdown -= Time.deltaTime;\n }\n\n IEnumerator SpawnWave ()\n {\n      waveNumber++;\n\n      for (int i = 0; i < waveNumber; i++)\n      {\n          SpawnEnemy();\n          yield return new WaitForSeconds(0.7f);\n      }\n }\n\n void SpawnEnemy()\n {\n      Instantiate(enemyPrefab, spawnPoint.position, \n            spawnPoint.rotation);\n }\n```", "```py\n public float speed;\n public int health;\n public float speedTurn;\n\n private Transform target;\n private int wavepointIndex = 0;\n\n void Start ()\n {\n      target = waypoints.points[0];\n      speed = 10f;\n      speedTurn = 0.2f;\n }\n\n void Update ()\n {\n      Vector3 dir = target.position - transform.position;\n      transform.Translate(dir.normalized * speed * Time.deltaTime, \n            Space.World);\n\n      if(Vector3.Distance(transform.position, target.position) <= 0.4f)\n      {\n          GetNextWaypoint();\n      }\n\n      Vector3 newDir = Vector3.RotateTowards(transform.forward, dir, \n            speedTurn, 0.0F);\n\n      transform.rotation = Quaternion.LookRotation(newDir);\n }\n\n void GetNextWaypoint()\n {\n      if(wavepointIndex >= waypoints.points.Length - 1)\n      {\n          Destroy(gameObject);\n          return;\n      }\n\n      wavepointIndex++;\n      target = waypoints.points[wavepointIndex];\n } \n```", "```py\n public static bool raceStarted = false;\n\n public float aiSpeed = 10.0f;\n public float aiTurnSpeed = 2.0f;\n public float resetAISpeed = 0.0f;\n public float resetAITurnSpeed = 0.0f;\n\n public GameObject waypointController;\n public List<Transform> waypoints;\n public int currentWaypoint = 0;\n public float currentSpeed;\n public Vector3 currentWaypointPosition; \n```", "```py\n void Start () \n {\n       GetWaypoints();\n       resetAISpeed = aiSpeed;\n       resetAITurnSpeed = aiTurnSpeed;\n }\n```", "```py\n  void Update () \n  {\n       if(raceStarted)\n       {\n           MoveTowardWaypoints();    \n       }\n  }\n```", "```py\n  void GetWaypoints()\n  {\n    Transform[] potentialWaypoints = waypointController.\n        GetComponentsInChildren<Transform>();\n\n    waypoints = new List<Transform>();\n\n    for each(Transform potentialWaypoint in potentialWaypoints)\n     {\n        if(potentialWaypoint != waypointController.transform)\n        {\n           waypoints.Add(potentialWaypoint);    \n        }\n     } \n  } \n```", "```py\n  void MoveTowardWaypoints()\n  {\n     float currentWaypointX = waypoints[currentWaypoint].position.x;\n     float currentWaypointY = transform.position.y;\n     float currentWaypointZ = waypoints[currentWaypoint].position.z;\n\n     Vector3 relativeWaypointPosition = transform.\n        InverseTransformPoint (new Vector3(currentWaypointX,   \n        currentWaypointY, currentWaypointZ));\n     currentWaypointPosition = new Vector3(currentWaypointX, \n         currentWaypointY, currentWaypointZ);\n\n     Quaternion toRotation = Quaternion.LookRotation\n        (currentWaypointPosition - transform.position);\n     transform.rotation = Quaternion.RotateTowards\n        (transform.rotation, toRotation, aiTurnSpeed);\n\n     GetComponent<Rigidbody>().AddRelativeForce(0, 0, aiSpeed);\n\n     if(relativeWaypointPosition.sqrMagnitude < 15.0f)\n     {\n        currentWaypoint++;\n\n        if(currentWaypoint >= waypoints.Count)\n        {\n           currentWaypoint = 0;    \n        }\n     }\n\n     currentSpeed = Mathf.Abs(transform.\n       InverseTransformDirection\n      (GetComponent<Rigidbody>().velocity).z);\n\n     float maxAngularDrag = 2.5f;\n     float currentAngularDrag = 1.0f;\n     float aDragLerpTime = currentSpeed * 0.1f;\n\n     float maxDrag = 1.0f;\n     float currentDrag = 3.5f;\n     float dragLerpTime = currentSpeed * 0.1f;\n\n     float myAngularDrag = Mathf.Lerp(currentAngularDrag, \n        maxAngularDrag, aDragLerpTime);\n     float myDrag = Mathf.Lerp(currentDrag, maxDrag, dragLerpTime);\n\n     GetComponent<Rigidbody>().angularDrag = myAngularDrag;\n     GetComponent<Rigidbody>().drag = myDrag;\n   } \n```", "```py\n   Quaternion toRotation = Quaternion.LookRotation\n           (currentWaypointPosition - transform.position);\n   transform.rotation = Quaternion.RotateTowards\n           (transform.rotation, toRotation, aiTurnSpeed);\n```", "```py\n public static bool raceStarted = false;\n\n public float aiSpeed = 10.0f;\n public float aiTurnSpeed = 2.0f;\n public float resetAISpeed = 0.0f;\n public float resetAITurnSpeed = 0.0f;\n\n public GameObject waypointController;\n public List<Transform> waypoints;\n public int currentWaypoint = 0;\n public float currentSpeed;\n public Vector3 currentWaypointPosition;\n\n void Start () \n {\n      GetWaypoints();\n      resetAISpeed = aiSpeed;\n      resetAITurnSpeed = aiTurnSpeed;\n }\n\n void Update () \n {\n    if(raceStarted)\n    {\n        MoveTowardWaypoints();    \n    }\n }\n\n void GetWaypoints()\n  {\n      Transform[] potentialWaypoints =  \n        waypointController.GetComponentsInChildren<Transform>();\n\n      waypoints = new List<Transform>();\n\n      foreach(Transform potentialWaypoint in potentialWaypoints)\n      {\n          if(potentialWaypoint != waypointController.transform)\n          {\n              waypoints.Add(potentialWaypoint);    \n          }\n      }\n }\n\n void MoveTowardWaypoints()\n {\n      float currentWaypointX = waypoints[currentWaypoint].position.x;\n      float currentWaypointY = transform.position.y;\n      float currentWaypointZ = waypoints[currentWaypoint].position.z;\n\n      Vector3 relativeWaypointPosition = transform.\n         InverseTransformPoint (new Vector3(currentWaypointX, \n         currentWaypointY, currentWaypointZ));\n      currentWaypointPosition = new Vector3(currentWaypointX, \n         currentWaypointY, currentWaypointZ);\n\n      Quaternion toRotation = Quaternion.\n         LookRotation(currentWaypointPosition - transform.position);\n      transform.rotation = Quaternion.RotateTowards\n         (transform.rotation, toRotation, aiTurnSpeed);\n\n      GetComponent<Rigidbody>().AddRelativeForce(0, 0, aiSpeed);\n\n      if(relativeWaypointPosition.sqrMagnitude < 15.0f)\n      {\n          currentWaypoint++;\n\n          if(currentWaypoint >= waypoints.Count)\n          {\n              currentWaypoint = 0;    \n           }\n      }\n\n      currentSpeed = Mathf.Abs(transform.\n          InverseTransformDirection\n          (GetComponent<Rigidbody>().velocity).z);\n\n      float maxAngularDrag = 2.5f;\n      float currentAngularDrag = 1.0f;\n      float aDragLerpTime = currentSpeed * 0.1f;\n\n      float maxDrag = 1.0f;\n      float currentDrag = 3.5f;\n      float dragLerpTime = currentSpeed * 0.1f;\n\n      float myAngularDrag    = Mathf.Lerp(currentAngularDrag, \n          maxAngularDrag, aDragLerpTime);\n      float myDrag = Mathf.Lerp(currentDrag, maxDrag, dragLerpTime);\n\n      GetComponent<Rigidbody>().angularDrag = myAngularDrag;\n      GetComponent<Rigidbody>().drag = myDrag;\n } \n```", "```py\n public static Transform[] points;\n\n void Awake () \n {\n      points = new Transform[transform.childCount];\n      for (int i = 0; i < points.Length; i++)\n      {\n          points[i] = transform.GetChild(i); \n      }\n }\n```", "```py\n public static Transform[] 1_Top;\n\n void Awake () \n {\n      1_Top = new Transform[transform.childCount];\n      for (int i = 0; i < 1_Top.Length; i++)\n      {\n          1_Top[i] = transform.GetChild(i); \n      }\n }\n```", "```py\n public static Transform[] 1_Middle;\n\n void Awake () \n {\n      1_Middle = new Transform[transform.childCount];\n      for (int i = 0; i < 1_Top.Length; i++)\n      {\n          1_Middle[i] = transform.GetChild(i); \n      }\n }\n```", "```py\n public static Transform[] 1_Bottom;\n\n void Awake () \n {\n      1_Bottom = new Transform[transform.childCount];\n      for (int i = 0; i < 1_Top.Length; i++)\n      {\n          1_Bottom[i] = transform.GetChild(i); \n      }\n }\n```", "```py\n public static Transform[] 2_Top;\n\n void Awake () \n {\n      2_Top = new Transform[transform.childCount];\n      for (int i = 0; i < 1_Top.Length; i++)\n      {\n          2_Top[i] = transform.GetChild(i); \n      }\n }\n```", "```py\n public static Transform[] 2_Middle;\n\n void Awake () \n {\n      2_Middle = new Transform[transform.childCount];\n      for (int i = 0; i < 2_Middle.Length; i++)\n      {\n          2_Middle[i] = transform.GetChild(i); \n      }\n }\n```", "```py\n public static Transform[] 2_Bottom;\n\n void Awake () \n {\n      2_Bottom = new Transform[transform.childCount];\n      for (int i = 0; i < 2_Bottom.Length; i++)\n      {\n          2_Bottom[i] = transform.GetChild(i); \n      }\n }\n```", "```py\n public float speed;\n public int health;\n public float speedTurn;\n\n private Transform target;\n private int wavepointIndex = 0;\n\n void Start ()\n {\n      target = waypoints.points[0];\n      speed = 10f;\n      speedTurn = 0.2f;\n }\n\n void Update ()\n {\n      Vector3 dir = target.position - transform.position;\n      transform.Translate(dir.normalized * speed * Time.deltaTime, \n         Space.World);\n\n      if(Vector3.Distance(transform.position, target.position) <= 0.4f)\n      {\n          GetNextWaypoint();\n      }\n\n      Vector3 newDir = Vector3.RotateTowards(transform.forward, dir, \n         speedTurn, 0.0F);\n\n      transform.rotation = Quaternion.LookRotation(newDir);\n }\n\n void GetNextWaypoint()\n {\n      if(wavepointIndex >= waypoints.points.Length - 1)\n      {\n          Destroy(gameObject);\n          return;\n      }\n\n      wavepointIndex++;\n      target = waypoints.points[wavepointIndex];\n } \n```", "```py\n public bool Team1;\n public bool Team2;\n```", "```py\n public bool Top;\n public bool Middle; \n public bool Bottom; \n```", "```py\nif(Team1 == true)\n {\n          if(Top == true)\n          {\n              target = 1_Top.1_Top[0];\n          }\n\n          if(Middle == true)\n          {\n              target = 1_Middle.1_Middle[0];\n          }\n\n          if(Bottom == true)\n          {\n             target = 1_Bottom.1_Top[0];\n          }\n }\n\n if(Team2 == true)\n {\n          if(Top == true)\n          {\n             target = 2_Top.2_Top[0];\n          }\n\n          if(Middle == true)\n          {\n              target = 2_Middle.2_Middle[0];\n          }\n\n          if(Bottom == true)\n          {\n              target = 2_Bottom.2_Top[0];\n          }\n } \n```", "```py\nvoid GetNextWaypoint()\n{\n    if(Team1 == true)\n    {\n       if(Top == true)\n       {\n          if(wavepointIndex >= 1_Top.1_Top.Length - 1)\n          {\n             Destroy(gameObject);\n              return;\n           }\n\n           wavepointIndex++;\n           target = 1_Top.1_Top[wavepointIndex];\n         }\n\n         if(Middle == true)\n         {\n            if(wavepointIndex >= 1_Middle.1_Middle.Length - 1)\n            {\n               Destroy(gameObject);\n               return;\n             }\n\n             wavepointIndex++;\n             target = 1_Middle.1_Middle[wavepointIndex];\n           }\n\n           if(Bottom == true)\n           {\n              if(wavepointIndex >= 1_Bottom.1_Bottom.Length - 1)\n              {\n                 Destroy(gameObject);\n                 return;\n               }\n\n               wavepointIndex++;\n               target = 1_Bottom.1_Bottom[wavepointIndex];\n           }\n       }\n\n       if(Team2 == true)\n       {\n         if(Top == true)\n         {\n            if(wavepointIndex >= 2_Top.2_Top.Length - 1)\n            {\n                Destroy(gameObject);\n                return;\n             }\n\n             wavepointIndex++;\n             target = 2_Top.2_Top[wavepointIndex];\n           }\n\n           if(Middle == true)\n           {\n              if(wavepointIndex >= 2_Middle.2_Middle.Length - 1)\n              {\n                 Destroy(gameObject);\n                 return;\n               }\n\n               wavepointIndex++;\n               target = 2_Middle.2_Middle[wavepointIndex];\n            }\n\n            if(Bottom == true)\n            {\n               if(wavepointIndex >= 2_Bottom.2_Bottom.Length - 1)\n               {\n                 Destroy(gameObject);\n                 return;\n               }\n\n               wavepointIndex++;\n               target = 2_Bottom.2_Bottom[wavepointIndex];\n             }\n         }\n     }  \n```", "```py\n  public float speed;\n  public int health;\n  public float speedTurn;\n\n  public bool Team1;\n  public bool Team2;\n\n  public bool Top;\n  public bool Middle;\n  public bool Bottom;\n\n  private Transform target;\n  private int wavepointIndex = 0;\n```", "```py\n  void Start ()\n  {\n     if(Team1 == true)\n     {\n        if(Top == true)\n        {\n            target = 1_Top.1_Top[0];\n         }\n\n         if(Middle == true)\n         {\n              target = 1_Middle.1_Middle[0];\n          }\n\n          if(Bottom == true)\n          {\n              target = 1_Bottom.1_Top[0];\n          }\n      }\n\n      if(Team2 == true)\n      {\n          if(Top == true)\n          {\n             target = 2_Top.2_Top[0];\n           }\n\n          if(Middle == true)\n          {\n             target = 2_Middle.2_Middle[0];\n          }\n\n           if(Bottom == true)\n           {\n               target = 2_Bottom.2_Top[0];\n            }\n    }\n    speed = 10f;\n    speedTurn = 0.2f;\n  }\n```", "```py\n  void Update ()\n  {\n     Vector3 dir = target.position - transform.position;\n     transform.Translate(dir.normalized * speed * Time.deltaTime, \n        Space.World);\n\n     if(Vector3.Distance(transform.position, target.position) <= 0.4f)\n     {\n         GetNextWaypoint();\n     }\n\n     Vector3 newDir = Vector3.RotateTowards(transform.forward, dir, \n        speedTurn, 0.0F);\n\n     transform.rotation = Quaternion.LookRotation(newDir);\n  }\n\n  void GetNextWaypoint()\n  {\n      if(Team1 == true)\n      {\n        if(Top == true)\n        {\n          if(wavepointIndex >= 1_Top.1_Top.Length - 1)\n          {\n            Destroy(gameObject);\n            return;\n          }\n\n          wavepointIndex++;\n          target = 1_Top.1_Top[wavepointIndex];\n        }\n\n        if(Middle == true)\n        {\n          if(wavepointIndex >= 1_Middle.1_Middle.Length - 1)\n          {\n             Destroy(gameObject);\n             return;\n           }\n\n           wavepointIndex++;\n           target = 1_Middle.1_Middle[wavepointIndex];\n        }\n\n        if(Bottom == true)\n        {\n           if(wavepointIndex >= 1_Bottom.1_Bottom.Length - 1)\n           {\n                Destroy(gameObject);\n                return;\n            }\n\n            wavepointIndex++;\n            target = 1_Bottom.1_Bottom[wavepointIndex];\n        }\n      }\n\n      if(Team2 == true)\n      {\n         if(Top == true)\n         {\n           if(wavepointIndex >= 2_Top.2_Top.Length - 1)\n           {\n                Destroy(gameObject);\n                return;\n            }\n\n             wavepointIndex++;\n             target = 2_Top.2_Top[wavepointIndex];\n          }\n\n          if(Middle == true)\n          {\n             if(wavepointIndex >= 2_Middle.2_Middle.Length - 1)\n             {\n                Destroy(gameObject);\n                return;\n              }\n\n              wavepointIndex++;\n              target = 2_Middle.2_Middle[wavepointIndex];\n            }\n\n            if(Bottom == true)\n            {\n              if(wavepointIndex >= 2_Bottom.2_Bottom.Length - 1)\n              {\n                 Destroy(gameObject);\n                 return;\n               }\n\n               wavepointIndex++;\n               target = 2_Bottom.2_Bottom[wavepointIndex];\n             }\n         }\n     }  \n```", "```py\n  public float speed;\n  private List <GameObject> wayPointsList;\n  private Transform target;\n  private GameObject[] wayPoints;\n\n  void Start ()\n  {\n\n      target = GameObject.FindGameObjectWithTag(\"target\").transform;\n      wayPointsList = new List<GameObject>();\n\n      wayPoints = GameObject.FindGameObjectsWithTag(\"wayPoint\");\n\n      for each(GameObject newWayPoint in wayPoints)\n      {\n         wayPointsList.Add(newWayPoint);\n       }\n   }\n\n   void Update ()\n   {\n      Follow();\n   }\n\n   void Follow () \n   {\n      GameObject wayPoint = null;\n\n      if (Physics.Linecast(transform.position, target.position))\n      {\n         wayPoint = findBestPath();\n       }\n\n       else\n       {\n          wayPoint = GameObject.FindGameObjectWithTag(\"target\");  \n        }\n\n        Vector3 Dir = (wayPoint.transform.position - \n                transform.position).normalized;\n        transform.position += Dir * Time.deltaTime * speed;\n        transform.rotation = Quaternion.LookRotation(Dir);\n     }\n\n     GameObject findBestPath()\n     {\n         GameObject bestPath = null;\n         float distanceToBestPath = Mathf.Infinity;\n\n         for each(GameObject go in wayPointsList)\n         {\n            float distToWayPoint = Vector3.\n               Distance(transform.position, go.transform.position);\n            float distWayPointToTarget = Vector3.\n               Distance(go.transform.position, \n               target.transform.position);\n            float distToTarget = Vector3.\n               Distance(transform.position, target.position);\n            bool wallBetween = Physics.Linecast\n               (transform.position, go.transform.position);\n\n            if((distToWayPoint < distanceToBestPath) \n                && (distToTarget > distWayPointToTarget) \n                    &&  (!wallBetween))\n             {\n                 distanceToBestPath = distToWayPoint;\n                 bestPath = go;\n             }\n\n             else\n             {\n                 bool wayPointToTargetCollision = Physics.Linecast\n                    (go.transform.position, target.position);\n                 if(!wayPointToTargetCollision)\n                 {\n                      bestPath = go;        \n                  }    \n             }\n         }\n         return bestPath;\n     } \n```", "```py\n  public static bool raceStarted = false;\n\n  public float aiSpeed = 10.0f;\n  public float aiTurnSpeed = 2.0f;\n  public float resetAISpeed = 0.0f;\n  public float resetAITurnSpeed = 0.0f;\n\n  public GameObject waypointController;\n  public List<Transform> waypoints;\n  public int currentWaypoint = 0;\n  public float currentSpeed;\n  public Vector3 currentWaypointPosition;\n\n  public static bool isBlocked;\n  public static bool isBlockedFront;\n  public static bool isBlockedRight;\n  public static bool isBlockedLeft;\n```", "```py\n   void Start () \n   {\n         GetWaypoints();\n         resetAISpeed = aiSpeed;\n         resetAITurnSpeed = aiTurnSpeed;\n    }\n\n```", "```py\n   void Update () \n    {\n       if(raceStarted && isBlocked == false)\n       {\n          MoveTowardWaypoints();    \n        }\n\n       if(raceStarted && isBlockedFront == true \n           && isBlockedLeft == false && isBlockedRight == false)\n        {\n            TurnRight();\n        }\n\n        if(raceStarted && isBlockedFront == false\n             && isBlockedLeft == true && isBlockedRight == false)\n        {\n             TurnRight();\n        }\n\n        if(raceStarted && isBlockedFront == false \n              && isBlockedLeft == false && isBlockedRight == true)\n        {\n             TurnLeft();\n        }\n     }\n\n     void GetWaypoints()\n      {\n            Transform[] potentialWaypoints = waypointController.\n                GetComponentsInChildren<Transform>();\n\n            waypoints = new List<Transform>();\n\n            for each(Transform potentialWaypoint in potentialWaypoints)\n             {\n                 if(potentialWaypoint != waypointController.transform)\n                 {\n                      waypoints.Add(potentialWaypoint);    \n                  }\n              }\n     }\n\n     void MoveTowardWaypoints()\n     {\n        float currentWaypointX = waypoints[currentWaypoint].position.x;\n        float currentWaypointY = transform.position.y;\n        float currentWaypointZ = waypoints[currentWaypoint].position.z;\n\n        Vector3 relativeWaypointPosition = transform.\n           InverseTransformPoint (new Vector3(currentWaypointX, \n           currentWaypointY, currentWaypointZ));\n        currentWaypointPosition = new Vector3(currentWaypointX, \n           currentWaypointY, currentWaypointZ);\n\n        Quaternion toRotation = Quaternion.\n           LookRotation(currentWaypointPosition - transform.position);\n        transform.rotation = Quaternion.\n           RotateTowards(transform.rotation, toRotation, aiTurnSpeed);\n\n         GetComponent<Rigidbody>().AddRelativeForce(0, 0, aiSpeed);\n\n         if(relativeWaypointPosition.sqrMagnitude < 15.0f)\n         {\n               currentWaypoint++;\n\n               if(currentWaypoint >= waypoints.Count)\n               {\n                        currentWaypoint = 0;    \n                }\n           }\n\n           currentSpeed = Mathf.Abs(transform.\n               InverseTransformDirection(GetComponent<Rigidbody>().\n               velocity).z);\n\n           float maxAngularDrag = 2.5f;\n           float currentAngularDrag = 1.0f;\n           float aDragLerpTime = currentSpeed * 0.1f;\n\n           float maxDrag = 1.0f;\n           float currentDrag = 3.5f;\n           float dragLerpTime = currentSpeed * 0.1f;\n\n           float myAngularDrag = Mathf.Lerp(currentAngularDrag, \n                 maxAngularDrag, aDragLerpTime);\n           float myDrag = Mathf.Lerp(currentDrag, maxDrag, \n                 dragLerpTime);\n\n           GetComponent<Rigidbody>().angularDrag = myAngularDrag;\n           GetComponent<Rigidbody>().drag = myDrag;\n     }\n\n     void TurnLeft()\n     {\n         //turning left function here\n     }\n\n     void TurnRight()\n     {\n         //turning right function here\n     } \n```", "```py\n  public float speed; \n  public int health; \n  public float speedTurn; \n\n  public bool Team1; \n  public bool Team2; \n\n  public bool Top; \n  public bool Middle; \n  public bool Bottom; \n\n  private Transform target; \n  private int wavepointIndex = 0; \n\n  static Transform heroTarget; \n  static bool heroTriggered; \n\n```", "```py\n   void Start () \n   { \n         if(Team1 == true) \n         { \n            if(Top == true) \n            { \n                  target = 1_Top.1_Top[0]; \n             } \n\n              if(Middle == true) \n              { \n                    target = 1_Middle.1_Middle[0]; \n              } \n\n               if(Bottom == true) \n               { \n                   target = 1_Bottom.1_Top[0]; \n                } \n         } \n\n          if(Team2 == true) \n          { \n            if(Top == true) \n            { \n              target = 2_Top.2_Top[0]; \n            } \n\n             if(Middle == true) \n             { \n                target = 2_Middle.2_Middle[0]; \n             } \n\n              if(Bottom == true) \n              { \n                  target = 2_Bottom.2_Top[0]; \n               } \n          } \n          speed = 10f; \n          speedTurn = 0.2f; \n        } \n\n```", "```py\n        void Update () \n        { \n           Vector3 dir = target.position - transform.position; \n           transform.Translate(dir.normalized * speed * Time.deltaTime, \n              Space.World); \n\n           if(Vector3.Distance(transform.position, target.position) <=\n                 0.4f && heroTriggered == false) \n            { \n                GetNextWaypoint(); \n             } \n\n             if(heroTriggered == true) \n             { \n                  GetHeroWaypoint(); \n              } \n\n              Vector3 newDir = Vector3.RotateTowards(transform.\n                     forward, dir, speedTurn, 0.0F); \n\n              transform.rotation = Quaternion.LookRotation(newDir); \n        } \n\n```", "```py\n        void GetNextWaypoint() \n        { \n           if(Team1 == true) \n           { \n              if(Top == true) \n              { \n                 if(wavepointIndex >= 1_Top.1_Top.Length - 1) \n                 { \n                      Destroy(gameObject); \n                      return; \n                  } \n\n                  wavepointIndex++; \n                  target = 1_Top.1_Top[wavepointIndex]; \n                } \n\n                if(Middle == true) \n                { \n                  if(wavepointIndex >= 1_Middle.1_Middle.Length - 1) \n                  { \n                    Destroy(gameObject); \n                    return; \n                   } \n\n                   wavepointIndex++; \n                   target = 1_Middle.1_Middle[wavepointIndex]; \n                } \n\n                if(Bottom == true) \n                { \n                   if(wavepointIndex >= 1_Bottom.1_Bottom.Length - 1) \n                   { \n                      Destroy(gameObject); \n                      return; \n                   } \n\n                    wavepointIndex++; \n                    target = 1_Bottom.1_Bottom[wavepointIndex]; \n                  } \n            } \n\n            if(Team2 == true) \n            { \n               if(Top == true) \n               { \n                  if(wavepointIndex >= 2_Top.2_Top.Length - 1) \n                  { \n                     Destroy(gameObject); \n                     return; \n                  } \n\n                  wavepointIndex++; \n                  target = 2_Top.2_Top[wavepointIndex]; \n                } \n\n                if(Middle == true) \n                { \n                    if(wavepointIndex >= 2_Middle.2_Middle.Length - 1) \n                    { \n                       Destroy(gameObject); \n                       return; \n                     } \n\n                     wavepointIndex++; \n                     target = 2_Middle.2_Middle[wavepointIndex]; \n                  } \n\n                  if(Bottom == true) \n                  { \n                     if(wavepointIndex >= 2_Bottom.2_Bottom.Length - 1) \n                      { \n                         Destroy(gameObject); \n                         return; \n                       } \n\n                       wavepointIndex++; \n                       target = 2_Bottom.2_Bottom[wavepointIndex]; \n                    } \n               } \n    }\n\n```", "```py\n    void GetHeroWaypoint() \n    { \n        target = heroTarget.transform; \n    } \n```"]