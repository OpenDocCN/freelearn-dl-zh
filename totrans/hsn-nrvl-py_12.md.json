["```py\n        if len(self.novel_items) >= MAXNoveltyArchiveSize:\n            # check if this item has higher novelty than  \n            # last item in the archive (minimal novelty)\n            if item > self.novel_items[-1]:\n                # replace it\n                self.novel_items[-1] = item\n        else:\n            # just add new item\n            self.novel_items.append(item)\n\n        # sort items array in descending order by novelty score\n        self.novel_items.sort(reverse=True)\n```", "```py\n        distances = []\n        for n in self.novel_items:\n            if n.genomeId != item.genomeId:\n                distances.append(self.novelty_metric(n, item))\n            else:\n                print(\"Novelty Item is already in archive: %d\" % \n                       n.genomeId)\n```", "```py\n        for p_item in n_items_list:\n            if p_item.genomeId != item.genomeId:\n                distances.append(self.novelty_metric(p_item, item))\n```", "```py\n        distances = sorted(distances) \n        item.novelty = sum(distances[:KNN])/KNN\n```", "```py\n    params = create_objective_fun_params()\n    # Genome has one input (0.5) and two outputs (a and b)\n    genome = NEAT.Genome(0, 1, 1, 2, False, \n        NEAT.ActivationFunction.TANH, # hidden layer activation\n        NEAT.ActivationFunction.UNSIGNED_SIGMOID, # output layer activation\n        1, params, 0)\n    pop = NEAT.Population(genome, params, True, 1.0, seed)\n    pop.RNG.Seed(seed)\n\n    obj_archive = archive.NoveltyArchive(\n                             metric=maze.maze_novelty_metric_euclidean)\n    obj_fun = ObjectiveFun(archive=obj_archive, \n                             genome=genome, population=pop)\n```", "```py\n    params = create_robot_params()\n    # Genome has 11 inputs and two outputs\n    genome = NEAT.Genome(0, 11, 0, 2, False, \n                        NEAT.ActivationFunction.UNSIGNED_SIGMOID, \n                        NEAT.ActivationFunction.UNSIGNED_SIGMOID, \n                        0, params, 0)\n    pop = NEAT.Population(genome, params, True, 1.0, seed)\n    pop.RNG.Seed(seed)\n\n    robot_archive = archive.NoveltyArchive(metric=maze.maze_novelty_metric)\n    robot = Robot(maze_env=maze_env, archive=robot_archive, genome=genome, \n                  population=pop)\n```", "```py\n    obj_func_genomes = NEAT.GetGenomeList(obj_function.population)\n    for genome in obj_func_genomes:\n        n_item = evaluate_individ_obj_function(genome=genome, \n                                            generation=generation)\n        n_items_list.append(n_item)\n        obj_func_coeffs.append(n_item.data)\n```", "```py\n    max_fitness = 0\n    for i, genome in enumerate(obj_func_genomes):\n        fitness = obj_function.archive.evaluate_novelty_score(\n               item=n_items_list[i],n_items_list=n_items_list)\n        genome.SetFitness(fitness)\n        max_fitness = max(max_fitness, fitness)\n```", "```py\n    n_item = archive.NoveltyItem(generation=generation, genomeId=genome_id)\n    # run the simulation\n    multi_net = NEAT.NeuralNetwork()\n    genome.BuildPhenotype(multi_net)\n    depth = 2\n    try:\n        genome.CalculateDepth()\n        depth = genome.GetDepth()\n    except:\n        pass\n    obj_net = ANN(multi_net, depth=depth)\n\n    # set inputs and get outputs ([a, b])\n    output = obj_net.activate([0.5])\n\n    # store coefficients\n    n_item.data.append(output[0])\n    n_item.data.append(output[1])\n```", "```py\n    robot_genomes = NEAT.GetGenomeList(robot.population)\n    for genome in robot_genomes:\n        found, distance, n_item = evaluate_individual_solution(\n            genome=genome, generation=generation, robot=robot)\n        # store returned values\n        distances.append(distance)\n        n_items_list.append(n_item)\n```", "```py\n    for i, n_item in enumerate(n_items_list):\n        novelty = robot.archive.evaluate_novelty_score(item=n_item, \n                                         n_items_list=n_items_list)\n        # The sanity check\n        assert robot_genomes[i].GetID() == n_item.genomeId\n\n        # calculate fitness\n        fitness, coeffs = evaluate_solution_fitness(distances[i], \n                                        novelty, obj_func_coeffs)\n        robot_genomes[i].SetFitness(fitness)\n```", "```py\n        if not solution_found:\n            # find the best genome in population\n            if max_fitness < fitness:\n                max_fitness = fitness\n                best_robot_genome = robot_genomes[i]\n                best_coeffs = coeffs\n                best_distance = distances[i]\n                best_novelty = novelty\n        elif best_robot_genome.GetID() == n_item.genomeId:\n            # store fitness of winner solution\n            max_fitness = fitness\n            best_coeffs = coeffs\n            best_distance = distances[i]\n            best_novelty = novelty\n```", "```py\n    n_item = archive.NoveltyItem(generation=generation, \n                                 genomeId=genome_id)\n    # run the simulation\n    maze_env = copy.deepcopy(robot.orig_maze_environment)\n    multi_net = NEAT.NeuralNetwork()\n    genome.BuildPhenotype(multi_net)\n    depth = 8\n    try:\n        genome.CalculateDepth()\n        depth = genome.GetDepth()\n    except:\n        pass\n    control_net = ANN(multi_net, depth=depth)\n    distance = maze.maze_simulation_evaluate(\n        env=maze_env, net=control_net, \n        time_steps=SOLVER_TIME_STEPS, n_item=n_item)\n```", "```py\n    record = agent.AgenRecord(generation=generation, \n                              agent_id=genome_id)\n    record.distance = distance\n    record.x = maze_env.agent.location.x\n    record.y = maze_env.agent.location.y\n    record.hit_exit = maze_env.exit_found\n    record.species_id = robot.get_species_id(genome)\n    robot.record_store.add_record(record)\n```", "```py\n    normalized_novelty = novelty\n    if novelty >= 1.00:\n        normalized_novelty = math.log(novelty)\n    norm_distance = math.log(distance)\n\n    max_fitness = 0\n    best_coeffs = [-1, -1]\n    for coeff in obj_func_coeffs:\n        fitness = coeff[0] / norm_distance + coeff[1] * normalized_novelty\n        if fitness > max_fitness:\n            max_fitness = fitness\n            best_coeffs[0] = coeff[0]\n            best_coeffs[1] = coeff[1]\n```", "```py\n    robot = create_robot(maze_env, seed=seed)\n    obj_func = create_objective_fun(seed)\n```", "```py\n    for generation in range(n_generations):\n        # evaluate objective function population\n        obj_func_coeffs, max_obj_func_fitness = \\\n                    evaluate_obj_functions(obj_func, generation)\n        # evaluate robots population\n        robot_genome, solution_found, robot_fitness, distances, \\\n        obj_coeffs, best_distance, best_novelty = \\\n          evaluate_solutions(robot=robot, \n          obj_func_coeffs=obj_func_coeffs, generation=generation)\n```", "```py\n        stats.post_evaluate(max_fitness=robot_fitness, \n                            errors=distances)\n        # store the best genome\n        best_fitness = robot.population.GetBestFitnessEver()\n        if solution_found or best_fitness < robot_fitness:\n            best_robot_genome_ser = pickle.dumps(robot_genome)\n            best_robot_id = robot_genome.GetID()\n            best_obj_func_coeffs = obj_coeffs\n            best_solution_novelty = best_novelty\n```", "```py\n        if solution_found:\n            print('Solution found at generation: %d, best fitness: %f, species count: %d' % (generation, robot_fitness, len(pop.Species)))\n            break\n        # advance to the next generation\n        robot.population.Epoch()\n        obj_func.population.Epoch()\n```", "```py\n        if args is None:\n            visualize.draw_maze_records(maze_env, \n                       robot.record_store.records, \n                       view=show_results)\n        else:\n            visualize.draw_maze_records(maze_env, \n                      robot.record_store.records, \n                      view=show_results, width=args.width, \n                      height=args.height,\n                      filename=os.path.join(trial_out_dir, \n                                     'maze_records.svg'))\n```", "```py\n        multi_net = NEAT.NeuralNetwork()\n        best_robot_genome.BuildPhenotype(multi_net)\n\n        control_net = ANN(multi_net, depth=depth)\n        path_points = []\n        distance = maze.maze_simulation_evaluate(\n                                    env=maze_env, \n                                    net=control_net, \n                                    time_steps=SOLVER_TIME_STEPS,\n                                    path_points=path_points)\n        print(\"Best solution distance to maze exit: %.2f, novelty: %.2f\" % (distance, best_solution_novelty))\n        visualize.draw_agent_path(robot.orig_maze_environment, \n                          path_points, best_robot_genome,\n                          view=show_results, width=args.width, \n                          height=args.height, \n                          filename=os.path.join(trial_out_dir,\n                                      'best_solver_path.svg'))\n```", "```py\n        visualize.plot_stats(stats, ylog=False, view=show_results, \n           filename=os.path.join(trial_out_dir,'avg_fitness.svg'))\n```", "```py\n    params.PopulationSize = 250\n```", "```py\n    params.MutateAddNeuronProb = 0.03\n    params.MutateAddLinkProb = 0.05\n```", "```py\n    params.MaxWeight = 30.0\n    params.MinWeight = -30.0\n```", "```py\n    params.Elitism = 0.1\n```", "```py\n    params.PopulationSize = 100\n```", "```py\n    params.MutateAddNeuronProb = 0.03\n    params.MutateAddLinkProb = 0.05\n```", "```py\n$ conda create --name maze_co python=3.5\n$ conda activate maze_co\n$ conda install -c conda-forge multineat \n$ conda install matplotlib\n$ conda install graphviz\n$ conda install python-graphviz\n```", "```py\n$ git clone https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python.git\n$ cd Hands-on-Neuroevolution-with-Python/Chapter9\n$ python maze_experiment_safe.py -t 1 -g 150 -m medium\n```", "```py\n****** Generation: 105 ******\n\nMaze solved in 338 steps\n\nSolution found at generation: 105, best fitness: 3.549289, species count: 7\n\n==================================\nRecord store file: out/maze_medium_safe/5/data.pickle\nRandom seed: 1571021768\nBest solution fitness: 3.901621, genome ID: 26458\nBest objective func coefficients: [0.7935419704765059, 0.9882050653334634]\n------------------------------\nMaze solved in 338 steps\nBest solution distance to maze exit: 3.56, novelty: 19.29\n------------------------\nTrial elapsed time: 4275.705 sec\n==================================\n```"]