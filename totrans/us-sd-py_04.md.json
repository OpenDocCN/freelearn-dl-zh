["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ipyplot\nfrom PIL import Image\n# Load an image\nimg_path = r\"dog.png\"\nimage = plt.imread(img_path)\n# Parameters\nnum_iterations = 16\nbeta = 0.1              # noise_variance\nimages = []\nsteps = [\"Step:\"+str(i) for i in range(num_iterations)]\n# Forward diffusion process\nfor i in range(num_iterations):\n    mean = np.sqrt(1 - beta) * image\n    image = np.random.normal(mean, beta, image.shape)\n    # convert image to PIL image object\n    pil_image = Image.fromarray((image * 255).astype('uint8'), 'RGB')\n    # add to image list\n    images.append(pil_image)\nipyplot.plot_images(images, labels=steps, img_width=120)\n```", "```py\nsample_img = image  # take the last image from the diffusion process\nplt.scatter(sample_img[:, 0], sample_img[:, 1], alpha=0.5)\nplt.title(\"2D Isotropic Gaussian Distribution\")\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\nplt.axis(\"equal\")\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom itertools import accumulate\ndef get_product_accumulate(numbers):\n    product_list = list(accumulate(numbers, lambda x, y: x * y))\n    return product_list\n# Load an image\nimg_path = r\"dog.png\"\nimage = plt.imread(img_path)\nimage = image * 2 - 1                   # [0,1] to [-1,1]\n# Parameters\nnum_iterations = 16\nbeta = 0.05                             # noise_variance\nbetas = [beta]*num_iterations\nalpha_list = [1 - beta for beta in betas]\nalpha_bar_list = get_product_accumulate(alpha_list)\ntarget_index = 5\nx_target = (\n    np.sqrt(alpha_bar_list[target_index]) * image\n    + np.sqrt(1 - alpha_bar_list[target_index]) * \n    np.random.normal(0,1,image.shape)\n)\nx_target = (x_target+1)/2\nx_target = Image.fromarray((x_target * 255).astype('uint8'), 'RGB')\ndisplay(x_target)\n```", "```py\nimport torch\nimport torch.nn as nn\n# code prepare the model object, image and timestep\n# ...\n# noise is the Ɛ ~ N(0,1) with the shape of the image x_t.\nnoise = torch.randn_like(x_t)\n# x_t is the noised image at step \"t\", together with the time_step value\npredicted_noise = model(x_t, time_step)\nloss = nn.MSELoss(noise, predicted_noise)\n# backward weight propagation\n# ...\n```"]