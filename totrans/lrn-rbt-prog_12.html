<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer179">
			<h1 id="_idParaDest-205"><em class="italic"><a id="_idTextAnchor192"/>Chapter 10</em>: Using Python to Control Servo Motors</h1>
			<p>Servo motors can make precise and repeatable motions. Motion such as this is vital for moving sensors, controlling robot legs or arms, and moving them to a known position. Its uses are so engineers can predict robot behavior, so a robot can repeat things in automation, or so code can move limbs to accurately respond to what their sensors are instructing them. Raspberry Pi or add-on boards can control them. In this chapter, we will use these motors to build a pan and tilt mechanism—a head to position a sensor.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>What are servo motors?</li>
				<li>Positioning a servo motor with the Raspberry Pi</li>
				<li>Adding a pan and tilt mechanism</li>
				<li>Creating pan and tilt code</li>
			</ul>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor193"/>Technical requirements</h1>
			<p>For this chapter, you require the following:</p>
			<ul>
				<li>The robot with the Raspberry Pi built in the previous chapters</li>
				<li>Screwdrivers—small Phillips</li>
				<li>Small pliers or a set of miniature spanners</li>
				<li>Nylon bolts and standoffs kit—2.5 mm</li>
				<li>A two-axis mini pan-tilt micro servo kit</li>
				<li>Two micro SG90/9g or MG90s servo motors, with their hardware and servo horns. The pan-tilt kit may already include the following:</li>
				<li>Cutting pliers or side cutters</li>
				<li>Safety goggles</li>
			</ul>
			<p>The code for this chapter is available at <a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/2LKh92g">https://bit.ly/2LKh92g</a>.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor194"/>What are servo motors?</h1>
			<p><strong class="bold">Servo motors</strong>, or <a id="_idTextAnchor195"/><strong class="bold">servomechanism motors</strong>, are used to position robotic appendages such as arms, grippers, legs, and sensor mounts. They create other movements where the <a id="_idIndexMarker474"/>position is the main factor, unlike the wheel motors (DC motors), where speed is the controlling factor. Servo motors are used where (to some level of accuracy) turning to a specific place might be required. You can use code to control these precise positioning movements or a sequence of them:</p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="Images/B15660_10_01.jpg" alt="" width="1127" height="483"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – A small selection of servo motors</p>
			<p>Servos come in many sizes, from the very small at around 20-30 mm (shown in <em class="italic">Figure 10.1</em>) to those large enough to move heavy machinery. <em class="italic">Figure 10.2</em> shows some of the miniature hobby servos I use for my robots:</p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="Images/B15660_10_02.jpg" alt="" width="1200" height="789"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – A small selection of servo motors in robots</p>
			<p>Now that you've seen<a id="_idIndexMarker475"/> where you might use servo motors, we can dive deeper and find out how a servo motor works.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor196"/>Looking inside a servo</h2>
			<p>Inside the compact form of a servo motor hides a <a id="_idIndexMarker476"/>controller, a DC motor, a gearbox (usually with a stop), and a sensor. These motors have a built-in feedback system. A servo motor takes input from a controller, which specifies a position for the motor to go to. The servo's controller gets the motor's current direction from the internal sensor. The controller <a id="_idIndexMarker477"/>compares the current motor position with the position that has been requested and generates an error—a difference. Based on this difference, the servo drives its motor to try and reduce that error to zero. When the motor moves, the sensor changes, and that error value changes, generating feedback and making the control loop shown in <em class="italic">Figure 10.3</em>:</p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="Images/B15660_10_03.jpg" alt="" width="574" height="267"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – The servo motor control loop</p>
			<p>Some types of servo motors, such <a id="_idIndexMarker478"/>as those used in ArmBot (<em class="italic">Figure 10.2</em>), have an additional output allowing you to read the state of the position sensor in your code too.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor197"/>Sending input positions to a servo motor</h2>
			<p>Signals are sent<a id="_idIndexMarker479"/> to servo motors using <strong class="bold">Pulse Width Modulation</strong> (<strong class="bold">PWM</strong>). PWM is the same <a id="_idIndexMarker480"/>system seen in <a href="B15660_02_Final_ASB_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Robot Building Blocks – Code and Electronics</em>, and is used on our robot to drive the wheel motors. PWM is a square wave, which has two states, <em class="italic">on</em> or <em class="italic">off</em> only. It is the timing of the signal, shown in <em class="italic">Figure 10.4</em>, which is interesting. You can consider the wave as a stream of pulses, where the length in time of each pulse encodes the position information for the servo controller. These pulses repeatedly cycle, with a period or frequency. People usually express frequency as cycles-per-second or hertz. A shorter pulse is a lower value, and a longer pulse is a higher value. The controller keeps the period/frequency the same, and it is the duty cycle (on-time to off-time ratio) that changes. With servo motors, the pulse length is the information encoding feature:</p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="Images/B15660_10_04.jpg" alt="" width="594" height="381"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – PWM for servo motors</p>
			<p>In <em class="italic">Figure 10.4</em>, each graph has time on the <em class="italic">x</em>-axis. The <em class="italic">y</em>-axis for each of the stacked graphs has <strong class="bold">L</strong> for a logic-low and <strong class="bold">H</strong> for a logic-high. The top graph shows short pulses. The charts at the bottom show increased pulse time; however, they vary in an important aspect. In the middle graph, the off-time has not changed, but the period has changed.</p>
			<p>In the bottom graph of <em class="italic">Figure 10.4</em>, the period is the <a id="_idIndexMarker481"/>same as the first graph, but it has a longer pulse time, with shorter off-time. Servo motors measure pulse length and not frequency, so the third graph's variation is the correct type.</p>
			<p>In our robot, we already have a chip in the motor controller that performs the fixed period PWM style. The chip is designed to control LEDs, but happily controls other PWM devices. We can control when the off-time and the on-times should start in a fixed period, which means it behaves like the bottom graph for longer pulse widths.</p>
			<p>Pulse width control leads us nicely into the next section, where we make our robot generate PWM to position a servo. Let's prepare a servo motor, plug it in, and make it move.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor198"/>Positioning a servo motor with the Raspberry Pi</h1>
			<p>To position a servo, we<a id="_idIndexMarker482"/> need to set up a <strong class="bold">servo horn</strong> to see it move, and<a id="_idIndexMarker483"/> then plug it into the motor controller board. A servo horn is a small collar with one or more arms, usually used to connect the servo spindle/axle to a mechanism they move. <em class="italic">Figure 10.5</em> shows how to attach a horn to a servo:</p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="Images/B15660_10_05.jpg" alt="" width="1107" height="679"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Fitting a servo horn</p>
			<p>The images in <em class="italic">Figure 10.5</em> show how to fit a<a id="_idIndexMarker484"/> servo horn. Perform the following steps:</p>
			<ol>
				<li value="1">Servo motors usually come with small bags of hardware, containing a few different horn types and screws to attach them to the servo and the parts you want them to move.</li>
				<li>Use the very short small screws for this, as the longer screws can break the servo.</li>
				<li>Screw a one-armed servo horn into the servo. The long collar of the horn fits over the servo's output spindle.</li>
				<li>The servo should now look like this. Don't over-tighten the collar screw, as you may need to loosen it and<a id="_idIndexMarker485"/> set the middle again.</li>
			</ol>
			<p>In the next image, we plug the servo into the control board to test it:</p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="Images/B15660_10_06.jpg" alt="" width="1442" height="675"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – Plugging a servo into the control board</p>
			<p>Follow <em class="italic">Figure 10.6</em> to see how to connect the servo to the Full Function Motor HAT board on the robot. Make sure you power down the robot fully before connecting it: </p>
			<ol>
				<li value="1">The outline arrow here indicates the servo connector. Servo connectors have three pins shown with the solid arrows: brown for <strong class="bold">ground</strong> (<strong class="bold">G</strong>), red for <strong class="bold">voltage</strong> (<strong class="bold">V</strong>), and yellow/orange/white for <strong class="bold">signal</strong> (<strong class="bold">S</strong>).</li>
				<li>This panel shows that the Motor HAT has a 4 x 3 block of connectors marked <strong class="bold">PWM/Servo</strong>, indicated by the arrows. The four servo channel columns are numbered (<strong class="bold">0</strong>,<strong class="bold"> 1</strong>, <strong class="bold">14</strong>, and <strong class="bold">15</strong>). Each channel has three pins, marked with a pin label (GVS). <strong class="bold">GVS</strong> refers<a id="_idIndexMarker486"/> to <strong class="bold">ground</strong>, <strong class="bold">voltage</strong>, and <strong class="bold">signal</strong>. Align the yellow wire from the servo connector with row S and the brown wire with row G, with the red wire in the middle. Plug this servo into channel 0.</li>
			</ol>
			<p>The connection is similar to controllers such as the PiConZero, but may require some soldering work on other <a id="_idIndexMarker487"/>motor boards. Now that you have wired this motor in, we need to write some code to test it.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor199"/>Writing code for turning a servo</h2>
			<p>Some board libraries can<a id="_idIndexMarker488"/> convert directly from degree to servo movement pulses. With this library, we need to write the code for that math. Some of the calculations result in constants that won't change once we know which servo controller and servo we are using. We can store the results as constants and reuse them.</p>
			<p>You could store the result of such calculations in a variable, but letting the computer do it has a few advantages: </p>
			<ul>
				<li>The computer is excellent and quick at calculating these constants. It may make rounding errors but is likely to make fewer errors than a human would copying from a calculator. </li>
				<li>It's clear what numbers came from where and how to calculate them. Putting in a <em class="italic">magic number</em> that came from a calculator makes it harder to see where it came from.</li>
				<li>If you change a tuning factor, the calculations stay fresh.</li>
				<li>If you find an error, it's easy to change it here.<p class="callout-heading">Tip</p><p class="callout">When setting out calculations in code, use descriptive variable names and comments—being descriptive helps you understand your code and check whether the math makes sense. You read code many times after writing it, so this principle applies to any variable or function name.</p></li>
			</ul>
			<p>Let's make some test code to move a servo to a position typed by the user in degrees. Put this code in <strong class="source-inline">servo_type_position.py</strong>:</p>
			<ol>
				<li value="1">The <strong class="source-inline">Raspi_MotorHAT</strong> library we are using for the robot has a <strong class="source-inline">PWM</strong> module, which we import and create an object to manage. We use <strong class="source-inline">atexit</strong> again to ensure that the controller stops signaling the motor:<p class="source-code"><strong class="bold">from Raspi_MotorHAT.Raspi_PWM_Servo_Driver import PWM</strong></p><p class="source-code"><strong class="bold">import atexit</strong></p></li>
				<li>We must specify the address when setting up the PWM device — it's the same I2C device we are using for the motors and has the same address:<p class="source-code"><strong class="bold">pwm = PWM(0x6f)</strong></p></li>
				<li>The servo works in cycles <a id="_idIndexMarker489"/>at 50 Hz; however, we can use 100 Hz so our motors can drive too. If the frequency is low, the DC motors will stall very easily. This frequency will be a time base for our PWM frequency, which we keep to also use in calculations:<p class="source-code"><strong class="bold"># This sets the timebase for it all</strong></p><p class="source-code"><strong class="bold">pwm_frequency = 100</strong></p><p class="source-code"><strong class="bold">pwm.setPWMFreq(pwm_frequency)</strong></p></li>
				<li>Let's call the middle position 0 degrees. For most servos, turning to -90 degrees requires a pulse of 1 ms; going to the center requires 1.5 ms:<p class="source-code"><strong class="bold"># Mid-point of the servo pulse length in milliseconds.</strong></p><p class="source-code"><strong class="bold">servo_mid_point_ms = 1.5</strong></p><p>This code is an example of using descriptive variable names. A variable named <strong class="source-inline">m</strong> or <strong class="source-inline">p</strong> means far less than <strong class="source-inline">servo_mid_point_ms</strong>.</p></li>
				<li>Turning it to 90 degrees requires a pulse of 2 ms; this is 0.5 ms from the mid-point, which gives us a primary calibration point for 90 degrees:<p class="source-code"><strong class="bold"># What a deflection of 90 degrees is in pulse length in milliseconds</strong></p><p class="source-code"><strong class="bold">deflect_90_in_ms = 0.5</strong></p></li>
				<li>The length of a pulse in our chip also depends on the frequency. This chip specifies a pulse's size as the number of steps per cycle, using 4,096 steps (12 bits) to represent this. A higher frequency would require more steps in the pulse to maintain the pulse length in milliseconds. We can make a ratio for this; steps per millisecond:<p class="source-code"><strong class="bold"># Frequency is 1 divided by period, but working ms, we can use 1000</strong></p><p class="source-code"><strong class="bold">period_in_ms = 1000 / pwm_frequency</strong></p><p class="source-code"><strong class="bold"># The chip has 4096 steps in each period.</strong></p><p class="source-code"><strong class="bold">pulse_steps = 4096</strong></p><p class="source-code"><strong class="bold"># Steps for every millisecond.</strong></p><p class="source-code"><strong class="bold">steps_per_ms = pulse_steps / period_in_ms </strong></p></li>
				<li>Now that we have steps per <a id="_idIndexMarker490"/>millisecond and know how many milliseconds a pulse should be for 90 degrees, we can get a ratio of steps per degree. We can also use this to redefine our middle point in steps, too:<p class="source-code"><strong class="bold"># Steps for a degree.</strong></p><p class="source-code"><strong class="bold">steps_per_degree = (deflect_90_in_ms * steps_per_ms) / 90</strong></p><p class="source-code"><strong class="bold"># Mid-point of the servo in steps</strong></p><p class="source-code"><strong class="bold">servo_mid_point_steps = servo_mid_point_ms * steps_per_ms</strong></p></li>
				<li>We can use these constants in a <strong class="source-inline">convert_degrees_to_pwm</strong> function to get the steps needed for any angle in degrees:<p class="source-code"><strong class="bold">def convert_degrees_to_steps(position):</strong></p><p class="source-code"><strong class="bold">    return int(servo_mid_point_steps + (position * steps_per_degree))</strong></p></li>
				<li>Before we move anything, we should make sure the system stops. We stop by setting PWM to <strong class="source-inline">4096</strong>. This number may sound odd, but instead of giving a long pulse, it turns on an additional bit in the control board, which turns the servo pin entirely off. Turning off the pin releases/relaxes the servo motor. Otherwise, the motor would try to seek/hold the last position we gave it until it's powered down. We can use <strong class="source-inline">atexit</strong> to do this, just as we did with stopping motors:<p class="source-code"><strong class="bold">atexit.register(pwm.setPWM, 0, 0, 4096)</strong></p></li>
				<li>We can now ask for user input in a loop. The <strong class="source-inline">input</strong> function in Python asks the user to type something and<a id="_idIndexMarker491"/> stores it in a variable. We convert it into an integer to use it:<p class="source-code"><strong class="bold">while True:</strong></p><p class="source-code"><strong class="bold">    position = int(input("Type your position in degrees (90 to -90, 0 is middle): "))</strong></p></li>
				<li>We can then convert the position to an end step using our preceding calculations:<p class="source-code"><strong class="bold">    end_step = convert_degrees_to_steps(position)</strong></p></li>
				<li>We can then use <strong class="source-inline">pwm.setPWM</strong> to set our pulse in steps. It takes the servo channel number, a start step, which we'll hold at 0, and an end step, which we've calculated previously:<p class="source-code"><strong class="bold">    pwm.setPWM(0, 0, end_step)</strong></p></li>
			</ol>
			<p>You can now turn the robot on and send this code to it. When you run this code, it will ask you to type a number. Start with number 0. When you press <em class="italic">Enter</em>, you will hear the servo move.</p>
			<p>You can now try other values, but do not give it values outside of -90 to 90 degrees as you may damage the servo. We add code later to protect against this damage. If this system works, you should see the servo move between each different value.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor200"/>Troubleshooting</h2>
			<p>If you find problems<a id="_idIndexMarker492"/> getting this to run, try the following:</p>
			<ul>
				<li>Ensure that the servo motors are plugged into the correct ports and are the right way around. The <strong class="bold">S</strong> pin should go into a yellow cable on most servos.</li>
				<li>Lots of jittering or failing to get to the right position can mean you have less than fresh batteries—please ensure they are fresh.</li>
				<li>When running DC motor behaviors from other chapters, if the servo droops, this may also be down to lower battery power. Make sure you are using metal hydride rechargeables.</li>
			</ul>
			<p>Before we move on, how does this<a id="_idIndexMarker493"/> Motor HAT control both servo motors and DC motors? Let's take a closer look at it.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor201"/>Controlling DC motors and servo motors</h2>
			<p>The HAT that I've suggested<a id="_idIndexMarker494"/> for this book (and readers may choose others) is based <a id="_idIndexMarker495"/>on a PCA9685 chip, which is popular for making robots such as this. It is a multi-channel PWM controller. Take a look at the diagram for an overview of how it is connected in this robot:</p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="Images/B15660_10_07.jpg" alt="" width="767" height="678"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – Block diagram of the motor board</p>
			<p><em class="italic">Figure 10.7</em> shows a block <a id="_idIndexMarker496"/>diagram of the Full Function Motor HAT. This is not a wiring <a id="_idIndexMarker497"/>diagram, it is still a functional block diagram, but it shows components and connections on the board. On the far left is the Raspberry Pi, with a line connecting the PCA9685 chip. This line is the I2C communication going into the hat, shown by the labeled gray box.</p>
			<p>The PWM generator has many connections out. Eight of these outputs go to control TB6612 motor drivers. These have power outputs suitable for DC motors (or stepper motors). They are still in the gray box as they are part of the hat. We connected those power outputs to our right motor (m1), left motor (m2), and have a space m3/m4 connection for other motors.</p>
			<p>The servo channels <a id="_idIndexMarker498"/>expose four of these PWM outputs directly. We'll connect the pan servo to one output and tilt to another.</p>
			<p>In the preceding code, I<a id="_idIndexMarker499"/> mentioned driving the PWM chip at 100 Hz instead of 50. This is because if we combine servo motors and DC motors, the time base for the chip applies to all the PWM outputs, even if the duty cycle (on-time to off-time ratio) changes.</p>
			<p>Now that you have tested the basics, we can calibrate the servo, finding where the 0 position is and making sure 90 degrees is moving by the right amount.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor202"/>Calibrating your servos</h2>
			<p>The servo horn allows<a id="_idIndexMarker500"/> you to see the servo motor's movement. Zero should be close to the middle:</p>
			<ol>
				<li value="1">First, use a screwdriver with the horn to line zero up with the middle. Loosen it, lift it, move it around to the middle, and then push it down again. Do not tighten this much as we will be removing this again.<p class="callout-heading">Important note</p><p class="callout">If the servo motor's motion is impeded, including an attempt to move it past its limits, it pulls higher currents to try and reach the position. Stalling a servo like that can cause a lot of heat and damage to the stalled motor.  </p></li>
				<li>Now try entering 90 and -90. You may find the two sides are not reaching 90 because servos can vary slightly. Increase the <strong class="source-inline">deflect_90_in_ms</strong> value to adjust the motor range. Do so in small 0.1 increments, as going too far here may lead to servo damage.</li>
				<li>When you've calibrated your servo, it is a good idea to ask each servo to go to position 0 before starting the next step. You can do this by plugging the second servo into channel 1 on the servo's connector, and then swapping the first parameter of every call to the <strong class="source-inline">pwm.setPWM</strong> method from 0 to 1.</li>
			</ol>
			<p>You have now tested some<a id="_idIndexMarker501"/> basic servo code, and then tried both servos and two channels. We can now use the servo motors to build a pan and tilt mechanism to point sensors.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor203"/>Adding a pan and tilt mechanism</h1>
			<p>We are now going to <a id="_idIndexMarker502"/>build and add a pan and tilt servo mechanism to our robot. This mechanism is like a head for our robot to mount sensors on it. A <strong class="bold">pan and tilt mechanism</strong>, shown in <em class="italic">Figure 10.8</em>, moves a sensor (or anything else) through two axes under servo motor control.</p>
			<p><em class="italic">Pan</em> means to turn left or right. <em class="italic">Tilt</em> means to tilt up or down:</p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="Images/B15660_10_08.jpg" alt="" width="463" height="333"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – A pan and tilt mechanism from a typical kit</p>
			<p>Kits like the one in <em class="italic">Figure 10.8</em> are available from Mouser, along with Adafruit outlets. You may need to purchase the servo motors separately. There are other types of pan-tilt. Ensure it is the type that uses two servos and refer to the manufacturer's documentation where it is different. We build the kit, mount it onto our robot, and plug it into the controller.</p>
			<p>Our robot block diagram with the servos looks like <em class="italic">Figure 10.9</em>:</p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="Images/B15660_10_09.jpg" alt="" width="1115" height="746"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – Block diagram of the robot with servo motors added</p>
			<p>The block diagram in <em class="italic">Figure 10.9</em> extends the block diagram from the previous chapter by adding the pan and tilt<a id="_idIndexMarker503"/> servos. These connect to the Motor HAT.</p>
			<p>Now that you've seen how it fits in the robot block diagram, it's time to build it!</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor204"/>Building the kit</h2>
			<p>You need your pan <a id="_idIndexMarker504"/>and tilt kit, a screwdriver, and a cutter. <em class="italic">Figure 10.10</em> shows the parts of the mechanism laid out:</p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="Images/B15660_10_10.jpg" alt="" width="950" height="671"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – The parts of the pan-tilt mechanism</p>
			<p>Take note of the terms I use for the different plastic parts in <em class="italic">Figure 10.10</em>; I use those for the assembly. Next to these<a id="_idIndexMarker505"/> are the screws that would have come with the kit too. There are usually self-tapping M2 screws in a servo motor's hardware bag – please ensure you have them.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The plastic here may ping off, so don't do this without safety goggles. Be aware of other people in the room and tiny sharp plastic bits landing. Please wear safety goggles for this step!</p>
			<p>Once you have your parts ready, we'll begin by assembling the base:</p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="Images/B15660_10_11.jpg" alt="" width="1650" height="762"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – Preparing the pan base</p>
			<p>Let's assemble the base, as shown in <em class="italic">Figure 10.11</em>, with the help of the following steps:</p>
			<ol>
				<li value="1">Measure out and cut<a id="_idIndexMarker506"/> a cross-shaped servo horn to fit the base. There are ridges it must fit into in the base. Shorten the servo horn's long arms to just over three holes and make them slightly thinner with the cutters.</li>
				<li>Line up the servo horn in the base, so the arms are in the recessed area, and the servo horn collar is facing away from the base.</li>
				<li>Find four of the long M2 self-tapping screws.</li>
				<li>Screw the servo horn into the base. Note that, with some servo horns, only the horizontal or the vertical screws may line up; two is sufficient, but four are more secure.</li>
			</ol>
			<p>Our base is now ready. Next, we'll assemble the left arm:</p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="Images/B15660_10_12.jpg" alt="" width="1428" height="381"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – Assembling the left arm and tilt plate</p>
			<p>To assemble the left arm, perform<a id="_idIndexMarker507"/> the following steps:</p>
			<ol>
				<li value="1">Line up the stud with the hole on the tilt plate, as shown in <em class="italic">Figure 10.12</em>. </li>
				<li>Push the stud into this hole; you will need to hold this in place for the next step.</li>
				<li>Take one of the servo motors and the two screws with collars. The servo rests on the two brackets on the tilt plate, and when screwed in, holds the left arm in place. Ensure that the servo's spindle aligns with the stud and hole before screwing it in.</li>
			</ol>
			<p>Great! Now let's move on to the right arm:</p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="Images/B15660_10_13.jpg" alt="" width="1650" height="360"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.13 – Assembling the right arm</p>
			<p>Follow these steps to assemble the arm:</p>
			<ol>
				<li value="1">To assemble the right arm, you need another servo horn—this time, the kind with just a collar and<a id="_idIndexMarker508"/> a single straight arm. As shown in <em class="italic">Figure 10.13</em>, the servo horn needs trimming to fit the intended recess on the right arm. Use one of the M2 self-tapping screws to bolt this onto the right arm of the mechanism. The servo horn you have attached is at the front of the mechanism.</li>
				<li>Flip this assembly over and slot another servo (this is the pan servo) into the slots as indicated.</li>
				<li>It should have the spindle facing the bottom of the photo, as shown in the third panel. This servo motor faces downward. </li>
			</ol>
			<p>Our next step is to combine the left and right arm that we just created. Follow along:</p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="Images/B15660_10_14.jpg" alt="" width="1650" height="784"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.14 – Combining the left arm and right arm</p>
			<p>You need to follow these steps to combine the arms:</p>
			<ol>
				<li value="1"><em class="italic">Figure 10.14</em> shows how to bring the left and right arm of the mechanism together. When combining the arms, the right arm servo horn's collar should clip around the tilt servo you screwed onto the tilt plate.</li>
				<li>The pan servo, in the left-arm assembly, fits into a matching cut-out.</li>
				<li>Use one of the short screws to attach the collar of the right arm to the tilt servo, keeping the tilt plate upright.</li>
				<li>Use two of the small thin screws to screw the two arms together.</li>
			</ol>
			<p>We're almost there. The last part is to combine the base that we initially created to the rest of the mechanism:</p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="Images/B15660_10_15.jpg" alt="" width="1476" height="389"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15 – Combining the base with the mechanism</p>
			<p>Continue with the procedure as follows:</p>
			<ol>
				<li value="1"><em class="italic">Figure 10.15</em> shows how to <a id="_idIndexMarker509"/>attach the mechanism to its base. Push the collar from the servo horn screwed into the base onto the pan servo spindle. Line it up so that the long axis of the base is in line with the bottom of the mechanism.</li>
				<li>Use one of the very short screws to bolt the collar onto the servo.</li>
				<li>The final panel shows the fully assembled pan and tilt mechanism.</li>
			</ol>
			<p>You've seen how a pan and tilt mechanism goes together around the servos. Assembling constructions like this is valuable for seeing how these mechanisms work and getting a feel for what the servo motors will do when they move. Now that the pan and tilt mechanism has been assembled, we need to attach it to the robot before we can move the head around.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor205"/>Attaching the pan and tilt mechanism to the robot</h2>
			<p>The mechanism needs to <a id="_idIndexMarker510"/>become part of the robot. We need both to<a id="_idIndexMarker511"/> attach it physically and wire it in place so that the motor controller can send signals to it.</p>
			<p><em class="italic">Figure 10.16</em> shows how to attach the pan and tilt mechanism to the robot:</p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="Images/B15660_10_16.jpg" alt="" width="773" height="625"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.16 – Attaching the pan and tilt mechanism to the robot</p>
			<p>Follow these<a id="_idIndexMarker512"/> instructions, along with the steps shown in <em class="italic">Figure 10.16</em>:</p>
			<ol>
				<li value="1">For this, you <a id="_idIndexMarker513"/>need two long bolts and two nuts to attach the pan and tilt mechanism to the robot.</li>
				<li>Drop the bolts into the short end of the pan and tilt base so that they are pointing down.</li>
				<li>The chassis I recommended has a slot across the front, which came in handy for the line sensor. This slot is perfect for mounting this pan and tilt mechanism, with the screws through the slot. On another chassis, you may need to measure and drill holes for this.</li>
				<li>Thread on the nuts and tighten from beneath the robot.</li>
				<li>Wire in the servos. The tilt (up and down servo) should plug into servo channel 0, and the pan (left and right) should plug into servo channel 1.</li>
			</ol>
			<p>Congratulations! Your<a id="_idIndexMarker514"/> robot is ready, and the hardware setup is complete. You are <a id="_idIndexMarker515"/>now ready to write code and try out the new head for your robot. So, let's dive straight in.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor206"/>Creating pan and tilt code</h1>
			<p>We build our pan and tilt code<a id="_idIndexMarker516"/> in layers. We create a <strong class="source-inline">Servos</strong> class and put the previous calculations into it. We set up our robot class to have an instance of the <strong class="source-inline">Servos</strong> class, and ways to access the servo to pan and the servo to tilt. </p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor207"/>Making the servo object</h2>
			<p>In this class, we <a id="_idIndexMarker517"/>encapsulate (internally manage the details of) converting an angle into a servo movement, and the quirks, such as channel numbers, of our servo board. We make a <strong class="source-inline">Servos</strong> class in a <strong class="source-inline">servos.py</strong> file for this: </p>
			<ol>
				<li value="1">The <strong class="source-inline">servos.py</strong> file starts with an import and then goes straight into the constructor (the <strong class="source-inline">__init__</strong> function):<p class="source-code"><strong class="bold">from Raspi_MotorHAT.Raspi_PWM_Servo_Driver import PWM</strong></p><p class="source-code"><strong class="bold">class Servos:</strong></p><p class="source-code"><strong class="bold">  def __init__(self, addr=0x6f, deflect_90_in_ms=0.6):</strong></p><p>Here we have an address for the PWM device. There's a deflection/calibration parameter called <strong class="source-inline">deflect_90_in_ms</strong> so that it can be overridden with the value obtained while calibrating your servos.</p></li>
				<li>Next, we will add a comment, so when we use the <strong class="source-inline">Servos</strong> class, we can see what we meant. The text in here will show up as help for our class in some code editors:<p class="source-code"><strong class="bold">     """addr: The i2c address of the PWM chip.</strong></p><p class="source-code"><strong class="bold">     deflect_90_in_ms: set this to calibrate the servo motors. </strong></p><p class="source-code"><strong class="bold">     it is what a deflection of 90 degrees is</strong></p><p class="source-code"><strong class="bold">     in terms of a pulse length in milliseconds."""</strong></p><p>The triple-quoted string at the top <a id="_idIndexMarker518"/>of the constructor is a <a id="_idIndexMarker519"/>convention known as a <strong class="bold">docstring</strong> in Python. Any string declared at the top of a function, method, class, or file becomes a special kind of comment, which many editors use to show you more help for the library. It's useful in any kind of library layer. The convention of using a docstring will complement all of the explanatory comments that we'll carry in from the test code.</p></li>
				<li>The next section of the <strong class="source-inline">__init__</strong> method should look familiar. It sets up all the calculations created in <em class="italic">steps 3</em> to <em class="italic">7</em> of the <em class="italic">Writing code for turning a servo</em> section within the <strong class="source-inline">servos</strong> object. We are storing the PWM object in <strong class="source-inline">self._pwm</strong>. We only keep some of the variables for later by storing them in <strong class="source-inline">self</strong>, and the rest are intermediate calculations:<p class="source-code"><strong class="bold">        self._pwm = PWM(addr)</strong></p><p class="source-code"><strong class="bold">        # This sets the timebase for it all</strong></p><p class="source-code"><strong class="bold">        pwm_frequency = 100</strong></p><p class="source-code"><strong class="bold">        self._pwm.setPWMFreq(pwm_frequency)</strong></p><p class="source-code"><strong class="bold">        # Mid-point of the servo pulse length in milliseconds.</strong></p><p class="source-code"><strong class="bold">        servo_mid_point_ms = 1.5</strong></p><p class="source-code"><strong class="bold">        # Frequency is 1/period, but working ms, we can use 1000</strong></p><p class="source-code"><strong class="bold">        period_in_ms = 1000 / pwm_frequency</strong></p><p class="source-code"><strong class="bold">        # The chip has 4096 steps in each period.</strong></p><p class="source-code"><strong class="bold">        pulse_steps = 4096</strong></p><p class="source-code"><strong class="bold">        # Steps for every millisecond.</strong></p><p class="source-code"><strong class="bold">        steps_per_ms = pulse_steps / period_in_ms</strong></p><p class="source-code"><strong class="bold">        # Steps for a degree</strong></p><p class="source-code"><strong class="bold">        self.steps_per_degree = (deflect_90_in_ms * steps_per_ms) / 90</strong></p><p class="source-code"><strong class="bold">        # mid-point of the servo in steps</strong></p><p class="source-code"><strong class="bold">        self.servo_mid_point_steps = servo_mid_point_ms * steps_per_ms</strong></p></li>
				<li>In the last part of the <strong class="source-inline">__init__</strong> method, we create <strong class="source-inline">self._channels</strong>; this variable lets us use<a id="_idIndexMarker520"/> channel numbers 0, 1, 2, and 3, and maps them to the quirky numbers on the board:<p class="source-code"><strong class="bold">        # Map for channels</strong></p><p class="source-code"><strong class="bold">        self._channels = [0, 1, 14, 15]</strong></p></li>
				<li>Next, we want a safety function to turn all of the servo motors off. Sending no pulse at all does that and releases the servos, protecting power and saving the motors from damage. This function uses the trick seen in <em class="italic">step 9</em> of the <em class="italic">Writing code for turning a servo recipe</em>, setting a start time of <strong class="source-inline">0</strong> and <strong class="source-inline">4096</strong> for the off flag to generate no pulse:<p class="source-code"><strong class="bold">    def stop_all(self):</strong></p><p class="source-code"><strong class="bold">        # 0 in start is nothing, 4096 sets the OFF bit.</strong></p><p class="source-code"><strong class="bold">        off_bit = 4096</strong></p><p class="source-code"><strong class="bold">        self._pwm.setPWM(self.channels[0], 0, off_bit)</strong></p><p class="source-code"><strong class="bold">        self._pwm.setPWM(self.channels[1], 0, off_bit)</strong></p><p class="source-code"><strong class="bold">        self._pwm.setPWM(self.channels[2], 0, off_bit)</strong></p><p class="source-code"><strong class="bold">        self._pwm.setPWM(self.channels[3], 0, off_bit)</strong></p></li>
				<li>Next is the conversion function, which we saw in <em class="italic">step 8</em> of the <em class="italic">Writing code for turning a servo section</em>, but localized to the class. We will only use this conversion internally. The Python convention for this is to prefix it with an underscore:<p class="source-code"><strong class="bold">    def _convert_degrees_to_steps(self, position):</strong></p><p class="source-code"><strong class="bold">        return int(self.servo_mid_point_steps + (position * self.steps_per_degree))</strong></p></li>
				<li>Also, we need a method to move the servo to an angle. It will take a channel number and an angle. I've used another docstring in this method to explain what it does and what the limits are:<p class="source-code"><strong class="bold">    def set_servo_angle(self, channel, angle):</strong></p><p class="source-code"><strong class="bold">        """position: The position in degrees from the center. -90 to 90"""        </strong></p></li>
				<li>The next couple of lines <a id="_idIndexMarker521"/>validate the input. It limits the angle to protect the servo from an out-of-range value, raising a Python exception if it's outside. An exception pushes a problem like this up to calling systems until one of them handles it, killing the code if nobody does: <p class="source-code"><strong class="bold">        # Validate</strong></p><p class="source-code"><strong class="bold">        if angle &gt; 90 or angle &lt; -90:</strong></p><p class="source-code"><strong class="bold">            raise ValueError("Angle outside of range")</strong></p></li>
				<li>The last two lines of this method set the position:<p class="source-code"><strong class="bold">      # Then set the position</strong></p><p class="source-code"><strong class="bold">      off_step = self._convert_degrees_to_steps(angle)</strong></p><p class="source-code"><strong class="bold">      self._pwm.setPWM(self.channels[channel], 0, off_step)</strong></p></li>
			</ol>
			<p>You can find the full code at <a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/servos.py">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/servos.py</a>.</p>
			<p>This class is now ready to incorporate into our robot. Let's do this in the next section.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor208"/>Adding the servo to the robot class</h2>
			<p>Before we start using the<a id="_idIndexMarker522"/> preceding <strong class="source-inline">Servos</strong> class in behaviors, we will incorporate it into our <strong class="source-inline">robot.py</strong> file and assign specific purposes to specific servo motors. This way, a behavior could use a different robot with differently configured pan and tilt mechanisms by swapping out the robot class:</p>
			<ol>
				<li value="1">Next, we need to patch this into the <strong class="source-inline">Robot</strong> class in <strong class="source-inline">robot.py</strong>. First, let's import it after the <strong class="source-inline">leds</strong> import:<p class="source-code"><strong class="bold">import leds_led_shim</strong></p><p class="source-code"><strong class="bold">from servos import Servos</strong></p><p class="source-code"><strong class="bold">...</strong></p></li>
				<li>This <strong class="source-inline">servos</strong> object then needs to be set up in the constructor for <strong class="source-inline">Robot</strong>, passing along<a id="_idIndexMarker523"/> the address:<p class="source-code"><strong class="bold">class Robot:</strong></p><p class="source-code"><strong class="bold">    def __init__(self, motorhat_addr=0x6f):</strong></p><p class="source-code"><strong class="bold">       # Setup the motorhat with the passed in address</strong></p><p class="source-code"><strong class="bold">       self._mh = Raspi_MotorHAT(addr=motorhat_addr)</strong></p><p class="source-code"><strong class="bold">       # get local variable for each motor</strong></p><p class="source-code"><strong class="bold">       self.left_motor = self._mh.getMotor(1)</strong></p><p class="source-code"><strong class="bold">       self.right_motor = self._mh.getMotor(2)</strong></p><p class="source-code"><strong class="bold">       # Setup the Leds</strong></p><p class="source-code"><strong class="bold">       self.leds = leds_led_shim.Leds()</strong></p><p class="source-code"><strong class="bold">       # Set up servo motors for pan and tilt.</strong></p><p class="source-code"><strong class="bold">       self.servos = Servos(addr=motorhat_addr)</strong></p><p class="source-code"><strong class="bold">       # ensure the motors get stopped when the code exits</strong></p><p class="source-code"><strong class="bold">       atexit.register(self.stop_all)</strong></p><p class="source-code"><strong class="bold">...</strong></p></li>
				<li>Now, we should make sure it stops when the robot stops by adding it to the <strong class="source-inline">stop_all</strong> code:<p class="source-code"><strong class="bold">    def stop_all(self):</strong></p><p class="source-code"><strong class="bold">        self.stop_motors()</strong></p><p class="source-code"><strong class="bold">        # Clear the display</strong></p><p class="source-code"><strong class="bold">        self.leds.clear()</strong></p><p class="source-code"><strong class="bold">        self.leds.show()</strong></p><p class="source-code"><strong class="bold">        # Reset the servos</strong></p><p class="source-code"><strong class="bold">        self.servos.stop_all()</strong></p><p class="source-code"><strong class="bold">...</strong></p></li>
				<li>The last thing to do in <strong class="source-inline">robot</strong> is to map setting pan and tilt values to the actual servo motors: <p class="source-code"><strong class="bold">    def set_pan(self, angle):</strong></p><p class="source-code"><strong class="bold">        self.servos.set_servo_angle(1, angle)</strong></p><p class="source-code"><strong class="bold">    </strong></p><p class="source-code"><strong class="bold">    def set_tilt(self, angle):</strong></p><p class="source-code"><strong class="bold">        self.servos.set_servo_angle(0, angle)</strong></p></li>
			</ol>
			<p>Our <strong class="source-inline">Robot</strong> object now has methods<a id="_idIndexMarker524"/> to interact with the pan and tilt servos on the robot chassis. This gives us specific controls for servos on the robot and presents a layer to use in behaviors. In the next section, we will make a behavior that uses these to make circles.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor209"/>Circling the pan and tilt head</h2>
			<p>In this section, we make the pan <a id="_idIndexMarker525"/>and tilt head move in small circles of around 30 degrees. This behavior demonstrates the mechanism and the parts of the code to talk to it. The code creates a repeating animated kind of behavior that uses a time base—a current time. We use the time base to draw the circle:</p>
			<ol>
				<li value="1">Create a new file; I suggest the name <strong class="source-inline">circle_pan_tilt_behavior.py</strong>.</li>
				<li>We start with a number of imports; the <strong class="source-inline">Robot</strong> object, the <strong class="source-inline">math</strong> library, and some timing:<p class="source-code"><strong class="bold">from time import sleep</strong></p><p class="source-code"><strong class="bold">import math</strong></p><p class="source-code"><strong class="bold">from robot import Robot</strong></p><p>We prepare the <strong class="source-inline">math</strong> library as we are going to use sine and cosine to calculate that circle.</p></li>
				<li>As our behavior has local data, we will put it into a class of its own. The constructor (<strong class="source-inline">the__init__</strong> method) takes the <strong class="source-inline">Robot</strong> object:<p class="source-code"><strong class="bold">class CirclePanTiltBehavior:</strong></p><p class="source-code"><strong class="bold">    def __init__(self, the_robot):</strong></p><p class="source-code"><strong class="bold">        self.robot = the_robot</strong></p></li>
				<li>This behavior is essentially an animation, so it has a time and count of <em class="italic">frames</em> or positions for each circle. We use a <strong class="source-inline">frames_per_circle</strong> variable to adjust how many steps it goes through:<p class="source-code"><strong class="bold">        self.current_time = 0</strong></p><p class="source-code"><strong class="bold">        self.frames_per_circle = 50</strong></p></li>
				<li>The math functions work in radians. A full circle of radians is <em class="italic">2 times pi</em>. We divide that by <strong class="source-inline">frames_per_circle</strong> to make a multiplier we call <strong class="source-inline">radians_per_frame</strong>. We can multiply this back out with the current frame to give us a radian angle for the circle later:<p class="source-code"><strong class="bold">        self.radians_per_frame = (2 * math.pi) / self.frames_per_circle</strong></p><p>We work with radians <a id="_idIndexMarker526"/>and not degrees here because we'd end up with a constant multiplier, taking the degrees into radians and dividing by frames per circle, so we'd end up back with <strong class="source-inline">radians_per_frame</strong>.</p></li>
				<li>Being a circle, it should also have a radius, representing how far our servos deflect from the middle:<p class="source-code"><strong class="bold">        self.radius = 30</strong></p></li>
				<li>The next method in the behavior is <strong class="source-inline">run</strong>. This puts the behavior in a <strong class="source-inline">while True</strong> loop, so it runs until the user stops it:<p class="source-code"><strong class="bold">    def run(self):</strong></p><p class="source-code"><strong class="bold">        while True:</strong></p></li>
				<li>When our behavior runs, we then take <strong class="source-inline">current_time</strong> and turn it into a frame number using the modulo (remainder) operation on <strong class="source-inline">frames_per_circle</strong>. The modulo constrains the number between zero and the number of frames: <p class="source-code"><strong class="bold">            frame_number = self.current_time % self.frames_per_circle</strong></p></li>
				<li>We then take this <strong class="source-inline">frame_number</strong> variable and turn it back into radians, a position around the circle, by multiplying it back with <strong class="source-inline">radians_per_frame</strong>. This multiplication gives us a value we call <strong class="source-inline">frame_in_radians</strong>:<p class="source-code"><strong class="bold">            frame_in_radians = frame_number * self.radians_per_frame</strong></p></li>
				<li>The formula for drawing <a id="_idIndexMarker527"/>a circle is to make one of the axes the cosine of the angle, times the radius, and the other the sine of the angle, times the radius. So, we calculate this and feed each axis to a servo motor:<p class="source-code"><strong class="bold">            self.robot.set_pan(self.radius * math.cos(frame_in_radians))</strong></p><p class="source-code"><strong class="bold">            self.robot.set_tilt(self.radius * math.sin(frame_in_radians))</strong></p></li>
				<li>We perform a small <strong class="source-inline">sleep()</strong> to give the motors time to reach their position, and then add one to the current time:<p class="source-code"><strong class="bold">            sleep(0.05)</strong></p><p class="source-code"><strong class="bold">            self.current_time += 1</strong></p></li>
				<li>That entire <strong class="source-inline">run</strong> method together (<em class="italic">steps 7-11</em>) is as follows:<p class="source-code"><strong class="bold">    def run(self):</strong></p><p class="source-code"><strong class="bold">        while True:</strong></p><p class="source-code"><strong class="bold">            frame_number = self.current_time % self.frames_per_circle</strong></p><p class="source-code"><strong class="bold">            frame_in_radians = frame_number * self.radians_per_frame</strong></p><p class="source-code"><strong class="bold">            self.robot.set_pan(self.radius * math.cos(frame_in_radians))</strong></p><p class="source-code"><strong class="bold">            self.robot.set_tilt(self.radius * math.sin(frame_in_radians))</strong></p><p class="source-code"><strong class="bold">            sleep(0.05)</strong></p><p class="source-code"><strong class="bold">            self.current_time += 1</strong></p></li>
				<li>Finally, we just want to start up and run our behavior:<p class="source-code"><strong class="bold">bot = Robot()</strong></p><p class="source-code"><strong class="bold">behavior = CirclePanTiltBehavior(bot)</strong></p><p class="source-code"><strong class="bold">behavior.run()</strong></p></li>
			</ol>
			<p>So, we've built a <strong class="source-inline">Servos</strong> class, and incorporated<a id="_idIndexMarker528"/> it to control the pan and tilt mechanism in our <strong class="source-inline">Robot</strong> code. You've seen code to move servo motors in an animation-like way. We can combine this with the physical pan-tilt in the next section to see this run.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor210"/>Running it</h2>
			<p>You <a id="_idIndexMarker529"/>need to send <strong class="source-inline">servos.py</strong>, <strong class="source-inline">robot.py</strong>, and <strong class="source-inline">circle_pan_tilt_behavior.py</strong> to the Raspberry Pi over SFTP. On the Raspberry Pi, type <strong class="source-inline">python3 circle_pan_tilt_behaviour.py</strong> to see it. The head should now be making circles.</p>
			<p>This is demonstration code for the device, but will later be able to use the same device to track faces by mounting a camera on it. The use of frames here to create an animation is important for making smooth predetermined movements with a robot, controlling small movements over time.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor211"/>Troubleshooting</h2>
			<p>If this does not run, please try <a id="_idIndexMarker530"/>the following:</p>
			<ul>
				<li>Ensure you were able to test the servos as shown in the <em class="italic">Writing code for turning a servo</em> section. There is no need to disassemble the pan and tilt mechanism for this, but please make sure you have made a servo move with the code there and followed that troubleshooting section.</li>
				<li>If you see errors while running this, please ensure you are running with <strong class="source-inline">python3</strong>. Please ensure that you have checked for typos in your code.</li>
				<li>If the code fails to import anything, ensure that you have copied over all the preceding files and that you have installed/set up the libraries in previous chapters.</li>
				<li>If the motors move to an extreme position, you may have missed the step to calibrate them. You will need to unbolt and pop each out of the servo horn, send it to position 0, using the test code from the <em class="italic">Writing code for turning a servo</em> section, and then push them back in at a neutral position, screwing them back in.</li>
				<li>If a servo refuses to move at all, check that it has been plugged in the right way, ensuring that G corresponds to the black servo wire, V corresponds to the red wire, and S to the yellow signal wire from the servo. The robot code has assumed that the servo motors are plugged into channels 0 and 1 of the motor control board.</li>
				<li>Ensure that there are no breaks in the wires or their insulation. I have seen a batch of servo motors of this type with wire problems and had to return them. You should not be able to see any bare patches of wire.</li>
				<li>Ensure that the<a id="_idIndexMarker531"/> connectors are pushed in firmly. If they are loose here, then a signal may not be getting to the servo motors.</li>
				<li>It's worth saying again: low batteries will make a servo jitter or fail to reach a set point.</li>
			</ul>
			<p>You should now have troubleshot the common problems seen with running this circle servo motor behavior and see the head making small and slow circles. We will be able to use this system in a later chapter to look at faces.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor212"/>Building a scanning sonar</h1>
			<p>Using the distance sensor we attached in <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>, with the pan and tilt<a id="_idIndexMarker532"/> mechanism allows us to set up an interesting experiment. If we attach the distance sensor to the head, and then slowly sweep in a direction (for example, the pan direction), we can create a sensor sweep of an area. We can then use some Python code to plot this, making a small map of things in front of the robot.</p>
			<p>A sensor similar to this combination is found in advanced robots (like those from Boston Dynamics) and autonomous cars. LIDAR and RADAR sensors use laser light or radio frequencies with a fast spinning drum to perform the same kind of sweeps far faster than our example. LIDAR sensors are starting to appear on the hobbyist market, but are still a little costly.</p>
			<p>To visualize this, we are going to use a <a id="_idIndexMarker533"/>special kind of chart – a polar plot. This plots around a circle, with the <em class="italic">x</em>-axis being where we are around a circle (in radians – multiples of pi). The <em class="italic">y</em>-axis forms how far a plotted point is from the center of a circle – so a larger value will be further out. This lends itself very well to this example because we are sweeping the servo through angles and receiving distance data. We will have to account for the servo working in degrees and translate to radians for the graph output.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor213"/>Attaching the sensor</h2>
			<p>In this step, we'll extend a <a id="_idIndexMarker534"/>sensor's wires and reposition the sensor onto the pan-and-tilt head. Start with the robot powered down:</p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="Images/B15660_10_17.jpg" alt="" width="1650" height="465"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.17 – Pop out the sensor and prepare two wires</p>
			<p>Follow these steps to reposition the sensor together with <em class="italic">Figure 10.17</em>:</p>
			<ol>
				<li value="1">You will need to pop one of the distance sensors out of the mount on the robot's front. I used the left.</li>
				<li>On the pan/tilt head there, identify the small slots.</li>
				<li>Make two lengths of single-core wire or sandwich ties. A length of about 18 cm for each should suffice:<div id="_idContainer173" class="IMG---Figure"><img src="Images/B15660_10_18.jpg" alt="" width="1650" height="466"/></div><p class="figure-caption">Figure 10.18 – Steps 4 to 6; putting wires in the slots</p></li>
				<li>For each side, first push the wire through the indicated slot shown in <em class="italic">Figure 10.18</em>.</li>
				<li>Bend it around a little, pushing the two <a id="_idIndexMarker535"/>ends nearly together so that it doesn't just drop out.</li>
				<li>Prepare the other side the same way, so both sides are ready:<div id="_idContainer174" class="IMG---Figure"><img src="Images/B15660_10_19.jpg" alt="" width="1650" height="430"/></div><p class="figure-caption">Figure 10.19 – Wrapping wire underneath the sensor</p></li>
				<li>Put the sensor in place and bend the left wire coming from the top of the head around the sensor's front.</li>
				<li>Now bend it under the big round element (the ultrasonic transducer) indicated by the white arrow in <em class="italic">Figure 10.19</em>.</li>
				<li>Bend the wire <a id="_idIndexMarker536"/>sticking out underneath over the sensor:<div id="_idContainer175" class="IMG---Figure"><img src="Images/B15660_10_20.jpg" alt="" width="1650" height="408"/></div><p class="figure-caption">Figure 10.20 – Twist the wire and repeat for the right</p></li>
				<li>Wrap this wire around the top of the left transducer and bring the two wire ends together.</li>
				<li>Twist the top and bottom ends together, as shown in <em class="italic">Figure 10.20</em>.</li>
				<li>Repeat <em class="italic">steps 8</em> to <em class="italic">11</em> for the wires on the right:<div id="_idContainer176" class="IMG---Figure"><img src="Images/B15660_10_21.jpg" alt="" width="1650" height="429"/></div><p class="figure-caption">Figure 10.21 – The sensor temporarily secured to the pan-and-tilt head</p></li>
				<li>The sensor should now be temporarily secured to the pan-and-tilt head, as shown in <em class="italic">Figure 10.21</em>. You are now ready to wire it back in:<div id="_idContainer177" class="IMG---Figure"><img src="Images/B15660_10_22.jpg" alt="" width="1650" height="651"/></div><p class="figure-caption">Figure 10.22 – Extend the wires and plug the wires in</p><p>You may need to<a id="_idIndexMarker537"/> extend the jumper wires, as shown in <em class="italic">Figure 10.22</em>. You are likely to have more male-female jumper cables left, so use four of those to extend the sensor. Be careful to ensure that you make the same connections through these to the sensor. It helps to use the same colors if you can.</p></li>
				<li>Now make the wire connections to the sensor. Refer back to <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>, for reference.</li>
			</ol>
			<p>I suggest running the <strong class="source-inline">test_distance_sensor.py</strong> code from <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>, and checking that the sensor is working before you continue.</p>
			<p>Now that you have mounted the sensor on the head, it will move when we instruct the servo motors to move. Let's make sure that we have the right tools on the Raspberry Pi for the code first.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor214"/>Installing the library</h2>
			<p>The code will use the<a id="_idIndexMarker538"/> Python tool <strong class="source-inline">matplotlib</strong> to output the data. It makes a <strong class="bold">polar</strong> plot, a graph <a id="_idIndexMarker539"/>originating radially from a point, which will look like a sonar scan you may have seen in movies. To do this, you will need to install Matplotlib (and its dependencies) onto your Raspberry Pi.</p>
			<p>SSH (putty) into the Raspberry Pi and type the following to get the packages that Matplotlib requires:</p>
			<p class="source-code">$ sudo apt update</p>
			<p class="source-code">$ sudo apt install libatlas3-base libgfortran5</p>
			<p>The next thing you need is Matplotlib itself:</p>
			<p class="source-code">$ pip3 install matplotlib</p>
			<p>Matplotlib may take a short time to install and install many helper packages along the way. </p>
			<p>With the library installed, you are ready to write the code.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor215"/>Behavior code</h2>
			<p>To make our plot and get the data, the<a id="_idIndexMarker540"/> code will move the sensor to the full extent on one side, and then move back in steps (for example, 5 degrees), measuring at each. This example will show using a sensor and servo motor together and introduce other ways to view sensor data.</p>
			<p>Create a file named <strong class="source-inline">sonar_scan.py</strong> and follow these steps for its content:</p>
			<ol>
				<li value="1">We'll start with some imports; the <strong class="source-inline">time</strong> import, with which we can give motor and sensors time to work, <strong class="source-inline">math</strong> to convert from degrees to radians, <strong class="source-inline">matplotlib</strong> to make the display, and <strong class="source-inline">robot</strong> to interface with the robot: <p class="source-code"><strong class="bold">import time</strong></p><p class="source-code"><strong class="bold">import math</strong></p><p class="source-code"><strong class="bold">import matplotlib.pyplot as plt</strong></p><p class="source-code"><strong class="bold">from robot import Robot</strong></p></li>
				<li>We then have some setup parameters. We put these out here to encourage you to experiment with different turn speeds and extents:<p class="source-code"><strong class="bold">start_scan =0</strong></p><p class="source-code"><strong class="bold">lower_bound = -90</strong></p><p class="source-code"><strong class="bold">upper_bound = 90</strong></p><p class="source-code"><strong class="bold">scan_step = 5</strong></p></li>
				<li>Next, let's initialize the <strong class="source-inline">Robot</strong> object and ensure the tilt is looking horizontally:<p class="source-code"><strong class="bold">the_robot = Robot()</strong></p><p class="source-code"><strong class="bold">the_robot.set_tilt(0)</strong></p></li>
				<li>We need to prepare a place to store<a id="_idIndexMarker541"/> our scan data. We will use a dictionary mapping from a heading in degrees to the value sensed there:<p class="source-code"><strong class="bold">scan_data = {}</strong></p></li>
				<li>The scan loop starts from the lower bound and increments by the scan step up to the upper bound; this gives us our range of facings:<p class="source-code"><strong class="bold">for facing in range(lower_bound, upper_bound, scan_step):</strong></p></li>
				<li>For each facing in the loop, we need to point the sensor, and wait for the servo to move and for the sensor to get readings. We negate the facing here because the servo motor turns the opposite way to the polar plot:<p class="source-code"><strong class="bold">    the_robot.set_pan(-facing)</strong></p><p class="source-code"><strong class="bold">    time.sleep(0.1)</strong></p></li>
				<li>We then store the sensor distance as centimeters in the scan data for each facing, using the facing as its key:<p class="source-code"><strong class="bold">    scan_data[facing] = the_robot.left_distance_sensor.distance * 100</strong></p></li>
				<li>The following loop converts the facings into radians. The servo works in degrees, but a quirk of Matplotlib is that the polar axis must be in radians:<p class="source-code"><strong class="bold">axis = [math.radians(facing) for facing in scan_data.keys()]</strong></p></li>
				<li>Now we make our polar plot, telling Matplotlib the axis and the data, and that we want a green line with <strong class="source-inline">g-</strong>:<p class="source-code"><strong class="bold">plt.polar(axis, list(scan_data.values()), 'g-')</strong></p></li>
				<li>The last line<a id="_idIndexMarker542"/> writes this plot out to a <strong class="source-inline">png</strong> image file, so we can use <strong class="source-inline">scp</strong> to download it from the Raspberry Pi and view the plot:<p class="source-code"><strong class="bold">plt.savefig("scan.png")</strong></p></li>
			</ol>
			<p>Put this code on the Raspberry Pi, place the robot somewhere with a few obstacles less than a meter away, and run the code with <strong class="source-inline">python3 sonar_scan.py</strong>. You should see the servo motor make a sweep of the bounds.</p>
			<p>When this runs, the <strong class="source-inline">scan.png</strong> output should look something like <em class="italic">Figure 10.23</em>:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="Images/B15660_10_23.jpg" alt="" width="646" height="444"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.23 – A sonar scan plot of my lab</p>
			<p><em class="italic">Figure 10.23</em> shows the sonar scan output on a polar plot. It shows the measurements in degrees, with a green line tracing the contours of items detected in front of the sensor. In this image, my lower<a id="_idIndexMarker543"/> bound was -90, my upper bound 90, and my step at 2 degrees for slightly finer resolution.</p>
			<p>Choosing a finer resolution (less than 2 degrees) will make it slower. The sleep value could be tuned, but lower values risk the servo not settling or the sensor not producing further readings.</p>
			<h3 id="_idParaDest-228">Troubleshooting</h3>
			<p>If you encounter problems while running this tool, please try the following:</p>
			<ul>
				<li>First, ensure the distance<a id="_idIndexMarker544"/> sensor works by following the troubleshooting and testing steps in <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>. Verify the wiring and use the test code.</li>
				<li>Verify that the servo motors are working, as shown in the preceding <em class="italic">Creating the pan and tilt code</em> section. Follow the troubleshooting procedures there.</li>
				<li>If there are errors running the code, ensure that you have installed all the libraries needed.</li>
				<li>Check that there are no typos in the code you have entered. </li>
				<li>Remember, the file output will be on the Raspberry Pi, so you will have to copy it back to view it.</li>
				<li>It can be helpful to print values before they go into the <strong class="source-inline">plt.polar</strong> method. Add the following:<p class="source-code"><strong class="bold">print(axis)</strong></p><p class="source-code"><strong class="bold">print(scan_data.values())</strong></p></li>
			</ul>
			<p>You should now have been able to make a sonar scan and get a plot like the one above. I suggest you experiment with the values to create different plot resolutions and put different object combinations in front of the sensor. </p>
			<p>Let's summarize what we've seen in the chapter.</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor216"/>Summary</h1>
			<p>In this chapter, you have learned about servo motors, how to control them with your motor controller, and how they work. You've built a pan and tilt mechanism with them and added code to the <strong class="source-inline">Robot</strong> object to work with that mechanism. Finally, you've demonstrated all of the parts with the circling behavior.</p>
			<p>You will be able to use the code you've seen to control other servo motor systems, such as robot arms. The animation style techniques can be useful for smooth movement and circular motions. I used a system a little like this when controlling the 18 motors in SpiderBot's legs.</p>
			<p>You've seen how to use a servo with a sensor on a head to make some kind of map of the world and related it to the LIDAR systems used on bigger and more expensive robots.</p>
			<p>In the next chapter, we will look at another way to map and observe the world with encoders. These sensors will detect wheels turning on our robot to determine how our robot is moving.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor217"/>Exercises</h1>
			<ol>
				<li value="1">Consider how you might build other servo-based extensions. A robot arm needs at least four servos, but a simple gripper/grabber can use the two additional channels our robot has left.</li>
				<li>Look around at kits for a gripper, a design with a pincer, and perhaps an up/down control. </li>
				<li>How would you write the code for this gripper? What would you add to the <strong class="source-inline">Robot</strong> object?</li>
				<li>What demo behavior would you make for this gripper?</li>
				<li>A gripper might move too violently when just given a different position to be in. How would you make a slower smooth movement?</li>
			</ol>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor218"/>Further reading</h1>
			<p>Please refer to the following links for more information:</p>
			<ul>
				<li>This servo motor control hat is based on the PCA9685 device. The PCA9685 product data sheet (<a href="https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf">https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf</a>) contains full information about operating this chip. I highly recommend referencing this.</li>
				<li>I also recommend looking at the SG90 servo motor data sheet (<a href="http://www.ee.ic.ac.uk/pcheung/teaching/DE1_EE/stores/sg90_datasheet.pdf">http://www.ee.ic.ac.uk/pcheung/teaching/DE1_EE/stores/sg90_datasheet.pdf</a>) for information about their operation.</li>
				<li>The AdaFruit guide to the pan and tilt mechanism (<a href="https://learn.adafruit.com/mini-pan-tilt-kit-assembly">https://learn.adafruit.com/mini-pan-tilt-kit-assembly</a>) has a set of assembly instructions. They are in a slightly different order from mine but may give a different perspective if this is proving to be tricky.</li>
			</ul>
		</div>
	</div></body></html>