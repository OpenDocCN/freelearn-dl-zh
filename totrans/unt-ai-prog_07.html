<html><head></head><body>
		<div><h1 id="_idParaDest-85"><em class="italic"><a id="_idTextAnchor332"/>Chapter <a id="_idTextAnchor333"/>5</em>: Flocking</h1>
			<p>During early summer evenings, you have probably seen flocks of birds flying in the sky. You have probably noted how they seem to move as a single living object: they all move in a particular direction, turn around, and grow and shrink. A flocking system aims to replicate this behavior in games: we want to implement an algorithm to move many objects as an organic group.</p>
			<p>In games, we call each <a id="_idIndexMarker268"/>element of a flock a <strong class="bold">boid</strong>. To implement a flocking behavior, we do not need to equip each boid with a high-level complex decision-making system; instead, all we need to do is implement simple <em class="italic">reactive</em> rules for each boid that depend only on the state of the flock itself. Thus, flocking is an excellent example of emergent behavior: each boid reacts exclusively to its neighbor's behaviors; nevertheless, the flock seems to move as if someone were coordinating it.</p>
			<p>In this chapter, we will learn what these rules are and how to implement them in Unity3D. We will implement two variations of flocking in this chapter. The first one is based on an old flocking behavior demo that has been circulating in the Unity community since since the game engine was created.</p>
			<p>The second variation is based on Craig Reynold's original flocking algorithm from 1986.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>An overview of basic flocking behavior and how to implement it<a id="_idTextAnchor334"/><a id="_idTextAnchor335"/></li>
				<li>An alternative implementation of flocking behavior<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/></li>
			</ul>
			<h1 id="_idParaDest-86">Technical requirements<a id="_idTextAnchor338"/><a id="_idTextAnchor339"/></h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <code>Chapter 5</code> folder in the book's repository:<a id="_idTextAnchor340"/><a id="_idTextAnchor341"/> <a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor342"/>Basic flocking behavior</h1>
			<p>As we said in <a id="_idIndexMarker269"/>the introduction to this chapter, we can describe a flocking behavior by using just three intuitive properties<a id="_idTextAnchor343"/>:</p>
			<ul>
				<li><strong class="bold">Separation</strong>: This property, also called <em class="italic">short-range repulsion</em>, represents the minimum <a id="_idIndexMarker270"/>distance between neighboring boids to avoid collisions. You can imagine this rule as a force that pushes a boid away from the othe<a id="_idTextAnchor344"/>rs.</li>
				<li><strong class="bold">Alignment</strong>: This <a id="_idIndexMarker271"/>property represents the likelihood for each boid to move in the same direction as the flock (we measure this as the average direction of all the individual boids).</li>
				<li><strong class="bold">Cohesion</strong>: This property, also <a id="_idIndexMarker272"/>called <em class="italic">long-range attraction</em>, represents the likelihood for each boid to move toward the center of mass of <a id="_idIndexMarker273"/>the flock (we measure this by averaging the position of each boid in the flock). Thus, you can imagine this rule as a force that pushes a boid toward the center of the flock.</li>
			</ul>
			<p>In this demo, we will create a scene with flocks of objects and implement the flocking behavior in C#. For this first version, we compute all the rules by ourselves. Also, we will create a boid commander that leads the crowd to control and track the general position of the flock easily.</p>
			<p>You can see the <strong class="bold">Hierarchy</strong> scene in the following screenshot. As you can see, we have several boid entities named <strong class="bold">UnityFlock</strong>, under a controller named <strong class="bold">UnityFlockController</strong>. <strong class="bold">UnityFlock</strong> entities are individual boid objects that refer to their parent <strong class="bold">UnityFlockController</strong> entity, using it as a leader. The controller updates the next destination point randomly once it reaches the current destination point:</p>
			<div><div><img src="img/B17984_05_1.jpg" alt="Figure 5.1 – The scene hierarchy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The scene hierarchy</p>
			<p><code>UnityFlock</code> script. We can use any <a id="_idTextAnchor345"/><a id="_idTextAnchor346"/>other mesh <a id="_idIndexMarker275"/>representation for this prefab to represent something more interesting, such as birds. You can add as many <strong class="bold">UnityFlock</strong> prefabs as you like. The algorithm will automatically check the number of children in the <strong class="bold">UnityFlockController</strong> o<a id="_idTextAnchor347"/><a id="_idTextAnchor348"/>bject.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor349"/>Individual behavior</h2>
			<p><em class="italic">Boid</em> is a term coined by Craig Reynold that refers to bird-like objects. We use this term to describe <a id="_idIndexMarker276"/>each object in our flock. The boid behaviour consists of a group of objects, each having their individual position, velocity, and orientation. Now, let's implement the boid behavior. You can find the behavior that controls each boid in the flock in the <code>UnityFlock.cs</code> script, which we'll examine now:</p>
			<pre>using UnityEngine;
using System.Collections;
public class UnityFlock : MonoBehaviour { 
    public float minSpeed = 20.0f;
    public float turnSpeed = 20.0f; 
    public float randomFreq = 20.0f;
    public float randomForce = 20.0f;
    //alignment variables
    public float toOriginForce = 50.0f;
    public float toOriginRange = 100.0f;
    public float gravity = 2.0f;
    //seperation variables
    public float avoidanceRadius = 50.0f;
    public float avoidanceForce = 20.0f;
    //cohesion variables
    public float followVelocity = 4.0f;
    public float followRadius = 40.0f;
    //these variables control the movement of the boid
    private Transform origin;
    private Vector3 velocity;
    private Vector3 normalizedVelocity;
    private Vector3 randomPush;
    private Vector3 originPush;
    private Transform[] objects;
    private UnityFlock[] otherFlocks;
    private Transform transformComponent;
    private float randomFreqInterval;</pre>
			<p>As public fields, we declare the input values for our algorithm. These can be set up and customized <a id="_idIndexMarker277"/>from within the Inspector. In this script, we perform the following operations:</p>
			<ol>
				<li>We define the minimum movement speed (<code>minSpeed</code>) and rotation speed (<code>turnSpeed</code>) for our boid.</li>
				<li>We use <code>randomFreq</code> to determine how many times we want to update the <code>randomPush</code> value, based on the <code>randomForce</code> value. Then, we use this force to vary the single boid's velocity and make the flock's movement look more realistic.</li>
				<li><code>toOriginRange</code> specifies how much we want the flock to spread out. In other words, it represents the maximum distance from the flock's origin in which we want to maintain the boids (following the previously mentioned cohesion rule). We use the <code>avoidanceRadius</code> and <code>avoidanceForce</code> properties to maintain a minimum distance between individual boids (following the separation rule). Similarly, we use <code>followRadius</code> and <code>followVelocity</code> to keep a minimum distance between the leader or origin of the flock. The <code>origin</code> variable stores the parent object that controls the entire flock; in other words, it is the flock leader. The boids need to know about the other boids in the flock. Therefore, we use the <code>objects</code> and <code>otherFlocks</code> attributes to store the neighboring boid's information.</li>
			</ol>
			<p>This is the initialization method for our boid:</p>
			<pre>void Start () {
    randomFreqInterval = 1.0f / randomFreq;
    // Assign the parent as origin 
    origin = transform.parent;
    // Flock transform 
    transformComponent = transform;
    // Temporary components 
    Component[] tempFlocks= null;
    // Get all the unity flock components from the parent 
    // transform in the group 
    if (transform.parent) {
        tempFlocks = transform.parent
          .GetComponentsInChildren&lt;UnityFlock&gt;();       
    }
    // Assign and store all the flock objects in this group 
    objects = new Transform[tempFlocks.Length];
    otherFlocks = new UnityFlock[tempFlocks.Length];
    for (int i = 0;i&lt;tempFlocks.Length;i++) { 
        objects[i] = tempFlocks[i].transform;
        otherFlocks[i] = (UnityFlock)tempFlocks[i];
    }
    // Null Parent as the flock leader will be 
    // UnityFlockController object 
    transform.parent = null;
    // Calculate random push depends on the random 
    // frequency provided
    StartCoroutine(UpdateRandom());
}</pre>
			<p>We set the <a id="_idIndexMarker278"/>parent of the object of our boid as origin, meaning that this is the controller object for the other boids to follow. Then, we grab all the other boids in the group and store them in the <code>otherFlocks</code> attribute for later reference.</p>
			<p class="callout-heading">Coroutines</p>
			<p class="callout">Put simply, coroutines <a id="_idIndexMarker279"/>are <em class="italic">functions that can be paused</em>. With coroutines, you can run a method, pause the execution for a desired amount of time (for example, a single frame or several seconds), and then continue from the following line as if nothing happened. They have two primary use cases: to run a function after a specific interval (without keeping track of every frame of <code>elapsedTimes</code>, as we did in other examples) or to split the computation of some heavy algorithm over multiple frames (and, therefore, not incur in frame drops). Coroutines, it turns out, are a pretty helpful <a id="_idIndexMarker280"/>tool to master. You can read more at <a href="https://docs.unity3d.com/Manual/Coroutines.html">https://docs.unity3d.com/Manual/Coroutines.html</a>.</p>
			<p>Now, we can implement <a id="_idIndexMarker281"/>the <code>UpdateRandom</code> coroutine. As a coroutine, the function never actually terminates, but we run the body of the <code>while</code> loop for each random time interval:</p>
			<ol>
				<li value="1">We define the <code>UpdateRandom</code> method as a coroutine by specifying the <code>IEnumerator</code> r<a id="_idTextAnchor350"/><a id="_idTextAnchor351"/>eturn type: <pre>IEnumerator UpdateRandom() { 
    while (true) {
        randomPush = 
          Random.insideUnitSphere * randomForce;
        yield return new WaitForSeconds(
          randomFreqInterval + Random.Range(
            -randomFreqInterval / 2.0f, 
            randomFreqInterval / 2.0f));
    }
}</pre></li>
				<li>The <code>UpdateRandom()</code> method updates the <code>randomPush</code> value throughout the game with an interval based on <code>randomFreq</code>. <code>Random.insideUnitSphere</code> returns a <code>Vector3</code> object with random <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> values within a sphere, with a radius of the <code>randomForce</code> value.</li>
				<li>We wait <a id="_idIndexMarker282"/>for a certain random amount of time before resuming <code>while(true)</code>.</li>
				<li>Loop to update the <code>randomPush</code> value again.</li>
				<li>Now, here is our boid behavior's <code>Update()</code> method, which helps the boid entity comply with the three rules of the flocking algorithm:<pre>void Update() {
        //Internal variables
        float speed = velocity.magnitude;
        Vector3 avgVelocity = Vector3.zero;
        Vector3 avgPosition = Vector3.zero;
        int count = 0;
        Vector3 myPosition = 
          transformComponent.position;
        Vector3 forceV;
        Vector3 toAvg;
        for (int i = 0; i &lt; objects.Length; i++) {
            Transform boidTransform = objects[i];
            if (boidTransform != transformComponent) {
                Vector3 otherPosition =
                  boidTransform.position;
                // Average position to calculate 
                // cohesion
                avgPosition += otherPosition;
                count++;
                //Directional vector from other flock
                // to this flock
                forceV = myPosition - otherPosition;
                //Magnitude of that directional 
                //vector(Length)
                float directionMagnitude = 
                  forceV.magnitude;
                float forceMagnitude = 0.0f;
                if (directionMagnitude &lt; followRadius)
                {
                    if (directionMagnitude &lt;
                         avoidanceRadius) {
                        forceMagnitude = 1.0f – 
                          (directionMagnitude / 
                           avoidanceRadius);
                        if (directionMagnitude &gt; 0)
                            avgVelocity += (forceV /
                              directionMagnitude) *
                              forceMagnitude * 
                              avoidanceForce;
                    }
                    forceMagnitude =
                      directionMagnitude / 
                      followRadius;
                    UnityFlock tempOtherBoid = 
                      otherFlocks[i];
                    avgVelocity += followVelocity *
                      forceMagnitude * 
                     tempOtherBoid.normalizedVelocity;
                }
            }
        }</pre></li>
			</ol>
			<p>The preceding code implements the separation rule. First, we check the distance between the current boid and the other boids, and then we update the velocity accordingly, as explained in the comments in the preceding code block.</p>
			<ol>
				<li value="6">We now calculate <a id="_idIndexMarker283"/>the average velocity vector of the flock by dividing the current velocity vector by the number of boids in the flock:<pre>        if (count &gt; 0) {
            //Calculate the average flock
           //velocity(Alignment)
            avgVelocity /= count;
            //Calculate Center value of the 
            //flock(Cohesion)
            toAvg = (avgPosition / count) –
              myPosition;
        } else {
            toAvg = Vector3.zero;
        }
        //Directional Vector to the leader
        forceV = origin.position - myPosition;
        float leaderDirectionMagnitude = 
          forceV.magnitude;
        float leaderForceMagnitude =
          leaderDirectionMagnitude / toOriginRange;
        //Calculate the velocity of the flock to the
        //leader
        if (leaderDirectionMagnitude &gt; 0)
            originPush = leaderForceMagnitude * 
              toOriginForce * (forceV /
              leaderDirectionMagnitude);
        if (speed &lt; minSpeed &amp;&amp; speed &gt; 0) {
            velocity = (velocity / speed) * minSpeed;
        }
        Vector3 wantedVel = velocity;
        //Calculate final velocity
        wantedVel -= wantedVel * Time.deltaTime;
        wantedVel += randomPush * Time.deltaTime;
        wantedVel += originPush * Time.deltaTime;
        wantedVel += avgVelocity * Time.deltaTime;
        wantedVel += gravity * Time.deltaTime * 
          toAvg.normalized;
        velocity = Vector3.RotateTowards(velocity,
          wantedVel, turnSpeed * Time.deltaTime, 
          100.00f);
        transformComponent.rotation =
          Quaternion.LookRotation(velocity);
        //Move the flock based on the calculated
        //velocity
        transformComponent.Translate(velocity * 
          Time.deltaTime, Space.World);
        normalizedVelocity = velocity.normalized;
    }</pre></li>
				<li>We add up <a id="_idIndexMarker284"/>all the factors, such as <code>randomPush</code>, <code>originPush</code>, and <code>avgVelocity</code>, to calculate the final target velocity vector, <code>wantedVel</code>. We also update the current velocity to <code>wantedVel</code> with a linear interpolation by using the <code>Vector3.RotateTowards</code> method.</li>
				<li>We move our boid based on the new velocity using the <code>Translate</code> method.</li>
				<li>As a final touch, we create a cube mesh, to which we add the <code>UnityFlock</code> script, and then save it as a prefab, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B17984_05_2.jpg" alt="Figure 5.2 – The UnityFlock prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – The Uni<a id="_idTextAnchor352"/><a id="_idTextAnchor353"/><a id="_idTextAnchor354"/><a id="_idTextAnchor355"/>tyFlock prefab</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor356"/>Controller</h2>
			<p>Now, it is time <a id="_idIndexMarker285"/>to create the controller class. This class updates its position so that the other individual boid objects know where to go. The <code>origin</code> variable in the preceding <code>UnityFlock</code> script contains a reference to this object.</p>
			<p>The following is the code in the <code>UnityFlockController.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
public class UnityFlockController : MonoBehaviour { 
    public Vector3 bound;
    public float speed = 100.0f;
    public float targetReachedRadius = 10.0f;
    private Vector3 initialPosition;
    private Vector3 nextMovementPoint;
    // Use this for initialization 
    void Start () {
        initialPosition = transform.position;
        CalculateNextMovementPoint();
    }
    // Update is called once per frame 
    void Update () {
        transform.Translate(Vector3.forward * speed * 
          Time.deltaTime);
        transform.rotation = 
          Quaternion.Slerp(transform.rotation,
            Quaternion.LookRotation(nextMovementPoint –
            transform.position), 1.0f * Time.deltaTime);
        if (Vector3.Distance(nextMovementPoint, 
            transform.position) &lt;= targetReachedRadius) 
            CalculateNextMovementPoint();
    }</pre>
			<p>In the <code>Update()</code> method, we check whether our controller object is near the target destination <a id="_idIndexMarker286"/>point. If it is, we update the <code>nextMovementPoint</code> variable again with the <code>CalculateNextMovementPoint()</code> method that we just discussed:</p>
			<pre>void CalculateNextMovementPoint () {
    float posX = Random.Range(initialPosition.x - bound.x,
      initialPosition.x + bound.x);
    float posY = Random.Range(initialPosition.y - bound.y, 
      initialPosition.y + bound.y);
    float posZ = Random.Range(initialPosition.z - bound.z,
      initialPosition.z + bound.z);
    nextMovementPoint = initialPosition + new Vector3(posX,
      posY, posZ);
}</pre>
			<p>The <code>CalculateNextMovementPoint()</code> method finds the next random destination position in a range between the current position and the boundary vectors.</p>
			<p>Finally, we put all of this together, as shown in <em class="italic">Figure 5.1</em>, which should give you flocks of squares flying around realistically in the sunset:</p>
			<div><div><img src="img/B17984_05_3.jpg" alt="Figure 5.3 – A demonstration of the ﬂocking behavior using the Unity seagull sample&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – A demonstration of the ﬂocking behavior using the Unity seagull sample</p>
			<p>The previous <a id="_idIndexMarker287"/>example gave you the basics of flocking behaviors. In the next section, we will explore a different implementation that makes use of Unity's <code>Rigi<a id="_idTextAnchor357"/><a id="_idTextAnchor358"/><a id="_idTextAnchor359"/><a id="_idTextAnchor360"/>dbody</code> component.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor361"/>Alternative implementation</h1>
			<p>In this section, we use the Unity physics engine to simplify the code a bit. In fact, in this example, we <a id="_idIndexMarker288"/>attach a <code>Rigidbody</code> component to the boids to use the <code>Rigidbody</code> properties to translate and steer them. In addition, the <code>Rigidbody</code> component is also helpful in preventing the other boids from overlapping with each other.</p>
			<p>In this implementation, we have two components: the individual boid behavior and the controller behavior (the element referred to as the <em class="italic">flock controller</em> in the previous section). As before, the controller is the object that the rest of the boids follow.</p>
			<p>The code in the <code>Flock.cs</code> file is as follows:</p>
			<pre>using UnityEngine;
using System.Collections;
using System.Collections.Generic;
public class Flock : MonoBehaviour { 
    internal FlockController controller;
    private new Rigidbody rigidbody;
    private void Start() {
        rigidbody = GetComponent&lt;Rigidbody&gt;();
    }
    void Update () {
        if (controller) {
            Vector3 relativePos = Steer() * Time.deltaTime;
            if (relativePos != Vector3.zero)
              rigidbody.velocity = relativePos;
            // enforce minimum and maximum speeds for the
            // boids 
            float speed = rigidbody.velocity.magnitude;
            if (speed &gt; controller.maxVelocity) {
                rigidbody.velocity =
                  rigidbody.velocity.normalized *
                  controller.maxVelocity;
            } else if (speed &lt; controller.minVelocity) {
                rigidbody.velocity =
                  rigidbody.velocity.normalized *
                  controller.minVelocity;
            }
        }
    }</pre>
			<p>We will create <code>FlockController</code> in a moment. In the meantime, in the <code>Update()</code> method in the previous code block, we calculate the boid's velocity using the <code>Steer()</code> method and apply the <a id="_idIndexMarker289"/>result to the boid's rigid-body velocity.</p>
			<p>Next, we check whether the current speed of the <code>Rigidbody</code> component falls inside our controller's maximum and minimum velocity ranges. If not, we cap the velocity at the preset range:</p>
			<pre>private Vector3 Steer () {
    Vector3 center = controller.flockCenter – 
      transform.localPosition;   // cohesion
    Vector3 velocity = controller.flockVelocity –
      rigidbody.velocity; // allignement
    Vector3 follow = controller.target.localPosition – 
      transform.localPosition; // follow leader
    Vector3 separation = Vector3.zero;
    foreach (Flock flock in controller.flockList) { 
        if (flock != this) {
            Vector3 relativePos = transform.localPosition - 
              flock.transform.localPosition;
            separation += relativePos.normalized;
        }
    }
    // randomize
    Vector3 randomize = new Vector3( (Random.value * 2) –
      1, (Random.value * 2) - 1, (Random.value * 2) - 1);
    randomize.Normalize();
    return (controller.centerWeight * center + 
            controller.velocityWeight * velocity + 
            controller.separationWeight * separation +
            controller.followWeight * follow + 
            controller.randomizeWeight * randomize);
}</pre>
			<p>The <code>steer()</code> method <a id="_idIndexMarker290"/>implements the <em class="italic">separation</em>, <em class="italic">cohesion</em>, <em class="italic">alignment</em>, and <em class="italic">follows the leader</em> rules of the flocking algorithm. Then, we add up all the factors with a random weight value. We use this <em class="italic">Flock</em> script together with the <code>Rigidbody</code> and <code>SphereCollider</code> components to create a Flock prefab, as shown in the following screenshot (make sure to disable the gravity by unchecking <strong class="bold">Use Gravity</strong>):</p>
			<div><div><img src="img/B17984_05_4.jpg" alt="Figure 5.4 – Flock&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Flock</p>
			<p>It is now <a id="_idIndexMarker291"/>time to implement the final piece of the puzzle: the <code>FlockCo<a id="_idTextAnchor362"/><a id="_idTextAnchor363"/><a id="_idTextAnchor364"/><a id="_idTextAnchor365"/>ntroller</code> component.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor366"/>FlockController</h2>
			<p>This <code>FlockController</code> component <a id="_idIndexMarker292"/>is similar to the one in the previous example. In addition to controlling the flock's speed and position, this script also instantiates the boids at runtime:</p>
			<ol>
				<li value="1">The code in the <code>FlockController.cs</code> file is as follows:<pre>using UnityEngine;
using System.Collections;
using System.Collections.Generic;
public class FlockController : MonoBehaviour { 
    public float minVelocity = 1;
    public float maxVelocity = 8;
    public int flockSize = 20;
    public float centerWeight = 1;
    public float velocityWeight = 1;
    public float separationWeight = 1;
    public float followWeight = 1;
    public float randomizeWeight = 1;
    public Flock prefab; 
    public Transform target;
    Vector3 flockCenter;
    internal Vector3 flockVelocity;
    public ArrayList flockList = new ArrayList();
    void Start () {
        for (int i = 0; i &lt; flockSize; i++) {
            Flock flock = Instantiate(prefab,
              transform.position, transform.rotation)
              as Flock;
            flock.transform.parent = transform;
            flock.controller = this;
            flockList.Add(flock);
        }
    }</pre></li>
				<li>We declare all the public properties to implement the flocking algorithm and then start generating the boid objects based on the flock size input.</li>
				<li>We set <a id="_idIndexMarker293"/>up the controller class and the parent <code>Transform</code> object, as we did last time.</li>
				<li>We add every boid object we create to the <code>flockList</code> array. The target variable accepts an entity to be used as a moving leader. In this example, we create a sphere entity as a moving target leader for our flock:<pre>  <a id="_idTextAnchor367"/><a id="_idTextAnchor368"/>  void Update() {
        //Calculate the Center and Velocity of the
        // whole flock group
        Vector3 center = Vector3.zero;
        Vector3 velocity = Vector3.zero;
        foreach (Flock flock in flockList) {
                center += 
                  flock.transform.localPosition;
                velocity += flock.GetComponent
                  &lt;Rigidbody&gt;().velocity;
        }
        flockCenter = center / flockSize;
        flockVelocity = velocity / flockSize;
    }
}</pre></li>
				<li>In the <code>Update</code> method, we <a id="_idIndexMarker294"/>keep updating the average center and velocity of the flock. These are the values referenced from the boid object and are used to adjust the cohesion and alignment properties with the controller:</li>
			</ol>
			<div><div><img src="img/B17984_05_5.jpg" alt="Figure 5.5 – Flock Controller&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Flock Controller</p>
			<p>We need <a id="_idIndexMarker295"/>to implement our <strong class="bold">Target</strong> entity with the <strong class="bold">Target Movement (Script)</strong>. The movement script is the same as what we saw in our previous Unity3D sample controller's movement script:</p>
			<div><div><img src="img/B17984_05_6.jpg" alt="Figure 5.6 – The Target entity with the TargetMovement script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – The Target entity with the TargetMovement script</p>
			<ol>
				<li value="6">Here is how our <code>TargetMovement</code> script works: we pick a random point nearby for the <a id="_idIndexMarker296"/>target to move to, and when we get close to that point, we pick a new one. The code in the <code>TargetMovement.cs</code> file is as follows:<pre>using UnityEngine;
using System.Collections;
public class TargetMovement : MonoBehaviour {
    // Move target around circle with tangential speed
    public Vector3 bound;
    public float speed = 10<a id="_idTextAnchor369"/><a id="_idTextAnchor370"/>0.0f;
    public float targetReachRadius = 10.0f;
    private Vector3 initialPosition;
    private Vector3 nextMovementPoint;
    void Start () {
        initialPosition = transform.position;
        CalculateNextMovementPoint();
    }
    void CalculateNextMovementPoint () {
        float posX = Random.Range(initialPosition.x =
          bound.x, initialPosition.x+bound.x);
        float posY = Random.Range(initialPosition.y = 
          bound.y, initialPosition.y+bound.y);
        float posZ = Random.Range(initialPosition.z =
          bound.z, initialPosition.z+bound.z);
        nextMovementPoint = initialPosition + 
          new Vector3(posX, posY, posZ);
    }
    void Update () {
        transform.Translate(Vector3.forward * speed *
          Time.deltaTime); 
        transform.rotation = 
          Quaternion.Slerp(transform.rotation,
        Quaternion.LookRotation(nextMovementPoint –
          transform.position), Time.deltaTime);
        if (Vector3.Distance(nextMovementPoint,
          transform.position) &lt;= targetReachRadius)
          CalculateNextMovementPoint();
    }
}</pre></li>
				<li>After we <a id="_idIndexMarker297"/>put everything together, we should see a nice flock of cubic boids flying around in the scene, all chasing the spheric target:</li>
			</ol>
			<div><div><img src="img/B17984_05_7.jpg" alt="Figure 5.7 – Flocking with Craig Reynold's algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Flocking with Craig Reynold's algorithm</p>
			<p>Now that <a id="_idIndexMarker298"/>we have implemented flocking behavior in two different ways, we can experiment with different parameters and tweak the boids' behavior until we find a movement we like. I want to conclude this chapter with an important takeaway: note that we do not need complex algorithms to have a natural-looking behavior. For that, we just need simple reactive rules and<a id="_idTextAnchor371"/><a id="_idTextAnchor372"/> a way to combine them.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor373"/>Summary</h1>
			<p>In this chapter, we learned how to implement flocking behaviors in two ways. First, we examined and learned how to implement a basic flocking algorithm using nothing other than our scripts. Next, we implemented the same algorithm using Unity's <code>Rigidbody</code> component to control the boid's movement and Sphere Collider to avoid collision with other boids.</p>
			<p>In our example, we always referred to boids as bird-like entities. However, we can use flocking for many other applications: fishes swimming in the sea, sheep grazing on a plane, a swarm of insects, and even groups of people walking on the street can show flocking behavior. To adapt the algorithm to different scenarios, we just need to change the flocking rules' values and eventually lock the movement to a plane.</p>
			<p>In the next chapter, we will go beyond random movement and look at how to follow a specific path. This is the first step toward learning how to avoid obstacles that are in your way.</p>
		</div>
	</body></html>