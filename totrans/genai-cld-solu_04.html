<html><head></head><body>
		<div><h1 id="_idParaDest-70" class="chapter-number"><a id="_idTextAnchor070"/>4</h1>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>RAGs to Riches: Elevating AI with External Data</h1>
			<p>LLMs such as GPT have certain limitations. They may not have up-to-date information due to their knowledge cutoff date for training. This poses a significant challenge when we want our AI models to provide accurate, context-aware, and timely responses. Imagine asking an LLM a question about the latest technology trends or seeking real-time updates on a breaking news event; traditional language models might fall short in these scenarios.</p>
			<p>In this chapter, we’re going to introduce you to a game-changing technique called <strong class="bold">retrieval-augmented generation</strong> (<strong class="bold">RAG</strong>), an <a id="_idIndexMarker359"/>outcome of the work carried out by researchers at Facebook AI (now Meta). It’s the secret sauce that empowers language models such as GPT to bridge the gap between their static knowledge and the dynamic real world. With RAG, we’ll show you how to equip your generative AI applications with the ability to pull in fresh information, ground your organizational data, cross-reference facts to address hallucinations, and stay contextually aware, all in real time. We will also discuss the fundaments of vector databases, a new, hot, and emerging database that is designed for storing, indexing, and querying vectors that represent highly dimensional data; they are typically used for similarity search and machine learning applications and are important in building RAG applications.</p>
			<p>Let’s understand how RAG can turn your language model into an information-savvy conversational assistant, ensuring that it’s always in the know, no matter when you ask the question.</p>
			<p>We will cover the following main topics in the chapter:</p>
			<ul>
				<li>A deep dive into vector DB essentials</li>
				<li>Vector stores</li>
				<li>The role of vector DBs in retrieval-augmented generation (RAG)</li>
				<li>Chunking strategies</li>
				<li>Evaluation of RAG using Azure Prompt Flow</li>
				<li>Case study – Global chat application deployment by a multinational organization</li>
			</ul>
			<div><div><img src="img/B21443_04_1.jpg" alt="Figure 4.1 – Benefits of RAG"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Benefits of RAG</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>A deep dive into vector DB essentials</h1>
			<p>To fully <a id="_idIndexMarker360"/>comprehend RAG, it’s imperative to understand vector DBs because RAG relies heavily on its efficient data retrieval for query resolution. A vector DB is a database designed to store and efficiently query highly dimensional vectors and is often used in similarity searches and machine learning tasks. The design and mechanics of vector DBs directly influence the effectiveness and accuracy of RAG answers.</p>
			<p>In this section, we will cover the fundamental components of vector DBs (vectors and vector embeddings), and in the next section, we will dive deeper into the important characteristics of <a id="_idIndexMarker361"/>vector DBs that enable a RAG-based generative AI solution. We will also explain how it differs from regular databases and then tie it all back to explain RAG.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Vectors and vector embeddings</h2>
			<p>A vector<a id="_idIndexMarker362"/> is a mathematical object that has both magnitude and direction and can be represented by an ordered list of numbers. In a more general sense, especially in computer science and machine learning, a vector can be thought of as an array or list of numbers that represents a point in a certain dimensional space. For instances depicted in the following image, in 2D space (on the left), a vector might be represented as [x, y], whereas in 3D space (on the right), it might be [x, y, z]:</p>
			<div><div><img src="img/B21443_04_2.jpg" alt="Figure 4.2 – Representation of vectors in 2D and 3D space"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Representation of vectors in 2D and 3D space</p>
			<p>Vector embedding<a id="_idIndexMarker363"/> refers to the representation of objects, such as words, sentences, or even entire documents, as vectors in a highly dimensional space. A highly dimensional space denotes a mathematical space with more than three dimensions, frequently used in data analysis and machine learning to represent intricate data structures. Think of it as a room where you can move in more than three directions, facilitating the description and analysis of complex data. The embedding process converts words, sentences, or documents into vector representations, capturing the intricate semantic relationships between them. Hence, words with similar meanings tend to be close to each other in the highly dimensional space. Now, you must be wondering how this plays a role in designing generative AI solutions consisting of LLMs. Vector embeddings <a id="_idIndexMarker364"/>provide the foundational representation of data. They are a standardized numerical representation for diverse types of data, which LLMs use to process and generate information. Such an embedding process to convert words and sentences to a numerical representation is initiated by embedding models such as OpenAI’s text-embedding-ada-002. Let’s explain this with an example.</p>
			<p>The following image <a id="_idIndexMarker365"/>visually represents the clustering of mammals and birds in a two-dimensional vector embedding space, differentiating between their realistic and cartoonish portrayals. This image depicts a spectrum between “REALISTIC” and “CARTOON” representations, further categorized into “MAMMAL” and “BIRD.” On the realistic side, there’s a depiction of a mammal (elk) and three birds (an owl, an eagle, and a small bird). On the cartoon side, there are stylized and whimsical cartoon versions of mammals and birds, including a comically depicted deer, an owl, and an exaggerated bird character. LLMs use such vector embedding spaces, which are numerical representations of objects in highly dimensional spaces, to understand, process, and generate information. For example, imagine an educational application designed to teach children about wildlife. If a student prompts the chatbot to provide images of birds in a cartoon representation, the LLM will search and generate information from the bottom right quadrant:</p>
			<div><div><img src="img/B21443_04_3.jpg" alt="Figure 4.3 – Location of animals with similar characteristics in a highly dimensional space, demonstrating “relatedness”"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Location of animals with similar characteristics in a highly dimensional space, demonstrating “relatedness”</p>
			<p>Now, let’s delve into the<a id="_idIndexMarker366"/> evolution of embedding models that produce embeddings, a.k.a numerical representations of objects, within highly dimensional spaces. Embedding models have experienced significant evolution, transitioning from the initial methods that mapped discrete words to dense vectors, such as word-to-vector (Word2Vec), global vectors for word representation (GloVe), and FastText to more sophisticated contextual embeddings using deep learning architectures. These newer models, such as embeddings from language models (ELMos), utilize long short-term memory (LSTM)-based structures to offer context-specific representations. The newer transformer architecture-based embedding models, which underpin models such as bidirectional encoder representations from transformers (BERT), generative pre-trained transformer (GPT), and their subsequent iterations, marked a revolutionary leap over predecessor models.</p>
			<p>These models capture contextual information in unparalleled depth, enabling embeddings to represent nuances in word meanings based on the surrounding context, thereby setting new standards in various natural language processing tasks.</p>
			<p class="callout-heading">Important note:</p>
			<p class="callout">In Jan 2024, OpenAI <a id="_idIndexMarker367"/>announced two third-generation embedding models, <strong class="bold">text-embedding-3-small </strong>and <strong class="bold">text-embedding-3-large</strong>, which are the newest models that have better<a id="_idIndexMarker368"/> performance, lower costs, and better multi-lingual retrieval and parameters to reduce the overall size of dimensions when compared to predecessor second-generation model, <strong class="bold">text-embedding-ada-002</strong>. Another <a id="_idIndexMarker369"/>key difference is the number of dimensions between the two generations. The third-generation models come in different dimensions, and the highest they can go up to is 3,072. As of Jan 2024, we have seen more production workloads using text-embedding-ada-002 in production, which has 1,536 dimensions. OpenAI recommends using the third-generation models going forward for improved performance and reduced costs.</p>
			<p>We also wanted you to know that while OpenAI’s embedding model is one of the most popular choices when it comes to text embeddings, you can find the list of leading embedding models on Hugging Face (<a href="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a>).</p>
			<p>The following snippet of code gives an example of generating Azure OpenAI endpoints:</p>
			<pre class="source-code">
import openai
openai.api_type = "azure"
openai.api_key = YOUR_API_KEY
openai.api_base = "https://YOUR_RESOURCE_NAME.openai.azure.com"
openai.api_version = "YYYY-MM-DD"  ##Replace with latest version
response = openai.Embedding.create (
    input="Your text string goes here",
    engine="YOUR_DEPLOYMENT_NAME"
)
embeddings = response['data'][0]['embedding']
print(embeddings)</pre>			<p>In this section, we highlighted the significance of vector embeddings. However, their true value emerges when used effectively. Hence, we’ll now dive deep into indexing and vector search strategies, which are crucial for optimal data retrieval in the RAG workflow.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Vector search strategies</h2>
			<p>Vector search strategies are <a id="_idIndexMarker370"/>crucial because they determine how efficiently and accurately highly dimensional data (such as embeddings) can be queried and retrieved. Optimal strategies ensure that the most relevant and contextually appropriate results are returned. In vector-based searching, there<a id="_idIndexMarker371"/> are primarily two main <a id="_idIndexMarker372"/>strategies: <strong class="bold">exact search</strong> and <strong class="bold">approximate search</strong>.</p>
			<h3>Exact search</h3>
			<p>The exact search method, as the <a id="_idIndexMarker373"/>term suggests, directly matches a query vector with vectors in the database. It uses an exhaustive approach to identify the closest neighbors, allowing minimal to no errors.</p>
			<p>This is typically what the traditional KNN method employs. Traditional KNNs utilize brute force methods to find the K-nearest neighbors, which demands a thorough comparison of the input vector with every other vector in the dataset. Although computing the similarity for each vector is typically quick, the process becomes time-consuming and resource-intensive over extensive datasets because of the vast number of required comparisons. For instance, if you had a dataset of one million vectors and wanted to find the nearest neighbors for a single input vector, the traditional KNN would require one million distance computations. This can be thought of as looking up a friend’s phone number in a phone book by checking each entry one by one rather than using a more efficient search strategy that speeds up the process, which we will discuss in the next section.</p>
			<h3>Approximate nearest neighbors (ANNs)</h3>
			<p>In modern vector DBs, the <a id="_idIndexMarker374"/>search strategy known as<a id="_idIndexMarker375"/> ANN stands out as a powerful technique that quickly finds the near-closest data points in highly dimensional spaces, potentially trading off a bit of accuracy for speed. Unlike KNN, ANN prioritizes search speed at the expense of slight accuracy. Additionally, for it to function effectively, a vector index must be built beforehand.</p>
			<h4>The process of vector indexing</h4>
			<p>The process of vector indexing <a id="_idIndexMarker376"/>involves the organization of embeddings in a data structure called an index, which can be traversed quickly for retrieval purposes. Many ANN algorithms aid in forming a vector index, all aiming for rapid querying by creating an efficiently traversable data structure. Typically, they compress the original vector representation to enhance the search process.</p>
			<p>There are numerous <a id="_idIndexMarker377"/>indexing algorithms, and this is an active research area. ANNs <a id="_idIndexMarker378"/>can be <a id="_idIndexMarker379"/>broadly <a id="_idIndexMarker380"/>classified into <strong class="bold">tree-based indexes</strong>, <strong class="bold">graph-based indexes</strong>, <strong class="bold">hash-based indexes</strong>, and <strong class="bold">quantization-based indexes</strong>. In this section, we will cover the two most popular indexing algorithms. When creating an LLM application, you don’t need to dive deep into the indexing process since many vector databases provide this as a service to you. But it’s important to choose the right type of index for your specific needs to ensure efficient data retrieval:</p>
			<ul>
				<li><strong class="bold">Hierarchical navigable small world</strong> (<strong class="bold">HNSW</strong>): This is a method for approximate similarity search in<a id="_idIndexMarker381"/> highly dimensional spaces. HNSW is a graph-based index that works by creating a hierarchical graph structure, where each node represents a data point, and the edges connect similar data points. This hierarchical structure allows for efficient search operations, as it narrows down the search space quickly. HNSW is well suited for similarity search use cases, such as content-based recommendation systems and text search.<p class="list-inset">If you wish to dive deeper into its workings, we recommend checking out this research paper: <a href="https://arxiv.org/abs/1603.09320">https://arxiv.org/abs/1603.09320</a>.</p><p class="list-inset">The following image is a<a id="_idIndexMarker382"/> representation of the HNSW index:</p></li>
			</ul>
			<div><div><img src="img/B21443_04_4.jpg" alt="Figure 4.4 – Representation of HNSW index"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Representation of HNSW index</p>
			<p class="list-inset">The image illustrates the HNSW graph structure used for efficient similarity searches. The graph is constructed in layers, with decreasing density from the bottom to the top. Each layer’s characteristic radius reduces as we ascend, creating sparser connections. The depicted search path, using the red dotted lines, showcases the algorithm’s strategy; it starts from the sparsest top layer, quickly navigating vast data regions, and then refines its search in the denser lower layers, minimizing the overall comparisons and enhancing search efficiency.</p>
			<ul>
				<li><strong class="bold">Facebook AI Similarity Search</strong> (<strong class="bold">FAISS</strong>): FAISS, developed by Facebook AI Research, is a <a id="_idIndexMarker383"/>library designed for the efficient similarity search and clustering of highly dimensional vectors. It uses product quantization to compress data during indexing, accelerating similarity searches in vast datasets. This method divides the vector space into regions known as Voronoi cells, each symbolized by a centroid. The primary purpose is to minimize storage needs and expedite searches, though it may slightly compromise accuracy. To visualize this, consider the following image. The Voronoi cells denote regions from quantization, and the labeled points within these cells are the centroids or representative vectors. When indexing a new vector, it’s aligned with its closest centroid. For searches, FAISS pinpoints the probable Voronoi cell containing the nearest neighbors and then narrows down the search within that cell, significantly cutting down distance calculations:</li>
			</ul>
			<div><div><img src="img/B21443_04_5.jpg" alt="Figure 4.5 – Representation of FAISS index"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Representation of FAISS index</p>
			<p>It excels in applications such as image and video search, recommendation systems, and any task that involves searching for nearest neighbors in highly dimensional spaces because of its performance optimizations and built-in GPU optimization.</p>
			<p>In this section, we covered indexing and the role of ANNs in index creation. Next, we’ll explore similarity measures, how they differ from indexing, and their impact on improving data retrieval.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>When to Use HNSW vs. FAISS</h2>
			<h3>Use HNSW when:</h3>
			<ul>
				<li>High<a id="_idIndexMarker384"/> precision in similarity search is crucial.</li>
				<li>The dataset size is large but not at the scale where managing it becomes impractical for HNSW.</li>
				<li>Real-time or near-real-time search performance is required.</li>
				<li>The dataset is dynamic, with frequent updates or insertions.</li>
				<li>Apt for use cases involving text like article recommendation systems</li>
			</ul>
			<h3>Use FAISS when:</h3>
			<ul>
				<li>Managing<a id="_idIndexMarker385"/> extremely large datasets (e.g., billions of vectors).</li>
				<li>Batch processing and GPU optimization can significantly benefit the application.</li>
				<li>There’s a need for flexible trade-offs between search speed and accuracy.</li>
				<li>The dataset is relatively static, or batch updates are acceptable.</li>
				<li>Apt for use cases like image and video search.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Choosing the right indexing strategy hinges on several critical factors, including the nature and structure of the data, the types of queries (e.g. range queries, nearest neighbors, exact search) to be supported, and the volume and growth of the data. Additionally, the frequency of data updates (e.g., static vs dynamic) the dimensionality of the data, performance requirements (real-time, batch), and resource constraints play significant roles in the decision-making process.</p>
			<h3>Similarity measures</h3>
			<p>Similarity measures<a id="_idIndexMarker386"/> dictate how the index is organized, and this makes sure that the retrieved data are highly relevant to the query. For instance, in a system designed to retrieve similar images, the index might be built around the feature vectors of images, and the similarity measure would determine which images are “close” or “far” within that indexed space. The importance of these concepts is two-fold: indexing significantly speeds up data retrieval, and similarity measures ensure that the retrieved data is relevant to the query, together enhancing the efficiency and efficacy of data retrieval systems. Selecting an appropriate distance metric greatly enhances the performance of classification and clustering tasks. The optimal similarity measure is chosen based on the nature of the data input. In other words, similarity measures define how closely two items or data points are related. They can be broadly classified<a id="_idIndexMarker387"/> into <strong class="bold">distance metrics</strong> and <strong class="bold">similarity metrics</strong>. Next, we’ll explore the three top similarity metrics for<a id="_idIndexMarker388"/> building AI applications: cosine similarity and Euclidean and Manhattan distance.</p>
			<ul>
				<li><strong class="bold">Similarity metrics – Cosine similarity</strong>: Cosine similarity, a type of similarity metric, calculates the cosine value of the angle <a id="_idIndexMarker389"/>between two vectors, and OpenAI suggests using it for its models to measure the distance between two embeddings obtained from text-embedding-ada-002. The higher the metric, the more similar they are:</li>
			</ul>
			<div><div><img src="img/B21443_04_6.jpg" alt="Figure 4.6 – Illustration of relatedness through cosine similarity between two words"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Illustration of relatedness through cosine similarity between two words</p>
			<p class="list-inset">The preceding<a id="_idIndexMarker390"/> image shows a situation where the cosine similarity is 1 for India and the USA because they are related, as both are countries. In the other image, the similarity is 0 because football is not similar to a lion.</p>
			<ul>
				<li><strong class="bold">Distance metrics – Euclidean (L2)</strong>: Euclidean distance<a id="_idIndexMarker391"/> computes the straight-line distance between two points in Euclidean space. The higher the metric, the less similar the two points are:</li>
			</ul>
			<div><div><img src="img/B21443_04_7.jpg" alt="Figure 4.7 – Illustration of Euclidean distance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Illustration of Euclidean distance</p>
			<p class="list-inset">The image illustrates the <a id="_idIndexMarker392"/>Euclidean distance formula in a 2D space. It shows two points: (x1,y1) and (x2,y2). The preceding formula calculates the straight-line distance between the two points in a plane.</p>
			<ul>
				<li><strong class="bold">Distance metrics – Manhattan (L1)</strong>: Manhattan distance<a id="_idIndexMarker393"/> calculates the sum of absolute differences along each dimension. The higher the metric, the less similar the differences. The following image depicts the Manhattan distance (or L1 distance) between two points in a 2D space, where the distance is measured along the axes at right angles, similar to navigating city blocks in a grid-like street layout:</li>
			</ul>
			<div><div><img src="img/B21443_04_8.jpg" alt="Figure 4.8 – Illustration of Manhattan distance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Illustration of Manhattan distance</p>
			<p>You might be wondering when to select one metric over another during the development of generative AI applications. The decision on which similarity measure to use hinges on various elements, such as the type of data, the context of the application, and the bespoke demands of the analysis results.</p>
			<p>Cosine similarity<a id="_idIndexMarker394"/> is preferred over <a id="_idIndexMarker395"/>Manhattan and Euclidean distances when the magnitude of the data vectors is less relevant than the direction or orientation of the data. In text analysis, for example, two documents might be represented by highly dimensional vectors of word frequencies. If one document is a longer version of the other, their word frequency vectors will point in the same direction, but the magnitude (length) of one vector will be larger due to the higher word count. Using Euclidean or Manhattan distance would highlight these differences in magnitude, suggesting the documents are different. However, using cosine similarity would capture their similarity in content (the direction of the vectors), de-emphasizing the differences in word count. In this context, cosine similarity is more appropriate, as it focuses on the angle between the vectors, reflecting the content overlap of the documents rather than their length or magnitude.</p>
			<p>Euclidean and Manhattan distances<a id="_idIndexMarker396"/> are more apt than cosine similarity when the magnitude and absolute differences between data vectors are crucial, such as with consistent scaled numerical data (e.g., age, height, weight, and so on) or in spatial applications such as grid-based pathfinding. While cosine similarity emphasizes the orientation or pattern of data vectors, which is especially useful in highly dimensional, sparse datasets, Euclidean and Manhattan distances capture the actual differences between data points, making them preferable in scenarios where absolute value deviations are significant such as when comparing the medical test results of patients or finding the distance between geographical co-ordinates on earth.</p>
			<p>The following is a snippet of code that uses Azure OpenAI endpoints to calculate the similarity between two sentences: “What number of countries do you know?” and “How many countries are you familiar with?” by using embedding model text-embedding-ada-002. It gives a score of 0.95:</p>
			<pre class="source-code">
import os
import openai
openai.api_type = "azure"
openai.api_base = "https://ak-deployment-3.openai.azure.com/"
openai.api_version = "2023-07-01-preview" 
##replace "2023-07-01-preview" with latest version
openai.api_key = "xxxxxxxxxxxxxxxxxxxxxxx"
def get_embedding(text, model="text-embedding-ada-002"):
    return openai.Embedding.create(engine=model, input=[text], \
        model=model)['data'][0]['embedding']
embedding1 = get_embedding("What number of countries do you know?", \
    model='text-embedding-ada-002')
embedding2 = get_embedding("How many countries are you familiar \
    with?", model='text-embedding-ada-002')
embedding1_np = np.array(embedding1)
embedding2_np = np.array(embedding2)
similarity = cosine_similarity([embedding1_np], [embedding2_np])
print(similarity)
# [[0.95523639]]</pre>			<p>Now let us walkthrough a scenario where Cosine Similarity will be preferred over Manhattan distance.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Recommendation System for Articles</h2>
			<p>Let's consider a scenario <a id="_idIndexMarker397"/> where a news aggregation platform aims to recommend articles similar to what a user is currently reading, enhancing user engagement by suggesting relevant content.</p>
			<h4>How It Works:</h4>
			<ul>
				<li><strong class="bold">Preprocessing and Indexing</strong>: Articles in the<a id="_idIndexMarker398"/> platform’s database are processed to extract textual features, often converted into high-dimensional vectors using LDA or transformer based embeddings like text-ada-embedding-002. These vectors are then indexed using HNSW, an algorithm suitable for high-dimensional spaces due to its hierarchical structure that facilitates efficient navigation and search.</li>
				<li><strong class="bold">Retrieval Time</strong>: When a user <a id="_idIndexMarker399"/>reads an article, the system generates a feature vector for this article and queries the HNSW index to find vectors (and thus articles) that are close in the high-dimensional space. Cosine similarity can be used to evaluate the similarity between the query article’s vector and those in the index, identifying <a id="_idIndexMarker400"/>articles with similar content.</li>
				<li><strong class="bold">Outcome</strong>: The <a id="_idIndexMarker401"/>system recommends a list of articles ranked by their relevance to the currently viewed article. Thanks to the efficient indexing and similarity search, these recommendations are generated quickly, even from a vast database of articles, providing the user with a seamless experience.</li>
			</ul>
			<p>Now let us walkthrough a scenario where Manhattan Distance will be preferred over Cosine Similarity.</p>
			<h4>Ride-Sharing App Matchmaking</h4>
			<p>Let's consider a scenario where a ride-sharing application needs to match passengers with nearby drivers efficiently. The system must quickly find the closest available drivers to a passenger’s location to minimize wait times and optimize routes.</p>
			<h3>How It Works:</h3>
			<ul>
				<li><strong class="bold">Preprocessing and Indexing</strong>: Drivers’ <a id="_idIndexMarker402"/>current locations are constantly being updated and stored as points in a 2D space representing a map. These points can be indexed using a tree based spatial indexing techniques or data structures optimized for geospatial data, such as R-trees.</li>
				<li><strong class="bold">Retrieval Time</strong>: When a passenger requests a ride, the application uses the passenger’s current location as a query <a id="_idIndexMarker403"/>point. Manhattan distance (L1 norm) is particularly suitable for urban environments, where movement is constrained by a grid-like structure of streets and avenues, mimicking the actual paths a car would take along city blocks.</li>
				<li><strong class="bold">Outcome</strong>: The system<a id="_idIndexMarker404"/> quickly identifies the nearest available drivers using the indexed data and Manhattan distance calculations, considering the urban grid’s constraints. This process ensures a swift matchmaking process, improving the user experience by reducing wait times.</li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Vector stores</h1>
			<p>As generative<a id="_idIndexMarker405"/> AI applications continue to push the boundaries of what’s possible in tech, vector stores have emerged as a crucial component, streamlining and optimizing the search and retrieval of relevant data. In our previous discussions, we’ve delved into the advantages of vector DBs over traditional databases, unraveling the concepts of vectors, embeddings, vector search strategies, approximate nearest neighbors (ANNs), and similarity measures. In this section, we aim to provide an integrative understanding of these concepts within the realm of vector DBs and libraries.</p>
			<p>The image illustrates a workflow for transforming different types of data—Audio, Text, and Videos—into vector embeddings.</p>
			<ul>
				<li><strong class="bold">Audio</strong>: An audio input is processed through an “Audio Embedding model,” resulting in “Audio vector embeddings.”</li>
				<li><strong class="bold">Text</strong>: Textual data undergoes processing in a “Text Embedding model,” leading to “Text vector embeddings.”</li>
				<li><strong class="bold">Videos</strong>: Video content is processed using a “Video Embedding model,” generating “Video vector embeddings.”</li>
			</ul>
			<p>Once these embeddings are created, they are subsequently utilized (potentially in an enterprise vector database system) to perform “Similarity Search” operations. This implies that the vector embeddings can be compared to find similarities, making them valuable for tasks such as content recommendations, data retrieval, and more.</p>
			<div><div><img src="img/B21443_04_9.jpg" alt="Figure 4.9 – Multimodal embeddings process in an AI application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Multimodal embeddings process in an AI application</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>What is a vector database?</h2>
			<p>A <strong class="bold">vector database</strong> (<strong class="bold">vector DB</strong>) is a <a id="_idIndexMarker406"/>specialized database designed to handle highly dimensional vectors primarily generated from embeddings of complex data types such as text, images, or audio. It provides capabilities to store and index unstructured data and enhance searches, as well as retrieval capabilities as a service.</p>
			<p>Modern vector databases that are brimming with advancements empower you to architect resilient enterprise solutions. Here, we list 15 key features to consider when choosing a vector DB. Every feature may not be important for your use case, but it might be a good place to start. Keep in mind that this area is changing fast, so there might be more features emerging in the future:</p>
			<ul>
				<li><strong class="bold">Indexing</strong>: As mentioned earlier, indexing<a id="_idIndexMarker407"/> refers to the process of organizing highly dimensional vectors in a way that allows for efficient similarity searches and retrievals. A vector DB offers built-in indexing features designed to arrange highly dimensional vectors for swift and effective similarity-based searches and retrievals. Previously, we discussed indexing algorithms such as FAISS and HNSW. Many vector DBs incorporate such features natively. For instance, Azure AI Search integrates the HNSW indexing service directly.</li>
				<li><strong class="bold">Search and retrieval</strong>: Instead of relying on exact matches, as traditional databases do, vector DBs provide <a id="_idIndexMarker408"/>vector search capabilities as a service, such as approximate nearest neighbors (ANNs), to quickly find vectors that are roughly the closest to a given input. To quantify the closeness or similarity between vectors, they utilize similarity measures such as cosine similarity or Euclidean distance, enabling efficient and nuanced similarity-based searches in large datasets.</li>
				<li><strong class="bold">Create, read, update, and delete</strong>: A vector DB manages highly dimensional vectors and offers create, read, update, and delete (CRUD) operations<a id="_idIndexMarker409"/> tailored to vectorized data. When vectors are created, they’re indexed for efficient retrieval. Reading often means performing similarity searches to retrieve vectors closest to a given query vector, typically using methods such as ANNs. Vectors can be updated, necessitating potential re-indexing, and they can also be deleted, with the database adjusting its internal structures accordingly to maintain efficiency and consistency.</li>
				<li><strong class="bold">Security</strong>: This meets GDPR, SOC2 Type II, and HIPAA rules to easily manage access to the console and use <a id="_idIndexMarker410"/>SSO. Data is encrypted when stored and in transit, which also provides more granular identity and access management features.</li>
				<li><strong class="bold">Serverless</strong>: A high-quality<a id="_idIndexMarker411"/> vector database is designed to gracefully autoscale with low management overhead as data volumes soar into millions or billions of entries, distributing seamlessly across several nodes. <strong class="bold">Optimal vector</strong> databases<a id="_idIndexMarker412"/> grant users the flexibility to adjust the system in response to shifts in data insertion, query frequencies, and underlying hardware configurations.</li>
				<li><strong class="bold">Hybrid search</strong>: Hybrid <a id="_idIndexMarker413"/>search combines traditional keyword-based search methods with other search mechanisms, such as semantic or contextual search, to retrieve results from both the exact term matches and by understanding the underlying intent or context of the query, ensuring a more comprehensive and relevant set of results.</li>
				<li><strong class="bold">Semantic re-ranking</strong>: This is a secondary ranking step to improve the relevance of search results. It<a id="_idIndexMarker414"/> re-ranks the search results that were initially scored by state-of-the-art ranking algorithms such as BM25 and RRF based on language understanding. For instance, Azure AI search employs secondary ranking that uses multi-lingual, deep learning models derived from Microsoft Bing to elevate the results that are most relevant in terms of meaning.</li>
				<li><strong class="bold">Auto vectorization/embedding</strong>: Auto-embedding in a vector database refers to the automatic process of <a id="_idIndexMarker415"/>converting data items into vector representations for efficient similarity searches and retrieval, with access to multiple embedding models.</li>
				<li><strong class="bold">Data replication</strong>: This ensures<a id="_idIndexMarker416"/> data availability, redundancy, and recovery in case of failures, safeguarding business continuity and reducing data loss risks.</li>
				<li><strong class="bold">Concurrent user access and data isolation</strong>: Vector databases support a large number of users <a id="_idIndexMarker417"/>concurrently and ensure robust data isolation to ensure updates remain private unless deliberately shared.</li>
				<li><strong class="bold">Auto-chunking</strong>: Auto-chunking <a id="_idIndexMarker418"/>is the automated process of dividing a larger set of data or content into smaller, manageable pieces or chunks for easier processing or understanding. This process helps preserve the semantic relevance of texts and addresses the token limitations of embedding models. We will learn more about chunking strategies in the upcoming sections in this chapter.</li>
				<li><strong class="bold">Extensive interaction tools</strong>: Prominent vector databases, such as Pinecone, offer versatile APIs and SDKs across <a id="_idIndexMarker419"/>languages, ensuring adaptability in integration and management.</li>
				<li><strong class="bold">Easy integration</strong>: Vector <a id="_idIndexMarker420"/>DBs provide seamless integration with LLM orchestration frameworks and SDKs, such as Langchain and Semantic Kernel, and leading cloud providers, such as Azure, GCP, and AWS.</li>
				<li><strong class="bold">User-friendly interface</strong>: This <a id="_idIndexMarker421"/>ensures an intuitive platform with simple navigation and direct feature access, streamlining the user experience.</li>
				<li><strong class="bold">Flexible pricing models</strong>: Provides flexible pricing models<a id="_idIndexMarker422"/> as per user needs to keep the costs low for the user.</li>
				<li><strong class="bold">Low downtime and high resiliency</strong>: Resiliency<a id="_idIndexMarker423"/> in a vector database (or any database) refers to its ability to recover quickly from failures, maintain data integrity, and ensure continuous availability even in the face of adverse conditions, such as hardware malfunctions, software bugs, or other unexpected disruptions.</li>
			</ul>
			<p>As of early 2024, a few prominent open source vector databases include Chroma, Milvus, Quadrant, and Weaviate, while Pinecone and Azure AI search are among the leading proprietary solutions.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Vector DB limitations</h2>
			<ul>
				<li><strong class="bold">Accuracy vs. speed trade-off</strong>: When <a id="_idIndexMarker424"/>dealing with highly dimensional data, vector DBs often face a trade-off between speed and accuracy for similarity searches. The core challenge stems from the computational expense of searching for the exact nearest neighbors in large datasets. To enhance search speed, techniques such as ANNs are employed, which quickly identify “close enough” vectors rather than the exact matches. While ANN methods can dramatically boost query speeds, they may sometimes sacrifice pinpoint accuracy, potentially missing the true nearest vectors. Certain vector index methods, such as product quantization, enhance storage efficiency and accelerate queries by condensing and consolidating data at the expense of accuracy.</li>
				<li><strong class="bold">Quality of embedding</strong>: The effectiveness of a vector database is dependent on the quality of the vector embedding used. Poorly designed embeddings can lead to inaccurate search results or missed connections.</li>
				<li><strong class="bold">Complexity</strong>: Implementing<a id="_idIndexMarker425"/> and managing vector databases can be complex, requiring specialized knowledge about vector search strategy indexing and chunking strategies to optimize for specific use cases.</li>
			</ul>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>Vector libraries</h2>
			<p>Vector databases may not always be necessary. Small-scale applications may not require all the advanced features that vector DBs provide. In those instances, vector libraries become very valuable. Vector libraries<a id="_idIndexMarker426"/> are usually sufficient for small, static data and provide the ability to store in memory, index, and use similarity search strategies. However, they may not provide features such as CRUD support, data replication, and being able to store data on disk, and hence, the user will have to wait for a full import before they can query. Facebook’s FAISS is a popular example of a vector library.</p>
			<p>As a rule of thumb, if you are dealing with millions/billions of records and storing data that are changing frequently, require millisecond response times, and more long-term storage capabilities on disk, it is recommended to use vector DBs over vector libraries.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Vector DBs vs. traditional databases – Understanding the key differences</h2>
			<p>As stated earlier, vector databases <a id="_idIndexMarker427"/>have become pivotal, especially<a id="_idIndexMarker428"/> in the era of generative AI, because they facilitate efficient storage, querying, and retrieval of highly dimensional vectors that are nothing but numerical representations of words or sentences often produced by deep learning models. Traditional scalar databases are designed to handle discrete and simple data types, making them ill-suited for the complexities of large-scale vector data. In contrast, vector databases are optimized for similar searches in the vector space, enabling the rapid identification of vectors that are “close” or “similar” in highly dimensional spaces. Unlike conventional data models such as relational databases, where queries commonly resemble “retrieve the books borrowed by a particular member” or “identify the items currently discounted,” vector queries primarily seek similarities among vectors based on one or more reference vectors. In other words, queries might look like “identify the top 10 images of dogs similar to the dog in this photo” or “locate the best cafes near my current location.”  At retrieval time, vector databases are crucial, as they facilitate the swift and precise retrieval of relevant document embeddings to augment the generation process. This technique is also called RAG, and we will learn more about it in the later sections.</p>
			<p>Imagine you have a database <a id="_idIndexMarker429"/>of fruit images, and <a id="_idIndexMarker430"/>each image is represented by a vector (a list of numbers) that describes its features. Now, let’s say you have a photo of an apple, and you want to find similar fruits in your database. Instead of going through each image individually, you convert your apple photo into a vector using the same method you used for the other fruits. With this apple vector in hand, you search the database to find vectors (and therefore images) that are most similar or closest to your apple vector. The result would likely be other apple images or fruits that look like apples based on the vector representation.</p>
			<div><div><img src="img/B21443_04_10.jpg" alt="Figure 4.10 – Vector represenation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Vector represenation</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Vector DB sample scenario – Music recommendation system using a vector database</h2>
			<p>Let’s consider a music<a id="_idIndexMarker431"/> streaming platform aiming to provide song recommendations based on a user’s current listening. Imagine a user who is listening to “Song X” on the platform.</p>
			<p>Behind the scenes, every song in the platform’s library is represented as a highly dimensional vector based on its musical features and content, using embeddings. “Song X” also has its vector representation. When the system aims to recommend songs similar to “Song X,” it doesn’t look for exact matches (as traditional databases might). Instead, it leverages a vector DB to search for songs with vectors closely resembling that of “Song X.” Using an ANN search strategy, the system quickly sifts through millions of song vectors to find those that are approximately nearest to the vector of “Song X.” Once potential song vectors are identified, the system employs similarity measures, such as cosine similarity, to rank these songs based on how close their vectors are to “Song X’s” vector. The top-ranked songs are then recommended to the user.</p>
			<p>Within milliseconds, the user gets a list of songs that musically resemble “Song X,” providing a seamless and personalized listening experience. All this rapid, similarity-based recommendation magic is powered by the vector database’s specialized capabilities.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Common vector DB applications</h1>
			<ul>
				<li><strong class="bold">Image and video similarity search</strong>: In the<a id="_idIndexMarker432"/> context of<a id="_idIndexMarker433"/> image and video similarity search, a vector DB specializes in efficiently storing and querying highly dimensional embeddings derived from multimedia content. By processing images through deep learning models, they are converted into feature vectors, a.k.a embeddings, that capture their essential characteristics. When it comes to videos, an additional step may need to be carried out to extract frames and then convert them into vector embeddings. Contrastive language-image pre-training (CLIP) from OpenAI is a very popular choice for embedding videos and images. These vector embeddings are indexed in the vector DB, allowing for rapid and precise retrieval when a user submits a query. This mechanism powers applications such as reverse image and video search, content recommendations, and duplicate detection by comparing and ranking content based on the proximity of their embeddings.</li>
				<li><strong class="bold">Voice recognition</strong>: Voice recognition<a id="_idIndexMarker434"/> with vectors is akin to video vectorization. Analog audio is digitized into short frames, each representing an audio segment. These frames are processed and stored as feature vectors, with the entire audio sequence representing things such as spoken sentences or songs. For user authentication, a vectorized spoken key phrase might be compared to stored recordings. In conversational agents, these vector sequences can be inputted into neural networks to recognize and classify spoken words in speech and generate responses, similar to ChatGPT.</li>
				<li><strong class="bold">Long-term memory for chatbots</strong>: Virtual database management systems (VDBMs) can be employed to <a id="_idIndexMarker435"/>enhance the long-term memory capabilities of chatbots or generative models. Many generative models can only process a limited amount of preceding text in prompt responses, which results in their inability to recall details from prolonged conversations. As these models don’t have inherent memory of past interactions and can’t differentiate between factual data and user-specific details, using VDBMs can provide a solution for storing, indexing, and referencing previous <a id="_idIndexMarker436"/>interactions to improve consistency and context-awareness<a id="_idIndexMarker437"/> in responses.</li>
			</ul>
			<p>This is a very important use case and plays a key role in implementing RAG, which we will discuss in the next section.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>The role of vector DBs in retrieval-augmented 
generation (RAG)</h1>
			<p>To fully understand RAG and the pivotal role of vector DBs within it, we must first acknowledge the inherent constraints of LLMs, which paved the way for the advent of RAG techniques powered by vector DBs. This section sheds light on the specific LLM challenges that RAG aims to overcome and the importance of vector DBs.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>First, the big question – Why?</h2>
			<p>In <a href="B21443_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we delved into the limitations of LLMs, which include the following:</p>
			<ul>
				<li>LLMs possess a<a id="_idIndexMarker438"/> fixed knowledge base determined by their training data; as of February 2024, ChatGPT’s knowledge is limited to information up until April 2023.</li>
				<li>LLMs can occasionally produce false narratives, spinning tales or facts that aren’t real.</li>
				<li>They lack personal memory, relying solely on the input context length. For example, take GPT4-32K; it can only process up to 32K tokens between prompts and completions (we’ll dive deeper into prompts, completions, and tokens in <a href="B21443_05.xhtml#_idTextAnchor098"><em class="italic">Chapter 5</em></a>).</li>
			</ul>
			<p>To counter these challenges, a promising avenue is enhancing LLM generation with retrieval components. These components can extract pertinent data from external knowledge bases—a process termed RAG, which we’ll explore further in this section.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>So, what is RAG, and how does it help LLMs?</h2>
			<p>Retrieval-augmented generation (RAG) was <a id="_idIndexMarker439"/>first introduced in a paper ti<a href="https://arxiv.org/pdf/2005.11401.pdf">tled <em class="italic">Retrieval-Augmented Generation </em></a><em class="italic">for Knowledge-Intensive NLP Tasks</em> (<a href="https://arxiv.org/pdf/2005.11401.pdf">https://arxiv.org/pdf/2005.11401.pdf</a>) in November 2020 by Facebook AI Research (now Meta). RAG is an approach that combines the generative capabilities of LLMs with retrieval mechanisms to extract relevant information from vast datasets. LLMs, such as the GPT variants, have the ability to generate human-like text based on patterns in their training data but lack the means to perform real-time external lookups or reference specific external knowledge bases post-training. RAG addresses this limitation by using a retrieval model to query a dataset and fetch relevant information, which then serves as the context for the generative model to produce a detailed and informed response. This also helps in grounding the LLM queries with relevant information that reduces the chances of hallucinations.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>The critical role of vector DBs</h2>
			<p>A vector DB plays<a id="_idIndexMarker440"/> a crucial role in facilitating the efficient retrieval aspect of RAG. In this setup, each piece of information, such as text, video, or audio, in the dataset is represented as a highly dimensional vector and indexed in a vector DB. When a query from a user comes in, it’s also converted into a similar vector representation. The vector DB then rapidly searches for vectors (documents) in the dataset that are closest to the query vector, leveraging techniques such as ANN search. Then, it attaches the query with relevant content and sends it to the LLMs to generate a response. This ensures that the most relevant information is retrieved quickly and efficiently, providing a foundation for the generative model to build upon.</p>
			<h3>Example of an RAG workflow</h3>
			<p>Let’s walk through <a id="_idIndexMarker441"/>as an example step by step, as shown in the image. Imagine a platform where users can ask about ongoing cricket matches, including recent performances, statistics, and trivia:</p>
			<ol>
				<li>Suppose the user asks, “How did Virat Kohli perform in the last match, and what’s an interesting fact from that game?” Since the LLM was trained until April 2023, the LLM may not have this answer.</li>
				<li>The retrieval model will embed the query and send it to a vector DB.</li>
				<li>All the latest cricket news is stored in a vector DB in a properly indexed format using ANN strategies such as HNSW. The vector DB performs a cosine similarity with the indexed information and provides a few relevant results or contexts.</li>
				<li>The<a id="_idIndexMarker442"/> retrieved context is then sent to the LLM along with the query to synthesize the information and provide a relevant answer.</li>
				<li>The LLM provides the relevant answer: “Virat Kohli scored 85 runs off 70 balls in the last match. An intriguing detail from that game is that it was the first time in three years that he hit more than seven boundaries in an ODI inning.”</li>
			</ol>
			<p>The following <a id="_idIndexMarker443"/>image illustrates the preceding points:</p>
			<div><div><img src="img/B21443_04_11.jpg" alt="Figure 4.11 – Representation of RAG workflow with vector database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Representation of RAG workflow with vector database</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Business applications of RAG</h1>
			<p>In the following list, we have <a id="_idIndexMarker444"/>mentioned a few popular business applications of RAG based on what we’ve seen in the industry:</p>
			<ul>
				<li><strong class="bold">Enterprise search engines</strong>: One of<a id="_idIndexMarker445"/> the most prominent applications of RAG is in the realm of enterprise learning and development, serving as a search engine for employee upskilling. Employees can pose questions about the company, its culture, or specific tools, and RAG swiftly delivers accurate and relevant answers.</li>
				<li><strong class="bold">Legal and compliance</strong>: RAG fetches relevant case laws or checks business practices against<a id="_idIndexMarker446"/> regulations.</li>
				<li><strong class="bold">Ecommerce</strong>: RAG suggests products or <a id="_idIndexMarker447"/>summarizes reviews based on user behavior and queries.</li>
				<li><strong class="bold">Customer support</strong>: RAG provides precise answers to customer queries by pulling information from the<a id="_idIndexMarker448"/> company’s knowledge base and providing solutions in real time.</li>
				<li><strong class="bold">Medical and healthcare</strong>: RAG <a id="_idIndexMarker449"/>retrieves pertinent medical research or provides preliminary symptom-based<a id="_idIndexMarker450"/> suggestions.</li>
			</ul>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Chunking strategies</h1>
			<p>In our last discussion, we delved into vector DBs and RAG. Before diving into RAG, we need to efficiently house our embedded data. While we touched upon indexing methods to speed up data fetching, there’s another crucial step to take even before that: chunking.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>What is chunking?</h2>
			<p>In the context of <a id="_idIndexMarker451"/>building LLM applications with embedding models, chunking involves dividing a long piece of text into smaller, manageable pieces or “chunks” that fit within the model’s token limit. The process involves breaking text into smaller segments before sending these to the embedding models. As shown in the following image, chunking happens before the embedding process. Different documents have different structures, such as free-flowing text, code, or HTML. So, different chunking strategies can be applied to attain optimal results. Tools such as Langchain provide you with functionalities to chunk your data efficiently based on the nature of the text.</p>
			<p>The diagram below depicts a data processing workflow, highlighting the chunking step, starting with raw “Data sources” that are converted into “Documents.” Central to this workflow is the “Chunk” stage, where a “TextSplitter” breaks the data into smaller segments. These chunks are then transformed into numerical representations using an “Embedding model” and are subsequently indexed into a “Vector DB” for efficient search and retrieval. The text associated with the retrieved chunks is then sent as context to the LLMs, which <a id="_idIndexMarker452"/>then generate a final response:</p>
			<div><div><img src="img/B21443_04_12.jpg" alt="Fig 4.12 – Chunking Process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fig 4.12 – Chunking Process</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>But why is it needed?</h2>
			<p>Chunking is <a id="_idIndexMarker453"/>vital for two main reasons:</p>
			<ul>
				<li>Chunking strategically divides document text to enhance its comprehension by embedding models, and it boosts the relevance of the content retrieved from a vector DB. Essentially, it refines the accuracy and context of the results sourced from the database.</li>
				<li>It tackles the token constraints of embedding models. For instance, Azure’s OpenAI embedding models like text-embedding-ada-002 can handle up to 8,191 tokens, which is about 6,000 words, given each token averages four characters. So, for optimal embeddings, it’s crucial our text stays within this limit.</li>
			</ul>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Popular chunking strategies</h2>
			<ul>
				<li><strong class="bold">Fixed-size chunking</strong>: This is a <a id="_idIndexMarker454"/>very common approach that defines a <a id="_idIndexMarker455"/>fixed size (200 words), which is enough to capture the semantic meaning of a paragraph, and it incorporates an overlap of about 10–15% as an input to the vector embedding generation model. Chunking data with a slight overlap between text ensures context preservation. It’s advisable to begin with a roughly 10% overlap. Below is a snippet of code that demonstrates the use of fixed-size chunking with LangChain:</li>
			</ul>
			<pre class="source-code">
text = "Ladies and Gentlemen, esteemed colleagues, and honored \guests. Esteemed leaders and distinguished members of the \community. Esteemed judges and advisors. My fellow citizens. Last \year, unprecedented challenges divided us. This year, we stand \united, ready to move forward together"
from langchain.text_splitter import TokenTextSplitter
text_splitter = TokenTextSplitter(chunk_size=20, chunk_overlap=5)
texts = text_splitter.split_text(text)
print(texts)</pre>			<p>The <a id="_idIndexMarker456"/>output is the <a id="_idIndexMarker457"/>following:</p>
			<pre class="console">
['Ladies and Gentlemen, esteemed colleagues, and honored guests. Esteemed leaders and distinguished members', 'emed leaders and distinguished members of the community. Esteemed judges and advisors. My fellow citizens.', '. My fellow citizens. Last year, unprecedented challenges divided us. This year, we stand united,', ', we stand united, ready to move forward together']</pre>			<ul>
				<li><strong class="bold">Variable-size chunking</strong>: Variable-size chunking refers to the dynamic segmentation of data or text into varying-sized components, as opposed to fixed-size divisions. This approach accommodates the diverse structures and characteristics present in different types of data.<ul><li><strong class="bold">Sentence splitting</strong>: Sentence <a id="_idIndexMarker458"/>transformer models are neural <a id="_idIndexMarker459"/>architectures optimized for embedding<a id="_idIndexMarker460"/> at the sentence level. For example, BERT works best when chunked at the sentence level. Tools such as NLTK and SpaCy provide functions to split the sentences within a text.</li><li><strong class="bold">Specialized chunking</strong>: Documents, such <a id="_idIndexMarker461"/>as research <a id="_idIndexMarker462"/>papers, possess a structured organization of sections, and the Markdown language, with its unique syntax, necessitates specialized chunking, resulting in the proper separation between sections/pages to yield contextually relevant chunks.</li><li><strong class="bold">Code Chunking</strong>: When embedding <a id="_idIndexMarker463"/>code into your vector DB, this technique can be invaluable. Langchain supports code chunking<a id="_idIndexMarker464"/> for numerous languages. Below is a snippet code to chunk your Python code:</li></ul></li>
			</ul>
			<pre class="source-code">
from langchain.text_splitter import (
    RecursiveCharacterTextSplitter,
    Language,
)
PYTHON_CODE = """
class SimpleCalculator:
    def add(self, a, b):
        return a + b
    def subtract(self, a, b):
        return a - b
# Using the SimpleCalculator
calculator = SimpleCalculator()
sum_result = calculator.add(5, 3)
diff_result = calculator.subtract(5, 3)
"""
python_splitter = RecursiveCharacterTextSplitter.from_language(
    language=Language.PYTHON, chunk_size=50, chunk_overlap=0
)
python_docs = python_splitter.create_documents([PYTHON_CODE])
python_docs</pre>			<p>The output is the following:</p>
			<pre class="console">
[Document(page_content='class SimpleCalculator:\n    def add(self, a,                                                              b):'),
 Document(page_content='return a + b'),
 Document(page_content='def subtract(self, a, b):'),
 Document(page_content='return a - b'),
 Document(page_content='# Using the SimpleCalculator'),
 Document(page_content='calculator = SimpleCalculator()'),
 Document(page_content='sum_result = calculator.add(5, 3)'),
 Document(page_content='diff_result = calculator.subtract(5, 3)')]</pre>			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Chunking considerations</h2>
			<p>Chunking <a id="_idIndexMarker465"/>strategies vary based on <strong class="bold">data type</strong> and <strong class="bold">format</strong> and the <strong class="bold">chosen embedding model</strong>. For instance, code requires a distinct chunking approach compared to unstructured text. While models such as text-embedding-ada-002 excel with 256- and 512-token-sized chunks, our understanding of chunking is ever-evolving. Moreover, preprocessing plays a crucial role before chunking, where you can optimize your content by removing unnecessary text content, such as stop words, special symbols, etc., that add noise. For the latest techniques, we suggest regularly checking the text splitters section in the LangChain documentation, ensuring you employ the best<a id="_idIndexMarker466"/> strategy for your needs</p>
			<p>(Split by tokens from Langchain: <a href="https://python.langchain.com/docs/modules/data_connection/document_transformers/split_by_token">https://python.langchain.com/docs/modules/data_connection/document_transformers/split_by_token</a>).</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Evaluation of RAG using Azure Prompt Flow</h1>
			<p>Up to this point, we have <a id="_idIndexMarker467"/>discussed the <a id="_idIndexMarker468"/>development of resilient RAG applications. However, the question arises: How can we determine whether these applications are functioning as anticipated and if the context they retrieve is pertinent? While manual validation—comparing the responses generated by LLMs against ground truth—is possible, this method proves to be labor-intensive, costly, and challenging to execute on a large scale. Consequently, it’s essential to explore methodologies that facilitate automated evaluation on a vast scale. Recent research has delved into the concept of utilizing “LLM as a judge” to assess output, a strategy that Azure Prompt Flow incorporates within its offerings.</p>
			<p>Azure Prompt Flow has built-in and structured metaprompt templates with comprehensive guardrails to evaluate your output against ground truth. The following mentions four metrics that can help you evaluate your RAG solution in Prompt Flow:</p>
			<ul>
				<li><strong class="bold">Groundedness</strong>: Measures the alignment of the model’s answers with the input source, making sure the model’s generated response is not fabricated. The model must always extract information from the provided “context” while responding to user’s query.</li>
				<li><strong class="bold">Relevance</strong>: Measures the degree to which the model’s generated response is closely connected to the context and user query.</li>
				<li><strong class="bold">Retrieval score</strong>: Measures the extent to which the model’s retrieved documents are pertinent and directly related to the given questions.</li>
				<li><strong class="bold">Custom metrics</strong>: While the above three are the most important for evaluating RAG applications, Prompt Flow allows you to use custom metrics, too. Bring your own LLM as a judge and define your own metrics by modifying the existing metaprompts. This also allows you to use open source models such as Llama and to build your own metrics from code with Python functions. The above evaluations are more no-code or low-code friendly; however, for a more pro-code friendly approach, azureml-metrics SDK, such as ROUGE, BLEU, F1-Score, Precision, and Accuracy, can be utilized as well.</li>
			</ul>
			<p>The field is <a id="_idIndexMarker469"/>advancing quickly, so<a id="_idIndexMarker470"/> we recommend regularly checking Azure ML Prompt Flow’s latest updates on evaluation metrics. Start with the “Manual Evaluation” feature in Prompt Flow to gain a basic understanding of LLM performance. It’s important to use a mix of metrics for a thorough evaluation that captures both semantic and syntactic essence rather than relying on just one metric to compare the responses with the actual ground truth.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Case study – Global chat application deployment by a multinational organization</h1>
			<p>A global<a id="_idIndexMarker471"/> firm recently launched an advanced internal chat application featuring a Q&amp;A support chatbot. This innovative tool, deployed across various Azure regions, integrates several large language models, including the specialized finance model, BloombergGPT. To meet specific organizational requirements, bespoke plugins were developed. It had an integration with Service Now, empowering the chatbot to streamline ticket generation and oversee incident actions.</p>
			<p>In terms of data refinement, the company meticulously preprocessed its knowledge base (KB) information, eliminating duplicates, special symbols, and stop words. The KB consisted of answers to frequently asked questions and general information to various support-related questions. They employed fixed chunking approaches, exploring varied chunk sizes, before embedding these data into the Azure AI search. Their methodology utilized Azure OpenAI’s text-ada-embedding-002 models in tandem with the cosine similarity metric and Azure AI search’s vector search capabilities.</p>
			<p>From their extensive testing, they discerned optimal results with a chunk size of 512 tokens and a 10% overlap. Moreover, they adopted an ANN vector search methodology using cosine similarity. They also incorporated hybrid search that included keyword and semantic search with Semantic Reranker. Their RAG workflow, drawing context from Azure Vector Search and the GPT 3.5 Turbo-16K models, proficiently generated responses to customer support inquiries. They implemented caching techniques using Azure Cache Redis and rate-limiting strategies using Azure API Management to optimize the costs.</p>
			<p>The integration of the<a id="_idIndexMarker472"/> support Q&amp;A chatbot significantly streamlined the multinational firm’s operations, offering around-the-clock, consistent, and immediate responses to queries, thereby enhancing user satisfaction. This not only brought about substantial cost savings by reducing human intervention but also ensured scalability to handle global demands. By automating tasks such as ticket generation, the firm gained deeper insights in<a href="https://arxiv.org/pdf/2309.11322.pdf">to user interactions, allowing for continuous improvement and refinement of their services.</a></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Summary</h1>
			<p>In this chapter, we explored the RAG approach, a powerful method for leveraging your data to craft personalized experiences, reduce hallucinations while also addressing the training limitations inherent in LLMs. Our journey began with an examination of foundational concepts such as vectors and databases, with a special focus on Vector Databases. We understood the critical role that Vector DBs play in the development of RAG-based applications, also highlighting how they can enhance LLM responses through effective chunking strategies. The discussion also covered practical insights on building engaging RAG experiences, evaluating them through prompt flow, and included a hands-on lab available on GitHub to apply what we’ve learned.</p>
			<p>In the next chapter we will introduce another popular technique designed to minimize hallucinations and more easily steer the responses of LLMs. We will cover prompt engineering strategies, empowering you to fully harness the capabilities of your LLMs and engage more effectively with AI. This exploration will provide you with the tools and knowledge to enhance your interactions with AI, ensuring more reliable and contextually relevant outputs.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>References</h1>
			<ol>
				<li>Vector database management systems: Fundamental concepts, use-cases, and current challenges : <a href="https://arxiv.org/pdf/2309.11322.pdf">https://arxiv.org/pdf/2309.11322.pdf</a></li>
				<li>Two minutes NLP — 11 word embeddings models you should know | by Fabio Chiusano | NLPlanet | Medium - <a href="https://medium.com/nlplanet/two-minutes-nlp-11-word-embeddings-models-you-should-know-a0581763b9a9">https://medium.com/nlplanet/two-minutes-nlp-11-word-embeddings-models-you-should-know-a0581763b9a9</a></li>
				<li>How To Choose The Right Embedding Model For You | by Chebbah Mehdi | Medium: <a href="mailto:https://medium.com/@mehdi_chebbah/how-to-choose-the-right-embedding-model-for-you-1fc917d14517">https://medium.com/@mehdi_chebbah/how-to-choose-the-right-embedding-model-for-you-1fc917d14517</a></li>
				<li>A Gentle Introduction to Vector Databases | Weaviate - vector database - <a href="https://weaviate.io/blog/what-is-a-vector-database">https://weaviate.io/blog/what-is-a-vector-database</a></li>
				<li>Vector Library versus Vector Database | Weaviate - vector database - <a href="https://weaviate.io/blog/vector-library-vs-vector-database#feature-comparison---library-versus-database">https://weaviate.io/blog/vector-library-vs-vector-database#feature-comparison---library-versus-database</a></li>
				<li>Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs - <a href="https://arxiv.org/abs/1603.09320">https://arxiv.org/abs/1603.09320</a></li>
				<li>Introduction Milvus v2.0.x documentation: <a href="https://milvus.io/docs/v2.0.x/overview.md">https://milvus.io/docs/v2.0.x/overview.md</a></li>
				<li>The 5 Best Vector Databases | A List With Examples | DataCamp - <a href="https://www.datacamp.com/blog/the-top-5-vector-databases">https://www.datacamp.com/blog/the-top-5-vector-databases</a></li>
				<li>Vector Library versus Vector Database | Weaviate - vector database - <a href="https://weaviate.io/blog/vector-library-vs-vector-database#feature-comparison---library-versus-database">https://weaviate.io/blog/vector-library-vs-vector-database#feature-comparison---library-versus-database</a></li>
				<li>RAG: <a href="https://milvus.io/docs/v2.0.x/overview.md">https://milvus.io/docs/v2.0.x/overview.md</a></li>
				<li>Chunk documents in vector search - Azure Cognitive Search | Microsoft Learn - <a href="https://learn.microsoft.com/en-us/azure/search/vector-search-how-to-chunk-documents">https://learn.microsoft.com/en-us/azure/search/vector-search-how-to-chunk-documents</a></li>
				<li>Chunking Strategies for LLM Applications | Pinecone - <a href="https://www.pinecone.io/learn/chunking-strategies/">https://www.pinecone.io/learn/chunking-strategies/</a></li>
				<li>Product Quantization: Compressing high-dimensional vectors by 97% | Pinecone: <a href="https://www.pinecone.io/learn/series/faiss/product-quantization/">https://www.pinecone.io/learn/series/faiss/product-quantization/</a></li>
				<li>Evaluation and monitoring metrics for generative AI - Azure AI Studio | Microsoft Learn - <a href="https://learn.microsoft.com/en-us/azure/ai-studio/concepts/evaluation-metrics-built-in">https://learn.microsoft.com/en-us/azure/ai-studio/concepts/evaluation-metrics-built-in</a></li>
				<li>Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks: <a href="https://arxiv.org/abs/2005.11401">https://arxiv.org/abs/2005.11401</a></li>
			</ol>
		</div>
	</body></html>