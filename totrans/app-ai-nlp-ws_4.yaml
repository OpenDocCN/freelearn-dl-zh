- en: 4\. Conversational Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 对话式人工智能
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter teaches you how to design a chatbot using Amazon Lex. You will
    start by learning the basics of **Conversational Artificial Intelligence** and
    some of the best practices that go behind using that technology to design custom
    chatbots. Then, you will use Amazon Lex to create a custom chatbot that gets the
    latest stock market quotes by recognizing the intent in text. By the end of this
    chapter, you would be well-versed with the basics of chatbots, and the process
    that goes into designing them. Using this knowledge, you will be able to create
    your own chatbots to solve a variety of business challenges.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教你如何使用Amazon Lex设计聊天机器人。你将从学习**对话式人工智能**的基础以及使用该技术设计定制聊天机器人的最佳实践开始。然后，你将使用Amazon
    Lex创建一个自定义聊天机器人，通过识别文本中的意图来获取最新的股市报价。到本章结束时，你将熟练掌握聊天机器人的基础知识以及设计它们的过程。利用这些知识，你将能够创建自己的聊天机器人来解决各种商业挑战。
- en: Introduction to Conversational AI
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话式人工智能简介
- en: Like the other chapters in this book, this chapter spans the conceptual aspects
    as well as pragmatic hands-on building – this time, the domain is Conversational
    AI. From many reports, it's stated that the conversational AI market will grow
    more than 30% per year and that the majority of customers, as well as employees,
    will be interacting with digital assistants.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他章节一样，本章涵盖了概念方面以及实用的动手构建——这次，领域是对话式人工智能。从许多报告中可以看出，对话式人工智能市场将每年增长超过30%，并且大多数客户以及员工都将与数字助手进行互动。
- en: 'The challenge in creating responsive, intelligent, and interactive bots is
    that, for machines, conversation is very hard to achieve. Let''s look at the top
    three reasons why this is the case:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 创建响应性、智能和交互式机器人的挑战在于，对于机器来说，对话是非常难以实现的。让我们看看为什么这是这种情况的前三个原因：
- en: Conversation conveys only the essential information – most of the information
    that's derived from a conversation is not even in the conversation. That is because
    humans have common sense, reasoning, shared context, knowledge, and assumptions
    at hand. We also overload a conversation with meanings derived from tonality,
    facial expressions, and even non-verbal communication, that is, via body language.
    These factors make conversations hard to comprehend, even though fewer words are
    exchanged. So, a conversational AI that looks at only the words that are exchanged
    probably misses 90% of the embedded information.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话只传达必要的信息——从对话中得出的大多数信息甚至不在对话中。这是因为人类拥有常识、推理、共享的上下文、知识和假设。我们还通过语气、面部表情甚至非言语交流（即肢体语言）赋予对话丰富的含义。这些因素使得对话难以理解，尽管交换的词汇较少。因此，只关注交换的词汇的对话式人工智能可能错过了90%的嵌入信息。
- en: It is not just a bunch of computer algorithms – the computer theoretic view
    is only part of a conversation exchange. We also need to incorporate linguistics,
    conversation implicature, and other domains. Again, this is a very hard task for
    computers – they can do neural networks very well, but grammar, not so much.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不仅仅是一系列计算机算法——计算机理论观点只是对话交换的一部分。我们还需要结合语言学、对话含义和其他领域。再次强调，这对计算机来说是一个非常困难的任务——它们在神经网络方面做得很好，但在语法方面就不那么擅长了。
- en: Consumers are spoiled by extremely good conversation interactions. While the
    conversation domain is very complex, products such as Alexa, Siri, and Google
    Assistant are achieving huge progress in conversational AI. This adds a degree
    of high expectation for a business that is developing interactions based on conversational
    AI. Even for the most mundane tasks oriented around conversational interactions,
    consumers expect the sophistication of Alexa, Siri, or Google Assistant. So, your
    conversational systems have to cross that barrier.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者被极好的对话交互所宠坏。虽然对话领域非常复杂，但像Alexa、Siri和Google Assistant这样的产品在对话式人工智能方面取得了巨大的进步。这给基于对话式人工智能开发交互业务的企业带来了一定的高期望。即使是围绕对话交互的最普通任务，消费者也期望达到Alexa、Siri或Google
    Assistant的复杂程度。因此，你的对话系统必须跨越这个障碍。
- en: 'This brings us nicely to the start of this chapter: Amazon Lex uses the same
    technology as Alexa and the Amazon Contact Center uses Amazon Connect, which means
    that we get to deploy their best practices. In fact, Amazon Connect was developed
    in order to meet the strict requirements of their customer service departments.
    So, we are in luck – we can leverage the state-of-the art interactions that our
    customers are used to in their daily lives.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这很自然地引出了本章的开始：Amazon Lex 使用与 Alexa 相同的技术，而 Amazon Contact Center 使用 Amazon Connect，这意味着我们可以部署他们的最佳实践。实际上，Amazon
    Connect 是为了满足他们客户服务部门的严格要求而开发的。所以，我们很幸运——我们可以利用我们的客户在日常生活中习惯的尖端交互。
- en: Interaction Types
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互类型
- en: When we talk about conversational AI, there are two main types – task-oriented
    and open-ended conversation. As the name implies, task-oriented conversations
    function to fulfill a task (for example, query balances in an account, order an
    item, check the weather, check the price of a stock, and find out how many vacation
    days are remaining). Open-ended general conversations are broader as they cover
    various topics – this could be the weather, movies, financial well-being, investing,
    and so on. In this chapter, we will focus on task-oriented conversations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论对话人工智能时，主要有两种类型——面向任务型和开放式对话。正如其名所示，面向任务型的对话旨在完成任务（例如，查询账户余额、订购商品、查看天气、查看股票价格、了解剩余的假期天数等）。开放式一般对话更广泛，因为它们涵盖了各种主题——这可能是天气、电影、财务状况、投资等等。在本章中，我们将专注于面向任务型的对话。
- en: Omnichannel
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全渠道
- en: Another point to keep in mind is the omnichannel aspect of conversations – conversations
    can be had via a chatbot with a text interface or via a **voice UI** (**VUI**);
    they can jump from one to the other, and with the new concept of Visual IVR, they
    might even be concurrent. That is why we will cover chatbots and then voice in
    this chapter. Multimodality is an important part of conversational AI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的是对话的全渠道方面——可以通过聊天机器人的文本界面或**语音用户界面（VUI**）进行对话；它们可以从一个跳转到另一个，而且随着新的视觉
    IVR 概念的出现，它们甚至可能是并行的。这就是为什么我们将在本章中先介绍聊天机器人，然后介绍语音。多模态是对话人工智能的一个重要组成部分。
- en: In short, in this chapter, you will learn how to build a chatbot using **Amazon
    Lex**. We will also cover the design of conversational AIs. We will then dive
    into Amazon Connect and explore adding voice to our bots. First, we'll talk about
    how to design a chatbot. Then, we will dive into exploring the Amazon Lex service
    by creating a sample chatbot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在本章中，你将学习如何使用 **Amazon Lex** 构建聊天机器人。我们还将涵盖对话人工智能的设计。然后，我们将深入研究 Amazon
    Connect 并探索为我们的机器人添加语音。首先，我们将讨论如何设计聊天机器人。然后，我们将通过创建一个示例聊天机器人来深入了解 Amazon Lex 服务。
- en: What Is a Chatbot?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是聊天机器人？
- en: A chatbot is a specific instance of a task-oriented conversational AI – the
    goal is to be able to hold a conversation with the user to the extent required
    in order to resolve customer queries, perform a task that the customer requests,
    or suggest a way to move forward from them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人是面向任务型对话人工智能的一个具体实例——目标是能够与用户进行对话，达到解决客户查询、执行客户请求的任务或建议从他们那里前进的方式所需的程度。
- en: As in normal conversation, the means by which we interact with the bot can be
    written text or speech. Often, the chatbots are integrated with messaging platforms,
    such as Slack, Facebook, Kik, and WeChat. This can also be integrated with a custom
    web or mobile interface.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如正常对话一样，我们与机器人互动的方式可以是书面文字或语音。通常，聊天机器人会集成到消息平台中，如 Slack、Facebook、Kik 和微信。这也可以集成到自定义的网页或移动界面中。
- en: It is easier, of course, to integrate within an existing messaging platform,
    since the user is likely to be familiar with the interface. Moreover, these platforms
    provide support to the chatbot developers with infrastructure and development
    tools.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现有的消息平台中集成更容易，因为用户可能熟悉该界面。此外，这些平台为聊天机器人开发者提供基础设施和开发工具的支持。
- en: Some examples of chatbots include systems for ordering products, reporting,
    internal communication, and scheduling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人的例子包括产品订购系统、报告、内部沟通和调度。
- en: What Is Natural Language Understanding?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是自然语言理解？
- en: NLP is the general term for a set of technologies that deal with natural language.
    **Natural Language Understanding** (**NLU**) is a focused subset of NLP that deals
    with actual conversational input.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）是一组处理自然语言技术的通用术语。**自然语言理解（NLU**）是 NLP 的一个专注于实际对话输入的子集。
- en: NLU can handle unstructured inputs and convert them into a structured, machine-understandable
    form. Words that the user enters are transformed into intents and entities, or
    slots. The NLU chatbot is further able to infer intents and slots from user input,
    which may be similar to – but not the same as – the examples it has been trained
    with.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: NLU能够处理非结构化输入并将它们转换成结构化、机器可理解的格式。用户输入的词语会被转换成意图和实体，或者称为slots。NLU聊天机器人还能够从用户输入中推断意图和slots，这些可能与——但并不一定与——它所训练的例子相同。
- en: Core Concepts in a Nutshell
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心概念概述
- en: Before we can get started with building chatbots, you will need to understand
    some concepts first. Let's take a look at the technical meaning of the term *chatbot*
    and the names of the pieces that make up a chatbot and work together to deliver
    a conversational experience to the user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建聊天机器人之前，你首先需要了解一些概念。让我们来看看术语*chatbot*的技术含义以及构成聊天机器人并协同工作以向用户提供对话体验的各个组件的名称。
- en: Chatbot
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chatbot
- en: A chatbot, also known as a `bot` or artificial conversation entity, is a piece
    of software that can converse using natural language with the user. The goal is
    for the user to believe that they can interact freely and naturally with the bot,
    almost as if speaking with another person.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人，也称为`bot`或人工对话实体，是一种能够使用自然语言与用户进行对话的软件。目标是让用户相信他们可以与机器人自由自然地互动，几乎就像与另一个人交谈一样。
- en: Utterances
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Utterances
- en: 'Things that the user says to the bot are called **utterances**. The bot regards
    the utterances from the user as input and is able to parse them into machine-recognizable
    formats. Some examples of utterances are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 用户对机器人说的话被称为**utterances**。机器人将用户的utterances视为输入，并能够将其解析成机器可识别的格式。以下是一些utterances的例子：
- en: I'd like to see the dentist.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想去看看牙医。
- en: Can you tell me what the weather is like today?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能告诉我今天的天气怎么样吗？
- en: Intent
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Intent
- en: An **intent** is something that a user wants to do, based on the content of
    their utterances. An intent can be a single step (for example, get a balance)
    or a multi-step process (for example, booking a trip that includes booking tickets,
    booking a hotel, booking transportation, and so on). The bot infers the intent
    from the user's utterances as well as the context and supports them based on its
    internal set of business rules or application flow, with the result of either
    a change in its internal state or an action being performed. These also typically
    result in a response being provided to the user as feedback or information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**intent**是指用户根据其utterances的内容想要做的事情。意图可以是一个单一步骤（例如，获取余额）或一个多步骤过程（例如，预订包括订票、订酒店、订交通等在内的旅行）。机器人从用户的utterances以及上下文中推断出意图，并根据其内部业务规则或应用程序流程支持它们，结果可能是其内部状态的变化或执行某个动作。这些通常也会导致向用户提供反馈或信息的响应。'
- en: 'So, from the preceding utterance examples, a bot may infer intents such as
    the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从先前的utterance例子中，机器人可能会推断出以下意图：
- en: I'd like to see the dentist => SeeDentist.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想去看看牙医 => SeeDentist。
- en: Can you tell me what the weather is like today? => GetWeather.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能告诉我今天的天气怎么样吗？ => GetWeather。
- en: Inferring intent is a large part of what NLU platforms such as Lex do behind
    the scenes. A number of training examples, in the form of sentences that the user
    might provide, are fed to the platform, and a probabilistic model is built from
    these examples. This means that, in practice, the platform should be able to infer
    the correct intent from input, which is similar to, but not necessarily a part
    of, the examples that the system was trained on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 推断意图是NLU平台（如Lex）在幕后执行的重要部分。一系列训练示例，以用户可能提供的句子形式，被输入到平台中，并从这些例子中构建一个概率模型。这意味着在实践中，平台应该能够从输入中推断出正确的意图，这可能与——但不一定是——系统所训练的例子的一部分。
- en: Prompts
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Prompts
- en: When the bot requires more information from the user or is unclear about an
    intent, it can ask the user follow-up questions, in order to collect more data.
    These are called **prompts**. Prompts typically fill in slot values that are required,
    although your application logic may attempt to fill in values that are optional
    as well if you desire.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器人需要从用户那里获取更多信息或对意图不清楚时，它可以询问用户后续问题，以便收集更多信息。这些被称为**prompts**。Prompts通常填充所需的slot值，尽管如果你的应用程序逻辑需要，也可以尝试填充可选值。
- en: Slot
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Slot
- en: A slot is a piece of information, or parameter, that is associated with an intent.
    Information can be provided within the initial user request, and Lex will be able
    to parse out the information and correctly assign it to the corresponding slot
    correctly. If this information is not provided as a part of the request, then
    the bot should be able to prompt the user for the information separately. Slots
    may be optional or required.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 槽位是与意图相关联的信息或参数。信息可以包含在初始用户请求中，Lex 将能够解析出信息并将其正确分配给相应的槽位。如果此信息不是作为请求的一部分提供，那么机器人应该能够单独提示用户提供信息。槽位可以是可选的或必需的。
- en: 'The type of information represented by a **slot** is known as the **slot type**.
    There are a number of built-in slot types within Lex that represent common types
    of information, such as a city or state. The following are a few examples of common
    slot types that are incorporated into Lex:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**槽位**所表示的信息类型称为**槽位类型**。Lex 中内置了许多槽位类型，代表常见的信息类型，例如城市或州。以下是一些常见的槽位类型示例，它们被纳入
    Lex 中：'
- en: '![Figure 4.1: Table of slot types built into Lex'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1：Lex 内置的槽位类型表'
- en: '](img/B16061_04_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16061_04_01.jpg](img/B16061_04_01.jpg)'
- en: 'Figure 4.1: Table of slot types built into Lex'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：Lex 内置的槽位类型表
- en: Of course, this is just a very limited subset of examples. There are many more
    built-in types, as well as different types for different languages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个非常有限的示例子集。还有许多其他内置类型，以及不同语言的类型。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can refer to the following link to get a full list of built-in intents
    and slots: [https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html](https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接以获取内置意图和槽位的完整列表：[https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html](https://docs.aws.amazon.com/lex/latest/dg/howitworks-builtins.html).
- en: Most of the built-in intents and slots are documented as part of the Alexa Skills
    Kit documentation, with some differences for Lex, which are documented at the
    preceding link. Make sure to keep the link bookmarked and refer to the page regularly,
    since Amazon keeps updating the service and things may change.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置的意图和槽位都作为 Alexa 技能套件文档的一部分进行了文档记录，Lex 中有一些差异，这些差异在先前的链接中有记录。请确保将链接添加到书签并定期参考该页面，因为亚马逊会不断更新服务，事情可能会发生变化。
- en: If the type of information that you would like your bot to handle is not represented
    by one of these built-in types, you can define your own, along with the actual
    values that the slot is allowed to take.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的机器人处理的信息类型不是这些内置类型之一，您可以定义自己的类型，以及槽位允许的实际值。
- en: Fulfillment
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 满足
- en: Note that the bot will not be able to proceed to the next step until it fills
    in all of the required slot values. Naturally, this does not apply to slot values
    that are optional.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，机器人只有在填写了所有必需的槽位值后才能继续进行下一步。当然，这并不适用于可选的槽位值。
- en: 'When all of the required slots for an intent have been filled, the slot is
    then ready for fulfillment. At this stage, the bot is ready to execute the business
    logic that''s required to fulfill the intent. Business logic may be any of the
    following actions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个意图的所有必需槽位都已填写时，槽位就准备好进行满足了。在这个阶段，机器人准备好执行满足意图所需的企业逻辑。企业逻辑可能是以下任何一种操作：
- en: Changes in the internal state
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部状态的变化
- en: Running code internally
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部运行代码
- en: Calling an internal or external service to get information from it
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个内部或外部服务以从中获取信息
- en: Calling an internal or external service to post information to it
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个内部或外部服务以向其发布信息
- en: The fulfillment action can be performed with or without some feedback to the
    user, but as a matter of best practice, it is always better to err on the side
    of more feedback to the user, rather than less.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完成操作可以带有或没有对用户的反馈，但作为最佳实践，总是更好地偏向于提供更多的反馈给用户，而不是更少。
- en: Best Practices for Designing Conversational AI
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计对话式人工智能的最佳实践
- en: 'Before we dive into some of the best practices, we will go over two quick points.
    We are only covering the most important ones and there are excellent materials
    and books available for a more in-depth study. Second, you will encounter situations
    where these tips might need to be ignored – this may include delivery pressures
    and resource constraints, but they may just be wrong due to advances in technologies.
    However, we need to be aware of the potential technical debt that can be created
    and document them somewhere for future reference. A few best practices are as
    follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨一些最佳实践之前，我们将简要介绍两个要点。我们只涵盖最重要的内容，并且有大量优秀的资料和书籍可供深入研究。其次，你可能会遇到需要忽略这些提示的情况——这可能包括交付压力和资源限制，但它们可能只是由于技术进步而错误。然而，我们需要意识到可能产生的潜在技术债务，并在某处记录下来以供未来参考。以下是一些最佳实践：
- en: When thinking about bots, think **Search**, not a single question-answer session.
    This requires a little thought — the bot should want to understand what the user
    wants and participate in an iterative collaborative interaction to facilitate
    what the user is looking for. For example, a user might ask "How much money do
    I have?" and you can resolve this to the balance in the checking account and returning
    an answer. However, the user might be looking to invest based on a stock tip or
    may be contemplating a large purchase. So, a follow-up question such as "Does
    this make sense? What are you thinking of?" might be a good strategy. The quintessential
    example is the question "What is the nearest restaurant?". For this, you can give
    a clinically correct answer based on distance, but the restaurant might be closed.
    So, volunteering more information such as "The nearest restaurant is x minutes
    away, but it is closed now. Are you looking for an open restaurant to go to now?"
    might be a good response.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当思考机器人时，要考虑**搜索**，而不是单一的问题-答案会话。这需要一点思考——机器人应该想要理解用户的需求，并参与迭代协作互动，以促进用户寻找的内容。例如，用户可能会问“我有多少钱？”你可以将其解决到支票账户的余额，并给出答案。然而，用户可能基于股票提示想要投资，或者可能在考虑一笔大额购买。因此，一个后续问题，如“这合理吗？你在想什么？”可能是一个好的策略。一个典型的例子是问题“最近的餐厅在哪里？”对于这个问题，你可以基于距离给出一个临床正确的答案，但餐厅可能已经关闭。因此，自愿提供更多信息，如“最近的餐厅距离x分钟，但现在已关闭。你现在是否在寻找一家可以去的开放餐厅？”可能是一个好的回应。
- en: 'Conversation is a continuum from simple commands and notifications to deep
    nested conversations, as shown in the following diagram:![Figure 4.2: Levels of
    conversational AI'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话是一个从简单的命令和通知到深层嵌套对话的连续体，如下面的图表所示：![图4.2：对话式AI的层次]
- en: '](img/B16061_04_02.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_02.jpg)'
- en: 'Figure 4.2: Levels of conversational AI'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.2：对话式AI的层次
- en: At the current maturity of technologies, we are at level 3 – Dialogues via Contextual
    Bots, which is at its very initial stages. Understanding these levels and positioning
    your bot service in the continuum is very important for estimating what is possible
    as well as the effort required, especially when it comes to the expectations of
    users.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在当前技术的成熟度下，我们处于第3级——通过上下文机器人进行对话，这处于非常初级的阶段。理解这些层次并将你的机器人服务定位在连续统一体中对于估计可能性和所需努力非常重要，尤其是在用户期望方面。
- en: Think of conversational AI – chatbots or voice assistants or a combination of
    the two, as interactions of **Available, Smart, and Autonomous.**
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对话式AI——聊天机器人、语音助手或两者的结合，视为**可用、智能和自主**的交互。
- en: A bot (chatbot, voice, or even the Visual IVR) is an experience. This means
    that you need to develop a minimum lovable product — it shouldn't be too ambitious
    and complex with lots of features; also, it shouldn't be too narrow such that
    it doesn't serve a good purpose completely. Keep the steps small and show value
    while ensuring that they do what they need to do.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个机器人（聊天机器人、语音机器人，甚至是可视IVR）是一种体验。这意味着你需要开发一个最小令人喜爱的产品——它不应该过于雄心勃勃和复杂，拥有众多功能；同时，它也不应该过于狭隘，以至于不能完全发挥其作用。保持步骤简单，在确保它们完成所需任务的同时展示价值。
- en: There is a misconception that bots do not have **visual branding**. The conversational
    UX, as a "transparent" user experience, still provides a good amount of visual
    aspects that impact the branding of your bot.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一种误解认为机器人没有**视觉品牌**。对话式用户体验作为一种“透明”的用户体验，仍然提供了足够多的视觉元素，这些元素会影响你机器人的品牌形象。
- en: '**Monitor, adapt and improve** — the utterance monitoring log is your friend.
    Use analytics extensively to ask questions about the user''s learning curve —
    How long does it take for the user to understand the scope of the bot?'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控、适应和改进** —— 话语监控日志是你的朋友。广泛使用分析来询问关于用户学习曲线的问题——用户需要多长时间才能理解机器人的功能范围？'
- en: Visual designers spend time on aesthetics and, like them, conversation designers
    spend a lot of time writing content and functionality that fits the scope and
    audience of your bot. We do not speak the way we write, so you can't literally
    turn your website into a bot.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视觉设计师在美学上花费时间，就像他们一样，对话设计师在编写适合你的机器人范围和受众的内容和功能上花费大量时间。我们说话的方式与我们写作的方式不同，所以你不能字面地将你的网站变成一个机器人。
- en: Think about the engagement trio, that is, **Attract-Engage-Delight**. Be very
    crisp and clear about your bot's purpose and core functionality. Surprise your
    users with **Acuity and Serendipity**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到参与三要素，即 **吸引-参与-愉悦**。对你的机器人目的和核心功能要有非常清晰和明确的认识。用 **敏锐和意外** 来惊喜你的用户。
- en: Bots are very **iterative** — you have to keep on improving them as you learn,
    as well as the users. Build the user's trust and confidence slowly. Expose users
    to new functionalities continuously; a welcome area with talks about new features
    is a good idea. Alternatively, suggest new contextual features for original questions.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器人非常 **迭代** —— 你必须随着你的学习和用户的进步不断改进它们。慢慢建立用户的信任和信心。持续向用户展示新功能；一个关于新功能的话题欢迎区是个好主意。或者，为原始问题建议新的上下文功能。
- en: Think of bots as a **gateway** — an interface to services. You still need the
    backend to fulfill the services — queries et al.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将机器人视为 **门户** —— 服务的界面。你仍然需要后端来满足服务——查询等。
- en: Plan for learning from real users and improve your bot. Once your assistant
    is able to handle a few happy path stories, it is time to let it loose into the
    real world to steer the direction of development.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计划从真实用户那里学习并改进你的机器人。一旦你的助手能够处理几个愉快的路径故事，就是让它进入现实世界以引导开发方向的时候了。
- en: Follow **Grice's maxims**, viz. the maxim of quality, the maxim of quantity
    (as informative as required and not more), the maxim of relation (or relevance
    – be relevant), the maxim of manner (be brief and orderly), and the maxim of smartness.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循 **格赖斯准则**，即质量准则、数量准则（如所需的信息量，不要更多）、关系准则（或相关性——保持相关性）、方式准则（简短有序）和智慧准则。
- en: Creating a Custom Chatbot
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义聊天机器人
- en: 'In this section, we will create a custom chatbot to get stock market quotes
    using `GetQuote`. This signals to the bot that, for example, we had to get a stock
    market quote for a given stock ticker symbol, which will reside in a slot named
    **ticker**. The bot will then look up the quote for that ticker symbol from a
    freely available financial API named **IEX**, and will return the information
    to the user via a conversational response:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个自定义聊天机器人，使用 `GetQuote` 获取股票市场报价。这向机器人表明，例如，我们必须为给定的股票代码获取股票市场报价，该报价将驻留在名为
    **ticker** 的槽位中。然后机器人将从名为 **IEX** 的免费金融API中查找该股票代码的报价，并通过对话响应将信息返回给用户：
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A stock ticker symbol is the standard way in which stocks that are traded on
    an exchange, such as the New York Stock Exchange or NASDAQ, are represented. A
    sequence of alphabetical letters represents the company's stock that is being
    traded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 股票代码是表示在交易所（如纽约证券交易所或纳斯达克）交易的股票的标准方式。一系列字母代表正在交易的公司的股票。
- en: '![Figure 4.3: The chatbot’s workflow'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3：聊天机器人工作流程'
- en: '](img/B16061_04_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16061_04_03.jpg)'
- en: 'Figure 4.3: The chatbot''s workflow'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：聊天机器人工作流程
- en: 'We can create a flowchart for this process, as shown in the following diagram.
    Let''s go over it in further detail:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为这个过程创建一个流程图，如下所示。让我们进一步详细地讨论它：
- en: '![Figure 4.4: Flowchart of the chatbot’s workflow'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4：聊天机器人工作流程流程图'
- en: '](img/B16061_04_04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16061_04_04.jpg)'
- en: 'Figure 4.4: Flowchart of the chatbot''s workflow'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：聊天机器人工作流程流程图
- en: '**Recognizing the Intent and Filling the Slot Value**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别意图和填充槽位值**'
- en: As a first step, the bot waits for the user's input in order to recognize a
    valid intent. When it extracts the `GetQuote` intent as the intent from an utterance
    posted by the user, it will then try to fill the required slots. In our case,
    we only have one slot of the `StockTicker` type (which is a custom slot type).
    The bot will issue a prompt, asking the user to provide the value of the slot
    and parse the utterance in response, in order to fill the slot value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，机器人等待用户的输入以识别一个有效的意图。当它从用户发布的言语中提取`GetQuote`意图作为意图时，它将尝试填充所需的槽位。在我们的例子中，我们只有一个`StockTicker`类型的槽位（这是一个自定义槽位类型）。机器人将发出提示，要求用户提供槽位的值，并解析用户响应的言语，以填充槽位值。
- en: Valid slots are those that the system recognizes. If the slot value is not part
    of the list of permitted values, or if the system does not recognize what is entered
    for the slot value, it is said to be `invalid`, or `not valid`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的槽位是系统可以识别的槽位。如果槽位值不是允许值列表的一部分，或者如果系统无法识别输入的槽位值，则称其为`无效`或`非有效`。
- en: If the slot value is not valid, it will go back to trying to fill the slot (at
    least up to the number of times we have specified it should try before giving
    up and going back to the beginning). Once the bot has a slot filled with a valid
    value, it then proceeds to fulfill the intent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果槽位值无效，它将回退到尝试填充槽位（至少尝试到我们指定的次数，然后放弃并返回开始）。一旦机器人用有效值填充了槽位，它就会继续满足意图。
- en: '**Fulfilling the Intent with a Lambda Function**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Lambda函数满足意图**'
- en: While the default fulfillment action is to return the intent and slot value
    to the user so that they can proceed to work with it within their own application,
    we will instead choose to set up a Lambda function on AWS that can handle the
    intent and run the business logic required to fulfill it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当默认的满足动作是将意图和槽值返回给用户，以便他们可以在自己的应用程序中继续处理时，我们选择在AWS上设置一个Lambda函数来处理意图并运行满足该意图所需的企业逻辑。
- en: 'At this point, the bot process running within Lex proceeds to call the `Lambda`
    function, which we have written and specified for fulfillment:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Lex中运行的机器人流程将继续调用我们编写并指定的`Lambda`函数：
- en: '`Lambda_function.Lambda_handler`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lambda_function.Lambda_handler`'
- en: When Lex calls out to the function for fulfillment, it sends a `JSON` payload
    containing various pieces of information about the sender, as well as the intent
    and slot value. The `Lambda_handler()` method parses the intent and slot parameter
    value from the `JSON` payload, and then dispatches another function call to the
    method, which gets the market quote value that we're looking for from the external
    API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当Lex调用函数以满足需求时，它发送一个包含有关发送者、意图和槽位值的各种信息的`JSON`有效负载。`Lambda_handler()`方法从`JSON`有效负载中解析意图和槽位参数值，然后调度另一个函数调用，从外部API获取我们正在寻找的市场报价值。
- en: Finally, the `Lambda` function also packages the response as another `JSON`
    string and returns it to Lex. Lex parses the `JSON` response behind the scenes
    and presents the response message to the user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Lambda`函数还将响应打包为另一个`JSON`字符串，并将其返回给Lex。Lex在幕后解析`JSON`响应，并将响应消息呈现给用户。
- en: We will go through all of these elements in a lot more depth in the next two
    exercises. In the first exercise, we will set up the new chatbot, and in the second
    one, we will implement our Lambda handler function so that it returns back to
    the user the actual value of the market price of the ticker symbol that the user
    asks the bot for.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的两个练习中更深入地探讨所有这些元素。在第一个练习中，我们将设置新的聊天机器人，在第二个练习中，我们将实现我们的Lambda处理程序函数，以便它返回用户请求的股票代码的实际市场价格。
- en: A Bot That Recognizes an Intent and Filling a Slot
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别意图并填充槽位的机器人
- en: In the next exercise, you will create a custom chatbot that recognizes the intent,
    named `GetQuote`, in order to get a market price quote for a given ticker symbol.
    The bot will prompt the user for the value of the ticker symbol that the user
    is interested in, until the slot is filled. You will also learn how to state the
    intent and fill the slot in the same utterance. This chatbot can be tested via
    a conversational interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将创建一个自定义聊天机器人，该机器人可以识别名为`GetQuote`的意图，以便为给定的股票代码获取市场价格报价。机器人将提示用户输入他们感兴趣的股票代码的值，直到槽位被填充。你还将学习如何在同一句话中声明意图和填充槽位。这个聊天机器人可以通过对话界面进行测试。
- en: 'Exercise 4.01: Creating a Bot That Will Recognize an Intent and Fill a Slot'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：创建一个能够识别意图并填充槽位的bot
- en: 'In this exercise, we will create and test an Amazon Lex-based bot with a custom
    intent and slot. The steps that have to be performed to create a bot with a custom
    intent and slot are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建并测试一个基于Amazon Lex的自定义意图和槽位的bot。创建具有自定义意图和槽位的bot必须执行的步骤如下：
- en: The first step is to navigate to `Amazon Lex service` from the Amazon Management
    Console. Usually, this entails going to aws.amazon.com, then **My account**, and
    then clicking **AWS Management Console**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是从亚马逊管理控制台导航到`Amazon Lex服务`。通常，这需要访问aws.amazon.com，然后是**我的账户**，然后点击**AWS管理控制台**。
- en: You can select **Services** by clicking **Amazon Lex** under **Machine Learning**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在**机器学习**下的**Amazon Lex**处点击来选择**服务**。
- en: 'The next step is to select the `Create` button. This will take you to the `bot`
    creation screen:![Figure 4.5: Amazon Lex Console'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是选择`创建`按钮。这将带您进入`bot`创建屏幕：![图4.5：Amazon Lex控制台
- en: '](img/B16061_04_05.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_05.jpg)'
- en: 'Figure 4.5: Amazon Lex Console'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.5：Amazon Lex控制台
- en: 'At this point, you can create a custom bot by clicking the **Custom bot** option
    button. This reveals the bot''s details, which can be filled out, as shown in
    the following screenshot:![Figure 4.6: Custom bot option'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，您可以通过点击**自定义bot**选项按钮来创建一个自定义bot。这将揭示bot的详细信息，可以填写，如下面的截图所示：![图4.6：自定义bot选项
- en: '](img/B16061_04_06.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_06.jpg)'
- en: 'Figure 4.6: Custom bot option'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.6：自定义bot选项
- en: The `bot` name field can be set to `MarketNanny`. The `None. This is only a
    text based application`, because we will only be interacting with the bot with
    text in this section, and not with voice just yet.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bot`名称字段可以设置为`MarketNanny`。这是仅基于文本的应用程序，因为我们在这个部分只会用文本与bot交互，而不会使用语音。'
- en: The session timeout can be set to the default of `5 min`. The IAM role field
    displays the name of the IAM role, which is automatically created by Lex for use
    by bot applications. Let's set `Sentiment Analysis` to `Yes`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 会话超时可以设置为默认的`5分钟`。IAM角色字段显示IAM角色的名称，Lex会自动创建该角色以供bot应用程序使用。让我们将`情感分析`设置为`是`。
- en: Finally, the `COPPA` field pertains to the `No`. If, however, you are a student
    under 13 or intend to have someone under 13 use your chatbot, then you should
    click the `Yes` option instead.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`COPPA`字段与`否`相关。然而，如果您是13岁以下的在校学生或打算让13岁以下的某人使用您的聊天机器人，那么您应该点击`是`选项。
- en: Note
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A law was passed in 1998 to protect the privacy of children under 13\. It states
    that online sites may not collect personal information from users younger than
    13 years of age without parental consent, among other provisions. You can learn
    more about the COPPA act at [https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule](https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule).
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1998年通过了一项法律来保护13岁以下的儿童隐私。它规定，在线网站在没有父母同意的情况下，不得收集13岁以下用户的个人信息，以及其他规定。您可以在[https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule](https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-proceedings/childrens-online-privacy-protection-rule)了解更多关于COPPA法案的信息。
- en: Finally, clicking the `Slot type`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击`槽类型`。
- en: 'Click the `Create Intent` button to bring up an `Add` `Intent` pop-up dialog window:![Figure
    4.7: MarketNanny bot editor'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`创建意图`按钮以弹出`添加意图`对话框：![图4.7：MarketNanny bot编辑器
- en: '](img/B16061_04_07.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_07.jpg)'
- en: 'Figure 4.7: MarketNanny bot editor'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.7：MarketNanny bot编辑器
- en: Conversely, if you already have an intent defined, you can create a new one
    by clicking on the `+` sign next to the `Intents` heading in the left-hand side
    column on the screen.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，如果您已经定义了意图，您可以通过点击屏幕左侧列中`意图`标题旁边的`+`号来创建一个新的意图。
- en: The `Create` `Intent` window offers a few options that we can use to add an
    intent to the bot. The `ZIP` file containing one or more `JSON` files with intents
    in the Lex format.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`创建意图`窗口提供了一些选项，我们可以使用这些选项将意图添加到bot中。包含一个或多个Lex格式意图的`JSON`文件的`ZIP`文件。'
- en: The search for existing intents allows you to reuse the intents that you may
    have defined or imported previously, as well as the built-in intents defined by
    `Amazon Lex`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索现有意图允许您重用您可能之前定义或导入的意图，以及由`Amazon Lex`定义的内置意图。
- en: Click on the `Create Intent` link to get to the dialog box shown in the following
    step.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`创建意图`链接以进入以下步骤中显示的对话框。
- en: 'In the `Create intent` dialog box, name your new intent `GetQuote`. The bot
    will recognize this intent when you let it know that you are interested in a market
    quote. Click the `Add` button to complete this step:![Figure 4.8: Creating an
    intent screen'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`创建意图`对话框中，将您的新意图命名为`GetQuote`。当您告诉机器人您对市场报价感兴趣时，机器人将识别此意图。点击`添加`按钮以完成此步骤：![图4.8：创建意图屏幕
- en: '](img/B16061_04_08.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_08.jpg)'
- en: 'Figure 4.8: Creating an intent screen'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.8：创建意图屏幕
- en: You should be back at the Editor screen at this point, and you should see the
    `GetQuote` intent in the left toolbar portion of the screen, as shown in the following
    screenshot. The Editor screen also contains a number of fields that are used to
    define and customize the new intent.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，您应该回到编辑器屏幕，您应该看到屏幕左侧工具栏部分的`GetQuote`意图，如以下截图所示。编辑器屏幕还包含一些用于定义和自定义新意图的字段。
- en: 'The first thing to do is to fill in some sample utterances to train the `NLU`
    system behind Lex to recognize the utterances you will provide to the bot as signaling
    the `GetQuote` intent:![Figure 4.9: Creating the intent'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的是填写一些样本语句来训练Lex背后的`NLU`系统，以便识别您提供给机器人的语句作为`GetQuote`意图的信号：![图4.9：创建意图
- en: '](img/B16061_04_09.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_09.jpg)'
- en: 'Figure 4.9: Creating the intent'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.9：创建意图
- en: 'After entering some sample utterances, click on the `Build` button near the
    top of the page in order to initiate the training process for the bot:![Figure
    4.10: Building the bot'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入一些样本语句后，点击页面顶部附近的`构建`按钮以启动机器人的训练过程：![图4.10：构建机器人
- en: '](img/B16061_04_10.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_10.jpg)'
- en: 'Figure 4.10: Building the bot'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.10：构建机器人
- en: 'There will be a follow-up dialog box with another `Build` button, which you
    should also click:![Figure 4.11: Build confirmation'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个后续的对话框，其中还有一个`构建`按钮，您也应该点击：![图4.11：构建确认
- en: '](img/B16061_04_11.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_11.jpg)'
- en: 'Figure 4.11: Build confirmation'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.11：构建确认
- en: 'After this, you should wait until you see the `MarketNanny build was successful`
    message box. This might take anything from a few seconds to a couple of minutes:![Figure
    4.12: Bot build is successful'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您应该等待，直到您看到`MarketNanny构建成功`的消息框。这可能需要几秒钟到几分钟的时间：![图4.12：机器人构建成功
- en: '](img/B16061_04_12.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_12.jpg)'
- en: 'Figure 4.12: Bot build is successful'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.12：机器人构建成功
- en: You can test your new intent within the bot in the `Test bot` pane, in the upper
    right-hand corner of the screen.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在屏幕右上角的`测试机器人`面板中测试您的新意图。
- en: Note
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If the Test bot pane is not visible, you may have to click on an arrow button
    in order to expand it and make it visible.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果测试机器人面板不可见，您可能需要点击一个箭头按钮来展开它并使其可见。
- en: 'Type *utterances* into the pane to verify that the bot is able to recognize
    the correct intent from the utterances:![Figure 4.13: Test bot'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板中输入*语句*以验证机器人能否从语句中识别出正确的意图：![图4.13：测试机器人
- en: '](img/B16061_04_13.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_13.jpg)'
- en: 'Figure 4.13: Test bot'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.13：测试机器人
- en: 'You know that it has recognized the intent correctly when it returns the following
    response: `Intent GetQuote is ReadyForFulfillment`. Feel free to experiment with
    different utterances, based on your sample utterances, in order to verify that
    the `GetQuote` intent and flag that it is ready for fulfillment. This is because
    we have not added any slots to the intent.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它返回以下响应时，你知道它已经正确识别了意图：`Intent GetQuote is ReadyForFulfillment`。请随意根据您的样本语句进行实验，以验证`GetQuote`意图及其已准备好执行的状态。这是因为我们尚未为此意图添加任何槽位。
- en: 'Your next step will be to add a slot, along with a custom slot type for the
    slot:![Figure 4.14: Adding a Slot'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的下一步将是添加一个槽位，以及为该槽位添加一个自定义槽位类型：![图4.14：添加槽位
- en: '](img/B16061_04_14.jpg)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_14.jpg)'
- en: 'Figure 4.14: Adding a Slot'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.14：添加槽位
- en: 'Adding a `slot type`. This can be done by pressing the `+` button next to slot
    types in the left toolbar section of the Editor screen. This brings up an `Add
    slot type` dialog box, where we can also choose to import the slot type as before
    with intents by using the Lex `JSON` structure. However, before we do that, we
    will click on the `Create slot type` link to create a new slot type:![Figure 4.15:
    Creating a slot type'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`槽位类型`。这可以通过在编辑器屏幕左侧工具栏部分旁边按下`+`按钮来完成。这会弹出一个`添加槽位类型`对话框，我们也可以选择像之前使用意图一样使用Lex的`JSON`结构来导入槽位类型。然而，在我们这样做之前，我们将点击`创建槽位类型`链接来创建一个新的槽位类型：![图4.15：创建槽位类型
- en: '](img/B16061_04_15.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_15.jpg)'
- en: 'Figure 4.15: Creating a slot type'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.15：创建槽位类型
- en: In the `Add slot type` dialog box that pops up, enter the slot type name as
    `StockTicker`. This is the name of the slot type that we are defining. Optionally,
    you can enter a description in the `Description` field and leave the `Slot Resolution`
    option as `Expand Values`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的`添加槽位类型`对话框中，输入槽位类型名称为`StockTicker`。这是我们正在定义的槽位类型的名称。可选地，你可以在`描述`字段中输入描述，并将`槽位解析`选项保留为`展开值`。
- en: 'Under the `Value` field, enter a few `stock ticker` symbols, as shown in the
    following screenshot, to provide sample values for the `StockTicker` slot type.
    You can add some of your own, as well, if you wish:![Figure 4.16: Adding a slot
    type'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`值`字段下，输入一些`股票代码`符号，如图所示，以提供`StockTicker`槽位类型的示例值。如果你愿意，也可以添加一些自己的：![图 4.16：添加槽位类型
- en: '](img/B16061_04_16.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_16.jpg)'
- en: 'Figure 4.16: Adding a slot type'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.16：添加槽位类型
- en: Finally, click on the `Add` `slot to intent` button in order to add the slot
    type to the intent, and close the dialog.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击`添加` `槽位到意图`按钮，以将槽位类型添加到意图中，并关闭对话框。
- en: We could have also clicked on the `Save slot type` button and added the slot
    to the intent in a separate step, but using the button is the shortcut to accomplishing
    both actions in a single step.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以点击`保存槽位类型`按钮，并在单独的步骤中将槽位添加到意图中，但使用按钮是完成这两个动作的单步快捷方式。
- en: When you close the dialog box, you will find that Lex has added a new slot entry
    as well, under the slots section. It is helpfully prefilled with the `StockTicker`
    slot type, and you should change the name of the slot to ticker under the `Name`
    field for the entry.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你关闭对话框时，你会在槽位部分找到Lex添加的新槽位条目，它有用地预先填充了`StockTicker`槽位类型，你应该在条目的`名称`字段中将槽位名称更改为`ticker`。
- en: 'Click the wheel under the `Prompt` field to expand it to a new dialog box:![Figure
    4.17: Editor dialog box'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`提示`字段下的轮盘，将其展开到一个新的对话框：![图 4.17：编辑对话框
- en: '](img/B16061_04_17.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_17.jpg)'
- en: 'Figure 4.17: Editor dialog box'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.17：编辑对话框
- en: The prompts editor dialog box (named ticker Prompts or ticker Settings) allows
    us to enter prompts for the `Slot`, which the bot will use to store the user `inputs`
    and corresponding sample `utterances` that the user would typically provide to
    the bot while the bot is trying to elicit the information from the user with the
    prompts.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示编辑对话框（命名为股票代码提示或股票代码设置）允许我们为`槽位`输入提示，机器人将使用这些提示来存储用户的`输入`以及用户在机器人试图通过提示从用户那里获取信息时通常会提供给机器人的示例`言语`。
- en: The placement of the slot value within the corresponding utterances for the
    slots is denoted by curly braces `{}` and the name of the slot within the braces.
    In this case, since the slot is named `ticker`, it is denoted by `{ticker}` within
    the sample utterances.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 槽位值在相应言语中的位置由花括号 `{}` 和括号内的槽位名称表示。在这种情况下，由于槽位名称为`ticker`，在示例言语中用 `{ticker}`
    表示。
- en: Fill in the prompts (a single prompt is fine – if you add more prompts, the
    bot will use them randomly, for variety) in the **Prompts** section.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**提示**部分填写提示（一个提示就足够了——如果你添加更多提示，机器人将随机使用它们，以增加多样性）。
- en: Then, add some `utterances` to the Corresponding utterances section, denoting
    the placement of the slot value using the placeholder token of `{ticker}` in each
    sample statement.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在相应的言语部分添加一些`言语`，在每个示例语句中使用占位符令牌 `{ticker}` 表示槽位值。
- en: 'Leave the `Maximum number of retries` field as the default value of `2`. This
    means that it will try to get the value for the slot twice before signaling an `error`:![Figure
    4.18: Ticker prompt screen'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`最大重试次数`字段保留为默认值`2`。这意味着它将尝试获取槽位值两次，然后才会发出错误信号：![图 4.18：股票代码提示屏幕
- en: '](img/B16061_04_18.jpg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_18.jpg)'
- en: 'Figure 4.18: Ticker prompt screen'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.18：股票代码提示屏幕
- en: Next, click the `Save` button to save the slot prompts and the corresponding
    utterances definitions.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`保存`按钮以保存槽位提示和相应的言语定义。
- en: 'Finally, click the `Save` `Intent` button at the bottom of the screen, and
    then the `Build` button at the top of the screen, in order to initiate the training
    process with the new slot and slot type that we have defined. Wait for the completion
    dialog to display when the training is done:![Figure 4.19: Saving the Intent'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击屏幕底部的`保存` `意图`按钮，然后点击屏幕顶部的`构建`按钮，以启动使用我们定义的新槽位和槽位类型的训练过程。等待训练完成后显示完成对话框：![图
    4.19：保存意图
- en: '](img/B16061_04_19.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_19.jpg)'
- en: 'Figure 4.19: Saving the Intent'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.19：保存意图
- en: 'Your updated intent is now ready to be tested in the `Test Bot` pane:![Figure
    4.20: Updated intent test bot'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您更新的意图现在可以在“测试机器人”面板中进行测试：![图4.20：更新后的意图测试机器人
- en: '](img/B16061_04_20.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16061_04_20.jpg]'
- en: 'Figure 4.20: Updated intent test bot'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.20：更新后的意图测试机器人
- en: 'At the end of the bot flow, when all the information it requires has been filled
    in, it returns the intent in the same format as before. However, it follows this
    response line with another line, containing the name and value of the slot parameter:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在机器人流程结束时，当所有需要的信息都已填写完毕，它将以之前相同的格式返回意图。然而，它随后又跟了一条包含槽位参数名称和值的行：
- en: '[PRE0]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This indicates that the ticker Slot has been filled with the `GOOG` value. So,
    that's great; our intent with slot is working.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这表明股票槽位已被填充为`GOOG`值。所以，太好了；我们的带槽位意图正在工作。
- en: While you're having fun playing around with the bot to verify that the intent
    and slot are working as they should, why not try something a little bit different?
    Enter some utterances that are not a part of the sample utterances that you previously
    entered to train the bot.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在与机器人玩耍以验证意图和槽位是否按预期工作的时候，为什么不尝试点不同的事情呢？输入一些不是你之前输入以训练机器人的样本语句的语句。
- en: 'Type `Can I get a market quote?` as your initial utterance and see whether
    the bot can recognize the intent. Bear in mind that the sentence, though similar
    to the sample utterances, is not one of those utterances:![Figure 4.21: Test bot
    screen'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以“我能得到一个市场报价吗？”作为你的初始语句，看看机器人是否能识别出意图。记住，尽管这个句子与样本语句相似，但它并不是那些语句之一：![图4.21：测试机器人屏幕
- en: '](img/B16061_04_21.jpg)'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16061_04_21.jpg]'
- en: 'Figure 4.21: Test bot screen'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.21：测试机器人屏幕
- en: As you can see from the testing shown in the preceding screenshot, not only
    does Lex recognize the correct intent from an utterance it has not been trained
    on, but it also recognizes a new symbol that it has not seen before (ADP) correctly
    as the value for the ticker slot.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，Lex不仅能够从它没有训练过的语句中识别出正确的意图，而且还能正确地将它之前没有见过的符号（ADP）识别为股票槽位的值。
- en: 'Now, let''s try a conversational form of a corresponding utterance for the
    slot prompt by inserting a random interjection as a part of the sentence, again
    using a new ticker symbol (`VZ`) that the bot has not been previously trained
    on. Again, it is correctly processed and recognized:![Figure 4.22: Test bot screen'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过在句子中插入一个随机的插入语作为句子的一部分，来为槽位提示尝试一种对应的对话形式，再次使用一个新股票代码符号（`VZ`），这个符号是机器人之前没有训练过的。再次，它被正确处理和识别：![图4.22：测试机器人屏幕
- en: '](img/B16061_04_22.jpg)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16061_04_22.jpg]'
- en: 'Figure 4.22: Test bot screen'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：测试机器人屏幕
- en: Clearly, quite a bit of flexibility is possible between training and realworld
    examples of conversational input with an NLU engine.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在训练和真实世界的对话输入之间，使用NLU引擎有很大的灵活性。
- en: Natural Language Understanding Engine
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然语言理解引擎
- en: NLU demonstrates the advantage of using an NLU engine that has been trained
    on a huge set of conversational sentences and has formed a large inference model.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: NLU展示了使用在大量对话句子上训练并形成大型推理模型的NLU引擎的优势。
- en: It is able to connect sentences that are not the same as the ones it has specifically
    been trained on. In fact, they can be significantly different, but the model is
    large enough to infer that the semantic meanings are similar.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它能够连接与它专门训练的句子不同的句子。事实上，它们可以非常不同，但模型足够大，可以推断出语义含义是相似的。
- en: 'There is one more trick that you can use to make it easier for the user to
    interact with your bot. You can fill the slot value with the same utterance as
    the one that establishes intent. This can be accomplished by simply including
    the slot placeholder token (`{ticker}`, in this case) in your sample utterances.
    Perform the following steps to do so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个技巧来让用户更容易与你的机器人互动。你可以用建立意图的相同语句填充槽位值。这可以通过简单地包括槽位占位符令牌（在这个例子中是`{ticker}`）在你的样本语句中来实现。执行以下步骤：
- en: 'Add a new sample utterance to your `GetQuote` intent, as follows:![Figure 4.23:
    GetQuote screen'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式向您的`GetQuote`意图添加一个新的样本语句：![图4.23：GetQuote屏幕
- en: '](img/B16061_04_23.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16061_04_23.jpg]'
- en: 'Figure 4.23: GetQuote screen'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.23：GetQuote屏幕
- en: 'The `ticker` placeholder token denotes that the slot may be filled directly
    within the initial utterance, and that, in this case, a prompt doesn''t need to
    be generated:![Figure 4.24: Build screen for the bot'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ticker`占位符标记表示该槽位可以直接在初始话语中填充，并且在这种情况下，不需要生成提示：![图4.24：机器人的构建屏幕'
- en: '](img/B16061_04_24.jpg)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_24.jpg)'
- en: 'Figure 4.24: Build screen for the bot'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.24：机器人的构建屏幕'
- en: 'Click on the `Build` button to train your updated intent as before, and then
    test it in the `Test Bot` pane, as follows:![Figure 4.25: Test Bot screen'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“构建”按钮，像以前一样训练您的更新意图，然后在“测试机器人”面板中测试它，如下所示：![图4.25：测试机器人屏幕
- en: '](img/B16061_04_25.jpg)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_25.jpg)'
- en: 'Figure 4.25: Test Bot screen'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25：测试机器人屏幕'
- en: You can see that the intent is ready for fulfillment and that the slot value
    is filled appropriately, in a single step.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到意图已准备好满足，并且槽位值已适当填充，只需一步即可。
- en: We have now gone through the process of defining a custom chatbot, complete
    with a custom intent, slot type, and slot, within Amazon Lex. Furthermore, we
    have trained and tested the bot to verify that it is able to classify the correct
    intent and correctly infer the slot values from conversational input to a high
    degree of accuracy.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了在Amazon Lex中定义自定义聊天机器人的过程，包括自定义意图、槽位类型和槽位。此外，我们还训练并测试了机器人，以验证它能够以高度准确度对正确的意图进行分类，并从会话输入中正确推断槽位值。
- en: Finally, we added a shortcut method to fill in the slot value directly in the
    initial utterance by inserting the placeholder token for the slot value in the
    sample utterance to train the NLU engine behind Lex.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一种快捷方法，通过在训练NLU引擎的示例话语中插入槽位值的占位符标记，直接在初始话语中填充槽位值。
- en: Lambda Function – Implementing Business Logic
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数 - 实现业务逻辑
- en: You can create AWS Lambda functions that can be triggered from your Amazon Lex
    bot. As we discussed in *Chapter 2*, *Analyzing Documents and Text with Natural
    Language Processing*, serverless computing and Lambda functions are a good match
    for implementing the fulfillment and validation functions in your Lex bot. The
    Lambda functions integrate better and faster and scale better than returning the
    intent to a backend application for every step, such as validation. Once the intent
    has been validated and you are satisfied with the parameters, you can call a backend
    API to fulfill the request. You can implement simple fulfillment requests as Lambda
    functions, thereby making your bot responsive and scalable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建AWS Lambda函数，这些函数可以从您的Amazon Lex机器人触发。正如我们在*第2章*中讨论的，*使用自然语言处理分析文档和文本*，无服务器计算和Lambda函数非常适合在Lex机器人中实现满足和验证功能。Lambda函数与返回到后端应用程序的每个步骤（如验证）相比，集成更好、更快，并且扩展性更好。一旦验证了意图并且您对参数满意，您就可以调用后端API来满足请求。您可以将简单的满足请求实现为Lambda函数，从而使您的机器人响应迅速且可扩展。
- en: In the next exercise, you will learn how to implement the business logic behind
    the bot as a Lambda function in AWS and call a real-world REST API to get information
    that you can return to the user from an external service.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将学习如何在AWS中将机器人的业务逻辑作为Lambda函数实现，并调用一个真实的REST API以获取您可以从外部服务返回给用户的信息。
- en: 'Exercise 4.02: Creating a Lambda Function to Handle Chatbot Fulfillment'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：创建处理聊天机器人满足的Lambda函数
- en: 'In this exercise, we will handle chatbot fulfillment business logic with a
    `Lambda` function that is created and deployed on AWS. In the previous exercise,
    we created a chatbot with a `GetQuote` intent and ticker slot. Perform the following
    steps to implement business logic:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用在AWS上创建和部署的`Lambda`函数来处理聊天机器人满足业务逻辑。在前一个练习中，我们创建了一个具有`GetQuote`意图和`ticker`槽位的聊天机器人。执行以下步骤以实现业务逻辑：
- en: Navigate to the **AWS Lambda** screen via **AWS Management Console – Services**
    and then **Lambda** under **Compute**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**AWS管理控制台 - 服务**导航到**计算**下的**AWS Lambda**屏幕。
- en: 'If you have never used Lambda before, you should be presented with a welcome screen:![Figure
    4.26: AWS Lambda start up screen'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过Lambda，您应该会看到一个欢迎屏幕：![图4.26：AWS Lambda启动屏幕
- en: '](img/B16061_04_26.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_26.jpg)'
- en: 'Figure 4.26: AWS Lambda start up screen'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.26：AWS Lambda启动屏幕
- en: Click the `Create a function` button to get started.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建函数”按钮开始。
- en: 'Select the `Author from scratch` option on the next page:![Figure 4.27: Selecting
    an author'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页选择“从零开始创建作者”选项：![图4.27：选择作者
- en: '](img/B16061_04_27.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_27.jpg)'
- en: 'Figure 4.27: Selecting an author'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.27：选择作者'
- en: 'For the runtime, choose `Python 3.6` from the drop-down menu as you will be
    implementing the handler in the Python language for this exercise. In the `Name`
    field, fill in `marketNannyHandler`:![Figure 4.28: Filling in the values'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于运行时，从下拉菜单中选择 `Python 3.6`，因为你将在这个练习中使用 Python 语言实现处理程序。在 `Name` 字段中填写 `marketNannyHandler`：![图
    4.28：填写值
- en: '](img/B16061_04_28.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_28.jpg)'
- en: 'Figure 4.28: Filling in the values'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.28：填写值
- en: 'Click `Choose or create an execution role` and choose the role field. Then,
    choose the `Create a new role from AWS policy templates` radio button:![Figure
    4.29: Role selection screen'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Choose or create an execution role` 并选择角色字段。然后，选择 `Create a new role from
    AWS policy templates` 单选按钮：![图 4.29：角色选择屏幕
- en: '](img/B16061_04_29.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_29.jpg)'
- en: 'Figure 4.29: Role selection screen'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.29：角色选择屏幕
- en: 'Enter the name `marketNannyProcessorRole` in the `Role name` field. Then, click
    the `Create function` button to create the Lambda function in AWS. You should
    see a confirmation screen, as follows:![Figure 4.30: Confirmation screen'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Role name` 字段中输入名称 `marketNannyProcessorRole`。然后，点击 `Create function` 按钮在
    AWS 中创建 Lambda 函数。你应该会看到一个确认屏幕，如下所示：![图 4.30：确认屏幕
- en: '](img/B16061_04_30.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16061_04_30.jpg)'
- en: 'Figure 4.30: Confirmation screen'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30：确认屏幕
- en: In this exercise, you learned how to handle chatbot fulfillment business logic
    with a Lambda function created and deployed on AWS.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了如何使用在 AWS 上创建和部署的 Lambda 函数处理聊天机器人满足业务逻辑。
- en: Implementing the Lambda Function
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Lambda函数
- en: 'Here, you will use the Lambda Function editor entirely in-line, which means
    that you can enter and modify the code directly without having to upload any files
    to AWS. The code that you enter will be executed when the Lambda function is invoked:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将完全在行内使用 Lambda 函数编辑器，这意味着你可以直接输入和修改代码，而无需将任何文件上传到 AWS。你输入的代码将在 Lambda
    函数被调用时执行：
- en: '![Figure 4.31: Function code screen'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.31：函数代码屏幕'
- en: '](img/B16061_04_31.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16061_04_31.jpg)'
- en: 'Figure 4.31: Function code screen'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31：函数代码屏幕
- en: First, let's look at the structure of the Lambda function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 Lambda 函数的结构。
- en: 'When you created the `marketNannyHandler` function, AWS created a folder with
    the same name, with a Python file named `Lambda_function.py` within the folder.
    This file contains a stub for the `Lambda_handler` function, which is the entry
    point of our Lambda function. The entry point takes two parameters as arguments:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 `marketNannyHandler` 函数时，AWS 创建了一个具有相同名称的文件夹，文件夹中包含一个名为 `Lambda_function.py`
    的 Python 文件。这个文件包含 `Lambda_handler` 函数的占位符，这是我们的 Lambda 函数的入口点。入口点接受两个参数作为参数：
- en: The event argument provides the value of the payload that is sent to the function
    from the calling process. It typically takes the form of a Python `dict` type,
    although it could also be one of `list`, `str`, `int`, `float`, or `NoneType`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件参数提供了从调用进程发送到函数的负载值。它通常以 Python `dict` 类型的形式出现，尽管它也可能是 `list`、`str`、`int`、`float`
    或 `NoneType` 之一。
- en: The context argument is of the `LambdaContext` type and contains runtime information.
    You will not be using this parameter in this exercise.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文参数是 `LambdaContext` 类型，包含运行时信息。在这个练习中你将不会使用此参数。
- en: The return value of the function can be of any type that is serializable by
    `JSON`. This value is returned to the calling application after serializing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值可以是 `JSON` 可序列化的任何类型。这个值在序列化后返回给调用应用程序。
- en: Input Parameter Structure
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入参数结构
- en: 'Now, let''s take a closer look at the structure of the event argument that
    gets passed to the `Lambda_handler` function. If we are asking for a market quote
    with a ticker value of `GOOG`, the `JSON` value of the intent section within the
    parameter will appear as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看传递给 `Lambda_handler` 函数的事件参数的结构。如果我们请求一个具有 `GOOG` 标记值的股票报价，参数中意图部分的
    `JSON` 值将如下所示：
- en: '[PRE1]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The relevant values that we are interested in for processing are `name` and
    the single `ticker` value within the `slots` section under `currentIntent`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在处理过程中感兴趣的相关值是 `name` 和 `currentIntent` 下的 `slots` 部分中的单个 `ticker` 值。
- en: 'Since our `JSON` input gets converted to a Python dictionary, we can obtain
    these values within the Lambda function as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `JSON` 输入被转换为 Python 字典，我们可以在 Lambda 函数中如下获取这些值：
- en: '[PRE2]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implementing the High-Level Handler Function
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现高级处理函数
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `lambda_function.py` file contains the full source code. It is available
    on GitHub at [https://packt.live/2O8TUwA](https://packt.live/2O8TUwA). You can
    refer to it as you type in the code in the Lambda editor. We have included debugging
    tips at the end of this example. It might be a good idea to read through the example
    as well as the tips first before you start implementing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in implementing our handler is to identify the intent name and
    call the corresponding function that implements it. The pseudocode for this looks
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is sufficiently complete to actually be tested against your chatbot at
    this point, if you so desire, but let's press on with the implementation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'To test, you should add a test event, as shown in the instructions that follow:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `Configure test events`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32: Configure test events drop-down box'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16061_04_32.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.32: Configure test events drop-down box'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit it as shown here. The Lambda function requires the JSON structure as shown:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33: Editing the Lambda test event'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16061_04_33.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.33: Editing the Lambda test event'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Function to Retrieve the Market Quote
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step will be to implement the `get_quote` function, which does the
    work of actually getting the market quote information and returning it to the
    calling handler function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that we have named the parameter request, so the `object` event to which
    we send the function is referred to as a request within this function. It contains
    the same value and structure, just renamed. Therefore, we can get the value of
    the ticker Slot, as mentioned previously, by getting the value of the item with
    the `ticker` key under it by using the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, we call the `call_quote_api()` function to retrieve the value of the market
    quote for the value of the ticker item. We haven't implemented `call_quote_api()`
    yet, so let's do this next.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement the `call_quote_api` function as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, ticker is the value of the ticker parameter (in this specific example,
    it would be `GOOG`). We use Alpha Vantage, which provides a static endpoint on
    the internet at [https://www.alphavantage.co/](https://www.alphavantage.co/),
    to retrieve a quote. We have also captured a sample response as an example. You
    should get your own API key.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Since it is implemented as a simple `GET` request, with the ticker parameter
    embedded within the `URL`, with the API key, we can simply use the built-in `urlopen`
    method in the `urllib.request` module (which we will have to remember to import)
    to receive a response from the URL with the ticker embedded within it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Since the response is also in `JSON` format, we need to import `json module`
    and load the response using the `json.load` function. The only field we are interested
    in within the response is `05\. price`, so we return that as the return value
    from our function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Returning the Information to the Calling App (the Chatbot)
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the market quote value, we can return it to our calling application,
    which is the chatbot that we implemented. We have to do a couple of small things,
    however, to return this value. First, we need to format it as a conversational
    response, as shown in the following string:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了市场报价值，我们可以将其返回到我们的调用应用程序，即我们实现的聊天机器人。然而，我们还需要做一些小事情来返回这个值。首先，我们需要将其格式化为对话响应，如下面的字符串所示：
- en: '[PRE7]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This should let the chatbot display the following message:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让聊天机器人显示以下消息：
- en: '[PRE8]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is one final step, which is to construct an `Amazon Lex` `JSON` return
    format that contains our message and a couple of other items of information. We
    will use the `close` helper function to do this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是构建一个包含我们的消息和其他一些信息的`Amazon Lex` `JSON`返回格式。我们将使用`close`辅助函数来完成此操作：
- en: '[PRE9]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our `close` function takes a single parameter, which is the string that we wish
    to return to the chatbot (in this case, this is the value of the message variable).
    It generates a `JSON` wrapper around the content, which conforms to the structure
    that our Lex-based bot is expecting and from which it can extract the content
    and deliver it to the user. The structure of the wrapper is not important at this
    stage, but if you are curious, you can look at the implementation of the `close`
    function. As we mentioned earlier, the `lambda-function.py` file contains the
    full source code for the lambda function. It is available in GitHub at [https://packt.live/2O8TUwA](https://packt.live/2O8TUwA).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`close`函数接受一个参数，即我们希望返回给聊天机器人的字符串（在这种情况下，这是消息变量的值）。它生成一个围绕内容的`JSON`包装器，符合我们的基于Lex的机器人所期望的结构，并从中提取内容并将其交付给用户。包装器的结构在此阶段并不重要，但如果你想了解，可以查看`close`函数的实现。如我们之前提到的，`lambda-function.py`文件包含Lambda函数的完整源代码。它可在GitHub上找到，网址为[https://packt.live/2O8TUwA](https://packt.live/2O8TUwA)。
- en: 'The code window should look as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 代码窗口应如下所示：
- en: '![Figure 4.34: Code window'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34：代码窗口'
- en: '](img/B16061_04_34.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_34.jpg)'
- en: 'Figure 4.34: Code window'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34：代码窗口
- en: Connecting to the Chatbot
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到聊天机器人
- en: 'At this point, the only task remaining is to connect the Lambda function to
    the chatbot and test it. Perform the following steps to do so:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一剩下的任务是将Lambda函数连接到聊天机器人并测试它。执行以下步骤来完成此操作：
- en: 'Navigate back to the Amazon Lex dashboard and select the `MarketNanny` bot:![Figure
    4.35: Connecting to the bot'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到Amazon Lex仪表板并选择`MarketNanny`机器人：![图4.35：连接到机器人
- en: '](img/B16061_04_35.jpg)'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_35.jpg)'
- en: 'Figure 4.35: Connecting to the bot'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.35：连接到机器人
- en: 'Then, scroll down to the `Fulfillment` section and select the `AWS Lambda function`
    option. Next, select the `marketNannyHandler` function from the `Lambda function`
    drop-down menu and leave `Version or alias` as the default value of `Latest`:![Figure
    4.36: Confirmation prompt'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向下滚动到`Fulfillment`部分并选择`AWS Lambda函数`选项。接下来，从`Lambda函数`下拉菜单中选择`marketNannyHandler`函数，并将`版本或别名`保留为默认值`最新`：![图4.36：确认提示
- en: '](img/B16061_04_36.jpg)'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_36.jpg)'
- en: 'Figure 4.36: Confirmation prompt'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.36：确认提示
- en: 'Rebuild the intent by clicking on the `Build` buttons, and test the chatbot
    together with the Lambda handler in the Test Chatbot pane:![Figure 4.37: Chatbot
    updated'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`构建`按钮重建意图，并在测试聊天机器人面板中与Lambda处理程序一起测试聊天机器人：![图4.37：聊天机器人更新
- en: '](img/B16061_04_37.jpg)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_37.jpg)'
- en: 'Figure 4.37: Chatbot updated'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.37：聊天机器人更新
- en: 'The following screenshot shows the interaction with the bot to find out the
    current price of AAPL:![Figure 4.38: Chatbot updated'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了与机器人交互以查找AAPL当前价格的过程：![图4.38：聊天机器人更新
- en: '](img/B16061_04_38.jpg)'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_38.jpg)'
- en: 'Figure 4.38: Chatbot updated'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38：聊天机器人更新
- en: Debugging Tips
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试技巧
- en: 'Here are some debugging tips that will help you:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些调试技巧可以帮助你：
- en: 'The logs from the monitoring tab on the Lambda pane are very useful:![Figure
    4.39: CloudWatch metrics'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda面板上的监控标签页的日志非常有用：![图4.39：CloudWatch指标
- en: '](img/B16061_04_39.jpg)'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_39.jpg)'
- en: 'Figure 4.39: CloudWatch metrics'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.39：CloudWatch指标
- en: 'The logs are collected at the `CloudWatch` Logs insight:![Figure 4.40: CloudWatch
    logs insights'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志收集在`CloudWatch`日志洞察中：![图4.40：CloudWatch日志洞察
- en: '](img/B16061_04_40.jpg)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_40.jpg)'
- en: 'Figure 4.40: CloudWatch logs insights'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.40：CloudWatch日志洞察
- en: 'As you can see, this took us quite a few attempts. we used print statements
    inside the Lambda that print out the contents. A couple of sample logs can be
    seen in the following screenshot, along with the printout of the request JSON
    from the Lex bot, as well as the http response from the stock quote API. This
    makes it easy to see where the various information pieces are nested:![Figure
    4.41: CloudWatch logs with output from print statements'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，这需要我们进行多次尝试。我们在Lambda中使用了print语句来打印内容。以下屏幕截图显示了几个示例日志，以及Lex机器人的请求JSON的打印输出，以及来自股票报价API的http响应。这使得很容易看到各种信息片段是如何嵌套的：![图4.41：CloudWatch日志显示print语句的输出
- en: '](img/B16061_04_41.jpg)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_41.jpg)'
- en: 'Figure 4.41: CloudWatch logs with output from print statements'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.41：CloudWatch日志显示print语句的输出'
- en: 'You can see an error that I encountered in the following screenshot. The stock
    API returns the values in a nested JSON, so you have to use the `response [''Global
    Quote'']["05\. price"]`, and not just the response `["05\. price"]:`![Figure 4.42:
    CloudWatch logs showing KeyError'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在下面的屏幕截图看到我遇到的一个错误。股票API以嵌套JSON的形式返回值，因此你必须使用`response ['Global Quote']["05\.
    price"]`，而不是仅仅使用`response ["05\. price"]:`![图4.42：CloudWatch日志显示KeyError
- en: '](img/B16061_04_42.jpg)'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B16061_04_42.jpg)'
- en: 'Figure 4.42: CloudWatch logs showing KeyError'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.42：CloudWatch日志显示KeyError'
- en: The Lambda logs are extremely useful and capture the errors. Develop incrementally
    and test every change. If there are too many moving parts or changes, debugging
    will be difficult.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda日志非常实用，能够捕捉错误。逐步开发并测试每一个变更。如果变动部分太多或变化频繁，调试将会变得困难。
- en: It will take a little time to get used to the various consoles of the AWS ecosystem,
    understand the permissions, and so on, but if you persist, you will reap the benefits.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适应AWS生态系统中的各种控制台、理解权限等需要一点时间，但如果你坚持不懈，你将收获好处。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with an introduction to Conversational Artificial Intelligence
    and learned how different aspects of this technology help us build a good, useful
    chatbot. We also learned some core concepts, such as utterances, intents, plots,
    and so on, that serve as the foundation for building a chatbot. Later, right before
    we built our first chatbot, we discussed some best practices that come in handy
    while designing Conversational AI. Equipped with this knowledge, we performed
    an exercise to create a bot to recognize intent and fill a slot to retrieve stock
    prices. We then created a Lambda function in AWS to help us implement the business
    logic behind the bot. In the next chapter, we will learn how to use speech with
    chatbots.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章从对话式人工智能的介绍开始，学习了该技术的不同方面如何帮助我们构建一个良好、有用的聊天机器人。我们还学习了一些核心概念，如话语、意图、情节等，这些是构建聊天机器人的基础。随后，在我们构建第一个聊天机器人之前，我们讨论了一些在设计对话式人工智能时非常有用的最佳实践。有了这些知识，我们进行了一次练习，创建了一个能够识别意图并填充槽位以检索股票价格的机器人。然后我们在AWS中创建了一个Lambda函数，帮助我们实现机器人的业务逻辑。在下一章中，我们将学习如何使用语音与聊天机器人交互。
