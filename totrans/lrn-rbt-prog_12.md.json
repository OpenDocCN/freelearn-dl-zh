["```py\n    from Raspi_MotorHAT.Raspi_PWM_Servo_Driver import PWM\n    import atexit\n    ```", "```py\n    pwm = PWM(0x6f)\n    ```", "```py\n    # This sets the timebase for it all\n    pwm_frequency = 100\n    pwm.setPWMFreq(pwm_frequency)\n    ```", "```py\n    m or p means far less than servo_mid_point_ms.\n    ```", "```py\n    # What a deflection of 90 degrees is in pulse length in milliseconds\n    deflect_90_in_ms = 0.5\n    ```", "```py\n    # Frequency is 1 divided by period, but working ms, we can use 1000\n    period_in_ms = 1000 / pwm_frequency\n    # The chip has 4096 steps in each period.\n    pulse_steps = 4096\n    # Steps for every millisecond.\n    steps_per_ms = pulse_steps / period_in_ms \n    ```", "```py\n    # Steps for a degree.\n    steps_per_degree = (deflect_90_in_ms * steps_per_ms) / 90\n    # Mid-point of the servo in steps\n    servo_mid_point_steps = servo_mid_point_ms * steps_per_ms\n    ```", "```py\n    def convert_degrees_to_steps(position):\n        return int(servo_mid_point_steps + (position * steps_per_degree))\n    ```", "```py\n    atexit.register(pwm.setPWM, 0, 0, 4096)\n    ```", "```py\n    while True:\n        position = int(input(\"Type your position in degrees (90 to -90, 0 is middle): \"))\n    ```", "```py\n        end_step = convert_degrees_to_steps(position)\n    ```", "```py\n        pwm.setPWM(0, 0, end_step)\n    ```", "```py\n    deflect_90_in_ms so that it can be overridden with the value obtained while calibrating your servos.\n    ```", "```py\n         \"\"\"addr: The i2c address of the PWM chip.\n    deflect_90_in_ms: set this to calibrate the servo motors. \n         it is what a deflection of 90 degrees is\n         in terms of a pulse length in milliseconds.\"\"\"\n    ```", "```py\n            self._pwm = PWM(addr)\n            # This sets the timebase for it all\n            pwm_frequency = 100\n            self._pwm.setPWMFreq(pwm_frequency)\n            # Mid-point of the servo pulse length in milliseconds.\n            servo_mid_point_ms = 1.5\n            # Frequency is 1/period, but working ms, we can use 1000\n            period_in_ms = 1000 / pwm_frequency\n            # The chip has 4096 steps in each period.\n            pulse_steps = 4096\n            # Steps for every millisecond.\n            steps_per_ms = pulse_steps / period_in_ms\n            # Steps for a degree\n            self.steps_per_degree = (deflect_90_in_ms * steps_per_ms) / 90\n            # mid-point of the servo in steps\n            self.servo_mid_point_steps = servo_mid_point_ms * steps_per_ms\n    ```", "```py\n            # Map for channels\n            self._channels = [0, 1, 14, 15]\n    ```", "```py\n        def stop_all(self):\n            # 0 in start is nothing, 4096 sets the OFF bit.\n            off_bit = 4096\n            self._pwm.setPWM(self.channels[0], 0, off_bit)\n            self._pwm.setPWM(self.channels[1], 0, off_bit)\n            self._pwm.setPWM(self.channels[2], 0, off_bit)\n            self._pwm.setPWM(self.channels[3], 0, off_bit)\n    ```", "```py\n        def _convert_degrees_to_steps(self, position):\n            return int(self.servo_mid_point_steps + (position * self.steps_per_degree))\n    ```", "```py\n        def set_servo_angle(self, channel, angle):\n            \"\"\"position: The position in degrees from the center. -90 to 90\"\"\"        \n    ```", "```py\n            # Validate\n            if angle > 90 or angle < -90:\n                raise ValueError(\"Angle outside of range\")\n    ```", "```py\n          # Then set the position\n          off_step = self._convert_degrees_to_steps(angle)\n          self._pwm.setPWM(self.channels[channel], 0, off_step)\n    ```", "```py\n    import leds_led_shim\n    from servos import Servos\n    ...\n    ```", "```py\n    class Robot:\n        def __init__(self, motorhat_addr=0x6f):\n           # Setup the motorhat with the passed in address\n           self._mh = Raspi_MotorHAT(addr=motorhat_addr)\n           # get local variable for each motor\n           self.left_motor = self._mh.getMotor(1)\n           self.right_motor = self._mh.getMotor(2)\n           # Setup the Leds\n           self.leds = leds_led_shim.Leds()\n           # Set up servo motors for pan and tilt.\n           self.servos = Servos(addr=motorhat_addr)\n           # ensure the motors get stopped when the code exits\n           atexit.register(self.stop_all)\n    ...\n    ```", "```py\n        def stop_all(self):\n            self.stop_motors()\n            # Clear the display\n            self.leds.clear()\n            self.leds.show()\n            # Reset the servos\n            self.servos.stop_all()\n    ...\n    ```", "```py\n        def set_pan(self, angle):\n            self.servos.set_servo_angle(1, angle)\n\n        def set_tilt(self, angle):\n            self.servos.set_servo_angle(0, angle)\n    ```", "```py\n    math library as we are going to use sine and cosine to calculate that circle.\n    ```", "```py\n    class CirclePanTiltBehavior:\n        def __init__(self, the_robot):\n            self.robot = the_robot\n    ```", "```py\n            self.current_time = 0\n            self.frames_per_circle = 50\n    ```", "```py\n    radians_per_frame.\n    ```", "```py\n            self.radius = 30\n    ```", "```py\n        def run(self):\n            while True:\n    ```", "```py\n                frame_number = self.current_time % self.frames_per_circle\n    ```", "```py\n                frame_in_radians = frame_number * self.radians_per_frame\n    ```", "```py\n                self.robot.set_pan(self.radius * math.cos(frame_in_radians))\n                self.robot.set_tilt(self.radius * math.sin(frame_in_radians))\n    ```", "```py\n                sleep(0.05)\n                self.current_time += 1\n    ```", "```py\n        def run(self):\n            while True:\n                frame_number = self.current_time % self.frames_per_circle\n                frame_in_radians = frame_number * self.radians_per_frame\n                self.robot.set_pan(self.radius * math.cos(frame_in_radians))\n                self.robot.set_tilt(self.radius * math.sin(frame_in_radians))\n                sleep(0.05)\n                self.current_time += 1\n    ```", "```py\n    bot = Robot()\n    behavior = CirclePanTiltBehavior(bot)\n    behavior.run()\n    ```", "```py\n$ sudo apt update\n$ sudo apt install libatlas3-base libgfortran5\n```", "```py\n$ pip3 install matplotlib\n```", "```py\n    import time\n    import math\n    import matplotlib.pyplot as plt\n    from robot import Robot\n    ```", "```py\n    start_scan =0\n    lower_bound = -90\n    upper_bound = 90\n    scan_step = 5\n    ```", "```py\n    the_robot = Robot()\n    the_robot.set_tilt(0)\n    ```", "```py\n    scan_data = {}\n    ```", "```py\n    for facing in range(lower_bound, upper_bound, scan_step):\n    ```", "```py\n        the_robot.set_pan(-facing)\n        time.sleep(0.1)\n    ```", "```py\n        scan_data[facing] = the_robot.left_distance_sensor.distance * 100\n    ```", "```py\n    axis = [math.radians(facing) for facing in scan_data.keys()]\n    ```", "```py\n    plt.polar(axis, list(scan_data.values()), 'g-')\n    ```", "```py\n    plt.savefig(\"scan.png\")\n    ```", "```py\n    print(axis)\n    print(scan_data.values())\n    ```"]