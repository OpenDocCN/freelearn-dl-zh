- en: '*Chapter 3*: Randomness and Probability'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：随机性和概率'
- en: In this chapter, we will look at how we can apply the concepts of probability
    and randomness to game AI. Because we will talk more about the use of randomness
    in game AI and less about Unity3D, we can apply the concepts of this chapter to
    any game development middleware or technology framework. We'll be using Mono C#
    in Unity3D for the demos, but we won't address much on the specific features of
    the Unity3D engine and the editor itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将概率和随机性的概念应用于游戏人工智能。因为我们将会更多地讨论随机性在游戏人工智能中的应用，而不是Unity3D，所以我们可以将本章的概念应用于任何游戏开发中间件或技术框架。我们将使用Unity3D中的Mono
    C#进行演示，但不会过多涉及Unity3D引擎和编辑器的具体功能。
- en: Game developers use probability to add a little uncertainty to the behaviors
    of AI characters and the wider game world. Randomness makes artificial intelligence
    look more realistic and natural, and it is the perfect "spice" for all those cases
    in which we do not need *intentional* predictability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发者使用概率为人工智能角色的行为和更广泛的游戏世界添加一些不确定性。随机性使人工智能看起来更加真实和自然，它是那些我们不需要*有意*可预测性的所有情况的完美“调味品”。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Introducing randomness in Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中引入随机性
- en: Learning the basics of probability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习概率的基本知识
- en: Exploring more examples of probability in games
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索游戏中更多概率的例子
- en: Creating a slot machine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个老虎机
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 3` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter03).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要Unity3D 2022。你可以在本书仓库中的`第3章`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter03)。
- en: Introducing randomness in Unity
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中引入随机性
- en: Game designers and developers use randomness in game AI to make a game and its
    characters more realistic by altering the outcomes of characters' decisions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计师和开发者使用随机性在游戏人工智能中，通过改变角色决策的结果，使游戏及其角色更加真实。
- en: Let's take an example of a typical soccer game. One of the rules of a soccer
    game is to award a direct free kick to a team if one opposing team player commits
    a foul while trying to retake control of the ball. However, instead of giving
    a free kick whenever that foul happens, the game developer can apply a probability
    to reward only 98% of all the fouls with a direct free kick.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一场典型的足球比赛为例。足球比赛的一条规则是，如果一方球员在试图夺回球权时犯规，将判给对方直接任意球。然而，游戏开发者可以应用概率，只对98%的所有犯规判给直接任意球。
- en: After all, in reality, referees make mistakes sometimes. As a result of this
    simple change, the player usually gets a direct free kick as expected. Still,
    when that remaining two percent happens, the game provides more emotional feedback
    to both teams (assuming that you are playing against another human, one player
    will be happy while the other will complain with the virtual referee).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，裁判有时也会犯错误。由于这个简单的改变，玩家通常可以得到预期的直接任意球。然而，当剩下的两百分之一发生时，游戏为两队提供更多的情感反馈（假设你在与另一名人类玩家对战，一名玩家会感到高兴，而另一名玩家会向虚拟裁判抱怨）。
- en: Of course, randomness is not always a desirable perk of AI. As we anticipated
    in the introduction, some level of predictability allows players to learn the
    AI patterns, and understanding the AI patterns is often the main component of
    gameplay. For example, in a stealth game, learning the enemy guards' paths is
    necessary to allow the player to find a sneaking route. Or imagine you need to
    design a boss for a game such as *Dark Souls*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随机性并不总是人工智能所期望的附加功能。正如我们在引言中所预期的，一定程度的可预测性允许玩家学习人工智能模式，而理解人工智能模式通常是游戏玩法的主要组成部分。例如，在潜行游戏中，学习敌方守卫的路径对于玩家找到潜行路线是必要的。或者想象你需要为像《黑暗之魂》这样的游戏设计一个Boss。
- en: 'Learning the big boss attack patterns is the player''s primary weapon and the
    only proper way to achieve mastery for boss fights. As always, you have to follow
    the polar star of game design: do only what it is fun for the player. If adding
    randomness adds only frustration for the players, then you should remove it without
    exceptions.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, a bit of randomness is useful, and for some games, such
    as gambling minigames, it is a necessary prerequisite. In those cases, how can
    a computer produce random values? And more importantly, how can we use random
    numbers in Unity?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Randomness in computer science
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computers are deterministic machines: by design, if we give a computer the
    same input multiple times, in the form of program code and data, it always returns
    the same output. Therefore, how can we have a program return unpredictable and
    random output?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need genuinely random numbers, then we need to take this randomness from
    somewhere else. That''s why many advanced applications try to combine different
    external sources of randomness into a random value: they may look at the movement
    of the mouse during a specific interval, to the noise of the internet connection,
    or even ask the user to smash the keyboard randomly, and so on. There is even
    dedicated hardware for random number generation!'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, in games, we do not need such genuinely random numbers, and we
    can use simpler algorithms that can generate sequences that look like a sequence
    of random numbers. Such algorithms are called **Pseudorandom Number Generators**
    (**PRNGs**). Using an initial seed, they can generate, in a deterministic way,
    a sequence of numbers that statistically approximate the properties of a sequence
    of truly random numbers. The catch is that if we start from the same seed, we
    always get the same sequence of numbers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we usually initialize the seed value from something that we
    imagine is always different every time the user opens the application, such as,
    for instance, the elapsed time in milliseconds since the computer started running,
    or the number of milliseconds since 1970 (the *Unix timestamp*). Note, however,
    that having the possibility to obtain the same random sequence every time is truly
    beneficial when debugging!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that some PRNGs are more random than others. If we were creating
    an encryption program, we would want to look into less predictable PRNGs, called
    **Cryptographically Secure Pseudorandom Number Generators** (**CSPRNGs**). Fortunately,
    for games, the simple **Random Number Generation** (**RNG**) that comes with Unity
    is good enough.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Random class
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Unity3D script has a `Random` class to generate random data. You can set
    the generator seed using the `InitState(int seed)` function. Usually, we wouldn't
    want to repeatedly seed the same value, as this generates the same predictable
    sequence of random numbers at each execution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some cases in which we want to give the user control over
    the seed – for instance, when we test the game or want the players to generate
    a procedural map/level with a specific seed. Then, you can read the `Random.value`
    property to get a random number between 0.0 and 1.0\. This generator is inclusive,
    and therefore, this property can return both 0.0 and 1.0\.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下我们希望用户能够控制种子 – 例如，当我们测试游戏或希望玩家使用特定的种子生成程序化地图/关卡时。然后，你可以读取`Random.value`属性来获取0.0到1.0之间的随机数。这个生成器是包含的，因此这个属性可以返回0.0和1.0。
- en: 'For example, in the following snippet, we generate a random color by choosing
    a random value between 0 and 1 for the red, green, and blue components:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码片段中，我们通过为红色、绿色和蓝色组件选择0到1之间的随机值来生成一个随机颜色：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another class method that can be quite handy is the `Range` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的类方法是`Range`方法：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use the `Range` method to generate a random number from a range. When
    given an integer value, it returns a random integer number between `min` (inclusive)
    and `max` (exclusive). Therefore, if we set `min` to 1 and `max` to 4, we can
    get 1, 2, or 3, but never 4\. Instead, if we use the `Range` function for float
    values, both `min` and `max` are inclusive, meaning we can get 1.0, or 4.0, or
    all the floats in between. Take note whenever a parameter is exclusive or inclusive
    because it is a common source of bugs (and confusion) when using the Unity `Random`
    class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Range`方法从一个范围内生成一个随机数。当给定一个整数值时，它返回一个介于`min`（包含）和`max`（不包含）之间的随机整数。因此，如果我们设置`min`为1，`max`为4，我们可以得到1、2或3，但永远不会得到4。相反，如果我们使用`Range`函数为浮点值，`min`和`max`都是包含的，这意味着我们可以得到1.0、4.0或介于两者之间的所有浮点数。请注意，当使用Unity的`Random`类时，参数是包含的还是不包含的是常见的错误（和混淆）来源。
- en: A simple random dice game
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的随机掷骰子游戏
- en: 'Let''s set up a straightforward dice game in a new scene where we need to guess
    the output of a six-sided dice (simulated by generating a random integer between
    one and six). The player wins if the input value matches the dice result generated
    randomly, as shown in the following `DiceGame.cs` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个新的场景中设置一个简单的掷骰子游戏，在这个场景中我们需要猜测六面骰子的输出（通过生成一个介于1到6之间的随机整数来模拟）。如果输入值与随机生成的骰子结果匹配，玩家获胜，如下面的`DiceGame.cs`文件所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the previous code, we saw the `DiceGame` class that implements the whole
    game. However, we still need to set up the scene with the appropriate UI object
    to accept the player''s inputs and display the results:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到了实现整个游戏的`DiceGame`类。然而，我们仍然需要设置场景，使用适当的UI对象来接受玩家的输入并显示结果：
- en: First, we need to create `guiText` to show the result. Click on `New Text` text
    to the game scene.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建`guiText`来显示结果。点击游戏场景中的`New Text`文本。
- en: Center it at the top of the canvas.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其置于画布顶部中央。
- en: Then, in the same way, create a button by selecting **Game Object** | **UI**
    | **Button – TextMeshPro** and an input field by selecting **Game Object** | **UI**
    | **Input Field – TextMeshPro**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，以同样的方式，通过选择**Game Object** | **UI** | **Button – TextMeshPro**创建一个按钮，通过选择**Game
    Object** | **UI** | **Input Field – TextMeshPro**创建一个输入字段。
- en: Arrange them vertically on the screen.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们垂直排列在屏幕上。
- en: 'Create an empty game object and call it `DiceGame`. At this point, you should
    have something similar to *Figure 3.1*:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的游戏对象，并将其命名为`DiceGame`。此时，你应该有类似于*图3.1*的界面：
- en: '![Figure 3.1 – Our simple Unity interface'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 我们简单的Unity界面'
- en: '](img/B17984_03_1.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_1.jpg)'
- en: Figure 3.1 – Our simple Unity interface
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 我们简单的Unity界面
- en: Select the text inside the button and replace `Button` with `Play!` in the **TextMeshPro**
    component.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮内部选择文本，并在**TextMeshPro**组件中将`Button`替换为`Play!`：
- en: 'Select the `New Text` text and replace it with `Result:` in the **TextMeshPro**
    component:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TextMeshPro**组件中选择`New Text`文本，并将其替换为`Result:`：
- en: '![Figure 3.2 – The TextMeshPro component'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – TextMeshPro组件'
- en: '](img/B17984_03_2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_2.jpg)'
- en: Figure 3.2 – The TextMeshPro component
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – TextMeshPro组件
- en: 'Now, attach the `DiceGame` component to the `DiceGame` object, and connect
    into the `DiceGame` component the tree UI elements that we created before:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`DiceGame`组件附加到`DiceGame`对象上，并将我们之前创建的UI元素树连接到`DiceGame`组件：
- en: '![Figure 3.3 – The DiceGame component'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – DiceGame组件'
- en: '](img/B17984_03_3.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_3.jpg)'
- en: Figure 3.3 – The DiceGame component
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – DiceGame组件
- en: 'Finally, select `Button` and look for the `onClick()` section in the `Button`
    component. Drag and drop the `DiceGame` object into the field with `None (GameObject)`
    and select `processGame` function to the click event for the button:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择“按钮”并查找“按钮”组件中的“onClick()”部分。将“DiceGame”对象拖放到带有“None (GameObject)”的字段中，并将“processGame”函数分配给按钮的点击事件：
- en: '![Figure 3.4 – The On Click event configuration'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 单击事件配置'
- en: '](img/B17984_03_4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B17984_03_4](img/B17984_03_4.jpg)'
- en: Figure 3.4 – The On Click event configuration
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 单击事件配置
- en: At this point, the game should be ready. Click Unity's play button and give
    it a go.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，游戏应该已经准备好了。点击Unity的播放按钮，开始游戏。
- en: To successfully manage random numbers, we need to have a basic understanding
    of the laws of probability. So, that's what we are going to learn in the next
    section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功管理随机数，我们需要对概率定律有一个基本的了解。因此，这就是我们将在下一节学习的内容。
- en: Learning the basics of probability
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习概率的基础
- en: There are many ways to define probability. The most intuitive definition of
    probability is called **frequentism**. According to frequentism, the probability
    of an event is the frequency with which the event occurs when we repeat the observation
    an infinite amount of times. In other words, if we throw a die 100 times, we expect
    to see a six, on average, 1/6th of the times, and we should get closer and closer
    to 1/6th with 1,000, 10,000, and 1 million throws.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定义概率的方法有很多。最直观的概率定义被称为**频率主义**。根据频率主义，事件的概率是在我们无限次重复观察时事件发生的频率。换句话说，如果我们掷骰子100次，我们期望平均看到一次六，大约是六分之一的时间，并且随着1,000次、10,000次和1,000,000次的投掷，我们应该越来越接近六分之一。
- en: We can write the probability of event A occurring as *P(A)*. To calculate *P(A)*,
    we need to know all the possible outcomes (*N*) for the observation and the total
    number of times in which the desired event occurs (*n*).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将事件A发生的概率写成 *P(A)*。要计算 *P(A)*，我们需要知道观察的所有可能结果 (*N*) 以及期望事件发生的总次数 (*n*)。
- en: 'We can calculate the probability of event *A* as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式计算事件 *A* 的概率：
- en: '![](img/Formula_01.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![公式 01](img/Formula_01.png)'
- en: 'If *P(A)* is the probability of event *A* happening, then the probability of
    event *A* not happening is equal to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *P(A)* 是事件 *A* 发生的概率，那么事件 *A* 不发生的概率等于以下：
- en: '![](img/Formula_2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![公式 2](img/Formula_2.png)'
- en: 'The probability must be a real number between zero and one. Having a probability
    of zero means that there''s no chance of the desired event happening; on the other
    hand, having a probability of one means that the event will occur for sure. As
    a consequence, the following must equal to one:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 概率必须是一个介于零和一之间的实数。概率为零意味着没有机会发生期望的事件；另一方面，概率为一意味着事件一定会发生。因此，以下必须等于一：
- en: '![](img/Formula_3.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![公式 3](img/Formula_3.png)'
- en: However, not all events are alike. One of the most critical concepts in probability
    calculus is the concept of *independent and non-independent events*. That's the
    topic of the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有事件都是相同的。概率论中最关键的概念之一是**独立和非独立事件**的概念。这就是下一节的主题。
- en: Independent and correlated events
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立和非相关事件
- en: Another important concept in probability is whether the chance of a particular
    event occurring depends on any other event somehow. For example, consider throwing
    a six-sided die twice and getting a double six. Each die throw can be viewed as
    an independent event. Each time you throw a die, the probability of each side
    turning up is one in six, and the outcome of the second die roll does not change
    depending on the result of the first roll. On the other hand, in drawing two aces
    from the same deck, each draw is not independent of the others. If you drew an
    ace in the first event, the probability of getting another ace the second time
    is different because there is now one less ace in the deck (and one less card
    in the deck).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 概率论中的另一个重要概念是，一个特定事件发生的概率是否以某种方式依赖于其他事件。例如，考虑掷两次六面骰子并得到一个双六。每次掷骰子都可以看作是一个独立事件。每次掷骰子，每个面出现的概率是六分之一，第二次掷骰子的结果不会因第一次掷骰子的结果而改变。另一方面，在从同一副牌中抽取两张A时，每次抽取并不是相互独立的。如果你在第一次事件中抽到了A，那么第二次抽到A的概率会不同，因为牌堆中现在少了一个A（并且少了一张牌）。
- en: 'The independence of events is crucial because it significantly simplifies some
    calculations. For instance, imagine that we want to know the probability of either
    event *A* or event *B* happening. If *A* and *B* are two independent events, then
    we can add the probabilities of *A* and *B*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的独立性至关重要，因为它显著简化了一些计算。例如，想象一下我们想知道事件 *A* 或事件 *B* 发生的概率。如果 *A* 和 *B* 是两个独立事件，那么我们可以将
    *A* 和 *B* 的概率相加：
- en: '![](img/Formula_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![公式_04.png](img/Formula_04.png)'
- en: 'In the same way, if we want to know the probability that both *A* and *B* occur,
    then we can multiply the individual probabilities together:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果我们想知道同时发生事件 *A* 和 *B* 的概率，那么我们可以将各自的概率相乘：
- en: '![](img/Formula_5.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![公式_5.png](img/Formula_5.png)'
- en: 'For instance, if we want to know the probability of getting two sixes by throwing
    two dice, we can multiply 1/6 by 1/6 to get the correct probability: 1/36.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想知道通过掷两个骰子得到两个六的概率，我们可以将1/6乘以1/6来得到正确的概率：1/36。
- en: Conditional probability
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件概率
- en: Now, let's consider another example. We are still throwing two dice, but this
    time, we are interested in the probability that the sum of the numbers showing
    up on two dice is equal to two. Since there's only one way to get this sum, one
    plus one, the probability is the same as getting the same number on both dice.
    In that case, it would still be 1/36.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个例子。我们仍然在掷两个骰子，但这次，我们感兴趣的是两个骰子显示的数字之和等于二的概率。由于只有一种方式得到这个总和，即一加一，所以概率与两个骰子显示相同数字的概率相同。在这种情况下，它仍然是1/36。
- en: 'But how about getting the sum of the numbers that show up on the two dice to
    seven? As you can see, there are a total of six possible ways of getting a total
    of seven, outlined in the following table:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如何得到两个骰子显示数字之和为七呢？正如你所见，总共有六种可能的方式得到总和为七，如下表所示：
- en: '![Figure 3.5 – The possible outcomes of two dice'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 两个骰子的可能结果'
- en: '](img/B17984_03_5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![B17984_03_5.jpg](img/B17984_03_5.jpg)'
- en: Figure 3.5 – The possible outcomes of two dice
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 两个骰子的可能结果
- en: In this case, we need to use the general probability formula. From the preceding
    table, we can see that we have six outcomes that give us a total sum of seven.
    Because we know that there are 36 total possible outcomes for 2 dice, we can quickly
    compute the final probability as 6/36 or, simplifying, one-sixth (16.7%).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要使用一般概率公式。从前面的表格中，我们可以看到我们有六个结果，总共有七个。因为我们知道两个骰子总共有36种可能的结果，所以我们可以快速计算出最终概率为6/36，或者简化为六分之一（16.7%）。
- en: Loaded dice
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加重骰子
- en: Now, let's assume that we haven't been all too honest, and our dice are loaded
    so that the side of the number six has a double chance of landing facing upward.
    Since we doubled the chance of getting six, we need to double the probability
    of getting six – let's say, up to roughly one-third (0.34) – and as a consequence,
    the rest is equally spread over the remaining five sides (0.132 each).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们并不完全诚实，并且我们的骰子是加重的，使得数字六的面有双倍的机会向上。由于我们增加了得到六的机会，我们需要将得到六的概率加倍——比如说，大约三分之一（0.34）——因此，其余的均匀分布在剩下的五个面上（每个面0.132）。
- en: 'We can implement a loaded dice algorithm this way: first, we generate a random
    value between 1 and 100\. Then, we check whether the random value falls between
    1 and 35\. If so, our algorithm returns six; otherwise, we get a random dice value
    between one and five (since these values have the same probability).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现一个加重的骰子算法：首先，我们生成一个介于1到100之间的随机值。然后，我们检查这个随机值是否落在1到35之间。如果是，我们的算法返回六；否则，我们得到一个介于1到5之间的随机骰子值（因为这些值有相同的概率）。
- en: 'For this, we create a new class called `DiceGameLoaded`. The game is identical
    to `DiceGame` but with an important difference: the `throwDice` function is changed,
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，我们创建一个新的类，称为 `DiceGameLoaded`。游戏与 `DiceGame` 相同，但有一个重要的区别：`throwDice` 函数被更改，如下所示：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To try this new version of the game, swap the `DiceGame` component with the
    `DiceGame` component in the `DiceGame` object and rebind the `onClick` button
    event as we did before. If we test our new loaded dice algorithm by throwing the
    dice multiple times, you'll notice that the `6` value yields more than usual.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个新版本的游戏，将 `DiceGame` 组件与 `DiceGame` 对象中的 `DiceGame` 组件交换，并重新绑定我们之前所做的 `onClick`
    按钮事件。如果我们通过多次掷骰子来测试我们的新加重骰子算法，你会注意到 `6` 值比平常更多。
- en: 'As you can see, the code is very similar to the non-loaded dice. However, this
    time, we are throwing an unfair dice that returns six much more than it should:
    we first select a random number between `0` and `100`; if the number is less than
    `35`, we return `6`. Otherwise, we choose a random number between `1` and `5`.
    Therefore, we get a `6` 35% of the time and every other number roughly 15% of
    the time (we divide the remaining 75% by `5`).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码与非加载骰子非常相似。然而，这次我们抛的是一个不公平的骰子，其返回六的概率远高于正常情况：我们首先在 `0` 和 `100` 之间选择一个随机数；如果这个数小于
    `35`，则返回 `6`。否则，我们在 `1` 和 `5` 之间选择一个随机数。因此，我们有 `35%` 的概率得到 `6`，而其他数字的大约 `15%`
    的概率（我们将剩余的 `75%` 除以 `5`）。
- en: Remember that, in games, it's not cheating if the goal is to give the player
    a more exciting and fun experience!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在游戏中，如果目标是给玩家带来更激动人心和有趣的体验，那么这并不算作弊！
- en: Exploring more examples of probability in games
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索游戏中概率的更多示例
- en: In this section, we will explore some of the most common applications of probability
    and randomness in video games.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨概率和随机性在视频游戏中最常见的应用。
- en: Character personalities
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色性格
- en: 'Probability and randomness are not only about dice. We can also use a probability
    distribution to specify an in-game character''s specialties. For example, let''s
    pretend we designed a game proposal for a population management game for the local
    government. We need to address and simulate issues such as taxation versus global
    talent attraction, and immigration versus social cohesion. We have three types
    of characters in our proposal – namely, workers, scientists, and professionals.
    Their efficiencies in performing their particular tasks are defined in the following
    table:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 概率和随机性不仅与骰子有关。我们还可以使用概率分布来指定游戏角色的特长。例如，让我们假设我们为地方政府设计了一个人口管理游戏的游戏提案。我们需要解决和模拟诸如税收与全球人才吸引、移民与社会凝聚力等问题。在我们的提案中，我们有三种类型的角色——即工人、科学家和专业人士。他们在执行特定任务时的效率定义在以下表格中：
- en: '![Figure 3.6 – The efficiency of every character in performing each task'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 每个角色执行每个任务时的效率'
- en: '](img/B17984_03_6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_6.jpg)'
- en: Figure 3.6 – The efficiency of every character in performing each task
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 每个角色执行每个任务时的效率
- en: Let's take a look at how we can implement this scenario. Let's say the player
    needs to build new houses to accommodate the increased population. A house construction
    would require 1,000 units of workload to finish. We use the earlier value as the
    workload that can be done per second per unit type for a particular task.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这个场景。假设玩家需要建造新的房屋以容纳增加的人口。房屋建造需要 1,000 个工作单位来完成。我们使用之前的价值作为特定任务中每个单位类型每秒可以完成的工作量。
- en: So, if you're building a house with one worker, it'll only take about 10 seconds
    to finish the construction (1000/95), whereas it'll take more than 3 minutes if
    you are trying to build with the scientists (1000/5 = 200 seconds). The same is
    true for other tasks, such as research and development and corporate jobs. Of
    course, these factors can be adjusted or enhanced later as the game progresses,
    making some entry-level tasks simpler and taking less time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你只用一个工人来建造房屋，建造时间大约只需 10 秒（1000/95），而如果你试图用科学家建造，则需要超过 3 分钟（1000/5 = 200
    秒）。其他任务也是如此，例如研发和公司工作。当然，随着游戏的进行，这些因素可以调整或增强，使得一些入门级任务变得简单，所需时间更少。
- en: 'Then, we introduce special items that the particular unit type can discover.
    We don''t want to give out these items every time a particular unit has done its
    tasks. Instead, we want to reward the player as a surprise. So, we associate the
    probability of finding such items according to the unit type, as described in
    the following table:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们引入特定单位类型可以发现的特殊物品。我们不想每次特定单位完成任务时都发放这些物品。相反，我们希望作为惊喜奖励玩家。因此，我们根据单位类型将找到此类物品的概率关联起来，如下表所述：
- en: '![Figure 3.7 – The probability of finding specific objects for each unit type'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 每个单位类型找到特定物体的概率'
- en: '](img/B17984_03_7.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_7.jpg)'
- en: Figure 3.7 – The probability of finding specific objects for each unit type
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 每个单位类型找到特定物体的概率
- en: The preceding table shows a 30% chance of a worker finding some raw materials
    and a 10% chance of earning bonus income whenever they have built a factory or
    a house. This allows the players to anticipate possible upcoming rewards once
    they've done some tasks and make the game more fun because they do not know the
    event's outcome.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格显示，工人找到一些原材料的机会有30%，而每当他们建造了一个工厂或一栋房子，就有10%的机会获得奖金收入。这允许玩家在完成一些任务后预测可能即将到来的奖励，从而使游戏更加有趣，因为他们不知道事件的结果。
- en: Perceived randomness
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感知随机性
- en: One critical aspect of randomness is that humans are terrible at understanding
    true randomness. Instead, when us humans talk about *random results*, we think
    of *equally distributed results*. For example, imagine a **Massive Online Battle
    Arena** (**MOBA**) game such as *League of Legends*. Imagine that we have a hero
    with an ability that does colossal damage but only hits 50% of the time. The player
    starts a game with such a hero, but the hero misses that ability five times in
    a row due to bad luck. Put yourself in the shoes of that player – you would think
    that the computer is cheating or that there is something wrong, right?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性的一个关键方面是，人类在理解真正的随机性方面非常糟糕。相反，当我们人类谈论*随机结果*时，我们想到的是*均匀分布的结果*。例如，想象一下像*英雄联盟*这样的**大型多人在线战斗竞技场**（**MOBA**）游戏。想象一下，我们有一个英雄拥有造成巨大伤害的能力，但只有50%的时间能命中。玩家用一个这样的英雄开始游戏，但这个英雄由于运气不好连续五次没有使用那个能力。换位思考一下那个玩家的感受——你会认为电脑在作弊或者有什么问题，对吧？
- en: However, getting 5 consecutive misses has a probability of 1 over 32\. That
    is about 3.1%, more than getting three of a kind in a five-card deal of poker
    (which is about 2.1%) – unlikely but possible. If our game uses a perfectly random
    number generator, we may get this scenario relatively often.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，连续五次未命中的概率是1/32。这大约是3.1%，比在五张牌的扑克牌中抽到三张同花（大约是2.1%）的可能性要大——不太可能但有可能。如果我们的游戏使用一个完美的随机数生成器，我们可能会相对频繁地遇到这种情况。
- en: Let's put it another way. Given a sequence of misses (*M*) and hits (*H*), which
    sequence do you find more *random* between *HHHHHMMM* and *HMHMHHMH*? I bet the
    second one, where we interleave misses and hits. It feels more random than the
    first one (where hits and misses are nicely grouped in strikes), even if they
    have the exact same chance of occurring naturally.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换一种说法。给定一系列的未命中（*M*）和命中（*H*），你会在*HHHHHMMM*和*HMHMHHMH*之间找到哪个序列更*随机*？我打赌是第二个，其中我们交替使用未命中和命中。它感觉比第一个（命中和未命中被很好地分组在打击中）更随机，即使它们自然发生的概率完全相同。
- en: The point is that, sometimes, for the sake of player engagements, games need
    to tweak their randomness to get something that feels more random than true randomness.
    Video games do that in several ways. The most common one is keeping track of the
    number of occurrences of a value that should be perceived as random.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，有时，为了提高玩家的参与度，游戏需要调整它们的随机性，以获得比真正的随机性感觉更随机的东西。视频游戏以几种方式做到这一点。最常见的一种是跟踪一个应该被视为随机值的出现的次数。
- en: So, for instance, we may keep track of the number of hits and misses of our
    hero's ability, and when we see that the ratio between the two get too far away
    from the theoretical one of 50% – for example, when we have 75% misses (or hits)
    – we rebalance the ratio by forcing a hit (or vice versa).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，我们可能会跟踪我们英雄能力命中和未命中的次数，当我们看到这两个比例与理论上的50%相差太远时——例如，当我们有75%的未命中（或命中）时——我们通过强制命中（或反之）来重新平衡比例。
- en: FSM with probability
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带概率的有限状态机
- en: 'In *Chapter 2*, *Finite State Machines*, we saw how to implement an FSM using
    simple switch statements or the FSM framework. We based the decision on choosing
    which state to execute purely on a given condition''s true or false value. Let''s
    go back for a moment to the FSM of our AI-controlled tank entity:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*有限状态机*中，我们看到了如何使用简单的开关语句或有限状态机框架来实现有限状态机。我们基于给定条件的真值或假值来选择执行哪个状态。让我们暂时回到我们的人工智能控制的坦克实体的有限状态机：
- en: '![Figure 3.8 – The tank AI FSM'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 坦克AI有限状态机'
- en: '](img/B17984_03_8.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_8.jpg)'
- en: Figure 3.8 – The tank AI FSM
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 坦克AI有限状态机
- en: 'For the sake of the example, we can give our tank entities some options to
    choose from instead of doing the same thing whenever it meets a specific condition.
    For example, in our earlier FSM, our AI tank would always chase the player tank
    once the player was in its line of sight. Instead, we can split the **player on
    sight** transaction and connect it to an additional new state, **Flee**. How can
    the AI decide which state to move to? Randomly, of course:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们可以给我们的坦克实体一些选项来选择，而不是每次遇到特定条件时都做同样的事情。例如，在我们的早期有限状态机中，我们的AI坦克一旦发现玩家在其视线中，就会一直追逐玩家坦克。相反，我们可以将**玩家在视线中**的交易拆分，并将其连接到一个新的附加状态，**逃跑**。AI如何决定移动到哪个状态呢？当然，随机选择：
- en: '![Figure 3.9 – FSM using probability'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – FSM using probability](img/B17984_03_9.jpg)'
- en: '](img/B17984_03_9.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_03_9.jpg](img/B17984_03_9.jpg)'
- en: Figure 3.9 – FSM using probability
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 使用概率的有限状态机
- en: As shown in the preceding diagram, instead of chasing every time, now, when
    the AI tank spots the player, there's a 50% chance that it'll flee the scene (maybe
    to report the attack to the headquarters or something else). We can implement
    this mechanism the same way we did with our previous dice example. First, we must
    randomly get a value between 1 and 100 and see whether the value lies between
    1 and 50, or 51 and 100\. If it's the former, the tank will flee; otherwise, it
    will chase the player.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，现在，当AI坦克发现玩家时，有50%的概率它会逃离现场（可能是向总部报告攻击或其他事情）。我们可以用与之前骰子示例相同的方式实现这个机制。首先，我们必须随机获取一个介于1到100之间的值，并查看这个值是否介于1到50之间，或者51到100之间。如果是前者，坦克将逃跑；否则，它将追逐玩家。
- en: Another way to implement a random selection is by using the **roulette wheel
    selection algorithm**. This algorithm is advantageous when we do not have exact
    probabilities or know all the possible options at compile time (for instance,
    because we load the FSM rules from a file).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现随机选择的方法是使用**轮盘赌选择算法**。当我们在编译时没有确切的概率或不知道所有可能的选项时，这个算法是有优势的（例如，因为我们从文件中加载了有限状态机规则）。
- en: 'As the name suggests, the idea is to imagine a roulette wheel with one sector
    for each event. However, the more probable an event is, the larger the sector
    is. Then, we mathematically spin the wheel and choose the event corresponding
    to the sector where we ended up:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这个想法是想象一个每个事件都有一个扇区的轮盘赌。然而，一个事件越可能发生，其扇区就越大。然后，我们数学上旋转这个轮盘，并选择我们最终到达的扇区对应的事件：
- en: '![Figure 3.10 – The roulette wheel'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.10 – The roulette wheel](img/B17984_03_10.jpg)'
- en: '](img/B17984_03_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_03_10.jpg](img/B17984_03_10.jpg)'
- en: Figure 3.10 – The roulette wheel
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 轮盘赌
- en: 'In our example, we have three states: **Chase**, **Flee**, and **SelfDestruct**.
    We assign a weight to each state, representing how probable they are with respect
    to each other. For instance, in the figure, you can see that I set **Chase** with
    weight **80**, **Flee** with weight **19**, and **SelfDestruct** with weight **1**.
    Note that weights do not need to sum to 1 like probabilities, nor 100, nor anything
    in particular.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有三个状态：**追逐**、**逃跑**和**自毁**。我们为每个状态分配一个权重，表示它们相对于彼此的概率。例如，在图中，你可以看到我将**追逐**的权重设置为**80**，**逃跑**的权重设置为**19**，**自毁**的权重设置为**1**。请注意，权重不需要像概率那样总和为1，也不需要是100，或其他特定的数值。
- en: 'In this case, however, I made them add to 100 because it is easier to translate
    weights into probabilities: we can imagine **Chase** happening 80% of the time,
    **Flee** 19% of the time, and in 1% of the cases, the tank self-destructing. However,
    in general, you can imagine the weight of event *X* as the number of balls with
    *X* written on them and put inside a lottery box.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我将它们加到100，因为这更容易将权重转换为概率：我们可以想象**追逐**发生80%的时间，**逃跑**发生19%的时间，而在1%的情况下，坦克自毁。然而，通常情况下，你可以想象事件*X*的权重是写有*X*的球的数量，并将它们放入一个彩票箱中。
- en: 'Let''s see the result in the `FSM.cs` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`FSM.cs`文件中看看结果：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The mechanism is straightforward. First, we sum all the weights to know the
    size of the imaginary wheel. Then, we pick a number between `0` and this sum.
    Finally, we subtract from this number the weights of each state (starting from
    the first one) until the number gets negative. Then, as you can see in the `Update()`
    method, every time we press the *Spacebar*, the algorithm chooses one random item
    from our `states` array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制很简单。首先，我们将所有权重相加，以了解想象中的轮盘的大小。然后，我们在0和这个总和之间选择一个数字。最后，我们从这个数字中减去每个状态的权重（从第一个开始），直到数字变成负数。然后，正如你在`Update()`方法中看到的，每次我们按下空格键，算法就会从我们的`states`数组中随机选择一个项目。
- en: Dynamically adapting AI skills
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态调整AI技能
- en: 'We can also use probability to specify the intelligence levels of AI characters
    or the global game settings, affecting, in turn, a game''s overall difficulty
    level to keep it challenging and exciting for the players. As described in the
    book *The Art of Game Design* by Jesse Schell, players only continue to play a
    game if the game keeps them in the flow channel (a concept adapted to games from
    the psychological works on flow state of Mihály Csíkszentmihályi):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用概率来指定AI角色的智能水平或全局游戏设置，从而影响游戏的总体难度水平，使其对玩家保持挑战性和趣味性。正如Jesse Schell在其著作《游戏设计艺术》中所描述的，如果游戏能够使玩家保持在“心流”通道中（一个从Mihály
    Csíkszentmihályi关于心流状态的心理工作中借鉴的概念），玩家才会继续玩游戏：
- en: '![Figure 3.11 – The player''s ﬂow channel'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 玩家的心流通道'
- en: '](img/B17984_03_11.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_03_11.jpg]'
- en: Figure 3.11 – The player's ﬂow channel
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 玩家的心流通道
- en: If we present too tricky challenges to the players before they have the necessary
    skills, they will feel anxious and disappointed. On the other hand, once they've
    mastered the game, they will get bored if we keep it at the same pace. The area
    in which the players remain engaged for a long time is between these two hard
    and easy extremes, which the original author referred to as the flow channel.
    To keep the players in the flow channel, the game designers need to feed challenges
    and missions that match the increasing skills that the players acquire over time.
    However, it is not easy to find a value that works for all players, since the
    pace of learning and expectations can differ from individual to individual.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在玩家具备必要技能之前就向他们展示过于复杂的挑战，他们将会感到焦虑和失望。另一方面，一旦他们掌握了游戏，如果我们保持同样的节奏，他们将会感到无聊。玩家保持参与的时间区域位于这两个极端之间，即困难与简单之间，原始作者将其称为“心流通道”。为了使玩家保持在心流通道中，游戏设计师需要提供与玩家随时间获得的技能提升相匹配的挑战和任务。然而，由于学习速度和期望值可能因人而异，因此很难找到一个对所有玩家都适用的值。
- en: One way to tackle this problem is to collect the player's attempts and results
    during the gameplay sessions and to adjust the difficulty of the opponent's AI
    accordingly. So, how can we change the AI's difficulty – for instance, by making
    the AI more aggressive, increasing the probability of landing a perfect shot,
    or decreasing the probability of erratic behavior?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是在游戏过程中收集玩家的尝试和结果，并相应地调整对手AI的难度。那么，我们如何改变AI的难度——例如，通过使AI更具侵略性，增加完美射击的概率，或减少异常行为发生的概率？
- en: Creating a slot machine
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建老虎机
- en: In this demo, we will design and implement a slot machine game with 10 symbols
    and 3 reels. To make it simple, we'll use the numbers from zero to nine as our
    symbols. Many slot machines use fruit and other simple shapes, such as bells,
    stars, and letters. Some other slot machines use a specific theme based on popular
    movies or TV franchises. Since there are 10 symbols and 3 reels, that's a total
    of 1,000 (10^3) possible combinations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将设计和实现一个带有10个符号和3个滚筒的老虎机游戏。为了简化，我们将使用从零到九的数字作为我们的符号。许多老虎机使用水果和其他简单的形状，例如铃铛、星星和字母。有些其他老虎机则使用基于流行电影或电视系列的特定主题。由于有10个符号和3个滚筒，因此总共有1,000（10^3）种可能的组合。
- en: A random slot machine
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机老虎机
- en: This random slot machine demo is similar to our previous dice example. This
    time, we are going to generate three random numbers for three reels. The only
    payout will be when we get three of the same symbols on the pay line. To make
    it simpler, we'll only have one line to play against in this demo. If the player
    wins, the game will return 500 times the bet amount.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个随机老虎机演示与我们的先前的骰子示例类似。这次，我们将为三个滚筒生成三个随机数字。唯一的回报是在支付线上出现三个相同的符号时。为了简化，在这个演示中我们只有一条线路可以玩。如果玩家赢了，游戏将返还投注金额的500倍。
- en: 'We''ll set up our scene with all our UI elements: three texts for the reels,
    another text element for the `betResult` object), one text element for the player''s
    credits (`Credits`), an input field for the bet (`InputField`), and a button to
    pull the lever (`Button`):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置场景中的所有UI元素：三个用于滚筒的文本，另一个用于`betResult`对象的文本元素，一个用于玩家信用额的文本元素（`Credits`），一个用于投注的输入字段（`InputField`），以及一个拉动摇杆的按钮（`Button`）：
- en: '![Figure 3.12 – Our GUI text objects'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – 我们的GUI文本对象'
- en: '](img/B17984_03_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_03_12.jpg]'
- en: Figure 3.12 – Our GUI text objects
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 我们的GUI文本对象
- en: 'This is how our new script looks, as shown in the following `SlotMachine.cs`
    file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的新脚本的样子，如下面的`SlotMachine.cs`文件所示：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we start by listing all the class attributes we need. Again, note that
    it is a good programming practice to avoid public fields unless strictly necessary.
    Therefore, you should use the `[SerializeField]` attribute instead. Here, however,
    we will use the `public` attribute to avoid making the code listing too long.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们列出所有需要的类属性。再次提醒，避免使用公共字段是一个好的编程实践，除非绝对必要。因此，你应该使用 `[SerializeField]` 属性。然而，在这里，我们将使用
    `public` 属性以避免使代码列表过长。
- en: 'Now, let''s continue by adding three new functions: `Spin`, which starts the
    spinning of the slot machine; `OnGui`, which we will use to update the user interface;
    and `checkBet`, a function that checks the result of the spin and informs the
    players if they win or lose:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续添加三个新的函数：`Spin`，它用于启动老虎机的旋转；`OnGui`，我们将用它来更新用户界面；以及 `checkBet`，这是一个检查旋转结果并通知玩家他们是否赢或输的函数：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we implement the main loop of the script. In the `FixedUpdate` function,
    we run the slot machine by spinning each reel in turn. In the beginning, `firstReelSpinned`,
    `secondReelSpinned`, and `thirdReelSpinned` are all false. Therefore, we enter
    in the first `if` block. Here, we set the reel to a random value, and we end the
    function. We repeat that until a certain amount of time has passed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现脚本的主体循环。在 `FixedUpdate` 函数中，我们依次旋转每个滚筒来运行老虎机。一开始，`firstReelSpinned`、`secondReelSpinned`
    和 `thirdReelSpinned` 都为假。因此，我们进入第一个 `if` 块。在这里，我们将滚筒设置为随机值，并结束函数。我们重复这个过程，直到经过一定的时间。
- en: 'After that, we set the reel to the final value, and we set `firstReelSpinned`
    to `true`. Then, the function will move to the second reel, where we repeat these
    steps. Finally, after the third reel is finally set to its final value, we check
    the results with `checkBet`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将滚筒设置为最终值，并将 `firstReelSpinned` 设置为 `true`。然后，函数将移动到第二个滚筒，重复这些步骤。最后，当第三个滚筒最终被设置为最终值时，我们使用
    `checkBet` 检查结果：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Attach the script to an empty `GameController` object and then fill in the
    referenced object in the Inspector. Then, we need to connect `Button` to the `Spin()`
    method. To do that, select `Button` and fill the **On Click ()** event handler
    in the Inspector, as shown in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本附加到一个空的 `GameController` 对象上，然后在检查器中填写引用的对象。然后，我们需要将 `Button` 连接到 `Spin()`
    方法。为此，选择 `Button` 并在检查器中填写 **On Click ()** 事件处理器，如下面的截图所示：
- en: '![Figure 3.13 – The On Click() event handler'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.13 – On Click() 事件处理器'
- en: '](img/B17984_03_13.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_13.jpg)'
- en: Figure 3.13 – The On Click() event handler
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – On Click() 事件处理器
- en: When we click the button, we set the `startSpin` flag to `true`. Once spinning,
    in the `FixedUpdate()` method, we generate a random value for each reel. Finally,
    once we've got the value for the third reel, we reset the `startSpin` flag to
    `false`. While we are getting the random value for each reel, we also track how
    much time has elapsed since the player pulled the lever.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击按钮时，我们将 `startSpin` 标志设置为 `true`。一旦开始旋转，在 `FixedUpdate()` 方法中，我们为每个滚筒生成一个随机值。最后，当我们得到第三个滚筒的值后，我们将
    `startSpin` 标志重置为 `false`。在我们获取每个滚筒的随机值的同时，我们还跟踪玩家拉杆以来经过的时间。
- en: 'Usually, each reel would take 3 to 5 seconds before landing the result in real-world
    slot machines. Hence, we also take some time, as specified in `spinDuration`,
    before showing the final random value. If you play the scene and click on the
    **Pull Lever** button, you should see the final result, as shown in the following
    screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个滚筒在现实世界的老虎机中需要 3 到 5 秒才能落地显示结果。因此，我们在显示最终的随机值之前也花费了一些时间，这些时间由 `spinDuration`
    指定。如果你播放场景并点击 **Pull Lever** 按钮，你应该看到最终的结果，如下面的截图所示：
- en: '![Figure 3.14 – Our random slot game in action'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.14 – 我们随机老虎机游戏的实际运行'
- en: '](img/B17984_03_14.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_14.jpg)'
- en: Figure 3.14 – Our random slot game in action
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 我们随机老虎机游戏的实际运行
- en: Since your chance of winning is 1 out of 100, it quickly becomes tedious, as
    you lose several times consecutively. However, if you've ever played a slot machine,
    this is not how it works, or at least not anymore. Usually, you can have several
    wins during your play. Even though these small wins don't recoup your principal
    bet (and in the long run, most players go broke), the slot machines still occasionally
    render winning graphics and exciting sounds, which researchers refer to as losses
    disguised as wins.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的获胜概率是100分之1，连续输几次后很快就会变得乏味。然而，如果你曾经玩过老虎机，这并不是它的运作方式，或者至少不再是。通常，你可以在游戏中赢得几次。尽管这些小赢不能收回你的本金（而且从长远来看，大多数玩家都会破产），老虎机仍然偶尔会显示获胜图形和令人兴奋的声音，研究人员将这些称为伪装成赢的损失。
- en: So, instead of just one single way to win the jackpot, we want to modify the
    rules a bit so that the slot machine pays out smaller returns during the play
    session.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不想只通过一种方式赢得大奖金，而是想稍微修改一下规则，使老虎机在游戏过程中支付较小的回报。
- en: Weighted probability
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加权概率
- en: Real slot machines have something called a **Paytable and Reel Strips** (**PARS**)
    sheet, which is the complete design document of the machine. The PARS sheet is
    used to specify the payout percentage, the winning patterns, their payouts, and
    so on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 真实老虎机的某个部分被称为**支付表和滚筒条**（**PARS**）表格，这是机器的完整设计文档。PARS表格用于指定支付百分比、获胜模式、它们的支付金额等等。
- en: The number of payout prizes and the frequencies of such wins must be carefully
    selected so that the house (the slot machine) always wins in the long run while
    making sure to return something to the players from time to time to make the machine
    attractive to play. This is known as payback percentage or **Return to Player**
    (**RTP**). For example, a slot machine with a 90% RTP means that, over time, the
    machine returns an average of 90% of all bets to the players.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 支付奖项的数量和此类胜利的频率必须仔细选择，以确保赌场（老虎机）在长期内总是获胜，同时确保不时地向玩家返还一些东西，以使机器更具吸引力。这被称为支付百分比或**玩家回报率**（**RTP**）。例如，具有90%
    RTP的老虎机意味着，随着时间的推移，机器平均将90%的所有赌注返还给玩家。
- en: In this demo, we will not focus on choosing the house's optimal value to yield
    specific wins over time, nor maintaining a particular payback percentage. Instead,
    we will demonstrate how to weight probability for specific symbols showing up
    more times than usual. So, let's say we want to make the 0 symbols appear 20%
    more than usual on the first and third reel and return half of the bet as a payout.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们不会关注选择赌场的最佳值以在一段时间内获得特定的胜利，也不会关注维持特定的支付百分比。相反，我们将演示如何为特定符号赋予更高的概率，使其出现次数多于平常。所以，假设我们想让0符号在第一和第三滚筒上比平常多出现20%，并将一半的赌注作为支付。
- en: 'In other words, a player only loses half of their bet if they got zero symbols
    on the first and third reels, essentially disguising a loss as a small win. Currently,
    the zero symbols have a probability of 1/10th (0.1), or a 10% probability. We''ll
    change this now to a 30% chance of zero landing on the first and third reels,
    as shown in the following `SlotMachineWeighted.cs` file (remember to switch to
    the `SlotMachineWeighted` component in the example code!):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果玩家在第一和第三滚筒上没有得到0符号，他们只会损失一半的赌注，这实际上是将损失伪装成小赢。目前，0符号的概率是1/10（0.1），或者说10%的概率。我们现在将其改为在第一和第三滚筒上零出现的30%的机会，如下面的`SlotMachineWeighted.cs`文件所示（记得在示例代码中切换到`SlotMachineWeighted`组件！）：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: New variable declarations are added, such as `zeroProbability`, to specify the
    probability percentage of the zero symbols landing on the first and third reels.
    For example, if `zeroProbability` is 30, the third reel will show 0 30% of the
    time. The `weightedReelPoll` array list is used to fill the weighted symbols,
    as we did in our earlier FSM example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 新增了变量声明，例如`zeroProbability`，以指定零符号落在第一和第三滚筒上的概率百分比。例如，如果`zeroProbability`是30，第三滚筒将有30%的时间显示0。`weightedReelPoll`数组列表用于填充加权符号，就像我们在早期的FSM示例中所做的那样。
- en: 'Then, we initialize this list in the `Start()` method, as shown in the following
    code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Start()`方法中初始化这个列表，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In practice, we set the value for 0 to 30, and we split the remaining 70 percentage
    points between the remaining 9 numbers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们将0的值设为30，并将剩余的70个百分点分配给剩余的9个数字。
- en: 'We are also writing a revised and improved `checkBet()` method. Instead of
    just one jackpot win option, we are now considering five conditions of jackpot:
    loss disguised as a win, a near miss, any two symbols matched on the first and
    third row, and of course, the `lose` condition:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在编写一个修订和改进的 `checkBet()` 方法。我们不再只考虑一个大奖赢取选项，现在我们正在考虑五种大奖条件：伪装成赢的损失、几乎错过、第一行和第三行上匹配的任何两个符号，当然，还有
    `lose` 条件：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `checkBet()` method, we designed our slot machine to return 50 times
    the bet if they hit the jackpot, to lose 50% of their bet if the first and third
    reels are 0, and to win twice if the first and third reels match with any other
    symbol.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `checkBet()` 方法中，我们设计我们的老虎机在击中大奖时返还赌注的 50 倍，如果第一和第三滚筒是 0 则损失赌注的 50%，如果第一和第三滚筒与任何其他符号匹配则赢两倍。
- en: 'Then, as in the previous example, we generate values for the three reels in
    the `FixedUpdate()` method, as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像前面的例子一样，我们在 `FixedUpdate()` 方法中为三个滚筒生成值，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For the first reel, we show the real random values as they occur during the
    spinning period. Once the time is up, we choose the value from the poll that is
    already populated with symbols according to the probability distribution. So,
    our zero symbols will have a 30% better chance of occurring than the rest.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一滚筒，我们展示在旋转期间实际发生的真实随机值。一旦时间结束，我们从已经根据概率分布填充了符号的投票中选择一个值。因此，我们的零符号将有 30%
    的更高几率出现。
- en: In reality, the player is losing on their bets if they get two zero symbols
    on the first and third reel; however, we make it seem like a win. It's just a
    lame message here, but this can work if we combine it with nice graphics, maybe
    even fireworks, and nice winning sound effects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，如果玩家在第一和第三滚筒上得到两个零符号，他们就会在赌注上亏损；然而，我们让它看起来像是一场胜利。这里只是一个蹩脚的消息，但如果我们结合漂亮的图形，甚至烟花，以及好的胜利音效，这可以起作用。
- en: A near miss
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几乎错过
- en: If the first and second reels return the same symbol, we have to provide the
    near-miss effect to the players by returning the random value to the third reel
    close to the second one. We can do this by checking the third random spin result
    first. If the random value is the same as the first and second results, this is
    a jackpot, and we shouldn't alter the result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一和第二滚筒返回相同的符号，我们必须通过将第三滚筒的随机值返回到接近第二个的位置来向玩家提供几乎错过的效果。我们可以通过首先检查第三个随机旋转结果来实现这一点。如果随机值与第一和第二个结果相同，这是一个大奖，我们不应该改变结果。
- en: 'But if it''s not, then we should modify the result so that it is close enough
    to the other two. Check the comments in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果不是，那么我们应该修改结果，使其足够接近其他两个。请检查以下代码中的注释：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And if that near miss happens, you should see it, as shown in the following
    screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生几乎错过的情况，您应该能看到，如下面的截图所示：
- en: '![Figure 3.15 – A near miss'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.15 – 几乎错过'
- en: '](img/B17984_03_15.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_03_15.jpg)'
- en: Figure 3.15 – A near miss
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 几乎错过
- en: We can go even further by adjusting the probability in real time, based on the
    bet amount (but that'd be too shady). Finally, we can add a **Game Over** message
    that appears when the player has bet all their money.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过根据赌注金额实时调整概率来更进一步（但这会有些可疑）。最后，我们可以在玩家赌光所有钱时添加一个 **游戏结束** 消息。
- en: This demo shows you the basic implementation of a slot machine game. You can
    start from this skeleton and improve it with nicer graphics, animations, and sound
    effects. The important takeaway, though, is understanding that you can already
    create a game with randomness and probability alone.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示向您展示了老虎机游戏的基本实现。您可以从这个骨架开始，并通过更漂亮的图形、动画和音效来改进它。然而，重要的是要理解您仅凭随机性和概率就可以创建一个游戏。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the applications of probability in AI game
    design. We experimented with some of the techniques by implementing them in Unity3D.
    As a bonus, we also learned about how a slot machine works and implemented a simple
    slot machine game using Unity3D. Probability in games is about making the game,
    and the characters, seem more realistic by adding uncertainty to their behavior
    so that players cannot predict the outcome.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了概率在人工智能游戏设计中的应用。我们通过在 Unity3D 中实现它们来实验了一些技术。作为额外收获，我们还学习了老虎机的工作原理，并使用
    Unity3D 实现了一个简单的老虎机游戏。游戏中的概率是通过向角色的行为添加不确定性来使游戏和角色看起来更真实，这样玩家就无法预测结果。
- en: In the next chapter, we will look at implementing sensors and how they can make
    our AI aware of its surroundings.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何实现传感器以及它们如何使我们的AI感知其周围环境。
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To further study the advanced techniques on probability in games, such as decision
    making under uncertainty using Bayesian techniques, I recommend reading *AI for
    Game Developers* by David M. Bourg and Glenn Seeman. *Rules of Play* by Katie
    Salen is another suggested book on game design.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步研究游戏中概率的高级技术，例如使用贝叶斯技术进行不确定性决策，我推荐阅读David M. Bourg和Glenn Seeman合著的《AI for
    Game Developers》。Katie Salen的《Rules of Play》也是关于游戏设计的一本推荐书籍。
