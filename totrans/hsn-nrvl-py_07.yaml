- en: Autonomous Maze Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The maze navigation is a classic computer science problem related to the autonomous
    navigation domain. In this chapter, you will learn how neuroevolution-based methods
    can be used to solve the challenge of maze navigation. Also, we will explain how
    to define a goal-oriented fitness function using the fitness scores of the navigator
    agent calculated as a derivative of the agent's distance from the final goal.
    By the end of this chapter, you will understand the basics of training an autonomous
    navigation agent using neuroevolution methods and will be able to create the more
    advanced maze solver that will be introduced in the next chapter. You will become
    familiar with advanced visualization techniques that will make it easier to understand
    the results of algorithm execution. Also, you will obtain hands-on experience
    of writing simulators of maze-navigating robots and related maze environments
    using the Python programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will become familiar with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The deceptive nature of the maze navigation problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simulator of a maze-navigating robot equipped with an array of sensors
    and actuators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a goal-oriented fitness function to guide the process of creating an
    appropriate maze solver using the neuroevolution algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the experiments with a simple and hard-to-solve  maze configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following technical requirements should be met to complete the experiments
    described in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8/10, macOS 10.13 or newer, or modern Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anaconda Distribution version 2019.03 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter5](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter5)
  prefs: []
  type: TYPE_NORMAL
- en: Maze navigation problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The maze navigation problem is a classic computer science problem that is closely
    related to creating autonomous navigation agents that can find a path through
    ambiguous environments. The maze environment is an illustrative domain for the
    class of problems that have a deceptive fitness landscape. This means that the
    goal-oriented fitness function can have steep gradients of fitness scores in dead
    ends in the maze that are close to the final goal point. Such areas of the maze
    become the local optima for objective-based search algorithms that may converge
    in these areas. When the search algorithm converges in such deceptive local optima,
    it cannot find an adequate maze-solver agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you can see a two-dimensional maze with local optima
    dead ends, which are shaded in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd56ef1f-ea8c-4f17-8d58-62c569a8352f.png)'
  prefs: []
  type: TYPE_IMG
- en: The two-dimensional maze configuration
  prefs: []
  type: TYPE_NORMAL
- en: The maze configuration in the diagram visualizes the landscape of the deceptive
    fitness scores concentrated in the local optima dead ends (marked as filled segments).
    The maze-solver agent navigating from the starting point (bottom circle) to the
    exit point (top circle) using the objective-based search algorithm will be prone
    to getting stuck in the local optima dead ends. Also, a deceptive fitness score
    landscape such as this can prevent the objective-based search algorithm from finding
    a successful maze solver.
  prefs: []
  type: TYPE_NORMAL
- en: The agent navigating through the maze is a robot equipped with a set of sensors,
    allowing it to detect nearby obstacles and get the direction to the maze exit.
    The motion of the robot is controlled by two actuators, which affect the linear
    and angular movement of the robot body. The actuators of the robot are controlled
    by an ANN, which receives input from the sensors and produces the two control
    signals for the actuators.
  prefs: []
  type: TYPE_NORMAL
- en: Maze simulation environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The environment for the maze simulation consists of three major components
    that are implemented as separate Python classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Agent`: The class that holds information related to the maze navigator agent
    that is used by simulation (see the `agent.py`file for the implementation details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AgentRecordStore`: The class that manages the storage of records relating
    to evaluations of all the solver agents during the evolutionary process. The collected
    records can be used to analyze the evolutionary process after its completion (see
    the `agent.py` file for the implementation details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MazeEnvironment`: The class that contains information about the maze simulation
    environment. This class also provides methods that manage the simulation environment,
    control the position of a solver agent, perform collision detection, and generate
    the input data for sensors of the agent (see the `maze_environment.py` file for
    the implementation details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will look at each part of the maze simulation
    environment in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Maze-navigating agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we consider a two-dimensional maze navigation task. This task
    is easy to visualize, and it is relatively easy to write the simulator of the
    maze-navigating robot for a two-dimensional maze. The main goal of the robot is
    to navigate through a maze to the defined goal point in a specified number of
    time steps. The ANN that controls the robot is a product of the neuroevolution
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The neuroevolution algorithm starts with a very basic initial ANN configuration
    that only has input nodes for sensors and output nodes for actuators, which gradually
    becomes more complex until a successful maze solver is found. This task is complicated
    by a peculiar configuration of the maze that has several *cul-de-sacs*, which
    prevent finding the route to the goal by creating local optima in the fitness
    landscape, as discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the schematic drawing of the maze agent used in
    the maze-solving simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d5ee7a0-e182-4b03-9e75-4d8dab75b2f9.png)'
  prefs: []
  type: TYPE_IMG
- en: The maze agent (robot) schema
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the filled circle defines the rigid body of the robot.
    The arrow within the filled circle shows the heading of the robot. The six arrows
    around the filled circle represent **six rangefinder sensors** that indicate the
    distance to the nearest obstacle in a given direction. The four outer circle segments
    denote the **four pie-slice radar sensors** that act as a compass toward the goal
    point (maze exit).
  prefs: []
  type: TYPE_NORMAL
- en: The specific radar sensor becomes activated when the line from the goal point
    to the center of the robot falls within its **field of view** (**FOV**). The detection
    range of the radar sensor is limited by the area of the maze that falls into its
    FOV. Thus, at any given time, one of the four radar sensors is activated, indicating
    the maze exit direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The radar sensors have the following FOV zones relative to the robot''s heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sensor** | **FOV, degrees** |'
  prefs: []
  type: TYPE_TB
- en: '| Front | 315.0 ~ 405.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Left | 45.0 ~ 135.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Back | 135.0 ~ 225.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Right | 225.0 ~ 315.0 |'
  prefs: []
  type: TYPE_TB
- en: The rangefinder sensor is a trace ray drawn from the center of the robot in
    a specific direction. It becomes activated when intersecting with any obstacle
    and returns a distance to the detected obstacle. The detection range of this sensor
    is defined by a particular configuration parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rangefinder sensors of the robot monitor the following directions relative
    to the agent heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sensor** | **Direction, degrees** |'
  prefs: []
  type: TYPE_TB
- en: '| Right | -90.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Front-right | -45.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Front | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Front-left | 45.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Left | 90.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Back | -180.0 |'
  prefs: []
  type: TYPE_TB
- en: The movement of the robot is controlled by two actuators that apply forces that
    turn and/or propel the agent frame, that is, change its linear and/or angular
    velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python implementation of the maze-solver agent has multiple fields to hold
    its current state and to maintain the activation states of its sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For more implementation details, refer to the `agent.py` file at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/agent.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/agent.py).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows a default constructor of the `Agent` class, where all
    fields of the agent are initialized. The maze environment simulation will use
    those fields to store the current state of the agent at each simulation step.
  prefs: []
  type: TYPE_NORMAL
- en: Maze simulation environment implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To simulate the solver agent navigating the maze, we need to define an environment
    that manages the configuration of the maze, tracks the position of the maze-solving
    agent, and provides inputs to the sensor data arrays of the navigating robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these features fit into one logical block that is encapsulated into
    the `MazeEnvironment` Python class, which has the following fields (as can be
    seen from the class constructor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows the default constructor of the `MazeEnvironment` class
    with initialization of all its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: The maze configuration is determined by a list of walls and `exit_point`. Walls
    are lists of line segments; each line segment represents a specific wall in the
    maze, and `exit_point` is the location of maze's exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exit_range` field stores value of the range distance around the `exit_point`
    that defines the exit area. We consider that the agent has successfully solved
    a maze when its position is in the exit area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `agent` field holds a reference to the initialized `Agent` class described
    in the previous section, which defines the starting location of the solver agent
    in the maze among other agent-related data fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `initial_distance` field stores the distance from the agent's starting position
    to the maze exit point. This value will be later used for the agent's fitness
    score calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensor data generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maze-solver agent is controlled by an ANN that needs to receive sensor
    data as input to produce the corresponding control signals as output. As we have
    already mentioned, the navigator agent is equipped with an array of two types
    of sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: Six *rangefinder sensors* for the detection of collisions with the maze walls,
    which indicate the distance to the closest obstacle in a particular direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four *pie-slice radar sensors*, which indicate the direction to the maze's exit
    point from any place in the maze.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sensor values need to be updated at each simulation step, and the `MazeEnvironment`
    class provides two designated methods that update both types of sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array of rangefinder sensors is updated as follows (see the `update_rangefinder_sensors`
    function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code enumerates all detection directions of the rangefinder sensors, which
    are determined by the direction angles (see the `range_finder_angles` field initialization
    in the `Agent` constructor). For each direction, a projection line is then created,
    starting from the current position of the agent and with a length equal to the
    rangefinder's detection range. After that, the projection line is tested to see
    if it intersects any of the maze walls. If multiple intersections are detected,
    the distance to the closest wall is stored as a value to a specific rangefinder
    sensor. Otherwise, the maximal detection range will be saved as a value for a
    rangefinder sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array of pie-slice radar sensors needs to be updated with the following
    code in the `MazeEnvironment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a copy of the maze exit point and rotates it with
    respect to the agent's heading and position within the global coordinate system.
    The target point is then translated to align it with the local coordinate system
    of the maze-solver agent; the agent is placed at the origin of the coordinates.
    After that, we calculate the angle of the vector drawn from the origin of the
    coordinates to the target point within the local coordinate system of the agent.
    This angle is an azimuth to the maze exit point from the current agent position.
    When the azimuth angle is found, we enumerate over the registered pie-sliced radar
    sensors to find the one that includes the azimuth angle in its FOV. The corresponding
    radar sensor is activated by setting its value to 1, while other radar sensors
    are deactivated by zeroing their values.
  prefs: []
  type: TYPE_NORMAL
- en: Agent position update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The position of the maze-solver agent within a maze needs to be updated in
    each simulation step after receiving the corresponding control signals from the
    controller ANN. The following code is executed to update the position of the maze-solver
    agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `update(self, control_signals)` function is defined in the `MazeEnvironment`
    class and is invoked in each simulation time step. It receives a list with control
    signals as input and returns a Boolean value indicating whether the maze-solver
    agent has reached the exit area after its position update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code at the beginning of this function applies received control signals
    to the current values of the agent''s angular and linear velocities as follows
    (see the `apply_control_signals(self, control_signals)` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the `x` and `y` velocity components, along with the agents heading,
    are calculated and used to estimate its new position within the maze. If this
    new position doesn''t collide with any of the maze walls, then it is assigned
    to the agent and becomes its current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, the new agent position is used in the following functions, which
    update the rangefinder and radar sensors to estimate new sensor inputs for the
    next time step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following function tests whether the agent has reached the maze
    exit, which is defined by the circular area around the exit point with a radius
    equal to the value of the `exit_range` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the maze exit has been reached, the value of the `exit_found` field is set
    to `True` to indicate the successful completion of the task, and its value is
    returned from the function call.
  prefs: []
  type: TYPE_NORMAL
- en: For more implementation details, refer to the `maze_environment.py` file at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_environment.py).
  prefs: []
  type: TYPE_NORMAL
- en: Agents records store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After completing the experiment, we are interested in evaluating and visualizing
    how each individual solver agent performed during the evolutionary process through
    all generations. This is accomplished by collecting additional statistical data
    about each agent after running the maze-solving simulation for a specified number
    of time steps. The collection of agent records is mediated by two Python classes:
    `AgentRecord` and `AgentRecordStore`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AgentRecord` class consists of several data fields, as can be seen in
    the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generation` holds the ID of the generation when the agent record was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`agent_id` is a unique agent identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` and `y` is the agent''s position within the maze after a simulation has
    been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fitness` is the resulting fitness score of the agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hit_exit` is a flag that indicates whether the agent has reached the maze
    exit area or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`species_id` and `species_age` are the ID and age of the species the agent
    belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AgentRecordStore` class holds a list of agent records and provides functions
    to load/dump the collected records from/to the specific file.
  prefs: []
  type: TYPE_NORMAL
- en: See the `agent.py` file in the directory associated with this chapter in the
    source code repository for the complete implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'New `AgentRecord` instances are added to the store after evaluation of the
    genome fitness, as defined in the `eval_fitness(genome_id, genome, config, time_steps=400)` function
    implemented in the `maze_experiment.py` file. This is done with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code first creates a deep copy of the original maze environment to avoid
    interference between evaluation runs. After that, it creates the control ANN from
    the specified genome using the provided NEAT configuration and starts the evaluation
    of the maze simulation for a given number of time steps. The returned fitness
    score of the agent along with other statistics are then stored into a particular
    `AgentRecord` instance and are added to the record store.
  prefs: []
  type: TYPE_NORMAL
- en: The records collected during one trial of the experiment will be saved to the
    `data.pickle` file in the `output` directory and used to visualize the performance
    of all the evaluated agents.
  prefs: []
  type: TYPE_NORMAL
- en: See the `maze_experiment.py` file for the complete implementation details: [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_experiment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_experiment.py).
  prefs: []
  type: TYPE_NORMAL
- en: The agent record visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After all agents' evaluation records are collected during the neuroevolutionary
    process, we are interested in visualizing the recorded data to get insights into
    performance. The visualization should include the final positions of all solver
    agents and allow to set the threshold value for the fitness of the species to
    control what species will be added to the corresponding plot. We decided to present
    the collected agent records in two plots drawn one above the other. The top plot
    is for the agent records that belong to the species with a fitness score greater
    than or equal to the specified fitness threshold, and the bottom plot is for the
    rest of the records.
  prefs: []
  type: TYPE_NORMAL
- en: The visualization of the agent records is implemented in the new methods in
    the `visualize.py` script. You should already be familiar with this script from
    the previous experiments described in this book.
  prefs: []
  type: TYPE_NORMAL
- en: See the `draw_maze_records(maze_env, records, best_threshold=0.8, filename=None,
    view=False, show_axes=False, width=400, height=400)` function definition in the
    `visualize.py` file at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/visualize.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/visualize.py).
  prefs: []
  type: TYPE_NORMAL
- en: Objective function definition using the fitness score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn about the creation of successful maze-solver
    agents using a goal-oriented objective function to guide the evolutionary process.
    This objective function is based on the estimation of the fitness score of the
    maze solver by measuring the distance between its final position and the maze
    exit after executing the 400 simulation steps. Thus, the objective function is
    goal-oriented and solely depends on the ultimate goal of the experiment: reaching
    the maze exit area.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will consider a different approach for solution search
    optimization, which is based on the **Novelty Search** (**NS**) optimization method.
    The NS optimization method is built around exploring new configurations of the
    solver agent during evolution and doesn't include proximity to the final goal
    (in this case, the maze exit) in the objective function definition. We will demonstrate
    that the NS approach can outperform the conventional goal-oriented objective function
    definition that we consider in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal-oriented objective function used in this experiment is determined
    as follows. First, we need to define the loss function as the *Euclidean distance*
    between the final position of the agent at the end of the simulation and the position
    of the maze exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c15d4c04-be73-46a0-8646-389753f2063f.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/6cf451c8-aadb-4687-83ce-03c2010b1639.png) is a loss function, ![](img/81e08623-15b0-4415-ab2b-5ce0ca539338.png)
    is the coordinates of the final position of the agent, and ![](img/79fa5d4c-f267-4202-b143-38f359cf7e81.png)
    is the coordinates of the maze exit. In this experiment, we considered a two-dimensional
    maze configuration, so the coordinates have two values, one for each dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the loss function defined previously, we now can specify the fitness function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce2af4c9-1d4c-44b0-8e44-7283a2ee9c1e.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/77443d18-44e5-4825-ad13-e2e97b4fbea7.png) is the radius of the exit
    area around the maze exit point and ![](img/7eee273d-055d-4d6b-a6dd-e728f8d893bb.png)
    is the normalized fitness score. The normalized fitness score is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0806012-1153-441c-9cca-ecc9e2d334ea.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/412eae6e-5bcb-478b-abed-32e75ca636c1.png) is the initial distance from
    the solver agent to the maze exit at the start of the navigation simulation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation normalizes the fitness score to be in the range `(0,1]`, but can
    result in negative values in rare cases when the final position of the agent is
    far away from its initial position and the maze exit. The following amendments
    to the normalized fitness score will be applied to avoid negative values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a5fb3c0-5f4a-4ad0-8a6a-b8e87b8c6f69.png)'
  prefs: []
  type: TYPE_IMG
- en: When the fitness score is less than or equal to `0.01`, it will be assigned
    the minimal fitness score value (`0.01`) supported; otherwise, it will be used
    as is. We selected the minimal fitness score to be higher than zero to give every
    genome the chance to reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code in Python implements the goal-oriented objective function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code first invokes the `agent_distance_to_exit()` function, which calculates
    the Euclidean distance from the current agent position to the maze exit and uses
    the returned value as a first approximation of the fitness score. After that,
    the fitness score (distance to the maze exit) is compared with the exit range
    value. If the fitness score is less or equal to the exit range value, we assign
    it the final value of `1.0`. Otherwise, the normalized fitness score is calculated
    as a division of the difference between the final and initial distances from the
    agent to the maze exit by the initial distance. Sometimes, this can lead to a
    negative value of the normalized fitness value, which is corrected by comparing
    the fitness value with `0.01` and making the necessary amendments.
  prefs: []
  type: TYPE_NORMAL
- en: See the `maze_environment.py` script for complete implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Running the experiment with a simple maze configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start our experiments related to the creation of the successful maze navigation
    agent with a simple maze configuration. The simple maze configuration, while having
    the deceptive *local optima cul-de-sacs* discussed earlier, has a relatively straightforward
    path from the start point to the exit point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the maze configuration used for this experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a30ae052-0e37-42e9-bc05-602ff422106d.png)'
  prefs: []
  type: TYPE_IMG
- en: The simple maze configuration
  prefs: []
  type: TYPE_NORMAL
- en: The maze in the diagram has two specific positions marked with filled circles.
    The top-left circle denotes the starting position of the maze navigator agent.
    The bottom-right circle marks the exact location of the maze exit that needs to
    be found by the maze solver. The maze solver is required to reach the vicinity
    of the maze exit point denoted by the specific exit range area around it in order
    to complete the task.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the objective function definition, the maximum value of the navigator
    agent fitness score that can be obtained by reaching the maze exit area is `1.0`.
    We are also expecting that the initial configuration of the controller ANN is
    more complicated than in the previous experiments described earlier in the book,
    and this will impact the speed of the algorithm's execution. Due to this, it would
    take too long on a moderate PC to complete the neuroevolution algorithm with a
    significantly large genome population. But at the same time, the task at hand
    is much more complicated than in previous experiments and requires using a wider
    search area for successful solution exploration. Thus, through trial and error,
    we found that the population size can be set to `250`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section from the configuration file contains the definition of
    the parameters we''ve just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial configuration of the phenotype ANN includes `10` input nodes, `2`
    output nodes, and `1` hidden node. The input and output nodes correspond to the
    input sensors and the control signal outputs. The hidden node is provided to introduce
    non-linearity from the start of the neuroevolutionary process and to save time
    for the evolution process to discover it. The ANN configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To extend the solution search area, we need to boost the speciation of the population
    to try different genome configurations within a limited number of generations.
    This can be done either by reducing the compatibility threshold or by increasing
    the values of the coefficients that are used to perform the calculation of genome
    compatibility scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this experiment, we used both amendments because the fitness function landscape
    is deceptive, and we need to emphasize even tiny changes in the genome configurations
    to create a new species. The following configuration parameters are affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are particularly interested in creating the optimal configuration of a maze
    solver control ANN that has a minimum number of hidden nodes and connections.
    The optimal ANN configuration is less computationally expensive during training
    by the neuroevolutionary process, as well as during the inference phase in a maze-solving
    simulator. The optimal ANN configuration can be produced by reducing the likelihood
    of adding new nodes, as shown in the following snippet from the NEAT configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we allow the neuroevolutionary process to exploit not only the ANN
    configurations with feed-forward connections, but also recurrent ones. By having
    the recurrent connections, we enable the possibility for the ANN to have a memory
    and become a state machine. This happens to be beneficial for the evolutionary
    process. The following configuration hyperparameter controls this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The hyperparameters described in this section were found to be beneficial to
    the NEAT algorithm that is used in the experiment to create a successful maze-solving
    agent within a limited number of generations.
  prefs: []
  type: TYPE_NORMAL
- en: For the complete list of the hyperparameters used in the simple maze-solving
    experiment, please refer to the `maze_config.ini` file at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_config.ini](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter5/maze_config.ini).
  prefs: []
  type: TYPE_NORMAL
- en: Maze configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maze configuration for our experiment is provided in plain text. This file
    is loaded into the simulation environment, and the corresponding maze configuration
    becomes instantiated. The configuration file has content similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the maze configuration file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line holds the number of walls in the maze.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line determines the agent's starting position (*x*, *y*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line denotes the initial heading of the agent in degrees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth line holds the maze exit position (*x*, *y*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines define the walls of the maze. The number of maze walls is
    given by the first number in the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maze wall is presented as a line segment with the first two numbers defining
    the coordinates of the starting point and the last two numbers determining the
    coordinates of the endpoint. The starting position of the agent and the maze exit
    are presented in the form of two numbers indicating the *x* and *y* coordinates
    of a point in a two-dimensional space.
  prefs: []
  type: TYPE_NORMAL
- en: Working environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The working environment for the simple maze-solving experiment can be set up
    with the following commands entered in your terminal application of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These commands create and activate a `maze_objective_neat` virtual environment
    with Python 3.5\. After that, the NEAT-Python library with version 0.92 was installed,
    along with other dependencies used by our visualization utilities.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we are ready to start with the implementation of the experiment
    runner.
  prefs: []
  type: TYPE_NORMAL
- en: The experiment runner implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The experiment runner is implemented in the `maze_experiment.py` file, which you
    should refer to for the complete implementation details. This Python script provides
    functions to read command-line arguments, to configure and start the neuroevolution
    process, and to render the experiment's results after completion. Also, it includes
    the implementation of callback functions to evaluate the fitness of genomes belonging
    to the particular population. These callback functions will be provided to the
    NEAT-Python library environment during the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we discuss the essential parts of the experiment runner''s implementation
    that were not addressed previously in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by initializing the maze simulation environment with the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`args.maze` refers to the command-line argument supplied by the user when starting
    the Python script and refers to the type of maze environment with which we would
    like to experiment. It can have two values: *medium* and *hard*. The former refers
    to the simple maze configuration that we use in this experiment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we set the specific seed number for the random number generator,
    create the NEAT configuration object, and create the `neat.Population` object
    using the created configuration object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It happens that the random seed value found in the double-pole balancing experiment
    is suitable for this experiment too. We can assume that we found a random attractor
    that is specific to the stochastic process implemented by the NEAT-Python library.
    Later in the book, we will check whether this is true for other experiments as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to create the appropriate maze simulation environment and
    store it as a global variable to simplify access to it from the fitness evaluation
    callback functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `MazeSimulationTrial` object holds fields that provide access to the original
    maze simulation environment and to the record store used to save the evaluation
    results of the maze-solver agents. At each call to the fitness evaluation callback
    function, `eval_fitness(genome_id, genome, config, time_steps=400)`, the original
    maze simulation environment will be duplicated and will be used for the maze-solving
    simulation by a specific solver agent for 400 time steps. After that, the full
    statistics about the maze-solver agent, including its final position within the
    maze, will be collected from the environment and added to the record store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code has become standard for our experiments, and it is related
    to adding various statistics reporters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The reporters are used to display the intermediate results of the neuroevolution
    process to the console, as well as to collect more detailed statistics that will
    be rendered after the process is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we run the neuroevolution process for the specified number of generations
    and check whether the solution has been found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We assume that a solution has been found if the best genome returned by the
    NEAT-Python library has a fitness score that is greater than or equal to the fitness
    threshold value set in the configuration file (`1.0`). The elapsed time is calculated
    to print how long it took to complete the process.
  prefs: []
  type: TYPE_NORMAL
- en: Genome fitness evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The callback function to evaluate the fitness scores of all genomes belonging
    to a particular population of organisms is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `eval_fitness(genome_id, genome, config)` function evaluates the fitness
    of a specific genome by running the maze-solving simulation against the solver
    agent controlled by the ANN encoded with this genome. The implementation of this
    function is not provided here as it has already been discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Running the simple maze navigation experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having implemented the maze-solver simulator, as well as the experiment runner
    and fitness evaluation callbacks, we are ready to start a maze-solving experiment.
    Make sure you copy all the related Python scripts and configuration files (`maze_config.ini`
    and `medium_maze.txt`) into the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, enter this directory and execute the following command from your
    terminal application of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to activate the appropriate virtual environment with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conda activate maze_objective_neat`'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command loads the simple maze configuration from the `medium_maze.txt` file and
    creates the appropriate maze simulation environment. After that, it launches the
    neuroevolutionary process under the control of the NEAT algorithm, using the hyperparameters
    specified in the `maze_config.ini`file. The NEAT algorithm uses a maze-solver
    simulation environment to evaluate the fitness of every genome produced during
    the neuroevolution over `150` generations
  prefs: []
  type: TYPE_NORMAL
- en: (`-g` in the command-line arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'After `144` generations of evolution, the successful maze-solver agent is found
    at generation `145`. The console output for the last generation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, general statistics about the genome population:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, the configuration of the genome encoding the successful maze-solver
    controller ANN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console output, you can see that the successful maze solver controller
    was found during evolution and was able to reach the maze exit area in 388 steps
    from the allotted 400\. The configuration of the control ANN of the successful
    maze solver consists of 2 output nodes and 1 hidden node, with 11 connections
    in between these nodes and from the inputs. The final configuration of the controller
    ANN is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f5be19e-6d05-4715-8a90-d99e2c4d8c7f.png)'
  prefs: []
  type: TYPE_IMG
- en: The ANN configuration controlling a successful solver of a simple maze
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to look at the graph to study how different sensor inputs
    influence the output control signals. We can see that the ANN configuration completely
    ignores the inputs from the front and left rangefinder sensors (**RF_FR** and
    **RF_L**) and from the backward pie-slice radar sensor (**RAD_B**) of the robot.
    At the same time, the linear and angular velocities of the robot are controlled
    by unique combinations of other sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we can see the aggregation of the left and right pie-slice radar
    sensors (**RAD_L** and **RAD_R**) with the backward rangefinder (**RF_B**) through
    the hidden node, which then relayed an aggregated signal to a node controlling
    the angular velocity. If we take a look at the simple maze configuration image
    shown in this chapter (see the simple maze configuration image), the aggregation
    seems pretty natural. This allows the robot to turn around and continue to explore
    the maze when it is trapped in dead ends, where the local fitness optima are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fitness scores of the solver agents over generations is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7742ca6f-7471-4c1c-a546-46feb0ed5a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: The average fitness scores over generations
  prefs: []
  type: TYPE_NORMAL
- en: In this plot, we can see that the evolutionary process was able to produce pretty
    successful maze-solver agents at generation `44` with a fitness score of **0.96738**.
    But it took an additional 100 generations to evolve the genome that encodes the
    ANN of the successful maze-solver agent.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is interesting to note that the boost in performance at generation
    `44` is generated by the species with ID `1`, but the genome of the successful
    maze solver belongs to a species with ID `7`, which was not even known at the
    time of the first spike. The species producing the champion appeared after 12
    generations and remained in the population until the end, preserving the beneficial
    mutation and elaborating over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The speciation over generations is shown in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/496ddb2e-cbce-463a-8e06-8079fe6bd57c.png)'
  prefs: []
  type: TYPE_IMG
- en: The speciation over generations
  prefs: []
  type: TYPE_NORMAL
- en: On the speciation plot, we can see the species with ID `7` marked in pink. This
    species ultimately produced the genome of the successful maze solver during the
    evolutionary process. The size of species 7 varies considerably throughout its
    life, and at one time it was the only species in the entire population for several
    generations (from 105 until 108).
  prefs: []
  type: TYPE_NORMAL
- en: Agent record visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this experiment, we presented a new visualization method that allows us
    to visually discern the performance of various species in the evolutionary process.
    The visualization can be performed using the following command, executed from
    the working directory of the experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The command loads records about the fitness evaluation of each maze-solving
    agent during the evolution, which is stored in the `data.pickle` file. After that,
    it draws the final positions of the agents on the maze map at the end of the maze-solving
    simulation. Each agent''s final position is presented as a color-coded circle.
    The color of the circle encodes the species to which the particular agent belongs.
    Each species produced during the evolution has a unique color code. The results
    of this visualization can be seen in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0618c36d-4f70-4b38-91e4-9c565ea53733.png)'
  prefs: []
  type: TYPE_IMG
- en: The visualization of the evaluation of the solver agents
  prefs: []
  type: TYPE_NORMAL
- en: To make the visualization more informative, we have introduced the fitness threshold
    to filter out the most performant species. The top subplot shows the final positions
    of the solver agents belonging to the champion species (the fitness score is above
    **0.8**). As you can see, the organisms belonging to these six species are active
    explorers, who have genes inciting search through unknown places in the maze.
    Their final locations are distributed almost uniformly through the maze area around
    the starting point and have a low density at the local optima *cul-de-sacs*.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, you can see in the bottom subplot that the evolutionary losers
    demonstrate more conservative behavior, concentrating mainly near the walls in
    the starting area and in the strongest local optima region—the biggest *cul-de-sac*,
    which is at the bottom of the maze.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to increase the `compatibility_disjoint_coefficient` parameter in the `maze_config.ini` file
    and run the experiment with new settings. What impact does this modification have
    on the number of species produced during the evolution? Is the neuroevolution
    process able to find a successful maze solver?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the population size by 200% (the `pop_size` parameter). Was the neuroevolution
    process able to find a solution in this case, and if so, how many generations
    did it take?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the seed value of the random number generator (see line 118 of the `maze_experiment.py` file).
    Does the neuroevolution process succeed with this new value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the experiment with a hard-to-solve maze configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next experiment in this chapter is to run the neuroevolution process to
    find an agent that can solve a maze with a more complex configuration of walls.
    This hard-to-solve maze configuration introduces powerful local fitness optima
    traps and does not have a straightforward route from the start position of the
    agent to the exit area of the maze. You can see the maze configuration in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6a9ca88-aa2a-4fa0-b0b9-976e1312b55a.png)'
  prefs: []
  type: TYPE_IMG
- en: The hard-to-solve maze configuration
  prefs: []
  type: TYPE_NORMAL
- en: The maze configuration has its start position in the bottom-left corner, marked
    with a green circle, and the position of the maze exit point is in the top-left
    corner, marked with a red circle. You can see that, to solve the maze, the navigator
    agent must develop a complex control strategy that allows it to avoid the local
    fitness optima traps around the starting point. The control strategy needs to
    be able to follow an elaborate trajectory from the starting point to the exit,
    which has several turns and more local optima traps.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this experiment, we will use the same hyperparameters that we used in the
    simple maze solving experiment. Our idea is to have the same initial conditions
    for the neuroevolutionary algorithm and to see whether it can evolve a successful
    solver agent for a different, more complex maze configuration. This will indicate
    how well the algorithm generalizes using the hyperparameter settings used for
    a different maze configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Working environment setup and experiment runner implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The setup of the working environment remains the same as for a simple maze navigation
    experiment. The experiment runner implementation also remains the same. We only
    change the file describing the maze environment configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Running the hard-to-solve maze navigation experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned, we will use the same experiment runner implementation and
    the same NEAT hyperparameters settings as in the previous experiment. But we will
    configure the different maze environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while, when the experiment is over, we see that even after `500` generations
    of evolution, a successful maze solver has not been found. The best genome obtained
    using the neuroevolution algorithm encodes a bizarre and non-functional controller
    ANN configuration, which is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86d45012-74e5-49fd-b7e1-b5d3cd3ee482.png)'
  prefs: []
  type: TYPE_IMG
- en: ANN configuration controlling the solver of the hard-to-solve maze
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be seen in the graph that the rotation of the robot depends only on
    the frontal rangefinder sensor (**RF_FR**), and the linear movement is controlled
    by a combination of several rangefinders and radar sensors. Such control configuration
    leads to simplified linear movements of the robot until a wall is detected in
    front of the robot. Our assumption about motion patterns is confirmed when we
    look at the visualization of the agent evaluation records:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c570b8e-b28f-4f8f-afbe-59f83f72ed85.png)'
  prefs: []
  type: TYPE_IMG
- en: The visualization of solver agents' evaluation records
  prefs: []
  type: TYPE_NORMAL
- en: The visualization of the final positions of the solver agents demonstrates that
    most species are trapped around the start position, where some areas of local
    fitness score optima are located. None of the species could even show a fitness
    score above our threshold (**0.8**). Also, as we mentioned earlier, there are
    clearly distinguishable vertical lines formed by the final positions of the solver
    agents (gray dots creating vertical columns). This confirms our assumption about
    the incorrect configuration of the controller ANN that was encoded by the best
    genome found during the evolutionary process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The average fitness scores over generations are shown in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8988407f-0d34-4c5e-9cb0-823a070d778c.png)'
  prefs: []
  type: TYPE_IMG
- en: The average fitness score over generations
  prefs: []
  type: TYPE_NORMAL
- en: In the plot of the average fitness scores, we can see that the neuroevolutionary
    process was able to significantly increase the fitness scores of solver agents
    in the very first generations, but after that it reached a plateau, showing no
    improvements. This means that a further increase in the number of evolutionary
    generations does not make any sense, and other measures need to be taken to improve
    the performance of the neuroevolutionary process.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to increase the population size by tweaking the `pop_size` parameter in
    the `maze_config.ini` file. Did this help the neuroevolutionary process to evolve
    a successful maze solver?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This may take a long time to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about a class of planning and control problems
    that use goal-oriented fitness functions that have a deceptive definition landscape.
    In this landscape, there are multiple traps created by the local optima areas
    of the fitness function that mislead the solution search process, which is based
    only on the fitness score calculated as a derivative of the distance from the
    agent to the goal. You have learned that the conventional goal-oriented fitness
    function can help the search process to create a successful maze navigator agent
    for a simple maze configuration, but failed with a more complex maze due to the
    local optima traps.
  prefs: []
  type: TYPE_NORMAL
- en: We presented a useful visualization method that allowed us to visualize the
    final positions of all evaluated agents on the maze map. With this visualization,
    you can make assumptions about the performance of the evolutionary process. You
    can then make decisions about changes to the configuration settings that may lead
    to further performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you have learned that when there is a higher chance of fitness function
    convergence in the local optima, the neuroevolution process tends to produce fewer
    species. In extreme cases, it creates only one species, which impedes innovation
    and hinders the evolutionary process. To avoid this, you learned how speciation
    can be boosted by changing the value of the compatibility disjoint coefficient,
    which is used in the calculation of the genome compatibility factor. This coefficient
    controls the weight that will be assigned to the excess or disjoint parts of genomes
    being compared. Higher coefficient values increase the importance of topological
    differences in the compared genomes and allow more diverse genomes to belong to
    the same species.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will present the NS optimization method, which is better
    at solving deceptive tasks such as maze navigation.
  prefs: []
  type: TYPE_NORMAL
