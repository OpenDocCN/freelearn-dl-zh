<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Pole-Balancing Experiments</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, you will learn about a classic reinforcement learning experiment, which is also an established benchmark for testing various implementations of the control strategies. In this chapter, we consider three modifications of the cart-pole balancing experiment and develop control strategies that can be used to stabilize the cart-pole apparatuses of given configurations. You will learn how to write accurate simulations of real-life physical systems and how to use them for a definition of the objective function for the NEAT algorithm. After this chapter, you will be ready to apply the NEAT algorithm to implement controllers that can be directly used to control physical appliances.</p>
<p class="p1"><span class="s1">In this chapter, we will cover the following topics:</span></p>
<ul class="ul1">
<li class="li1"><span class="s1">The single-pole balancing problem in reinforcement learning</span></li>
<li class="li1"><span class="s1">Implementation of the simulator of the cart-pole apparatus in Python</span></li>
<li class="li1"><span class="s1">How to define the objective function of a single-pole balancing controller using the simulator</span></li>
<li class="li1"><span class="s1">The peculiarities of the double-pole balancing problem</span></li>
<li class="li1"><span class="s1">Implementation of the simulator of the cart-pole apparatus with two poles in Python</span></li>
<li class="li1"><span class="s1">How to define the objective function for the double-pole balancing controller</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The following technical requirements should be met to execute the experiments described in this chapter:</p>
<ul>
<li>Windows 8/10, macOS 10.13 or newer, modern Linux</li>
<li><span>Anaconda Distribution version 2019.03 or newer</span></li>
</ul>
<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The single-pole balancing problem</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The single-pole balancer (or <em>inverted pendulum</em>) is an unstable pendulum that has its center of mass above its pivot point. It can be stabilized by applying external forces under the control of a specialized system that monitors the angle of the pole and moves the pivot point horizontally back and forth under the center of mass as it starts to fall. The single-pole balancer is a classic problem in dynamics and control theory that is used as a benchmark for testing control strategies, including strategies based on reinforcement learning methods. We are particularly interested in the implementation of the specific control algorithm that uses neuroevolution-based methods to stabilize the inverted pendulum for a given amount of time.</span></p>
<p class="p1">The experiment described in this chapter considers the simulation of the inverted pendulum implemented as a cart that can move horizontally with a pivot point mounted on top of it, that is, the cart and pole apparatus. The apparatus is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-756 image-border" src="assets/04194552-ebae-4b1d-9065-f5b8b24bd0d3.png" style="width:42.67em;height:24.75em;"/></p>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1">The cart and single-pole apparatus</span></div>
<p>Before we start writing the source code of the simulator, we need to determine the equation of motion that can be used to estimate the values of the state variables of the pole balancer at any given time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The equations of motion of the single-pole balancer</h1>
                </header>
            
            <article>
                
<p>The goal of the controller is to exert a sequence of forces, <img class="fm-editor-equation" src="assets/da59aea6-7aaf-4dcc-b9b9-71b57429240c.png" style="width:1.17em;height:1.00em;"/>, on the center of mass of the cart such that the pole balanced for a specific (or infinite) amount of time and the cart stays within the track, that is, doesn't hit left or right walls. Taking into account the mechanics described here, we can qualify the pole-balancing task as an <em>avoidance control problem</em>, because the state of the cart-pole apparatus must be maintained to avoid certain regions of the state space. No unique solution exists for appropriate state estimation, and any solution of equations of motion that enables the avoidance of certain regions is acceptable.</p>
<p>The learning algorithm needs to receive a minimal amount of knowledge about the task from the environment to train the pole-balancing controller. Such knowledge should reflect how close our controller is to the goal. The goal of the pole-balancing problem is to stabilize an inherently unstable system and keep it balanced for as long as possible. Thus, the reinforcement signal (<img class="fm-editor-equation" src="assets/26ea1e55-3d34-4214-8331-06b49b30babf.png" style="width:0.83em;height:0.83em;"/>) received from the environment must reflect the occurrence of a failure. The failure can be caused either by the pole falling past a predefined angle or the cart hitting the boundaries of the track. The reinforcement signal, <img class="fm-editor-equation" src="assets/bd9c30b3-3068-43dd-b7d3-1095f8352daf.png" style="width:0.92em;height:0.92em;"/>, can be defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/7d4d96cc-9586-408a-a885-40932a4e22cf.png" style="width:36.33em;height:2.75em;"/></p>
<p>In this equation, <img class="fm-editor-equation" src="assets/d8e041b6-58a4-4246-a4a9-573157c6ed86.png" style="width:0.75em;height:0.92em;"/> is the angle between the pole and vertical positive in a clockwise direction, and <img class="fm-editor-equation" src="assets/2396aff1-1592-49c4-a48d-8ff923372a48.png" style="width:1.00em;height:0.75em;"/> is the horizontal position of the cart relative to the track. </p>
<div class="packt_infobox">Note that the reinforcement signal, <img class="fm-editor-equation" src="assets/8dab6ab8-0563-45f3-9987-f3b998fd51a9.png" style="width:0.83em;height:0.92em;"/>, doesn't depend on either the angular pole velocity (<img class="fm-editor-equation" src="assets/3a0f38ae-f21b-4581-98b9-2519f93c205f.png" style="width:0.58em;height:1.08em;"/>) or the horizontal cart speed (<img class="fm-editor-equation" src="assets/69dc9bb7-9be3-4dc6-b951-1dcc2e2483a8.png" style="width:0.67em;height:0.92em;"/>). It only provides information on whether the dynamics of the cart-pole system is within defined constraints.</div>
<p>The motion-dynamic equations for the cart-pole system, ignoring friction, are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b872602d-f323-45d6-bd34-bf79162e33db.png" style="width:18.92em;height:6.50em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/569d99aa-eb6f-4478-b2ab-cf9019ff492c.png" style="width:15.33em;height:3.17em;"/></p>
<p>In this equation, <img class="fm-editor-equation" src="assets/a74032f1-8797-452d-aba9-88d20e0a3138.png" style="width:0.58em;height:1.08em;"/> is the angular velocity of the pole, and <img class="fm-editor-equation" src="assets/a563f582-b8d8-459d-8399-b1d20863f099.png" style="width:0.58em;height:1.08em;"/> is the angular acceleration of the pole. Furthermore, <img class="fm-editor-equation" src="assets/75f31906-f413-4400-9508-27f1c3d199c4.png" style="width:0.67em;height:0.92em;"/> is the horizontal velocity of the cart and <img class="fm-editor-equation" src="assets/f4d891cd-5fec-4d08-b2ab-70bf4e6c49d3.png" style="width:0.67em;height:0.92em;"/> is the acceleration of the cart along the <img class="fm-editor-equation" src="assets/5bc9487f-6bb1-4e33-9c68-c8b5040bf8c5.png" style="width:0.67em;height:0.67em;"/>-axis.</p>
<p>In our experiment, the following system parameters are used:</p>
<ul>
<li><img class="fm-editor-equation" src="assets/c3b5660e-a3be-4e08-9895-3ca305f63b0a.png" style="width:5.58em;height:1.17em;"/>  <span>is the mass of the cart.</span></li>
<li><img class="fm-editor-equation" src="assets/6fc8f666-84e7-4697-8c44-6e6e6b42a62d.png" style="width:5.75em;height:1.25em;"/>  is the mass of the pole.</li>
<li><img class="fm-editor-equation" src="assets/0c6ee46a-7895-45dd-8f53-a40ee215dfb7.png" style="width:4.67em;height:0.92em;"/>  is the distance from the center of mass of the pole to the pivot.</li>
<li><img class="fm-editor-equation" src="assets/766ff045-f59f-45b1-a859-2f2276c99c6d.png" style="width:5.58em;height:1.42em;"/> is the acceleration due to gravity.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State equations and control actions</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The cart-pole system for the experiment is simulated by numerically approximating the equations of motion using Euler's method with a time step of <img class="fm-editor-equation" src="assets/15d32731-3561-401b-8c1f-2572a9e32d62.png" style="width:3.83em;height:0.92em;"/> seconds. Thus, the state equations can be defined as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/eb31ceb3-2e5c-4a37-a79b-7971acad5a74.png" style="width:9.33em;height:1.33em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9ab5e970-1363-42a8-a143-6065a69b8222.png" style="width:9.33em;height:1.33em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/db3b725e-234b-4f0a-810a-614033f041c7.png" style="width:8.75em;height:1.75em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9f5d47cd-9318-4420-8c73-3c4928712df9.png" style="width:8.50em;height:1.67em;"/></p>
<p>For a small range of pole angles, as used in our experiment, we can use the linear approximation of the surface that divides the space of all possible states of the system that require different actions (the switching surface). Thus, the action space consists of left and right push actions. The cart-pole controller that we use in our experiment is not designed to produce a zero force. Instead, at each time step, <img class="fm-editor-equation" src="assets/a9bcebe7-b837-4fb4-94c3-8321270bb1d5.png" style="width:0.50em;height:1.08em;"/>, it applies a force to the cart's center of mass with equal amplitude, but in the opposite direction. Such a control system has a name (<em>bang-bang controller</em>) and can be defined with the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f0b8468b-d784-4fd5-b5fa-773694a2f120.png" style="width:13.50em;height:2.75em;"/></p>
<p class="p1"><span class="s1">In this equation, <img class="fm-editor-equation" src="assets/96c1b1e3-df69-433d-b53c-a747378fe6f6.png" style="width:1.50em;height:1.25em;"/> is an action signal received from the solver. Given the action value, the bang-bang controller applies the force, <img class="fm-editor-equation" src="assets/a7c80f82-cb8e-4b5b-b2f0-6902d406c4bb.png" style="width:1.25em;height:1.08em;"/>, of the same magnitude (<kbd>10</kbd> Newtons) but in the opposite direction, depending on the action selected.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The interactions between the solver and the simulator</h1>
                </header>
            
            <article>
                
<p>The solver receives scaled values of the state variables described previously at each given time, <img class="fm-editor-equation" src="assets/bad9077a-b37c-4c92-ab5e-c3ce78033789.png" style="width:0.50em;height:1.08em;"/>. These values serve as inputs to the ANNs created from the phenotypes of the solver genomes and are defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/27403595-0fc3-41f3-9f56-f017f9ac11d8.png" style="width:5.83em;height:1.50em;"/>,</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/a96e3891-a4dc-45bc-816f-19edc4c593b9.png" style="width:11.83em;height:2.67em;"/>,</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/7aed04f2-fdda-4b48-b276-6f3591bca4c8.png" style="width:10.58em;height:2.58em;"/>,<br/>
<img class="fm-editor-equation" src="assets/7f6d4b84-7103-4c6a-a5b2-eb32f337b7e6.png" style="width:12.08em;height:2.50em;"/>,</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6ec11018-42cc-4fbe-b4f4-3c52ddebbab5.png" style="width:9.58em;height:2.50em;"/>.</p>
<p class="p1"><span class="s1">In the first equation, <img class="fm-editor-equation" src="assets/1029b3f4-cc37-405c-8a2e-cb1fcd3e1c8f.png" style="width:1.25em;height:0.92em;"/> is a constant bias value and <img class="fm-editor-equation" src="assets/bed0a79c-afd6-4d3e-954e-bf18119af381.png" style="width:4.25em;height:0.92em;"/> correspond to the cart's horizontal position, its horizontal speed, the pole angle from vertical, and its angular speed, respectively.</span></p>
<p>Taking into account the system constraints defined previously (see <img class="fm-editor-equation" src="assets/5405e25b-263b-4b23-9a7c-bb926b1f6e7f.png" style="width:0.92em;height:0.92em;"/>), the scaled values of <img class="fm-editor-equation" src="assets/0020bc36-496d-45a9-a6cb-e07d173269f6.png" style="width:1.17em;height:0.83em;"/> and <img class="fm-editor-equation" src="assets/92d3c005-8913-4062-a2cd-0875e6ffcdde.png" style="width:1.17em;height:0.83em;"/> are guaranteed to be within the <kbd>[0,1]</kbd> range, while the scaled values of <img class="fm-editor-equation" src="assets/88387d60-8a76-48dd-95ac-74cfaf15c01b.png" style="width:1.25em;height:0.92em;"/> and <img class="fm-editor-equation" src="assets/94eef5a7-8b78-44aa-95ce-e3ad28939679.png" style="width:1.17em;height:0.83em;"/> mostly fall within the <kbd>[0,1]</kbd> range, but can fall outside these bounds eventually. The state variables are scaled to accomplish the two essential goals:</p>
<ul class="ol1">
<li class="li1"><span class="s2">To remove the learning bias that can arise when terms with predominantly large magnitudes have a more significant impact on the learner due to the rounding effects.</span></li>
<li class="li1"><span class="s2">For this particular task, since the values of state variables are centered around zero, it is possible to find an ANN solver that doesn't need any hidden units. However, we are interested in evolving the topology of neural networks with the NEAT algorithm. The introduced scaling scheme ensures that the neuroevolution process eventually produces phenotypes that encode the hidden units.</span></li>
</ul>
<p>The pole-balancing controller takes the scaled inputs and produces an output that is a binary value determining the action to be applied at time <em><strong>t</strong></em>, as discussed earlier. The sampling rate of the state variables of the cart-pole system and the rate at which the control force is applied are the same as the simulation rate, <img class="fm-editor-equation" src="assets/f6062caf-1343-4a5e-ad79-7a21226005d7.png" style="width:4.83em;height:1.08em;"/>.</p>
<p>Thus, the initial configuration of the controller's ANN can be depicted as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-757 image-border" src="assets/1664e358-d178-4ce9-8b25-1ff3c52f5243.png" style="width:21.50em;height:14.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The initial ANN configuration of a single-pole balancing controller</div>
<p>The initial configuration of the single-pole balancing controller's ANN includes five input nodes for the horizontal position of the cart (<strong>x1</strong>) and its velocity (<strong>x2</strong>), for the vertical angle of the pole <span>(<strong>x3</strong>)</span> and its angular velocity <span>(<strong>x4</strong>)</span>, and an additional input node for bias <span>(<strong>x0</strong>) </span>(<em>which can be optional depending on the particular NEAT library used</em>). The output node (<strong>a</strong>) is a binary node providing the control signal to the [<kbd>0</kbd> or <kbd>1</kbd>] application. The hidden node (<strong>h</strong>) is optional and can be skipped.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Objective function for a single-pole balancing experiment</h1>
                </header>
            
            <article>
                
<p>Our goal is to create a pole balancing controller that's able to maintain a system in a stable state within defined constraints for as long as possible, but at least for the expected number of time steps specified in the experiment configuration (500,000). Thus, the objective function must optimize the duration of stable pole-balancing and can be defined as the logarithmic difference between the expected number of steps and the actual number of steps obtained during the evaluation of the phenotype ANN. The loss function is given as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b6168406-2921-4200-b53b-075bb365fc0b.png" style="width:11.75em;height:2.83em;"/></p>
<p>In this experiment, <img class="fm-editor-equation" src="assets/bf1d2e38-3978-46e1-bcca-2642dc98a7fb.png" style="width:2.25em;height:1.08em;"/> is the expected number of time steps from the configuration of the experiment, and <img class="fm-editor-equation" src="assets/4e8600b4-f33e-4657-bc81-b0d5d52cef57.png" style="width:1.92em;height:1.00em;"/> is the actual number of time steps during which the controller was able to maintain a stable pole balancer state within allowed bounds (refer to the reinforcement signal definition for details about permissible bounds).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cart-pole apparatus simulation</h1>
                </header>
            
            <article>
                
<p>The given definition of the objective function assumes that we can measure the number of time steps during which the single-pole balancer was in a stable state. To perform such measurements, we need to implement the simulator of the cart-pole apparatus, using the equations of motion and data constraints defined earlier.</p>
<p>The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4</a>.</p>
<p>First, we need to create a file called <kbd>cart_pole.py</kbd> in the <kbd>work</kbd> directory. This file contains the source code of the equations of motion and the function for evaluating the fitness of a single-pole balancer:</p>
<ol>
<li>We start with a definition of the constants describing the physics of the cart-pole apparatus:</li>
</ol>
<pre style="padding-left: 60px"> GRAVITY = 9.8 # m/s^2<br/> MASSCART = 1.0 # kg<br/> MASSPOLE = 0.5 # kg<br/> TOTAL_MASS = (MASSPOLE + MASSCART)<br/> # The distance from the center of mass of the pole to the pivot<br/> # (actually half the pole's length)<br/> LENGTH = 0.5 # m<br/> POLEMASS_LENGTH = (MASSPOLE * LENGTH) # kg * m<br/> FORCE_MAG = 10.0 # N<br/> FOURTHIRDS = 4.0/3.0<br/> # the number seconds between state updates <br/> TAU = 0.02 # sec</pre>
<ol start="2">
<li>After that, we are ready to implement the equations of motion using these constants:</li>
</ol>
<pre style="padding-left: 60px">    force = -FORCE_MAG if action &lt;= 0 else FORCE_MAG<br/>    cos_theta = math.cos(theta)<br/>    sin_theta = math.sin(theta)<br/>    temp = (force + POLEMASS_LENGTH * theta_dot * theta_dot * \<br/>           sin_theta) / TOTAL_MASS<br/>    # The angular acceleration of the pole<br/>    theta_acc = (GRAVITY * sin_theta - cos_theta * temp) /\ <br/>                  (LENGTH * (FOURTHIRDS - MASSPOLE * \<br/>                   cos_theta * cos_theta / TOTAL_MASS))<br/>    # The linear acceleration of the cart<br/>    x_acc = temp - POLEMASS_LENGTH * theta_acc * \<br/>            cos_theta / TOTAL_MASS<br/>    # Update the four state variables, using Euler's method.<br/>    x_ret = x + TAU * x_dot<br/>    x_dot_ret = x_dot + TAU * x_acc<br/>    theta_ret = theta + TAU * theta_dot<br/>    theta_dot_ret = theta_dot + TAU * theta_acc</pre>
<div class="p1 packt_infobox"><span class="s1">Refer to the <kbd>do_step(action, x, x_dot, theta, theta_dot)</kbd> function implementation in the source code of this chapter for full details.</span></div>
<p>The preceding code snippet uses the current system state <span>(<kbd>x, x_dot, theta, theta_dot</kbd>) along with a control action as input and applies the equations of motion described earlier to update the system state for the next time step. The updated system state then returns to update the simulator and to check for constraint violations. Thus, the simulation cycle is organized, as described in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The simulation cycle</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Now we have fully implemented the equations of motion and the numerical approximation of the state variables for one step of the cart-pole apparatus simulation. With this, we are ready to start the implementation of a full simulation cycle, which uses the ANN of the controller to evaluate the current system state and to select the appropriate action (the force to be applied) for the next step. The ANN mentioned previously is created for each genome of the population for a particular generation of evolution, allowing us to evaluate the performance of all genomes.</span></p>
<div class="p1 packt_infobox"><span class="s1">Refer to the <kbd>run_cart_pole_simulation(net, max_bal_steps, random_start=True)</kbd> function implementation for complete implementation details.</span></div>
<p>We can refer to the following steps to perform the <span>implementation of a full simulation cycle:</span></p>
<ol>
<li>First, we need to initialize the initial state variables, either with zeros or with random values within the constraints described previously and centered around zero. The random state values can be created as follows:</li>
</ol>
<pre style="padding-left: 60px">    # -1.4 &lt; x &lt; 1.4<br/>    x = (random.random() * 4.8 - 2.4) / 2.0<br/>    # -0.375 &lt; x_dot &lt; 0.375<br/>    x_dot = (random.random() * 3 - 1.5) / 4.0 <br/>    # -0.105 &lt; theta &lt; 0.105<br/>    theta = (random.random() * 0.42 - 0.21) / 2.0<br/>    # -0.5 &lt; theta_dot &lt; 0.5<br/>    theta_dot = (random.random() * 4 - 2) / 4.0</pre>
<div class="packt_infobox">We intentionally reduced the range of all values compared to the corresponding scaled constraints to make sure that the algorithm does not start in the critical state, that is, when stabilization is no longer possible.</div>
<ol start="2">
<li>After that, we are ready to start the simulation cycle over the defined number of steps, which are specified by the <kbd>max_bal_steps</kbd> parameter. The following <span>code </span>is executed inside the <em>simulation loop</em>.</li>
<li>The state variables need to be scaled to fit into the <kbd>[0,1]</kbd> range before being loaded as inputs into the ANN of the controller. This procedure has a computational and evolutionary advantage, as previously described. The bias value is not explicitly provided because the NEAT-Python framework handles it internally, so the inputs of the ANN can be defined as follows in the source code:</li>
</ol>
<pre style="padding-left: 60px">    input[0] = (x + 2.4) / 4.8<br/>    input[1] = (x_dot + 1.5) / 3<br/>    input[2] = (theta + 0.21) / .42<br/>    input[3] = (theta_dot + 2.0) / 4.0</pre>
<ol start="4">
<li>Next, the scaled inputs can be used to activate the ANN of the phenotype, and its output is used to produce a discrete value of the action:</li>
</ol>
<pre style="padding-left: 60px">    # Activate the NET<br/>    output = net.activate(input)<br/>    # Make action values discrete<br/>    action = 0 if output[0] &lt; 0.5 else 1</pre>
<ol start="5">
<li>With the produced value of the action and the current values of the state variables, you can run a single step of the cart-pole simulation. After the simulation step, the returned state variables are tested against the constraints to check whether the state of the system is still within the boundaries.</li>
</ol>
<p style="padding-left: 60px">In case of failure, the current number of simulation steps is returned, and its value will be used to evaluate the fitness of the phenotype:</p>
<pre style="padding-left: 60px">    # Apply action to the simulated cart-pole<br/>    x, x_dot, theta, theta_dot = do_step(action = action, <br/>                      x = x, x_dot = x_dot, <br/>                      theta = theta, theta_dot = theta_dot )<br/><br/>    # Check for failure due constraints violation. <br/>    # If so, return number of steps.<br/>    if x &lt; -2.4 or x &gt; 2.4 or theta &lt; -0.21 or theta &gt; 0.21:<br/>        return steps</pre>
<p class="p1"><span class="s1">If the controller's ANN was able to maintain a stable state of the cart-pole apparatus balancing for all simulation steps, the value with the maximum number of simulation steps is returned by the <kbd>run_cart_pole_simulation</kbd> function.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Genome fitness evaluation</h1>
                </header>
            
            <article>
                
<p>Using the number of successful simulation steps returned by the <kbd>run_cart_pole_simulation</kbd> function described earlier, we are ready to implement the genome fitness evaluation function:</p>
<ol>
<li>First, we run the cart-pole simulation loop, which returns the number of successful simulation steps:</li>
</ol>
<pre style="padding-left: 60px">    steps = run_cart_pole_simulation(net, max_bal_steps)</pre>
<ol start="2">
<li>After that, we are ready to evaluate the fitness score of the particular genome, as described previously:</li>
</ol>
<pre style="padding-left: 60px">    log_steps = math.log(steps)<br/>    log_max_steps = math.log(max_bal_steps)<br/>    # The loss value is in range [0, 1]<br/>    error = (log_max_steps - log_steps) / log_max_steps<br/>    # The fitness value is a complement of the loss value<br/>    fitness = 1.0 - error</pre>
<div class="p1 packt_infobox"><span class="s1">Refer to the <kbd>eval_fitness(net, max_bal_steps=500000)</kbd> function for more details.</span></div>
<p><span>We use a logarithmic scale because most simulation runs fail in about 100 steps,</span> <span>but we test against <kbd>500000</kbd></span><span> balancing steps.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The single-pole balancing experiment</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Now that we have an objective function defined and implemented along with a simulation of cart-pole apparatus dynamics, we are ready to start writing the source code to run the neuroevolutionary process with the NEAT algorithm. We will use the same NEAT-Python library as in the XOR experiment in the previous chapter, but with the NEAT hyperparameters adjusted appropriately. The hyperparameters are stored in the</span> <kbd>single_pole_config.ini</kbd><em> </em><span>file</span><span>, which can be found in the source code repository related to this chapter. You need to copy this file into your local <kbd>Chapter4</kbd> directory, in which you already should have a Python script with the cart-pole simulator we created earlier.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hyperparameter selection</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In the NEAT section of the configuration file, we define the population of organisms set <span><span>to</span></span> <img class="fm-editor-equation" src="assets/213bc840-04cb-428f-bd8f-84a908f856ae.png" style="width:1.50em;height:0.83em;"/> individuals, and the fitness threshold with a value of</span> <kbd>1.0</kbd><span class="s1"> as a termination criterion.</span></p>
<p class="p1"><span class="s1">The <kbd>fitness_criterion</kbd> is set to <kbd>max</kbd>, which means that the evolutionary process terminates when any individual reaches a fitness score equal to the <kbd>fitness_threshold</kbd> value: </span></p>
<pre>[NEAT]<br/>fitness_criterion   = max<br/>fitness_threshold   = 1.0<br/>pop_size            = 150<br/>reset_on_extinction = False</pre>
<p>Also, we significantly decreased the probability of adding the new node to bias the evolutionary process into elaborating more on the connectivity patterns with a minimal number of ANN nodes in the controller. Thus, we aim to reduce the energy consumption of the evolved controller's ANN and to reduce the computational costs of training.</p>
<p>The corresponding parameters in the configuration file are as follows:</p>
<pre># node add/remove rates<br/>node_add_prob    = 0.02<br/>node_delete_prob = 0.02</pre>
<p>The parameters describing our initial network configuration by a count of hidden, input, and output nodes are given as follows:</p>
<pre># network parameters<br/>num_hidden = 0<br/>num_inputs = 4<br/>num_outputs = 1</pre>
<p>We increased the species' compatibility threshold to bias the evolutionary process into producing fewer species. Also, we increased the minimum species' size to indicate that we are interested in much more highly populated species that have a bigger chance of preserving beneficial mutations. At the same time, we decreased the maximal stagnation age to intensify the evolutionary process by heightening the early extinction of stagnated species that do not show any fitness improvements.</p>
<p>The related parameters in the configuration file are as follows:</p>
<pre>[DefaultSpeciesSet]<br/>compatibility_threshold = 4.0<br/><br/>[DefaultStagnation]<br/>species_fitness_func = max<br/>max_stagnation = 15<br/>species_elitism = 2<br/><br/>[DefaultReproduction]<br/>elitism = 2<br/>survival_threshold = 0.2<br/>min_species_size = 8</pre>
<div class="packt_infobox">Refer to the <kbd>single_pole_config.ini</kbd><span> configuration file for full details.</span></div>
<p>As a result of the configuration parameters, more populated species will be used during the evolutionary process; however, the number of unique species will be kept low.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working environment setup</h1>
                </header>
            
            <article>
                
<p>Before you start writing the source code of the experiment runner, you must set up a virtual Python environment and install all the necessary dependencies. You can do this with Anaconda by executing the following commands in the command line:</p>
<pre><strong>$ conda create --name single_pole_neat python=3.5</strong><br/><strong>$ conda activate single_pole_neat</strong><br/><strong>$ pip install neat-python==0.92 </strong><br/><strong>$ conda install matplotlib</strong><br/><strong>$ conda install graphviz</strong><br/><strong>$ conda install python-graphviz</strong></pre>
<p>First, these commands create and activate a <kbd>single_pole_neat</kbd> virtual environment with Python 3.5. After that, the NEAT-Python library, version 0.92, is installed, along with the other dependencies used by our visualization utilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The experiment runner implementation</h1>
                </header>
            
            <article>
                
<p>First, you need to create a <kbd>single_pole_experiment.py</kbd> file in the <kbd>Chapter4</kbd> directory. In that file, the source code of the single-pole balancing experiment will be written. Also, you need to copy the <kbd>visualize.py</kbd> <span>file </span>from the chapter's repository into this directory as well. We will use the visualization utilities from this file to render the results of the experiment.</p>
<p>The experiment runner script includes two essential functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function to evaluate the fitness of all genomes in the population</h1>
                </header>
            
            <article>
                
<p>The first function evaluates the list of all genomes in the population and assigns a fitness score to each of them. This function is passed by reference into the neuroevolution runner of the NEAT-Python library. The source code of this function is as follows:</p>
<pre>def eval_genomes(genomes, config):<br/>    for genome_id, genome in genomes:<br/>        genome.fitness = 0.0<br/>        net = neat.nn.FeedForwardNetwork.create(genome, config)<br/>        fitness = cart.eval_fitness(net)<br/>        if fitness &gt;= config.fitness_threshold:<br/>            # do additional steps of evaluation with random initial states<br/>            # to make sure that we found stable control strategy rather <br/>            # than special case for particular initial state<br/>            success_runs = evaluate_best_net(net, config, <br/>                                             additional_num_runs)<br/>            # adjust fitness<br/>            fitness = 1.0 - (additional_num_runs - success_runs) / \<br/>                      additional_num_runs<br/><br/>        genome.fitness = fitness</pre>
<div class="packt_infobox">Note that we are introducing additional simulation runs for the winning genome to make sure that its control strategy is stable when starting from a variety of random initial states. This additional check guarantees that we have found the real winner rather than a special case that's specific to a particular initial state.</div>
<p class="mce-root">The preceding function receives the list of all genomes in the population and the NEAT configuration parameters. For each specific genome, it creates the phenotype ANN and uses it as a controller to run the cart-pole apparatus simulation, as defined in the following snippet from the preceding code:</p>
<pre>fitness = cart.eval_fitness(net)</pre>
<p class="mce-root">The returned fitness score is then compared with the fitness threshold value we defined in the configuration parameters. If it exceeds the threshold, we can assume that a successful controller was found. To further verify the validity of the found controller, it will be tested for additional simulation runs and a final fitness score will be calculated (as in the following snippet taken from the preceding code):</p>
<pre>success_runs = evaluate_best_net(net, config, additional_num_runs)<br/>fitness = 1.0 - (additional_num_runs - success_runs) / additional_num_runs</pre>
<p>The additional simulation steps will use different seeds for a random number generator to cover the majority of possible initial configurations of the cart-pole apparatus.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The experiment runner function</h1>
                </header>
            
            <article>
                
<p>The second function configures, executes, and outputs the results of the neuroevolution process. Here, we outline some critical places in the implementation of the experiment runner function:</p>
<ol>
<li>The function begins with the loading of the hyperparameters from the configuration file and spawns the initial population using the loaded configuration:</li>
</ol>
<pre style="padding-left: 60px">    # Load configuration.<br/>    config = neat.Config(neat.DefaultGenome, <br/>                         neat.DefaultReproduction,<br/>                         neat.DefaultSpeciesSet, <br/>                         neat.DefaultStagnation,<br/>                         config_file)<br/><br/>    # Create the population, which is the top-level object <br/>    # for a NEAT run.<br/>    p = neat.Population(config)</pre>
<ol start="2">
<li>After that, it configures statistics' reporters to collect the statistics regarding execution of the evolutionary process. The output reporters are added as well in order to output the execution results to the console <span>in real time</span>. The checkpoints collector is also configured to save intermediary stages of execution, which can be useful if you need to restore the training process later:</li>
</ol>
<pre style="padding-left: 60px">    # Add a stdout reporter to show progress in the terminal.<br/>    p.add_reporter(neat.StdOutReporter(True))<br/>    stats = neat.StatisticsReporter()<br/>    p.add_reporter(stats)<br/>    p.add_reporter(neat.Checkpointer(5, <br/>                 filename_prefix=‘out/spb-neat—checkpoint-'))</pre>
<ol start="3">
<li>Finally, the evolution process is executed over the specified number of generations, and the results are saved in the <kbd>output</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px">    # Run for up to N generations.<br/>    best_genome = p.run(eval_genomes, n=n_generations)<br/><br/>    # Display the best genome among generations.<br/>    print('\nBest genome:\n{!s}'.format(best_genome))<br/><br/>    # Check if the best genome is a winning Single-Pole <br/>    # balancing controller <br/>    net = neat.nn.FeedForwardNetwork.create(best_genome, config)<br/>    best_genome_fitness = cart.eval_fitness(net)<br/>    if best_genome_fitness &gt;= config.fitness_threshold:<br/>        print("\n\nSUCCESS: The Single-Pole balancing controller has been found!!!")<br/>    else:<br/>        print("\n\nFAILURE: Failed to find Single-Pole balancing controller!!!")</pre>
<div class="packt_infobox">Refer to the <kbd>run_experiment(config_file, n_generations=100)</kbd> function for full implementation details.</div>
<p class="mce-root">After the best genome has been found during the evolutionary process, it is verified whether it actually meets the fitness threshold criteria that we set in the configuration file. There may be no working solution found during the process, but nevertheless, the NEAT-Python library will return the best fit genome. That is why we need this additional check to ensure that the resulting best fit genome can actually solve the problem in practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the single-pole balancing experiment</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">You need to enter the directory containing the <kbd>single_pole_experiment.py</kbd> file and execute the following command:</span></p>
<pre><strong>$ python single_pole_experiment.py</strong></pre>
<div class="p1 packt_infobox"><span class="s1">Do not forget to activate the appropriate virtual environment with the following command:<br/>
<br/></span> <kbd><span class="s1">conda activate single_pole_neat</span></kbd></div>
<p class="p1"><span class="s1">During the execution of the Python script, the console will print the following output for each generation of the evolution:</span></p>
<pre><strong> ****** Running generation 13 ****** </strong><br/><br/><strong>Population's average fitness: 0.26673 stdev: 0.12027</strong><br/><strong>Best fitness: 0.70923 - size: (1, 2) - species 1 - id 2003</strong><br/><strong>Average adjusted fitness: 0.161</strong><br/><strong>Mean genetic distance 1.233, standard deviation 0.518</strong><br/><strong>Population of 150 members in 1 species:</strong><br/><strong>   ID age size fitness adj fit stag</strong><br/><strong>  ==== === ==== ======= ======= ====</strong><br/><strong>     1 13 150 0.7 0.161 7</strong><br/><strong>Total extinctions: 0</strong><br/><strong>Generation time: 4.635 sec (0.589 average)</strong></pre>
<p class="p1"><span class="s1">In the output, you can see that the average fitness of the population in generation <kbd>14</kbd> is low, but the fitness of the best performing organism</span> (<span class="s1"><kbd>0.70923</kbd></span>) <span class="s1">is already close to our completion threshold value (<kbd>fitness_threshold = 1.0</kbd>), which was set in the configuration file. The organism champion encodes the phenotype ANN that consists of one non-linear node (output) and only two connections (<kbd>size: (1, 2)</kbd>). Also, it is interesting to note that only one species exists in the population.</span></p>
<p class="p1"><span class="s1">After the winner is found, the console output has the following lines:</span></p>
<pre><strong> ****** Running generation 14 ****** </strong><br/><br/><strong>Population's average fitness: 0.26776 stdev: 0.13359</strong><br/><strong>Best fitness: 1.00000 - size: (1, 3) - species 1 - id 2110</strong><br/><br/><strong>Best individual in generation 14 meets fitness threshold - complexity: (1, 3)</strong><br/><br/><strong>Best genome:</strong><br/><strong>Key: 2110</strong><br/><strong>Fitness: 1.0</strong><br/><strong>Nodes:</strong><br/><strong>  0 DefaultNodeGene(key=0, bias=-3.328545880116371, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>Connections:</strong><br/><strong>  DefaultConnectionGene(key=(-4, 0), weight=2.7587300138861037, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-3, 0), weight=2.951449584136504, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-1, 0), weight=0.9448711043565166, enabled=True)</strong><br/><br/><br/><strong>Evaluating the best genome in random runs</strong><br/><strong>Runs successful/expected: 100/100</strong><br/><strong>SUCCESS: The stable Single-Pole balancing controller has been found!!!</strong></pre>
<p class="p1"><span class="s1">The best genome that is an evolution winner encodes a phenotype ANN that consists of only one non-linear node (output) and three connections from input nodes (<kbd>size: (1, 3)</kbd>). It is interesting to note that evolution was able to produce a solid control strategy that completely ignores the linear velocity of the cart and only uses the other three inputs: <kbd>x</kbd>,</span> <kbd>θ</kbd><span class="s1">, and</span> <kbd>θ</kbd><span class="s1">. This fact is another sign of the correctness of the evolutionary selection because we decided to ignore friction of the cart, which effectively excluded the linear velocity of the cart from the equations of motion.</span></p>
<p class="p1"><span class="s1">The graph with ANN of winning single-pole balancing controller is shown here:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-758 image-border" src="assets/94084e5e-4ec0-4bad-89ac-5f47182ac36e.png" style="width:15.42em;height:9.75em;"/></p>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1">The ANN of the single-pole balancing controller found by the NEAT algorithm</span></div>
<p class="p1"><span class="s1">The plot with the changes in fitness value over generations of evolution is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-759 image-border" src="assets/115564ed-987f-4fac-b451-982f0d357b05.png" style="width:28.92em;height:23.00em;"/></p>
<div class="p1 CDPAlignCenter CDPAlign packt_figref"><span class="s1">The population's average and best fitness in the single-pole experiment</span></div>
<p>The average fitness of the population in all generations was low, but from the very beginning, there was a beneficial mutation that spawned a particular lineage of organisms. From generation to generation, gifted individuals from that lineage were able not only to preserve their beneficial traits but also to improve them, which ultimately led to finding an evolution winner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<ol class="ol1">
<li class="li1"><span class="s2">Try to increase the value of the <kbd>node_add_prob</kbd> parameter and see what happens. Does the algorithm produce any number of hidden nodes, and if so, how many?</span></li>
<li class="li1"><span class="s2">Try to decrease/increase the <kbd>compatibility_threshold</kbd> value. What happens if you set it to <kbd>2.0</kbd> or <kbd>6.0</kbd>? Can the algorithm find the solution in each case?</span></li>
<li class="li1"><span class="s2">Try to set the <kbd>elitism</kbd> value to zero in the <kbd>DefaultReproduction</kbd> section. See what happens. How long did the evolutionary process take to find an acceptable solution in this case?</span></li>
<li class="li1"><span class="s2">Set the <kbd>survival_threshold</kbd> value to <kbd>0.5</kbd> in the <kbd>DefaultReproduction</kbd> section. See how this affects speciation during evolution. Why does it?</span></li>
<li class="li1"><span class="s2">Increase the <kbd>additional_num_runs</kbd> and <kbd>additional_steps</kbd> values in order of magnitude to examine further how well the found control strategy is generalized. Is the algorithm still able to find a winning solution?</span></li>
</ol>
<div class="packt_infobox">The last exercise will lead to an increase in the execution time of the algorithm.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The double-pole balancing problem</h1>
                </header>
            
            <article>
                
<p>The single-pole balancing problem is easy enough for the NEAT algorithm, which can quickly find the optimal control strategy to maintain a stable system state. To make the experiment more challenging, we present a more advanced version of the cart-pole balancing problem. In this version, the two poles are connected to the moving cart by a hinge.</p>
<p>A schema of the new cart-poles apparatus is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-760 image-border" src="assets/d8951ad6-2e47-4f3b-88d6-11033cf61335.png" style="width:41.67em;height:23.92em;"/></p>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1">The cart-poles apparatus with two poles</span></div>
<p class="p1"><span class="s1">Before we move to the implementation details of the experiment, we need to define the state variables and equations of motion for the simulation of the double-pole balancing system.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The system state and equations of motion</h1>
                </header>
            
            <article>
                
<p>The goal of the controller is to apply the force to the cart in order to keep two poles balanced for as long as possible. At the same time, the cart should stay within the defined boundaries. As with the single-pole balancing problem discussed previously, the control strategy can be defined as an avoidance control problem, which means that the controller must maintain a stable system state, avoiding the danger zones when the cart moves outside the track boundaries or either of the poles fall beyond the allowed vertical angle. There is no unique solution for this problem, but an appropriate control strategy can be found because the poles have different lengths and masses. Therefore, they respond differently to the control inputs.</p>
<p class="p1"><span class="s1">The current state of the double-pole balancing apparatus can be defined by the following variables:</span></p>
<ul class="ul1">
<li class="li1"><span class="s1">Cart position on the track (<img class="fm-editor-equation" src="assets/58c58c96-ed90-4af9-b600-cc33827280c3.png" style="width:0.75em;height:0.75em;"/>)</span></li>
<li class="li1"><span class="s1">Cart velocity (<img class="fm-editor-equation" src="assets/a8659522-7d44-462f-8108-c6a0764a4b01.png" style="width:0.83em;height:1.17em;"/>)</span></li>
<li class="li1"><span class="s1">First pole's angle from the vertical (<img class="fm-editor-equation" src="assets/87a960cd-9398-48da-b0d6-fdaa85a4d46c.png" style="width:1.00em;height:1.17em;"/>)</span></li>
<li class="li1"><span class="s1">First pole's angular velocity (<img class="fm-editor-equation" src="assets/7863f770-1d28-421f-bd4d-1d1924e2af43.png" style="width:1.08em;height:1.25em;"/>)</span></li>
<li class="li1"><span class="s1">Second pole's angle from the vertical (<img class="fm-editor-equation" src="assets/8511a332-e426-417d-8bdb-adce53560d5e.png" style="width:1.08em;height:1.25em;"/>)</span></li>
<li class="li1"><span class="s1">Second pole's angular velocity (<img class="fm-editor-equation" src="assets/c1f55beb-93ff-4611-8935-b99b3b4ea2e7.png" style="width:1.08em;height:1.33em;"/>)</span></li>
</ul>
<p>The equations of motion for two unjoined poles balanced on a single cart that ignores friction between cart wheels and the track are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/be73a75c-bd3d-4f0e-9094-c0a069e73e8e.png" style="width:9.58em;height:3.58em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8968071c-f398-4735-babc-3c6e082107aa.png" style="width:19.00em;height:3.00em;"/></p>
<p class="p1"><span class="s1">In this equation, <img class="fm-editor-equation" src="assets/ac7d62d9-cc3b-4797-ae79-24f1c86c0bb0.png" style="width:1.17em;height:1.25em;"/> is the reaction force from the <img class="fm-editor-equation" src="assets/2344d1ef-0f0b-41f4-8745-862dae768ce7.png" style="width:1.42em;height:1.33em;"/> pole on the cart:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/7c073c61-901d-41af-b765-3975d752f109.png" style="width:23.33em;height:2.92em;"/></p>
<p class="p1"><span class="s1">In this equation, <img class="fm-editor-equation" src="assets/51d64bef-2e18-48a3-b169-ca75ec0813ae.png" style="width:1.50em;height:1.08em;"/> is the effective mass of the <img class="fm-editor-equation" src="assets/c60f03fd-eeb7-4bc9-847b-d502b936cd82.png" style="width:1.33em;height:1.25em;"/> pole:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4e7d1be9-3acc-4be8-b82f-b46b9a20a454.png" style="width:11.33em;height:2.75em;"/></p>
<p>The following parameters are used for double-pole simulation:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p class="p1"><strong><span class="s1">Symbol</span></strong></p>
</td>
<td>
<p class="p1"><strong><span class="s1">Description</span></strong></p>
</td>
<td>
<p class="p1 CDPAlignLeft CDPAlign"><strong><span class="s1">Values</span></strong></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c2dae5b9-fe5b-49ad-b531-2c7f56e9e0ba.png" style="width:0.67em;height:0.67em;"/></p>
</td>
<td>
<p class="p1"><span class="s1">The position of the cart on a track</span></p>
</td>
<td>
<p class="p1 CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b6112da8-918a-43b3-9c96-208b8a5477b4.png" style="width:6.17em;height:1.17em;"/></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/57f65383-80b5-4e30-874e-d224020a9eac.png" style="width:0.50em;height:0.83em;"/></p>
</td>
<td>
<p class="p1">The angle of a pole from the vertical</p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cee7bb3d-eb7b-4dc2-8987-ec1894749e15.png" style="width:7.42em;height:1.08em;"/></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/714d496d-1542-4fee-b132-911103af8029.png" style="width:1.17em;height:1.00em;"/></p>
</td>
<td>
<p class="p1"><span class="s1">The control force applied to the cart</span></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1b8ee74e-42f7-4859-a8a2-c35fcab26cf1.png" style="width:2.58em;height:0.83em;"/></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1b4458eb-1b1c-45ec-9ecd-726631e96f33.png" style="width:1.25em;height:1.17em;"/></p>
</td>
<td>
<p class="p1"><span class="s1">The distance from the center of mass of the pole to the pivot</span></p>
</td>
<td>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/29a6b8ac-e763-46a5-9d6a-d2996df44b3d.png" style="width:4.42em;height:0.92em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/2ad149c7-6285-439b-8236-364142659995.png" style="width:4.83em;height:0.92em;"/></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c277bb60-e1e7-40e3-b926-50e557bf2b64.png" style="width:1.08em;height:0.83em;"/></p>
</td>
<td>
<p class="p1"><span class="s1">The mass of the cart</span></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/70043e09-5a9d-47ba-844c-b60957781183.png" style="width:2.17em;height:1.00em;"/></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4eefd5e6-7d13-486a-a5fe-cd5b61f4a5fe.png" style="width:1.67em;height:1.00em;"/></p>
</td>
<td>
<p class="p1"><span class="s1">The mass of the <img class="fm-editor-equation" src="assets/ec921e39-7533-4f39-aaf4-ec4e2f91e7c1.png" style="width:1.42em;height:1.33em;"/> pole</span></p>
</td>
<td>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c3f17eb0-7427-4086-b3e7-b4f233da118b.png" style="width:5.33em;height:1.17em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/dd8bd2ca-d758-409e-97c4-02564ce9f3b4.png" style="width:5.50em;height:1.08em;"/></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6134cc80-b12b-4af1-86cb-891ff6807ffd.png" style="width:1.17em;height:0.92em;"/></p>
</td>
<td>
<p class="p1"><span class="s1">The coefficient of friction of the <strong>pivot</strong> of the <img class="fm-editor-equation" src="assets/32e5ed21-4a64-4fe4-b40b-6b2fcea1c797.png" style="width:1.42em;height:1.33em;"/> pole</span></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/3629a999-06c3-4cd7-82d2-ff0e7ac38bab.png" style="width:3.25em;height:0.75em;"/></p>
</td>
</tr>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/00ccc395-dcb9-451f-90f0-84ac7191b5e6.png" style="width:0.58em;height:0.92em;"/></p>
</td>
<td>
<p class="p1"><span class="s1">Acceleration of free fall due to gravity</span></p>
</td>
<td>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9f831f81-d62e-491d-b3b7-15a1e5ba67e7.png" style="width:4.50em;height:1.33em;"/></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="p1"><span class="s1">The corresponding Python code defines these system parameters as constants:</span></p>
<pre>GRAVITY = -9.8 # m/s^2 - here negative as equations of motion for 2-pole system assume it to be negative<br/>MASS_CART = 1.0 # kg<br/>FORCE_MAG = 10.0 # N<br/># The first pole<br/>MASS_POLE_1 = 1.0 # kg<br/>LENGTH_1 = 0.5 # m - actually half the first pole's length<br/># The second pole<br/>MASS_POLE_2 = 0.1 # kg<br/>LENGTH_2 = 0.05 # m - actually half the second pole's length<br/># The coefficient of friction of pivot of the pole<br/>MUP = 0.000002</pre>
<p class="p1"><span class="s1">The implementation of the equations of motion in Python is as follows:</span></p>
<pre># Find the input force direction<br/>force = (action - 0.5) * FORCE_MAG * 2.0 # action has binary values<br/># Calculate projections of forces for the poles<br/>cos_theta_1 = math.cos(theta1)<br/>sin_theta_1 = math.sin(theta1)<br/>g_sin_theta_1 = GRAVITY * sin_theta_1<br/>cos_theta_2 = math.cos(theta2)<br/>sin_theta_2 = math.sin(theta2)<br/>g_sin_theta_2 = GRAVITY * sin_theta_2<br/># Calculate intermediate values<br/>ml_1 = LENGTH_1 * MASS_POLE_1<br/>ml_2 = LENGTH_2 * MASS_POLE_2<br/>temp_1 = MUP * theta1_dot / ml_1<br/>temp_2 = MUP * theta2_dot / ml_2<br/>fi_1 = (ml_1 * theta1_dot * theta1_dot * sin_theta_1) + \<br/>       (0.75 * MASS_POLE_1 * cos_theta_1 * (temp_1 + g_sin_theta_1))<br/>fi_2 = (ml_2 * theta2_dot * theta2_dot * sin_theta_2) + \<br/>       (0.75 * MASS_POLE_2 * cos_theta_2 * (temp_2 + g_sin_theta_2))<br/>mi_1 = MASS_POLE_1 * (1 - (0.75 * cos_theta_1 * cos_theta_1))<br/>mi_2 = MASS_POLE_2 * (1 - (0.75 * cos_theta_2 * cos_theta_2))<br/># Calculate the results: cart acceleration and poles angular accelerations<br/>x_ddot = (force + fi_1 + fi_2) / (mi_1 + mi_2 + MASS_CART)<br/>theta_1_ddot = -0.75 * (x_ddot * cos_theta_1 + \<br/>                        g_sin_theta_1 + temp_1) / LENGTH_1<br/>theta_2_ddot = -0.75 * (x_ddot * cos_theta_2 + \<br/>                        g_sin_theta_2 + temp_2) / LENGTH_2</pre>
<div class="p1 packt_infobox"><span class="s1">More implementation details are available in the <kbd>cart_two_pole.py</kbd> file in the repository associated with</span> <kbd>Chapter4</kbd> <span class="s1">source code files. Refer to the <kbd>calc_step(action, x, x_dot, theta1, theta1_dot, theta2, theta2_dot)</kbd> <span>function.</span></span></div>
<p class="mce-root">The preceding code receives the current system state (<kbd>x, x_dot, theta1, theta1_dot, theta2, theta2_dot</kbd>) along with the control action and calculates the derivatives (cart acceleration and angular acceleration of both poles).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reinforcement signal</h1>
                </header>
            
            <article>
                
<p>The simulation environment must provide minimal information about the system state after performing actions in the form of a reinforcement signal (<img class="fm-editor-equation" src="assets/fc22bec5-3708-414b-b602-27448d4ac84b.png" style="width:1.08em;height:1.08em;"/>). The reinforcement signal indicates whether a double-pole balancing system violates the bounding constraints after applying an action. It can be defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b788c1c5-bb85-4a4c-b1bb-b85d3861ebd7.png" style="width:37.58em;height:2.92em;"/></p>
<p> The implementation of the reinforcement signal generation in Python is as follows:</p>
<pre>res = x &lt; -2.4 or x &gt; 2.4 or \<br/>    theta1 &lt; -THIRTY_SIX_DEG_IN_RAD or theta1 &gt; THIRTY_SIX_DEG_IN_RAD or \<br/>    theta2 &lt; -THIRTY_SIX_DEG_IN_RAD or theta2 &gt; THIRTY_SIX_DEG_IN_RAD</pre>
<p><span>The condition checks that the angle of each pole is </span><img class="fm-editor-equation" src="assets/7ec89f5d-74cb-4799-97d2-9e4dc2192645.png" style="width:11.92em;height:1.25em;"/><span> from the vertical, and that the position of the cart is</span> <img class="fm-editor-equation" src="assets/7d5bde15-10d8-4bd6-9e68-1aa3252ba5e2.png" style="width:2.92em;height:0.83em;"/><span> from the center of the track.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initial conditions and state update</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In the single-pole balancing experiment, we used random initial state conditions, but with the two poles, the initial conditions are a bit more simplified. The system starts with all cart and pole velocities set to zero. The initial position of the long pole is one degree from the vertical, and the short pole is exactly upright.</span></p>
<p class="p1"><span class="s1">The initial conditions are as follows:</span></p>
<ul>
<li class="p1"><img class="fm-editor-equation" src="assets/8a69cfc8-74b9-4b45-af4f-8f911b37565f.png" style="width:2.58em;height:0.92em;"/></li>
<li class="p1"><img class="fm-editor-equation" src="assets/667f19c3-c24e-4a7d-89ce-22897e01410b.png" style="width:2.83em;height:1.00em;"/></li>
<li class="p1"><img class="fm-editor-equation" src="assets/d019620c-0c49-44c5-bb15-3aafe6dd430e.png" style="width:4.33em;height:2.08em;"/></li>
<li class="p1"><img class="fm-editor-equation" src="assets/3b91fda3-c5e7-44a9-9c00-9e8980bc6b68.png" style="width:3.08em;height:1.33em;"/></li>
<li class="p1"><img class="fm-editor-equation" src="assets/c8f77873-ac3d-4d28-b103-e8d686bdcd37.png" style="width:2.92em;height:1.08em;"/></li>
<li class="p1"><img class="fm-editor-equation" src="assets/da16b0a8-cb4e-4b6f-bbb0-542b9f53ef91.png" style="width:3.08em;height:1.33em;"/></li>
</ul>
<p><span>The state of the cart-pole system is updated at each simulation step by numerical approximation of the equations of motion using the Runge-Kutta fourth-order method with a time step size of <em>0.01</em></span><span> seconds.</span> <span>The Runge-Kutta fourth-order approximation method allows calculation of the system response given the state variables of the current time step. </span><span>The new control inputs are generated every </span><img class="fm-editor-equation" src="assets/08aa1b9b-c4ac-45e5-90af-ceb2e8acd574.png" style="width:3.83em;height:0.92em;"/><span> seconds. Thus, the control frequency is <strong>50 Hz</strong></span><span>, and the update frequency of the system state is <strong>100 Hz</strong></span><span>.</span></p>
<p class="p1"><span class="s1">The Runge-Kutta fourth-order method implementation in Python is as follows:</span></p>
<ol>
<li>Use the current cart-pole apparatus state variables to update the intermediate state for the next half-time step and do the first simulation step:</li>
</ol>
<pre style="padding-left: 60px">hh = tau / 2.0<br/>yt = [None] * 6<br/><br/># update intermediate state<br/>for i in range(6):<br/>    yt[i] = y[i] + hh * dydx[i]<br/><br/># do simulation step<br/>x_ddot, theta_1_ddot, theta_2_ddot = calc_step(action = f, yt[0], yt[1], yt[2], yt[3], yt[4], yt[5])<br/><br/># store derivatives<br/>dyt = [yt[1], x_ddot, yt[3], theta_1_ddot, yt[5], theta_2_ddot]</pre>
<ol start="2">
<li>Update the intermediate state using the derivatives obtained from the first simulation step and perform the second simulation step:</li>
</ol>
<pre style="padding-left: 60px"><span># update intermediate state </span><br/><span>for i in range(6):</span><br/><span>    yt[i] = y[i] + hh * dyt[i]</span><br/><br/><span># do one simulation step</span><br/><span>x_ddot, theta_1_ddot, theta_2_ddot = calc_step(action = f, </span><span>yt[0], yt[1], yt[2], yt[3], yt[4], yt[5])<br/></span><br/><span># store derivatives</span><br/><span>dym = [yt[1], x_ddot, yt[3], theta_1_ddot, yt[5], theta_2_ddot]</span></pre>
<ol start="3">
<li>Update the intermediate state using the derivatives from the first and second simulation steps and execute the third pole-balancing simulation step using the updated state:</li>
</ol>
<pre style="padding-left: 60px"># update intermediate state<br/>for i in range(6):<br/>    yt[i] = y[i] + tau * dym[i]<br/>    dym[i] += dyt[i]<br/><br/># do one simulation step<br/>x_ddot, theta_1_ddot, theta_2_ddot = calc_step(action = f, yt[0], yt[1], yt[2], yt[3], yt[4], yt[5])<br/><br/># store derivatives<br/>dyt = [yt[1], x_ddot, yt[3], theta_1_ddot, yt[5], theta_2_ddot]</pre>
<ol start="4">
<li>Finally, use the derivatives from the first three simulation steps to approximate the final state of the cart-pole apparatus that will be used in further simulation:</li>
</ol>
<pre style="padding-left: 60px"># find system state after approximation<br/>yout = [None] * 6 # the approximated system state<br/>h6 = tau / 6.0<br/>for i in range(6):<br/>    yout[i] = y[i] + h6 * (dydx[i] + dyt[i] + 2.0 * dym[i])</pre>
<p class="p1"><span class="s1">Let's examine the elements of the preceding equation:</span></p>
<ul class="ul1">
<li><kbd>f</kbd> is a control action to apply during simulation (<strong>0 </strong>or <strong>1</strong>).</li>
<li class="li2"><span class="s1"><kbd>y</kbd> is a list with the <span>current </span>values of the state variables (<img class="fm-editor-equation" src="assets/f79951a1-1e41-4e79-aa7f-c1d0026ec371.png" style="width:8.33em;height:1.42em;"/>).</span></li>
<li class="li2"><span class="s1"><kbd>dydx</kbd> is a list with the derivatives of the state variables (<img class="fm-editor-equation" src="assets/e2d8988c-2ae7-41e1-b34a-f6f52382d77b.png" style="width:9.17em;height:1.50em;"/>).</span></li>
<li class="li2"><span class="s1"><kbd>tau</kbd> is the size of the time step for approximation.</span></li>
</ul>
<div class="p1 packt_infobox"><span class="s1">For more implementation details, refer to the <kbd>rk4(f, y, dydx, tau)</kbd> function in the <kbd>cart_two_pole.py</kbd> <span>file.</span></span></div>
<p>This <span>implementation of the</span> Runge-Kutta fourth-order method receives the current system state (<kbd>x, x_dot, theta1, theta1_dot, theta2, theta2_dot</kbd><span>) along with derivatives and approximates the system state at the next time step.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Control actions</h1>
                </header>
            
            <article>
                
<p>As with the single-pole balancing experiment discussed earlier in this chapter, the control system for the double-pole balancing experiment generates only two control signals: push left and push right with a constant force. Thus, the control force at time <img class="fm-editor-equation" src="assets/bb496626-827c-48e5-a3b3-bc89636b64ba.png" style="width:0.42em;height:0.92em;"/> can be defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/592640c7-d64b-4179-ad0c-76402aedacca.png" style="width:13.83em;height:2.83em;"/></p>
<p class="p1"><span class="s1">In the preceding equation, <img class="fm-editor-equation" src="assets/829855d2-7f89-434d-9c3b-1db857635745.png" style="width:1.50em;height:1.25em;"/> is an action signal received from the controller <span>at time </span><img class="fm-editor-equation" src="assets/b234e4ad-b9f4-4830-b99e-4ed4dc1ca359.png" style="width:0.42em;height:0.92em;"/>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interactions between the solver and the simulator</h1>
                </header>
            
            <article>
                
<p>The state variables are scaled down to fit the <kbd>[0,1]</kbd><span> range </span>before they are applied as inputs to the controller ANN. Thus, the <span>equations for </span>preprocessing of the <span>state input </span>variables are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><br/>
<img class="fm-editor-equation" src="assets/36086576-53c2-4337-804e-6749919a2333.png" style="width:10.75em;height:2.42em;"/><br/>
<img class="fm-editor-equation" src="assets/ef65aaa9-36d9-442e-8d78-a723bbc49afe.png" style="width:9.92em;height:2.42em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/68e2406f-5a04-4df0-9d6f-248e1c857a87.png" style="width:12.83em;height:2.33em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/db6d27ef-0051-48a2-a214-2aa9794cca09.png" style="width:9.42em;height:2.33em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/38cb7007-53ae-47ca-8c80-b7a75f15ea9b.png" style="width:12.33em;height:2.25em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1eb1c5c3-59d6-426a-94aa-6b63fb6a6e05.png" style="width:10.83em;height:2.67em;"/></p>
<p class="p1"><span class="s1">In the preceding equations, <img class="fm-editor-equation" src="assets/c44ddf68-8ca2-4a1e-9875-78023cf88b28.png" style="width:4.33em;height:0.92em;"/><span> </span>correspond to the cart's horizontal position, its horizontal velocity, the first pole's angle from the vertical, its angular velocity, and the second pole's angle and angular velocity, respectively.</span></p>
<p>Taking into account the system constraints defined earlier (see<span> </span><img class="fm-editor-equation" src="assets/43575c2d-0f73-48c9-908b-c6c1728f46ce.png" style="width:1.00em;height:1.00em;"/>), the scaled values of<span> </span><img class="fm-editor-equation" src="assets/49856ea8-0837-4ea2-a4f6-bd79dd87bd32.png" style="width:1.25em;height:0.92em;"/>,<span> </span><img class="fm-editor-equation" src="assets/77bd9544-f690-443f-8c59-9c6bfce465b0.png" style="width:1.25em;height:0.92em;"/>, and <img class="fm-editor-equation" src="assets/776c7abd-c5ad-41cc-a2aa-4eb54b18b5c0.png" style="width:1.25em;height:0.92em;"/><span> </span>are guaranteed to be within the <kbd>[0,1]</kbd> range, while the scaled values of<span> </span><img class="fm-editor-equation" src="assets/47785056-fe6d-4c4c-a2ab-d741a1b5b1f9.png" style="width:1.25em;height:0.92em;"/>,<span> </span><img class="fm-editor-equation" src="assets/d739616c-3da4-484c-8310-fa542cbc0ebb.png" style="width:1.17em;height:0.83em;"/>, and <img class="fm-editor-equation" src="assets/cd31e739-15e7-4671-8e4e-505547b4f2ff.png" style="width:1.25em;height:0.92em;"/><span> </span>mostly fall within the <kbd>0...1</kbd><span> </span>range, but can fall outside these bounds eventually.</p>
<p>The corresponding source code for input scaling is as follows:</p>
<pre>input[0] = (state[0] + 2.4) / 4.8<br/>input[1] = (state[1] + 1.5) / 3.0<br/>input[2] = (state[2] + THIRTY_SIX_DEG_IN_RAD) / (THIRTY_SIX_DEG_IN_RAD * 2.0)<br/>input[3] = (state[3] + 2.0) / 4.0<br/>input[4] = (state[4] + THIRTY_SIX_DEG_IN_RAD) / (THIRTY_SIX_DEG_IN_RAD * 2.0)<br/>input[5] = (state[5] + 2.0) / 4.0</pre>
<p class="p1"><span class="s1">The state list holds the current state variables in the following order:<span> </span><img class="fm-editor-equation" src="assets/a74878d2-4ef8-40a6-be7e-d27af13dadd7.png" style="width:9.25em;height:1.25em;"/>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Objective function for a double-pole balancing experiment</h1>
                </header>
            
            <article>
                
<p>The objective function for this problem is similar to the objective function defined earlier for the single-pole balancing problem. It is given by the following equations:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/fd546863-081e-4289-b3f1-a1c5c99d7156.png" style="width:11.75em;height:2.83em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/64991d2c-7d00-4676-a9c8-cea273e14412.png" style="width:5.33em;height:0.92em;"/></p>
<p>In these equations, <img class="fm-editor-equation" src="assets/9bcb9c30-deec-483a-9f71-dca8ab267bd6.png" style="width:2.42em;height:1.17em;"/> is the expected number of time steps specified in the configuration of the experiment (100,000), and <img class="fm-editor-equation" src="assets/0d98561b-d894-41dd-bcc9-70cfb2b6eed0.png" style="width:2.17em;height:1.17em;"/> is the actual number of time steps during which the controller was able to maintain <span>a stable state of the pole balancer </span>within the specified limits.</p>
<p>We use logarithmic scales because most of the trials fail in the first several 100 steps, but we are testing against 100,000 steps. With a logarithmic scale, we have a better distribution of fitness scores, even compared with a small number of steps in failed trials.</p>
<p>The first of the preceding equations defines the loss, which is in the <kbd>[0,1]</kbd> range, and the second is a fitness score that is complementing the loss value. Thus, the fitness score values are in the <kbd>[0,1]</kbd> range, and the higher the value, the better the outcome.</p>
<p class="p1"><span class="s1">The Python source code is similar to the objective function definition in the single-pole balancing experiment, but it uses different simulator calls to get a number of balanced steps:<br/></span></p>
<pre><span># First we run simulation loop returning number of successful</span><br/><span># simulation steps</span><br/><span>steps = cart.run_markov_simulation(net, max_bal_steps)</span><br/><br/><span>if steps == max_bal_steps:</span><br/><span>    # the maximal fitness</span><br/><span>    return 1.0</span><br/><span>elif steps == 0: # needed to avoid math error when taking log(0)</span><br/><span>    # the minimal fitness</span><br/><span>    return 0.0</span><br/><span>else:</span><br/><span>    log_steps = math.log(steps)</span><br/><span>    log_max_steps = math.log(max_bal_steps)</span><br/><span>    # The loss value is in range [0, 1]</span><br/><span>    error = (log_max_steps - log_steps) / log_max_steps</span><br/><span>    # The fitness value is a complement of the loss value</span><br/><span>    return 1.0 - error</span></pre>
<p>We use the logarithmic scale here because most of the runs fail too early, within 100 steps or so, but we are testing against 100,000 steps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Double-pole balancing experiment</h1>
                </header>
            
            <article>
                
<p>This experiment uses a version of the double-pole balancing problem that assumes full knowledge of the current system state, including the angular velocities of the poles and the velocity of the cart. The criteria of success in this experiment are to keep both poles balanced for<span> 100,000 </span>steps, or approximately 33 minutes of simulated time. The pole is considered balanced when it stays within <img class="fm-editor-equation" src="assets/7e187b55-6614-4d0d-a5dd-2d7f77fb5e3a.png" style="width:2.58em;height:1.25em;"/><span> </span>degrees of vertical, while the cart remains within <img class="fm-editor-equation" src="assets/e10fcf6e-7929-49ab-8962-ee029537efe4.png" style="width:3.00em;height:1.25em;"/><span> </span>meters of the track's center.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hyperparameter selection</h1>
                </header>
            
            <article>
                
<p>Compared to the previous experiment described in this chapter, double-pole balancing is much harder to solve due to its complex motion dynamics. Thus, the search space for a successful control strategy is broader and requires a more diverse population. To increase the diversity of the population, we increase its size to become 10 times bigger than with a single-pole balancing experiment.</p>
<p>The fitness termination threshold remains the same as shown here:</p>
<pre>[NEAT]<br/>fitness_criterion = max<br/>fitness_threshold = 1.0<br/>pop_size = 1000<br/>reset_on_extinction = False</pre>
<p class="p1"><span class="s1">To </span><span>intensify evolutionary diversity further, we increase the probabilities of adding new nodes and connections, as well as changing the configuration scheme of initial connections. Also, the value of the</span> <kbd>initial_connection</kbd> <span>parameter contains the probability of connection creation, which introduces additional non-determinism into the process of the production of the connections graph:</span></p>
<pre># connection add/remove rates<br/>conn_add_prob = 0.5<br/>conn_delete_prob = 0.2<br/><br/>initial_connection = partial_direct 0.5<br/><br/># node add/remove rates<br/>node_add_prob = 0.2<br/>node_delete_prob = 0.2</pre>
<p>Finally, taking into account the size of a population and the possible size of a species, we reduced the fraction of individuals who are allowed to reproduce (<kbd>survival_threshold</kbd>). This tweak limits the search space of the solution by enabling only the fittest organisms to participate in the recombination process:</p>
<pre>[DefaultReproduction]<br/>elitism = 2<br/>survival_threshold = 0.1<br/>min_species_size = 2</pre>
<div class="packt_tip">The last tweak is controversial and can reduce the performance of the evolutionary process in general. But with large populations, it often works well by decreasing the number of possible recombinations. Thus, as a rule of thumb, large survival thresholds are used for small populations, and small values are used for large populations.</div>
<p class="p1"><span class="s1">Due to the increased complexity of this experiment, the additional hyperparameter type becomes extremely important for the final outcome. The neuroevolution process is built around the likelihood of mutations occurring, and the probability of mutation is tested against the values produced by a random number generator.</span></p>
<p class="p1"><span class="s1">As you know, in conventional computers, there is no true source of randomness. Instead, the randomness is generated by a pseudo-random algorithm that heavily depends on the random seed to start the generation of a random number sequence. Actually, the random seed value exactly defines a sequence of all pseudo-random numbers that will be produced by a given generator.</span></p>
<p class="p1"><span class="s1">Thus, we can consider the random seed number as an essential parameter defining the initial conditions. This parameter sets the properties of the random attractor, which will amplify the tiny changes in the <span>numerical search space of the </span>algorithm. The effect of amplification ultimately determines whether the algorithm will be able to find the winner and how long it will take.</span></p>
<p class="p1"><span class="s1">The random seed value is defined in the <kbd>two_pole_markov_experiment.py</kbd> file around line 100:</span></p>
<pre># set random seed<br/>seed = 1559231616<br/>random.seed(seed)</pre>
<div class="packt_infobox">For the complete list of hyperparameters used in the double-pole balancing experiment, please refer to the <kbd>two_pole_markov_config.ini</kbd> file in the source code repository associated with this chapter.</div>
<p class="mce-root">The preceding code sets the seed value of the standard random number generator supplied with the Python environment. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working environment setup</h1>
                </header>
            
            <article>
                
<p>The working environment for the double-pole balancing experiment can be set up with the following commands entered into your Terminal application of choice:</p>
<pre><strong>$ conda create --name double_pole_neat python=3.5</strong><br/><strong>$ conda activate double_pole_neat</strong><br/><strong>$ pip install neat-python==0.92 </strong><br/><strong>$ conda install matplotlib</strong><br/><strong>$ conda install graphviz</strong><br/><strong>$ conda install python-graphviz</strong></pre>
<p class="p1"><span class="s1">These commands create and activate a <kbd>double_pole_neat</kbd></span> virtual environment with Python 3.5. After that, the NEAT-Python library with version 0.92 is installed, along with the other dependencies used by our visualization utilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The experiment runner implementation</h1>
                </header>
            
            <article>
                
<p>The source code implementing the evaluation of the genome fitness is similar to the one used for a single-pole balancing experiment. The main difference is that it will refer to another simulation environment to get the number of balanced steps. Thus, you can refer to the source code of the <kbd>eval_fitness(net, max_bal_steps=100000)</kbd> and <kbd>eval_genomes(genomes, config)</kbd> <span>functions </span>in the <kbd>two_pole_markov_experiment.py</kbd> <span>file </span><span>for implementation details</span><span>.</span></p>
<p>In this experiment, we introduced adaptive learning, which will try to find the correct short pole length during the evolution process. The length of the short pole changes the motion dynamics of the system. Not all combinations of hyperparameters combined with a particular <span>length</span><span> of the short pole</span> can produce a successful control strategy. Thus, we implement a sequential <span>increase of the short pole </span>length until the solution is found:</p>
<pre># Run the experiment<br/>pole_length = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]<br/>num_runs = len(pole_length)<br/>for i in range(num_runs):<br/>    cart.LENGTH_2 = pole_length[i] / 2.0<br/>    solved = run_experiment(config_path, n_generations=100, silent=False)<br/>    print("run: %d, solved: %s, length: %f" % <br/>                                         (i + 1, solved, cart.LENGTH_2))<br/>    if solved:<br/>        print("Solution found in: %d run, short pole length: %f" % <br/>                                                 (i + 1, cart.LENGTH_2))<br/>    break</pre>
<div class="packt_infobox">Refer to the <kbd>two_pole_markov_experiment.py</kbd> file for more implementation details.</div>
<p>The preceding code runs the simulation using different short pole length values until the solution is found.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the double-pole balancing experiment</h1>
                </header>
            
            <article>
                
<p>Having implemented the two-pole balancing simulator, genome fitness function evaluator, and experiment runner code, we are ready to start experimenting. Enter the directory containing the <kbd>two_pole_markov_experiment.py</kbd> file and execute the following command:</p>
<pre><strong>$ python two_pole_markov_experiment.py</strong></pre>
<div class="p1 packt_infobox"><span class="s1">Do not forget to activate the appropriate virtual environment with the following command: <br/></span><strong><kbd><span class="s1">conda</span> <span class="s1">ac</span><span class="s1">tivate</span> <span class="s1">do</span><span class="s1">uble_pole_neat</span></kbd></strong></div>
<p>The preceding command will launch the evolutionary process under the control of the NEAT algorithm, using the hyperparameters specified in the <kbd>two_pole_markov_config.ini</kbd> file, as well as the simulator of the cart-two-pole apparatus that we already implemented.</p>
<p>After <kbd>96</kbd> generations, the winning solution can be found in generation <kbd>97</kbd>. The console output for the last generation looks similar to the following:</p>
<pre><strong> ****** Running generation 97 ****** </strong><br/><br/><strong>Population's average fitness: 0.27393 stdev: 0.10514</strong><br/><strong>Best fitness: 1.00000 - size: (1, 6) - species 26 - id 95605</strong><br/><br/><strong>Best individual in generation 97 meets fitness threshold - complexity: (1, 6)</strong><br/><br/><strong>Best genome:</strong><br/><strong>Key: 95605</strong><br/><strong>Fitness: 1.0</strong><br/><strong>Nodes:</strong><br/><strong>  0 DefaultNodeGene(key=0, bias=7.879760594997953, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>Connections:</strong><br/><strong>  DefaultConnectionGene(key=(-6, 0), weight=1.9934757746640883, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-5, 0), weight=3.703109977745863, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-4, 0), weight=-11.923951805881497, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-3, 0), weight=-4.152166115226511, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-2, 0), weight=-3.101569479910728, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-1, 0), weight=-1.379602358542496, enabled=True)</strong><br/><br/><br/><strong>Evaluating the best genome in random runs</strong><br/><strong>Runs successful/expected: 1/1</strong><br/><strong>SUCCESS: The stable Double-Pole-Markov balancing controller found!!!</strong><br/><strong>Random seed: 1559231616</strong><br/><strong>run: 1, solved: True, half-length: 0.050000</strong><br/><strong>Solution found in: 1 run, short pole length: 0.100000</strong></pre>
<p>In the console output, we can see that the winning genome has a size <kbd>(1, 6)</kbd>, which means that it has only one non-linear node—the output—and a full set of connections from six inputs to the output nodes. Thus, we can assume that the minimal possible configuration of the controller ANN was found because it does not include any hidden nodes, but instead encodes control behavior with specifically explored connection weights. Also, it is interesting to note that the solution <span>for the smallest length value among the list of all possible short pole length values </span>was found.</p>
<p>The configuration of the controller's ANN that's capable of executing a reliable control strategy is shown in the following graph:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-761 image-border" src="assets/56f7e312-d4bf-44a8-a2d9-80c6c37e2049.png" style="width:39.33em;height:14.58em;"/></p>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1">The ANN of the double-pole balancing controller</span></div>
<p>The fitness scores vary over generations, as shown in the following graph:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-762 image-border" src="assets/c2dd4e25-d092-4764-976a-93ddc822f705.png" style="width:35.33em;height:28.17em;"/></p>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1">The fitness scores through generations for a double-pole balancing experiment</span></div>
<p>The preceding graph is interesting if we want to know how the evolution works. You can see that before finding a winner, the fitness score drops sharply. This is due to the extinction of stagnated species that have reached a plateau with medium-high fitness scores that showed no improvement over the past 15 generations. After that, the vacant place is occupied by fresh species endowed with the genetic knowledge accumulated by extinct species. This newborn species also introduces a beneficial mutation that combines its hereditary knowledge with new tricks and, ultimately, produces a winner.</p>
<p class="p1"><span class="s1">In this experiment, we decided to intensify the species' diversity by significantly increasing the population size and making other tweaks to the hyperparameters. In the following graph, you can see that we have reached our goal, and that the neuroevolution process goes through a wide variety of species until a solution is found:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-763 image-border" src="assets/5e427f23-b42c-4b61-bfd0-06e9342b2095.png" style="width:29.33em;height:22.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The speciation by generations for a double-pole balancing experiment</div>
<p>Next, we would like to learn how a change in the value of the random seed number impacts the NEAT algorithm. To begin with, we increased the value of the random seed number only by one (everything else has not changed). With this new condition, the NEAT algorithm could still find a stable control strategy but created a different, bizarre configuration of the controller's ANN instead of the optimal configuration shown earlier:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-764 image-border" src="assets/e0231b73-c676-4c23-ae6e-f9775c7deb11.png" style="width:28.83em;height:17.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The ANN of a double-pole balancing controller with a random seed number increased by one (everything else is unchanged)</div>
<p>When the value of the random seed number increased, for example, by 10, the neuroevolution process could not find any solid control strategy at all.</p>
<div class="packt_infobox">This experiment revealed another vital aspect of methods based on neuroevolution—the impact of the initial conditions determined by the value of the random seed number. The random seed defines the properties of a random attractor, which amplifies the effects of the evolution process, both good or bad. So, with this experiment, it is crucial to find a suitable value of the random seed number to bootstrap the process of neuroevolution. We will discuss methods for finding appropriate values of the random seed numbers at the end of this book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<ol class="ol1">
<li class="li1"><span class="s2">Try setting the <kbd>node_add</kbd> parameter value to <kbd>0.02</kbd> in the configuration file and see what happens.</span></li>
<li class="li1"><span class="s2">Change the seed value of the random number generator and see what happens. Was a solution found with a new value? How is it different from what we have presented in this chapter?</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In this chapter, we learned how to implement control strategies for controllers that can maintain a stable state of a cart-pole apparatus with one or two poles mounted on top. We improved our Python skills and expanded our knowledge of the NEAT-Python library by implementing accurate simulations of physical apparatuses, which was used to define the objective functions for the experiments. Besides this, we learned about two methods for numerical approximations of differential equations, Euler's and Runge-Kutta, and implemented them in Python.</span></p>
<p class="p1"><span class="s1">We found that the initial conditions that determine the neuroevolutionary process, such as a random seed number, have a significant impact on the performance of the algorithm. These values determine the entire sequence of numbers that will be generated by a random number generator. They serve as a random attractor that can amplify or dampen the effects of evolution.</span></p>
<p class="p1"><span class="s1">In the next chapter, we will discuss how to use neuroevolution to create navigator agents that can find their way through a maze. You will learn how to define a goal-oriented objective function to solve the maze problem and how to write an accurate simulation of a robotic agent that can navigate through the maze. We will take a look at two types of maze environments and examine how the goal-oriented fitness function can get stuck trying to find a solution in the deceptive environment of a hard maze configuration.</span></p>


            </article>

            
        </section>
    </body></html>