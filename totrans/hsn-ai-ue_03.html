<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Behavior Trees and Blackboards</h1>
                </header>
            
            <article>
                
<p><em>A tree to decide how we should behave, a blackboard to remember it!</em></p>
<p>Welcome to <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a>, <em>Behavior Trees and Blackboards</em>. This is where things start to get a bit more interesting because we will learn how to use the two main Unreal AI Framework structures. First, we will look at <strong><em>Behavior Tree</em><em>s</em></strong> and learn all about their principal components, such as tasks, decorators, and services. Next, we will learn about <strong><em>Blackboards</em></strong> and how to integrate them with <strong><em>Behavior Trees</em></strong>. After we have covered this, will be able to set up AI controllers that use <strong><em>Behavior Trees</em></strong>, which is key in implementing the rest of the techniques in this book.</p>
<p>As you may notice, there is a pattern in which we first learn a little bit about the theory, and then we jump straight into practice to understand how it all works. This is a pattern that we will follow in each chapter. So, let's get going.</p>
<p>In the field of <em>Decision-Making</em>, there are many mathematical structures that can be used. <strong>Finite State Machines</strong> (<strong>FSM</strong>s) are an easy, yet powerful example of systems that are able to make complex decisions. However, in the world of Artificial Intelligence for games, there is another structure that can also be used by non-AI experts: <strong><em>Behavior Trees</em></strong>.</p>
<p>As a result, one of the design choices of Unreal Engine is that it has built-in support for Behavior Trees, and is actually part of the main core of the AI Framework. This does not imply that you cannot implement other decision-making processes or structures, but using the built-in support for Behavior Trees will greatly benefit your team's budget (in terms of time). So, before you implement a different Decision-Making structure in Unreal, think twice about whether that is a good decision (of course, a Behavior Tree might not be optimal for your game, but keep in mind that they have built-in support and might be a great time-saver). Nonetheless, you can still implement sub-structures within the <strong><em>Behavior Tree</em></strong> to extend its functionality, but do not rush too much; first, let's learn about the basics of <strong><em>Behav</em></strong><strong><em>ior Trees</em></strong>.</p>
<p class="mceNonEditable"/>
<p>In particular, in this chapter, we will learn about the following topics:</p>
<ul>
<li>What a <strong><em>Behavior Tree</em></strong> is, both in broader terms and within the Unreal Context.</li>
<li>How a <strong><em>Behavior Tree works</em></strong> within Unreal, including its different components and how they interact with the tree</li>
<li>What a <strong><em>Blackboard</em></strong> is and how it can be used to store data for the Behavior Tree</li>
<li>How to <strong><em>start running a Behavior Tree</em></strong> by using the AI Controller, both in Blueprint and C++</li>
</ul>
<p>So, let's dive in!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Behavior Trees work</h1>
                </header>
            
            <article>
                
<p>The easiest way to think about the role that a Behavior Tree assumes within our AI Agent is to imagine it as a brain. It makes decisions and, as a consequence, acts on them. It is the processor for the artificial intelligence within our agent. Before we get started, if you have any experience with Behavior Trees in other contexts, it is important to understand that they differ in the context of Unreal.</p>
<div class="packt_infobox">If you want to learn more about how they are different, you can do so by visiting the following link: <a href="https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer">https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer</a>.</div>
<p class="mce-root">It is, however, important to highlight one key difference here: <strong><em>Unreal Behavior Trees</em></strong> are read from the top to the bottom, and nodes will be executed from left to right. In other contexts, you might have found this to the other way around, in which the tree is read from left to right, and the nodes are executed from top to bottom.</p>
<p>If this is the first time you have encountered a Behavior Tree, then this will make sense when you read the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The structure of a Mathematical Tree</h1>
                </header>
            
            <article>
                
<p>Alright, it's time to understand how a <strong><em>Behavior Tree</em></strong> works. First of all, as the name suggests, it is a tree, mathematical speaking.</p>
<div class="packt_infobox">If you are interested to learn more about trees in graph theory, you can consult the following Wikipedia page: <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">https://en.wikipedia.org/wiki/Tree_(graph_theory)</a>. Alternatively, if you want to get even more technical, you can consult the following page: <a href="http://mathworld.wolfram.com/Tree.html">http://mathworld.wolfram.com/Tree.html</a>. However, the definitions that are found at both the links are pretty mathematical, and you don't need them to understand Behavior Trees. </div>
<p><span>It is important to specify that a (mathematical) tree expresses relationships between nodes. In this sense, the same relationship that describes a family (e.g. parent, child, sibling) has been adopted in technical terms. To simplify the understanding of a tree, you can imagine your </span>genealogical<span> tree: each node is a person, and the branches (that connect people) are the relationships between the various people. However, the structure is still slightly different.</span></p>
<p>So, what is a tree? It is a graph that describes relationships between different nodes.</p>
<p>In particular, there is a "<strong><em>Root</em></strong>" node, which is <em>the only node without a parent</em>. From there, <em>every node can have one or more children</em>, <em>but only one parent</em>. The end nodes, which are the ones that do not have any child, are called <strong><em>leaves</em></strong>. Here is a simple diagram to help you understand the basic structure of a <em>Mathematical Tree</em> in general:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d49467c4-7e43-45bd-bebc-0a0ccd1d2733.png" style="width:24.33em;height:18.58em;"/></p>
<p>It might sound complicated, but it really isn't. Things will start getting interesting as we move on and talk about BehaviorTrees.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Behavior Tree components</h1>
                </header>
            
            <article>
                
<p>If you go through the official documentation, you will find that there are five types of nodes (<strong><em>Task</em></strong>, <strong><em>Decorator</em></strong>, <strong><em>Service</em></strong>, <strong><em>Composite</em></strong>, and <strong><em>Root</em></strong>) available to use, depending on the type of behavior that you're trying to create (and subsequently, how the AI should act in the world). However, I'd like to reformulate this to you in order to make it easier to understand and hopefully more practical.</p>
<p>Besides the <strong><em>Root</em></strong> node, the only kind of nodes (that are not leaves) are the <strong><em>Composites</em></strong> nodes. Leaves are called <strong><em>Tasks</em></strong>. <strong><em>Decorators</em></strong> and <strong><em>Services</em></strong> are <em>add-ons</em> for either a <em>Composite</em> node or a <em>Task</em> leaf. Although Unreal lets you leave a <em>Composite</em> node as a leaf, you shouldn't, because it means that you can remove that node and the Behavior Tree will still work in the same way. Here is an example of a tree showing all the different types of node (actually, we will build this <em>Behavior Tree</em> later in this book):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c71a9cbe-925e-4e5f-8e48-548b7d9efc47.png"/></p>
<p>When a tree is executing, you need to start following from the root node and go down the tree, reading the nodes from left to right. You traverse all the different branches (<em><strong>Composite</strong></em> nodes) in a specific way (we are going to see this in a little while), until we reach a leaf, which is a <strong><em>Task</em></strong>. In this case, the AI performs that <strong><em>Task</em></strong>. It is important to note that a <strong><em>Task</em></strong> can fail, for instance, if the AI is unable to complete it. The fact that a <em>Task</em> can fail will be useful for understanding how Composite nodes work. After all, a decision-making process is just choosing which task to perform to achieve a goal in a better way (e.g. killing the player). Thus, based on which task failed to execute (or, as we will see, a Decorator can make a task or a whole branch fail), the Composite nodes will determine the next tasks in the tree.</p>
<p>In addition, when you create your <strong><em>Behavior Tree</em></strong>, each node can be selected, and some settings to adjust the behavior of the node/leaf can be found in the <em>Detail Panel</em>. Moreover, since the order is important, the nodes in the Behavior Tree have numbers (in the top-right corner) to help you understand the ordering of the node (although it is always from top to bottom, left to right). The following screenshot shows where you can find these numbers:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/bb35abb8-d2b7-441b-93c1-1370be2b29d6.png" style="width:19.17em;height:19.83em;"/></p>
<div class="packt_infobox">A value of "<em>-1</em>" means that the node will never be executed in any order, and the color around the node will be a bit darker. This might be due to the fact that the node is not connected in some way to the root, and so it is isolated:<br/>
<img src="assets/f6e82db7-47f6-4d5b-86d8-9ad6695ec0ec.png" style="width:9.92em;height:6.25em;"/></div>
<p>Let's look at these components in detail and pay particular attention to <strong><em>Composite</em></strong> nodes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Root</h1>
                </header>
            
            <article>
                
<p>There isn't much to say about the <strong><em>ROOT</em></strong> node. The tree needs to begin somewhere, so the Root node is just where the tree starts its execution. Here is what it looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bca76338-5fba-4d62-b753-d1d82d74f05b.png" style="width:6.00em;height:4.33em;"/></div>
<p>Please note that the <strong><em>Root</em></strong> node can have only one child, and this must be a <strong><em>Composite</em></strong> node. You cannot attach any <em>Decorator</em> or <em>Service</em> to the <strong><em>Root</em></strong>. If you select the <strong><em>Root</em></strong> node, it doesn't have any property, but you will be able to assign a <strong><em>Blackboard</em></strong> (which we will cover later in this chapter), as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ee43b04f-4fae-4aca-b9be-5a6f1dc9d828.png" style="width:37.00em;height:13.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tasks</h1>
                </header>
            
            <article>
                
<p>When we think of a tree, we often picture a large trunk with branches, and on those branches are leaves. In the context of UE4, those “<em>leaves</em>” are what we call “<strong><em>Tasks</em></strong>”. These are nodes that perform various actions, such as moving an AI, and can have <em>Decorator</em> or <em>Service</em> nodes attached to them. However, they do not have an output, which means that they do not play a role in the decision-making process itself, which is left entirely to Composite nodes. Instead, they define what an AI should do if that task needs to be executed.</p>
<p>Please note that <strong><em>Tasks</em></strong> can be as complex as you like. They can be as simple as waiting an amount of time, to being as complex as solving a puzzle while shooting at the player. Huge tasks are hard to debug and maintain, while small tasks can make the <em><strong>Behavior Tree</strong></em> easily overcrowded and huge. As a good AI Designer, you should try to find a balance between the size of the task and write them in such a way that they can be reused in different parts of the tree (or even in other trees).</p>
<p>A <em>Task</em> can either <strong><em>Fail</em></strong> (report <strong><em>Failure</em></strong>) or <strong><em>Succeed</em></strong> (report <strong><em>Success</em></strong>), and it will not stop its execution until one of these two results is reported. <em>Composite</em> nodes are responsible for taking care of this result and deciding on what to do next. Thus, a Task might need several frames to executed, but it will end only when it reports either <em>Failure</em> or <em>Success</em>. Keep this in mind when you move on to<em> </em><a href="e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml">Chapter 6</a>, <em>Extending Behavior Trees</em>, where you will create your own Tasks.</p>
<p><em>Tasks</em> can have parameters (which you will be able to set in the <em>Details Panel</em> once a <em>Task</em> has been selected), and usually, they are either hard-coded values or <em>Blackboard Key references</em> (more on <em>Blackboards</em> later in this chapter).</p>
<p>Within the Behavior Tree editor, a Task appears as a purple box. In the following screenshot, you can see some examples of Tasks and how they look within the Editor:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ab90dd1b-0e74-41cc-8102-551541615f3c.png" style="width:19.08em;height:16.33em;"/></div>
<p>Unreal comes with some built-in Tasks that are ready to be used. They are general and cover the basic cases that you will probably need. Obviously, they cannot be specific to your game, so you will need to create your own <em>Tasks</em> (we will look at this in <a href="e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml">Chapter 6</a>, <em>Extending Behavior Trees</em>).</p>
<p>Here is the list of the built-in tasks in Unreal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8a1a9e32-3274-4e95-bac9-8d737562fe47.png" style="width:16.00em;height:27.17em;"/></p>
<ul>
<li><em><strong>Finish with Result</strong></em>: Forces the Task to return a <em>Finish Result</em> (either <em>Fail</em> or <em>Succeed</em>) for this task immediately.</li>
<li><strong><em>Make Noise</em></strong>: Produces a noise stimulus, which is used by the <em>Perception System</em> (this will be explored in <a href="94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml">Chapter 5</a>, <em>Agent Awareness</em>).</li>
<li><strong><em>Move Directly Toward</em></strong>: Like the following node, but it disregards the <em>Navigation System</em>.</li>
<li><strong><em>Move To</em></strong>: Moves the Pawn (by using the <em>Navigation System</em>, which we will explore in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>) to a location that's specified from the <em>Blackboard</em> (we will explore <em>Blackboards</em> later in this chapter).</li>
<li><strong><em>Play Animation</em></strong>: A<span>s the name suggests, this node plays an animation. However, exceptions aside (and this is the reason why this node exists), it is good practice to separate animation logic and behavior logic. Therefore, try not to use this node, and instead improve your Animation Blueprint.</span></li>
<li><strong><em>Play Sound</em></strong>: As the name suggests, this node plays a sound.</li>
<li><strong><em>Push Pawn Action</em></strong>: Performs a <em>Pawn Action</em> (unfortunately, we will not cover them in this book).</li>
<li><strong><em>Rotate to face BBEntry</em></strong>: Rotates the AI pawn to face a specific key that's been memorized inside the Blackboard (we will look at what <em>Blackboards</em> are later in this chapter).</li>
<li><strong><em>Run Behavior</em></strong>: Runs another <em>Behavior Tree</em> as a whole sub-tree. As a result, it is possible to nest <em>Behavior Trees</em> to create and compose very complex behaviors.</li>
<li><strong><em>Run Behavior Dynamic</em></strong>: Like the previous node, but it is possible to change which (<em>sub-</em>)<em>Behavior Tree</em> to execute at runtime.</li>
<li><strong><em>Run EQSQuery</em></strong>: Performs an <em>EQS Query</em> (we will see what they are in <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a><em>, Environment Querying System</em>) and stores the result within the <em>Blackboard</em>.</li>
<li><strong><em>Set Tag Cooldown</em></strong>: Sets the timer (by using a tag) for a specific <em>Cooldown</em> node (which is a decorator that we will look at later in this chapter).</li>
<li><strong><em>Wait</em></strong>: Stops the behavior for a specific amount of time. Arandom deviation can be specified to make the amount of time to wait different each time.</li>
<li><strong><em>Wait Blackboard Time</em></strong>: Like the previous node, but the amount of time is retrieved from the <em>Blackboard</em> (more on <em>Blackboards</em> later in this chapter).</li>
</ul>
<p>Now that we have looked at how a <em>Task</em> node works, let's explore <em>Composite</em> nodes, which make decisions based up whether a <em>Task</em> returns Failure or Success.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite</h1>
                </header>
            
            <article>
                
<p>Composite nodes are at the core of the decision-making capabilities of <strong><em>Behavior Trees</em></strong> in Unreal, and understanding how they work is key.</p>
<p>There are three kinds of Composite nodes: <em>Selector</em>, <em>Sequence</em>, and <em>Simple Parallel</em>. The last one has been added recently, and you will find that by using a combination of <em>Selectors</em> and <em>Sequences</em>, you will be able to cover most of your cases. Here is how they work:</p>
<p><strong>Selector</strong>: This kind of node will try to find one of its children to execute, which means it tries to find either a branch (so another <em>Composite</em> node attached as a child) or a <em>Task</em> (another child, but it is a leaf) to execute. So, the <strong><em>Selector</em></strong> starts from the left-most child node and tries to execute it. If it fails (either the <em>Task</em> failed to be executed, or the whole branch failed), then it tries the second left-most, and so on. If one of the children returns <em>Success</em>, which means that either the Task has been completed or a whole branch has been completed, then the <strong><em>Selector</em></strong> reports <em>Success</em> to its parent, and stop executing other children. On the other hand, if all the children of the <strong><em>Selector</em></strong> report a <em>fail</em>, then the <strong><em>Selector</em></strong> reports a <em>fail</em> to its parent as well. In the following screenshot, you can see what the <strong><em>Selector</em></strong> node looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/390d6972-3055-4ef2-ad83-02242c41cf80.png" style="width:9.67em;height:6.42em;"/></div>
<p><strong>Sequence</strong>: This kind of node works a bit like the opposite of the <em>Selector</em>. To report a success to its parent, all of the Sequence's children must report a success. This means that the Sequence will start executing the left-most child node. If it is a success, it carries on with the second left-most, and so on if it is successful as well. If all the children until the right-most are a success, then the <strong><em>Sequence</em></strong> reports a <em>Success</em> to its parent. Otherwise, if just one the children fail, then the <strong><em>Sequence</em></strong> will stop executing its children, and report a <em>fail</em> to the parent. In the following screenshot, you can see what the <strong><em>Sequence</em></strong> node looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bf17f5fe-6ef0-45b4-94a0-b7c783960ef2.png" style="width:9.67em;height:6.08em;"/></div>
<p><strong>Simple Parallel</strong>: This is a particular kind of <em>Composite</em> node, which is used in specific cases. In fact, it can only have two children. The left-most child must be a <em>Task</em>, whereas the right-most child can be either a <em>Task</em> or a <em>Composite</em> (thus giving birth to a sub-tree). The <strong><em>Simple Parallel</em></strong> starts to execute both its children in parallel, although the left-most is considered the main one. If the main one fails, it reports a fail, but if the main one succeeds, then it reports a success. Based on its settings, the Simple Parallel, once it has finished executing the main task, can either wait until the end of execution of the sub-tree or directly report success or fail the main one to its parent and stop executing the sub-tree. In the following screenshot, you can see what the <strong><em>Simple Parallel</em></strong> node looks like. Please note that it is possible to drag only two children, in which the left-most must be a <em>Task</em> (the purple block is the draggable area):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/34d7e425-1a2a-49e6-8848-0076f66a06b3.png" style="width:17.83em;height:8.50em;"/></div>
<p>In this way, <em>Composite</em> nodes can "<em>decide</em>" which tasks to execute, based on what their children report (fail or success), and the <em>Composite</em> node reports back (either fail or success) to their parent. Even if the only-child of the root (which is a <em>Composite</em> node) reports back a success to the <strong><em>Root</em></strong>, then the tree has been executed with success. A good <strong><em>Behavior Tree</em></strong> design should always allow for success.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorators</h1>
                </header>
            
            <article>
                
<p><strong><em>Decorator</em></strong> nodes (also known as conditionals) are attached to either a <em>Composite</em> or <em>Task</em> node. <strong><em>Decorator</em></strong> nodes make decisions on whether a branch in the <em>Behavior Tree</em>, or even a single node, can be executed. In their essence, they are a condition; they check whether something should be occurring. In other words, a <strong><em>Decorator</em></strong> can check whether it is worthwhile continuing on that branch and can report a preventive F<em>ailure</em> if, based on a condition, we know for sure that the <em>Task</em> (or the sub-tree) will fail. This will avoid the Decorator trying to perform a <em>Task</em> (or sub-tree) that is impossible (for any reason: lack of information, the goal is no longer relevant, etc...).</p>
<p>In general, Decorator nodes can assume the role of a <strong><em>Gate</em></strong> between the parent and the rest of the sub-tree. Thus, Decorators have the power to loop the sub-tree until a certain condition is met, or to not make execute within that sub-tree until a specific timer has expired, or even change the return result of the <em>Sub-Tree</em>.</p>
<p>For a (simple) example, imagine that there is a sub-tree dedicated to killing the player (it will make decisions so that the Agent will try and kill the player). Checking if the player is in range (and not from the other side of the map), or even if the player is still alive, might give us a preventive fail without us even having to execute that sub-tree. Consequently, the tree can continue with other events or parts of the tree, for example, in another sub-tree, which will be responsible for the wander behavior.</p>
<p><em>Decorators</em><span> can have parameters (which you will be able to set in the </span><em>Details Panel</em><span> once a </span><em>Decorator</em><span> has been selected), and usually they are either hard-coded values or </span><em>Blackboard Key references</em><span> (more on </span><em>Blackboards</em><span> later in this chapter).</span></p>
<p>Almost every <em>Decorator</em> has a checkbox in its parameters that allows you to invert the conditions (as a result, you will have more freedom, and you can use the same decorator on two different parts of the tree to execute different conditions).</p>
<p>The following screenshot shows how a decorator can be attached to a <em>Composite</em> node. Note that it is possible to have more than one Decorator per node:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d46cee45-42c5-404b-a191-17d34b1695a9.png" style="width:34.33em;height:24.25em;"/></div>
<div class="mce-root packt_infobox">For those who are familiar with Conditional nodes in other Behavior Tree systems, it is important not to confuse them with Task leaf nodes in Unreal Engine. More information can be found at <a href="https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer">https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer</a>.</div>
<p>Like Tasks, Unreal comes with some built-in Decorators that are ready to be used. They are general and cover the basic cases that you will probably need, but obviously, they cannot be specific for your game or application, and so you will need to create your own <em>Decorators</em> (we will look at this in detail in <a href="e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml">Chapter 6</a><em>, Extending Behavior Trees</em>).</p>
<p><span>Here is the list of the built-in tasks in Unreal:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c0ed724e-39d8-4f0a-a9e9-a4ef8b4a0f71.png" style="width:26.75em;height:31.42em;"/></p>
<ul>
<li><strong><em>Blackboard</em></strong>: Checks if a specific key on the <em>Blackboard</em> <em>Is Set</em> (or <em>Is Not Set</em>).</li>
<li><strong><em>Check Gameplay Tags on Actor</em></strong>: As the name suggests, it checks if there is a specific Gameplay Tag(s) on an Actor that's been specified by a Blackboard value.</li>
<li><strong><em>Compare BBEntries</em></strong>: Compares two Blackboard values and checks if they are equal (or not equal) to each other.</li>
<li><strong><em>Composite</em></strong>: This allows you to compose different <em>Decorators</em> at once with boolean logic. Once you have placed this <em>Decorator</em>, you can open its editor by double-clicking on it. From there, you will be able to build a graph with boolean operators and other <em>Decorators</em>.</li>
<li><strong><em>Conditional Loop</em></strong>: As long as the condition is satisfied (whether a <em>Blackboard Key</em> <em>Is Set</em> or <em>Is Not Set</em>), it will keep looping through the sub-tree.</li>
<li><strong><em>Cone Check</em></strong>: This checks if one point (usually another Actor) is within a cone, starting from another point (usually the AI agent); the cone angle and direction can be changed. An example of its use is if you want to check whether the Player is in front of the enemy or not—you could use this code to determine this condition.</li>
<li><strong><em>Cooldown</em></strong>: Once the execution exits from the branch containing this <em>Decorator</em>, a <em>Cooldown timer</em> will start, and this <em>Decorator</em> doesn't allow the execution to enter again until this timer has expired (it reports <em>Failure</em> immediately). This node is used so that you don't repeat the same sub-tree too frequently.</li>
<li><strong><em>Does Path Exist</em></strong>: This uses the Navigation System (more on this in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>) to determine (and check) whether or not a Path exists for a specific point.</li>
<li><strong><em>Force Success</em></strong>: As the name suggests, it forces the Success of the sub-tree, regardless of whether a <em>Failure</em> (or a <em>Success</em>) has been reported from below. This is useful for creating optional branches in a Sequence.</li>
</ul>
<div class="packt_infobox">Note that Force Failure doesn't exist, since it wouldn't make sense. If this were to be placed on a Selection, this would make it a Sequence, and if it were placed on a Sequence, it would only make one child execute.</div>
<ul>
<li><strong><em>Is at Location</em></strong>: As the name suggests, it checks if the Pawn is (near or) at a specific Location (optionally, using the <em>Navigation System</em>).</li>
<li><strong><em>Is BBEntry of Class</em></strong>:As the name suggests, it checks if a specific Blackboard Entry is of a specific Class. This is useful when the Blackboard Entry is of type Object, and you need to check if the reference within the Blackboard is of a specific class (or inherits from one).</li>
<li><strong><em>Keep in Cone</em></strong>: Similar to <em>Cone Check</em>, this <em>Decorator</em> (continuously) checks if the <em>Observer</em> is within a <em>Cone</em>.</li>
<li><strong><em>Loop</em></strong>: As the name suggests, it loops within the sub-tree for a specific number of times (or even an infinite number of times; in this case, something else is needed to stop the behavior of the sub-tree, e.g. another <em>Decorator</em>).</li>
<li><strong><em>Set Tag Cooldown</em></strong>: Similar to its homonym <em>Task</em>, when this <em>Decorator</em> becomes relevant (or if you imagine it as a gate, when it is traversed), it will change the <em>Cooldown</em> timer for a specific <em>Tag</em> (see the following node).</li>
<li><strong><em>Tag Cooldown</em></strong>: This is the same as the <em>Cooldown</em> node, but it has a timer associated with a <em>Tag</em>. As a result, this timer can be changed by the "<em>Set Tag Cooldown</em>" <em>Task</em> and by the "<em>Set Tag Cooldown</em>" <em>Decorator</em>.</li>
<li><strong><em>Time Limit</em></strong>: As the name suggests, it provides a time limit for the sub-tree to finish its execution. Otherwise, this Decorator will stop execution and return a <em>Failure</em>.</li>
</ul>
<p><span>Now that we have seen how</span> <em>Decorator</em><span> nodes work, let's explore the last type of nodes of the Behavior Tree, </span><em>Service</em><span> nodes, which will continuously update and provide information in real time.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service</h1>
                </header>
            
            <article>
                
<p><strong><em>Service</em></strong> nodes attach to <em>Composite</em> or <em>Task</em> nodes and will execute if their branch is being executed. This means that as long as a node below the node is attached, it doesn't matter how many levels of parent-children are being executed—the Service will run as well. The following screenshot will help you visualize this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0508789a-67b2-425b-b713-99a88cd2190a.png"/></p>
<p>This means that Service nodes are the eyes on the Behavior Tree's execution. In fact, they run continuously (if the sub-tree is active) and can perform checks and/or update <em>Blackboard</em> (see later) values in real-time.</p>
<p><strong><em>Service</em></strong> nodes are really specific for your <em>Behavior Tree</em> application, so there are only two default ones. An example of their usage might be providing/updating information to the sub-tree. For instance, imagine a situation where a sub-tree (the enemy) is trying to kill the player. However, it would be dumb (well, it depends of the enemy type, trolls might not be so smart) to pursue this objective, even when the player isn't shooting back at the enemy. Thus, while the sub-tree is trying to kill the player, the sub-tree needs to find cover to reduce the damage the enemy takes. However, the enemy might be moving in the map, or the player might destroy the cover where our AI is hiding. Thus, the sub-tree needs information regarding the location of the nearest and safest cover, which is still in range of the player (an <em>EQS Query</em> can calculate that). A service can update this information in real-time so that when the sub-tree needs to use the data regarding the cover, they are ready. In this particular example, to find cover, running an <em>Environment Query</em> on the Service is a dynamic way to handle the task (we will look at this topic in <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environmental Querying System</em>). Otherwise, the <em>Service</em> might check certain specified points in the map that have been placed by a designer and evaluate which one is the best for its given action.</p>
<p>As you can see, <strong><em>Service</em></strong> nodes can be really powerful, but they are also specific to the application you are using them for. Thus, they really depend on the AIs you are programming for your game.</p>
<p>The following screenshot shows a couple of examples of Services. Please notice that <em>Services</em> can be used along with <em>Decorators</em>, and that a <em>Composite</em> node can have more than one <strong><em>Service</em></strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/12559947-1cc8-4ce0-be57-f6504a1174b1.png" style="width:45.00em;height:13.17em;"/></div>
<div class="mce-root packt_infobox"><em>Service nodes</em> replace traditional <em>Parallel nodes</em> in other <em>Behavior Tree systems</em>.</div>
<p class="CDPAlignLeft CDPAlign">The only two available default <em>Services</em> <span>(since you will need to program your own for your game, which we will do in </span><a href="e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml">Chapter 6</a><em>, Extending Behavior Trees</em><span>)</span> are shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/edab27c3-7245-4fb9-84a8-2dde04d5ab59.png" style="width:33.42em;height:21.75em;"/></p>
<ul>
<li><strong><em>Set Default Focus</em></strong>: When this node becomes active, it automatically sets the <em>Default Focus</em> for the <em>AI controller</em>.</li>
<li><strong><em>Run EQS</em></strong> <em>(Query on a regular basis)</em>: As the name suggests, it runs an <em>Environmental Query</em> (check out <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environment Querying System</em>, for more information) on a regular basis to check for specific locations or actors. This was the kind of service that we needed in our example of finding cover for the enemy.</li>
</ul>
<div class="packt_infobox">You will learn more about <em>Environmental Queries</em> in <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml"/><a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml"/><a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environment Querying System</em>. However, for now, all you need to know is that this is a system for spatial reasoning, and running these queries can find locations (or actors) within the space with specific properties (in the example of finding cover for the enemy, the one that maximizes these properties: the nearest, the safest, and still in rage to shoot to the player).</div>
<p>Now, we have learned about the different kind of nodes that compose a <em>Behavior Tree</em>. Now, it is time to explore Blackboards!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blackboards and their integration with Behavior Trees</h1>
                </header>
            
            <article>
                
<p>Considering the <em>Behavior Tree</em> as a brain, we can think of a <em><strong>Blackboard</strong></em> as its memory—more specifically, the memory of the AI. The <strong><em>Blackboard</em></strong> stores (and sets) key values for the <em>Behavior Tree</em> to use.</p>
<p>They are called blackboards because, in a classroom, the blackboard is a place where a lot of information is conveyed, but most of it is shared among students; the single notes that are given out to students are personal. You can imagine the students as the different tasks (and nodes) of the <em>Behavior Tree</em>, and the <strong><em>Blackboard</em></strong> as a shared place for data.</p>
<p><strong><em>Blackboards</em></strong> are fairly simple to understand, since they are only a little more complex than a data structure. The only difference lies in the possibility to assign to a <em>Behavior Tree</em> to a particular <strong><em>Blackboard</em></strong>, which is shared by every node of the tree. As a result, each node can read and/or write back to the <em>Blackboard</em>.</p>
<div class="packt_infobox">For those of you who are familiar with the <strong><em>Design Pattern of Blackboards</em></strong>, within the context of Unreal, they just cover the role of holding the memory for a <em>Behavior Tree</em>.</div>
<p>It works like a <em>dictionary</em> (the data structure), in which a key corresponds to a specific value type (e.g. a vector, a float, an actor, etc…, even another <em>Blackboard Key</em>). So, by using or recalling the key, it is possible to write or read the associated value.</p>
<p>Another cool feature of <strong><em>Blackboards</em></strong> is that they can be extended through inheritance. This means that another <strong><em>Blackboard</em></strong> can be a parent, and the child will inherit all the parent's pairs key-value, plus some specific ones that are contained in the child itself.</p>
<p>Now that we have covered the theory, let's look at how we can create a <em>Behavior Tree</em> and make it run. To do that, let's start by creating a new project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our AI project</h1>
                </header>
            
            <article>
                
<p>From now on, we will get our feet wet by creating a project, and get a gist of what we have learned about <strong><em>Behavior Trees</em></strong>. In this <span><span>section, </span></span>we are going to create a simple tree, but as we learn more about other topics in the following chapters, we will iterate over the tools for <strong><em>Behavior Trees</em></strong>. As a result, this will provide you with a better understanding of the tools that are required to create awesome <strong><em>Behavior Trees</em></strong>. Then, in <a href="6995bf12-0f10-47a9-a48c-cec31696df87.xhtml">Chapter 8</a>, <em>Designing Behavior Trees - Part I</em>, <a href="063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml">Chapter 9</a>, <span> </span><em><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">Designing Behavior Trees - Part II</span></span></em>, and <a href="039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml">Chapter 10</a>, <em>Designing Behavior Trees - Part III</em>, we will be focusing on how to <em>create and design</em> a <strong><em>Behavior Tree</em></strong> from scratch that chases the player, which will give you a practical approach to <strong><em>Behavior Trees</em></strong>.</p>
<p>So, to be able test the techniques that we are going to explore in this book, we need to create a project. By doing this, you will be able to follow the practical aspects that will be covered throughout this book.</p>
<p>You can create a new project from a template. The Third Person template works particularly well. In fact, it already has a character set up inside it, which can be easily possessed by an AI. This means that you don't have to worry too much about non-AI related details, such as animations. You can choose either the Blueprint version or the C++ one. I'll explain the concepts that we'll cover in both Blueprint and C++ terms throughout, but do note that some techniques in this book will work better if they're programmed in C++. As a result, I'm choosing the C++ version of the Third Person template, although this initial choice doesn't affect us much (we are programming AIs, not a Player or Gameplay).</p>
<p>Finally, I'm naming my project <kbd>UnrealAIBook</kbd>, as shown in the following screenshot. Once again, you will be able to find the project files at the following link: <a href="http://hog.red/AIBook2019ProjectFiles">http://hog.red/AIBook2019ProjectFiles</a> (the link is case-sensitive):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/690fb145-83c8-4a15-9941-04460e4d954e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting Behavior Trees from AI Controllers</h1>
                </header>
            
            <article>
                
<p>Now that we have covered the basics of what Behavior Trees are and what they consist of, let's create our own. Recall from the previous chapter, the class in charge of possessing a Pawn and controlling it is the AI Controller. Thus, our <strong><em>Behavior Trees</em></strong> should run on <em>AI Controllers</em>.</p>
<p>We have two ways we can do this. The first one is by using Blueprints. Usually, even if you are a programmer, it is best to create a <strong><em>Behavior Tree</em></strong> using Blueprints, since the logic is really easy and the controller is simple. On the other hand, if you are a C++ fan and you want to use it as much as possible, even for small tasks, don't worry—I'll recreates the same logic we will do in Blueprint again, but this time in C++. In any case, <strong><em>Behavior Tree</em></strong> assets should be created and modified within the editor. What you will eventually program are different nodes than the ones that are available by default (we will see this later in this book), but the tree itself is always made in the editor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Behavior Tree and the Blackboard </h1>
                </header>
            
            <article>
                
<p>To begin, we will need to create four Blueprint Classes: <strong><em>AI Controller</em></strong>, <strong><em>Character</em></strong>, <strong><em>Behavior Tree</em></strong>, and <strong><em>Blackboard</em></strong>. We will cover the AI controller later. If you chose one of the two Third Person templates, you should already have a <em>Character</em> ready to go. Thus, you just need to create a <strong><em>Behavior Tree</em></strong> and a <strong><em>Blackboard</em></strong>.</p>
<p>In the <em>Content Browser</em>, create a new folder and name it <kbd>Chapter2</kbd>. This will help keep things organized. Then, create a sub-folder and name it <kbd>AI</kbd>. As a result, we can keep our project tidy and ensure that we don't mix up items from this chapter with other <em>non-AI-related</em> classes and/or objects we might create. We will put all the assets we are going to create for the AI in this folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Blackboard</h1>
                </header>
            
            <article>
                
<p>Now, we need to add a <strong><em>Blackboard</em></strong>, which should always be within the <kbd>AI</kbd> folder. To do this, go to the <strong>Content Browser</strong> and select <strong>Add New</strong> &gt; <strong>Artificial Intelligence</strong> &gt; <strong>Blackboard</strong>.</p>
<p>For now, we will call our Blackboard <kbd>BB_MyFirstBlackboard</kbd>. Here, I'm using the naming convention to prefix all Blackboards with <kbd>BB_</kbd>. Unless you have a specific reason to not follow this naming convention, please use it. By doing this, you will be in sync with the rest of this book.</p>
<div class="packt_tip">Since it is not possible to have multiple Blackboards on the same <em>Behavior Tree</em>, you can use inheritance with Parent and Child within the <strong>Blackboard Details</strong> panel, as shown in the following screenshot on the right):</div>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e49c8321-5531-4b68-ad1d-74fda84e703f.png" style="width:37.33em;height:17.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Behavior Tree</h1>
                </header>
            
            <article>
                
<p>Let's add a <em>Behavior Tree</em> by going to the <strong>Content Browser</strong> and selecting <strong>Add New</strong> &gt; <strong>Artificial Intelligence</strong> &gt; <strong>Behavior Tree</strong>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/54632525-d656-4f2e-8b63-746deeeba315.png" style="width:24.33em;height:36.92em;"/></div>
<p>For now, we will call our Behavior Tree <kbd>BT_MyFirstBehaviorTree</kbd>. Again, here, I'm using a specific naming convention to prefix all Behavior Tree assets with <kbd>BT_</kbd>. Once again, please follow the naming convention, unless you have a specific reason not to.</p>
<p>When you open the <em>Behavior Tree</em> window, you will see a single node called <strong>Root</strong>, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e44e6054-d9fb-4b2f-905c-6e4fbaedaea1.png" style="width:8.00em;height:5.83em;"/></div>
<p>The <strong>Root</strong> is where the execution of your <em>Behavior Tree</em> begins (from top to bottom and left to right). The Root itself only has one reference and that is the Blackboard, so it cannot be connected to anything else. It is the tip of the tree, and all subsequent nodes are below it.</p>
<p>If you drag from the <strong><em>Root</em></strong> Node, you will be able to add <strong><em>Composite</em></strong> nodes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ce9e5a41-1bee-40c0-bd09-89af8162c83f.png" style="width:19.08em;height:21.25em;"/></p>
<p>For this, the <em>Behavior Tree Editor</em> is very intuitive. You can keep dragging out from the nodes to add <strong><em>Composite</em></strong> or <strong><em>Tasks</em></strong> nodes. To add a <strong><em>Decorator</em></strong> or a <strong><em>Service</em></strong>, you can right-click on a node and select "<strong><em>Add Decorator...</em></strong>" or "<strong><em>Add Service...</em></strong>", respectively, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca3285ef-4156-434c-aa1c-8757ec4a9ab2.png" style="width:18.75em;height:22.42em;"/></p>
<p>Finally, if you click on a node, it is possible to choose its parameters in the <em>Details Panel</em> (the following screenshot shows an example of a <em>Move To Node</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e3975fc3-c7f6-4b68-a779-8e91f7ad82a8.png" style="width:37.00em;height:26.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The AI Controller to run a Behavior Tree</h1>
                </header>
            
            <article>
                
<p>The next step is to run the <em>Behavior Tree</em> from an <em>AI Controller</em>. Usually, this is an easy task that it is implemented in Blueprint (in which it is possible to directly refer to a specific Behavior Tree). Even if we have a complex <em>C++ AI Controller</em>, we can extend the controller in Blueprint and <em>Run</em> the <em>Behavior Tree</em> from Blueprint. In any case, if a hard reference doesn't work (e.g. you are using C++ or because you want to have more flexibility), then you can store the <em>Behavior Tree</em> in the <em>Character/Pawn</em> that needs to run that specific <em>Behavior Tree</em>, and retrieve it when the <em>AI Controller</em> possesses the <em>Pawn</em>.</p>
<p>Let's explore how we can do this both in Blueprint (we will reference the <em>Behavior Tree</em> in a variable, in which we can decide on the default value) and in C++ (in which we will store the <em>Behavior Tree</em> in the <em>Character</em>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AI Controller in Blueprint</h1>
                </header>
            
            <article>
                
<p>We can create a Blueprint AI Controller by clicking on <strong>Add New</strong> | <strong>Blueprint Class</strong> | <strong>AI</strong> <strong>Controller.</strong> You will have to click <strong>All Classes</strong> and search for <strong>AI Controller</strong> to access it. You can see an example of this in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e050bec6-3b7f-425c-a8b8-388c924585cf.png" style="width:22.92em;height:29.50em;"/></div>
<p>For now, we will call our <strong>AI Controller</strong> <kbd>BP_MyFirstAIController</kbd>. Double-click on it to open the <em>Blueprint Editor</em>.</p>
<p>First, we need to create a variable so that we can store our <strong><em>Behavior Tree</em></strong>. Although it's not necessary to keep reference of the <em>Behavior Tree</em>, it's good practice to do so. To create a variable, we need to press the <strong><em>+ Variable </em></strong>button in the <em>My Blueprint </em>panel, next to the <strong><em>Variables</em></strong> tab, as shown in the following screenshot (keep in mind that your cursor needs to be on the Variables tab for the button to show up):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7851d84-9f87-4b1a-b664-a061dd73f5c0.png" style="width:24.08em;height:21.00em;"/></p>
<p>Then, as a variable type, you need to select <em>Behavior Tree</em> and give it a name, such as <strong><em>BehaviorTreeReference</em></strong>. This is how what your variable should look like:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e519b4d5-55f8-4b5e-8412-630d53473810.png" style="width:22.00em;height:3.25em;"/></p>
<p>Then, in the <em>Detail Panel</em>, we will set the Default value (remember that to set the default value, the Blueprint needs to be compiled):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c558b0b0-f5f3-401f-b3ea-7d4b152305af.png" style="width:44.50em;height:35.00em;"/></p>
<p>Then, we need to override the <strong><em>On Possess</em></strong> function, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cfaf02f5-051a-424b-95ae-030256348ed0.png" style="width:45.08em;height:37.75em;"/></p>
<p>Finally, in the <em><strong>Event On Possess</strong></em> of the <em>AI Controller</em>, we need to start running/executing the <em>Behavior Tree</em>. We can achieve this by using the following simple node, named <strong><em>Run Behavior Tree</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a481b8ea-9642-47eb-957e-ec36be49a6c4.png" style="width:32.25em;height:11.92em;"/></p>
<p>As a result, your AI controller will be able to execute the <em>Behavior Tre</em><em>e</em> that's stored within the <strong><em>BehaviorTreeReference</em></strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AI Controller in C++</h1>
                </header>
            
            <article>
                
<p>If you have decided to create this simple AI controller in C++<span>, let's get started. I'm assuming that your Unreal Editor is already set up to work in C++ (e.g. you have Visual Studio installed, symbols for debugs, etc.... Here is a reference link so that you can get started:</span> <a href="https://docs.unrealengine.com/en-us/Programming/QuickStart">https://docs.unrealengine.com/en-us/Programming/QuickStart</a><span>) and that you have basic knowledge of how C++ works in Unreal.</span><span> Here is a link for the naming convention so that you understand why some classes are prefixed with letters in the code: </span><a href="https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard">https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard</a>.</p>
<div class="packt_infobox">Before you start, remember that in order to work on AI in C++, you need to add the public dependencies in your <span>your <kbd>.cs</kbd> file (in this case, </span><strong><em>UnrealAIBook.cs</em></strong><span>), and add </span><strong>GameplayTasks</strong><span> and</span> <strong>AIModule</strong><span> as public dependencies, like in the following code:</span><br/>
<kbd>PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay",<span> </span><strong>"GameplayTasks", "AIModule"</strong><span> </span>});</kbd><br/>
<span>This will ensure that your code will compile without problems.</span></div>
<p>Let's create a new C++ class, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3139ede6-da33-4d59-ac3b-4b2863792098.png" style="width:16.00em;height:45.58em;"/></p>
<p>The class needs to inherits from the <strong><em>AIController</em></strong> class. You might need to check the <em>Show All Classes</em> checkbox in the right-top corner and then use the search bar, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f085bf2-d334-40bb-a6e1-2e5a1a00db98.png"/></p>
<p class="CDPAlignLeft CDPAlign">Click on <em>Next</em> and name the class <strong><em>MyFirstAIController</em></strong>. Moreover, I'd suggest that you keep our project tidy. Thus, click on the <strong><em>Choose Folder</em></strong> button. Unreal will prompt you to go to your system folder explorer. Here, create a folder named <kbd>Chapter2</kbd>, and within it a sub-folder named <kbd>AI</kbd>. Choose this folder as the place where you are going to store the piece of code we are going to create. This is what the dialogue box should look like, just before you click on <em>Create</em>:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/3b74268a-2b98-4910-817b-68634caf997d.png" style="width:69.83em;height:42.08em;"/></p>
<p>Now, click on <em>Create</em> and wait for your editor to load. You might see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b2f65620-b4cb-4792-b5af-171ce4c74753.png" style="width:40.83em;height:8.58em;"/></p>
<p>The structure of our code will be slightly different compared to the Blueprint version. In fact, we cannot assign a <strong><em>Behavior Tree</em></strong> directly from the AI Controller class (mainly because it would be hard to reference it directly); instead, we need to take it from the Character. As I mentioned previously, this is a good approach when you're working with Blueprints too, but since we have chosen a C++ project, we should look at some code. In Visual Studio, open the <kbd>UnrealAIBookCharacter.h</kbd> file, and just below the public variables, add the following lines of code:</p>
<pre>    //** Behavior Tree for an AI Controller (Added in Chapter 2)<br/>    UPROPERTY(EditAnywhere, BlueprintReadWrite, category=AI)<br/>    UBehaviorTree* BehaviorTree;</pre>
<p>For those who are still unfamiliar, here is a larger chunk of code so that you can understand where to place the preceding code within the class:</p>
<pre>public:<br/>     AUnrealAIBookCharacter();<br/><br/>    /** Base turn rate, in deg/sec. Other scaling may affect final turn rate. */<br/>     UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=Camera)<br/>     float BaseTurnRate;<br/><br/>    /** Base look up/down rate, in deg/sec. Other scaling may affect final rate. */<br/>     UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=Camera)<br/>     float BaseLookUpRate;<br/><br/><strong><em>    //** Behavior Tree for an AI Controller (Added in Chapter 2)</em></strong><br/><strong><em>     UPROPERTY(EditAnywhere, BlueprintReadWrite, category=AI)</em></strong><br/><strong><em>     UBehaviorTree* BehaviorTree;</em></strong></pre>
<p>Moreover, to compile the preceding code, we also have to include the following statement at the top of the class, just above <kbd>.generated</kbd>:</p>
<pre>#include "CoreMinimal.h"<br/>#include "GameFramework/Character.h"<br/><strong>#include "BehaviorTree/BehaviorTree.h"<br/></strong>#include "UnrealAIBookCharacter.generated.h"</pre>
<p>Close the <em>Character class</em>, since we have finished with it. As a result, every time we have an instance of that character placed in the world, we will be able to specify a <em>Behavior Tree</em> from the <em>Details</em> panel, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a8890c1f-47aa-4dc9-bb45-e9d180b264bb.png" style="width:30.17em;height:25.42em;"/></p>
<p>Let's open the header (<kbd>.h</kbd>) file of our newly created AI controller (it should already be open in <em>Visual Studio</em> if you are using it as an <em>IDE</em>). In particular, we need to override a function of the AI Controller class. The function we are going to override is called <kbd>Possess()</kbd>, and it allows us to run some code as soon as this AI Controller possess a new Pawn (that is, when it takes control of the character, which is a Pawn). Add the following code in bold (within a protected visibility):</p>
<pre>UCLASS()<br/>class UNREALAIBOOK_API AMyFirstAIController : public AAIController<br/>{<br/>     GENERATED_BODY()<br/> <br/><strong>protected:</strong><br/><br/><strong>  //** override the OnPossess function to run the behavior tree.</strong><br/><strong>  void OnPossess(APawn* InPawn) override;</strong><br/> <br/> <br/>};</pre>
<p>Next, open the implementation (<kbd>.cpp</kbd>) file. Once again, to use <em>Behavior Trees</em>, we have to include both <em>Behavior Trees</em> and the <kbd>UnrealAIBookCharacter</kbd> class:</p>
<pre>#include "MyFirstAIController.h"<br/><strong>#include "UnrealAIBookCharacter.h"<br/></strong><strong>#include "BehaviorTree/BehaviorTree.h"</strong></pre>
<p>Next, we need to assign a functionality to the <kbd>Possess()</kbd> function. We need to check whether the <em>Pawn</em> is actually an <strong><em>UnrealAIBookCharacter</em></strong>, and if so, we retrieve the <em>Behavior Tree</em> and run it. Of course, this is surrounded by an <kbd>if</kbd> statement to avoid our pointers being <kbd>nullptr</kbd> :</p>
<pre>void AMyFirstAIController::OnPossess(APawn* InPawn)<br/>{<br/>  Super::OnPossess(InPawn);<br/>  AUnrealAIBookCharacter* Character = Cast&lt;AUnrealAIBookCharacter&gt;(InPawn);<br/>  if (Character != nullptr)<br/>  {<br/>    UBehaviorTree* BehaviorTree = Character-&gt;BehaviorTree;<br/>    if (BehaviorTree != nullptr) {<br/>      RunBehaviorTree(BehaviorTree);<br/>    }<br/>  }<br/>}</pre>
<div class="packt_infobox">If, for any reason, you cannot get the code to work, you can just use a Blueprint controller to start the <em>Behavior Tree</em>, or just inherit the C++ controller, and make sure that all rest of the code runs, and make a call to the <kbd>RunBehaviorTree()</kbd> function in Blueprint.</div>
<p>Once we have compiled our project, we will be able to use this controller. Select our AI character from the Level (if you don't have it, you can create one) and this time, in the <em>Details</em> panel, we can set our C++ controller, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2ca2c2d3-949d-4a87-a980-858ee4285383.png" style="width:37.75em;height:14.00em;"/></p>
<p>Also, don't forget to assign the <em>Behavior Tree</em> as well, which we always do in the <em>Details Panel</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b8129073-f0fa-4531-9556-ab97d878ab78.png" style="width:36.33em;height:7.42em;"/></p>
<p>As a result, once the game starts, the enemy will start executing the Behavior Tree. At the moment, the tree is empty, but this gives us the structure we need so that we can start working with <em>Behavior Trees</em>. In the following chapters, we are going to explore <em>Behavior Trees</em> more in detail, especially in chapters 8, 9, and 10, where we will look at a more practical approach to designing and building <em>Behavior Trees</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered what a <strong><em>Behavior Tree</em></strong> is and some of the things that they consist of, including <em>Tasks</em>, <em>Decorators</em>, and <em>Services</em>. Next, we learned about <strong><em>Blackboards</em></strong> and how to integrate them with <em>Behavior Trees</em>. Then, we created a <em>Behavior Tree</em> and learned how to make it start from an <em>AI Controller</em> (both in Blueprint and C++). By doing this, we have developed a solid foundation that has provided us with key knowledge so that we can tackle the other parts of this book.</p>
<p>As a result, we will meet more <em><strong>Behavior Trees</strong></em> throughout this book, and you will have a chance to master them. But before that, there are certain topics we need to learn about first. Once we have a solid foundation of navigation and perception (including EQS), we can iterate over <strong><em>Behavior Trees</em></strong> to understand the role of <em>Composite</em> nodes, along with <em>Decorator</em> and <em>Tasks</em>. Moreover, we will be able to create our own. Chapters 8, 9, and 10 will guide you through the process of creating a Behavior Tree from scratch, from the designing phase to realization.</p>
<p>But until then, let's move on to the next chapter, in which we are going to discuss <em>Navigation</em> and <em>Pathfinding</em>!</p>


            </article>

            
        </section>
    </body></html>