<html><head></head><body>
        

                            
                    <h1 class="header-title">Advanced Pathfinding</h1>
                
            
            
                
<p>In this chapter, we will take a look at the advanced pathfinding methods that can be used in a wide range of games. The main objective of this chapter is to learn the foundations of how to create an advanced AI element that can analyze the map and process all the necessary information in order to decide the best path that needs to be taken. Advanced pathfinding methods can be found in many popular game titles that require the AI character to choose the best path in real time, and we will analyze some of the most famous examples and how can we replicate the same results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple versus advanced pathfinding</h1>
                
            
            
                
<p>As we discovered in the previous chapter, pathfinding is used by AI characters to discover the direction that they need to move and how to do it correctly. Depending on the game that we are working on, we could use a simple pathfinding system or a complex one. Both can be very useful. There are situations where a simple pathfinding system is enough to accomplish the task that we are looking for, but in other cases we need a different alternative to the methods that we have covered before in order to achieve the complexity and realism that is necessary for our AI character.</p>
<p>Before talking about any advanced system of creating a pathfinding method, let's discover why we need to use it and in what circumstances it is necessary to update our character and make it more intelligent and aware. Using our previous examples, we will be looking at the limitations that exist for a normal pathfinding method. Understanding the limitations of a simple pathfinding system will help us acknowledge what is missing and what challenges we will face when we are about to create a more complex system. So it is a good start to first learn how we can set up a simple pathfinding system and then we can move on to a more complex one. Because games have evolved at the same rate as the technology available to create them, our first example will be an older game, and then we'll see how the same game has evolved, in particular AI pathfinding.</p>
<p>Open world maps are now very common, and many games from different genres use this to create a rich experience, but it wasn't always like this. Let's take the first <strong>Grand Theft Auto</strong> (<strong>GTA</strong>) game as an example. Analyzing the pattern of the cars that are driving on the map, we can see that they don't have a complex system, and the drivers are stuck to the predefined route or lap that each of them is assigned to follow. Obviously, this AI pathfinding system was very advanced at that time and even if we play it today, we don't feel discouraged by the AI characters because it works wonderfully for that game.</p>
<p>The AI drivers follow their path and stop every time the player is in their way. This demonstrates that they have a collision detector in front of each car to tell them if there is something blocking the path. If there is something in front of the car, the driver stops immediately, and until the path is unblocked, it won't drive again. This is a sign that the drivers have some sort of pathfinding system that couldn't solve different situations where it was not possible for them to keep driving in the same direction. For that reason and to avoid any errors or glitches in the game, the programmers have chosen to make the drivers stop when that happens.</p>
<div><img height="307" width="409" class=" image-border" src="img/d96ded83-37cb-4284-8fa1-2309735da118.jpg"/></div>
<p>The preceding case scenario, where the drivers stop when it's not possible for them to keep moving forward, became one of the biggest strengths in their future games. Many things have evolved in the GTA games, and the AI is definitely one of them. They have refined the AI drivers, making them aware of the situation and their surroundings. Let's analyze <em>GTA San Andreas,</em> which is also available to play on mobile phones. In this game, if we stop our car in front of the AI driver, the results are completely different. Depending on the personality of the AI driver, it will react differently; for example, some of them will simply honk the horn and wait a little bit, and if the player keeps blocking their way, the driver will outrun the player. Others might react more aggressively, getting out of the car to confront the player physically.</p>
<p>If the AI driver notices that the environment is getting dangerous by hearing shots, they speed up and choose the fastest path to get out of that situation. This type of behavior demonstrates that the AI characters have a more complex and refined pathfinding system in conjunction with a possibility map, where the surrounding situation will reflect which path they end up choosing.</p>
<div><img height="270" width="432" class=" image-border" src="img/29e6ca7d-c2bb-45dc-aaad-a200b6e6cd79.jpg"/></div>
<p>As we can see, the drivers now have a presence that's much more noticeable than in the first game. In the previous chapter, we studied how to create a simple pathfinding system, very similar to what we analyzed in the first GTA game. Now, we'll look in depth at how to create an AI character that can get away from any unexpected situation.</p>
<p>This is one of those things that still isn't perfect, and many developers are trying new ways of creating AI characters that can behave almost like a human person would if trapped in the same situation. Some companies are getting close to that--one big example is Rockstar Games with their GTA franchise, and for that reason we have chosen to start with their example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A* search algorithm</h1>
                
            
            
                
<p>Unpredictable situations usually lead to a large amount of hours coding the extensive possibilities that the characters have. For this reason, it was necessary to think on a new way to create a better pathfinding system, where the characters could analyze the surroundings for themselves in real time and choose the best path to take. One method that has become very popular for this effect is using <strong>theta algorithms</strong>, which allows the characters to constantly search for the best path without it being necessary to manually set which points they need to follow.</p>
<p>The Theta search algorithm (A*) is a widely used search algorithm that can be used to find solutions for many problems and pathfinding is one of them. Using this algorithm to solve pathfinding problems is very common due to the uniform-cost search and heuristic search. The Theta search algorithm examines every corner of the map to help the character determine if it is possible to use that location or not, while trying to reach the desired destination.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works</h1>
                
            
            
                
<p>The map or scene of the game needs to be prepared or pre-analyzed before the theta algorithm can work. The environment that includes all the assets of the map will be handled as a graph. This means that the map will be broken into different points and locations, which are called nodes. These nodes are used to record all the progress of the search. While memorizing the map location, each individual node has other attributes, such as fitness, goal, and heuristic, usually represented by the letters f, g, and h. The purpose of the fitness, goal, and heuristic attributes is to put in order how good a path is according to the current node.</p>
<p>Different values are assigned to the paths between the nodes. These values usually represent the distances between the nodes. The value between the nodes doesn't necessarily have to be distance. The value can also be time; this will help us find the fastest path instead of the shortest one, for example. The Theta algorithm uses two lists, an open list and a closed list. The open list contains the nodes that were totally explored. Marker arrays can also be used to find out whether a state is in the open list or the closed list.</p>
<div><img height="266" width="380" class=" image-border" src="img/7325c113-ad29-4aec-95ac-4dc68ba988a5.jpg"/></div>
<p>This means that the character will constantly be searching for the best nodes to follow in order to achieve the fastest or shortest results. As we can see in the preceding screenshot, the map was pre-analyzed, the walkable area is represented by the small gray squares, while the big squares represent the area that is blocked by some object or environment asset. The AI character represented by the black and white circle needs to move node by node until it reaches the star object. If for some reason one of the nodes is blocked, the character will rapidly switch to the closest one and then continue on its way.</p>
<p>As we can see, this pathfinding method's theory is very similar to what we have created before, where the character follows point by point until it arrives at the final destination. The main difference is that with the Theta algorithm, the points are generated automatically by the AI, making it the best choice when developing big or complex scenes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Disadvantages of using A*</h1>
                
            
            
                
<p>The Theta algorithm is not the perfect solution that can be used everywhere or in every game, and we should keep that thought in mind. Because the AI character is constantly searching for the best path to follow, a significant portion of the CPU is being used exclusively for that task. Because tablets and mobile devices are very popular gaming platforms nowadays, it is worth mentioning that developing a game for these platforms requires paying special attention to the CPU and GPU usage, and for that reason, A* pathfinding can be a disadvantage here.</p>
<p>But hardware limitation isn't the only disadvantage. When we let the AI assume all the work without any human control, bugs are highly likely. That is one reason why modern games that prefer using open world maps encounter a lot of bugs and weird AI reactions, because it is extremely difficult to narrow down all the possible outcomes in a massive gameplay area.</p>
<p>" says bugs in the latest demo are natural for open world games"<br/>
Final Fantasy XV director</p>
<div><img height="336" width="509" class=" image-border" src="img/d0b85096-b48d-4dea-9e47-44c982765b97.jpg"/></div>
<p>The director of Final Fantasy XV commented about this issue, stating that bugs are expected in every open world game. This summarizes perfectly why using theta algorithms for AI pathfinding is a popular and efficient approach when developing open world games, but it is not perfect and bugs will definitely occur.</p>
<p>Now that we have a basic understanding of the theta algorithm and the pros and cons of it, let's move on to the practical section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Going directly from A to B</h1>
                
            
            
                
<p>We are going to start with a simple example, without any obstacles between one point and another. This will help us visualize how the algorithm finds the best path. Then we will be adding an obstacle and observing how the algorithm chooses the best path when contouring the obstacle at the same time.</p>
<div><img height="174" width="348" class=" image-border" src="img/aad6a824-7609-45fa-8528-7fb8d1fcd22a.jpg"/></div>
<p>On this grid we have two points, <strong>A</strong> that is the starting point and <strong>B</strong> that is the end point. We want to find the shortest path between the two. To help us solve this problem, we will be using the A* algorithm and we'll see how it manages to find the shortest path.</p>
<div><img height="175" width="350" class=" image-border" src="img/93ce4d0d-9c3a-4b13-9bac-daf1e24f2006.jpg"/></div>
<p>So, the algorithm calculates every step to find the shortest one. To calculate this, the algorithm uses two nodes, as we discovered before, the G node and the H node. G represents the distance from the starting point, so it calculates how far it is from the <strong>A</strong> position. H represents the distance from the end point, so it calculates how far it is from the <strong>B</strong> position. If we sum both nodes (<em>G + H = F</em>), we get the F node value, which represents the shortest path.</p>
<p>In this case, the shortest number is <strong>42</strong>, so we can move to that position and calculate again every available hypothesis.</p>
<div><img height="175" width="350" class=" image-border" src="img/e7dbd57e-5e87-4f6b-9fa2-353608b3c063.jpg"/></div>
<p>Once again, the algorithm calculates the best options that are available from the position that we are in. We are getting close to B, and for that reason the values for the H nodes are getting smaller while the values for the G nodes are getting bigger, and that is perfectly fine. From all the possibilities that we currently have, the number <strong>42</strong> is once again the lowest number and the best option to take. So the natural decision is to move towards that position.</p>
<div><img height="181" width="360" class=" image-border" src="img/d07cdf49-4103-415c-83e7-41ef34ddff18.jpg"/></div>
<p>And finally, we have arrived at the <strong>B</strong> point. Once the algorithm finds that the H node value is zero, that means that it has already arrived at the desired destination and there's no need to keep searching for a better path.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">From point A to B with obstacles in the way</h1>
                
            
            
                
<p>This is exactly how the A* pathfinding works; it goes from point to point evaluating the best options and pursuing the shortest path until it reaches the final destination. The earlier example was simple, and now we are going to make it more interesting to see how it works if we add obstacles to the map.</p>
<div><img height="167" width="332" class=" image-border" src="img/62751395-95a1-49b1-831a-868731b8a83d.jpg"/></div>
<p>Using the same map, we have painted some squares in black, representing that those positions can't be used. Now, it starts getting slightly more interesting, because if we try to guess what the best path to take would be, we might be wrong. Once again, let's calculate what the best options are, as follows:</p>
<div><img height="169" width="336" class=" image-border" src="img/2adcc2c2-b7bc-482a-a9f4-24de3f92f740.jpg"/></div>
<p>The results that we get are exactly the same as the first test and this is normal, because none of the points that are surrounding the <strong>A</strong> position are positioned on the black squares. Once again, we can move towards the lowest number that is <strong>42</strong>.</p>
<div><img height="191" width="380" class=" image-border" src="img/80c93264-b146-4336-a0e4-99b0b97c13b5.jpg"/></div>
<p>Now that we have made our first move and calculated the best options that are available from that point, we are in an interesting situation. At this moment, we have the three lowest numbers and we have to choose one. We need to find the shortest path that leads us to the <strong>B</strong> position and because the three lowest numbers are the same, we need to make the decision according to the H node only, which represents the distance between our current position and the B position. Two of the positions have the H value of <strong>38</strong> while just one of them has the value of <strong>24</strong>, making it the lowest H value of the three. So let's move on in that direction, which seems to be closer to the final destination.</p>
<div><img height="179" width="358" class=" image-border" src="img/7a7b201a-6932-4130-b195-4c98124c81ef.jpg"/></div>
<p>From now on we can notice that the F values are getting higher, which represents the shortest path value. This is due to the black squares that we have added to the map. Because of them, we need to go around, increasing the length of the path that we need to take. This is how the AI will perceive the walls; they know for a fact that the final destination is close, but in order to arrive there, they can't pass through the wall, so they need to go around until they find an open door or something similar.</p>
<p>Now, the lowest values are in the other direction, which means that we need to go back in order to find a better path. This is a very important aspect of the algorithm, because if we have the character walking around searching for the best path at the same time that it is walking, we will have a more human-like result. It will look like that he is searching for the correct path to arrive at the desired destination, like a person would if they didn't know the right path. On the other hand, the character can be programmed to make all the calculations before it starts moving, and in that case we would see a character going directly to the right path until it reaches the final point. Both methods are valid and can be used for different purposes and different games.</p>
<p>Continuing our pathfinding, we need to keep choosing the lowest value, so at this point we need to go back and choose between the two lowest values, <strong>48</strong>. Both have the same G and H values, so the only way to find out which is the best path to take is to randomly choose one of the points or pre-calculate them to see which of them will have the lowest value. So let's choose one randomly to see the values that come up.</p>
<div><img height="205" width="410" class=" image-border" src="img/11b3a167-57a4-4c63-a903-1996d152010c.jpg"/></div>
<p>After choosing one of the two shortest possibilities, we found that the values are getting higher, and for that reason we need to go back and calculate the other value as well to see if there is a lower value after that. Because we can already see the map and we already know where the <strong>B</strong> point is placed, we know for a fact that the lowest value is actually further away than the <strong>68</strong> value that appeared just now. But if we didn't know where the B point was, we still needed to check that <strong>48</strong> value, to see if the destination point was near that position or not. That is what the AI character will decide in the gameplay it will constantly check the lowest F value.</p>
<div><img height="197" width="394" class=" image-border" src="img/343ff24c-7d89-4093-a9f6-d08258520075.jpg"/></div>
<p>After choosing the new position, we can see that it didn't provide any better opportunities, and we need to keep searching for a better path, which in this case is going to be a point that we have already discovered, but whose outcomes we didn't calculate. Once again, we have the two lowest F values and we will be choosing the lowest H value, that is, <strong>20</strong>.</p>
<div><img height="188" width="376" class=" image-border" src="img/87f40b8b-3f80-416d-9b77-8445089ec64b.jpg"/></div>
<p>After calculating the new possibilities, we notice that we need to choose <strong>54</strong> again to see if the final destination is closer to that point. This is exactly the process that will occur when we program the AI to find the shortest path that it will need to take in order to arrive at the final destination. The calculations need to be solved in real time, and as will start to notice, they can get very complex. This is why it consumes a significant portion of the CPU power, because it is the hardware component designated to this function (calculus).</p>
<p>Now, we will be selecting the number <strong>54</strong>, because it is the lowest number on the map.</p>
<div><img height="183" width="366" class=" image-border" src="img/68864176-58de-44d5-8aab-249035f9b385.jpg"/></div>
<p>If we keep moving down, the values will get higher, which means that we are getting farther away from where we need to be. If we were the AI and didn't know that the final destination is at the top, we would need to check the number <strong>60</strong>, because it is the most promising of them all at the moment. So, let's calculate the outcomes.</p>
<div><img height="183" width="366" class=" image-border" src="img/4e973133-d4ea-46da-97f0-807b6cd896b3.jpg"/></div>
<p>Now, we can see that there are a lot of identical lowest numbers, which are <strong>62</strong>, so we need to explore them all and keep calculating until the character finds the right path. For the purposes of the example we will be moving to every lowest number that we can see on the map now.</p>
<div><img height="180" width="358" class=" image-border" src="img/f08211d8-9543-4434-b006-274a738a8f16.jpg"/></div>
<p>After exploring all the lowest possibilities, we can see that we are getting closer to the final destination. At this point, the lowest value available is <strong>68</strong>, and after that it will be easy to reach the final point.</p>
<div><img height="185" width="370" class=" image-border" src="img/cd6307c8-185a-43a2-a0a6-43bd9afe0a10.jpg"/></div>
<p>Finally, we have arrived at the point <strong>B</strong> destination. This is the visual aspect of A* algorithm, where the darker gray area represents the positions that the computer has visited and the lighter gray area represents the outcome calculations of those areas that we visited.</p>
<p>The computer can calculate the best path in real time, or the developers can also choose to let the AI calculate the best options before exporting the game. So the AI will automatically know which path it needs to follow when the game starts, saving some CPU power.</p>
<p>To explain how this works in the programming language, we will be using pseudo code to demonstrate this example. This way we can understand from start to finish how we can create the search method in any programming language and how we can adapt it ourselves:</p>
<pre>OPEN // the set of nodes to be evaluated 
CLOSED // the set of nodes already evaluated 
 
Add the start node to OPEN 
 
loop 
   current = node in OPEN with the lowest f_cost 
   remove current from OPEN 
   add current to CLOSED 
 
   if current is the target node // path has been found 
         return 
 
   foreach neighbor of the current node 
         if neighbor is not traversable or neighbor is in CLOSED 
               skip to the next neighbor 
 
if new path to neighbor is shorter OR neighbor is not in OPEN 
   set f_cost of neighbor 
   set parent of neighbor to current 
   if neighbor is not in OPEN 
         add neighbor to OPEN </pre>
<p>Let's analyze each line of code that we used to create the example. We have divided the grid map into two different categories: <kbd>OPEN</kbd> and <kbd>CLOSED</kbd>. The <kbd>OPEN</kbd> ones are the squares that we have already explored, represented on the image by the dark gray blocks. While the <kbd>CLOSED</kbd> are the white blocks that we didn't explore yet. This will allow the AI to distinguish between the explored and not explored blocks, going from point to point finding the best path:</p>
<pre>Add the start node to OPEN </pre>
<p>Then we assigned the first block that is considered <kbd>OPEN</kbd>; this will set the starting point and it will automatically start calculating the best options from that position:</p>
<pre>loop 
   current = node in OPEN with the lowest f_cost 
   remove current from OPEN 
   add current to CLOSED </pre>
<p>After that, we need to create a loop, and inside our loop we have a temporary variable called <kbd>current</kbd>; this is equal to the node in the <kbd>OPEN</kbd> list that has the lowest F cost. Then it will be removed from the <kbd>OPEN</kbd> list and added to the <kbd>CLOSED</kbd> list:</p>
<pre>if current is the target node // path has been found 
         return </pre>
<p>Then, if the current node is the target node, the code assumes that the final destination has been explored and we can just exit out of the loop:</p>
<pre>foreach neighbor of the current node 
         if neighbor is not traversable or neighbor is in CLOSED 
               skip to the next neighbor </pre>
<p>Otherwise, we must go through each of the <kbd>neighbor</kbd> nodes of the current node. If it is not traversable, meaning that we cannot pass that position or if it was previously explored and is on the <kbd>CLOSED</kbd> list, the code can skip to the next neighbor. This part sets where it is possible to move and also tells the AI to not take into consideration positions that were previously explored:</p>
<pre>if new path to neighbor is shorter OR neighbor is not in OPEN 
   set f_cost of neighbor 
   set parent of neighbor to current 
   if neighbor is not in OPEN 
         add neighbor to OPEN </pre>
<p>If it is not the case, then we can move on and check a couple of things. If the new path to the <kbd>neighbor</kbd> is shorter than the old path or if the <kbd>neighbor</kbd> is not on the <kbd>OPEN</kbd> list, then we set the <kbd>f_cost</kbd> of the <kbd>neighbor</kbd> by calculating the <kbd>g_cost</kbd> and the <kbd>h_cost</kbd>. We see the new possible blocks have children from the current block, so we can trace the steps that are being taken. And finally, if the <kbd>neighbor</kbd> is not on the <kbd>OPEN</kbd> list, we can add it.</p>
<p>Looping this, the code will constantly be searching for the best options and moving towards the closest values until it arrives at the target node value.</p>
<div><img height="275" width="489" class=" image-border" src="img/b87cd73d-436e-405a-9656-47babb924f1f.jpg"/></div>
<p>The same principles that we have just learned can be found in pedestrians of the <em>GTA 5</em>. Many other games use this method, obviously, but we wanted to use this game as an example of the two pathfinding systems that can be found in most games. If we applied this system to AI police in order to search and find the player, we would have more or less the same results that can be seen in the actual gameplay.</p>
<p>It takes more than just searching for the final destination, and this is just a small portion of the final code, but we would see an AI character avoiding walls and getting closer to the player position, step by step. On top of that, it would be necessary to add more content to the AI code, letting the character know what to do in multiple situations that can occur, such as having water in the middle of the path, stairs, moving cars, and many others.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating grid nodes</h1>
                
            
            
                
<p>Now we are going to implement what we have learned so far into a practical exercise. Let's start by creating or importing our scene into the game editor.</p>
<div><img height="251" width="446" class=" image-border" src="img/4d89e5ee-c238-4908-a358-e69832b11670.png"/></div>
<p>For this example, we are going to use buildings as non-walkable objects, but it can be anything that we choose, then we need to separate the objects that we just imported from the ground. To do this, we are going to assign them to a separate layer, and we are going to call it <strong>unwalkable</strong>.</p>
<p>Then we can start creating our first class of the game, and we are going to start from the <kbd>node</kbd> class:</p>
<pre>public bool walkable;<br/> public Vector3 worldPosition; public Node(bool _walkable, Vector3<br/>         _worldPos, int _gridX, int _gridY) {<br/>         walkable = _walkable;<br/>         worldPosition = _worldPos; </pre>
<p>We have seen that the nodes have two different states, either they are walkable or non-walkable, so we can start by creating a Boolean called <kbd>walkable</kbd>. Then we need to know in what point in the world the node represents, so we create a <kbd>Vector 3</kbd> for the <kbd>worldPosition</kbd>. Now, we need some way to assign these values when we create a node, so we create the <kbd>Node</kbd> variable that will contain all the important information regarding the nodes.</p>
<p>After creating the essential part of this class, we can move on to the <kbd>grid</kbd> class:</p>
<pre class="mce-root"> Node[,] grid;  <br/> public LayerMask unwalkableMask;<br/> public Vector2 gridWorldSize;<br/> publicfloatnodeRadius;<br/> void OnDrawGizmos() 
 {<br/>         Gizmos.DrawWireCube(transform.position,new<br/>    Vector3(gridWorldSize.x,1,gridWorldSize.y));  
 } </pre>
<p>First of all, we need a two-dimensional array of nodes that represents our grid, so let's create a two-dimensional array of nodes, and we can call it <kbd>grid</kbd>. Then we can create a <kbd>Vector2</kbd> that will define the area in world coordinates that this grid covers and call it <kbd>gridWorldSize</kbd>. We also need a <kbd>float</kbd> variable to define how much space each individual node covers, which in this class is called <kbd>nodeRadius</kbd>. Then we need to create a <kbd>LayerMask</kbd> to define the area that is non-walkable and give it the name <kbd>unwalkableMask</kbd>.</p>
<p>In order to visualize the grid that we just created in our game editor, we decided to use <kbd>OnDrawGizmos</kbd> method; using this is useful but not mandatory:</p>
<pre>     public LayerMask unwalkableMask;<br/>     public Vector2 gridWorldSize;<br/>     public float nodeRadius;<br/>     Node[,] grid;<br/><br/>     float nodeDiameter;<br/>     int gridSizeX, gridSizeY;<br/><br/>     void Start() {<br/>         nodeDiameter = nodeRadius*2;<br/>         gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);<br/>         gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);<br/>         CreateGrid();<br/>     }<br/><br/>     void CreateGrid(){<br/>         grid = new Node[gridSizeX,gridSizeY];<br/>         Vector3 worldBottomLeft = transform.position - Vector3.right *<br/>     gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;<br/>     } </pre>
<p>Let's create a <kbd>Start</kbd> method, and we are going to add some basic calculations. The main thing that we need to figure out is how many nodes can we fit in to our grid. We start by creating a new <kbd>float</kbd> variable called <kbd>nodeDiameter</kbd> and new <kbd>int</kbd> variables called <kbd>gridSizeX</kbd> and <kbd>gridSizeY</kbd>. Then, inside of our <kbd>Start</kbd> method we are going to add the value of the <kbd>nodeDiameter</kbd> that is equal to <kbd>nodeRadius*2</kbd>. <kbd>gridSizeX</kbd> is equal to <kbd>gridWorldSize.x/nodeDiameter</kbd>,and this will tell us how many nodes can fit in the <kbd>gridWorldSize.x</kbd>. Then we will be rounding the number to fit into an integer number, so we will be using <kbd>Mathf.RoundToInt</kbd> to make this possible. After creating the calculus for the <kbd>x</kbd> axis, we can duplicate the same code and change it to make it work for the <kbd>y</kbd> axis. To finalize our <kbd>Start</kbd> method, we create a new function, we are going to call <kbd>CreateGrid()</kbd>:</p>
<pre> public LayerMask unwalkableMask;<br/> public Vector2 gridWorldSize;<br/> public float nodeRadius;<br/> Node[,] grid;<br/><br/> float nodeDiameter;<br/> int gridSizeX, gridSizeY;<br/><br/> void Start(){<br/>         nodeDiameter = nodeRadius*2;<br/>         gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);<br/>         gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);<br/>         CreateGrid();<br/> } 
 
 void CreateGrid() 
 {<br/>         grid = new Node[gridSizeX,gridSizeY];<br/>         Vector3 worldBottomLeft = transform.position - Vector3.right *<br/>         gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;<br/><br/>         for (int x = 0; x &lt; gridSizeX; x ++) {<br/>             for (int y = 0; y &lt; gridSizeY; y ++) {<br/>                 Vector3 worldPoint = worldBottomLeft + Vector3.right *<br/>                 (x * nodeDiameter + nodeRadius) + Vector3.forward * (y<br/>                 * nodeDiameter + nodeRadius);<br/>                 bool walkable = !(Physics.CheckSphere(worldPoint,<br/>                                   nodeRadius,unwalkableMask));<br/>                 grid[x,y] = new Node(walkable,worldPoint);<br/>             }<br/>         } 
 }  </pre>
<p>Here we add the value of the <kbd>grid</kbd> variable, <kbd>grid = new Node[gridSizeX, gridSizeY];</kbd>. Now we need to add collision detection that will establish the walkable and non-walkable areas of the map. To do this, we create a loop that can be seen in the code demonstrated previously. We simply added a new <kbd>Vector3</kbd> variable to get the bottom left corner of the map, which is called <kbd>worldBottomLeft</kbd>. Then we assigned the collision detection, which will search for any objects that are colliding with the walkable area by using <kbd>Physics.Check</kbd>:</p>
<pre> void OnDrawGizmos() {<br/>         Gizmos.DrawWireCube(transform.position,new<br/>         Vector3(gridWorldSize.x,1,gridWorldSize.y));<br/><br/><br/>         if (grid != null) {<br/>             foreach (Node n in grid) {<br/>                 Gizmos.color = (n.walkable)?Color.white:Color.red;<br/>                 Gizmos.DrawCube(n.worldPosition, Vector3.one *<br/>                 (nodeDiameter-.1f));<br/>             }<br/>         }<br/> } </pre>
<p>Before testing it out, we need to update our <kbd>OnDrawGizmos</kbd> function, so that we can see the grid on top of the map. To make the grid visible, we assigned the colors red and white and the form of the cubes by using the <kbd>nodeDiameter</kbd> value to set the dimension of each cube. If the node is walkable, the color will be set to white; otherwise, it will be set to red. Now we can test it out:</p>
<div><img height="259" width="344" class=" image-border" src="img/cef43480-0339-4096-9e07-cbd490f9ba37.png"/></div>
<p>The results are wonderful; now we have a grid that auto-analyses the map and indicates the walkable and non-walkable areas. With this part completed, the rest will be easier to implement. Before moving on to the next part, we need to add a method that will tell our character which node it is standing in. In our code, we will be adding a function called <kbd>NodeFromWorldPoint</kbd> that will make this possible:</p>
<pre> public LayerMask unwalkableMask;<br/> public Vector2 gridWorldSize;<br/> public float nodeRadius;<br/> Node[,] grid;<br/><br/> float nodeDiameter;<br/> int gridSizeX, gridSizeY;<br/><br/> void Start(){<br/>         nodeDiameter = nodeRadius*2;<br/>         gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);<br/>         gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);<br/>         CreateGrid();<br/> } 
 
 void CreateGrid() 
 {<br/>         grid = new Node[gridSizeX,gridSizeY];<br/>         Vector3 worldBottomLeft = transform.position - Vector3.right *<br/>               gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;<br/><br/>         for (int x = 0; x &lt; gridSizeX; x ++) {<br/>             for (int y = 0; y &lt; gridSizeY; y ++) {<br/>                 Vector3 worldPoint = worldBottomLeft + Vector3.right *<br/>                 (x * nodeDiameter + nodeRadius) + Vector3.forward * (y<br/>                 * nodeDiameter + nodeRadius);<br/>                 bool walkable = !(Physics.CheckSphere(worldPoint,<br/>                                   nodeRadius,unwalkableMask));<br/>                 grid[x,y] = new Node(walkable,worldPoint);<br/>             }<br/>         } 
 }  <br/> public Node NodeFromWorldPoint(Vector3 worldPosition) {<br/>         float percentX = (worldPosition.x + gridWorldSize.x/2) /<br/>         gridWorldSize.x;<br/>         float percentY = (worldPosition.z + gridWorldSize.y/2) /<br/>         gridWorldSize.y;<br/>         percentX = Mathf.Clamp01(percentX);<br/>         percentY = Mathf.Clamp01(percentY);<br/><br/>         int x = Mathf.RoundToInt((gridSizeX-1) * percentX);<br/>         int y = Mathf.RoundToInt((gridSizeY-1) * percentY);<br/>         return grid[x,y];<br/>     } void OnDrawGizmos() {<br/>         Gizmos.DrawWireCube(transform.position,new<br/>         Vector3(gridWorldSize.x,1,gridWorldSize.y));<br/><br/><br/>         if (grid != null) {<br/>             foreach (Node n in grid) {<br/>                 Gizmos.color = (n.walkable)?Color.white:Color.red;<br/>                 Gizmos.DrawCube(n.worldPosition, Vector3.one *<br/>                (nodeDiameter-.1f));<br/>             }<br/>         }<br/>     } </pre>
<p>And we have finally completed the first part of our example. We have a code that can work in any scene we just need to define the scale of the map in which we want the code to search for the walkable and non-walkable areas, and the dimensions of each node in case we want to change the precision of the pathfinding remember that if we increase the number of nodes on the map, more CPU power will be required to calculate the pathfinding system).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pathfinding implementation</h1>
                
            
            
                
<p class="mce-root">The next step is to set the character to search for the final destination that we want. Let's start by creating a new class, which we will call <strong>pathfinding</strong>. This class will manage the search for the best path in order to reach the final destination. It will calculate in real time the shortest path that the character needs to follow and it will be updated every second, so if the final destination is moving, it will keep following and recalculating the best path.</p>
<div><img height="196" width="347" class=" image-border" src="img/7ebdfdaf-0ab4-4e0c-b6c8-4d411df3b50c.png"/></div>
<p>We start by adding the AI character into our game editor that will eventually search for another character of the game. For test purposes, we will simply add some basic functions to our character that will let him move around the map, but we can also use a simple cube to test whether the pathfinding system is working.</p>
<p>After importing our character into the game, we can start creating the class that will be assigned to it:</p>
<pre>Grid grid;<br/><br/>void Awake(){<br/>      requestManager = GetComponent&lt;PathRequestManager&gt;();<br/>      grid = GetComponent&lt;Grid&gt;();<br/> } 
 
void FindPath(Vector3 startPos, Vector3 targetPos) 
{ 
Node startNode = grid.NodeFromWorldPoint(startPos);<br/> Node targetNode = grid.NodeFromWorldPoint(targetPos);  
} 
 </pre>
<p>We start by creating a function called <kbd>FindPath</kbd> that will store all the necessary values to calculate the distance between the start position and the target position. Then we add a <kbd>Grid</kbd> variable that will have the same value as the <kbd>grid</kbd> that we have previously created. Then we used the <kbd>Awake</kbd> function to access to the <kbd>grid</kbd> values:</p>
<pre>void FindPath(Vector3 startPos, Vector3 targetPos) 
{ 
Node startNode = grid.NodeFromWorldPoint(startPos); 
Node targetNode = grid.NodeFromWorldPoint(targetPos); 
 
List&lt;Node&gt; openSet = new List&lt;Node&gt;(); 
HashSet&lt;Node&gt; closedSet = new HashSet&lt;Node&gt;(); 
openSet.Add(startNode); 
} </pre>
<p>Then we need to create a list that will contain all of the nodes present in the game, as we have demonstrated before. One list contains all the <kbd>OPEN</kbd> nodes, and another one will contain all the <kbd>CLOSED</kbd> nodes:</p>
<pre>public bool walkable; 
public Vector3 worldPosition; 
 
public int gCost; 
public int hCost; 
public Node parent; 
    
public Node(bool _walkable, Vector3 _worldPos, int _gridX, int _gridY) 
{ 
         walkable = _walkable; 
         worldPosition = _worldPos; 
} 
 
public int fCost 
{ 
         get { 
               return gCost + hCost; 
         } 
} </pre>
<p>Now we have opened the <kbd>Node</kbd> class, and we added new variables called <kbd>gCost</kbd> and <kbd>hCost</kbd>. The idea is that this class calculates the shortest path value, and as we saw previously, in order to get the <kbd>fCost</kbd> that represents the shortest path, we need to sum the values of the <kbd>g</kbd> and <kbd>h</kbd> nodes.</p>
<div><em>f(n)=g(n)+h(n).</em></div>
<p>Once the <kbd>Node</kbd> class is edited, we can go back to our pathfinding class and continue implementing the lines of code that will make our AI character search for the optimal path:</p>
<pre>Grid grid; 
 
void Awake() 
{ 
         grid = GetComponent&lt;Grid&gt; (); 
} 
 
void FindPath(Vector3 startPos, Vector3 targetPos) 
{ 
   Node startNode = grid.NodeFromWorldPoint(startPos); 
   Node targetNode = grid.NodeFromWorldPoint(targetPos); 
 
   List&lt;Node&gt; openSet = new List&lt;Node&gt;(); 
   HashSet&lt;Node&gt; closedSet = new HashSet&lt;Node&gt;(); 
   openSet.Add(startNode); 
 
   while (openSet.Count &gt; 0) 
{ 
         Node node = openSet[0]; 
         for (int i = 1; i &lt; openSet.Count; i ++) { 
         if (openSet[i].fCost &lt; node.fCost || openSet[i].fCost ==<br/>         node.fCost) { 
         if (openSet[i].hCost &lt; node.hCost) 
         node = openSet[i]; 
   } 
} </pre>
<p>Back to our pathfinding class; we need to define the current node that the character is positioned in. To make this happen, we added <kbd>Node currentNode = openSet[0]</kbd>; this will set 0 as the default node. Then we create the loop that will compare the <kbd>fCost</kbd> of the possible nodes to choose which one is the best option, <kbd>openSet[i].fCost &lt; node.fCost || openSet[i].fCost == node.fCost</kbd>. This is the code that we have used to achieve the desirable results for this example, but it can still be optimized if necessary:</p>
<pre>Grid grid; 
void Awake() 
{ 
         grid = GetComponent&lt;Grid&gt; (); 
} 
 
void FindPath(Vector3 startPos, Vector3 targetPos) 
{ 
   Node startNode = grid.NodeFromWorldPoint(startPos); 
   Node targetNode = grid.NodeFromWorldPoint(targetPos); 
 
   List&lt;Node&gt; openSet = new List&lt;Node&gt;(); 
   HashSet&lt;Node&gt; closedSet = new HashSet&lt;Node&gt;(); 
   openSet.Add(startNode); 
 
   while (openSet.Count &gt; 0) 
{ 
         Node node = openSet[0]; 
         for (int i = 1; i &lt; openSet.Count; i ++) 
{ 
         if (openSet[i].fCost &lt; node.fCost || openSet[i].fCost ==<br/>         node.fCost){ 
               if (openSet[i].hCost &lt; node.hCost) 
         node = openSet[i]; 
           } 
         } 
 
         openSet.Remove(node); 
         closedSet.Add(node); 
 
         if (node == targetNode) { 
               RetracePath(startNode,targetNode); 
               return; 
         } </pre>
<p>Continuing our loop, we have now defined when the current node is set to <kbd>OPEN</kbd> or <kbd>CLOSED</kbd> and established that if the current node value is equal to the target node value, it means that the character already has arrived at the final destination <kbd>if (currentNode == targetNode)</kbd>:</p>
<pre>public List&lt;Node&gt; GetNeighbors(Node node) 
{ 
   List&lt;Node&gt; neighbors = new List&lt;Node&gt;(); 
 
   for (int x = -1; x &lt;= 1; x++) { 
         for (int y = -1; y &lt;= 1; y++) { 
               if (x == 0 &amp;&amp; y == 0) 
                     continue; 
 
               int checkX = node.gridX + x; 
               int checkY = node.gridY + y; 
 
               if (checkX &gt;= 0 &amp;&amp; checkX &lt; gridSizeX &amp;&amp; checkY &gt;= 0 &amp;&amp;<br/>               checkY &lt; gridSizeY) { 
                     neighbors.Add(grid[checkX,checkY]); 
                     } 
               } 
         } 
   } </pre>
<p>Now we need to loop through each of the <kbd>neighbor</kbd> nodes of the <kbd>current node</kbd>. To do this, we have decided to add this to our grid code, so we need to open the <kbd>grid</kbd> class that we created at the beginning of the example and add the <kbd>List</kbd> function demonstrated previously. Then we will be adding the necessary values to the <kbd>Node</kbd> class (<kbd>gridX</kbd> and <kbd>gridY</kbd>):</p>
<pre>public bool walkable; 
public Vector3 worldPosition; 
public int gridX; 
public int gridY; 
 
public int gCost; 
public int hCost; 
public Node parent; 
    
public Node(bool _walkable, Vector3 _worldPos, int _gridX, int _gridY) 
{ 
   walkable = _walkable; 
   worldPosition = _worldPos; 
   gridX = _gridX; 
   gridY = _gridY; 
} 
 
public int fCost 
{ 
   get 
{ 
         return gCost + hCost; 
   } 
} 
 </pre>
<p>Here, we have added the final content for the <kbd>Node</kbd> class that contains the <kbd>gridX</kbd> and <kbd>gridY</kbd> values that will be used by the <kbd>grid</kbd> code. This is the final look at the <kbd>Node</kbd> class. Now, we can move on to the pathfinding class again:</p>
<pre>foreach (Node neighbor in grid.GetNeighbors(node)) { 
if (!neighbor.walkable || closedSet.Contains(neighbor)) 
{ 
               continue; 
} 
} </pre>
<p>Here, we have added a <kbd>foreach</kbd> loop that will loop through the neighbors to check if they are walkable or non-walkable.</p>
<p>To better understand the next step that we are going to take, there will be some example diagrams of what we want to achieve to complete the pathfinding system:</p>
<div><img height="103" width="188" class=" image-border" src="img/7eb863af-bbac-4bfc-b32b-507673cc5503.jpg"/></div>
<p>We first need to count along the <strong>X</strong> axis to know how many nodes away we are from the final position on the <strong>X</strong> axis, and then we count along the <strong>Y</strong> axis to find out how many nodes away we are from the final position on the <strong>Y</strong> axis:</p>
<div><img height="107" width="196" class=" image-border" src="img/81d50822-c277-45cf-8f96-07afe7230459.jpg"/></div>
<p>In this example, we can see that in order to get to the <strong>B</strong> position we need to move upwards two points. Because we are always searching for the shortest path, at the same time we are going upwards, we move on the <strong>X</strong> axis:</p>
<div><img height="117" width="216" class=" image-border" src="img/1f5e29a8-8561-430b-833d-45e81bfc6b5d.jpg"/></div>
<p>To calculate how many either vertical or horizontal moves are necessary to reach the <strong>B</strong> position, we just subtract the lower number from the higher number. For example, before going on a straight line to the <strong>B</strong> position, it is necessary to calculate <em>5-2 = 3</em>, which gives us how many horizontal moves we need to reach the final destination.</p>
<p>Now, we can get back to the pathfinding code and add the equation that we have just learned:</p>
<pre>int GetDistance(Node nodeA, Node nodeB) 
{ 
   int dstX = Mathf.Abs(nodeA.gridX - nodeB.gridX); 
   int dstY = Mathf.Abs(nodeA.gridY - nodeB.gridY); 
 
   if (dstX &gt; dstY) 
         return 14*dstY + 10* (dstX-dstY); 
   return 14*dstX + 10 * (dstY-dstX); 
} </pre>
<p>Here, we just added the lines of code that will tell us how many horizontal and vertical steps the AI needs to take in order to arrive at the target destination. Now, if we look back at the pseudo code that we created at the very beginning of this chapter to check what is left to create, we can see that we have followed the same structure and that we are almost finished. The pseudo code is as follows:</p>
<pre>OPEN // the set of nodes to be evaluated 
CLOSED // the set of nodes already evaluated 
 
Add the start node to OPEN 
 
loop 
   current = node in OPEN with the lowest f_cost 
   remove current from OPEN 
   add current to CLOSED 
 
   if current is the target node // path has been found 
         return 
 
   foreach neighbor of the current node 
         if neighbor is not traversable or neighbor is in CLOSED 
               skip to the next neighbor 
 
if new path to neighbor is shorter OR neighbor is not in OPEN 
   set f_cost of neighbor 
   set parent of neighbor to current 
   if neighbor is not in OPEN 
         add neighbor to OPEN </pre>
<p>So, let's keep adding more important content into our code and keep moving towards the conclusion of the pathfinding class.</p>
<p>We need to set the neighbor's <kbd>f_cost</kbd> and as we already know, to calculate this value, we need to use the <kbd>g_Cost</kbd> and <kbd>h_Cost</kbd> of the neighbor node:</p>
<pre>foreach (Node neighbor in grid.GetNeighbors(node)) 
{ 
   if (!neighbor.walkable || closedSet.Contains(neighbor)) { 
         continue; 
   } 
 
   int newCostToNeighbor = node.gCost + GetDistance(node, neighbor); 
   if (newCostToNeighbor &lt; neighbor.gCost ||<br/>   !openSet.Contains(neighbor)) { 
         neighbor.gCost = newCostToNeighbor; 
         neighbor.hCost = GetDistance(neighbor, targetNode); 
         neighbor.parent = node; 
   } </pre>
<p>In the pathfinding class we have added the following code, which will calculate the neighbor nodes to check for their <kbd>f_cost</kbd>:</p>
<pre>void RetracePath(Node startNode, Node endNode) { 
         List&lt;Node&gt; path = new List&lt;Node&gt;(); 
         Node currentNode = endNode; 
 
         while (currentNode != startNode) { 
               path.Add(currentNode); 
               currentNode = currentNode.parent; 
         } 
         path.Reverse(); 
 
         grid.path = path; 
} </pre>
<p>Before exiting from the loop, we will be calling a function called <kbd>RetracePath</kbd>,and we can give it <kbd>startNode</kbd> and <kbd>targetNode</kbd>. Then we have to create that new function with the same name and assign a list of the nodes that we have already explored. In order to visualize the pathfinding to see if it is working properly or not, we also have a path that we will be creating in the <kbd>grid</kbd> class:</p>
<pre>public List&lt;Node&gt; path; 
void OnDrawGizmos() 
{ 
Gizmos.DrawWireCube(transform.position,new Vector3(gridWorldSize.x,1,gridWorldSize.y)); 
 
         if (grid != null) { 
               foreach (Node n in grid) { 
                     Gizmos.color = (n.walkable)?Color.white:Color.red; 
                     if (path != null) 
                           if (path.Contains(n)) 
                                 Gizmos.color = Color.black; 
                     Gizmos.DrawCube(n.worldPosition, Vector3.one * (nodeDiameter-.1f)); 
               } 
   } 
} </pre>
<p>This section of the <kbd>grid</kbd> class was updated, now containing the <kbd>List</kbd>, <kbd>path</kbd>, and a new gizmo that will show on the editor view, the path between the AI position and the target position:</p>
<pre>public Transform seeker, target; 
 
Grid grid; 
 
void Awake() 
{ 
   grid = GetComponent&lt;Grid&gt; (); 
} 
 
void Update() 
{ 
   FindPath (seeker.position, target.position); 
} </pre>
<p>And finally, to conclude our example, we add a <kbd>void Update()</kbd> into our pathfinding class that will make the AI constantly search for the target position.</p>
<p>Now we can move on to our game editor and assign the code pathfinding that we have created to the grid. Then we simply assign the AI character and the target position that we want:</p>
<div><img height="239" width="342" class=" image-border" src="img/69ac8284-7d67-4bcf-9f86-3198c61abdee.png"/></div>
<p>If we test the pathfinding system, we can see that it is working perfectly. In the preceding screenshot, the top left point is the AI character's position, and in the bottom right is the target destination. We can see that the character planned the shortest path and one that avoids colliding with the buildings:</p>
<div><img height="263" width="301" class=" image-border" src="img/1872a4d1-4477-4263-b3ac-60ec6805bb43.png"/></div>
<p class="mce-root">Then we have disabled the mesh from the buildings to have a better look at the walkable and unwalkable areas of the map. We can see that the character only chooses the walkable areas and avoids any obstacles in its way. It is complicated to demonstrate it using still images, but if we change the target location in real time, we can see the pathfinding adjusting the route that the character needs to take, and it always chooses the shortest path.</p>
<div><img height="313" width="557" class=" image-border" src="img/7e9a26eb-f9f9-409f-96fe-d41bd0f9b3ed.jpg"/></div>
<p>The advanced pathfinding system that we have just created can be found in many popular games that everybody loves. Now that we have learned how to create a complex pathfinding system, we are able to re-create some parts of the most advanced AI characters of modern games such as GTA or Assassins Creed. Talking about Assassins Creed, it will be our next game, reference for the next chapter because its AI characters link perfectly between A* pathfinding and realistic crowd interactions, as we can see in the preceding screenshot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we revisited how to create point-to-point movement, but instead of using a simple method, we have studied how huge and successful game studios manage to solve one of the most complicated features of a AI, pathfinding. Here, we have learned how to use theta algorithms to recreate an human feature that helps us search and move in the right direction in order to arrive at the desired destination.</p>
<p>In the next chapter, we will be talking about realistic crowd interactions, a very important aspect when trying to make an AI character as realistic as possible. We will be studying different approaches used in different types of game, and also we will be looking at how humans and animals interact in their environments and how we can use that in our AI code.</p>


            

            
        
    </body></html>