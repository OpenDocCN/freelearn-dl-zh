<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making the First Steps in the World of AI</h1>
                </header>
            
            <article>
                
<p><em>From the bronze giant Talos, to Symbolic Systems and Neural Networks: how AI has been shaped and used in video games.</em></p>
<p>Welcome, reader, to the beginning of our journey in Artificial Intelligence, or AI for short. Have you ever wondered about how those hard-working peons in <em>Warcraft</em> explore complicated maps? Or, how those perky ghosts in <em>Pac-Man</em> can get you wherever you are? Or perhaps how your opponents in <em>Final Fantasy</em> optimize their attacks to slaughter your team?</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/68ed6eec-3c27-47e4-bbf6-7d203106baa5.png" style="width:44.67em;height:25.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A screenshot from Final Fantasy XV [Square Enix, 2016] during a battle.</div>
<p>Then you've come to the right place!</p>
<p>In this chapter, we will explore the prerequisites to becoming an AI game developer and how AI is used in the game development pipeline. Then, we will take a look at the history of AI in general and in video games, and learn how the conjunctive effort of many brilliant minds built AI as we know it today. Afterwards, we will discuss the AI Framework underneath the Unreal Engine, since this book will focus on Unreal.</p>
<p>Finally, we will plan our journey and get a general overview of the topics that the different chapters in this book deal with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Before starting...</h1>
                </header>
            
            <article>
                
<p>... I'd like to reply to some questions that some of you might already have.</p>
<p><strong>Does this book take into account Blueprint or C++?</strong></p>
<p>This book will explain both, so don't worry.</p>
<p>If you don't know C++, you can follow along with the Blueprint part of this book, and if you so wish, you can try the C++ one.</p>
<p>If, on the other hand, you are a programmer that prefers C++, then don't worry! This book will explain how to deal with AI in Unreal using C++.</p>
<p><strong>There are so many books around about AI, why should I choose this one?</strong></p>
<p>Different books explain different aspects of AI, and often they are not mutually exclusive, but rather they complement each other.</p>
<p>However, the major point of interest of this book is that it is a good compromise between the theory of the different AI systems that are present in Unreal and practical applications, since the whole book is full of concrete examples.</p>
<p><strong>Does this book provide a test project/materials to work on?</strong></p>
<p>Absolutely, yes. You will be able to download the content for this book from the following link: <a href="http://hog.red/AIBook2019ProjectFiles">http://hog.red/AIBook2019ProjectFiles</a> (the link is case-sensitive).</p>
<p class="mce-root"/>
<p><strong>I am already using the Unreal Engine for Artificial Intelligence, is this book good for me?</strong></p>
<p>This all depends on your level of knowledge. In fact, in the first part of this book, we will talk mainly about the AI framework that's built into the Unreal Engine and how to use it. This is probably the part you are more familiar with if you have had some experience with Unreal for AI. However, this book will dive deep in these topics, that even an expert could find some useful tips. The second part, instead, will discuss some debugging methods for Game AI and will also explain how to extend them (mainly with C++). Feel free to have a look at the outline, and decide if this book suits you.</p>
<p><strong>I am already using another game engine, is this book still good for me?</strong></p>
<p>Well, as much as I'd like to say that this is a general book about AI, it isn't—at least not completely. Although the main focus will still be toward the main concepts of AI, we will look at implementing them in Unreal. However, this book will heavily rely on the built-in AI framework in Unreal. Thus, I encourage you to read more generalized books about AI to get a better understanding. On the other hand, you can always try. Maybe, by understanding some concepts here, other books will be easier to read and you will be able to transfer this knowledge into the game engine of your choice.</p>
<p><strong>I'm a student/teacher, is this book suitable for teaching in class?</strong></p>
<p>Absolutely, yes. I know how important it is to find good resources when teaching a class, and I'm writing this book with this intention in mind. As a result, regardless of whether you are a student or a teacher, you will find a section at the end of each chapter with some exercises that you can improve your skills this (or propose them to your students, if you are a teacher). Also, you can find some more integrative material here: <a href="http://hog.red/AIBook2019LearningMaterial">http://hog.red/AIBook2019LearningMaterial</a> (the link is case-sensitive).</p>
<p><strong>Is this book going to cover everything, everything, and everything about AI in Unreal and all its systems?</strong></p>
<p>Well, despite my best efforts to describe each of the systems in great detail, covering everything is an impossible task, due also to the complexity of such big engine. However, I'm confident to say that this book covers most of the aspects related to each AI system within the Unreal Engine, including how to extend the built-in systems and how to efficiently perform debugging. Thus, I can certainly say that this book is very comprehensive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>Since this book is targeted at people who are getting started with AI in game development, I will not assume any prior/background knowledge in AI. However, please take the following into account:</p>
<ul>
<li><em>Blueprint users</em>: You should be familiar with Blueprint programming, and know how a Blueprint graph works in general.</li>
<li><em>C++ users</em>: You should be familiar with programming, especially with the C family languages (such as C, C#, C++, or even Java), and in particular with C++, since it's the language that Unreal Engine uses. Being familiar<span> with the Unreal Engine C++ API is a great bonus, although not strictly required. So, even if you are not a master, don't worry—follow along and you will learn.</span></li>
</ul>
<p>Also, it would be great if you had some knowledge about vector math and physical kinematic principles <span>–</span> at least the ones commonly used in video games. Either way, <span>in case you are rusty on those, don't worry too much, since it is not required for</span> this book; however, it is <em>nice to have</em> if you're looking for a job as an AI Developer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and preparing the software</h1>
                </header>
            
            <article>
                
<p>Before you continue reading, let's install the software we need. In particular, we will need Unreal Engine and Visual Studio.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unreal Engine</h1>
                </header>
            
            <article>
                
<p>Let's talk about Unreal Engine. After all, this is a book about how to develop game AI within this wonderful game engine.</p>
<p><em>Unreal Engine</em> is a game engine that was developed by <em>Epic Games</em>. It was first released in 1998, and nowadays it is one of the most used (open) game engines (alongside Unity) due to its powerful features. The following screenshot shows the main interface of Unreal Engine:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9c8d5e35-5810-4640-8cd6-75071136d49b.png"/></p>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Screenshot of the main interface of Unreal Engine</div>
<p>We need to have the latest version of Unreal Engine installed. You can find it by visiting <a href="https://www.unrealengine.com/en-US/what-is-unreal-engine-4">https://www.unrealengine.com/en-US/what-is-unreal-engine-4</a> . Unless you took Unreal Engine from the source code (<a href="https://docs.unrealengine.com/en-us/Programming/Development/BuildingUnrealEngine">https://docs.unrealengine.com/en-us/Programming/Development/BuildingUnrealEngine</a>), you will have the <em>Epic Launcher</em> installed. If you are a Blueprint user, and do not intend to use C++, then this is enough for you. If, on the other hand, you will be using C++, you will need to perform a couple of extra steps.</p>
<p>When installing the Engine, you will need to check some options (if you are using C++). In particular, we need to check that we have both "<strong><em>Engine Source</em></strong>" and "<strong><em>Editor symbols for debugging</em></strong>", as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1fbaf220-3e90-4a85-a4b9-43bade811eeb.png" style="width:31.33em;height:25.83em;"/></p>
<p>By doing so, we will be able to navigate through the C++ Engine Source and also have a full stack of calls in the case of a crash (so you will know what went wrong). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio</h1>
                </header>
            
            <article>
                
<p>You won't need this if you are using Blueprint—<span>this is for</span> C++ users only. </p>
<p>In fact, we will need an IDE to edit our C++ code. We are going to use <em>Visual Studio</em>, since it's well-integrated with Unreal. You will be able to download <em>Visual Studio Community Edition</em> for free through the official website, <a href="https://www.visualstudio.com">https://www.visualstudio.com</a>, or from <a href="https://visualstudio.microsoft.com/vs/">https://visualstudio.microsoft.com/vs/</a>.</p>
<p>You may also find this short guide on how to set up <em>Visual Studio </em>so that it works with Unreal Engine useful: <a href="https://docs.unrealengine.com/en-us/Programming/Development/VisualStudioSetup">https://docs.unrealengine.com/en-us/Programming/Development/VisualStudioSetup</a>.</p>
<p>Once you have everything installed and ready to go, we can continue with the rest of this chapter.</p>
<div class="packt_infobox">If you are a <em>MacOS</em> user, there is a version of <em>Visual Studio</em> for <em>MacOS</em>. You can use that one. Alternatively, you might be able to use <em>XCode</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Becoming an AI Game Developer</h1>
                </header>
            
            <article>
                
<p>Ever dreamed of becoming an AI Game Developer? Or maybe just be able to write "<em>intelligent</em>" programs? Then this book is for you!</p>
<p>However, I need to advise you that this is no easy task.</p>
<p>Game development and design are some of the most extensive works of art around. This is due to a large amount of expertise that is required to bring a game to life. You can get an idea of this by just looking at the final credits in a game. They are endless and contain names of people who have dedicated a lot of their time to the game in various roles. AI development is a central part of this big process, and it requires years to master it, like most things in life. As such, iteration is key, and a great place to get started in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What it means to be an AI Game Developer</h1>
                </header>
            
            <article>
                
<p>First of all, you will need to master maths, physics, and coding. Also, you will mostly probably work in an interdisciplinary team, which includes artists, designers, and programmers. In fact, you will probably work with existing proprietary software technology, and it's required that you are able to build new technology to fulfill the project's technical requirements. You will be asked to research coding techniques and algorithms so that you keep yourself up to date on technological developments and advancements in the game industry and to identify technical and developmental risks/obstacles and generate solutions to overcome identified risks.</p>
<p>On the other hand, you will be able to give life to characters and entities in video games. After all the frustrations that you might go through, you will be the first one to assist, or better, generate an intelligent behavior in games. It takes time and is quite challenging, so don't be too hard on yourself in the early stages. Once you achieve some real AI in your game that can think on its own, this is an achievement worthy of rewarding yourself for.</p>
<p>For beginners in AI, this book will help you set the first stones toward that goal. For experts, this book will provide a useful guide to refresh the different AI systems in Unreal, and explore in-depth features that might help you in your work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AI in the game development process</h1>
                </header>
            
            <article>
                
<p>The game development pipeline might vary a lot, depending on which studio you visit, but all of them lead to the creation of a video game. This is not a book about pipelines, so we won't explore them, but it's important to have a rough idea of where AI is collocated.</p>
<p>In fact, AI intersects with many parts of the game development pipeline. Here are some of the main ones:</p>
<ul>
<li><strong>Animation</strong>: It might surprise some of you, but there is a lot of research going on regarding this topic. Sometimes, animation and AI overlap. For instance, one of the problems that developers need to solve consists of how we can procedurally generate hundreds of animations for characters, which can behave realistically, and also how they interact with each other. In fact, solving the inverse kinematic (IK) is a mathematical problem, but which of the infinite solutions to choose to achieve a goal (or just to provide a realistic look) is an AI task. We won't face this specific problem during this book, but the last chapter will provide pointers to places where you can learn more about this.</li>
<li><strong>Level Design</strong>: If a game automatically produces levels, then AI plays an important role in that game. <em>Procedural Content Generation</em> (PCG) in games is a hot topic at the moment. There are games that are entirely based on PCG. Different tools to procedurally generate height maps can help Level Designers achieve realistic looking landscapes and environments. This is indeed a wide topic to explore.</li>
<li><strong>Game Engine</strong>: Of course, inside the game engine, there are many AI algorithms that come into play. Some of these are specific for agents, while others just improve the engine's features and/or tasks. These represent the most vast category, in which they can vary from simple algorithms to adjust a Bezier curve based on the context, to implementing behavior trees or finite state machines for animations. Under the hood, there is a lot going on here. We will explore some of these concepts in this book, but the message to take home is that an algorithm can be adapted to solve similar problems in different fields. In fact, if Finite State Machines (FSMs) are used to make decisions, why not use them to "<em>decide</em>" which animation to play? Or why not even handle the whole game logic (i.e. the blueprint visual scripting in Unreal Engine)?</li>
</ul>
<ul>
<li><strong>Non-Player Characters</strong> (<strong>NPCs</strong>): This is the most visible example of using AI in games, and this is also the most obvious AI to the Player (we will explore more about the relationship between the AI and the player in <a href="d9a581ce-adca-46fe-8f95-a78b762ebc46.xhtml">Chapter 14</a>, G<em><span class="cdp-organizer-chapter-title">oing Beyond</span></em>). This is what most of this book is focused on; that is, from moving the character (for instance, with a Pathfinding Algorithm) to making decisions (i.e. with Behavior trees), or collaborate with other NPCs (multi-agent systems).</li>
</ul>
<p>Unfortunately, we don't have the space to deal with all of these topics in this book. Therefore, we will just be focusing on the last part (NPCs), and explore the AI Framework that's built into Unreal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A bit of history</h1>
                </header>
            
            <article>
                
<p>Before venturing on our journey, I believe that having a general overview of the history of AI and AI in games might be beneficial. Of course, you can skip this part if you are a more hands-on type of person who cannot wait to getting down to programming AI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is AI?</h1>
                </header>
            
            <article>
                
<p>This is a very interesting question, which doesn't have a unique answer. In fact, different answers lead to different aspects of AI. Let's explore some (of many) definitions that have been given by different scholars (in chronological order).</p>
<p>Actually, Russell and Norvig, in their book, organized these specific definitions into four categories. Here is their schema:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/981bfe0d-8e8f-412c-b761-38ef9cbc0ab1.png" style="width:33.67em;height:28.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Russell and Norvig's four categories. Top-left: "Systems that think like humans". Top-Right: "Systems that think rationally". Bottom-Left: "Systems that act like humans". Bottom-Right: "Systems that act rationally".</div>
<p>We don't have the time to go into detail about the question "<em>What is AI?</em>", since this could fill up another book on its own, but the last chapter of this book will also include some philosophical reference where you can expand your knowledge on this topic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A glance into the past</h1>
                </header>
            
            <article>
                
<p>It might come unexpected to some of you, but the story of AI started well before computers. In fact, even ancient Greeks hypothesized the existence of intelligence machines. A famous example is the bronze giant Talos, who protected the city of Crete from invaders. Another is the golden helpers of Hephaestus, who helped God in his volcano forge along with the Cyclops. In the XVII century, René Descartes wrote about automatons that could think, and believed that animals were do different from machines, which could be replicated with pulleys, pistons, and cams.</p>
<p>However, the core of this story starts in 1931, when the Austrian logician, mathematician, and philosopher Kurt Gödel proved that all the true statements in the first-order logic are derivable. On the other hand, this is not true for higher order logics, in which some true (or false) statements are unprovable. This made first-order logic a good candidate to automate derived logical consequences. Sounds complicated? Well, you can imagine how that sounded to the ears of his traditionalist contemporaries.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d3fab71d-5a35-4d94-9d8a-a4e9ee4434ed.png" style="width:19.50em;height:25.42em;"/></p>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Photo of Alan Turing at the age of 16</div>
<p>In 1937, Alan Turing, an English computer scientist, mathematician, logician, cryptanalyst, philosopher, and theoretical biologist, pointed out some of the limits of "<em>intelligent machines</em>" with the halting problem: it is not possible to predict a-priori if a program will terminate unless it is actually run. This has many consequences in theoretical computer science. However, the fundamental step happened thirteen years later, in 1950, when Alan Turing wrote his famous paper "<em>Computing Machinery and Intelligence</em>", in which he talked about the imitation game, nowadays mostly known as "<em>The Turing Test</em>": a way to define what an intelligent machine is.</p>
<p>In the 1940s, some attempts were made to emulate biological systems: McCulloch and Pitts developed a mathematical model for a neuron in 1943, and Marvin Minsky created a machine that was able to emulate 40 neurons with 3,000 vacuum tubes in 1951. However, they fell into the dark.</p>
<p>From the late 1950s through to the early 1980s, a great portion of AI research was devoted to "<em>Symbolic systems</em>". These are based on two components: a knowledge base made out of symbols and a reasoning algorithm, which uses logical inference to manipulate those symbols, in order to expand the knowledge base itself.</p>
<p>During this period, many brilliant minds made significant progresses. A name worth quoting is McCarthy, who organized a conference in Dartmouth College in 1956, where the term "<em>Artificial Intelligence</em>" was first coined. Two years later, he invented the high-level programming language <em>LISP</em>, in which the first programs that were able to modify themselves were written. Other remarkable results include Gelernter's <em>Geometry Theorem Prover</em> in 1959, the <em>General Problem Solver</em> (GPS) by Newell and Simon in 1961, and the famous chat-bot <em>Eliza</em> by Weizenbaum, which was the first software that, in 1966, could have a conversation in natural language. Finally, the apotheosis of symbolic systems happened in 1972 with the invention of <em>PROLOG</em> by the French scientist Alain Colmerauer.</p>
<p>Symbolic systems led to many AI techniques, which are still used in games, such as blackboard architectures, pathfinding, decision trees, state machines, and steering algorithms, and we will explore all of them throughout this book.</p>
<p>The trade-off of these systems is between knowledge and search. The more knowledge you have, the less you need to search, and the faster you can search, the less knowledge you will need. This has even been proven mathematically by Wolpert and Macready in 1997. We will have the chance to examine this trade-off in more detail later in this book.</p>
<p>At the beginning of the 1990s, symbolic systems became inadequate, because they proved hard to scale to larger problems. Also, some philosophical arguments arose against them, maintaining that symbolic systems are an incompatible model for organic intelligence. As a result, old and new technologies have been developed that were inspired by biology. The old Neural Networks were dusted off from the shelf, with the success of Nettalk in 1986, a program that was able to learn how to read aloud, and with the publication of the book "<em>Parallel distributed processing</em>" by Rumelhart and McClelland in the same year. In fact, "<em>back-propagation</em>" algorithms were rediscovered, since they allow a Neural Network (NN) to actually learn.</p>
<p>In the last 30 years of AI, research took new directions. From the work of Pearl on "<em>Probabilistic reasoning in intelligent systems</em>", probability has been adopted as one of the principal tools to handle uncertainty. As a result, AI started to use many statistical techniques, such as Bayesian-nets, Support Vector Machines (SVMs), Gaussian processes, and the Markov Hidden Model, which is used widely to represent the temporal evolution of the states of a system. Also, the introduction of large databases unlocked many possibilities in AI, and a new whole branch named "<em>Deep Learning</em>" arose.</p>
<p>However, it's important to keep in mind that, even if AI researchers discover new and more advance techniques, the old are not to be discarded. In fact, we will see how, depending on the problem and its size, a specific algorithm can shine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AI in games</h1>
                </header>
            
            <article>
                
<p>The history of AI in video games is as interesting as what we talked about in the previous section. We don't have the time to go through it in detail and analyze every single game and how each one of them contributed to the field. For the most curious of you, toward the end of this book, you will find other lectures, videos, and books where you can dive deeper into the history of AI in games.</p>
<p>The first form of AI in video games was rudimental and used in games like <strong>Pong</strong> [<em>Atari</em>, 1972], <strong>Space Invaders</strong> [<em>Midway Games West, Inc</em>., 1978], and so on. In fact, beyond moving a paddle to try and catch a ball, or moving aliens toward the player, there wasn't much more we could do:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c86806ca-4daf-4fad-827d-285c2f8e832b.png" style="width:15.92em;height:17.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>A screenshot of <strong>Space Invaders</strong> Midway Games West, Inc., 1978], in which a rudimental form of AI is used to control the aliens</span></div>
<p>The first renowned game that used a noticeable AI was <strong>Pac-Man</strong> [<em>Midway Games West, Inc.</em>, 1979]. The four <em>monsters</em> (later named <em>ghosts</em> due to a flickering port in the Atari 2600) used an FSM to chase (or flee from) the player:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/30482b02-8104-4223-94f4-ac5f99d868e6.png" style="width:15.42em;height:18.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>A screenshot from the game <strong>Pac-Man</strong> Midway Games West, Inc., 1979], in which the four monsters use an FSM trying to catch the player</span></div>
<p>During the 1980s, AI in games didn't change much. It was only with the introduction of <strong>Warcraft: Orcs &amp; Humans</strong> [<em>Blizzard Entertainment</em>, 1994] that a pathfinding system was successfully implemented in a video game. We will explore the Navigation system in Unreal in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em><span class="cdp-organizer-chapter-title">Navigation</span>:</em></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27bbf5bf-6748-4d4d-8c46-3876435e494f.png" style="width:24.75em;height:15.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>A screenshot from <strong>Warcraft: Orcs Humans</strong> Blizzard Entertainment, 1994], in which the units (orc peons and grunts in this screenshot) use pathfinding algorithms to move in the map</span></div>
<p>The game that probably started to sensitize people about AI was <strong>Goldeneye 007</strong> [<em>Rare Ltd.</em>, 1997], which showed how AI could improve gameplay. Although it was still relying on FSMs, the innovation was that characters could <em>see</em> each other, and act accordingly. We will explore <em>agent-awareness</em> in <a href="94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml">Chapter 5</a>,<em> Agent Awareness</em>. This was a hot topic at the time, and some games made it the main game mechanic, such as <strong>Thief: The Dark Project</strong> [<em>Looking Glass Studios, Inc.</em>, 1998]:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4b4769fa-42b2-46be-98f5-75b43cc90fa5.png" style="width:33.17em;height:17.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A screenshot from <strong>Goldeneye 007</strong> Rare Ltd., 1997], which has changed how people perceive AI in video games</div>
<div class="packt_figure CDPAlignLeft CDPAlign"><span>and </span><strong>Metal Gear Solid</strong><span> [</span><em>Konami Corporation</em><span>, 1998]:</span></div>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eee2d65c-c724-4049-aeae-f6ac6a85cb51.png" style="width:36.08em;height:14.83em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A screenshot from <strong>Metal Gear Solid</strong> [<em>Konami Corporation</em>, 1998],</div>
<p>Another hot topic was modeling a soldiers' emotions during battles. One of the first games that implemented an emotional model was <strong>Warhammer: Dark Omen</strong> [<em>Mindscape</em>, 1998], but it was only with <strong>Shogun: Total War</strong> [<em>The Creative Assembly</em>, 2000] that these models were used with extreme success with a large number of soldiers without performance issues:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eee4cb0a-4b47-4e11-b18e-178e449089ec.png" style="width:27.58em;height:20.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A screenshot from <strong>Warhammer: Dark Omen,</strong> one of the first games that used an emotional model for soldiers</div>
<div>and</div>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e4fb9ab1-12bf-4e7c-ba19-a92705b21626.png" style="width:30.75em;height:17.42em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A screenshot from Shogun: Total War. The emotional model of the soldiers were more sophisticated than the one in Warhammer: Dark Omen, and yet it was used successfully with many soldiers</div>
<p>Some games even made AI the core of the gameplay. Although one of the first games to do so was <strong>Creatures</strong> [<em>Cyberlife Technology Ltd.</em>, 1997], the concept is more evident in games like <strong>The Sims</strong> [<em>Maxis Software, Inc.</em>, 2000] or <strong>Black and White</strong> [<em>Lionhead Studios Ltd.</em>, 2001]:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/53a162f4-6729-4196-983f-ed257e27632f.png" style="width:41.25em;height:14.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A screenshot from The Sims. A Sim (the character) is cooking, which is part of a complex behavior piloted by AI in the game.</div>
<p>In the last 20 years, many AI techniques have been adopted and/or developed. However, if the game doesn't require an advanced AI, you will probably find FSMs, still being broadly used, along with Behavior trees, which we will start exploring soon in <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a><em>, <span class="cdp-organizer-chapter-title">Behavior Trees and Blackboards</span></em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AI in games – Industry and Academia</h1>
                </header>
            
            <article>
                
<p>When it comes to comparing AI that's applied to video games, both in Academia and in the Industry, there is a big discrepancy. I would say that there was almost a fight between the two. Let's have a look at the reasons behind this. In fact, they have very different goals.</p>
<p>Academia wants to <em>create AI agents for games that <strong>think intelligently</strong> to act in the environment and interact with the player.</em></p>
<p>On the other hand, the game industry wants to <em>create AI agents for games that <strong>seem to think intelligently</strong> to act in the environment and interact with the player.</em></p>
<p>We can clearly notice that the first leads to a <strong>more realistic AI</strong>, whereas the second leads to a <strong>more believable AI</strong>. Of course, commercial games are more worried about the latter rather than the former.</p>
<p>We will explore this concept in more detail in <a href="d9a581ce-adca-46fe-8f95-a78b762ebc46.xhtml">Chapter 14</a>, <em><span class="cdp-organizer-chapter-title">Going Beyond</span></em>, when we talk about the psychology and game design involved in creating an AI system for games. In fact, to achieve a believable behavior, you often need to try and be realistic as well.</p>
<p>However, in more formal terms, we can say that game AI falls in the category of <em>weak AI</em> (opposite to <em>strong AI</em>), which focuses on solving a specific task or problem <em>intelligently</em>, rather than develop a consciousness behind it. In any case, we won't venture further into this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Planning our journey</h1>
                </header>
            
            <article>
                
<p>It's finally time to start planning our journey, before jumping into the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical terminology</h1>
                </header>
            
            <article>
                
<p>Since, for some of you, this is your first journey into AI, it's important that you have a small glossary of the technical terms that are used throughout this book (and in general, in AI). We have already encountered some of these in the past few pages:</p>
<ul>
<li><strong>Agents</strong> are systems that are capable of autonomous reasoning toward solving a specific set of goals.</li>
<li><strong>Backward Chaining</strong> is the process of tracing the cause of a problem by working backwards.</li>
<li><strong>Blackboard</strong> is an architecture for exchanging data between different agents, and sometimes even within the agent itself (especially in Unreal).</li>
<li><strong>Environment</strong> is the world where an agent lives. For instance, the game world is the environment of an NPC from the same game. Another example is a chess board, which represents the environment of a system that plays chess against humans (or other systems).</li>
<li><strong>Forward Chaining</strong>, opposite to Backward Chaining, is the process to work forward to find the solution to a problem.</li>
<li><strong>Heuristic</strong> is a practical approach to problem-solving, which does not guarantee to be optimal, nor sufficient for immediate goals. Heuristic methods are used when finding the optimal solution to a problem is impractical (if not impossible), in order to find a satisfactory solution. They can be thought of as mental shortcuts to lighten cognitive load during a decision-making process. Sometimes, it can represent the knowledge of an agent based on his/her past experience (although this is often given a-priori). The term "<em>Heuristic</em>" derives from ancient Greek, with the meaning of "<em>find</em>" or "<em>discover</em>".</li>
</ul>
<div class="packt_infobox">For a more extensive glossary, you can have a look at the one on Wikipedia. Here is the link: <a href="https://en.wikipedia.org/wiki/Glossary_of_artificial_intelligence"><span class="URLPACKT">https://en.wikipedia.org/wiki/Glossary_of_artificial_intelligence</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The bottom-up approach</h1>
                </header>
            
            <article>
                
<p>Usually, when a system is built or studied, there are two main approaches: top-down and bottom-up. The former starts from the high-level structures of the system and proceeds gradually into the granular details of the system. The latter starts from the basics and proceeds to create more complex structures that depend on the previous ones. Both approaches are valid, but, as a matter of preference, I chose the bottom-up approach to introduce the topics of this book.</p>
<p>In fact, we will start with how an agent can move, then understand how it can perceive, and finally use this data to make an informative decision or even come up with a plan. This is reflected in the structure of this book and its parts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The agent schema</h1>
                </header>
            
            <article>
                
<p>Since, during this book, we will be going through the different parts of how an AI agent can perceive, move, plan, and interact with its surroundings, it will be useful to draw a schema for this. Of course, there can be many other schemas, and they are all equally valid, but I believe that this one is particularly useful for getting started with <em>AI Game Development</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f80e4f4-82f6-4501-98a6-b81090fbddd0.png" style="width:47.75em;height:24.75em;"/></p>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The Agent model that we are going to use in this book</div>
<p>Since we chose a bottom-up approach, we should read the schema from the bottom. We will refer to this in more formal terms as our <em>agent model</em>.</p>
<p>First, we can see that the agent always exchanges information with the Game World, which includes geometry, physics, and animations, but also abstractions of it. This information is used at all the levels of our agent model.</p>
<p>From the bottom, we can see that our first concern is how to move in the environment. This is a process that can be split into Motion and Pathfinding (<a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a><em>, <span class="cdp-organizer-chapter-title">Navigation</span></em>). Going up the chain, we can see that the agent perceives the world (<a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>,<em> <span class="cdp-organizer-chapter-title">Environment Query System</span>, and 5, <span class="cdp-organizer-chapter-title">Agent Awareness</span></em>), and, based on this perception, the agent can make a decision (<a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a>, <em><span class="cdp-organizer-chapter-title">Behavior Trees and Blackboards</span></em>). Sometimes, making the best decision at that moment in time, might not lead to a better result in the long run, and so the agent should be able to plan ahead. Often, in video games, an AI system (which is not necessarily an NPC) can control more than one character, and, as a result, it should be able to coordinate a group of characters. Finally, the agent might need to collaborate with other agents. Of course, we won't be able to go deep into each topic in this book, but feel free to take a look online so that you can dive deeper into certain topics.</p>
<p>One final remark: Often, AI in games doesn't use all of these levels at once; some implement just one of them, or mix them up. However, it's important to keep in mind how things are structured before you start playing with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unreal Engine AI Framework</h1>
                </header>
            
            <article>
                
<p>Despite other game engines, which just give you rendering capability, Unreal Engine comes with many things implemented (and extended through plugins). This doesn't mean that making a game is easier, but rather that we have more tools to develop one.</p>
<p>As a matter of fact, Unreal implements many tools for Artificial Intelligence as well. While we explore them, we can create a schema of these tools and how they correlate to each other. So, let's try to just understand at which level we are going to operate. This means scratching the surface of the <strong>Unreal Game Play Framework</strong> (you can find more information about this here: <a href="https://docs.unrealengine.com/en-us/Gameplay/Framework">https://docs.unrealengine.com/en-us/Gameplay/Framework</a>).</p>
<p>There is a Controller Class, which can be divided into two subclasses. The first one is a Player Controller; as the name suggests, it offers an interface between the game and the player (of course, it is not covered in this book, since we will focus on AI and not general Gameplay). The second class is the AIController, which, instead, offers an interface between our AI algorithms and the game itself.</p>
<p>The following diagram shows these and how they interact with one another:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7a56b556-a050-42e2-9591-252dc5412561.png"/></p>
<p>Both kinds of controllers can possess a Pawn, which can be considered a virtual avatar. For the player, this may be the main character; for an AIController, a Pawn can be the enemy who wants to defeat the player.</p>
<p>In this book, we will focus only on the AIController, and all the tools around and beneath it to bring our AI to life (we will not cover the dotted sections in the preceding diagram). We will understand what I mean by this at a later stage, but the key concept is that we are going to operate at the level of an <strong><em>AIController</em></strong>.</p>
<div class="packt_tip">If you are already a bit familiar with C++ and Unreal, you can have a look at its class, which is defined in the <em><strong>AIController.h</strong></em> file, to learn a bit more about this controller.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A sketch of our journey</h1>
                </header>
            
            <article>
                
<p>Now that we have a rough idea of the schema we are going to use, let's break down what we will cover in this book, more or less in the order we will face the topics (I said more or less, because some topics are spread over more than one chapter, and they need to iterate once our knowledge of AI has been expanded).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>However, you can think of this book as being divided into three parts:</p>
<ul>
<li><em>Chapters 2-7</em>: A description of the different built-in AI systems</li>
<li><em>Chapters 8-10</em>: A concrete example of how to use the AI systems we explored in the previous chapters</li>
<li><em>Chapters 11-13</em>: A description of the different debugging methods for Game AI (since I believe that this part is equally important that knowing the systems themselves)</li>
</ul>
<p>Let's talk about what we will be covering in this book in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decision-making with Behavior Trees (chapters 2, 6, 8, 9, and 10)</h1>
                </header>
            
            <article>
                
<p><span>Once the agent can perceived the world around it, it needs to start making decisions, which have consequences. Some decision-making processes might become so complicated that the agent needs to come up with a proper plan to successfully achieve a goal.</span></p>
<p>The built-in Unreal Engine framework for AI rotates around Behavior Trees, which occupy a significant part of this book. Of course, this doesn't preclude the possibility to implement other AI systems on your own for decision-making in Unreal, but, by choosing Behavior Trees, you will have a strong set of tools ready to go, which we will explore in detail in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigation (chapters 3 and 7)</h1>
                </header>
            
            <article>
                
<p>Unless the game is discrete or turn-based, each AI agent needs to move around its own environment in a continuous fashion. Unreal provides a strong Navigation System that lets your AI Agents navigate easily within the environment, from falling to jumping, from crouching to swimming, to different kind of areas and different types of agent.</p>
<p>This system is so huge that it will be hard to cover it all, but we will do our best to cover everything you need to get started in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environment Query System (chapters 4 and 12)</h1>
                </header>
            
            <article>
                
<p>The <em>Environment Query System (ESQ)</em> can gather information from the environment surrounding the agent, thus allowing the agent to make decisions accordingly. This book dedicates a whole chapter to this system. In fact, it lies between <a href="94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml">Chapter 5</a>,<span> </span><em>Agent Awareness</em><span>, </span>and<span> </span><em>Decision Making</em>, and it is a great resource that's already built into Unreal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Agent Awareness (chapters 5 and 12)</h1>
                </header>
            
            <article>
                
<p><em>Agent Awareness</em> (or <em>Perception</em>) deals with the capacity to give senses to the AI agents. In particular, we will cover sight, which is the most common and widely used, but also hearing and smell.</p>
<p>Moreover, we will start to explore how this data will be used in higher level structures so that the agent can act accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Crowds (chapter 7)</h1>
                </header>
            
            <article>
                
<p>When you have many AI agents within your map, the environment becomes easily overcrowded, and the various agents might interfere with each other. Crowds Systems allow you to control large sets of AI Agents (while they can keep an individual behavior) so that they can avoid each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing Behavior Trees (chapters 8, 9, and 10)</h1>
                </header>
            
            <article>
                
<p>It is not enough for an AI developer to know how a Behavior Tree works: he/she needs to know how to design them. In fact, most of your job is about creating an abstract system that coordinates all your AI agents, and only after that will you spend the rest of the time implementing it. Therefore, we will cover a single and large example of how to design, create single pieces, and build a whole <em>Behavior Tree</em> from scratch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging methods for Game AI (chapters 11, 12, and 13)</h1>
                </header>
            
            <article>
                
<p>Once you have learned about all the different AI systems, you can start to experiment on those or program a game, but how do you understand if your AI is doing what you have planned and/or is performing well? Debugging methods are key in any software, but in Game AI, you will also need visual debugging. As such, Unreal Engine comes with many debugging methods (including some that are specific for AI), and I strongly believe that being knowledgeable of those is very important. You will not only learn the tools, but also how to extend them as per your needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going beyond (chapter 14)</h1>
                </header>
            
            <article>
                
<p>This last section of this book will explore some exciting ideas and innovation that's currently going on in the AI world, and will give you the inspiration to continue your wonderful journey. I will introduce some of the ongoing research on AI that's being applied to games, and how this can ultimately benefit your game. Being aware of new technologies and algorithms is key in this field so that you are always up to date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling AI for C++ users</h1>
                </header>
            
            <article>
                
<p>In case you are following this book as a C++ user, when you write C++ code within your project (or a specific module of your project or plugin), you will need to ensure that you add the right dependencies so that you have access to the AI systems, otherwise you will end up with compilation errors. We will look at this in more detail in the next chapter when we create a project for inserting all the code we will produce in this book. However, here is the line of code to insert/modify code in the <kbd>.cs</kbd> project file (the part of code in bold is required for AI to work):</p>
<pre>PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", <strong><em>"GameplayTasks", "AIModule"</em></strong> });</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have seen how wonderful the world of AI in video games is. We explored the history behind video games, both in Academia and in the industry. We have planned our journey in this book and explained what it will look like.</p>
<p>Now, it is time to prepare ourselves because, starting from the next chapter, we are going to get our hands dirty and jump straight into Unreal Engine.</p>


            </article>

            
        </section>
    </body></html>