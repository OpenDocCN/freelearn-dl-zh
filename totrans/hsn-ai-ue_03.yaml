- en: Behavior Trees and Blackboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A tree to decide how we should behave, a blackboard to remember it!*'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml), *Behavior
    Trees and Blackboards*. This is where things start to get a bit more interesting
    because we will learn how to use the two main Unreal AI Framework structures.
    First, we will look at ***Behavior Tree**s*** and learn all about their principal
    components, such as tasks, decorators, and services. Next, we will learn about
    ***Blackboards*** and how to integrate them with ***Behavior Trees***. After we
    have covered this, will be able to set up AI controllers that use ***Behavior
    Trees***, which is key in implementing the rest of the techniques in this book.
  prefs: []
  type: TYPE_NORMAL
- en: As you may notice, there is a pattern in which we first learn a little bit about
    the theory, and then we jump straight into practice to understand how it all works.
    This is a pattern that we will follow in each chapter. So, let's get going.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the field of *Decision-Making*, there are many mathematical structures that
    can be used. **Finite State Machines** (**FSM**s) are an easy, yet powerful example
    of systems that are able to make complex decisions. However, in the world of Artificial
    Intelligence for games, there is another structure that can also be used by non-AI
    experts: ***Behavior Trees***.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, one of the design choices of Unreal Engine is that it has built-in
    support for Behavior Trees, and is actually part of the main core of the AI Framework.
    This does not imply that you cannot implement other decision-making processes
    or structures, but using the built-in support for Behavior Trees will greatly
    benefit your team's budget (in terms of time). So, before you implement a different
    Decision-Making structure in Unreal, think twice about whether that is a good
    decision (of course, a Behavior Tree might not be optimal for your game, but keep
    in mind that they have built-in support and might be a great time-saver). Nonetheless,
    you can still implement sub-structures within the ***Behavior Tree*** to extend
    its functionality, but do not rush too much; first, let's learn about the basics
    of ***Behav******ior Trees***.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, in this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a ***Behavior Tree*** is, both in broader terms and within the Unreal Context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a ***Behavior Tree works*** within Unreal, including its different components
    and how they interact with the tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a ***Blackboard*** is and how it can be used to store data for the Behavior
    Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ***start running a Behavior Tree*** by using the AI Controller, both
    in Blueprint and C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: How Behavior Trees work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to think about the role that a Behavior Tree assumes within
    our AI Agent is to imagine it as a brain. It makes decisions and, as a consequence,
    acts on them. It is the processor for the artificial intelligence within our agent.
    Before we get started, if you have any experience with Behavior Trees in other
    contexts, it is important to understand that they differ in the context of Unreal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about how they are different, you can do so by visiting
    the following link: [https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer](https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is, however, important to highlight one key difference here: ***Unreal Behavior
    Trees*** are read from the top to the bottom, and nodes will be executed from
    left to right. In other contexts, you might have found this to the other way around,
    in which the tree is read from left to right, and the nodes are executed from
    top to bottom.'
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time you have encountered a Behavior Tree, then this will
    make sense when you read the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a Mathematical Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, it's time to understand how a ***Behavior Tree*** works. First of all,
    as the name suggests, it is a tree, mathematical speaking.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested to learn more about trees in graph theory, you can consult
    the following Wikipedia page: [https://en.wikipedia.org/wiki/Tree_(graph_theory)](https://en.wikipedia.org/wiki/Tree_(graph_theory)).
    Alternatively, if you want to get even more technical, you can consult the following
    page: [http://mathworld.wolfram.com/Tree.html](http://mathworld.wolfram.com/Tree.html).
    However, the definitions that are found at both the links are pretty mathematical,
    and you don''t need them to understand Behavior Trees.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to specify that a (mathematical) tree expresses relationships
    between nodes. In this sense, the same relationship that describes a family (e.g.
    parent, child, sibling) has been adopted in technical terms. To simplify the understanding
    of a tree, you can imagine your genealogical tree: each node is a person, and
    the branches (that connect people) are the relationships between the various people.
    However, the structure is still slightly different.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a tree? It is a graph that describes relationships between different
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, there is a "***Root***" node, which is *the only node without
    a parent*. From there, *every node can have one or more children*, *but only one
    parent*. The end nodes, which are the ones that do not have any child, are called
    ***leaves***. Here is a simple diagram to help you understand the basic structure
    of a *Mathematical Tree* in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d49467c4-7e43-45bd-bebc-0a0ccd1d2733.png)'
  prefs: []
  type: TYPE_IMG
- en: It might sound complicated, but it really isn't. Things will start getting interesting
    as we move on and talk about BehaviorTrees.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior Tree components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go through the official documentation, you will find that there are five
    types of nodes (***Task***, ***Decorator***, ***Service***, ***Composite***, and
    ***Root***) available to use, depending on the type of behavior that you're trying
    to create (and subsequently, how the AI should act in the world). However, I'd
    like to reformulate this to you in order to make it easier to understand and hopefully
    more practical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the ***Root*** node, the only kind of nodes (that are not leaves) are
    the ***Composites*** nodes. Leaves are called ***Tasks***. ***Decorators*** and
    ***Services*** are *add-ons* for either a *Composite* node or a *Task* leaf. Although
    Unreal lets you leave a *Composite* node as a leaf, you shouldn''t, because it
    means that you can remove that node and the Behavior Tree will still work in the
    same way. Here is an example of a tree showing all the different types of node
    (actually, we will build this *Behavior Tree* later in this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c71a9cbe-925e-4e5f-8e48-548b7d9efc47.png)'
  prefs: []
  type: TYPE_IMG
- en: When a tree is executing, you need to start following from the root node and
    go down the tree, reading the nodes from left to right. You traverse all the different
    branches (***Composite*** nodes) in a specific way (we are going to see this in
    a little while), until we reach a leaf, which is a ***Task***. In this case, the
    AI performs that ***Task***. It is important to note that a ***Task*** can fail,
    for instance, if the AI is unable to complete it. The fact that a *Task* can fail
    will be useful for understanding how Composite nodes work. After all, a decision-making
    process is just choosing which task to perform to achieve a goal in a better way
    (e.g. killing the player). Thus, based on which task failed to execute (or, as
    we will see, a Decorator can make a task or a whole branch fail), the Composite
    nodes will determine the next tasks in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, when you create your ***Behavior Tree***, each node can be selected,
    and some settings to adjust the behavior of the node/leaf can be found in the
    *Detail Panel*. Moreover, since the order is important, the nodes in the Behavior
    Tree have numbers (in the top-right corner) to help you understand the ordering
    of the node (although it is always from top to bottom, left to right). The following
    screenshot shows where you can find these numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb35abb8-d2b7-441b-93c1-1370be2b29d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A value of "*-1*" means that the node will never be executed in any order,
    and the color around the node will be a bit darker. This might be due to the fact
    that the node is not connected in some way to the root, and so it is isolated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6e82db7-47f6-4d5b-86d8-9ad6695ec0ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at these components in detail and pay particular attention to ***Composite***
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There isn''t much to say about the ***ROOT*** node. The tree needs to begin
    somewhere, so the Root node is just where the tree starts its execution. Here
    is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bca76338-5fba-4d62-b753-d1d82d74f05b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please note that the ***Root*** node can have only one child, and this must
    be a ***Composite*** node. You cannot attach any *Decorator* or *Service* to the
    ***Root***. If you select the ***Root*** node, it doesn''t have any property,
    but you will be able to assign a ***Blackboard*** (which we will cover later in
    this chapter), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee43b04f-4fae-4aca-b9be-5a6f1dc9d828.png)'
  prefs: []
  type: TYPE_IMG
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think of a tree, we often picture a large trunk with branches, and on
    those branches are leaves. In the context of UE4, those “*leaves*” are what we
    call “***Tasks***”. These are nodes that perform various actions, such as moving
    an AI, and can have *Decorator* or *Service* nodes attached to them. However,
    they do not have an output, which means that they do not play a role in the decision-making
    process itself, which is left entirely to Composite nodes. Instead, they define
    what an AI should do if that task needs to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that ***Tasks*** can be as complex as you like. They can be as simple
    as waiting an amount of time, to being as complex as solving a puzzle while shooting
    at the player. Huge tasks are hard to debug and maintain, while small tasks can
    make the ***Behavior Tree*** easily overcrowded and huge. As a good AI Designer,
    you should try to find a balance between the size of the task and write them in
    such a way that they can be reused in different parts of the tree (or even in
    other trees).
  prefs: []
  type: TYPE_NORMAL
- en: A *Task* can either ***Fail*** (report ***Failure***) or ***Succeed*** (report ***Success***),
    and it will not stop its execution until one of these two results is reported.
    *Composite* nodes are responsible for taking care of this result and deciding
    on what to do next. Thus, a Task might need several frames to executed, but it
    will end only when it reports either *Failure* or *Success*. Keep this in mind
    when you move on to[Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml), *Extending
    Behavior Trees*, where you will create your own Tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '*Tasks* can have parameters (which you will be able to set in the *Details
    Panel* once a *Task* has been selected), and usually, they are either hard-coded
    values or *Blackboard Key references* (more on *Blackboards* later in this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the Behavior Tree editor, a Task appears as a purple box. In the following
    screenshot, you can see some examples of Tasks and how they look within the Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab90dd1b-0e74-41cc-8102-551541615f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Unreal comes with some built-in Tasks that are ready to be used. They are general
    and cover the basic cases that you will probably need. Obviously, they cannot
    be specific to your game, so you will need to create your own *Tasks* (we will
    look at this in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml), *Extending
    Behavior Trees*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of the built-in tasks in Unreal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a1a9e32-3274-4e95-bac9-8d737562fe47.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Finish with Result***: Forces the Task to return a *Finish Result* (either
    *Fail* or *Succeed*) for this task immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Make Noise***: Produces a noise stimulus, which is used by the *Perception
    System* (this will be explored in [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml),
    *Agent Awareness*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Move Directly Toward***: Like the following node, but it disregards the
    *Navigation System*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Move To***: Moves the Pawn (by using the *Navigation System*, which we will
    explore in [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml), *Navigation*)
    to a location that''s specified from the *Blackboard* (we will explore *Blackboards*
    later in this chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Play Animation***: As the name suggests, this node plays an animation. However,
    exceptions aside (and this is the reason why this node exists), it is good practice to
    separate animation logic and behavior logic. Therefore, try not to use this node,
    and instead improve your Animation Blueprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Play Sound***: As the name suggests, this node plays a sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Push Pawn Action***: Performs a *Pawn Action* (unfortunately, we will not
    cover them in this book).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Rotate to face BBEntry***: Rotates the AI pawn to face a specific key that''s
    been memorized inside the Blackboard (we will look at what *Blackboards* are later
    in this chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Run Behavior***: Runs another *Behavior Tree* as a whole sub-tree. As a
    result, it is possible to nest *Behavior Trees* to create and compose very complex
    behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Run Behavior Dynamic***: Like the previous node, but it is possible to change
    which (*sub-*)*Behavior Tree* to execute at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Run EQSQuery***: Performs an *EQS Query* (we will see what they are in [Chapter
    4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml)*, Environment Querying System*)
    and stores the result within the *Blackboard*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Set Tag Cooldown***: Sets the timer (by using a tag) for a specific *Cooldown*
    node (which is a decorator that we will look at later in this chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Wait***: Stops the behavior for a specific amount of time. Arandom deviation
    can be specified to make the amount of time to wait different each time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Wait Blackboard Time***: Like the previous node, but the amount of time
    is retrieved from the *Blackboard* (more on *Blackboards* later in this chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have looked at how a *Task* node works, let's explore *Composite*
    nodes, which make decisions based up whether a *Task* returns Failure or Success.
  prefs: []
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composite nodes are at the core of the decision-making capabilities of ***Behavior
    Trees*** in Unreal, and understanding how they work is key.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of Composite nodes: *Selector*, *Sequence*, and *Simple
    Parallel*. The last one has been added recently, and you will find that by using
    a combination of *Selectors* and *Sequences*, you will be able to cover most of
    your cases. Here is how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selector**: This kind of node will try to find one of its children to execute,
    which means it tries to find either a branch (so another *Composite* node attached
    as a child) or a *Task* (another child, but it is a leaf) to execute. So, the
    ***Selector*** starts from the left-most child node and tries to execute it. If
    it fails (either the *Task* failed to be executed, or the whole branch failed),
    then it tries the second left-most, and so on. If one of the children returns
    *Success*, which means that either the Task has been completed or a whole branch
    has been completed, then the ***Selector*** reports *Success* to its parent, and
    stop executing other children. On the other hand, if all the children of the ***Selector***
    report a *fail*, then the ***Selector*** reports a *fail* to its parent as well.
    In the following screenshot, you can see what the ***Selector*** node looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/390d6972-3055-4ef2-ad83-02242c41cf80.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Sequence**: This kind of node works a bit like the opposite of the *Selector*.
    To report a success to its parent, all of the Sequence''s children must report
    a success. This means that the Sequence will start executing the left-most child
    node. If it is a success, it carries on with the second left-most, and so on if
    it is successful as well. If all the children until the right-most are a success,
    then the ***Sequence*** reports a *Success* to its parent. Otherwise, if just
    one the children fail, then the ***Sequence*** will stop executing its children,
    and report a *fail* to the parent. In the following screenshot, you can see what
    the ***Sequence*** node looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf17f5fe-6ef0-45b4-94a0-b7c783960ef2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Simple Parallel**: This is a particular kind of *Composite* node, which is
    used in specific cases. In fact, it can only have two children. The left-most
    child must be a *Task*, whereas the right-most child can be either a *Task* or
    a *Composite* (thus giving birth to a sub-tree). The ***Simple Parallel*** starts
    to execute both its children in parallel, although the left-most is considered
    the main one. If the main one fails, it reports a fail, but if the main one succeeds,
    then it reports a success. Based on its settings, the Simple Parallel, once it
    has finished executing the main task, can either wait until the end of execution
    of the sub-tree or directly report success or fail the main one to its parent
    and stop executing the sub-tree. In the following screenshot, you can see what
    the ***Simple Parallel*** node looks like. Please note that it is possible to
    drag only two children, in which the left-most must be a *Task* (the purple block
    is the draggable area):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34d7e425-1a2a-49e6-8848-0076f66a06b3.png)'
  prefs: []
  type: TYPE_IMG
- en: In this way, *Composite* nodes can "*decide*" which tasks to execute, based
    on what their children report (fail or success), and the *Composite* node reports
    back (either fail or success) to their parent. Even if the only-child of the root
    (which is a *Composite* node) reports back a success to the ***Root***, then the
    tree has been executed with success. A good ***Behavior Tree*** design should
    always allow for success.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Decorator*** nodes (also known as conditionals) are attached to either a
    *Composite* or *Task* node. ***Decorator*** nodes make decisions on whether a
    branch in the *Behavior Tree*, or even a single node, can be executed. In their
    essence, they are a condition; they check whether something should be occurring.
    In other words, a ***Decorator*** can check whether it is worthwhile continuing
    on that branch and can report a preventive F*ailure* if, based on a condition,
    we know for sure that the *Task* (or the sub-tree) will fail. This will avoid
    the Decorator trying to perform a *Task* (or sub-tree) that is impossible (for
    any reason: lack of information, the goal is no longer relevant, etc...).'
  prefs: []
  type: TYPE_NORMAL
- en: In general, Decorator nodes can assume the role of a ***Gate*** between the
    parent and the rest of the sub-tree. Thus, Decorators have the power to loop the
    sub-tree until a certain condition is met, or to not make execute within that
    sub-tree until a specific timer has expired, or even change the return result
    of the *Sub-Tree*.
  prefs: []
  type: TYPE_NORMAL
- en: For a (simple) example, imagine that there is a sub-tree dedicated to killing
    the player (it will make decisions so that the Agent will try and kill the player).
    Checking if the player is in range (and not from the other side of the map), or
    even if the player is still alive, might give us a preventive fail without us
    even having to execute that sub-tree. Consequently, the tree can continue with
    other events or parts of the tree, for example, in another sub-tree, which will
    be responsible for the wander behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '*Decorators* can have parameters (which you will be able to set in the *Details
    Panel* once a *Decorator* has been selected), and usually they are either hard-coded
    values or *Blackboard Key references* (more on *Blackboards* later in this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: Almost every *Decorator* has a checkbox in its parameters that allows you to
    invert the conditions (as a result, you will have more freedom, and you can use
    the same decorator on two different parts of the tree to execute different conditions).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how a decorator can be attached to a *Composite*
    node. Note that it is possible to have more than one Decorator per node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d46cee45-42c5-404b-a191-17d34b1695a9.png)'
  prefs: []
  type: TYPE_IMG
- en: For those who are familiar with Conditional nodes in other Behavior Tree systems,
    it is important not to confuse them with Task leaf nodes in Unreal Engine. More
    information can be found at [https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer](https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer).
  prefs: []
  type: TYPE_NORMAL
- en: Like Tasks, Unreal comes with some built-in Decorators that are ready to be
    used. They are general and cover the basic cases that you will probably need,
    but obviously, they cannot be specific for your game or application, and so you
    will need to create your own *Decorators* (we will look at this in detail in [Chapter
    6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)*, Extending Behavior Trees*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of the built-in tasks in Unreal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0ed724e-39d8-4f0a-a9e9-a4ef8b4a0f71.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blackboard***: Checks if a specific key on the *Blackboard* *Is Set* (or
    *Is Not Set*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Check Gameplay Tags on Actor***: As the name suggests, it checks if there
    is a specific Gameplay Tag(s) on an Actor that''s been specified by a Blackboard
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Compare BBEntries***: Compares two Blackboard values and checks if they
    are equal (or not equal) to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Composite***: This allows you to compose different *Decorators* at once
    with boolean logic. Once you have placed this *Decorator*, you can open its editor
    by double-clicking on it. From there, you will be able to build a graph with boolean
    operators and other *Decorators*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Conditional Loop***: As long as the condition is satisfied (whether a *Blackboard
    Key* *Is Set* or *Is Not Set*), it will keep looping through the sub-tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Cone Check***: This checks if one point (usually another Actor) is within
    a cone, starting from another point (usually the AI agent); the cone angle and
    direction can be changed. An example of its use is if you want to check whether
    the Player is in front of the enemy or not—you could use this code to determine
    this condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Cooldown***: Once the execution exits from the branch containing this *Decorator*,
    a *Cooldown timer* will start, and this *Decorator* doesn''t allow the execution
    to enter again until this timer has expired (it reports *Failure* immediately).
    This node is used so that you don''t repeat the same sub-tree too frequently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Does Path Exist***: This uses the Navigation System (more on this in [Chapter
    3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml), *Navigation*) to determine (and
    check) whether or not a Path exists for a specific point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Force Success***: As the name suggests, it forces the Success of the sub-tree,
    regardless of whether a *Failure* (or a *Success*) has been reported from below.
    This is useful for creating optional branches in a Sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that Force Failure doesn't exist, since it wouldn't make sense. If this
    were to be placed on a Selection, this would make it a Sequence, and if it were
    placed on a Sequence, it would only make one child execute.
  prefs: []
  type: TYPE_NORMAL
- en: '***Is at Location***: As the name suggests, it checks if the Pawn is (near
    or) at a specific Location (optionally, using the *Navigation System*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Is BBEntry of Class***:As the name suggests, it checks if a specific Blackboard
    Entry is of a specific Class. This is useful when the Blackboard Entry is of type
    Object, and you need to check if the reference within the Blackboard is of a specific
    class (or inherits from one).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Keep in Cone***: Similar to *Cone Check*, this *Decorator* (continuously)
    checks if the *Observer* is within a *Cone*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Loop***: As the name suggests, it loops within the sub-tree for a specific
    number of times (or even an infinite number of times; in this case, something
    else is needed to stop the behavior of the sub-tree, e.g. another *Decorator*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Set Tag Cooldown***: Similar to its homonym *Task*, when this *Decorator*
    becomes relevant (or if you imagine it as a gate, when it is traversed), it will
    change the *Cooldown* timer for a specific *Tag* (see the following node).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Tag Cooldown***: This is the same as the *Cooldown* node, but it has a timer
    associated with a *Tag*. As a result, this timer can be changed by the "*Set Tag
    Cooldown*" *Task* and by the "*Set Tag Cooldown*" *Decorator*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Time Limit***: As the name suggests, it provides a time limit for the sub-tree
    to finish its execution. Otherwise, this Decorator will stop execution and return
    a *Failure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have seen how *Decorator* nodes work, let's explore the last type
    of nodes of the Behavior Tree, *Service* nodes, which will continuously update
    and provide information in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Service*** nodes attach to *Composite* or *Task* nodes and will execute
    if their branch is being executed. This means that as long as a node below the
    node is attached, it doesn''t matter how many levels of parent-children are being
    executed—the Service will run as well. The following screenshot will help you
    visualize this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0508789a-67b2-425b-b713-99a88cd2190a.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that Service nodes are the eyes on the Behavior Tree's execution.
    In fact, they run continuously (if the sub-tree is active) and can perform checks
    and/or update *Blackboard* (see later) values in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: '***Service*** nodes are really specific for your *Behavior Tree* application,
    so there are only two default ones. An example of their usage might be providing/updating
    information to the sub-tree. For instance, imagine a situation where a sub-tree
    (the enemy) is trying to kill the player. However, it would be dumb (well, it
    depends of the enemy type, trolls might not be so smart) to pursue this objective,
    even when the player isn''t shooting back at the enemy. Thus, while the sub-tree
    is trying to kill the player, the sub-tree needs to find cover to reduce the damage
    the enemy takes. However, the enemy might be moving in the map, or the player
    might destroy the cover where our AI is hiding. Thus, the sub-tree needs information
    regarding the location of the nearest and safest cover, which is still in range
    of the player (an *EQS Query* can calculate that). A service can update this information
    in real-time so that when the sub-tree needs to use the data regarding the cover,
    they are ready. In this particular example, to find cover, running an *Environment
    Query* on the Service is a dynamic way to handle the task (we will look at this
    topic in [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml), *Environmental
    Querying System*). Otherwise, the *Service* might check certain specified points
    in the map that have been placed by a designer and evaluate which one is the best
    for its given action.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, ***Service*** nodes can be really powerful, but they are also
    specific to the application you are using them for. Thus, they really depend on
    the AIs you are programming for your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a couple of examples of Services. Please notice
    that *Services* can be used along with *Decorators*, and that a *Composite* node
    can have more than one ***Service***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12559947-1cc8-4ce0-be57-f6504a1174b1.png)*Service nodes* replace traditional
    *Parallel nodes* in other *Behavior Tree systems*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only two available default *Services* (since you will need to program your
    own for your game, which we will do in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)*,
    Extending Behavior Trees*) are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edab27c3-7245-4fb9-84a8-2dde04d5ab59.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Set Default Focus***: When this node becomes active, it automatically sets
    the *Default Focus* for the *AI controller*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Run EQS*** *(Query on a regular basis)*: As the name suggests, it runs an
    *Environmental Query* (check out [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml),
    *Environment Querying System*, for more information) on a regular basis to check
    for specific locations or actors. This was the kind of service that we needed
    in our example of finding cover for the enemy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will learn more about *Environmental Queries* in [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml),
    *Environment Querying System*. However, for now, all you need to know is that
    this is a system for spatial reasoning, and running these queries can find locations
    (or actors) within the space with specific properties (in the example of finding
    cover for the enemy, the one that maximizes these properties: the nearest, the
    safest, and still in rage to shoot to the player).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have learned about the different kind of nodes that compose a *Behavior
    Tree*. Now, it is time to explore Blackboards!
  prefs: []
  type: TYPE_NORMAL
- en: Blackboards and their integration with Behavior Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering the *Behavior Tree* as a brain, we can think of a ***Blackboard***
    as its memory—more specifically, the memory of the AI. The ***Blackboard*** stores
    (and sets) key values for the *Behavior Tree* to use.
  prefs: []
  type: TYPE_NORMAL
- en: They are called blackboards because, in a classroom, the blackboard is a place
    where a lot of information is conveyed, but most of it is shared among students;
    the single notes that are given out to students are personal. You can imagine
    the students as the different tasks (and nodes) of the *Behavior Tree*, and the
    ***Blackboard*** as a shared place for data.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blackboards*** are fairly simple to understand, since they are only a little
    more complex than a data structure. The only difference lies in the possibility
    to assign to a *Behavior Tree* to a particular ***Blackboard***, which is shared
    by every node of the tree. As a result, each node can read and/or write back to
    the *Blackboard*.'
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who are familiar with the ***Design Pattern of Blackboards***,
    within the context of Unreal, they just cover the role of holding the memory for
    a *Behavior Tree*.
  prefs: []
  type: TYPE_NORMAL
- en: It works like a *dictionary* (the data structure), in which a key corresponds
    to a specific value type (e.g. a vector, a float, an actor, etc…, even another
    *Blackboard Key*). So, by using or recalling the key, it is possible to write
    or read the associated value.
  prefs: []
  type: TYPE_NORMAL
- en: Another cool feature of ***Blackboards*** is that they can be extended through
    inheritance. This means that another ***Blackboard*** can be a parent, and the
    child will inherit all the parent's pairs key-value, plus some specific ones that
    are contained in the child itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the theory, let's look at how we can create a *Behavior
    Tree* and make it run. To do that, let's start by creating a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our AI project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From now on, we will get our feet wet by creating a project, and get a gist
    of what we have learned about ***Behavior Trees***. In this section, we are going
    to create a simple tree, but as we learn more about other topics in the following
    chapters, we will iterate over the tools for ***Behavior Trees***. As a result,
    this will provide you with a better understanding of the tools that are required
    to create awesome ***Behavior Trees***. Then, in [Chapter 8](6995bf12-0f10-47a9-a48c-cec31696df87.xhtml),
    *Designing Behavior Trees - Part I*, [Chapter 9](063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml),
     *Designing Behavior Trees - Part II*, and [Chapter 10](039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml),
    *Designing Behavior Trees - Part III*, we will be focusing on how to *create and
    design* a ***Behavior Tree*** from scratch that chases the player, which will
    give you a practical approach to ***Behavior Trees***.
  prefs: []
  type: TYPE_NORMAL
- en: So, to be able test the techniques that we are going to explore in this book,
    we need to create a project. By doing this, you will be able to follow the practical
    aspects that will be covered throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a new project from a template. The Third Person template works
    particularly well. In fact, it already has a character set up inside it, which
    can be easily possessed by an AI. This means that you don't have to worry too
    much about non-AI related details, such as animations. You can choose either the
    Blueprint version or the C++ one. I'll explain the concepts that we'll cover in
    both Blueprint and C++ terms throughout, but do note that some techniques in this
    book will work better if they're programmed in C++. As a result, I'm choosing
    the C++ version of the Third Person template, although this initial choice doesn't
    affect us much (we are programming AIs, not a Player or Gameplay).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I''m naming my project `UnrealAIBook`, as shown in the following screenshot.
    Once again, you will be able to find the project files at the following link: [http://hog.red/AIBook2019ProjectFiles](http://hog.red/AIBook2019ProjectFiles)
    (the link is case-sensitive):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/690fb145-83c8-4a15-9941-04460e4d954e.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting Behavior Trees from AI Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the basics of what Behavior Trees are and what they
    consist of, let's create our own. Recall from the previous chapter, the class
    in charge of possessing a Pawn and controlling it is the AI Controller. Thus,
    our ***Behavior Trees*** should run on *AI Controllers*.
  prefs: []
  type: TYPE_NORMAL
- en: We have two ways we can do this. The first one is by using Blueprints. Usually,
    even if you are a programmer, it is best to create a ***Behavior Tree*** using
    Blueprints, since the logic is really easy and the controller is simple. On the
    other hand, if you are a C++ fan and you want to use it as much as possible, even
    for small tasks, don't worry—I'll recreates the same logic we will do in Blueprint
    again, but this time in C++. In any case, ***Behavior Tree*** assets should be
    created and modified within the editor. What you will eventually program are different
    nodes than the ones that are available by default (we will see this later in this
    book), but the tree itself is always made in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Behavior Tree and the Blackboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we will need to create four Blueprint Classes: ***AI Controller***,
    ***Character***, ***Behavior Tree***, and ***Blackboard***. We will cover the
    AI controller later. If you chose one of the two Third Person templates, you should
    already have a *Character* ready to go. Thus, you just need to create a ***Behavior
    Tree*** and a ***Blackboard***.'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Content Browser*, create a new folder and name it `Chapter2`. This will
    help keep things organized. Then, create a sub-folder and name it `AI`. As a result,
    we can keep our project tidy and ensure that we don't mix up items from this chapter
    with other *non-AI-related* classes and/or objects we might create. We will put
    all the assets we are going to create for the AI in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blackboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need to add a ***Blackboard***, which should always be within the `AI`
    folder. To do this, go to the **Content Browser** and select **Add New** > **Artificial
    Intelligence** > **Blackboard**.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will call our Blackboard `BB_MyFirstBlackboard`. Here, I'm using
    the naming convention to prefix all Blackboards with `BB_`. Unless you have a
    specific reason to not follow this naming convention, please use it. By doing
    this, you will be in sync with the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is not possible to have multiple Blackboards on the same *Behavior
    Tree*, you can use inheritance with Parent and Child within the **Blackboard Details**
    panel, as shown in the following screenshot on the right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e49c8321-5531-4b68-ad1d-74fda84e703f.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a *Behavior Tree* by going to the **Content Browser** and selecting **Add
    New** > **Artificial Intelligence** > **Behavior Tree**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54632525-d656-4f2e-8b63-746deeeba315.png)'
  prefs: []
  type: TYPE_IMG
- en: For now, we will call our Behavior Tree `BT_MyFirstBehaviorTree`. Again, here,
    I'm using a specific naming convention to prefix all Behavior Tree assets with
    `BT_`. Once again, please follow the naming convention, unless you have a specific
    reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the *Behavior Tree* window, you will see a single node called
    **Root**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e44e6054-d9fb-4b2f-905c-6e4fbaedaea1.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Root** is where the execution of your *Behavior Tree* begins (from top
    to bottom and left to right). The Root itself only has one reference and that
    is the Blackboard, so it cannot be connected to anything else. It is the tip of
    the tree, and all subsequent nodes are below it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you drag from the ***Root*** Node, you will be able to add ***Composite***
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce9e5a41-1bee-40c0-bd09-89af8162c83f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For this, the *Behavior Tree Editor* is very intuitive. You can keep dragging
    out from the nodes to add ***Composite*** or ***Tasks*** nodes. To add a ***Decorator***
    or a ***Service***, you can right-click on a node and select "***Add Decorator...***"
    or "***Add Service...***", respectively, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca3285ef-4156-434c-aa1c-8757ec4a9ab2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, if you click on a node, it is possible to choose its parameters in
    the *Details Panel* (the following screenshot shows an example of a *Move To Node*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3975fc3-c7f6-4b68-a779-8e91f7ad82a8.png)'
  prefs: []
  type: TYPE_IMG
- en: The AI Controller to run a Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to run the *Behavior Tree* from an *AI Controller*. Usually,
    this is an easy task that it is implemented in Blueprint (in which it is possible
    to directly refer to a specific Behavior Tree). Even if we have a complex *C++
    AI Controller*, we can extend the controller in Blueprint and *Run* the *Behavior
    Tree* from Blueprint. In any case, if a hard reference doesn't work (e.g. you
    are using C++ or because you want to have more flexibility), then you can store
    the *Behavior Tree* in the *Character/Pawn* that needs to run that specific *Behavior
    Tree*, and retrieve it when the *AI Controller* possesses the *Pawn*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how we can do this both in Blueprint (we will reference the *Behavior
    Tree* in a variable, in which we can decide on the default value) and in C++ (in
    which we will store the *Behavior Tree* in the *Character*).
  prefs: []
  type: TYPE_NORMAL
- en: AI Controller in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a Blueprint AI Controller by clicking on **Add New** | **Blueprint
    Class** | **AI** **Controller.** You will have to click **All Classes** and search
    for **AI Controller** to access it. You can see an example of this in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e050bec6-3b7f-425c-a8b8-388c924585cf.png)'
  prefs: []
  type: TYPE_IMG
- en: For now, we will call our **AI Controller** `BP_MyFirstAIController`. Double-click
    on it to open the *Blueprint Editor*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a variable so that we can store our ***Behavior Tree***.
    Although it''s not necessary to keep reference of the *Behavior Tree*, it''s good
    practice to do so. To create a variable, we need to press the ***+ Variable ***button
    in the *My Blueprint *panel, next to the ***Variables*** tab, as shown in the
    following screenshot (keep in mind that your cursor needs to be on the Variables
    tab for the button to show up):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7851d84-9f87-4b1a-b664-a061dd73f5c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, as a variable type, you need to select *Behavior Tree* and give it a
    name, such as ***BehaviorTreeReference***. This is how what your variable should
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e519b4d5-55f8-4b5e-8412-630d53473810.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the *Detail Panel*, we will set the Default value (remember that to
    set the default value, the Blueprint needs to be compiled):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c558b0b0-f5f3-401f-b3ea-7d4b152305af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we need to override the ***On Possess*** function, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfaf02f5-051a-424b-95ae-030256348ed0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in the ***Event On Possess*** of the *AI Controller*, we need to start
    running/executing the *Behavior Tree*. We can achieve this by using the following
    simple node, named ***Run Behavior Tree***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a481b8ea-9642-47eb-957e-ec36be49a6c4.png)'
  prefs: []
  type: TYPE_IMG
- en: As a result, your AI controller will be able to execute the *Behavior Tre**e* that's
    stored within the ***BehaviorTreeReference***.
  prefs: []
  type: TYPE_NORMAL
- en: AI Controller in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have decided to create this simple AI controller in C++, let''s get
    started. I''m assuming that your Unreal Editor is already set up to work in C++
    (e.g. you have Visual Studio installed, symbols for debugs, etc.... Here is a
    reference link so that you can get started: [https://docs.unrealengine.com/en-us/Programming/QuickStart](https://docs.unrealengine.com/en-us/Programming/QuickStart))
    and that you have basic knowledge of how C++ works in Unreal. Here is a link for
    the naming convention so that you understand why some classes are prefixed with
    letters in the code: [https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start, remember that in order to work on AI in C++, you need to
    add the public dependencies in your your `.cs` file (in this case, ***UnrealAIBook.cs***),
    and add **GameplayTasks** and **AIModule** as public dependencies, like in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure that your code will compile without problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new C++ class, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3139ede6-da33-4d59-ac3b-4b2863792098.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The class needs to inherits from the ***AIController*** class. You might need
    to check the *Show All Classes* checkbox in the right-top corner and then use
    the search bar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f085bf2-d334-40bb-a6e1-2e5a1a00db98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on *Next* and name the class ***MyFirstAIController***. Moreover, I''d
    suggest that you keep our project tidy. Thus, click on the ***Choose Folder*** button.
    Unreal will prompt you to go to your system folder explorer. Here, create a folder
    named `Chapter2`, and within it a sub-folder named `AI`. Choose this folder as
    the place where you are going to store the piece of code we are going to create.
    This is what the dialogue box should look like, just before you click on *Create*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b74268a-2b98-4910-817b-68634caf997d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on *Create* and wait for your editor to load. You might see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2f65620-b4cb-4792-b5af-171ce4c74753.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The structure of our code will be slightly different compared to the Blueprint
    version. In fact, we cannot assign a ***Behavior Tree*** directly from the AI
    Controller class (mainly because it would be hard to reference it directly); instead,
    we need to take it from the Character. As I mentioned previously, this is a good
    approach when you''re working with Blueprints too, but since we have chosen a
    C++ project, we should look at some code. In Visual Studio, open the `UnrealAIBookCharacter.h`
    file, and just below the public variables, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For those who are still unfamiliar, here is a larger chunk of code so that
    you can understand where to place the preceding code within the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, to compile the preceding code, we also have to include the following
    statement at the top of the class, just above `.generated`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the *Character class*, since we have finished with it. As a result, every
    time we have an instance of that character placed in the world, we will be able
    to specify a *Behavior Tree* from the *Details* panel, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8890c1f-47aa-4dc9-bb45-e9d180b264bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s open the header (`.h`) file of our newly created AI controller (it should
    already be open in *Visual Studio* if you are using it as an *IDE*). In particular,
    we need to override a function of the AI Controller class. The function we are
    going to override is called `Possess()`, and it allows us to run some code as
    soon as this AI Controller possess a new Pawn (that is, when it takes control
    of the character, which is a Pawn). Add the following code in bold (within a protected
    visibility):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the implementation (`.cpp`) file. Once again, to use *Behavior Trees*,
    we have to include both *Behavior Trees* and the `UnrealAIBookCharacter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to assign a functionality to the `Possess()` function. We need
    to check whether the *Pawn* is actually an ***UnrealAIBookCharacter***, and if
    so, we retrieve the *Behavior Tree* and run it. Of course, this is surrounded
    by an `if` statement to avoid our pointers being `nullptr` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If, for any reason, you cannot get the code to work, you can just use a Blueprint
    controller to start the *Behavior Tree*, or just inherit the C++ controller, and
    make sure that all rest of the code runs, and make a call to the `RunBehaviorTree()`
    function in Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have compiled our project, we will be able to use this controller.
    Select our AI character from the Level (if you don''t have it, you can create
    one) and this time, in the *Details* panel, we can set our C++ controller, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ca2c2d3-949d-4a87-a980-858ee4285383.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, don''t forget to assign the *Behavior Tree* as well, which we always
    do in the *Details Panel*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8129073-f0fa-4531-9556-ab97d878ab78.png)'
  prefs: []
  type: TYPE_IMG
- en: As a result, once the game starts, the enemy will start executing the Behavior
    Tree. At the moment, the tree is empty, but this gives us the structure we need
    so that we can start working with *Behavior Trees*. In the following chapters,
    we are going to explore *Behavior Trees* more in detail, especially in chapters
    8, 9, and 10, where we will look at a more practical approach to designing and
    building *Behavior Trees*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered what a ***Behavior Tree*** is and some of the
    things that they consist of, including *Tasks*, *Decorators*, and *Services*.
    Next, we learned about ***Blackboards*** and how to integrate them with *Behavior
    Trees*. Then, we created a *Behavior Tree* and learned how to make it start from
    an *AI Controller* (both in Blueprint and C++). By doing this, we have developed
    a solid foundation that has provided us with key knowledge so that we can tackle
    the other parts of this book.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we will meet more ***Behavior Trees*** throughout this book, and
    you will have a chance to master them. But before that, there are certain topics
    we need to learn about first. Once we have a solid foundation of navigation and
    perception (including EQS), we can iterate over ***Behavior Trees*** to understand
    the role of *Composite* nodes, along with *Decorator* and *Tasks*. Moreover, we
    will be able to create our own. Chapters 8, 9, and 10 will guide you through the
    process of creating a Behavior Tree from scratch, from the designing phase to
    realization.
  prefs: []
  type: TYPE_NORMAL
- en: But until then, let's move on to the next chapter, in which we are going to
    discuss *Navigation* and *Pathfinding*!
  prefs: []
  type: TYPE_NORMAL
