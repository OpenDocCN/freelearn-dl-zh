- en: Web Deployments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络部署
- en: So far, we have been focused on getting something to work for the very first
    time and then making incremental updates. These updates are almost always geared
    toward better techniques and better usability. But, how do we expose them to the
    user? One way to do this is via REST endpoints.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于让某件事第一次工作，然后进行增量更新。这些更新几乎总是针对更好的技术和更好的可用性。但是，我们如何向用户展示它们呢？一种方法是通过REST端点。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Training a model, and writing some neater utils for data I/O
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练模型，并为数据I/O编写一些更简洁的实用工具
- en: Building a predict function, separated from training
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立预测函数，与训练分离
- en: Exposing what we have covered using a Flask REST endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask REST端点公开我们所涵盖的内容
- en: Web deployments
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络部署
- en: This is the hackathon version, and more experienced engineers will notice that
    we neglect a lot of best practices in favor of saving developer time. In my defense,
    I did add pretty usable logging.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是黑客马拉松版本，更有经验的工程师会注意到我们为了节省开发者时间而忽略了大量最佳实践。为了自我辩护，我确实添加了相当实用的日志记录功能。
- en: 'We will start from where we left off when we talked about text classification
    using machine learning methods. There are a few challenges that we left untouched:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们之前讨论使用机器学习方法进行文本分类的地方开始。我们留下了一些未解决的问题：
- en: '**Model persistence**: How can I write the model, data, and code to disk?'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型持久化**：我如何将模型、数据和代码写入磁盘？'
- en: '**Model loading and prediction**: How can I load the model data *and code*
    from disk?'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型加载和预测**：我如何从磁盘加载模型数据和代码？'
- en: '**Flask for REST endpoints**: How can I expose the loaded model over the web?'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask用于REST端点**：我如何通过网络公开加载的模型？'
- en: If there is anything that you take away from this chapter, it should be the
    preceding three questions. If you have a clear and complete idea regarding how
    to tackle these three questions, your battle is won.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这个章节中学到了什么，应该是前面的三个问题。如果你对如何解决这三个问题有一个清晰和完整的概念，那么你的战斗就赢了。
- en: We will use a scikit-learn model and the same TF-IDF based pipelines we are
    familiar with for this demo.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用scikit-learn模型以及我们熟悉的基于TF-IDF的管道进行这个演示。
- en: Model persistence
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型持久化
- en: The first challenge is to write the model data and code it to disk. Let's start
    by training the pipeline first.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是将模型数据和代码写入磁盘。让我们先从训练管道开始。
- en: 'Let''s get the imports out of the way:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把导入的部分处理掉：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s write some utils for reading the data from text files and downloading
    them if absent:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些从文本文件中读取数据以及如果不存在则下载它们的实用工具：
- en: 'Let''s start by setting up a download progress bar for our use. We will do
    this by building a small abstraction over the `tqdm` package:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的使用设置一个下载进度条。我们将通过在`tqdm`包上构建一个小抽象来实现这一点：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s use the preceding `tqdm` progress information for defining a download
    utility:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面的`tqdm`进度信息来定义一个下载实用工具：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the utility uses `os` instead of `pathlib`, which is preferred throughout
    the text otherwise. This is both for variety and the fact that `os` works equally
    well in Python 2, while `pathlib` is best used with Python 3.4 or later. As a
    reminder, this entire book assumes that you are using Python 3.6 code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个实用工具使用`os`而不是`pathlib`，这在文本的其他部分是首选的。这既是为了多样性，也是因为`os`在Python 2中同样有效，而`pathlib`最好与Python
    3.4或更高版本一起使用。作为提醒，这本书假设你正在使用Python 3.6代码。
- en: 'Now that we have a `get_data` utility in place, let''s write a `read_data`
    utility, which is customized to our specific dataset:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个`get_data`实用工具，让我们编写一个`read_data`实用工具，它针对我们的特定数据集进行了定制：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: pandas DataFrames make our code much easier to read, manage, and debug. Additionally,
    this function actually uses a Python nested function to make it easier to increase
    code reuse. Notice that for both positive and negative reviews, we use the same
    internal function that does the I/O for us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: pandas DataFrames使我们的代码更容易阅读、管理和调试。此外，这个函数实际上使用Python嵌套函数来提高代码重用性。注意，对于正面和负面评论，我们都使用同一个内部函数来为我们执行I/O。
- en: 'Let''s import these utils now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们导入这些实用工具：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I have defined a logger from the Python 3 `logging` module, with both the file
    handler and the console handler. Since that is a well-known and established best
    practice, I am going to skip that here and use the logger directly instead:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从Python 3的`logging`模块定义了一个日志记录器，包括文件处理程序和控制台处理程序。由于这是一个众所周知且已确立的最佳实践，我在这里将跳过它，直接使用日志记录器：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `data_path` variable now contains the extracted folders and files from `aclImdb`.
    Notice that this extraction is not done by code, but is instead done by the user
    outside of this code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_path` 变量现在包含了从 `aclImdb` 提取的文件夹和文件。请注意，这个提取不是通过代码完成的，而是由用户在代码外部完成的。'
- en: This is because this extraction from `*.tar.gz` or `*.tgz` is OS-dependent.
    Another thing that you should have noticed by now is that we have moved away from
    notebooks with interspersed print statements and previews to Python scripts for
    this section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为从 `*.tar.gz` 或 `*.tgz` 的提取是依赖于操作系统的。现在你应该注意到的另一件事是我们已经从带有穿插打印语句和预览的笔记本转向了本节中的
    Python 脚本。
- en: 'We must download the compressed file – which is a little more than 110 MB –
    if it does not exist in the target location:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须下载压缩文件——它略大于 110 MB——如果目标位置不存在：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Extract the files while you''re offline before trying to read them:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试读取之前，先离线提取文件：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `train` variable is now a DataFrame with two columns: the raw *text* and
    the *label*. The label is either `pos` or `neg`, which is short for positive or
    negative. The label indicates the overall sentiment of the review. We separate
    these into two variables: `X_train` and `y_train`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`train` 变量现在是一个包含两列的 DataFrame：原始 *文本* 和 *标签*。标签是 `pos` 或 `neg`，分别代表正面或负面。标签表示评论的整体情感。我们将这些分开成两个变量：`X_train`
    和 `y_train`：'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s define the `Pipeline` of operations that we want to perform. The
    logistic regression model, which uses TF-IDF representations, is the simplest
    and fastest way to train the model, and has reasonably good performance. We will
    use that here, but you can (*and usually, should*) actually replace this with
    whatever has the best performance on your test data:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义我们想要执行的操作 `Pipeline`。使用 TF-IDF 表示的逻辑回归模型是训练模型最简单、最快的方式，并且性能相当不错。我们在这里将使用它，但你实际上可以（并且通常应该）用你在测试数据上性能最好的任何东西来替换它：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once we call the `.fit` function, we have trained our pipeline for text classification.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用 `.fit` 函数，我们就已经训练了我们的文本分类管道。
- en: Those who are familiar with Python might remember pickle or cPickle. Pickle
    is a Python-native utility for saving objects and other Python data structures
    to disk in binary for later reuse. `joblib` is a pickle improvement!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Python 的人可能会记得 pickle 或 cPickle。Pickle 是一个 Python 原生的工具，用于将对象和其他 Python 数据结构以二进制形式保存到磁盘，以便稍后重用。`joblib`
    是 pickle 的改进！
- en: '`joblib` is an improvement because it also caches the *code with data*, which
    is fantastic for our use case. We don''t have to worry about defining the pipeline
    in our web API layer. It is no longer tied to our specific model, which means
    that we can keep making better releases by simply changing the underlying `joblib.dump`
    file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`joblib` 是一个改进，因为它还缓存了 *带有数据的代码*，这对于我们的用例来说非常棒。我们不必担心在 Web API 层定义管道。它不再与我们的特定模型绑定，这意味着我们可以通过简单地更改底层的
    `joblib.dump` 文件来持续发布更好的版本。'
- en: 'As a tribute to the classic Python pickle, we are going to give a `.pkl` extension
    to this cached code and `model.pkl` data file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对经典 Python pickle 的致敬，我们将给这个缓存的代码和 `model.pkl` 数据文件赋予 `.pkl` 扩展名：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's it! We have now written our code and data logic into one single binary
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在已经将我们的代码和数据逻辑写入了一个单一的二进制文件。
- en: How will we actually use this? Let's look at how next.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上会如何使用它呢？让我们看看下一步。
- en: Model loading and prediction
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型加载和预测
- en: The next challenge is actually to load the model from our pickled file and use
    it to make predictions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个挑战实际上是加载我们的 pickle 文件中的模型并使用它进行预测。
- en: 'Let''s start by loading the model from disk:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从从磁盘加载模型开始：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `model` variable should now expose all the functions that the original `lr_clf`
    object did. Of all those methods, we are interested in the `predict` function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`model` 变量现在应该暴露出原始 `lr_clf` 对象所拥有的所有函数。在所有这些方法中，我们感兴趣的是 `predict` 函数。'
- en: 'But before we use that, let''s load some files from disk for making predictions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们使用它之前，让我们从磁盘加载一些文件来进行预测：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now pass these variables in a list to the `predict` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这些变量作为一个列表传递给 `predict` 方法：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What does the `predictions` variable contain at this point?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此时 `predictions` 变量包含什么内容？
- en: Is it a list? Is it a numpy array? Or just an integer?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个列表吗？是一个 numpy 数组？或者只是一个整数？
- en: 'You can check for this by using the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下代码进行检查：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, the predictions is a list of integers, identical to the way we
    had read our `y_train` variable in the training file. Let's go ahead and incorporate
    what we have learned here into a web interface and REST Endpoints.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，预测结果是一个整数列表，与我们读取训练文件中的`y_train`变量方式相同。让我们继续将在这里学到的知识应用到网络界面和REST端点中。
- en: Flask for web deployments
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask用于Web部署
- en: 'Let''s begin by getting the imports out of the way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理导入：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I am assuming that as a programmer, you can pick up Flask basics outside this
    book. Even then, for the sake of completeness, I am adding the main ideas that
    are relevant to us:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设作为程序员，你可以在本书之外掌握Flask基础知识。即便如此，为了完整性，我添加了与我们相关的主要思想：
- en: The main web app is defined in the `Flask` module, which is imported from Flask
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要的Web应用程序定义在`Flask`模块中，该模块是从Flask导入的。
- en: '`jsonify` converts any JSON-friendly dictionary into a JSON that can then be
    returned to the user'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonify`将任何JSON友好的字典转换为可以返回给用户的JSON。'
- en: '`render_template` is how we expose HTML pages and web interfaces to our users'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render_template`是我们向用户公开HTML页面和Web界面的方式。'
- en: 'Let''s begin by declaring our app first:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先声明我们的应用程序：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will use the `route` function to decorate our Python functions and
    expose them as REST endpoints. Let''s start by exposing a simple status endpoint
    that is always ON and return 200 for whenever the service is running:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`route`函数装饰我们的Python函数，并将它们公开为REST端点。让我们先公开一个始终开启的简单状态端点，并在服务运行时返回200。
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `methods` variable is usually a list of strings with the values `GET` `POST`,
    or both. GET is used for HTTP(S) GET calls that require no information from the
    user, except that which is already contained in the GET call. The HTTP POST calls
    supply additional data from the client (such as the browser) to the server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`methods`变量通常是一个包含值`GET`、`POST`或两者的字符串列表。GET用于不需要用户信息的HTTP(S) GET调用，除了GET调用中已经包含的信息。HTTP
    POST调用从客户端（如浏览器）向服务器提供额外数据。'
- en: This can be accessed by hitting the `/status` endpoint in your browser.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在浏览器中点击`/status`端点来访问。
- en: Go ahead and try it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。
- en: Ouch! We forgot to run the app itself first.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们忘记先运行应用程序本身了。
- en: 'Let''s go ahead and run the app in debug mode. Debug mode allows us to add
    and edit code, and automatically load the code on every save:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以调试模式运行应用程序。调试模式允许我们添加和编辑代码，并在每次保存时自动加载代码：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that we load the `model` variable from `joblib`, like we did earlier.
    This code segment is written at the end of an `api.py` file. This is remarkably
    sloppy, with no concurrency support, and isn't integrated with nginx – but all
    of that is fine for this demonstration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们像之前一样从`joblib`加载了`model`变量。这段代码位于`api.py`文件的末尾。这非常草率，没有并发支持，也没有与nginx集成，但所有这些都适合这个演示。
- en: What happens if we hit the `localhost:8000/status` endpoint from our browser
    now?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从浏览器中点击`localhost:8000/status`端点会发生什么？
- en: We get a status 200, and the data field contains our JSON with the version and
    *status* information. Great.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了状态码200，数据字段包含我们的JSON版本和*状态*信息。太好了。
- en: 'Let''s go ahead and add our `/predict` endpoint. Here is the outline of the
    steps this function will undertake:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加我们的`/predict`端点。以下是此函数将执行的步骤概述：
- en: It will check if this is indeed a POST method. If yes, it will extract the file
    information from the *file* key in `flask.request.files`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将检查这确实是一个POST方法。如果是，它将从`flask.request.files`中的`*file*`键提取文件信息。
- en: Then, it will write this file to disk and read again, and then pass string text
    to `model.predict` as a single element of a list.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将此文件写入磁盘并再次读取，然后将字符串文本作为列表的单个元素传递给`model.predict`。
- en: 'Finally, it will return the result to a web interface in HTML, after optionally
    deleting the file written to disk:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将在可选删除写入磁盘的文件后，将结果返回到Web界面中的HTML：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Quite obviously, the step for writing the file to disk is redundant if we are
    simply going to delete it later. In practice, I keep the files on disk since it
    helps with debugging and, in some cases, understanding how the API is being used
    in actual practice by its users.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们只是稍后删除它，将文件写入磁盘的步骤是多余的。在实践中，我保留文件在磁盘上，因为这有助于调试，在某些情况下，也有助于理解用户在实际使用中如何使用API。
- en: In the preceding snippet, you might have noticed that we return an `index.html`
    file with a `label` value. The label is set as part of `Jinja2` templates. The
    variable is used in the `index.html` itself and the value is updated when rendering
    the page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可能已经注意到我们返回了一个带有 `label` 值的 `index.html` 文件。这个标签是作为 `Jinja2` 模板的一部分设置的。变量在
    `index.html` 本身中使用，并在渲染页面时更新其值。
- en: 'This is the `index.html` we will use:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要使用的 `index.html`：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is what the HTML looks like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 HTML 的样子：
- en: '![](img/d94796a9-e320-469e-af4b-6030a0bbe624.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d94796a9-e320-469e-af4b-6030a0bbe624.png)'
- en: 'The Prediction: pos is actually a result from the file I uploaded to this page
    earlier. This was marked by the `{%%}` syntax in the actual HTML:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 预测：pos 实际上是来自我之前上传到这个页面的文件的结果。这由实际 HTML 中的 `{%%}` 语法标记：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, we have seen a few things in the Flask-based web deployment section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在基于 Flask 的网络部署部分看到了一些内容：
- en: How do you receive uploaded files on the Flask webserver?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在 Flask 网络服务器上接收上传的文件？
- en: How do you upload the file using a web interface?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何使用网络界面上传文件？
- en: 'And, as a bonus: Jinja templates to display the returned answer'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，作为额外奖励：用于显示返回答案的 Jinja 模板
- en: It is worth mentioning that we could make this even more general by separating
    returns. This would be for use by humans, where we return HTML, and for use by
    machine, where we return JSON. I leave this function refactoring as an exercise
    for you.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们可以通过分离返回值使这个功能更加通用。这将用于人类用户，我们返回 HTML，以及用于机器用户，我们返回 JSON。我将这个函数重构作为你的练习。
- en: Quite obviously, we could have done this with Django or any other web framework.
    The only reason I picked Flask is for demonstration purposes and because it is
    very lightweight, with no concern for model-view-controller separation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们也可以用 Django 或任何其他网络框架来做这件事。我选择 Flask 的唯一原因是为了演示目的，并且它非常轻量级，没有关注模型-视图-控制器分离。
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The key takeaway from this chapter should be that any machine learning model
    can be deployed like any other piece of code. The only difference is that we have
    to make room for being able to load the model again from disk. To do this, first,
    we need to train a model and write the model code and weights to disk using `joblib`.
    Then, we need to build a predict function, which is separated from training. Finally,
    we expose what we have done by using Flash with Jinja2 HTML templates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键要点应该是任何机器学习模型都可以像其他任何代码片段一样部署。唯一的区别是我们必须留出空间以便能够从磁盘再次加载模型。为此，首先，我们需要训练一个模型，并将模型代码和权重使用
    `joblib` 写入磁盘。然后，我们需要构建一个预测函数，这个函数与训练是分开的。最后，我们通过使用 Flask 和 Jinja2 HTML 模板来展示我们所做的工作。
