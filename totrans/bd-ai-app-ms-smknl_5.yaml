- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming with Planners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to chain functions manually to perform
    complex tasks. In this chapter, we will learn how to use **planners** to chain
    functions automatically. Chaining functions automatically can give your users
    a lot of flexibility, allowing them to use your application in ways that you don’t
    have to write code for.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how planners work, when to use them, and what
    to be careful about. We will also learn how to write functions and build a kernel
    that helps planners build good plans.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a planner is and when to use one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a planner to run a simple function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing functions to help a planner decide the best way to combine them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a planner to allow users combine functions in complex ways without having
    to write code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have learned how to empower users by giving
    them the ability to make requests in natural language, allowing them to solve
    complex problems that you didn’t have to write code for.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need to have a recent, supported version
    of your preferred Python or C# development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: For Python, the minimum supported version is Python 3.10, and the recommended
    version is Python 3.11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For C#, the minimum supported version is .NET 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will call OpenAI services. Given the amount that companies
    spend on training these LLMs, it’s no surprise that using these services is not
    free. You will need an **OpenAI API** key, either directly through **OpenAI**
    or **Microsoft**, via the **Azure** **OpenAI** service.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using .NET, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Python, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the required packages by going to the GitHub repository and
    using the following: `pip install -``r requirements.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a planner?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been performing complex requests by performing the function
    calls ourselves. This, however, requires you to restrict the kind of requests
    that your users can make to what you can predict and write ahead of time. It also
    restricts your users to only generating one output at a time. Sometimes, you may
    want to give them the ability to do more.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a semantic function that allows users to request jokes
    (as we built in [*Chapter 1*](B21826_01.xhtml#_idTextAnchor014)) and a user requests
    “*tell me a knock-knock joke*,” you can simply call the semantic function that
    tells knock-knock jokes. But if the user requests three knock-knock jokes, the
    function wouldn’t know how to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: A planner is a built-in function from Semantic Kernel that receives a user request
    and then goes through the descriptions of all the functions, parameters, and outputs
    of the functions you loaded in your kernel and decides the best way to combine
    them, generating a **plan**.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there are two planners – a **Handlebars planner** and
    a **Function Calling Stepwise planner**, which we will call a Stepwise planner
    for short. Both are used in the same way, but internally, they work in different
    ways. When Semantic Kernel uses the Handlebars planner, it asks the AI service
    (for example, GPT-3.5 or GPT-4) to write code that will call the functions you
    loaded into the kernel in a scripting language called Handlebars. The Handlebars
    planner is very new and still experimental. It is expected to consume fewer tokens
    than the Stepwise planner, as programming languages can be more efficient in expressing
    complex ideas such as conditionals and loops. The Stepwise planner generates a
    plan that is a dialog with a chat service, which can be longer than the plan generated
    by the Handlebars planner and consume more tokens. Currently, one of the major
    limitations of the Handlebars planner is that it is only available in C#, although
    a Python version is likely to be released in 2024.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand better how a planner works, assume you have a plugin that generates
    stories, a plugin that breaks stories into small parts, and a plugin that generates
    images. You load all these plugins into the kernel. The user submits a request:'
  prefs: []
  type: TYPE_NORMAL
- en: “*Create a two-page story about a data scientist that solves crimes with his
    faithful canine companion, break it into small parts, and generate an image in
    the style of Frank Miller for each part*.”
  prefs: []
  type: TYPE_NORMAL
- en: The planner will go through the functions you loaded in the kernel and determine
    the best order to call them, automatically producing a storyboard without you
    having to write any additional code other than the initial plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Planners can enable your users to execute complex tasks with minimal effort
    from your side. Let’s see when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: When to use a planner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Planners can help you as a developer in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Users can combine functions of your application in ways that you didn’t think
    of. If you make the functions of your application available as atomic functions
    inside plugins and give the users the ability to make requests to a planner, then
    the planner can combine these atomic functions in workflows without you having
    to write any code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As AI models improve, planners get better without you having to write any additional
    code. When Semantic Kernel was initially designed, the best AI model available
    was GPT-3.5 Turbo. Since then, we have had the releases of GPT-4 and GPT-4 Turbo,
    both with more capabilities. An application built with Semantic Kernel that used
    GPT-3.5 Turbo can now use GPT-4 Turbo with a minor configuration change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are, however, some considerations when using planners:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Planners need to read all the functions in your kernel and
    combine them with the user request. The richer your kernel is, the more functionality
    you can give to your users, but it will take longer for the planner to go through
    all the descriptions and combine them. In addition, newer models such as GPT-4
    generate better plans, but they are slower, and future models could be even slower.
    You need to find a good balance between the number of functions you make available
    to your users and the models you use. When testing your application, if you find
    that the planner delay is noticeable, you will also need to incorporate UI cues
    into your application so that users know that something is happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**: Generating a plan can consume many tokens. If you have lots of functions,
    and the user request is complex, Semantic Kernel will need to submit a very long
    prompt to the AI service containing the descriptions of the functions available
    in your kernel, their inputs, and their outputs to the AI service, in addition
    to the user request. The generated plan may also be long, and the AI service will
    bill you for the cost of both the submitted prompt and the output. One way to
    avoid this is monitoring which requests users create frequently and saving plans
    for those so that they don’t have to be regenerated every time. Note, however,
    that if you save plans and there’s an upgrade in the backend model (for example,
    GPT-5 is launched), you have to remember to re-generate these plans to take advantage
    of the new model’s capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Using a planner makes testing your application a lot harder. For
    example, it’s possible that your kernel has so many functions and that the user
    requests can be so complex that the planner will exceed the context window of
    the model you are using. You will need to do something to handle this runtime
    error, such as limiting the size of the user requests or the number of functions
    available in your kernel. In addition, while the planner works most of the time,
    it’s possible that the planner will occasionally produce faulty plans, such as
    plans that hallucinate functions. You will need to provide error handling for
    that. Interestingly, in practice, the simple error-handling technique of just
    resubmitting the failed plan, telling the AI service that the plan didn’t work,
    and asking “*can you fix it?*” usually works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all that in mind, let’s see how to use the planner. The first step is to
    instantiate a planner.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating a planner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instantiating and using a planner is straightforward. In C#, we are going to
    use the Handlebars planner, and in Python, we will use the Stepwise planner.
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: 'C# includes the new `HandlebarsPlanner`, which allows you to create plans that
    include loops, making them shorter. Before using the Handlebars planner in C#,
    you need to install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure your Handlebars planner, you will also need to install the OpenAI
    planner connector with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the planner is experimental, and C# will give you an error unless
    you let it know that you are OK with using experimental code, by adding a `pragma`
    directive to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a planner, we execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft recommends using a low `Temperature` and `TopP` for your planners,
    minimizing the chance of the planner creating non-existent functions. Planners
    may consume lots of tokens; therefore, we usually set `MaxTokens` to a high value
    to avoid having a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how to create a planner in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, the Handlebar planner is not available yet, so we need to instantiate
    the Stepwise planner. Plans created by the Stepwise planner tend to be longer
    than Handlebars plans. To add the Stepwise planner to your Python project, you
    need to import the `FunctionCallingStepwisePlanner` and `FunctionCallingStepwisePlannerOptions`
    classes from the `semantic_kernel.planners` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s usually a good idea to give planners plenty of tokens. The following is
    a sample command to create a planner, assuming you loaded a service with `service_id`
    set to `gpt4` in your semantic kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s create and run a plan for a user request.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and running a plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a planner, we can use it to create a plan for a user’s request
    and then invoke the plan to get a result. In both languages, we use two steps,
    one to create the plan and another one to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next two code snippets, assume you have the user’s request loaded into
    the `ask` string. Let’s see how to call the planner:'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You may remember from [*Chapter 1*](B21826_01.xhtml#_idTextAnchor014) that in
    Python, the result variable contains all the steps to create the plan, so in order
    to see the plan’s results, you need to print `result.final_answer`. If you print
    the `result` variable, you’ll get a large JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: An example of how a planner can help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see a simple example that already shows how a planner can help. Let’s
    say you create an application that helps aspiring comedians create jokes. You
    create and connect it to the `jokes` semantic plugin that we created in [*Chapter
    1*](B21826_01.xhtml#_idTextAnchor014). That plugin contains a semantic function
    that creates knock-knock jokes.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a UI that allows users to enter a theme (say, “*dog*”) and call
    that function to create a knock-knock joke. If the user wants to create 100 jokes,
    they’ll need to use that UI 100 times. You can work around that problem by creating
    yet another UI that asks for the number of jokes the user wants to create. However,
    if the user wants to create multiple jokes for multiple themes, then they must
    use your two UIs for each theme they want to create a joke for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, with just the semantic function and the planner, you can allow
    your user to describe what they want in natural language, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: “*Create four knock-knock jokes – two about dogs, one about cats, and one* *about
    ducks*.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created our kernel and added our jokes plugin to it.
    Now, let’s create the planner.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the following results for both Python and C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that with a single user request and a single call to `invoke`, Semantic
    Kernel generated several responses, without you having to write any loop, create
    any additional UIs, or chain any functions yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How do planners work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behind the scenes, the planner uses an LLM prompt to generate a plan. As an
    example, you can see the prompt that is used by `HandlebarsPlanner` by navigating
    to its prompt file in the Semantic Kernel repository, located at [https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars](https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last few lines of the prompt are the most important to understand how the
    planner works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11] handlebars block until you''re done with all the steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '{{#each functions}}'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{doubleOpen}}{{PluginName}}{{../nameDelimiter}}{{Name}}{{doubleClose}}`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Description: {{Description}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '{{#each Parameters}}'
  prefs: []
  type: TYPE_NORMAL
- en: '- {{Name}}:'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if ParameterType}} {{ParameterType.Name}} -'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~else}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if Schema}} {{getSchemaTypeName this}} -{{/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if Description}} {{Description}}{{/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if IsRequired}} (required){{else}} (optional){{/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{/each}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if ReturnParameter}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if ReturnParameter.ParameterType}} {{ReturnParameter.ParameterType.Name}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~else}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if ReturnParameter.Schema}} {{getSchemaReturnTypeName ReturnParameter}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{else}} string{{/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{~#if ReturnParameter.Description}} - {{ReturnParameter.Description}}{{/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{/if}}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{/each}}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: using System.ComponentModel;
  prefs: []
  type: TYPE_NORMAL
- en: using Microsoft.SemanticKernel;
  prefs: []
  type: TYPE_NORMAL
- en: public class HomeAutomation
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '[KernelFunction, Description("Turns the lights of the living room, kitchen,
    bedroom or garage on or off.")]'
  prefs: []
  type: TYPE_NORMAL
- en: public string OperateLight(
  prefs: []
  type: TYPE_NORMAL
- en: '[Description("Whether to turn the lights on or off. Must be either ''on'' or
    ''off''")] string action,'
  prefs: []
  type: TYPE_NORMAL
- en: '[Description("The location where the lights must be turned on or off. Must
    be ''living room'', ''bedroom'', ''kitchen'' or ''garage''")] string location)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string[] validLocations = {"kitchen", "living room", "bedroom", "garage" };
  prefs: []
  type: TYPE_NORMAL
- en: if (validLocations.Contains(location))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string exAction = $"Changed status of the {location} lights to {action}.";
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(exAction);
  prefs: []
  type: TYPE_NORMAL
- en: return exAction;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string error = $"Invalid location {location} specified.";
  prefs: []
  type: TYPE_NORMAL
- en: return error;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[KernelFunction, Description("Opens or closes the windows of the living room
    or bedroom.")]'
  prefs: []
  type: TYPE_NORMAL
- en: public string OperateWindow(
  prefs: []
  type: TYPE_NORMAL
- en: '[Description("Whether to open or close the windows. Must be either ''open''
    or ''close''")] string action,'
  prefs: []
  type: TYPE_NORMAL
- en: '[Description("The location where the windows are to be opened or closed. Must
    be either ''living room'' or ''bedroom''")] string location)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string[] validLocations = {"living room", "bedroom"};
  prefs: []
  type: TYPE_NORMAL
- en: if (validLocations.Contains(location))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string exAction = $"Changed status of the {location} windows to {action}.";
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(exAction);
  prefs: []
  type: TYPE_NORMAL
- en: return exAction;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string error = $"Invalid location {location} specified.";
  prefs: []
  type: TYPE_NORMAL
- en: return error;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[KernelFunction, Description("Puts a movie on the TV in the living room or
    bedroom.")]'
  prefs: []
  type: TYPE_NORMAL
- en: public string OperateTV(
  prefs: []
  type: TYPE_NORMAL
- en: '[Description("The movie to play on the TV.")] string movie,'
  prefs: []
  type: TYPE_NORMAL
- en: '[Description("The location where the movie should be played on. Must be ''living
    room'' or ''bedroom''")] string location)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string[] validLocations = {"living room", "bedroom"};
  prefs: []
  type: TYPE_NORMAL
- en: if (validLocations.Contains(location))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string exAction = $"Playing {movie} on the TV in the {location}.";
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(exAction);
  prefs: []
  type: TYPE_NORMAL
- en: return exAction;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string error = $"Invalid location {location} specified.";
  prefs: []
  type: TYPE_NORMAL
- en: return error;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[KernelFunction, Description("Opens or closes the garage door.")]'
  prefs: []
  type: TYPE_NORMAL
- en: public string OperateGarageDoor(
  prefs: []
  type: TYPE_NORMAL
- en: '[Description("The action to perform on the garage door. Must be either ''open''
    or ''close''")] string action)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string exAction = $"Changed status of the garage door to {action}.";
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(exAction);
  prefs: []
  type: TYPE_NORMAL
- en: return exAction;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: from typing_extensions import Annotated
  prefs: []
  type: TYPE_NORMAL
- en: from semantic_kernel.functions.kernel_function_decorator import kernel_function
  prefs: []
  type: TYPE_NORMAL
- en: 'class HomeAutomation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '@kernel_function('
  prefs: []
  type: TYPE_NORMAL
- en: description="Opens or closes the windows of the living room or bedroom.",
  prefs: []
  type: TYPE_NORMAL
- en: name="OperateWindow",
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: def OperateWindow(self,
  prefs: []
  type: TYPE_NORMAL
- en: 'location: Annotated[str, "The location where the windows are to be opened or
    closed. Must be either ''living room'' or ''bedroom''"],'
  prefs: []
  type: TYPE_NORMAL
- en: 'action: Annotated[str, "Whether to open or close the windows. Must be either
    ''open'' or ''close''"]) \'
  prefs: []
  type: TYPE_NORMAL
- en: '-> Annotated[str, "The action that was performed on the windows."]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if location in ["living room", "bedroom"]:'
  prefs: []
  type: TYPE_NORMAL
- en: action = f"Changed status of the {location} windows to {action}."
  prefs: []
  type: TYPE_NORMAL
- en: print(action)
  prefs: []
  type: TYPE_NORMAL
- en: return action
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: error = f"Invalid location {location} specified."
  prefs: []
  type: TYPE_NORMAL
- en: return error
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '@kernel_function('
  prefs: []
  type: TYPE_NORMAL
- en: description="Turns the lights of the living room, kitchen, bedroom or garage
    on or off.",
  prefs: []
  type: TYPE_NORMAL
- en: name="OperateLight",
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: def OperateLight(self,
  prefs: []
  type: TYPE_NORMAL
- en: 'location: Annotated[str, "The location where the lights are to be turned on
    or off. Must be either ''living room'', ''kitchen'', ''bedroom'' or ''garage''"],'
  prefs: []
  type: TYPE_NORMAL
- en: 'action: Annotated[str, "Whether to turn the lights on or off. Must be either
    ''on'' or ''off''"])\'
  prefs: []
  type: TYPE_NORMAL
- en: '-> Annotated[str, "The action that was performed on the lights."]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if location in ["kitchen", "living room", "bedroom", "garage"]:'
  prefs: []
  type: TYPE_NORMAL
- en: action = f"Changed status of the {location} lights to {action}."
  prefs: []
  type: TYPE_NORMAL
- en: print(action)
  prefs: []
  type: TYPE_NORMAL
- en: return action
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: error = f"Invalid location {location} specified."
  prefs: []
  type: TYPE_NORMAL
- en: return error
  prefs: []
  type: TYPE_NORMAL
- en: '@kernel_function('
  prefs: []
  type: TYPE_NORMAL
- en: description="Puts a movie on the TV in the living room or bedroom.",
  prefs: []
  type: TYPE_NORMAL
- en: name="OperateTV",
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: def OperateTV(self,
  prefs: []
  type: TYPE_NORMAL
- en: 'movie: Annotated[str, "The movie to play on the TV."],'
  prefs: []
  type: TYPE_NORMAL
- en: 'location: Annotated[str, "The location where the movie should be played on.
    Must be ''living room'' or ''bedroom''"]'
  prefs: []
  type: TYPE_NORMAL
- en: )\
  prefs: []
  type: TYPE_NORMAL
- en: '-> Annotated[str, "The action that was performed on the TV."]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if location in ["living room", "bedroom"]:'
  prefs: []
  type: TYPE_NORMAL
- en: action = f"Playing {movie} on the TV in the {location}."
  prefs: []
  type: TYPE_NORMAL
- en: print(action)
  prefs: []
  type: TYPE_NORMAL
- en: return action
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: error = f"Invalid location {location} specified."
  prefs: []
  type: TYPE_NORMAL
- en: return error
  prefs: []
  type: TYPE_NORMAL
- en: '@kernel_function('
  prefs: []
  type: TYPE_NORMAL
- en: description="Opens or closes the garage door.",
  prefs: []
  type: TYPE_NORMAL
- en: name="OperateGarageDoor"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: def OperateGarageDoor(self,
  prefs: []
  type: TYPE_NORMAL
- en: 'action: Annotated[str, "The action to perform on the garage door. Must be either
    ''open'' or ''close''"])\'
  prefs: []
  type: TYPE_NORMAL
- en: '-> Annotated[str, "The action that was performed on the garage door."]:'
  prefs: []
  type: TYPE_NORMAL
- en: action = f"Changed the status of the garage door to {action}."
  prefs: []
  type: TYPE_NORMAL
- en: print(action)
  prefs: []
  type: TYPE_NORMAL
- en: return action
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Given the request below, suggest exactly one movie that you think the requestor
    is going to like. If the request is already a movie title, just return that movie
    title.
  prefs: []
  type: TYPE_NORMAL
- en: Respond only with the title of the movie, nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Request:'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ $input }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"schema": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "RecommendMovie",'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "completion",'
  prefs: []
  type: TYPE_NORMAL
- en: '"execution_settings": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"default": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"temperature": 0.8,'
  prefs: []
  type: TYPE_NORMAL
- en: '"number_of_responses": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"top_p": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"max_tokens": 4000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"presence_penalty": 0.0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"frequency_penalty": 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"input_variables": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "input",'
  prefs: []
  type: TYPE_NORMAL
- en: '"description": "name or description of a movie that the user wants to see.
    ",'
  prefs: []
  type: TYPE_NORMAL
- en: '"required": true'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
  prefs: []
  type: TYPE_NORMAL
- en: from semantic_kernel.planning.stepwise_planner import StepwisePlanner
  prefs: []
  type: TYPE_NORMAL
- en: import semantic_kernel as sk
  prefs: []
  type: TYPE_NORMAL
- en: from HomeAutomation import HomeAutomation
  prefs: []
  type: TYPE_NORMAL
- en: from dotenv import load_dotenv
  prefs: []
  type: TYPE_NORMAL
- en: import asyncio
  prefs: []
  type: TYPE_NORMAL
- en: 'async def fulfill_request(planner: StepwisePlanner, request):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Fulfilling request: " + request)'
  prefs: []
  type: TYPE_NORMAL
- en: variables = sk.ContextVariables()
  prefs: []
  type: TYPE_NORMAL
- en: plan = planner.create_plan(request)
  prefs: []
  type: TYPE_NORMAL
- en: result = await plan.invoke_async(variables)
  prefs: []
  type: TYPE_NORMAL
- en: print(result)
  prefs: []
  type: TYPE_NORMAL
- en: print("Request completed.\n\n")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'async def main():'
  prefs: []
  type: TYPE_NORMAL
- en: kernel = sk.Kernel()
  prefs: []
  type: TYPE_NORMAL
- en: api_key, org_id = sk.openai_settings_from_dot_env()
  prefs: []
  type: TYPE_NORMAL
- en: gpt4 = OpenAIChatCompletion("gpt-4", api_key, org_id)
  prefs: []
  type: TYPE_NORMAL
- en: kernel.add_chat_service("gpt4", gpt4)
  prefs: []
  type: TYPE_NORMAL
- en: planner = StepwisePlanner(kernel)
  prefs: []
  type: TYPE_NORMAL
- en: kernel.import_skill(HomeAutomation())
  prefs: []
  type: TYPE_NORMAL
- en: kernel.import_semantic_skill_from_directory("../plugins/MovieRecommender", "RecommendMovie")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: await fulfill_request(kernel, planner, "Turn on the lights in the kitchen")
  prefs: []
  type: TYPE_NORMAL
- en: await fulfill_request(kernel, planner, "Open the windows of the bedroom, turn
    the lights off and put on Shawshank Redemption on the TV.")
  prefs: []
  type: TYPE_NORMAL
- en: await fulfill_request(kernel, planner, "Close the garage door and turn off the
    lights in all rooms.")
  prefs: []
  type: TYPE_NORMAL
- en: await fulfill_request(kernel, planner, "Turn off the lights in all rooms and
    play a movie in which Tom Cruise is a lawyer in the living room.")
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: load_dotenv()
  prefs: []
  type: TYPE_NORMAL
- en: asyncio.run(main())
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: using Microsoft.SemanticKernel;
  prefs: []
  type: TYPE_NORMAL
- en: using Microsoft.SemanticKernel.Planning.Handlebars;
  prefs: []
  type: TYPE_NORMAL
- en: '#pragma warning disable SKEXP0060'
  prefs: []
  type: TYPE_NORMAL
- en: var (apiKey, orgId) = Settings.LoadFromFile();
  prefs: []
  type: TYPE_NORMAL
- en: var builder = Kernel.CreateBuilder();
  prefs: []
  type: TYPE_NORMAL
- en: builder.AddOpenAIChatCompletion("gpt-4", apiKey, orgId);
  prefs: []
  type: TYPE_NORMAL
- en: builder.Plugins.AddFromType<HomeAutomation>();
  prefs: []
  type: TYPE_NORMAL
- en: builder.Plugins.AddFromPromptDirectory("../../../plugins/MovieRecommender");
  prefs: []
  type: TYPE_NORMAL
- en: var kernel = builder.Build();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: void FulfillRequest(HandlebarsPlanner planner, string ask)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine($"Fulfilling request: {ask}");'
  prefs: []
  type: TYPE_NORMAL
- en: var plan = planner.CreatePlanAsync(kernel, ask).Result;
  prefs: []
  type: TYPE_NORMAL
- en: var result = plan.InvokeAsync(kernel, []).Result;
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Request complete.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: var plannerOptions = new HandlebarsPlannerOptions()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ExecutionSettings = new OpenAIPromptExecutionSettings()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Temperature = 0.0,
  prefs: []
  type: TYPE_NORMAL
- en: TopP = 0.1,
  prefs: []
  type: TYPE_NORMAL
- en: MaxTokens = 4000
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: AllowLoops = true
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: var planner = new HandlebarsPlanner(plannerOptions);
  prefs: []
  type: TYPE_NORMAL
- en: FulfillRequest(planner, "Turn on the lights in the kitchen");
  prefs: []
  type: TYPE_NORMAL
- en: FulfillRequest(planner, "Open the windows of the bedroom, turn the lights off
    and put on Shawshank Redemption on the TV.");
  prefs: []
  type: TYPE_NORMAL
- en: FulfillRequest(planner, "Close the garage door and turn off the lights in all
    rooms.");
  prefs: []
  type: TYPE_NORMAL
- en: FulfillRequest(planner, "Turn off the lights in all rooms and play a movie in
    which Tom Cruise is a lawyer in the living room.");
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Fulfilling request: Turn on the lights in the kitchen'
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the kitchen lights to on.
  prefs: []
  type: TYPE_NORMAL
- en: Request complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fulfilling request: Open the windows of the bedroom, turn the lights off and
    put on Shawshank Redemption on the TV.'
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the bedroom windows to open.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the bedroom lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Playing Shawshank Redemption on the TV in the bedroom.
  prefs: []
  type: TYPE_NORMAL
- en: Request complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fulfilling request: Close the garage door and turn off the lights in all rooms.'
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the garage door to close.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the living room lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the bedroom lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the kitchen lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the garage lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Request complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fulfilling request: Turn off the lights in all rooms and play a movie in which
    Tom Cruise is a lawyer in the living room.'
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the living room lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the bedroom lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the kitchen lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Changed status of the garage lights to off.
  prefs: []
  type: TYPE_NORMAL
- en: Playing A Few Good Men on the TV in the living room.
  prefs: []
  type: TYPE_NORMAL
- en: Request complete.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The planner executed each request flawlessly, and you didn’t have to write any
    code. When the user asks something such as “*turn off the lights in all rooms*,”
    the planner realizes that it needs to call the function for the kitchen, the bedroom,
    the living room, and the garage.
  prefs: []
  type: TYPE_NORMAL
- en: When the user asks for a movie with Tom Cruise as a lawyer, the planner realizes
    that it needs to call a semantic function to find the name of the movie before
    calling the `OperateTV` function to put the movie on the TV, again without you
    having to write code for this explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the planner, a powerful function that allows
    users to execute very complex workflows with minimal effort on the developer’s
    part. We learned when to use the planner and what the potential issues are. We
    also learned how to use the planner, as well as how to write descriptions for
    the functions in our plugins in a way that makes it easier for the planner to
    combine them. We then saw a longer example of how to use the planner to let a
    user combine native and semantic functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore ways to make external data available to
    Semantic Kernel. Later we will pair search with external data to allow models
    to use large amounts of data that exceed models’ context windows.
  prefs: []
  type: TYPE_NORMAL
