<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Behavior Trees</h1>
                </header>
            
            <article>
                
<p><strong>Behavior trees</strong> (<strong>BTs</strong>) have been gaining popularity among game developers very steadily. Over the last decade, BTs have become the pattern of choice for many developers when it comes to implementing behavioral rules for their AI agents. Games such as <em>Halo</em> and <em>Gears of War</em> are among the more famous franchises to make extensive use of BTs. An abundance of computing power in PCs, gaming consoles, and mobile devices has made them a good option for implementing AI in games of all types and scopes.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The basics of a behavior tree</li>
<li>The benefits of using existing behavior tree solutions</li>
<li>How to implement our own behavior tree framework</li>
<li>How to implement a basic tree using our framework</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning the basics of behavior trees</h1>
                </header>
            
            <article>
                
<p>Behavior trees got their name from their hierarchical, branching system of nodes with a common parent, known as the root. As you've surely learned <span>by now </span><span>from reading this book, behavior trees too mimic the real thing they are named after—in this case, trees and their branching structure. If we were to visualize a behavior tree, it would look something like the following figure:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="114" width="235" src="assets/8fb25fdb-a320-469f-bc7a-41275648a156.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A basic tree structure</div>
<p>Of course, behavior trees can be made up of any number of nodes and child nodes. The nodes at the very end of the hierarchy are referred to as leaf nodes, just like a tree. Nodes can represent behaviors or tests. Unlike state machines, which rely on transition rules to traverse through them, a BT's flow is defined strictly by each node's order within the larger hierarchy. A BT begins evaluating from the top of the tree <span>(based on the preceding visualization)</span><span>, then continues through each child, which, in turn, runs through each of its children until a condition is met or the leaf node is reached. BTs always begin evaluating from the root node.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding different node types</h1>
                </header>
            
            <article>
                
<p>The names of the different types of node may vary depending on who you ask, and even nodes themselves are sometimes referred to as tasks. While the complexity of a tree is dependent entirely upon the needs of the AI, the high-level concepts about how BTs work are fairly easy to understand if we look at each component individually. The following is true for each node regardless of what type of node we're referring to. A node will always return one of the following states:</p>
<ul>
<li><strong>Success</strong>: The condition the node was checking for has been met.</li>
<li><strong>Failure</strong>: The condition the node was checking for was not, and will not, be met.</li>
<li><strong>Running</strong>: The validity of the condition the node is checking for has not been determined. Think of this as our "please wait" state.</li>
</ul>
<p>Due to the potential complexity of a BT, most implementations are asynchronous, which, at least for Unity, means that evaluating a tree will not block the game from continuing other operations. The evaluation process of the various nodes in a BT can take several frames, if necessary. If you had to evaluate several trees on any number of agents at a time, you can imagine how it would negatively affect the performance of the program to have to wait for each of them to return a true or false to the root node. This is why the "running" state is important.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining composite nodes</h1>
                </header>
            
            <article>
                
<p>Composite nodes are called so as they have one or more children. Their state is based entirely upon the result of evaluating their children, and while their children are being evaluated, they will be in a "running" state. There are a couple of composite node types, which are mostly defined by how their children are evaluated:</p>
<ul>
<li><strong>Sequences</strong>: The defining characteristic of a sequence is that the entire sequence of children needs to complete successfully in order for it to evaluate as a success itself. If any of the children at any step of the sequence return false, the sequence itself will report a failure. It is important to note that, in general, sequences are executed from left to right. The following figures show a successful sequence and a failed sequence, respectively:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="96" width="200" src="assets/b830e1a0-c291-4a84-a362-6692b4382d0c.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A successful sequence node</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="90" width="188" src="assets/713f4462-2fe4-48ae-b937-c0d4f1e675d0.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">An unsuccessful sequence node</div>
<ul>
<li><strong>Selectors</strong>: By comparison, selectors are much more forgiving parents to their children nodes. If any one of the children nodes in a selector sequence returns true, the selector says, "eh, good enough!" and returns true immediately, without evaluating any more of its children. The only way a selector node will return false is if all of its children are evaluated and none of them return a success.</li>
</ul>
<p>Of course, each composite node type has its use depending on the situation. You can think of the different types of sequence nodes as "and" and "or" conditionals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding decorator nodes</h1>
                </header>
            
            <article>
                
<p>The biggest difference between a composite node and a decorator node is that a decorator can have exactly one child, and one child only. At first, this may seem unnecessary as you would, in theory, be able to get the same functionality by containing the condition in the node itself rather than relying on its child, but the decorator node is special in that it essentially takes the state returned by the child and evaluates the response based on its own parameters. A decorator can even specify how its children are evaluated and how often they are evaluated. These are some common decorator types:</p>
<ul>
<li><strong>Inverter</strong>: Think of the inverter as a NOT modifier. It takes the opposite of the state returned by its child. For example, if the child returns TRUE, the decorator evaluates as FALSE, and vice versa. This is the equivalent of having the <kbd>!</kbd> operator in front of a Boolean in C#.</li>
<li><strong>Repeater</strong>: This repeats the evaluation of the child a specified (or infinite) number of times until it evaluates as either TRUE or FALSE as determined by the decorator. For example, you may want to wait indefinitely until a certain condition is met, such as "having enough energy" before a character uses an attack.</li>
<li><strong>Limiter</strong>: This simply limits the number of times a node will be evaluated to avoid getting an agent stuck in an awkward infinite behavior loop. This decorator, in contrast to the repeater, can be used to make sure a character only tries to, for example, kick the door open so many times before giving up and trying something else.</li>
</ul>
<p>Some decorator nodes can be used for debugging and testing your trees, for example:</p>
<ul>
<li><strong>Fake state</strong>: This always evaluates true or false as specified by the decorator. This is very helpful for asserting certain behavior in your agent. For example, you can also have the decorator maintain a fake "running" state indefinitely to see how other agents around it will behave.</li>
<li><strong>Breakpoint</strong>: Just like a breakpoint in code, you can have this node fire off logic to notify you via debug logs or other methods that the node has been reached.</li>
</ul>
<p>These types are not monolithic archetypes that are mutually exclusive. You can combine these types of nodes to suit your needs. Just be careful not to combine too much functionality into one decorator to the point where it may be more efficient or convenient to use a sequence node instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Describing the leaf node</h1>
                </header>
            
            <article>
                
<p>We briefly covered leaf nodes earlier in the chapter to make a point about the structure of a BT, but leaf nodes, in reality, can be just about any sort of behavior. They are magical in the sense that they can be used to describe any sort of logic your agent can have. A leaf node can specify a walk function, shoot command, or kick action. It doesn't matter what it does or how you decide to have it evaluate its states, it just has to be the last node in its own hierarchy and return any of the three states a node can return.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating the existing solutions</h1>
                </header>
            
            <article>
                
<p>The Unity asset store is an excellent resource for developers. Not only are you able to purchase art, audio, and other kinds of assets, but it is also populated with a large number of plugins and frameworks. Most relevant to our purposes, there are a number of behavior tree plugins available on the asset store, ranging from free to a few hundred dollars. Most, if not all, provide some sort of GUI to make visualizing and arranging a fairly painless experience.</p>
<p>There are many advantages of going with an off-the-shelf solution from the asset store. Many of the frameworks include advanced functionality such as runtime (and often visual) debugging, robust APIs, serialization, and data-oriented tree support. Many even include sample leaf logic nodes to use in your game, minimizing the amount of coding you have to do to get up and running.</p>
<p>The previous edition of this book, <em>Unity 4.x Game AI Programming</em>, focused on developer AngryAnt's Behave plugin, which is currently available as Behave 2 for Unity on the asset store as a paid plugin, which continues to be an excellent choice for your behavior tree needs (and so much more). It is a very robust, performant, and excellently designed framework.</p>
<p>Some other alternatives are <strong>Behavior Machine</strong> and <strong>Behavior Designer</strong>, which offer different pricing tiers (Behavior Machine even offers a free edition) and a wide array of useful features. Many other options can be found for free around the web as both generic C# and Unity-specific implementations. Ultimately, as with any other system, the choice of rolling your own or using an existing solution will depend on your time, budget, and project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a basic behavior tree framework</h1>
                </header>
            
            <article>
                
<p>While a fully-fledged implementation of a behavior tree with a GUI and its many node types and variations is outside the scope of this book, we can certainly focus on the core principles to get a solid grasp of what the concepts we've covered in this chapter look like in action. Provided with this chapter is the basic framework for a behavior tree. Our example will focus on simple logic to highlight the functionality of the tree, rather than muddy up the example with complex game logic. The goal of our example is to make you feel comfortable with what can seem like an intimidating concept in game AI, and give you the necessary tools to build your own tree and expand upon the provided code if you do so.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a base Node class</h1>
                </header>
            
            <article>
                
<p>There is a base functionality that needs to go into every node. Our simple framework will have all the nodes derived from a base abstract <kbd>Node.cs</kbd> class. This class will provide said base functionality or at least the signature to expand upon that functionality:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
[System.Serializable] 
public abstract class Node { 
 
    /* Delegate that returns the state of the node.*/ 
    public delegate NodeStates NodeReturn(); 
 
    /* The current state of the node */ 
    protected NodeStates m_nodeState; 
 
    public NodeStates nodeState { 
        get { return m_nodeState; } 
    } 
 
    /* The constructor for the node */ 
    public Node() {} 
 
    /* Implementing classes use this method to evaluate the desired set of conditions */ 
    public abstract NodeStates Evaluate(); 
 
} </pre>
<p>The class is fairly simple. Think of <kbd>Node.cs</kbd> as a blueprint for all the other node types to be built upon. We begin with the <kbd>NodeReturn</kbd> delegate, which is not implemented in our example, but the next two fields are. However, <kbd>m_nodeState</kbd> is the state of a node at any given point. As we learned earlier, it will be either <kbd>FAILURE</kbd>, <kbd>SUCCESS</kbd>, or <kbd>RUNNING</kbd>. The <kbd>nodeState</kbd> value is simply a getter for <kbd>m_nodeState</kbd> since it is protected and we don't want any other area of the code directly setting <kbd>m_nodeState</kbd> inadvertently.</p>
<p>Next, we have an empty constructor, for the sake of being explicit, even though it is not being used. Lastly, we have the meat and potatoes of our <kbd>Node.cs</kbd> class—the <kbd>Evaluate()</kbd> method. As we'll see in the classes that implement <kbd>Node.cs</kbd>, <kbd>Evaluate()</kbd> is where the magic happens. It runs the code that determines the state of the node.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending nodes to selectors</h1>
                </header>
            
            <article>
                
<p>To create a selector, we simply expand upon the functionality that we described in the <kbd>Node.cs</kbd> class:</p>
<pre>using UnityEngine; 
using System.Collections; 
using System.Collections.Generic; 
 
public class Selector : Node { 
    /** The child nodes for this selector */ 
    protected List&lt;Node&gt; m_nodes = new List&lt;Node&gt;(); 
 
 
    /** The constructor requires a lsit of child nodes to be  
     * passed in*/ 
    public Selector(List&lt;Node&gt; nodes) { 
        m_nodes = nodes; 
    } 
 
    /* If any of the children reports a success, the selector will 
     * immediately report a success upwards. If all children fail, 
     * it will report a failure instead.*/ 
    public override NodeStates Evaluate() { 
        foreach (Node node in m_nodes) { 
            switch (node.Evaluate()) { 
                case NodeStates.FAILURE: 
                    continue; 
                case NodeStates.SUCCESS: 
                    m_nodeState = NodeStates.SUCCESS; 
                    return m_nodeState; 
                case NodeStates.RUNNING: 
                    m_nodeState = NodeStates.RUNNING; 
                    return m_nodeState; 
                default: 
                    continue; 
            } 
        } 
        m_nodeState = NodeStates.FAILURE; 
        return m_nodeState; 
    } 
} </pre>
<p>As we learned earlier in the chapter, selectors are composite nodes: this means that they have one or more child nodes. These child nodes are stored in the <kbd>m_nodes List&lt;Node&gt;</kbd> variable. Although it's conceivable that one could extend the functionality of this class to allow adding more child nodes after the class has been instantiated, we initially provide this list via the constructor.</p>
<p>The next portion of the code is a bit more interesting as it shows us a real implementation of the concepts we learned earlier. The <kbd>Evaluate()</kbd> method runs through all of its child nodes and evaluates each one individually. As a failure doesn't necessarily mean a failure for the entire selector, if one of the children returns <kbd>FAILURE</kbd>, we simply continue on to the next one. Inversely, if any child returns <kbd>SUCCESS</kbd>, then we're all set; we can set this node's state accordingly and return that value. If we make it through the entire list of child nodes and none of them have returned <kbd>SUCCESS</kbd>, then we can essentially determine that the entire selector has failed and we assign and return a <kbd>FAILURE</kbd> state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving on to sequences</h1>
                </header>
            
            <article>
                
<p>Sequences are very similar in their implementation, but as you might have guessed by now, the <kbd>Evaluate()</kbd> method behaves differently:</p>
<pre>using UnityEngine; 
using System.Collections; 
using System.Collections.Generic; 
 
public class Sequence : Node { 
    /** Children nodes that belong to this sequence */ 
    private List&lt;Node&gt; m_nodes = new List&lt;Node&gt;(); 
 
    /** Must provide an initial set of children nodes to work */ 
    public Sequence(List&lt;Node&gt; nodes) { 
        m_nodes = nodes; 
    } 
 
    /* If any child node returns a failure, the entire node fails. Whence all  
     * nodes return a success, the node reports a success. */ 
    public override NodeStates Evaluate() { 
        bool anyChildRunning = false; 
         
        foreach(Node node in m_nodes) { 
            switch (node.Evaluate()) { 
                case NodeStates.FAILURE: 
                    m_nodeState = NodeStates.FAILURE; 
                    return m_nodeState;                     
                case NodeStates.SUCCESS: 
                    continue; 
                case NodeStates.RUNNING: 
                    anyChildRunning = true; 
                    continue; 
                default: 
                    m_nodeState = NodeStates.SUCCESS; 
                    return m_nodeState; 
            } 
        } 
        m_nodeState = anyChildRunning ? NodeStates.RUNNING : NodeStates.SUCCESS; 
        return m_nodeState; 
    } 
} </pre>
<p>The <kbd>Evaluate()</kbd> method in a sequence will need to return true for all the child nodes, and if any one of them fails during the process, the entire sequence fails, which is why we check for <kbd>FAILURE</kbd> first and set and report it accordingly. A <kbd>SUCCESS</kbd> state simply means we get to live to fight another day, and we continue on to the next child node. If any of the child nodes are determined to be in the <kbd>RUNNING</kbd> state, we report that as the state for the node, and then the parent node or the logic driving the entire tree can evaluate it again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a decorator as an inverter</h1>
                </header>
            
            <article>
                
<p>The structure of <kbd>Inverter.cs</kbd> is a bit different, but it derives from <kbd>Node</kbd>, just like the rest of the nodes. Let's take a look at the code and spot the differences:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class Inverter : Node { 
    /* Child node to evaluate */ 
    private Node m_node; 
 
    public Node node { 
        get { return m_node; } 
    } 
 
    /* The constructor requires the child node that this inverter decorator 
     * wraps*/ 
    public Inverter(Node node) { 
        m_node = node; 
    } 
 
    /* Reports a success if the child fails and 
     * a failure if the child succeeds. Running will report 
     * as running */ 
    public override NodeStates Evaluate() { 
        switch (m_node.Evaluate()) { 
            case NodeStates.FAILURE: 
                m_nodeState = NodeStates.SUCCESS; 
                return m_nodeState; 
            case NodeStates.SUCCESS: 
                m_nodeState = NodeStates.FAILURE; 
                return m_nodeState; 
            case NodeStates.RUNNING: 
                m_nodeState = NodeStates.RUNNING; 
                return m_nodeState; 
        } 
        m_nodeState = NodeStates.SUCCESS; 
        return m_nodeState; 
    } 
}</pre>
<p>As you can see, since a decorator only has one child, we don't have <kbd>List&lt;Node&gt;</kbd>, but rather a single node variable, <kbd>m_node</kbd>. We pass this node in via the constructor (essentially requiring it), but there is no reason you couldn't modify this code to provide an empty constructor and a method to assign the child node after instantiation.</p>
<p>The <kbd>Evalute()</kbd> implementation implements the behavior of an inverter that we described earlier in the chapter: when the child evaluates as <kbd>SUCCESS</kbd>, the inverter reports a <kbd>FAILURE</kbd>, and when the child evaluates as <kbd>FAILURE</kbd>, the inverter reports a <kbd>SUCCESS</kbd>. The <kbd>RUNNING</kbd> state is reported normally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a generic action node</h1>
                </header>
            
            <article>
                
<p>Now we arrive at <kbd>ActionNode.cs</kbd>, which is a generic leaf node to pass in some logic via a delegate. You are free to implement leaf nodes in any way that fits your logic, as long as it derives from <kbd>Node</kbd>. This particular example is equal parts flexible and restrictive. It's flexible in the sense that it allows you to pass in any method matching the delegate signature, but is restrictive for this very reason—it only provides one delegate signature that doesn't take in any arguments:</p>
<pre>using System; 
using UnityEngine; 
using System.Collections; 
 
public class ActionNode : Node { 
    /* Method signature for the action. */ 
    public delegate NodeStates ActionNodeDelegate(); 
 
    /* The delegate that is called to evaluate this node */ 
    private ActionNodeDelegate m_action; 
 
    /* Because this node contains no logic itself, 
     * the logic must be passed in in the form of  
     * a delegate. As the signature states, the action 
     * needs to return a NodeStates enum */ 
    public ActionNode(ActionNodeDelegate action) { 
        m_action = action; 
    } 
 
    /* Evaluates the node using the passed in delegate and  
     * reports the resulting state as appropriate */ 
    public override NodeStates Evaluate() { 
        switch (m_action()) { 
            case NodeStates.SUCCESS: 
                m_nodeState = NodeStates.SUCCESS; 
                return m_nodeState; 
            case NodeStates.FAILURE: 
                m_nodeState = NodeStates.FAILURE; 
                return m_nodeState; 
            case NodeStates.RUNNING: 
                m_nodeState = NodeStates.RUNNING; 
                return m_nodeState; 
            default: 
                m_nodeState = NodeStates.FAILURE; 
                return m_nodeState; 
        } 
    } 
} </pre>
<p>The key for making this node work is the <kbd>m_action</kbd> delegate. For those familiar with C++, a delegate in C# can be thought of as a function pointer of sorts. You can also think of a delegate as a variable containing (or more accurately, pointing to) a function. This allows you to set the function to be called at runtime. The constructor requires you to pass in a method matching its signature, and is expecting that method to return a <kbd>NodeStates</kbd> enum. That method can implement any logic you want, as long as these conditions are met. Unlike other nodes we've implemented, this one doesn't fall through to any state outside of the switch itself, so it defaults to a <kbd>FAILURE</kbd> state. You may choose to default to a <kbd>SUCCESS</kbd> or <kbd>RUNNING</kbd> state, if you so wish, by modifying the default return.</p>
<p>You can easily expand on this class by deriving from it or simply making the changes to it that you need. You can also skip this generic action node altogether and implement one-off versions of specific leaf nodes, but it's good practice to reuse as much code as possible. Just remember to derive from <kbd>Node</kbd> and implement the required code!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing our framework</h1>
                </header>
            
            <article>
                
<p>The framework that we just reviewed is nothing more than this. It provides us with all the functionality we need to make a tree, but we have to make the actual tree ourselves. For the purposes of this book, a somewhat manually constructed tree is provided.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Planning ahead</h1>
                </header>
            
            <article>
                
<p>Before we set up our tree, let's look at what we're trying to accomplish. It is often helpful to visualize a tree before implementing it. Our tree will count up from zero to a specified value. Along the way, it will check whether certain conditions are met for that value and report its state accordingly. The following diagram illustrates the basic hierarchy for our tree:</p>
<div class="CDPAlignCenter CDPAlign"><img height="96" width="129" src="assets/c0d1c39a-65d9-4ff9-978c-b834ab6f2d10.png"/></div>
<p>For our tests, we will use a three-tier tree, including the root node:</p>
<ul>
<li><strong>Node 1</strong>: This is our root node. It has children, and we want to be able to return a success if any of the children are a success, so we'll implement it as a selector.</li>
<li><strong>Node 2a</strong>: We'll implement this node using an <kbd>ActionNode</kbd>.</li>
<li><strong>Node 2b</strong>: We'll use this node to demonstrate how our inverter works.</li>
<li><strong>Node 2c</strong>: We'll run the same <kbd>ActionNode</kbd> from node <strong>2a</strong> again, and see how that affects our tree's evaluation.</li>
<li><strong>Node 3</strong>: Node <strong>3</strong> happens to be the lone node in the third tier of the tree. It is the child of the <strong>2b</strong> decorator node. This means that if it reports <kbd>SUCCESS</kbd>, <strong>2b</strong> will report a <kbd>FAILURE</kbd>, and vice versa.</li>
</ul>
<p>At this point, we're still a bit vague on the implementation details, but the preceding diagram will help us to visualize our tree as we implement it in code. Keep it handy for reference as we go through the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examining our scene setup</h1>
                </header>
            
            <article>
                
<p>We've now looked at the basic structure of our tree, and before we jump in and dig into the actual code implementation, let's look at our scene setup. The following screenshot shows our hierarchy; the nodes are highlighted for emphasis:</p>
<div class="CDPAlignCenter CDPAlign"><img height="222" width="223" src="assets/5b10126b-cb0d-411d-b231-77911792460a.png"/></div>
<p>The setup is quite simple. There is a quad with a world-space canvas, which is simply to display some information during the test. The nodes highlighted in the preceding screenshot will be referenced in the code later, and we'll be using them to visualize the status of each individual node. The actual scene looks something like the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="136" width="242" src="assets/d4cd6829-b2ae-44fd-b785-2c6b0611cc40.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Our actual layout mimics the diagram we created earlier</div>
<p>As you can see, we have one node or box representing each of the nodes that we laid out in our planning phase. These are referenced in the actual test code and will be changing colors according to the state that is returned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the MathTree code</h1>
                </header>
            
            <article>
                
<p>Without further ado, let's have a look at the code driving our test. This is <kbd>MathTree.cs</kbd>:</p>
<pre>using UnityEngine; 
using UnityEngine.UI; 
using System.Collections; 
using System.Collections.Generic; 
 
public class MathTree : MonoBehaviour { 
    public Color m_evaluating; 
    public Color m_succeeded; 
    public Color m_failed; 
 
    public Selector m_rootNode; 
 
    public ActionNode m_node2A; 
    public Inverter m_node2B; 
    public ActionNode m_node2C; 
    public ActionNode m_node3; 
 
    public GameObject m_rootNodeBox; 
    public GameObject m_node2aBox; 
    public GameObject m_node2bBox; 
    public GameObject m_node2cBox; 
    public GameObject m_node3Box; 
 
    public  int m_targetValue = 20; 
    private int m_currentValue = 0; 
 
    [SerializeField] 
    private Text m_valueLabel; </pre>
<p>The first few variables are simply used for debugging. The three color variables are the colors we'll be assigning to our node boxes to visualize their state. By default, <kbd>RUNNING</kbd> is yellow, <kbd>SUCCESS</kbd> is green, and <kbd>FAILED</kbd> is red. This is pretty standard stuff; let's move along.</p>
<p>We then declare our actual nodes. As you can see, <kbd>m_rootNode</kbd> is a selector, as we mentioned earlier. Notice that we do not assign any of the node variables yet, since we have to pass in some data to their constructors.</p>
<p>We then have the references to the boxes we saw in our scene. These are just game objects that we drag and drop into the inspector (we'll have a look at that after we inspect the code).</p>
<p>We then have a couple of <kbd>int</kbd> values, which will make more sense as we look at the logic, so we'll skip over these. Lastly, we have a unity UI Text variable that will display some values for us during the test.</p>
<p>Let's get into the initialization of our actual nodes:</p>
<pre>    /* We instantiate our nodes from the bottom up, and assign the children 
     * in that order */ 
   void Start () { 
        /** The deepest-level node is Node 3, which has no children. */ 
        m_node3 = new ActionNode(NotEqualToTarget); 
 
        /** Next up, we create the level 2 nodes. */ 
        m_node2A = new ActionNode(AddTen); 
 
        /** Node 2B is a selector which has node 3 as a child, so we'll pass  
         * node 3 to the constructor */ 
        m_node2B = new Inverter(m_node3); 
 
        m_node2C = new ActionNode(AddTen); 
 
        /** Lastly, we have our root node. First, we prepare our list of children 
         * nodes to pass in */ 
        List&lt;Node&gt; rootChildren = new List&lt;Node&gt;(); 
        rootChildren.Add(m_node2A); 
        rootChildren.Add(m_node2B); 
        rootChildren.Add(m_node2C); 
 
        /** Then we create our root node object and pass in the list */ 
        m_rootNode = new Selector(rootChildren); 
 
        m_valueLabel.text = m_currentValue.ToString(); 
 
        m_rootNode.Evaluate(); 
 
        UpdateBoxes(); 
   }</pre>
<p>For the sake of organization, we declare our nodes from the bottom of the tree to the top of the tree, or the root node. We do this because we cannot instantiate a parent without passing in its child nodes, so we have to instantiate the child nodes first. Notice that <kbd>m_node2A</kbd>, <kbd>m_node2C</kbd>, and <kbd>m_node3</kbd> are action nodes, so we pass in delegates (we'll look at these methods next). Then, <kbd>m_node2B</kbd>, being a selector, takes in a node as a child, in this case <kbd>m_node3</kbd>. After we've declared these tiers, we throw all the tier 2 nodes into a list because our tier 1 node, the root node, is a selector that requires a list of children to be instantiated.</p>
<p>After we've instantiated all of our nodes, we kick off the process and begin evaluating our root node using its <kbd>Evaluate()</kbd> method. The <kbd>UpdateBoxes()</kbd> method simply updates the <kbd>box</kbd> game objects that we declared earlier with the appropriate colors; we'll look at that later on in this section:</p>
<pre>private void UpdateBoxes() { 
        /** Update root node box */ 
        if (m_rootNode.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_rootNodeBox); 
        } else if (m_rootNode.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_rootNodeBox); 
        } 
 
        /** Update 2A node box */ 
        if (m_node2A.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node2aBox); 
        } else if (m_node2A.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node2aBox); 
        } 
 
        /** Update 2B node box */ 
        if (m_node2B.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node2bBox); 
        } else if (m_node2B.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node2bBox); 
        } 
 
        /** Update 2C node box */ 
        if (m_node2C.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node2cBox); 
        } else if (m_node2C.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node2cBox); 
        } 
 
        /** Update 3 node box */ 
        if (m_node3.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node3Box); 
        } else if (m_node3.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node3Box); 
        } 
    } </pre>
<p>There is not a whole lot to discuss here. Do notice that, because we set this tree up manually, we check each node individually and get its <kbd>nodeState</kbd> and set the colors using the <kbd>SetSucceeded</kbd> and <kbd>SetFailed</kbd> methods. Let's move on to the meaty part of the class:</p>
<pre>private NodeStates NotEqualToTarget() {         
        if (m_currentValue != m_targetValue) { 
            return NodeStates.SUCCESS; 
        } else { 
            return NodeStates.FAILURE; 
        } 
    } 
 
    private NodeStates AddTen() { 
        m_currentValue += 10; 
        m_valueLabel.text = m_currentValue.ToString(); 
        if (m_currentValue == m_targetValue) { 
            return NodeStates.SUCCESS; 
        } else { 
            return NodeStates.FAILURE; 
        } 
    } </pre>
<p>First, we have <kbd>NotEqualToTarget()</kbd>, which is the method we passed into our decorator's child action node. We're essentially setting ourselves up for a double negative here, so try to follow along. This method returns a success if the current value is <em>not</em> equal to the target value, and returns false otherwise. The parent inverter decorator will then evaluate to the opposite of what this node returns. So, if the value is not equal, the inverter node will fail; otherwise, it will succeed. If you're feeling a bit lost at this point, don't worry. It will all make sense when we see this in action.</p>
<p>The next method is the <kbd>AddTen()</kbd> method, which is the method passed into our other two action nodes. It does exactly what the name implies—it adds 10 to our <kbd>m_currentValue</kbd> variable, then checks whether it's equal to our <kbd>m_targetValue</kbd>, and evaluates as <kbd>SUCCESS</kbd> if so, and <kbd>FAILURE</kbd> if not.</p>
<p>The last few methods are self-explanatory so we will not go over them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing the test</h1>
                </header>
            
            <article>
                
<p>Now that we have a pretty good idea of how the code works, let's see it in action. First things first, however. Let's make sure our component is properly set up. Select the <span class="packt_screen">Tree</span> game object from the hierarchy, and its inspector should look similar to this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="279" width="307" src="assets/53ca85d6-29e9-4025-a991-7409bda131a8.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The default settings for the component</div>
<p>As you can see, the state colors and box references have already been assigned for you, as well as the <kbd>m_valueLabel</kbd> variable. The <kbd>m_targetValue</kbd> variable has also been assigned for you via code. Make sure to leave it at (or set it to) 20 before you hit play. Play the scene, and you'll see your boxes lit up, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="122" width="218" src="assets/30f951fc-e54e-4b01-946c-39cddfcb89c0.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The boxes lit up, indicating the result of each node's evaluation</div>
<p>As we can see, our root node evaluated to <kbd>SUCCESS</kbd>, which is what we intended, but let's examine why, one step at a time, starting at tier 2:</p>
<ul>
<li><strong>Node 2A</strong>: We started with <kbd>m_currentValue</kbd> at <kbd>0</kbd>, so upon adding <kbd>10</kbd> to it, it's still not equal to our <kbd>m_targetValue</kbd> (<kbd>20</kbd>) and it fails. Thus, it is red.</li>
<li><strong>Node 2B</strong>: As it evaluates its child, once again, <kbd>m_currentValue</kbd> and <kbd>m_targetValue</kbd> are not equal. This returns <kbd>SUCCESS</kbd>. Then, the inverter logic kicks in and reverses this response so that it reports <kbd>FAILURE</kbd> for itself. So, we move on to the last node.</li>
<li><strong>Node 2C</strong>: Once again, we add <kbd>10</kbd> to <kbd>m_currentValue</kbd>. It then becomes <kbd>20</kbd>, which is equal to <kbd>m_targetValue</kbd>, and evaluates as <kbd>SUCCESS</kbd>, so our root node is successful as a result.</li>
</ul>
<p>The test is simple, but it illustrates the concepts clearly. Before we consider the test a success, let's run it one more time, but change <kbd>m_targetValue</kbd> first. Set it to <kbd>30</kbd> in the inspector, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/05297735-8c83-48f3-9238-37fc70d5a36f.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The updated value is highlighted</div>
<p>A small change, to be sure, but it will change how the entire tree evaluates. Play the scene again, and we will end up with the set of nodes lit up, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="149" width="266" src="assets/abe6813b-80d5-4d18-998c-3e6956516a24.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A clearly different result from our first test</div>
<p>As you can see, all but one of the child nodes of our root failed, so it reports <kbd>FAILURE</kbd> for itself. Let's look at why:</p>
<ul>
<li><strong>Node 2A</strong>: Nothing really changes here from our original example. Our <kbd>m_currentValue</kbd> variable starts at <kbd>0</kbd> and ends up at <kbd>10</kbd>, which is not equal to our <kbd>m_targetValue</kbd> of <kbd>30</kbd>, so it fails.</li>
<li><strong>Node 2B</strong>: This evaluates its child once more, and because the child node reports <kbd>SUCCESS</kbd>, it reports <kbd>FAILURE</kbd> for itself, and we move on to the next node.</li>
<li><strong>Node 2C</strong>: Once again, we add <kbd>10</kbd> to our <kbd>m_currentValue</kbd> variable, adding up to <kbd>20</kbd>, which, after having changed the <kbd>m_targetValue</kbd> variable, no longer evaluates to <kbd>SUCCESS</kbd>.</li>
</ul>
<p>The current implementation of the nodes will have unevaluated nodes default to <kbd>SUCCESS</kbd>. This is because of our enum order, as you can see in <kbd>NodeState.cs</kbd>:</p>
<pre>public enum NodeStates { 
    SUCCESS, 
    FAILURE, 
    RUNNING, 
} </pre>
<p>In our enum, <kbd>SUCCESS</kbd> is the first enumeration, so if a node never gets evaluated, the default value is never changed. If you were to change the <kbd>m_targetValue</kbd> variable to <kbd>10</kbd>, for example, all the nodes would light up to green. This is simply a by-product of our test implementation and doesn't actually reflect any design issues with our nodes. Our <kbd>UpdateBoxes()</kbd> method updates all the boxes whether they were evaluated or not. In this example, node <strong>2A</strong> would immediately evaluate as <kbd>SUCCESS</kbd>, which, in turn, would cause the root node to report <kbd>SUCCESS</kbd>, and neither node <strong>2B</strong>, <strong>2C</strong>, nor <strong>3</strong> would be evaluated at all, having no effect on the evaluation of the tree as a whole.</p>
<p>You are highly encouraged to play with this test. Change the root node implementation from a selector to a sequence, for example. By simply changing <kbd>public Selector m_rootNode;</kbd> to <kbd>public Sequence m_rootNode;</kbd> and <kbd>m_rootNode = new Selector(rootChildren);</kbd> to <kbd>m_rootNode = new Sequence(rootChildren);</kbd>, you can test a completely different set of functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HomeRock card game example</h1>
                </header>
            
            <article>
                
<p>To further illustrate potential uses for BTs, let's take a look at the second example for this chapter included in the sample code. In the <kbd>CardGame</kbd> Unity scene, you'll find an implementation of a turn-based card game, where the player and the AI opponent have three different abilities: attack, heal, and defend. The user gets to pick which ability to use on their turn, and the AI will use a BT to decide which course of action to take. The game ends when a player reaches 0 hit points. The following image illustrates our game view:</p>
<div class="CDPAlignCenter CDPAlign"><br/>
<img height="166" width="297" class="aligncenter size-full wp-image-415 image-border" src="assets/edbf4249-ce47-411a-8f09-b2f88adf1cf0.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Game screen for HomeRock—Heroes of Unity</div>
<p>As you can see here, the player can select their attack by clicking on one of the cards, which have been spruced up with some flavor text. The player's hit points are displayed in the lower-left corner, and the AI enemy's hit points are displayed in the top-right corner of the screen. The premise is simple, even if the example is a bit silly. Let's take a look at the scene setup before we dive into the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The scene setup</h1>
                </header>
            
            <article>
                
<p>There are quite a few things going on in this scene, as this example is a bit more complex than previous ones in this book. We'll touch on each element, but will keep our focus on the topic at hand: behavior trees. Let's take a look at the scene hierarchy, which looks like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="237" width="294" src="assets/fef2c18f-c18a-4b31-bbca-dc61b05fd4da.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The scene hierarchy</div>
<p class="mce-root">In the hierarchy depicted in this screenshot, we'll find a few game-related elements, and you may also notice that the canvas has quite a few elements nested under it.</p>
<p class="mce-root">The <span class="packt_screen">Game</span> game object has two components on it—the Animator, which controls the game states, and the <kbd>Game.cs</kbd> component, which controls the game flow and rules. First, let's take a look at the game states. The Animator has a reference to the <kbd>GameFlowStateMachine</kbd><strong>, </strong>which looks like this screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="224" width="367" src="assets/3f8240a2-b289-4426-97c5-48141acb07d2.png"/></div>
<p>The state machine depicted has a few boilerplate states, such as <strong>MainMenu</strong> and <strong>GameEnd</strong>. You'll notice that <strong>MainMenu</strong> is our entry point. While our sample doesn't have a main menu, you could use this state to implement your own. In the sample, the state just automatically transitions to the <strong>GameIntro</strong> state. Again, <strong>GameIntro</strong> is provided as a staging area for you to implement any intro sequences or animations, but defaults to transitioning to the next stage, <strong>MainGame</strong>. Finally, we have <strong>GameEnd</strong>, which you can transition to from any state, so long as you hit the <kbd>EndGame</kbd> trigger. You may have noticed that <strong>MainGame</strong> is a nested tree, and if we double-click on it to dive into its contents, we'll find a tree that looks like this screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="163" width="532" src="assets/173343d3-c345-43a8-9e30-796a1d003f3e.png"/></div>
<p>The setup shown in the previous screenshot is simple enough—there is a player turn and an enemy turn. These simply bounce back and forth whenever we set the <kbd>EndTurn</kbd> trigger. Next, we have our <kbd>Game.cs</kbd> component, which looks like this in the inspector:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="122" width="391" src="assets/ddc54488-6113-444e-8ff0-785c1c3f4bd0.png"/></div>
<p>In the previous screenshot, we can see that the <span class="packt_screen">Game</span> component has some references to other scripts in our scene. We'll get to those in a minute, but do notice that there is a reference to our state machine. Let's dive into the <kbd>Game.cs</kbd> code to see what's going on under the hood:</p>
<pre>using UnityEngine;<br/><br/>public class Game : MonoBehaviour {<br/>    [SerializeField]<br/>    private Animator stateMachine;<br/>    [SerializeField]<br/>    private PlayerController playerController;<br/>    [SerializeField]<br/>    private EnemyBehaviorTree enemyBehaviorTree;<br/>    [SerializeField]<br/>    private Player humanPlayer;<br/>    [SerializeField]<br/>    private Player aiPlayer;<br/>    [SerializeField]<br/>    private UIController uiController;<br/>    private int turn = 0;<br/><br/>    private void Awake() {<br/>        enemyBehaviorTree.SetPlayerData(humanPlayer, aiPlayer);<br/>        enemyBehaviorTree.onTreeExecuted += EndTurn;<br/>        playerController.onActionExecuted += EndTurn;<br/>    }<br/><br/>    public void EvaluateAITree() {<br/>        enemyBehaviorTree.Evaluate(); <br/>    }<br/><br/>    private void EndTurn() {<br/>        if(humanPlayer.CurrentHealth &lt;= 0 || aiPlayer.CurrentHealth &lt;= 0) {<br/>            stateMachine.SetTrigger("EndGame");<br/>            uiController.EndGame();<br/>            return;<br/>        }<br/>        stateMachine.SetTrigger("EndTurn");<br/>        turn ^= 1;<br/>        uiController.SetTurn(turn);<br/>    }<br/>}</pre>
<p>First, we have all the serialized values we saw in the inspector just a moment ago, along with a private, non-serialized value, the <kbd>turn</kbd> value. This value flips between 0 and 1 for the player's turn and the AI's turn, respectively. Our <kbd>Awake</kbd> method does some setup, it initializes values in the <kbd>EnemyBehaviorTree.cs</kbd> script, and it adds some callbacks to the enemy AI controller and our player controller.</p>
<p>The <kbd>EvaluateAITree()</kbd> method simply wraps the enemy's BT's <kbd>Evaluate()</kbd> method. We do this for some pseudo-decoupling. Lastly, the <kbd>EndTurn()</kbd> method does a few things: it checks whether either of the players' health is below 0, and ends the game if so; it also toggles the turn value, sets the appropriate trigger on the state machine, and updates the turn message on the <kbd>UIController</kbd>.</p>
<p>Next in our scene's hierarchy, nested under the <span class="packt_screen">Game</span> game object, we have a <span class="packt_screen">HumanPlayer</span> game object, and an <span class="packt_screen">EnemyAI</span> game object. Both have a <kbd>Player.cs</kbd> script, which simply contains data and methods that control that player's values. The screenshot here shows the values for the <span class="packt_screen">HumanPlayer</span> game object's <span class="packt_screen">Player</span> component:</p>
<div class="CDPAlignCenter CDPAlign"><img height="73" width="375" src="assets/8278b54c-7710-4075-afa4-9a43382c4310.png"/></div>
<p>In order to get a better idea of what the values shown in the preceding screenshot do, let's take a look at the <kbd>Player.cs</kbd> script and break it down:</p>
<pre>using UnityEngine;<br/><br/>public class Player : MonoBehaviour {<br/>    [SerializeField]<br/>    private int maxHealth = 20;<br/><br/>    [SerializeField]<br/>    private int currentHealth;<br/><br/>    [SerializeField]<br/>    private int lowHealthThreshold = 7;<br/><br/>    [Header("Ability Parameters")]<br/>    private int minHealAmount = 2;<br/>    private int maxHealAmount = 5;<br/><br/>    private int minDamage = 2;<br/>    private int maxDamage = 5;<br/><br/>    private bool isBuffed = false;<br/><br/>    public int CurrentHealth {<br/>        get { return currentHealth; }<br/>    }<br/><br/>    public bool IsBuffed {<br/>        get { return isBuffed; }<br/>    }<br/><br/>    public bool HasLowHealth {<br/>        get { return currentHealth &lt; lowHealthThreshold; }<br/>    }<br/><br/>    private void Awake() {<br/>        currentHealth = maxHealth;<br/>    }<br/><br/>    public bool Buff() {<br/>        isBuffed = true;<br/>        return isBuffed;<br/>    }<br/><br/>    public int Heal() {<br/>        int healAmount = Random.Range(minHealAmount, maxHealAmount);<br/>        currentHealth += healAmount;<br/>        return currentHealth;<br/>    }<br/><br/>    public int Damage() {<br/>        int damageAmount = Random.Range(minDamage, maxDamage);<br/>        if(isBuffed) {<br/>            damageAmount /= 2;<br/>            isBuffed = false;<br/>        } <br/>        currentHealth -= damageAmount;<br/>        return currentHealth;<br/>    }<br/>}</pre>
<p>The first few values are fairly simple. We have the player's max health represented by <kbd>maxHealth</kbd> and their current health represented by <kbd>currentHealth</kbd>. We use a value called <kbd>lowHealthThreshold</kbd> for the AI to make some decisions. It gives us the ability to modify the AI's behavior based on its or its opponent's health. </p>
<p>We then list out some ability parameters. The <kbd>minHealAmount</kbd> and <kbd>maxHealAmount</kbd> represent the healing ability's lower and upper limits, respectively. The same goes for the <kbd>minDamage</kbd> and <kbd>maxDamage</kbd> fields for the attack ability. In the case of <kbd>isBuffed</kbd>, we use a bool to represent whether or not the player is "buffed," which is a generic term in some game genres to denote that a character or player has a beneficial gameplay status. There are some properties and initialization in our <kbd>Awake</kbd> method, and then a series of ability methods. </p>
<p>The <kbd>Buff()</kbd> method simply sets the <kbd>isBuffed</kbd> value to true. We use this in our damage calculation later on. The <kbd>Heal()</kbd> method picks a random number between the range specified by <kbd>minHealAmount</kbd> and <kbd>maxHealAmount</kbd>, and restores that much health to the player's <kbd>currentHealth</kbd> value. Lastly, the <kbd>Damage()</kbd> method applies a random amount of damage to the player (by subtracting from its current health), which is halved when the player's <kbd>isBuffed</kbd> flag is set to true.</p>
<p>We can now take a look at the next component of the <span class="packt_screen">HumanPlayer</span> game object, the <kbd>PlayerController.cs</kbd> script. The component's inspector values can be seen in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="122" width="378" src="assets/e378e9c3-c256-4e55-adb3-4afd8cb3865a.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The inspector showing all the assigned values for the player controller</div>
<p>You'll notice some references to its own <kbd>Player.cs</kbd> component as well as the enemy AI's component. The <span class="packt_screen">Buttons</span> section contains references to the ability card's UI buttons. The code for the class looks like this:</p>
<pre>using UnityEngine;<br/>using UnityEngine.UI;<br/><br/>public class PlayerController : MonoBehaviour {<br/>    [SerializeField]<br/>    private Player ownData;<br/>    [SerializeField]<br/>    private Player enemyData;<br/><br/>    [Header("Buttons")]<br/>    [SerializeField]<br/>    private Button defendButton;<br/>    [SerializeField]<br/>    private Button healButton;<br/>    [SerializeField]<br/>    private Button attackButton;<br/><br/>    public delegate void ActionExecuted();<br/>    public event ActionExecuted onActionExecuted;<br/><br/>  void Awake () {<br/>        defendButton.onClick.AddListener(Defend);<br/>        healButton.onClick.AddListener(Heal);<br/>        attackButton.onClick.AddListener(Attack);<br/>  }<br/><br/>    private void Attack() {<br/>        enemyData.Damage();<br/>        EndTurn();<br/>    }<br/><br/>    private void Heal() {<br/>        ownData.Heal();<br/>        EndTurn();<br/>    }<br/>    <br/>    private void Defend() {<br/>        ownData.Buff();<br/>        EndTurn();<br/>    }<br/><br/>    private void EndTurn() {<br/>        if(onActionExecuted != null) {<br/>            onActionExecuted();<br/>        }<br/>    }<br/>}</pre>
<p>The variables up top are fairly straightforward, and they are the very values we just saw in the inspector. You'll also find an <kbd>onActionExecuted</kbd> event here, which, if you remember, gets assigned from the <kbd>Game.cs</kbd> script's <kbd>Awake()</kbd> function. In this class's <kbd>Awake()</kbd>, we assign an <kbd>onClick</kbd> handler for each of the buttons: <strong>Defend</strong>, <strong>Heal</strong>, and <strong>Attack</strong>. Each of the methods calls the appropriate ability method on the <kbd>Player.cs</kbd> script, and then calls <kbd>EndTurn()</kbd>, which, in turn, calls the <kbd>onActionExecuted</kbd> callback. Refer back to the <kbd>Game.cs</kbd> script for what that does.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The enemy state machine</h1>
                </header>
            
            <article>
                
<p>The <kbd>EnemyAI</kbd> game object has its own <kbd>Player.cs</kbd> script, as we saw earlier, but it also has the script we're most interested in: the <kbd>EnemyBehaviorTree.cs</kbd> component. This component contains the BT for our enemy agent, along with some helper functionality. Let's take a look at that code now:</p>
<pre>using UnityEngine;<br/>using System.Collections;<br/>using System.Collections.Generic;<br/><br/>public class EnemyBehaviorTree : MonoBehaviour {<br/>    <br/>    private Player playerData; <br/>    private Player ownData;<br/><br/>    public RandomBinaryNode buffCheckRandomNode;<br/>    public ActionNode buffCheckNode;<br/>    public ActionNode healthCheckNode;<br/>    public ActionNode attackCheckNode;<br/>    public Sequence buffCheckSequence;<br/>    public Selector rootNode;</pre>
<p>We start off with some declarations as usual. Most notably, we declare our nodes here. We have some familiar nodes, the <kbd>ActionNode</kbd>, the <kbd>Sequence</kbd>, and the <kbd>Selector</kbd>, which you should be familiar with by now. But you may have also noticed an unfamiliar node as well—the <kbd>RandomBinaryNode</kbd>.  Before digging deeper into the <kbd>EnemyBehaviorTree.cs</kbd> code, let's take a look at the <kbd>RandomBinaryNode.cs</kbd> file to see what this node type does:</p>
<pre>using UnityEngine;<br/><br/>public class RandomBinaryNode : Node {<br/>    public override NodeStates Evaluate() {<br/>        var roll = Random.Range(0, 2);<br/>        return (roll == 0 ? NodeStates.SUCCESS : NodeStates.FAILURE);<br/>    }<br/>}</pre>
<p>As you can see, the node is very simple. We "roll" a random value between 0 and 1 (keeping in mind that <kbd>Random.Range(int, int)</kbd> has an exclusive upper range, meaning it can return up to that value, but not including it), and return a <kbd>SUCCESS</kbd> state when the <kbd>roll</kbd> is <kbd>0</kbd>, and <kbd>FAILURE</kbd> otherwise.</p>
<p>Going back to the <kbd>EnemyBehaviorTree.cs</kbd> class, we have another delegate/event declaration:</p>
<pre>public delegate void TreeExecuted();<br/>public event TreeExecuted onTreeExecuted;</pre>
<p>Similar to the <kbd>onActionExecuted</kbd> event on the <kbd>PlayerController.cs</kbd> class, this one will be called after the AI executes its action and triggers the end-of-turn checks. Up next, we have the <kbd>Start()</kbd> method, which is important as it sets up our node structure, starting from the lowest-level nodes:</p>
<pre>void Start () { <br/>    healthCheckNode = new ActionNode(CriticalHealthCheck);<br/><br/>    attackCheckNode = new ActionNode(CheckPlayerHealth);<br/><br/>    buffCheckRandomNode = new RandomBinaryNode();<br/>    buffCheckNode = new ActionNode(BuffCheck);<br/>    buffCheckSequence = new Sequence(new List&lt;Node&gt; {<br/>        buffCheckRandomNode,<br/>        buffCheckNode,<br/>    });<br/><br/>    rootNode = new Selector(new List&lt;Node&gt; {<br/>        healthCheckNode,<br/>        attackCheckNode,<br/>        buffCheckSequence,<br/>    });<br/>}</pre>
<p>To better understand what's going on in this section of the code, let's take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="163" width="356" src="assets/0bf4df0e-541f-4a2e-b823-8de031061df3.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Enemy turn behavior tree</div>
<p class="mce-root">As you can see, the enemy turn is broken up into three steps—health check, attack check, and buff check. The health check node is a simple <kbd>ActionNode</kbd>. In this case, we're modeling a fairly conservative agent, so it prioritizes its own health versus being aggressive. The node invokes the following method:</p>
<pre>private NodeStates CriticalHealthCheck() {<br/>    if(ownData.HasLowHealth) {<br/>        return NodeStates.SUCCESS;<br/>    } else {<br/>        return NodeStates.FAILURE;<br/>    }<br/>}</pre>
<p>We then have the attack check node, which is also an <kbd>ActionNode</kbd>. This one then checks if the human player's health is low, and attacks if so, in an attempt to go for the kill. This is the function it invokes:</p>
<pre>private NodeStates CheckPlayerHealth() {<br/>    if(playerData.HasLowHealth) {<br/>        return NodeStates.SUCCESS;<br/>    } else {<br/>        return NodeStates.FAILURE;<br/>    }<br/>}</pre>
<p>We then have a buff check node, that is actually a sequence, with two children nodes. The idea here is that if it did not heal, and it did not attack, the agent will attempt to buff itself. However, because this would lead to a loop where it buffs itself, the player attacks (thus removing the buff), and it buffs itself over and over until its health is low, we add a randomization factor via the <kbd>RandomBinaryNode</kbd> node. The actual buff check calls the following method:</p>
<pre>private NodeStates BuffCheck() {<br/>    if(!ownData.IsBuffed) {<br/>        return NodeStates.SUCCESS;<br/>    } else {<br/>        return NodeStates.FAILURE;<br/>    }<br/>}</pre>
<p>The root node itself is a <kbd>Selector</kbd>, so that it only requires one child to return <kbd>SUCCESS</kbd> for it to return <kbd>SUCCESS</kbd> itself. However, we do not use the root node's state value in this example. The last part of our AI code is the <kbd>Execute()</kbd> method, which as you may notice, is a coroutine. We do this to give the illusion that the AI is "thinking" about its move. The code looks like this:</p>
<pre>private IEnumerator Execute() {<br/>    Debug.Log("The AI is thinking...");<br/>    yield return new WaitForSeconds(2.5f);<br/><br/>    if(healthCheckNode.nodeState == NodeStates.SUCCESS) {<br/>        Debug.Log("The AI decided to heal itself");<br/>        ownData.Heal();<br/>    } else if(attackCheckNode.nodeState == NodeStates.SUCCESS) {<br/>        Debug.Log("The AI decided to attack the player!");<br/>        playerData.Damage();<br/>    } else if (buffCheckSequence.nodeState == NodeStates.SUCCESS) {<br/>        Debug.Log("The AI decided to defend itself");<br/>        ownData.Buff();<br/>    } else {<br/>        Debug.Log("The AI finally decided to attack the player");<br/>        playerData.Damage();<br/>    }<br/>    if(onTreeExecuted != null) {<br/>        onTreeExecuted();<br/>    }<br/>}</pre>
<p>We evaluate the state of each node, and act accordingly. In the case that all nodes report a <kbd>FAILURE</kbd>, we fall back to an <kbd>else</kbd> clause that attacks the enemy. At each stage we debug the AI's "process" via debug logs. After all the <kbd>if</kbd> checks, we simply fire off our callback, which in turn calls the <kbd>EndTurn()</kbd> method we passed in earlier via the <kbd>Game.cs</kbd> script.</p>
<p>The last bit of code to look at for this example is the <kbd>EnemyTurnState.cs</kbd> <kbd>StateMachineBehaviour</kbd> script. It's attached to the <span class="packt_screen">Enemy Turn</span> state in the state machine. In it, we only implement the following two methods: </p>
<pre>override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {<br/>    Debug.Log("********************* \n Strating the enemy's turn!");<br/>    animator.gameObject.GetComponent&lt;Game&gt;().EvaluateAITree();<br/>}</pre>
<p>As you can see, <kbd>OnStateEnter</kbd> logs some information to the console, then calls the <kbd>EvaluteAITree()</kbd> method on the <kbd>Game.cs</kbd> script, which in turn calls the <kbd>Evaluate()</kbd> method on the <kbd>EnemyBehaviorTree.cs</kbd> script:</p>
<pre>override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {<br/>    Debug.Log("Ending the enemy's turn. \n *********************");<br/>}</pre>
<p>The <kbd>OnStateExit</kbd> method simply logs out some information to the console, so that when we enter play mode in the editor, we'll see an output that looks like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="187" width="338" src="assets/0f665a42-a8cd-4a47-8db9-fc754505a97e.png"/></div>
<p>The preceding screenshot shows the console after the AI's first turn, where neither the AI agent nor the player have sustained enough damage for them to heal or attack, and the AI opted to defend itself instead, using the <strong>Buff</strong> ability. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the game</h1>
                </header>
            
            <article>
                
<p>All you have to do is hit play, and play along. Each game should play differently depending on how the randomness of the abilities and the <kbd>RandomBinaryNode</kbd> play out. As you can see, even with the simple three-branch behavior tree used here, we're able to create a huge number of possible outcomes for the game. Adding more branches to suit your game design can give your game added challenge, replay value, and unpredictability. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we dug into how a behavior tree works, and then we looked at each individual type of node that can make up a behavior tree. We also learned the different scenarios where some nodes would be more helpful than others. After looking at some off-the-shelf solutions available in the Unity asset store, we applied this knowledge by implementing our own basic behavior tree framework in C# and explored its inner workings. With the knowledge and the tools out of the way, we created a sample behavior tree using our framework to test the concepts learned throughout the chapter. We then went on to explore the implementation of <em>HomeRock</em>, a sample card game that showcases an AI opponent. This knowledge prepares us to harness the power of behavior trees in games and take our AI implementations to the next level.</p>
<p>In the next chapter, <a href="4dbbb008-faf0-41a9-87d5-391ac3af5781.xhtml">Chapter 7</a>, <em>Using Fuzzy Logic to Make Your AI Seem Alive</em>, we'll look at new ways to add complexity and functionality to the concepts we've learned in this chapter, modifying behavior trees and FSMs, which we covered in <a href="9e338555-162c-4ed0-a519-035cfcea94ce.xhtml">Chapter 2</a><em>,</em> <em>Finite State Machines and You</em>, via the concept of fuzzy logic.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>