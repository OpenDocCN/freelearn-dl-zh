<html><head></head><body>
        

                            
                    <h1 class="header-title">Finding Your Way</h1>
                
            
            
                
<p>Obstacle avoidance is a simple behavior that allows AI entities to reach a target point. It's important to note that the specific behavior implemented in this chapter is meant to be used for behaviors such as crowd simulation, where the main objective of each agent entity is just to avoid the other agents and reach the target. There's no consideration of what would be the most efficient and shortest path. We'll learn about the A* Pathfinding algorithm in the next section.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Path following and steering</li>
<li>A custom A* Pathfinding implementation</li>
<li>Unity's built-in NavMesh</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Following a path</h1>
                
            
            
                
<p>Before diving into A*, which is a procedural approach to pathfinding, we'll implement a more rudimentary waypoint-based system. While more advanced techniques, such as the aforementioned A* method or Unity's NavMesh, will often be the preferred method for pathfinding, looking at a simpler, more pure version will help set the foundation for understanding more complex pathfinding approaches. Not only that, but there are many scenarios in which a waypoint-based system will be more than enough, and will allow more fine-tuned control over your AI agent's behavior. </p>
<p>In this example, we'll create a path, which is made up of individual waypoints. For our purposes, a waypoint is simply a point in space with an X, Y, and Z value; we can simply use a <kbd>Vector3</kbd> to represent this data. By making a serialized array of <kbd>Vector3</kbd> in our script, we'll be able to edit the points in the inspector without much fuss. If you want to challenge yourself and tweak this system to be a bit more user-friendly, you may want to consider using an array of game objects instead, and using their position (a <kbd>Vector3</kbd> ) instead. For demonstration purposes, the example provided will stick to the <kbd>Vector3</kbd> array. After setting up some points in our array, we want to end up with a path that looks like the following screenshot:</p>
<div><img height="305" width="470" src="img/d7a9aa21-88e5-4b75-a064-bbd18eb1eefd.png"/></div>
<p>An object path</p>
<p class="mce-root">In the preceding screenshot, we use some debug lines to draw the connections between waypoints. Don't worry, there isn't any magic happening here. By using Unity's debug features, we can visualize the path we'll be having our agent traverse. Let's deconstruct our <kbd>Path.cs</kbd> script to see how we achieve this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The path script</h1>
                
            
            
                
<p>Here is our <kbd>Path.cs</kbd> script, which is responsible for managing our waypoints:</p>
<pre>using UnityEngine;<br/><br/>public class Path: MonoBehaviour<br/>{<br/>    [SerializeField]<br/>    private Vector3[] waypoints;<br/><br/>    public bool isDebug = true;<br/>    public float radius = 2.0f;<br/><br/>    public float PathLength {<br/>        get { return waypoints.Length; }<br/>    }<br/>    <br/>    public Vector3 GetPoint(int index)<br/>    {<br/>        return waypoints[index];<br/>    }<br/>    <br/>    private void OnDrawGizmos()<br/>    {<br/>        if (!isDebug) {<br/>            return;<br/>        }<br/><br/>        for (int i = 0; i &lt; waypoints.Length; i++)<br/>        {<br/>            if (i + 1 &lt; waypoints.Length)<br/>            {<br/>                Debug.DrawLine(waypoints[i], waypoints[i + 1], Color.red);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>SerializeField</kbd> property can be used to force Unity to serialize a private field, and display it in the inspector.</p>
<p>Our waypoints' <kbd>Vector3</kbd> array is the collection of waypoints in the path mentioned earlier. To initialize the waypoints, we must add the script to a game object in our scene. In the sample scene, we simply create an empty game object and attach the <kbd>Path.cs</kbd> script to it. For the sake of clarity, we've also renamed our game object to <kbd>Path</kbd>. With the <kbd>Path</kbd> game object ready to go, we can assign the path values in the inspector. The sample values look like this:</p>
<div><img height="349" width="378" src="img/0964a4e7-6420-4f16-a8a1-120044e65020.png"/></div>
<p>Path values provided in the sample project</p>
<p>The values in the screenshot here are arbitrary, and can be tweaked to your liking. You just need to make sure you have at least two waypoints along your path. </p>
<p>The <kbd>PathLength</kbd> property simply returns the length of our waypoint array. It provides a public getter for our private field, and is later used by another script. The <kbd>radius</kbd> variable allows us to define the tolerance for our pathfinding. Rather than expecting our agent to be at the precise location of our waypoint, we'll use a radius to determine when the agent is <em>close enough</em> to consider the waypoint visited. The <kbd>GetPoint</kbd> method is a simple helper to get a waypoint from the array at a given index. </p>
<p>It is common and proper practice to make fields <kbd>private</kbd> by default, especially when the data contained is integral to the functionality of the class. In our case, the waypoint order, array size, and more should not be modified at runtime, so we ensure that external classes can only get data from them by using helper methods and properties, and protect them from external changes by making them private.</p>
<p>Finally, we use <kbd>OnDrawGizmos</kbd>, which is a <kbd>MonoBehaviour</kbd> method that Unity automatically calls for us, to draw debug information in the scene view in the editor. We can toggle this functionality on and off by setting the value of <kbd>isDebug</kbd> to <kbd>true</kbd> or <kbd>false</kbd>, respectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the path follower</h1>
                
            
            
                
<p>Next, we'll set up our agent to follow the path defined in the previous section. We'll use a simple cube in the example, but feel free to use any art you want. Let's take a closer look at the <kbd>Pathing.cs</kbd> script provided in the sample code:</p>
<pre>public class Pathing : MonoBehaviour <br/>{<br/>    [SerializeField]<br/>    private Path path;<br/>    [SerializeField]<br/>    private float speed = 20.0f;<br/>    [SerializeField]<br/>    private float mass = 5.0f;<br/>    [SerializeField]<br/>    private bool isLooping = true;<br/>    <br/>    private float currentSpeed;<br/>    private int currentPathIndex = 0;<br/>    private Vector3 targetPoint;<br/>    private Vector3 direction;<br/>    private Vector3 targetDirection;</pre>
<p>The first group of fields are variables we want serialized so that they can be set via the inspector. <kbd>path</kbd> is a reference to the <kbd>Path</kbd> object we created earlier; we can simply drag and drop the component from the <kbd>path</kbd> game object into this field. <kbd>speed</kbd> and <kbd>mass</kbd> are used to calculate the movement of the agent along the path. <kbd>isLooping</kbd> is used to determine whether or not we should loop around the path. When true, the agent will reach the last waypoint, then go to the first waypoint on the path and start over. Once the values are all assigned, the inspector should look something like this: </p>
<div><img height="108" width="413" src="img/37e3073c-4ecc-4d97-8e2f-6c2c3fe32255.png"/></div>
<p>The pathfinding script inspector with its default values</p>
<p>Our <kbd>Start</kbd> method handles the initialization for some of the remaining private fields—<kbd>direction</kbd> and <kbd>targetPoint</kbd>:</p>
<pre>private void Start () <br/>    {<br/>        // Initialize the direction as the agent's current facing direction<br/>        direction = transform.forward; <br/>        // We get the firt point along the path<br/>        targetPoint = path.GetPoint(currentPathIndex);<br/>  }</pre>
<p> Our <kbd>Update</kbd> method does a few things for us. First, it does some boilerplate null safety checks, it updates the speed of the agent, checks whether the target has been reached, calls the <kbd>SetNextTarget</kbd> method to determine the next target point, and finally, applies the direction and rotation changes as needed:</p>
<pre>  private void Update () <br/>  {<br/>        if(path == null) {<br/>            return;<br/>        }<br/><br/>        currentSpeed = speed * Time.deltaTime;<br/>        <br/>        if(TargetReached())<br/>        {<br/>            if (!SetNextTarget()) {<br/>                return;<br/>            }<br/>        }<br/><br/>        direction += Steer(targetPoint);<br/>        transform.position += direction; //Move the agent according to the direction<br/>        transform.rotation = Quaternion.LookRotation(direction); //Rotate the agent towards the desired direction<br/>  }</pre>
<p>To keep things nice and readable, we moved some of the functionality out of the <kbd>Update</kbd> method. <kbd>TargetReached</kbd> is fairly straightforward. It uses the radius of <kbd>path</kbd> to determine if the agent is <em>close enough</em> to the target waypoint, as you can see here:</p>
<pre>private bool TargetReached() <br/>{<br/>    return (Vector3.Distance(transform.position, targetPoint) &lt; path.radius);<br/>}</pre>
<p>The <kbd>SetNextTarget</kbd> method is a bit more interesting.  As you can see, it returns a <kbd>bool</kbd>. If we haven't reached the end of the array, it'll just increment the value, but if the method is unable to set the next point, because we've reached the end of the array, and <kbd>isLooping</kbd> is false, it returns false. If you go back to our <kbd>Update</kbd> method for a moment, you'll see that when this happens, we simply return out of <kbd>Update</kbd> and do nothing. This is because we've reached the end of the road, and there is nowhere else for our agent to go. In the same scenario, but with <kbd>isLooping == true</kbd> evaluating to true, we reset our next target point to the first in the array (0):</p>
<pre>private bool SetNextTarget() <br/>{<br/>    bool success = false;<br/>    if (currentPathIndex &lt; path.PathLength - 1) {<br/>        currentPathIndex++;<br/>        success = true;<br/>    } <br/>    else <br/>    {<br/>        if(isLooping) <br/>        {<br/>            currentPathIndex = 0;<br/>            success = true;<br/>        } <br/>        else <br/>        {<br/>            success = false;<br/>        }<br/>    }<br/>    targetPoint = path.GetPoint(currentPathIndex);<br/>    return success;<br/>}</pre>
<p>The <kbd>Steer</kbd> method uses the given target point and does some calculations to get the new direction and rotation. By subtracting the target point (<em>b</em>) from the current position (<em>a</em>), we get a vector for the direction from <em>a</em> to <em>b</em>. We normalize that vector, then apply the current speed to determine how far to move this frame along the new <kbd>targetDirection</kbd>.  Lastly, we use the mass to ease the acceleration between our <kbd>targetDirection</kbd> and our current direction, and return that value as <kbd>acceleration</kbd>:</p>
<pre>public Vector3 Steer(Vector3 target)<br/>{<br/>    // Subtracting vector b - a gives you the direction from a to b. <br/>    targetDirection = (target - transform.position);<br/>    targetDirection.Normalize(); <br/>    targetDirection*= currentSpeed;<br/>    <br/>    Vector3 steeringForce = targetDirection - direction; <br/>    Vector3 acceleration = steeringForce / mass;<br/>    return acceleration;<br/>}</pre>
<p>When you run the scene, the agent cube will follow the path as expected. If you toggle <kbd>isLooping</kbd> off, the agent will reach the final waypoint and stop there, but if you leave it on, the agent will loop around the path infinitely. Try tweaking the various settings to see how it affects the outcome.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding obstacles</h1>
                
            
            
                
<p>Next, we'll look at an obstacle avoidance mechanic. To get started, pop open the same scene, named <kbd>ObstacleAvoidance</kbd>. The sample scene is quite straightforward. Aside from the camera and directional light, there is a plane with a series of blocks that will act as our obstacles, a cube that will act as our agent, and a canvas containing some instructional text. The scene will look like the following screenshot:</p>
<div><img height="270" width="364" src="img/57fe2cb7-788a-4b9e-8f71-1d2a7f44ad45.png"/></div>
<p>The sample scene setup</p>
<p>The hierarchy for the preceding scene pictures looks like this:</p>
<div><img height="205" width="325" src="img/e0ee092c-27b6-450d-943c-8988f5a6d3a4.png"/></div>
<p>The organized hierarchy</p>
<p>It is worth noting that this <kbd>Agent</kbd> object is not a pathfinder. As such, if we set too many walls up, our <kbd>Agent</kbd> might have a hard time finding the target. Try a few wall setups and see how our <kbd>Agent</kbd> performs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a custom layer</h1>
                
            
            
                
<p class="mce-root">Our mechanic relies on raycasting to detect obstacles. Rather than just assuming every single object is an obstacle, we specifically use a layer named Obstacles and filter out everything else. This is not a default layer in Unity, so we have to set it up manually. The sample project already has this set up for you, but if you wanted to add your own layer, you could access the layer setup window in two different ways. The first is through the menus—Edit | <strong>Project Settings</strong> | Tags and Layers—and the second method is by selecting the layer dropdown in the hierarchy and selecting Add Layer....The following screenshot shows the menu's location in the upper-right corner of the inspector:</p>
<div><img height="188" width="339" src="img/4de9590a-a78c-40f6-b125-8e3cdf75d258.png"/></div>
<p>Selecting the Tags and Layers menu through the menu shown in the preceding screenshot, or through Unity's menu bar, will open up a window where you can freely add, edit, or remove layers (and tags, but we're not interested in those at the moment). Let's add <kbd>Obstacles</kbd> in the 8th slot, as shown in this screenshot:</p>
<div><img height="267" width="378" src="img/533c8c62-0818-4eaf-a114-585bf6655687.png"/></div>
<p>Creating a new layer</p>
<p>You should save the project after you make any changes to the settings, but there is no dedicated save button for layers specifically. You can now assign the layer in the same dropdown in the inspector as the one we just used, as depicted in the following screenshot:</p>
<div><img height="211" width="418" src="img/6a4ce7da-241d-474f-9292-678523a9bcc8.png"/></div>
<p>Assigning our new layer</p>
<p>Layers are most commonly used by cameras to render a part of the scene, and by lights to illuminate only some parts of the scene. But they can also be used by raycasting to selectively ignore colliders or create collisions. You can learn more about this at <a href="https://docs.unity3d.com/Manual/Layers.html">http://docs.unity3d.com/Documentation/Components/Layers.html.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Obstacle avoidance</h1>
                
            
            
                
<p>Now that our scene is set up, let's take a look at our avoidance behavior script. It contains all the logic for driving our agent, and applies the avoidance to the movement of the agent. In the sample project, take a look at the <kbd>Avoidance.cs</kbd> script:</p>
<pre>using UnityEngine;<br/><br/>public class Avoidance : MonoBehaviour <br/>{<br/>    [SerializeField]<br/>    private float movementSpeed = 20.0f;<br/>    [SerializeField]<br/>    private float rotationSpeed = 5.0f;<br/>    [SerializeField]<br/>    private float force = 50.0f;<br/>    [SerializeField]<br/>    private float minimumAvoidanceDistance = 20.0f;<br/>    [SerializeField]<br/>    private float toleranceRadius = 3.0f;<br/>    <br/>    private float currentSpeed;<br/>    private Vector3 targetPoint;<br/>    private RaycastHit mouseHit;<br/>    private Camera mainCamera;<br/>    private Vector3 direction;<br/>    private Quaternion targetRotation;<br/>    private RaycastHit avoidanceHit;<br/>    private Vector3 hitNormal;<br/>    <br/>    private void Start () <br/>    {<br/>        mainCamera = Camera.main;<br/>        targetPoint = Vector3.zero;<br/>    }</pre>
<p>You'll find some familiar field names in the preceding code snippet. Values such as movement speed, rotation speed, tolerance radius, and more are similar to values we used in our waypoint system. Similarly, we use the <kbd>SerializeField</kbd> attribute to expose our private fields in the inspector for easy editing and assignment, while protecting our values from being tampered with by external objects at runtime. In the <kbd>Start</kbd> method, we simply initialize some values. For example, we cache a reference to our <kbd>Camera.main</kbd> here so that we don't have to do the lookup every single time we need a reference to it. Next, let's look at the <kbd>Update</kbd> method:</p>
<pre>  private void Update () <br/>  {<br/>        CheckInput();<br/>        direction = (targetPoint - transform.position);<br/>        direction.Normalize();<br/><br/>        //Apply obstacle avoidance<br/>        ApplyAvoidance(ref direction);<br/><br/>        //Don't move the agent when the target point is reached<br/>        if(Vector3.Distance(targetPoint, transform.position) &lt; toleranceRadius) {<br/>            return;<br/>        }<br/>        <br/>        currentSpeed = movementSpeed * Time.deltaTime;<br/><br/>        //Rotate the agent towards its target direction <br/>        targetRotation = Quaternion.LookRotation(direction);<br/>        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed *                   Time.deltaTime);<br/><br/>        //Move the agent forard<br/>        transform.position += transform.forward * currentSpeed;<br/>    }</pre>
<p>Right off the bat, we call <kbd>CheckInput()</kbd>, which looks like this:</p>
<pre>private void CheckInput() <br/>{<br/>    if (Input.GetMouseButtonDown(0)) <br/>    {<br/>        var ray = mainCamera.ScreenPointToRay(Input.mousePosition);<br/>        if (Physics.Raycast(ray, out mouseHit, 100.0f)) {<br/>            targetPoint = mouseHit.point;<br/>        }<br/>    }<br/>}</pre>
<p>We check whether the user has clicked the left mouse button (by default, it is the button mapped to "<kbd>0</kbd>"). If so, we check for a physics raycast originating from the main camera, shooting to the position of the mouse. If we get a positive hit, we simply assign the hit point from <kbd>mouseHit</kbd> to be our new <kbd>targetPoint</kbd>. This is where our agent will attempt to move to. Back to <kbd>Update</kbd>, we have the following lines, right after our <kbd>CheckInput()</kbd> method:</p>
<pre>direction = (targetPoint - transform.position);<br/>direction.Normalize();<br/><br/>//Apply obstacle avoidance<br/>ApplyAvoidance(ref direction);</pre>
<p>We calculate the direction to our target point, in the same way we did in our <kbd>Pathing.cs</kbd> script, and we normalize that vector so that it has a magnitude of no more than 1. Next, we modify that direction and apply avoidance, by sending that direction vector to our <kbd>ApplyAvoidance()</kbd> method, which looks like this:</p>
<pre>private void ApplyAvoidance(ref Vector3 direction)<br/>{<br/>    //Only detect layer 8 (Obstacles)<br/>    //We use bitshifting to create a layermask with a value of <br/>    //0100000000 where only the 8th position is 1, so only it is active.<br/>    int layerMask = 1 &lt;&lt; 8;<br/><br/>    //Check that the agent hit with the obstacles within it's minimum distance to avoid<br/>    if (Physics.Raycast(transform.position, transform.forward, out avoidanceHit, minimumAvoidanceDistance, layerMask))<br/>    {<br/>        //Get the normal of the hit point to calculate the new direction<br/>        hitNormal = avoidanceHit.normal;<br/>        hitNormal.y = 0.0f; //Don't want to move in Y-Space<br/><br/>        //Get the new directional vector by adding force to agent's current forward vector<br/>        direction = transform.forward + hitNormal * force;<br/>    }<br/>}</pre>
<p>Before digging into the preceding code, it's important to understand how Unity handles masking layers. As we mentioned earlier, we want our raycast to only hit the layers we care about, in this case, our <kbd>Obstacles</kbd> layer. If you were observant, you might have noticed our layer's array has 32 slots, from index 0 to 31. We put our <kbd>Obstacles</kbd> layer on slot 8 (index 9). The reason for this is that Unity represents the layers using a 32-bit int, and each bit represents one of the slots, from right to left. Let's break that down visually.</p>
<p>Let's say we want to represent a layer mask, where only the first slot (the first bit) is active. In this case, we'd assign the bit a value of 1. It would look like this:</p>
<pre>0000 0000 0000 0000 0000 0000 0000 0001</pre>
<p>And if you're still solid on your computer science fundamentals, you'll remember, that in binary, that value translates to an int value of 1. Let's say you have a mask that only has the first four slots/indices selected. That would like like this:</p>
<pre>0000 0000 0000 0000 0000 0000 0000 1111</pre>
<p>Once again, converting from binary, it gives us an int value of <em>15 (1 + 2+ 4 + 8)</em>.</p>
<p>In our script, we want a mask with only the 9th position active, which would look like this:</p>
<pre>0000 0000 0000 0000 0000 0001 0000 0000</pre>
<p>Again, doing the math, we know that the int value for that mask is 256. But doing the math manually is inconvenient. Luckily, C# provides some operators to manipulate bits. This line in the preceding code does just that:</p>
<pre>int layerMask = 1 &lt;&lt; 8;</pre>
<p>It uses a bit shift operator—the left-shift operator, specifically—to create our mask. The way it works is fairly straightforward: it takes an int operand (the int value on the left-hand side of the expression) with a value of 1, then shifts that bit representation to the left eight times. It looks something like this:</p>
<pre>0000 0000 0000 0000 0000 0000 0000 0001 //Int value of 1<br/>                              &lt;&lt;&lt;&lt; &lt;&lt;&lt;&lt; //Shift left 8 times<br/>0000 0000 0000 0000 0000 0001 0000 0000 //Int value of 256</pre>
<p>As you can see, bitwise operators are helpful, and though they don't always lead to very readable code, they're very handy in situations like this one.</p>
<p>You can also find a good discussion on using layermasks on Unity3D online. The question-and-answer site can be found at <a href="http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html">http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html</a>. Alternatively, you may consider using <kbd>LayerMask.GetMask()</kbd>, which is Unity's built-in method for dealing with named layers.</p>
<p>With that out of the way, let's go back to the rest of our <kbd>ApplyAvoidance()</kbd> code. After creating the layer mask, the following lines look like this:</p>
<pre>//Check that the agent hit with the obstacles within it's minimum distance to avoid<br/>if (Physics.Raycast(transform.position, transform.forward, out avoidanceHit, minimumAvoidanceDistance,     layerMask))<br/>{<br/>    //Get the normal of the hit point to calculate the new direction<br/>    hitNormal = avoidanceHit.normal;<br/>    hitNormal.y = 0.0f; //Don't want to move in Y-Space<br/><br/>    //Get the new direction vector by adding force to agent's current forward vector<br/>    direction = transform.forward + hitNormal * force;<br/>}</pre>
<p>Once again, we use a raycast, but this time, the origin is the position of the agent, and the direction is its forward vector. You'll also notice that we use an overload of the <kbd>Physics.Raycast()</kbd> method that takes our <kbd>layerMask</kbd> as an argument, meaning our raycast will only hit objects in our obstacles layer. When a hit does occur, we get the normal of the surface we hit and calculate the new direction vector.</p>
<p>The last bit of our <kbd>Update</kbd> function looks like this:</p>
<pre>//Don't move the agent when the target point is reached<br/>if(Vector3.Distance(targetPoint, transform.position) &lt; toleranceRadius) {<br/>    return;<br/>}<br/>        <br/>currentSpeed = movementSpeed * Time.deltaTime;<br/><br/>//Rotate the agent towards its target direction <br/>targetRotation = Quaternion.LookRotation(direction);<br/>transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed *                   Time.deltaTime);<br/><br/>//Move the agent forard<br/>transform.position += transform.forward * currentSpeed;</pre>
<p>Again, you may recognize some of this code, as it's very similar to the code used in the <kbd>Pathing.cs</kbd> script. If we've come within the acceptable radius of our destination, we do nothing. Otherwise, we rotate the agent and move it forward.</p>
<p>In the sample scene, you can find an <kbd>Agent</kbd> game object with the <kbd>Avoidance.cs</kbd> script attached. The inspector with all the values assigned will look like this:</p>
<div><img height="288" width="358" class="aligncenter size-full wp-image-407 image-border" src="img/6145a7df-3c30-4bf1-b6be-bbb983ae9fe8.png"/></div>
<p>Agent inspector view</p>
<p>Try tweaking the values to see what kinds of results you can get. Simply hit play and click around the scene to tell your agent to move. You may notice that, even though the agent is intelligently avoiding the obstacles, it won't always take the most efficient route to its target destination. That's where A* comes in.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A* Pathfinding</h1>
                
            
            
                
<p>Next up, we'll  implement the A* algorithm in a Unity environment using C#. The A* Pathfinding algorithm is widely used in games and interactive applications even though there are other algorithms, such as Dijkstra's algorithm, because of its simplicity and effectiveness. We've briefly covered this algorithm previously, in <a href="070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml">Chapter 1</a>, <em>The Basics of AI in Games</em>, but let's review the algorithm again from an implementation perspective.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Revisiting the A* algorithm</h1>
                
            
            
                
<p>We briefly touched on the A* algorithm earlier in the book, so let's review the basics before we dive into our implementation. For starters, we need to create a grid-based representation of our map. The best option for this is a 2D array. This grid and all of its associated data will be contained in our <kbd>GridManager</kbd> class. The <kbd>GridManager</kbd> class will contain a list of <kbd>Node</kbd> objects that represent each cell in our grid. The nodes themselves will contain some additional data about themselves, such as their heuristic cost and whether or not they are an obstacle node.</p>
<p>We'll also need to keep two lists—our open list, that is, our list of nodes to explore, and our closed list, which will contain nodes we've already visited. We'll implement these in our <kbd>PriorityQueue</kbd> class, which provides some additional helper functionality.</p>
<p>In essence, our A* algorithm, implemented in the <kbd>AStar</kbd> class, must do the following:</p>
<ol>
<li>Begin at the starting node and put it in the open list.</li>
<li>As long as the open list has some nodes in it, we'll perform the following processes:
<ol>
<li>Pick the first node from the open list and keep it as the current node. (This is assuming that we've sorted the open list and the first node has the least cost value, which will be mentioned at the end of the code.)</li>
<li>Get the neighboring nodes of this current node that are not obstacle types, such as a wall or canyon, that can't be passed through.</li>
<li>For each neighbor node, check if this neighbor node is already in the closed list. If not, we'll calculate the total cost (<kbd>F</kbd>) for this neighbor node using the following formula:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px">F = G + H</pre>
<ol>
<li style="list-style-type: none">
<ol start="4">
<li>In the preceding formula, <kbd>G</kbd> is the total cost from the start node to this node and <kbd>H</kbd> is the total cost from this node to the final target node.</li>
<li>Store this cost data in the neighbor node object. Also, store the current node as the parent node as well. Later, we'll use this parent node data to trace back the actual path.</li>
<li>Put this neighbor node in the open list. Sort the open list in ascending order, ordered by the total cost to reach the target node.</li>
<li>If there are no more neighbor nodes to process, put the current node in the closed list and remove it from the open list.</li>
<li>Go back to step 2 using the next node in the open list.</li>
</ol>
</li>
</ol>
<p>Once you have completed this process, your current node should be in the target goal node position, but only if there's an obstacle-free path to reach the goal node from the start node. If it is not at the goal node, there's no available path to the target node from the current node position. If there's a valid path, all we have to do now is trace back from the current node's parent node until we reach the start node again. This will give us a path list of all the nodes that we chose during our pathfinding process, ordered from the target node to the start node. We then just reverse this path list, since we want to know the path from the start node to the target goal node.</p>
<p>This is a general overview of the algorithm we're going to implement in Unity using C#. So, let's get started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementation</h1>
                
            
            
                
<p>In order to get started with A*, we'll have to take the concepts and apply them as concrete implementations in the code. In our sample code, we break the A* system into a few key components: the <kbd>Node</kbd>, <kbd>GridManager</kbd>, <kbd>PriorityQueue</kbd>, and <kbd>AStart</kbd> classes.</p>
<p>Let's break down what each class does in the following few sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Node class</h1>
                
            
            
                
<p>We can think of the <kbd>Node</kbd> class as a container for all of the relevant information about each tile in our grid. We store information about things such as the cost of the node, the parent of the node, and its position:</p>
<pre>using UnityEngine;<br/>using System;<br/><br/>public class Node : IComparable<br/>{<br/>    //Total cost so far for the node<br/>    public float gCost;<br/>    //Estimated cost from this node to the goal node<br/>    public float hCost;<br/>    //Is this an obstacle node<br/>    public bool bObstacle;<br/>    //Parent of the node in the linked list<br/>    public Node parent;<br/>    //Position of the node in world space<br/>    public Vector3 position; <br/>    <br/>    public Node()<br/>    {<br/>        hCost = 0.0f;<br/>        gCost = 1.0f;<br/>        bObstacle = false;<br/>        parent = null;<br/>    }<br/>    <br/>    public Node(Vector3 pos)<br/>    {<br/>        hCost = 0.0f;<br/>        gCost = 1.0f;<br/>        bObstacle = false;<br/>        parent = null;<br/><br/>        position = pos;<br/>    }<br/>    <br/>    public void MarkAsObstacle()<br/>    {<br/>        bObstacle = true;<br/>    }<br/>    <br/>    //IComparable Interface method implementation<br/>    public int CompareTo(object obj)<br/>    {<br/>        Node node = (Node)obj;<br/>        if (hCost &lt; node.hCost) <br/>        {<br/>            return -1;<br/>        }<br/>        if (hCost &gt; node.hCost) <br/>        {<br/>            return 1;<br/>        }<br/>        return 0;<br/>    }<br/>}</pre>
<p>In code, we represent our G and H costs as <kbd>gCost</kbd> and <kbd>hCost</kbd>, respectively. G refers to the cost from the start node to this node, and H refers to the estimated cost from this node to the end node. Depending on how comfortable you get with A*, you might consider renaming them something a bit more descriptive. In our example, we want to adhere as closely as possible to the <em>on paper</em> version of the names of concepts, for the purpose of explaining the C# implementation.</p>
<p>The class provides a simple constructor that takes no arguments, and one overload that takes in a position, which prepopulates the position field with the passed-in value. There's nothing too fancy here. </p>
<p>You may have noticed that our class implements the <kbd>IComparable</kbd> interface, which requires us to implement the <kbd>CompareTo()</kbd> method to satisfy the interface contract requirements. </p>
<p>You can think of an interface as a contract. On its own, it does nothing. You cannot implement any logic in an interface. By inheriting from an interface, you're simply agreeing to implement all the methods with the provided signatures in the implementing class. That way, any other class that wants to call a given method from an interface on your class can assume that the method exists.</p>
<p>The actual implementation of the method compares the given node to this node based on their <kbd>hCost</kbd>. We'll take a look at its usage later on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Establishing the priority queue</h1>
                
            
            
                
<p>We represent our open and closed list using the <kbd>PriorityQueue</kbd> class. This approach allows us to implement some helper methods for our own convenience. The <kbd>PriorityClass.cs</kbd> file looks like this:</p>
<pre>using System.Collections;<br/><br/>public class PriorityQueue <br/>{<br/>    private ArrayList nodes = new ArrayList();<br/>    <br/>    public int Length<br/>    {<br/>        get { return nodes.Count; }<br/>    }<br/>    <br/>    public bool Contains(object node)<br/>    {<br/>        return nodes.Contains(node);<br/>    }<br/>    <br/>    public Node GetFirstNode()<br/>    {<br/>        if (nodes.Count &gt; 0)<br/>        {<br/>            return (Node)nodes[0];<br/>        }<br/>        return null;<br/>    }<br/>    <br/>    public void Push(Node node)<br/>    {<br/>        nodes.Add(node);<br/>        nodes.Sort();<br/>    }<br/><br/>    public void Remove(Node node)<br/>    {<br/>        nodes.Remove(node);<br/>        nodes.Sort();<br/>    }<br/>}</pre>
<p>There isn't much of note in this code, but the <kbd>Sort()</kbd> method in particular is interesting. Remember the <kbd>CompareTo()</kbd> method in the <kbd>Node</kbd> class? The <kbd>ArrayList.Sort()</kbd> actually relies on the implementation of <kbd>CompareTo()</kbd> in the node class to sort the array. More specifically, it will sort according to the node's <kbd>hCost</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up our grid manager</h1>
                
            
            
                
<p>The <kbd>GridManager</kbd> class does a lot of the heavy lifting in terms of arranging and visualizing our grid. Compared to some of the code we've seen so far in this book, it's a fairly lengthy class, since it provides several helper methods. Pop open the <kbd>GridManager.cs</kbd> class to follow along:</p>
<pre> [SerializeField]<br/> private int numberOfRows = 20;<br/> [SerializeField]<br/> public int numberOfColumns = 20;<br/> [SerializeField]<br/> public float gridCellSize = 2;<br/> [SerializeField]<br/> public bool showGrid = true;<br/> [SerializeField]<br/> public bool showObstacleBlocks = true;<br/><br/> private Vector3 origin = new Vector3();<br/> private GameObject[] obstacleList;<br/> private Node[,] nodes { get; set; } </pre>
<p>We start off by setting up some variables. We specify how many rows and columns are in our grid, and we specify their size (in world units). There isn't much else of note here, but we should point out that the <kbd>Node[,]</kbd> syntax indicates that we are initializing a 2D array of <kbd>nodes</kbd>, which makes sense, since a grid is a 2D array itself.</p>
<p>In our <kbd>Awake</kbd> method, we see the following line:</p>
<pre>obstacleList = GameObject.FindGameObjectsWithTag("Obstacle");</pre>
<p>This simply initializes the <kbd>obstacleList</kbd> game object array by finding things tagged as <kbd>"Obstacle"</kbd>. <kbd>Awake</kbd> then calls two setup methods: <kbd>InitializeNodes()</kbd> and <kbd>CalculateObstacles()</kbd>:</p>
<pre>private void InitializeNodes() <br/>{<br/>    nodes = new Node[numberOfColumns, numberOfRows];<br/><br/>    int index = 0;<br/>    for (int i = 0; i &lt; numberOfColumns; i++) <br/>    {<br/>        for (int j = 0; j &lt; numberOfRows; j++) <br/>        {<br/>            Vector3 cellPosition = GetGridCellCenter(index);<br/>            Node node = new Node(cellPosition);<br/>            nodes[i, j] = node;<br/>            index++;<br/>        }<br/>    }<br/>}</pre>
<p>The names of these methods are to the point, so as you may have guessed, <kbd>InitializeNodes()</kbd> initializes our nodes, and does so by populating the <kbd>nodes</kbd> 2D array. This code invokes a helper method, <kbd>GetGridCellCenter()</kbd>, which we'll look at later on, but the approach is fairly straightforward. We loop through the 2D array, column by column and row by row, and we create nodes spaced apart according to the grid size:</p>
<pre>private void CalculateObstacles()<br/>{<br/>    if (obstacleList != null &amp;&amp; obstacleList.Length &gt; 0)<br/>    {<br/>        foreach (GameObject data in obstacleList)<br/>        {<br/>            int indexCell = GetGridIndex(data.transform.position);<br/>            int column = GetColumnOfIndex(indexCell);<br/>            int row = GetRowOfIndex(indexCell);<br/>           <br/>            nodes[row, column].MarkAsObstacle();<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>CalculateObstacles()</kbd> method simply runs through the list of obstacles we initialized during <kbd>Awake</kbd>, determines which grid slot the obstacle occupies, and marks the node at that grid slot as an obstacle using <kbd>MarkAsObtacle()</kbd>.</p>
<p>The <kbd>GridManager</kbd> class has a few helper methods to traverse the grid and get the grid cell data. The following is a list of some of them with brief descriptions of what they do. The implementation is simple, so we won't go into the details:</p>
<ul>
<li><kbd>GetGridCellCenter</kbd>: Given an index for a cell, it returns the center position (in world space) of that cell.</li>
<li><kbd>GetGridCellPositionAtIndex</kbd>: Returns the origin position of the cell (the corner). Used as a helper for <kbd>GetGridCellCenter</kbd>.</li>
<li><kbd>GetGridIndex</kbd>: Given a position (as a <kbd>Vector3</kbd> in world space), it returns the cell closest to the position.</li>
<li><kbd>GetRowOfIndex</kbd> and <kbd>GetColumnOfIndex</kbd>: Just as the names say, they return the row or column of the cell at the given index. For example, in a 2 x 2 grid, the cell at index 2 (starting from 0), would be in row 2, column 1.</li>
</ul>
<p>Next, we have some methods that help with figuring out the neighbors to a given node:</p>
<pre>public void GetNeighbors(Node node, ArrayList neighbors)<br/>{<br/>    Vector3 neighborPosition = node.position;<br/>    int neighborIndex = GetGridIndex(neighborPosition);<br/><br/>    int row = GetRowOfIndex(neighborIndex);<br/>    int column = GetColumnOfIndex(neighborIndex);<br/><br/>    //Bottom<br/>    int leftNodeRow = row - 1;<br/>    int leftNodeColumn = column;<br/>    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);<br/><br/>    //Top<br/>    leftNodeRow = row + 1;<br/>    leftNodeColumn = column;<br/>    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);<br/><br/>    //Right<br/>    leftNodeRow = row;<br/>    leftNodeColumn = column + 1;<br/>    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);<br/><br/>    //Left<br/>    leftNodeRow = row;<br/>    leftNodeColumn = column - 1;<br/>    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);<br/>}<br/>  <br/>// Check the neighbor. If it's not an obstacle, assign the neighbor.<br/>private void AssignNeighbor(int row, int column, ArrayList neighbors)<br/>{<br/>    if (row != -1 &amp;&amp; column != -1 &amp;&amp; row &lt; numberOfRows &amp;&amp; column &lt; numberOfColumns)<br/>    {<br/>        Node nodeToAdd = nodes[row, column];<br/>        if (!nodeToAdd.bObstacle)<br/>        {<br/>            neighbors.Add(nodeToAdd);<br/>        }<br/>    } <br/>}</pre>
<p>First, we have <kbd>GetNeighbors()</kbd>, which uses the given node's position in the grid to figure out which cells are to the bottom, top, right, and left of it. It assigns the node as a neighbor using <kbd>AssignNeighbor()</kbd>, which does some validation, such as checking that the potential neighbor is within bounds (of the array), and that the neighbor is not marked as an obstacle.</p>
<p>Lastly, we have <kbd>OnDrawGizmos()</kbd> and <kbd>DebugDrawGrid()</kbd>, which display the grid of the size we specified in our scene view for debugging. Next up, the meat and potatoes. We tie it all together with our <kbd>AStar</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Diving into our A* implementation</h1>
                
            
            
                
<p>The <kbd>AStar</kbd> class is the actual implementation of the A* algorithm. This is where the magic happens. The code in the <kbd>AStar.cs</kbd> file looks like this:</p>
<pre>using UnityEngine;<br/>using System.Collections;<br/><br/>public class AStar<br/>{<br/>    public static PriorityQueue closedList;<br/>    public static PriorityQueue openList;<br/>    <br/>    private static ArrayList CalculatePath(Node node)<br/>    {<br/>        ArrayList list = new ArrayList();<br/>        while (node != null)<br/>        {<br/>            list.Add(node);<br/>            node = node.parent;<br/>        }<br/>        list.Reverse();<br/>        return list;<br/>    }<br/><br/>    <br/>    /// Calculate the estimated Heuristic cost to the goal <br/>    private static float EstimateHeuristicCost(Node curNode, Node goalNode)<br/>    {<br/>        Vector3 vecCost = curNode.position - goalNode.position;<br/>        return vecCost.magnitude;<br/>    }<br/>    <br/>    // Find the path between start node and goal node using A* Algorithm<br/>    public static ArrayList FindPath(Node start, Node goal)<br/>    {<br/>        openList = new PriorityQueue();<br/>        openList.Push(start);<br/>        start.gCost = 0.0f;<br/>        start.hCost = EstimateHeuristicCost(start, goal);<br/><br/>        closedList = new PriorityQueue();<br/>        Node node = null;<br/>        GridManager gridManager = GameObject.FindObjectOfType&lt;GridManager&gt;();<br/>        if(gridManager == null) {<br/>            return null;<br/>        }<br/><br/>        while (openList.Length != 0)<br/>        {<br/>            node = openList.GetFirstNode();<br/><br/>            if (node.position == goal.position)<br/>            {<br/>                return CalculatePath(node);<br/>            }<br/>      <br/>            ArrayList neighbors = new ArrayList();<br/>            gridManager.GetNeighbors(node, neighbors);<br/>            <br/>            //Update the costs of each neighbor node.<br/>            for (int i = 0; i &lt; neighbors.Count; i++)<br/>            {<br/>                Node neighborNode = (Node)neighbors[i];<br/><br/>                if (!closedList.Contains(neighborNode))<br/>                { <br/>                  //Cost from current node to this neighbor node<br/>                  float cost = EstimateHeuristicCost(node, neighborNode); <br/>                  <br/>                  //Total Cost So Far from start to this neighbor node<br/>                  float totalCost = node.gCost + cost;<br/>          <br/>                  //Estimated cost for neighbor node to the goal<br/>                  float neighborNodeEstCost = EstimateHeuristicCost(neighborNode, goal); <br/>          <br/>                  //Assign neighbor node properties<br/>                  neighborNode.gCost = totalCost;<br/>                  neighborNode.parent = node;<br/>                  neighborNode.hCost = totalCost + neighborNodeEstCost;<br/>  <br/>                  //Add the neighbor node to the open list if we haven't already done so.<br/>                  if (!openList.Contains(neighborNode))<br/>                  {<br/>                      openList.Push(neighborNode);<br/>                  }<br/>                }<br/>            } <br/>            closedList.Push(node);<br/>            openList.Remove(node);<br/>        }<br/><br/>        //We handle the scenario where no goal was found after looping thorugh the open list<br/>        if (node.position != goal.position)<br/>        {<br/>            Debug.LogError("Goal Not Found");<br/>            return null;<br/>        }<br/><br/>        //Calculate the path based on the final node<br/>        return CalculatePath(node);<br/>    }<br/>}</pre>
<p>There is quite a bit to go over here, so let's break it down, step by step:</p>
<pre> public static PriorityQueue closedList;<br/> public static PriorityQueue openList;</pre>
<p>We start off by declaring our open and closed lists, which will contain visited and non-visited nodes, respectively:</p>
<pre>private static float EstimateHeuristicCost(Node currentNode, Node goalNode)<br/>{<br/>    Vector3 cost= currentNode.position - goalNode.position;<br/>    return cost.magnitude;<br/>}</pre>
<p>In the preceding code, we implement a method called <kbd>EstimateHeuristicCost</kbd> to calculate the cost between the two given nodes. The calculation is simple. We just find the direction vector between the two by subtracting one position vector from another. The magnitude of this resultant vector gives the direct distance from the current node to the goal node.</p>
<p>Next, we have our <kbd>FindPath</kbd> method, which does most of the work:</p>
<pre>  public static ArrayList FindPath(Node start, Node goal)<br/>  {<br/>      openList = new PriorityQueue();<br/>      openList.Push(start);<br/>      start.gCost = 0.0f;<br/>      start.hCost = EstimateHeuristicCost(start, goal);<br/><br/>      closedList = new PriorityQueue();<br/>      Node node = null;<br/><br/>      GridManager gridManager = GameObject.FindObjectOfType&lt;GridManager&gt;();<br/>      if(gridManager == null) {<br/>          return null;<br/>      }</pre>
<p>It initializes our open and closed lists. At first, we'll only have the starting node in our <kbd>openList</kbd>. We also initialize the <kbd>gCost</kbd>, which is zero, because the distance to the starting node (itself) is zero. We then assign the <kbd>hCost</kbd> using the <kbd>EstimateHeuristicCost()</kbd> method we just discussed.</p>
<p>We'll need a reference to our <kbd>GridManager</kbd> going forward, so we get it using <kbd>FindObjectOfType()</kbd> and do some null checking. Next, we begin processing the open list:</p>
<pre>   while (openList.Length != 0)<br/>   {<br/>       node = openList.GetFirstNode();<br/><br/>       if (node.position == goal.position)<br/>       {<br/>           return CalculatePath(node);<br/>       }<br/>      <br/>       ArrayList neighbors = new ArrayList();<br/>       gridManager.GetNeighbors(node, neighbors);<br/>            <br/>       //Update the costs of each neighbor node.<br/>       for (int i = 0; i &lt; neighbors.Count; i++)<br/>       {<br/>           Node neighborNode = (Node)neighbors[i];<br/><br/>           if (!closedList.Contains(neighborNode))<br/>           { <br/>               //Cost from current node to this neighbor node<br/>               float cost = EstimateHeuristicCost(node, neighborNode); <br/>                  <br/>               //Total Cost So Far from start to this neighbor node<br/>               float totalCost = node.gCost + cost;<br/>          <br/>               //Estimated cost for neighbor node to the goal<br/>               float neighborNodeEstCost = EstimateHeuristicCost(neighborNode, goal); <br/>          <br/>               //Assign neighbor node properties<br/>               neighborNode.gCost = totalCost;<br/>               neighborNode.parent = node;<br/>               neighborNode.hCost = totalCost + neighborNodeEstCost;<br/>  <br/>               //Add the neighbor node to the open list if we haven't already done so.<br/>               if (!openList.Contains(neighborNode))<br/>               {<br/>                   openList.Push(neighborNode);<br/>               }<br/>             }<br/>         } <br/>         closedList.Push(node);<br/>         openList.Remove(node);<br/>     }<br/><br/>     //We handle the scenario where no goal was found after looping thorugh the open list<br/>     if (node.position != goal.position)<br/>     {<br/>         Debug.LogError("Goal Not Found");<br/>         return null;<br/>     }<br/><br/>     //Calculate the path based on the final node<br/>     return CalculatePath(node);<br/> }</pre>
<p>This code implementation resembles the  A* algorithm that we have previously discussed. This would be a good time to brush up on it.</p>
<p>In plain English, the preceding code can be described as following these steps:</p>
<ol>
<li>Get the first node of our <kbd>openList</kbd>. Keep in mind that our <kbd>openList</kbd> is always sorted after a new node is added so that the first node is always the node with the lowest estimated cost to the goal node.</li>
<li>Check whether the current node is already at the goal node. If so, exit the <kbd>while</kbd> loop and build the <kbd>path</kbd> array.</li>
<li>Create an array list to store the neighboring nodes of the current node being processed. Use the <kbd>GetNeighbors()</kbd> method to retrieve the neighbors from the grid.</li>
<li>For every node in the <kbd>neighbors</kbd> array, we check whether it's already in the <kbd>closedList</kbd>. If not, we calculate the cost values, update the node properties with the new cost values as well as the parent node data, and put it in <kbd>openList</kbd>.</li>
<li>Push the current node to <kbd>closedList</kbd> and remove it from <kbd>openList</kbd>. Rinse and repeat.</li>
</ol>
<p>If there are no more nodes in the <kbd>openList</kbd>, our current node should be at the target node if there's a valid path available. Then, we just call the <kbd>CalculatePath()</kbd> method with the current node as the argument. The <kbd>CalcualtePath()</kbd> method looks like this:</p>
<pre>private static ArrayList CalculatePath(Node node) <br/>{ 
    ArrayList list = new ArrayList(); 
    while (node != null) <br/>    { 
      list.Add(node); 
      node = node.parent; 
    } 
    list.Reverse(); 
    return list; 
} </pre>
<p>The <kbd>CalculatePath</kbd> method traces through each node's parent node object and builds an array list. This gives us an array list with nodes from the target node to the start node. Since we want a path array from the start node to the target node, we just call the <kbd>Reverse</kbd> method. And that's it! With our algorithm and helper classes out of the way, we can move on to our test script, which ties it all together. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a TestCode class</h1>
                
            
            
                
<p>Now that we have the A* algorithm implemented via our <kbd>AStar</kbd> class (and the associated helper classes), we actually implement it using the <kbd>TestCode</kbd> class. The <kbd>TestCode.cs</kbd> file looks like this:</p>
<pre>using UnityEngine;<br/>using System.Collections;<br/><br/>public class TestCode : MonoBehaviour <br/>{<br/>    private Transform startPosition;<br/>    private Transform endPosition;<br/><br/>    public Node startNode { get; set; }<br/>    public Node goalNode { get; set; }<br/><br/>    private ArrayList pathArray;<br/><br/>    private GameObject startCube;<br/>    private GameObject endCube;<br/>  <br/>    private float elapsedTime = 0.0f;<br/>    public float intervalTime = 1.0f; <br/>    private GridManager gridManager;</pre>
<p>We declare our variables here, and once again set up a variable to hold a reference to our <kbd>GridManager</kbd>. Then, the <kbd>Start</kbd> method does some initialization and fires off our <kbd>FindPath()</kbd> method, as shown in this code:</p>
<pre>    <br/>  private void Start () <br/>  {<br/>      gridManager = FindObjectOfType&lt;GridManager&gt;();<br/>      startCube = GameObject.FindGameObjectWithTag("Start");<br/>      endCube = GameObject.FindGameObjectWithTag("End");<br/><br/>      //Calculate the path using our AStart code.<br/>      pathArray = new ArrayList();<br/>      FindPath();<br/>  }<br/>  <br/>  private void Update () <br/>  {<br/>      elapsedTime += Time.deltaTime;<br/><br/>
      if(elapsedTime &gt;= intervalTime)<br/>      {<br/>          elapsedTime = 0.0f;<br/>          FindPath();<br/>      }<br/>  }</pre>
<p>In the <kbd>Update</kbd> method, we check for the path at intervals, which is a brute force approach to refreshing the path if the goal moves at runtime. You may want to consider implementing this code using an event to avoid unnecessary overhead in every frame (or interval, in this case).  The <kbd>FindPath()</kbd> method called in <kbd>Start</kbd> looks like this:</p>
<pre>private void FindPath()<br/>{<br/>    startPosition = startCube.transform;<br/>    endPosition = endCube.transform;<br/>        <br/>    startNode = new Node(gridManager.GetGridCellCenter(gridManager.GetGridIndex(startPosition.position)));<br/>    goalNode = new Node(gridManager.GetGridCellCenter(gridManager.GetGridIndex(endPosition.position)));<br/><br/>    pathArray = AStar.FindPath(startNode, goalNode);<br/>}</pre>
<p>First, it takes the positions of our start and end game objects. Then, it creates new <kbd>Node</kbd> objects using the helper methods <kbd>GridManager</kbd> and <kbd>GetGridIndex</kbd> to calculate their respective row and column index positions inside the grid. With those necessary values ready to go, we just call the <kbd>AStar.FindPath</kbd> method with the start node and goal node, and store the returned array list in the local <kbd>pathArray</kbd> variable.</p>
<p>Next, we implement the <kbd>OnDrawGizmos</kbd> method to draw and visualize the path found:</p>
<pre>private void OnDrawGizmos()<br/>{<br/>    if (pathArray == null) <br/>    {<br/>        return;<br/>    }<br/><br/>    if (pathArray.Count &gt; 0)<br/>    {<br/>        int index = 1;<br/>        foreach (Node node in pathArray)<br/>        {<br/>            if (index &lt; pathArray.Count)<br/>            {<br/>                Node nextNode = (Node)pathArray[index];<br/>                Debug.DrawLine(node.position, nextNode.position, Color.green);<br/>                index++;<br/>            }<br/>        };<br/>    }<br/>}</pre>
<p>We look through our <kbd>pathArray</kbd> and use the <kbd>Debug.DrawLine</kbd> method to draw the lines connecting the nodes from the <kbd>pathArray</kbd>. With this, we'll be able to see a green line connecting the nodes from start to end, forming a path, when we run and test our game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing it in the sample scene</h1>
                
            
            
                
<p>The sample scene looks like this:</p>
<div><img height="204" width="400" src="img/9bf044e3-b835-4b83-a532-d91330a844ec.png"/></div>
<p>Our sample scene with the pathfinding grid drawn over it</p>
<p>As you can see in the preceding screenshot, there is a red starting node, a green goal node, a plane, and some light grey obstacles.</p>
<p>The following screenshot is a snapshot of our scene hierarchy:</p>
<div><img height="198" width="306" src="img/cbba19a3-4926-4f98-a3a6-1c838fb01703.png"/></div>
<p>There are a few things to note in the preceding screenshot (and yes, you can ignore the Directional light, as it's just here to make our scene look pretty). First, we have grouped all of our obstacles under a parent <kbd>Obstacles</kbd> transform. Second, we have separate game objects for our <kbd>TestCode</kbd> class and our <kbd>GridManager</kbd> class as children under the <kbd>Scripts</kbd> game object. As you saw in the code sample earlier, there are some fields exposed in the <kbd>GridManager</kbd>, which should look like the following screenshot in our sample scene:</p>
<div><img height="187" width="496" class="aligncenter size-full wp-image-410 image-border" src="img/55d90b5e-b284-45aa-89fa-8cadb8d5b5db.png"/></div>
<p>As you can see in the previous screenshot, we have Show Grid ticked to true. This will enable us to see the grid in the scene view.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing all the components</h1>
                
            
            
                
<p>Now that we've looked at how everything is wired up, hit the play button and observe how a path will be drawn from our start node to our goal node, as shown in the following screenshot:</p>
<div><img height="183" width="454" src="img/2787783f-c474-4af1-9961-a2922a66afc2.png"/></div>
<p>Since we're checking for the path at intervals inside the <kbd>Update</kbd> loop, we can move the goal node in play mode, and see the path updated. The following screenshot shows the new path after moving our goal node to a different location:</p>
<div><img height="199" width="414" src="img/5df973a4-dca9-429c-a40d-da569c2122c2.png"/></div>
<p>As you can see, since the goal is closer, so is the most optimal path to reach it. In a little more than a nutshell, that is A*. A very powerful algorithm can be distilled down to a few classes totaling a few hundred lines of code (with most of it due to formatting and commenting). </p>


            

            
        
    

        

                            
                    <h1 class="header-title">A* vs IDA*</h1>
                
            
            
                
<p>In <a href="070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml">Chapter 1</a>, <em>The Basics of AI in Games</em>, we mentioned some of the differences between A* and IDA*. Now that you've implemented A*, you can see that the A* implementation keeps a few things in memory—the path array, the open list, and the closed list. At different points in the implementation, you may allocate more or less memory as you iterate through your lists. In this regard, A* is greedier than IDA*, but keep in mind that in most cases, on modern hardware, this is not an issue—even with much larger grids than ours. </p>
<p>The IDA* approach only looks at the the current iteration's adjacent/neighbor spots, and because it keeps no record of the visited nodes, it may end up visiting the same node multiple times. In similar circumstances, this means a much lower memory overhead than the faster A* version.</p>
<p>While the point can be argued, it is this humble author's opinion that IDA* is not a relevant pattern in modern game development—even on resource-conscious applications, such as mobile games. In other fields, one could make a stronger case for the iterative deepening approach, but, fortunately, even aging mobile devices have copious amounts of memory relative to the needs of the 99% of games that will implement some sort of pathfinding.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigation mesh</h1>
                
            
            
                
<p>Next, we'll learn how to use Unity's built-in navigation mesh generator that can make pathfinding for AI agents a lot easier. Early in the Unity 5.x cycle, NavMesh was made available to all users, including personal edition licensees, whereas it was previously a Unity Pro-only feature. Before the release of 2017.1, the system was upgraded to allow a component-based workflow, but as it requires an additional downloadable package that, at the time of writing is only available as a preview, we will stick to the default scene-based workflow. Don't worry, the concepts carry over, and when the final implementation eventually makes its way to 2017.x, there shouldn't be drastic changes.</p>
<p>For more information on Unity's NavMesh component system, head over to GitHub: <a href="https://github.com/Unity-Technologies/NavMeshComponents">https://github.com/Unity-Technologies/NavMeshComponents</a>.<a href="https://github.com/Unity-Technologies/NavMeshComponents"/></p>
<p>Now, we will dive in and explore all that this system has to offer. AI pathfinding needs a representation of the scene in a particular format; we've seen that using a 2D grid (array) for A* Pathfinding on a 2D map. AI agents need to know where the obstacles are, especially the static obstacles. Dealing with collision avoidance between dynamically moving objects is another subject, primarily known as steering behaviors. Unity has a built-in tool for generating a NavMesh that represents the scene in a context that makes sense for our AI agents to find the optimum path to the target. Pop open the demo project and navigate to the NavMesh scene to get started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inspecting our map</h1>
                
            
            
                
<p>Once you have the demo scene, NavMesh, open, it should look something like this screenshot:</p>
<div><img height="253" width="351" src="img/02e11547-8b78-46c9-9dc8-c33d3dc12349.png"/></div>
<p>A scene with obstacles and slopes</p>
<p>This will be our sandbox to explain and test the NavMesh system functionality. The general setup is similar to an RTS (real-time strategy) game. You control the blue tank. Simply click at a location to make the tank move to that location. The yellow indicator is the current target location for the tank.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigation Static</h1>
                
            
            
                
<p>The first thing to point out is that you need to mark any geometry in the scene that will be baked into the NavMesh as Navigation Static. You may have encountered this elsewhere, such as in Unity's light-mapping system, for example. Setting game objects as static is easy. You can easily toggle the <kbd>Static</kbd> flag on for all purposes (navigation, lighting, culling, batching and so on), or you can use the dropdown to specifically select what you want. The toggle is found in the top-right corner of the inspector for the selected object(s). Look at this screenshot for a general idea of what you're looking for:</p>
<div><img height="251" width="407" class="aligncenter size-full wp-image-409 image-border" src="img/0161c6b5-9d49-441d-95d0-2ae159fb52bf.png"/></div>
<p>The Navigation Static property</p>
<p>You can do this on a per-object basis, or, if you have a nested hierarchy of game objects in your hierarchy, you can apply the setting to the parent and Unity will prompt you to apply it to all children.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Baking the navigation mesh</h1>
                
            
            
                
<p>The navigation settings for the navigation mesh are applied via the Navigation window on a scene-wide basis. You can open the window by navigating to <strong>Window</strong> | Navigation in the menu bar. Like any other window, you can detach it to be free-floating, or you can dock it. Our screenshots show it docked as a tab next to the hierarchy, but you can place this window anywhere you please.</p>
<p>With the window open, you'll notice four separate tabs. It'll look something like this screenshot:</p>
<div><img height="418" width="375" src="img/68e75312-5685-42a9-96e3-b01c3f0626d0.png"/></div>
<p>The Navigation window</p>
<p>In our case, the preceding screenshot shows the Bake tab selected, but your editor might have one of the other tabs selected by default.</p>
<p>Let's take a look at each tab, starting from the left and working our way to the right, starting with the Agents tab, which looks like the following screenshot:</p>
<div><img height="289" width="383" src="img/a779bdea-6e25-4b36-9b20-3755c36c7b83.png"/></div>
<p>The Agents tab</p>
<p>If you're working on a different project, you may find that some of these settings are different than what we set them to in the sample project from which the preceding screenshot was taken. At the top of the tab, you can see a list where you can add additional agent types by pressing the "+" button. You can remove any of these additional agents by selecting it and pressing the "-" button. The window provides a nice visual of what the various settings do as you tweak them. Let's take a look at what each setting does:</p>
<ul>
<li><strong>Name</strong>: The name of the agent type to be displayed in the Agent Types dropdown.</li>
<li><strong>Radius</strong>: Think of it as the agent's "personal space". Agents will try to avoid getting too cozy with other agents based on this value, as it uses it for avoidance.</li>
<li><strong>Height</strong>: As you may have guessed, it dictates the height of the agent, which it can use for vertical avoidance (passing under things, for example).</li>
<li><strong>Step Height</strong>: This value determines how high of an obstacle the agent can climb over.</li>
<li><strong>Max Slope</strong>: As we'll see in the coming section, this value determines the max angle up which an agent can climb. This can be used to make steep areas of the map inaccessible to the agent.</li>
</ul>
<p>Next, we have the Areas tab, which looks like the following screenshot:</p>
<div><img height="252" width="376" src="img/3b31fe55-c3a0-472e-87cd-78a44d7518d2.png"/></div>
<p>As you can see in the preceding screenshot, Unity provides some default area types that cannot be edited: Walkable, Not Walkable, and Jump. In addition to naming and creating new areas, you can assign default costs to these areas.</p>
<p>Areas serve two purposes: making areas accessible or inaccessible per agent, and marking areas as less desirable in terms of navigation cost. For example, you may have an RPG where demon enemies cannot enter areas marked as "holy ground." You could also have areas of your map marked something like "marsh" or "swamp," which your agent could avoid based on the cost.</p>
<p>The third tab, Bake, is probably the most important. It allows you to create the actual NavMesh for your scene. You'll recognize some of the settings. The Bake tab looks like this:</p>
<div><img height="375" width="359" class="aligncenter size-full wp-image-408 image-border" src="img/f9482433-91a8-4304-89d5-7925486b76e0.png"/></div>
<p>The Bake tab</p>
<p>The agent size settings in this tab dictate how agents interact with the environment, whereas the settings in the Agents tab dictate how they interact with other agents and moving objects, but they control the same parameters, so we'll skip those here. The Drop Height and Jump Distance control how far an agent can "jump" to reach a portion of the NavMesh that is not directly connected to the one the agent is currently on. We'll go over this in more detail up ahead, so don't sweat it if you're not quite sure what that means yet.</p>
<p>There are also some advanced settings that are generally collapsed by default. Simply click the drop-down triangle by the Advanced heading to unfold these options. You can think of the Manual Voxel Size setting as the "quality" setting. The smaller the size, the more detail you can capture in the mesh. The Min Region Area is used to skip baking platforms or surfaces below the given threshold. The Height Mesh gives you more detailed vertical data when baking the mesh. For example, it will help preserve the proper placement of your agent when climbing up stairs.</p>
<p>The Clear button will clear any NavMesh data for the scene, and the Bake button will create the mesh for your scene. The process is fairly fast. As long as you have the window selected, you'll be able to see the NavMesh generated by the Bake button in your scene view. Go ahead and hit the Bake button to see the results. In our sample scene, you should end up with something that looks like the following screenshot:</p>
<div><img height="214" width="394" src="img/635a02ba-4a0d-4ee6-9277-a65afb81f0f7.png"/></div>
<p>The blue areas represent the NavMesh. We'll revisit this up ahead. For now, let's move on to the final tab, the Object tab, which looks like the following screenshot:</p>
<div><img height="113" width="330" src="img/c5ffe1e0-94f7-4695-8040-59605f694720.png"/></div>
<p>The three buttons pictured in the preceding screenshot, All, Mesh Renderers, and Terrains, act as filters for your scene. These are helpful when working in complex scenes with lots of objects in the hierarchy. Selecting an option will filter out that type in your hierarchy to make them easier to select. You can use this when digging through your scene looking for objects to mark as navigation static.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the NavMesh agent</h1>
                
            
            
                
<p>Now that we have our scene set up with a NavMesh, we need a way for our agent to use this information. Luckily for us, Unity provides a Nav Mesh Agent component we can throw onto our character. The sample scene has a game object named <kbd>Tank</kbd> with the component already attached to it. Take a look at it in the hierarchy, and it should look like the following screenshot:</p>
<div><img height="321" width="442" src="img/499a8c22-cba6-4488-bef5-93251b35904d.png"/></div>
<p>There are quite a few settings here, and we won't go over all of them, since they're fairly self-explanatory and you can find the full descriptions in the official Unity documentation, but let's point out a few key things:</p>
<ul>
<li>Agent Type: Remember the Agents tab in the Navigation window? The agent types you define there will be selectable here.</li>
<li>Auto Traverse Off Mesh Link: We'll get into Off Mesh Links up ahead, but this setting allows the agent to automatically use that feature.</li>
<li>Area Mask: The areas you set up in the Areas tab of the Navigation window will be selectable here.</li>
</ul>
<p>That's it. The component handles 90% of the heavy lifting for you: placement on the path, pathfinding, obstacle avoidance, and so on. The only thing you need to do is provide the agent with a target destination. Let's look at that next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting a destination</h1>
                
            
            
                
<p>Now that we've set up our AI agent, we need a way to tell it where to go. Our sample project provides a script named <kbd>Target.cs</kbd> that does just that.  </p>
<p>This is a simple class that does three things:</p>
<ul>
<li>Shoots a ray from the camera origin to the mouse world position using a ray</li>
<li>Updates the marker position</li>
<li>Updates the destination property of all the NavMesh agents</li>
</ul>
<p>The code is fairly straightforward. The entire class looks like this:</p>
<pre>using UnityEngine;<br/>using UnityEngine.AI;<br/><br/>public class Target : MonoBehaviour<br/>{<br/>    private NavMeshAgent[] navAgents;<br/>    public Transform targetMarker;<br/><br/>    private void Start ()<br/>    {<br/>      navAgents = FindObjectsOfType(typeof(NavMeshAgent)) as NavMeshAgent[];<br/>    }<br/><br/>    private void UpdateTargets ( Vector3 targetPosition )<br/>    {<br/>      foreach(NavMeshAgent agent in navAgents) <br/>      {<br/>        agent.destination = targetPosition;<br/>      }<br/>    }<br/><br/>    private void Update ()<br/>    {<br/>        if(GetInput()) <br/>        {<br/>            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br/>            RaycastHit hitInfo;<br/><br/>            if (Physics.Raycast(ray.origin, ray.direction, out hitInfo)) <br/>            {<br/>                Vector3 targetPosition = hitInfo.point;<br/>                UpdateTargets(targetPosition);<br/>                targetMarker.position = targetPosition;<br/>            }<br/>        }<br/>    }<br/><br/>    private bool GetInput() <br/>    {<br/>        if (Input.GetMouseButtonDown(0)) <br/>        {<br/>            return true;<br/>        }<br/>        return false;<br/>    }<br/><br/>    private void OnDrawGizmos() <br/>    {<br/>        Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * 5, Color.red);<br/>    }<br/>}</pre>
<p>There are a few things happening here. In the <kbd>Start</kbd> method, we initialize our <kbd>navAgents</kbd> array by using the <kbd>FindObjectsOfType()</kbd> method.</p>
<p>The <kbd>UpdateTargets()</kbd> method runs through our <kbd>navAgents</kbd> array and sets their target destination to the given <kbd>Vector3</kbd>. This is really the key to making it work. You can use any mechanism you wish to actually get the target destination, and all you need to do to get the agent to move there is set the <kbd>NavMeshAgent.destination</kbd> field; the agent will do the rest.</p>
<p>Our sample uses a click-to-move approach, so whenever the player clicks, we shoot a ray from the camera into the world towards the mouse cursor, and if we hit something, we assign that hit position as the new <kbd>targetPosition</kbd> for the agent. We also set the target marker accordingly for easy in-game visualization of the target destination.</p>
<p>To test it out, make sure you baked the NavMesh as described in the previous section, then enter play mode, and select any area on the map. If you go click-happy, you may notice there are some areas your agent <em>can't </em>reach—the top of the red cubes, the top-most platform, and the platform towards the bottom of the screen. </p>
<p>In the case of the red cubes, they're too far up. The ramp leading up to the top-most platform is too steep, as per our Max Slope settings, and the agent can't climb up to it. The following screenshots illustrate how the Max Slope settings affect the NavMesh:</p>
<p class="mce-root"/>
<div><img height="209" width="663" class="aligncenter size-full wp-image-424 image-border" src="img/904da452-21f6-4b35-a585-2345c9ba07c3.png"/></div>
<p>NavMesh with the max slope value set to 45</p>
<p>If you tweak the Max Slope to something like 51, then hit the Bake button again to re-bake the NavMesh, it will yield results like this:</p>
<div><img height="209" width="663" class="aligncenter size-full wp-image-425 image-border" src="img/54e13722-f590-42e5-ba54-3183912d0e99.png"/></div>
<p>NavMesh with the max slope value set to 51</p>
<p>As you can see, you can tweak your level design to make entire areas inaccessible by foot with a simple value tweak. An example where this would be helpful is if you had a platform or ledge that you need a rope, ladder, or elevator to get to. Maybe even a special skill, such as the ability to climb? I'll let your imagination do the work and think of all the fun ways to use this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making sense of Off Mesh Links</h1>
                
            
            
                
<p>You may have noticed that our scene features two gaps. The first one is accessible to our agent, but the one near the bottom of the screen is too far away. This is not completely arbitrary. Unity's <strong>Off Mesh Links </strong>effectively bridge the gap between segments of the NavMesh that are not connected. You can see these links in the editor, as shown in the next screenshot:</p>
<div><img height="230" width="447" src="img/4693841c-e10a-4d94-af62-ffd22c91c00f.png"/></div>
<p>The blue circles with the connecting lines are links</p>
<p>There are two ways that Unity can generate these links. The first we've already covered. Remember the Jump Distance value in the Bake tab of the Navigation window? Unity will automatically use that value to generate the links for us when baking the NavMesh. Try tweaking the value in our test scene to 5 and re-baking. Notice how, now, the platforms are linked? That's because the meshes are within the newly-specified threshold.</p>
<p>Set the value back to 2 and re-bake. Now, let's look at the second method. Create spheres that will be used to connect the two platforms. Place them roughly as shown in the following screenshot:</p>
<div><img height="223" width="392" src="img/afb8605c-b1bf-415e-bd12-df06565ec324.png"/></div>
<p>You may already see where this is going, but let's walk through the process to get these connected. In this case, I've named the sphere on the right <kbd>start</kbd>, and the sphere on the left <kbd>end</kbd>. You'll see why in a second. Next up, add the Off Mesh Link component on the platform on the right (relative to the preceding screenshot). You'll notice the component has <kbd>start</kbd> and <kbd>end</kbd> fields. As you may have guessed, we're going to drop the spheres we created earlier into their respective slots—the start sphere in the <kbd>start</kbd> field, and the end sphere in the <kbd>end</kbd> field. Our inspector will look something like this:</p>
<div><img height="131" width="410" src="img/fc74506a-1d1a-4785-88a9-5ccf1d71e15d.png"/></div>
<p>The Cost Override value kicks in when you set it to a positive number. It will apply a cost multiplier to using this link, as opposed to, potentially, a more cost-effective route to the target.</p>
<p>The Bi Directional value allows the agent to move in both directions when set to true. You can turn this off to create one-way links in your level design. The Activated value is just what it says. When set to false, the agent will ignore this link. You can turn it on and off to create gameplay scenarios where the player has to hit a switch to activate it, for example. </p>
<p>You don't have to re-bake to enable this link. Take a look at your NavMesh and you'll see that it looks like the following screenshot:</p>
<div><img height="169" width="445" src="img/20e91bab-332b-4d17-95f5-69100fbe091e.png"/></div>
<p>As you can see, the smaller gap is still automatically connected, and now we have a new link generated by our Off Mesh Link component between the two spheres. Enter play mode and click on the far platform, and, as expected, the agent can now navigate to the detached platform, as you can see in the following screenshot:</p>
<div><img height="238" width="316" src="img/97ffd6be-d9c6-45ad-9478-ab8bff38fa9e.png"/></div>
<p>In your own levels, you may need to tweak these settings to get the exact results you expect, but combining these features gives you a lot of power out-of-the-box. You can have a simple game up and running fairly quickly using Unity's NavMesh feature.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>You have now navigated your way to the end of this chapter (pun unapologetically intended). From simple waypoints, to the efficient and fast A* algorithm, to Unity's own powerful and robust NavMesh system, we've added some important and flexible tools to your game-making toolbelt. Not only do these concepts play well with each other, but they also work well with other systems we've already seen in this book, and we'll explore in those next few chapters.</p>
<p>In the next chapter,<em> </em>we'll start to look at how we can create efficient and realistic simulations for groups of agents that need to move in unison. Let's get to it!</p>


            

            
        
    </body></html>