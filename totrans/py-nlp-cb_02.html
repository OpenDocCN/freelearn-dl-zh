<html><head></head><body>
		<div id="_idContainer007" class="calibre2">
			<h1 id="_idParaDest-42" class="chapter-number"><a id="_idTextAnchor042" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">2</span></h1>
			<h1 id="_idParaDest-43" class="calibre7"><a id="_idTextAnchor043" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Playing with Grammar</span></h1>
			<p class="calibre3"><span class="kobospan" id="kobo.3.1">Grammar is one of the main building blocks of language. </span><span class="kobospan" id="kobo.3.2">Each human language, and programming language for that matter, has a set of rules that every person speaking it must follow, otherwise risking not being understood. </span><span class="kobospan" id="kobo.3.3">These grammatical rules can be uncovered using NLP and are useful for extracting data from sentences. </span><span class="kobospan" id="kobo.3.4">For example, using information about the grammatical structure of text, we can parse out subjects, objects, and relations between </span><span><span class="kobospan" id="kobo.4.1">different entities.</span></span></p>
			<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, you will learn how to use different packages to reveal the grammatical structure of words and sentences, as well as extract certain parts of sentences. </span><span class="kobospan" id="kobo.5.2">These are the topics covered in </span><span><span class="kobospan" id="kobo.6.1">this chapter:</span></span></p>
			<ul class="calibre15">
				<li class="calibre14"><span class="kobospan" id="kobo.7.1">Counting nouns – plural and </span><span><span class="kobospan" id="kobo.8.1">singular nouns</span></span></li>
				<li class="calibre14"><span class="kobospan" id="kobo.9.1">Getting the </span><span><span class="kobospan" id="kobo.10.1">dependency parse</span></span></li>
				<li class="calibre14"><span class="kobospan" id="kobo.11.1">Extracting </span><span><span class="kobospan" id="kobo.12.1">noun chunks</span></span></li>
				<li class="calibre14"><span class="kobospan" id="kobo.13.1">Extracting the subjects and objects of </span><span><span class="kobospan" id="kobo.14.1">the sentence</span></span></li>
				<li class="calibre14"><span class="kobospan" id="kobo.15.1">Finding patterns in text using </span><span><span class="kobospan" id="kobo.16.1">grammatical information</span></span></li>
			</ul>
			<h1 id="_idParaDest-44" class="calibre7"><a id="_idTextAnchor044" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.17.1">Technical requirements</span></h1>
			<p class="calibre3"><span class="kobospan" id="kobo.18.1">Please follow the installation requirements given in </span><a href="B18411_01.xhtml#_idTextAnchor013" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.19.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.20.1"> to run the notebooks in </span><span><span class="kobospan" id="kobo.21.1">this chapter.</span></span></p>
			<h1 id="_idParaDest-45" class="calibre7"><a id="_idTextAnchor045" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.22.1">Counting nouns – plural and singular nouns</span></h1>
			<p class="calibre3"><span class="kobospan" id="kobo.23.1">In this recipe, we will do two</span><a id="_idIndexMarker055" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.24.1"> things: determine whether a noun is plural or singular and turn plural nouns</span><a id="_idIndexMarker056" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.25.1"> into singular, and </span><span><span class="kobospan" id="kobo.26.1">vice versa.</span></span></p>
			<p class="calibre3"><span class="kobospan" id="kobo.27.1">You might need these two things for a variety of tasks. </span><span class="kobospan" id="kobo.27.2">For example, you might want to count the word statistics, and for that, you most likely need to count the singular and plural nouns together. </span><span class="kobospan" id="kobo.27.3">In order to count the plural nouns together with singular ones, you need a way to recognize that a word is plural </span><span><span class="kobospan" id="kobo.28.1">or singular.</span></span></p>
			<h2 id="_idParaDest-46" class="calibre5"><a id="_idTextAnchor046" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.29.1">Getting ready</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.30.1">To determine whether a noun is singular or plural, we will use </span><strong class="source-inline"><span class="kobospan" id="kobo.31.1">spaCy</span></strong><span class="kobospan" id="kobo.32.1"> via two different methods: by looking at the </span><a id="_idIndexMarker057" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.33.1">difference between the lemma and the actual word and by looking at the </span><strong class="source-inline"><span class="kobospan" id="kobo.34.1">morph</span></strong><span class="kobospan" id="kobo.35.1"> attribute. </span><span class="kobospan" id="kobo.35.2">To inflect these nouns, or turn singular nouns into plural or vice versa we will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.36.1">textblob</span></strong><span class="kobospan" id="kobo.37.1"> package. </span><span class="kobospan" id="kobo.37.2">We will also see how to determine the noun’s number using GPT-3 through the OpenAI API. </span><span class="kobospan" id="kobo.37.3">The code for this section is located </span><span><span class="kobospan" id="kobo.38.1">at </span></span><a href="https://github.com/PacktPublishing/Python-Natural-Language-Processing-Cookbook-Second-Edition/tree/main/Chapter02" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.39.1">https://github.com/PacktPublishing/Python-Natural-Language-Processing-Cookbook-Second-Edition/tree/main/Chapter02</span></span></a><span><span class="kobospan" id="kobo.40.1">.</span></span></p>
			<h2 id="_idParaDest-47" class="calibre5"><a id="_idTextAnchor047" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.41.1">How to do it…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.42.1">We will first use </span><strong class="source-inline"><span class="kobospan" id="kobo.43.1">spaCy</span></strong><span class="kobospan" id="kobo.44.1">’s lemma information to infer whether a noun is singular or plural. </span><span class="kobospan" id="kobo.44.2">Then, we will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.45.1">morph</span></strong><span class="kobospan" id="kobo.46.1"> attribute of </span><strong class="source-inline"><span class="kobospan" id="kobo.47.1">Token</span></strong><span class="kobospan" id="kobo.48.1"> objects. </span><span class="kobospan" id="kobo.48.2">We will then create a function that uses one of those methods. </span><span class="kobospan" id="kobo.48.3">Finally, we will use GPT-3.5 to find out the number </span><span><span class="kobospan" id="kobo.49.1">of nouns:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.50.1">Run  the code in the file and language </span><a id="_idIndexMarker058" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.51.1">utility notebooks. </span><span class="kobospan" id="kobo.51.2">If you run into an error saying that the small or large models do not exist, you need to open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.52.1">lang_utils.ipynb</span></strong><span class="kobospan" id="kobo.53.1"> file, uncomment, and run the statement that downloads </span><span><span class="kobospan" id="kobo.54.1">the model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.55.1">
%run -i "../util/file_utils.ipynb"
%run -i "../util/lang_utils.ipynb"</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.56.1">Initialize the </span><strong class="source-inline1"><span class="kobospan" id="kobo.57.1">text</span></strong><span class="kobospan" id="kobo.58.1"> variable and process it using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.59.1">spaCy</span></strong><span class="kobospan" id="kobo.60.1"> small model to get the resulting </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.61.1">Doc</span></strong></span><span><span class="kobospan" id="kobo.62.1"> object:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.63.1">
text = "I have five birds"
doc = small_model(text)</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.64.1">In this step, we loop through the </span><strong class="source-inline1"><span class="kobospan" id="kobo.65.1">Doc</span></strong><span class="kobospan" id="kobo.66.1"> object. </span><span class="kobospan" id="kobo.66.2">For each token in the object, we check whether it’s a noun and whether the lemma is the same as the word itself. </span><span class="kobospan" id="kobo.66.3">Since the lemma is the basic form of the word, if the lemma is different from the word, that token </span><span><span class="kobospan" id="kobo.67.1">is plural:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.68.1">
for token in doc:
    if (token.pos_ == "NOUN" and token.lemma_ != token.text):
        print(token.text, "plural")</span></pre><p class="calibre3"><span class="kobospan" id="kobo.69.1">The result should be </span><span><span class="kobospan" id="kobo.70.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.71.1">birds plural</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.72.1">Now, we will check the number of a noun using a different method: the </span><strong class="source-inline1"><span class="kobospan" id="kobo.73.1">morph</span></strong><span class="kobospan" id="kobo.74.1"> features of a </span><strong class="source-inline1"><span class="kobospan" id="kobo.75.1">Token</span></strong><span class="kobospan" id="kobo.76.1"> object. </span><span class="kobospan" id="kobo.76.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.77.1">morph</span></strong><span class="kobospan" id="kobo.78.1"> features are the morphological features of a word, such</span><a id="_idIndexMarker059" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.79.1"> as number, case, and so on. </span><span class="kobospan" id="kobo.79.2">Since we know that</span><a id="_idIndexMarker060" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.80.1"> token </span><strong class="source-inline1"><span class="kobospan" id="kobo.81.1">3</span></strong><span class="kobospan" id="kobo.82.1"> is a noun, we directly access the </span><strong class="source-inline1"><span class="kobospan" id="kobo.83.1">morph</span></strong><span class="kobospan" id="kobo.84.1"> features and get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.85.1">Number</span></strong><span class="kobospan" id="kobo.86.1"> to get the same result </span><span><span class="kobospan" id="kobo.87.1">as previo</span><a id="_idTextAnchor048" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.88.1">usly:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.89.1">
doc = small_model("I have five birds.")
print(doc[3].morph.get("Number"))</span></pre><p class="calibre3"><span class="kobospan" id="kobo.90.1">Here is </span><span><span class="kobospan" id="kobo.91.1">the result:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.92.1">['Plur']</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.93.1">In this step, we prepare to define a function that returns a tuple, </span><strong class="source-inline1"><span class="kobospan" id="kobo.94.1">(noun, number)</span></strong><span class="kobospan" id="kobo.95.1">. </span><span class="kobospan" id="kobo.95.2">In order to better encode the noun number, we use an </span><strong class="source-inline1"><span class="kobospan" id="kobo.96.1">Enum</span></strong><span class="kobospan" id="kobo.97.1"> class that assigns numbers to different values. </span><span class="kobospan" id="kobo.97.2">We assign </span><strong class="source-inline1"><span class="kobospan" id="kobo.98.1">1</span></strong><span class="kobospan" id="kobo.99.1"> to singular and </span><strong class="source-inline1"><span class="kobospan" id="kobo.100.1">2</span></strong><span class="kobospan" id="kobo.101.1"> to plural. </span><span class="kobospan" id="kobo.101.2">Once we create the class, we can directly refer to the noun number variables as </span><strong class="source-inline1"><span class="kobospan" id="kobo.102.1">Noun_number.SINGULAR</span></strong> <span><span class="kobospan" id="kobo.103.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.104.1">Noun_number.PLURAL</span></strong></span><span><span class="kobospan" id="kobo.105.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.106.1">
class Noun_number(Enum):
    SINGULAR = 1
    PLURAL = 2</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.107.1">In this step, we define the function. </span><span class="kobospan" id="kobo.107.2">It takes as input the text, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.108.1">spaCy</span></strong><span class="kobospan" id="kobo.109.1"> model, and the method of determining the noun</span><a id="_idIndexMarker061" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.110.1"> number. </span><span class="kobospan" id="kobo.110.2">The two methods are </span><strong class="source-inline1"><span class="kobospan" id="kobo.111.1">lemma</span></strong><span class="kobospan" id="kobo.112.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.113.1">morph</span></strong><span class="kobospan" id="kobo.114.1">, the same two methods</span><a id="_idIndexMarker062" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.115.1"> we used in </span><em class="italic"><span class="kobospan" id="kobo.116.1">steps 3</span></em><span class="kobospan" id="kobo.117.1"> and </span><em class="italic"><span class="kobospan" id="kobo.118.1">4</span></em><span class="kobospan" id="kobo.119.1">, respectively. </span><span class="kobospan" id="kobo.119.2">The function outputs a list of tuples, each of the format </span><strong class="source-inline1"><span class="kobospan" id="kobo.120.1">(&lt;noun text&gt;, &lt;noun number&gt;)</span></strong><span class="kobospan" id="kobo.121.1">, where the noun number is expressed using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.122.1">Noun_number</span></strong><span class="kobospan" id="kobo.123.1"> class defined in </span><span><em class="italic"><span class="kobospan" id="kobo.124.1">step 5</span></em></span><span><span class="kobospan" id="kobo.125.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.126.1">
def get_nouns_number(text, model, method="lemma"):
    nouns = []
    doc = model(text)
    for token in doc:
        if (token.pos_ == "NOUN"):
            if method == "lemma":
                if token.lemma_ != token.text:
                    nouns.append((token.text, 
                        Noun_number.PLURAL))
                else:
                    nouns.append((token.text,
                        Noun_number.SINGULAR))
            elif method == "morph":
                if token.morph.get("Number") == "Sing":
                    nouns.append((token.text,
                        Noun_number.PLURAL))
                else:
                    nouns.append((token.text,
                        Noun_number.SINGULAR))
    return nouns</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.127.1">We can use the preceding function and see its performance with different </span><strong class="source-inline1"><span class="kobospan" id="kobo.128.1">spaCy</span></strong><span class="kobospan" id="kobo.129.1"> models. </span><span class="kobospan" id="kobo.129.2">In this step, we use </span><a id="_idIndexMarker063" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.130.1">the small </span><strong class="source-inline1"><span class="kobospan" id="kobo.131.1">spaCy</span></strong><span class="kobospan" id="kobo.132.1"> model with the function we just defined. </span><span class="kobospan" id="kobo.132.2">Using </span><a id="_idIndexMarker064" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.133.1">both methods, we see that the </span><strong class="source-inline1"><span class="kobospan" id="kobo.134.1">spaCy</span></strong><span class="kobospan" id="kobo.135.1"> model gets the number of the irregular noun </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.136.1">geese</span></strong></span><span><span class="kobospan" id="kobo.137.1"> incorrectly:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.138.1">
text = "Three geese crossed the road"
nouns = get_nouns_number(text, small_model, "morph")
print(nouns)
nouns = get_nouns_number(text, small_model)
print(nouns)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.139.1">The result should be </span><span><span class="kobospan" id="kobo.140.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.141.1">[('geese', &lt;Noun_number.SINGULAR: 1&gt;), ('road', &lt;Noun_number.SINGULAR: 1&gt;)]
[('geese', &lt;Noun_number.SINGULAR: 1&gt;), ('road', &lt;Noun_number.SINGULAR: 1&gt;)]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.142.1">Now, let’s do the same using the large model. </span><span class="kobospan" id="kobo.142.2">If you have not yet downloaded the large model, do so by running the first line. </span><span class="kobospan" id="kobo.142.3">Otherwise, you can comment it out. </span><span class="kobospan" id="kobo.142.4">Here, we see that although the </span><strong class="source-inline1"><span class="kobospan" id="kobo.143.1">morph</span></strong><span class="kobospan" id="kobo.144.1"> method still incorrectly assigns singular to </span><strong class="source-inline1"><span class="kobospan" id="kobo.145.1">geese</span></strong><span class="kobospan" id="kobo.146.1">, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.147.1">lemma</span></strong><span class="kobospan" id="kobo.148.1"> method provides the </span><span><span class="kobospan" id="kobo.149.1">correct answer:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.150.1">
!python -m spacy download en_core_web_lg
large_model = spacy.load("en_core_web_lg")
nouns = get_nouns_number(text, large_model, "morph")
print(nouns)
nouns = get_nouns_number(text, large_model)
print(nouns)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.151.1">The result should be </span><span><span class="kobospan" id="kobo.152.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.153.1">[('geese', &lt;Noun_number.SINGULAR: 1&gt;), ('road', &lt;Noun_number.SINGULAR: 1&gt;)]
[('geese', &lt;Noun_number.PLURAL: 2&gt;), ('road', &lt;Noun_number.SINGULAR: 1&gt;)]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.154.1">Let’s now use GPT-3.5 to get the noun </span><a id="_idIndexMarker065" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.155.1">number. </span><span class="kobospan" id="kobo.155.2">In the results, we see that GPT-3.5 gives us an identical </span><a id="_idIndexMarker066" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.156.1">result and correctly identifies both the number for </span><strong class="source-inline1"><span class="kobospan" id="kobo.157.1">geese</span></strong><span class="kobospan" id="kobo.158.1"> and the number </span><span><span class="kobospan" id="kobo.159.1">for </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.160.1">road</span></strong></span><span><span class="kobospan" id="kobo.161.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.162.1">
from openai import OpenAI
client = OpenAI(api_key=OPEN_AI_KEY)
prompt="""Decide whether each noun in the following text is singular or plural.
</span><span class="kobospan1" id="kobo.162.2">Return the list in the format of a python tuple: (word, number). </span><span class="kobospan1" id="kobo.162.3">Do not provide any additional explanations.
</span><span class="kobospan1" id="kobo.162.4">Sentence: Three geese crossed the road."""
</span><span class="kobospan1" id="kobo.162.5">response = client.chat.completions.create(
    model="gpt-3.5-turbo",
    temperature=0,
    max_tokens=256,
    top_p=1.0,
    frequency_penalty=0,
    presence_penalty=0,
    messages=[
        {"role": "system", "content": "You are a helpful 
            assistant."},
        {"role": "user", "content": prompt}
    ],
)
print(response.choices[0].message.content)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.163.1">The result should be </span><span><span class="kobospan" id="kobo.164.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.165.1">('geese', 'plural')
('road', 'singular')</span></pre></li>			</ol>
			<h2 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor049" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.166.1">There’s more…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.167.1">We can also change the nouns </span><a id="_idIndexMarker067" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.168.1">from plural to singular, and vice versa. </span><span class="kobospan" id="kobo.168.2">We will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.169.1">textblob</span></strong><span class="kobospan" id="kobo.170.1"> package for that. </span><span class="kobospan" id="kobo.170.2">The package should be installed automatically via the </span><span><span class="kobospan" id="kobo.171.1">Poetry </span></span><span><a id="_idIndexMarker068" class="calibre6 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.172.1">environment:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.173.1">Import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.174.1">TextBlob</span></strong><span class="kobospan" id="kobo.175.1"> class from </span><span><span class="kobospan" id="kobo.176.1">the package:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.177.1">
from textblob import TextBlob</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.178.1">Initialize a list of text variables and process them using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.179.1">TextBlob</span></strong><span class="kobospan" id="kobo.180.1"> class via a </span><span><span class="kobospan" id="kobo.181.1">list comprehension:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.182.1">
texts = ["book", "goose", "pen", "point", "deer"]
blob_objs = [TextBlob(text) for text in texts]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.183.1">Use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.184.1">pluralize</span></strong><span class="kobospan" id="kobo.185.1"> function of the object to get the plural. </span><span class="kobospan" id="kobo.185.2">This function returns a list and we access its first element. </span><span class="kobospan" id="kobo.185.3">Print </span><span><span class="kobospan" id="kobo.186.1">the result:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.187.1">
plurals = [blob_obj.words.pluralize()[0] 
    for blob_obj in blob_objs]
print(plurals)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.188.1">The result should be </span><span><span class="kobospan" id="kobo.189.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.190.1">['books', 'geese', 'pens', 'points', 'deer']</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.191.1">Now, we will do the reverse. </span><span class="kobospan" id="kobo.191.2">We use the preceding </span><strong class="source-inline1"><span class="kobospan" id="kobo.192.1">plurals</span></strong><span class="kobospan" id="kobo.193.1"> list to turn the plural nouns into </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.194.1">TextBlob</span></strong></span><span><span class="kobospan" id="kobo.195.1"> objects:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.196.1">
blob_objs = [TextBlob(text) for text in plurals]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.197.1">Turn the nouns into singular using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.198.1">singularize</span></strong><span class="kobospan" id="kobo.199.1"> function </span><span><span class="kobospan" id="kobo.200.1">and print:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.201.1">
singulars = [blob_obj.words.singularize()[0] 
    for blob_obj in blob_objs]
print(singulars)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.202.1">The result should be the same as the list we started with in </span><span><em class="italic"><span class="kobospan" id="kobo.203.1">step 2</span></em></span><span><span class="kobospan" id="kobo.204.1">:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.205.1">['book', 'goose', 'pen', 'point', 'deer']</span></pre></li>			</ol>
			<h1 id="_idParaDest-49" class="calibre7"><a id="_idTextAnchor050" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.206.1">Getting the dependency parse</span></h1>
			<p class="calibre3"><span class="kobospan" id="kobo.207.1">A dependency parse is a tool that shows dependencies in a sentence. </span><span class="kobospan" id="kobo.207.2">For example, in the sentence </span><em class="italic"><span class="kobospan" id="kobo.208.1">The cat wore a hat</span></em><span class="kobospan" id="kobo.209.1">, the root of the sentence is the verb, </span><em class="italic"><span class="kobospan" id="kobo.210.1">wore</span></em><span class="kobospan" id="kobo.211.1">, and both the subject, </span><em class="italic"><span class="kobospan" id="kobo.212.1">the cat</span></em><span class="kobospan" id="kobo.213.1">, and the object, </span><em class="italic"><span class="kobospan" id="kobo.214.1">a hat</span></em><span class="kobospan" id="kobo.215.1">, are dependents. </span><span class="kobospan" id="kobo.215.2">The dependency parse can be very useful in many NLP tasks since it shows the grammatical structure of the sentence, with the subject, the main verb, the object, and so on. </span><span class="kobospan" id="kobo.215.3">It can then be used in </span><span><span class="kobospan" id="kobo.216.1">downstream processing.</span></span></p>
			<p class="calibre3"><span class="kobospan" id="kobo.217.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">spaCy</span></strong><span class="kobospan" id="kobo.219.1"> NLP engine does the dependency </span><a id="_idIndexMarker069" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.220.1">parse as part of its overall analysis. </span><span class="kobospan" id="kobo.220.2">The dependency parse tags explain the role of each word in the sentence. </span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">ROOT</span></strong><span class="kobospan" id="kobo.222.1"> is the main word that all other words depend on, usually </span><span><span class="kobospan" id="kobo.223.1">the verb.</span></span></p>
			<h2 id="_idParaDest-50" class="calibre5"><a id="_idTextAnchor051" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.224.1">Getting ready</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.225.1">We will use </span><strong class="source-inline"><span class="kobospan" id="kobo.226.1">spaCy</span></strong><span class="kobospan" id="kobo.227.1"> to create the dependency parse. </span><span class="kobospan" id="kobo.227.2">The required packages are part of the </span><span><span class="kobospan" id="kobo.228.1">Poetry environment.</span></span></p>
			<h2 id="_idParaDest-51" class="calibre5"><a id="_idTextAnchor052" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.229.1">How to do it…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.230.1">We will take a few sentences from the </span><strong class="source-inline"><span class="kobospan" id="kobo.231.1">sherlock_holmes1.txt</span></strong><span class="kobospan" id="kobo.232.1"> file to illustrate the dependency parse. </span><span class="kobospan" id="kobo.232.2">The steps are </span><span><span class="kobospan" id="kobo.233.1">as follows:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.234.1">Run the file and language </span><span><span class="kobospan" id="kobo.235.1">utility notebooks:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.236.1">
%run -i "../util/file_utils.ipynb"
%run -i "../util/lang_utils.ipynb"</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.237.1">Define the sentence we will </span><span><span class="kobospan" id="kobo.238.1">be parsing:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.239.1">
sentence = 'I have seldom heard him mention her under any other name.'</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.240.1">Define a function that will print the word, its grammatical function embedded in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.241.1">dep_</span></strong><span class="kobospan" id="kobo.242.1"> attribute, and the explanation of that attribute. </span><span class="kobospan" id="kobo.242.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.243.1">dep_</span></strong><span class="kobospan" id="kobo.244.1"> attribute of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.245.1">Token</span></strong><span class="kobospan" id="kobo.246.1"> object shows the grammatical function of the word in </span><span><span class="kobospan" id="kobo.247.1">the sentence:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.248.1">
def print_dependencies(sentence, model):
    doc = model(sentence)
    for token in doc:
        print(token.text, "\t", token.dep_, "\t", 
            spacy.explain(token.dep_))</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.249.1">Now, let’s use this function on the</span><a id="_idIndexMarker070" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.250.1"> first sentence in our list. </span><span class="kobospan" id="kobo.250.2">We can see that the verb </span><strong class="source-inline1"><span class="kobospan" id="kobo.251.1">heard</span></strong><span class="kobospan" id="kobo.252.1"> is the </span><strong class="source-inline1"><span class="kobospan" id="kobo.253.1">ROOT</span></strong><span class="kobospan" id="kobo.254.1"> word of the sentence, with all other words depending </span><span><span class="kobospan" id="kobo.255.1">on it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.256.1">
print_dependencies(sentence, small_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.257.1">The result should be </span><span><span class="kobospan" id="kobo.258.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.259.1">I    nsubj    nominal subject
have    aux    auxiliary
seldom    advmod    adverbial modifier
heard    ROOT    root
him    nsubj    nominal subject
mention    ccomp    clausal complement
her    dobj    direct object
under    prep    prepositional modifier
any    det    determiner
other    amod    adjectival modifier
name    pobj    object of preposition
.    punct    punctuation</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.260.1">To explore the dependency parse structure, we can use the attributes of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.261.1">Token</span></strong><span class="kobospan" id="kobo.262.1"> class. </span><span class="kobospan" id="kobo.262.2">Using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">ancestors</span></strong><span class="kobospan" id="kobo.264.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">children</span></strong><span class="kobospan" id="kobo.266.1"> attributes, we can get the tokens that this token</span><a id="_idIndexMarker071" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.267.1"> depends on and the tokens that depend on it, respectively. </span><span class="kobospan" id="kobo.267.2">The function to print the ancestors is </span><span><span class="kobospan" id="kobo.268.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.269.1">
def print_ancestors(sentence, model):
    doc = model(sentence)
    for token in doc:
        print(token.text, [t.text for t in token.ancestors])</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.270.1">Now, let’s use this function on the first sentence in </span><span><span class="kobospan" id="kobo.271.1">our list:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.272.1">
print_ancestors(sentence, small_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.273.1">The output will be as follows. </span><span class="kobospan" id="kobo.273.2">In the result, we see that </span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">heard</span></strong><span class="kobospan" id="kobo.275.1"> has no ancestors since it is the main word in the sentence. </span><span class="kobospan" id="kobo.275.2">All other words depend on it, and in fact, contain </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">heard</span></strong><span class="kobospan" id="kobo.277.1"> in their </span><span><span class="kobospan" id="kobo.278.1">ancestor lists.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.279.1">The dependency chain can be seen by following the ancestor links for each word. </span><span class="kobospan" id="kobo.279.2">For example, if we look at the word </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">name</span></strong><span class="kobospan" id="kobo.281.1">, we see that its ancestors are </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">under</span></strong><span class="kobospan" id="kobo.283.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">mention</span></strong><span class="kobospan" id="kobo.285.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">heard</span></strong><span class="kobospan" id="kobo.287.1">. </span><span class="kobospan" id="kobo.287.2">The immediate parent of </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">name</span></strong><span class="kobospan" id="kobo.289.1"> is </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">under</span></strong><span class="kobospan" id="kobo.291.1">, the parent of </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">under</span></strong><span class="kobospan" id="kobo.293.1"> is </span><strong class="source-inline"><span class="kobospan" id="kobo.294.1">mention</span></strong><span class="kobospan" id="kobo.295.1">, and the parent of </span><strong class="source-inline"><span class="kobospan" id="kobo.296.1">mention</span></strong><span class="kobospan" id="kobo.297.1"> is </span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">heard</span></strong><span class="kobospan" id="kobo.299.1">. </span><span class="kobospan" id="kobo.299.2">A dependency chain will always lead to the root, or the main word, of </span><span><span class="kobospan" id="kobo.300.1">the sentence:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.301.1">I ['heard']
have ['heard']
seldom ['heard']
heard []
him ['mention', 'heard']
mention ['heard']
her ['mention', 'heard']
under ['mention', 'heard']
any ['name', 'under', 'mention', 'heard']
other ['name', 'under', 'mention', 'heard']
name ['under', 'mention', 'heard']
. </span><span class="kobospan1" id="kobo.301.2">['heard']</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.302.1">To see all the</span><a id="_idIndexMarker072" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.303.1"> children, use the following function. </span><span class="kobospan" id="kobo.303.2">This function prints out each word and the words that depend on it, </span><span><span class="kobospan" id="kobo.304.1">its </span></span><span><strong class="bold"><span class="kobospan" id="kobo.305.1">children</span></strong></span><span><span class="kobospan" id="kobo.306.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.307.1">
def print_children(sentence, model):
    doc = model(sentence)
    for token in doc:
        print(token.text,[t.text for t in token.children])</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.308.1">Now, let’s use this function on the first sentence in </span><span><span class="kobospan" id="kobo.309.1">our list:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.310.1">
print_children(sentence, small_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.311.1">The result should be as follows. </span><span class="kobospan" id="kobo.311.2">Now, the word </span><strong class="source-inline"><span class="kobospan" id="kobo.312.1">heard</span></strong><span class="kobospan" id="kobo.313.1"> has a list of words that depend on it since it is the main word in </span><span><span class="kobospan" id="kobo.314.1">the sentence:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.315.1">I []
have []
seldom []
heard ['I', 'have', 'seldom', 'mention', '.']
him []
mention ['him', 'her', 'under']
her []
under ['name']
any []
other []
name ['any', 'other']
. </span><span class="kobospan1" id="kobo.315.2">[]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.316.1">We can also see left and right children in separate lists. </span><span class="kobospan" id="kobo.316.2">In the following function, we print the children </span><a id="_idIndexMarker073" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.317.1">as two separate lists, left and right. </span><span class="kobospan" id="kobo.317.2">This can be useful when doing grammatical transformations in </span><span><span class="kobospan" id="kobo.318.1">the sentence:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.319.1">
def print_lefts_and_rights(sentence, model):
    doc = model(sentence)
    for token in doc:
        print(token.text,
            [t.text for t in token.lefts],
            [t.text for t in token.rights])</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.320.1">Let’s use this function on the first sentence in </span><span><span class="kobospan" id="kobo.321.1">our list:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.322.1">
print_lefts_and_rights(sentence, small_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.323.1">The result should be </span><span><span class="kobospan" id="kobo.324.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.325.1">I [] []
have [] []
seldom [] []
heard ['I', 'have', 'seldom'] ['mention', '.']
him [] []
mention ['him'] ['her', 'under']
her [] []
under [] ['name']
any [] []
other [] []
name ['any', 'other'] []
. </span><span class="kobospan1" id="kobo.325.2">[] []</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.326.1">We can also see the </span><a id="_idIndexMarker074" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.327.1">subtree that the token is in by using </span><span><span class="kobospan" id="kobo.328.1">this function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.329.1">
def print_subtree(sentence, model):
    doc = model(sentence)
    for token in doc:
        print(token.text, [t.text for t in token.subtree])</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.330.1">Let’s use this function on the first sentence in </span><span><span class="kobospan" id="kobo.331.1">our list:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.332.1">
print_subtree(sentence, small_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.333.1">The result should be as follows. </span><span class="kobospan" id="kobo.333.2">From the subtrees that each word is part of, we can see the grammatical phrases that</span><a id="_idIndexMarker075" class="calibre6 pcalibre pcalibre1"/><a id="_idIndexMarker076" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.334.1"> appear in</span><a id="_idIndexMarker077" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.335.1"> the sentence, such as the </span><strong class="bold"><span class="kobospan" id="kobo.336.1">noun phrase</span></strong><span class="kobospan" id="kobo.337.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.338.1">any other name</span></strong><span class="kobospan" id="kobo.339.1">, and the </span><strong class="bold"><span class="kobospan" id="kobo.340.1">prepositional phrase</span></strong><span class="kobospan" id="kobo.341.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.342.1">under any </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">other name</span></strong></span><span><span class="kobospan" id="kobo.344.1">:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.345.1">I ['I']
have ['have']
seldom ['seldom']
heard ['I', 'have', 'seldom', 'heard', 'him', 'mention', 'her', 'under', 'any', 'other', 'name', '.']
him ['him']
mention ['him', 'mention', 'her', 'under', 'any', 'other', 'name']
her ['her']
under ['under', 'any', 'other', 'name']
any ['any']
other ['other']
name ['any', 'other', 'name']
. </span><span class="kobospan1" id="kobo.345.2">['.']</span></pre></li>			</ol>
			<h2 id="_idParaDest-52" class="calibre5"><a id="_idTextAnchor053" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.346.1">See also</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.347.1">The dependency parse can be</span><a id="_idIndexMarker078" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.348.1"> visualized graphically using the </span><strong class="source-inline"><span class="kobospan" id="kobo.349.1">displaCy</span></strong><span class="kobospan" id="kobo.350.1"> package, which is part of </span><strong class="source-inline"><span class="kobospan" id="kobo.351.1">spaCy</span></strong><span class="kobospan" id="kobo.352.1">. </span><span class="kobospan" id="kobo.352.2">Please see </span><a href="B18411_08.xhtml#_idTextAnchor205" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.353.1">Chapter </span></em></span></a><span><em class="italic"><span class="kobospan" id="kobo.354.1">7</span></em></span><span class="kobospan" id="kobo.355.1">, </span><em class="italic"><span class="kobospan" id="kobo.356.1">Visualizing Text Data</span></em><span class="kobospan" id="kobo.357.1">, for a detailed recipe on how to do </span><span><span class="kobospan" id="kobo.358.1">the visualization.</span></span></p>
			<h1 id="_idParaDest-53" class="calibre7"><a id="_idTextAnchor054" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.359.1">Extracting noun chunks</span></h1>
			<p class="calibre3"><span class="kobospan" id="kobo.360.1">Noun chunks are known in linguistics as noun phrases. </span><span class="kobospan" id="kobo.360.2">They</span><a id="_idIndexMarker079" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.361.1"> represent nouns and any words that depend on and accompany nouns. </span><span class="kobospan" id="kobo.361.2">For example, in the sentence </span><em class="italic"><span class="kobospan" id="kobo.362.1">The big red apple fell on the scared cat</span></em><span class="kobospan" id="kobo.363.1">, the noun</span><a id="_idIndexMarker080" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.364.1"> chunks are </span><em class="italic"><span class="kobospan" id="kobo.365.1">the big red apple</span></em><span class="kobospan" id="kobo.366.1"> and </span><em class="italic"><span class="kobospan" id="kobo.367.1">the scared cat</span></em><span class="kobospan" id="kobo.368.1">. </span><span class="kobospan" id="kobo.368.2">Extracting these noun chunks is instrumental to many other downstream NLP tasks, such as named entity recognition and processing entities and relations between them. </span><span class="kobospan" id="kobo.368.3">In this recipe, we will explore how to extract named entities from </span><span><span class="kobospan" id="kobo.369.1">a text.</span></span></p>
			<h2 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor055" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.370.1">Getting ready</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.371.1">We will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.372.1">spaCy</span></strong><span class="kobospan" id="kobo.373.1"> package, which has a function for extracting noun chunks, and the text from the </span><strong class="source-inline"><span class="kobospan" id="kobo.374.1">sherlock_holmes_1.txt</span></strong><span class="kobospan" id="kobo.375.1"> file as </span><span><span class="kobospan" id="kobo.376.1">an example.</span></span></p>
			<h2 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor056" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.377.1">How to do it…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.378.1">Use the following steps to get the noun chunks from </span><span><span class="kobospan" id="kobo.379.1">a text:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.380.1">Run the file and language </span><span><span class="kobospan" id="kobo.381.1">utility notebooks:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.382.1">
%run -i "../util/file_utils.ipynb"
%run -i "../util/lang_utils.ipynb"</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.383.1">Define the function</span><a id="_idIndexMarker081" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.384.1"> that will print out the noun chunks. </span><span class="kobospan" id="kobo.384.2">The noun chunks are contained in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.385.1">doc.noun_chunks</span></strong> <span><span class="kobospan" id="kobo.386.1">class variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.387.1">
def print_noun_chunks(text, model):
    doc = model(text)
    for noun_chunk in doc.noun_chunks:
        print(noun_chunk.text)</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.388.1">Read the text from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.389.1">sherlock_holmes_1.txt</span></strong><span class="kobospan" id="kobo.390.1"> file and use the function on the </span><span><span class="kobospan" id="kobo.391.1">resulting text:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.392.1">
sherlock_holmes_part_of_text = read_text_file("../data/sherlock_holmes_1.txt")
print_noun_chunks(sherlock_holmes_part_of_text, small_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.393.1">This is the partial result. </span><span class="kobospan" id="kobo.393.2">See the output of the notebook at </span><a href="https://github.com/PacktPublishing/Python-Natural-Language-Processing-Cookbook-Second-Edition/blob/main/Chapter02/noun_chunks_2.3.ipynb" class="calibre6 pcalibre pcalibre1"><span class="kobospan" id="kobo.394.1">https://github.com/PacktPublishing/Python-Natural-Language-Processing-Cookbook-Second-Edition/blob/main/Chapter02/noun_chunks_2.3.ipynb</span></a><span> </span><span class="kobospan" id="kobo.395.1">for the full printout. </span><span class="kobospan" id="kobo.395.2">The function gets the pronouns, nouns, and noun phrases that are in the </span><span><span class="kobospan" id="kobo.396.1">text correctly:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.397.1">Sherlock Holmes
she
the_ woman
I
him
her
any other name
his eyes
she
the whole
…</span></pre></li>			</ol>
			<h2 id="_idParaDest-56" class="calibre5"><a id="_idTextAnchor057" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.398.1">There’s more…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.399.1">Noun chunks are </span><strong class="source-inline"><span class="kobospan" id="kobo.400.1">spaCy</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.401.1">Span</span></strong><span class="kobospan" id="kobo.402.1"> objects and have all their properties. </span><span class="kobospan" id="kobo.402.2">See the official documentation </span><span><span class="kobospan" id="kobo.403.1">at </span></span><a href="https://spacy.io/api/token" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.404.1">https://spacy.io/api/token</span></span></a><span><span class="kobospan" id="kobo.405.1">.</span></span></p>
			<p class="calibre3"><span class="kobospan" id="kobo.406.1">Let’s explore some properties of </span><span><span class="kobospan" id="kobo.407.1">noun chunks:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.408.1">We will define a function that will print out the different properties of noun chunks. </span><span class="kobospan" id="kobo.408.2">It will print the text</span><a id="_idIndexMarker082" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.409.1"> of the noun chunk, its start and end indices within the </span><strong class="source-inline1"><span class="kobospan" id="kobo.410.1">Doc</span></strong><span class="kobospan" id="kobo.411.1"> object, the sentence it belongs to (useful when there is more than one sentence), the root of the noun chunk (its main word), and the chunk’s similarity to the word </span><strong class="source-inline1"><span class="kobospan" id="kobo.412.1">emotions</span></strong><span class="kobospan" id="kobo.413.1">. </span><span class="kobospan" id="kobo.413.2">Finally, it will print out the similarity of the whole input sentence </span><span><span class="kobospan" id="kobo.414.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.415.1">emotions</span></strong></span><span><span class="kobospan" id="kobo.416.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.417.1">
def explore_properties(sentence, model):
    doc = model(sentence)
    other_span = "emotions"
    other_doc = model(other_span)
    for noun_chunk in doc.noun_chunks:
        print(noun_chunk.text)
        print("Noun chunk start and end", "\t",
            noun_chunk.start, "\t", noun_chunk.end)
        print("Noun chunk sentence:", noun_chunk.sent)
        print("Noun chunk root:", noun_chunk.root.text)
        print(f"Noun chunk similarity to '{other_span}'",
            noun_chunk.similarity(other_doc))
    print(f"Similarity of the sentence '{sentence}' to 
        '{other_span}':",
        doc.similarity(other_doc))</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.418.1">Set the sentence to </span><strong class="source-inline1"><span class="kobospan" id="kobo.419.1">All emotions, and that one particularly, were abhorrent to his cold, precise but admirably </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.420.1">balanced mind</span></strong></span><span><span class="kobospan" id="kobo.421.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.422.1">
sentence = "All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind."</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.423.1">Use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.424.1">explore_properties</span></strong><span class="kobospan" id="kobo.425.1"> function on </span><a id="_idIndexMarker083" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.426.1">the sentence using the </span><span><span class="kobospan" id="kobo.427.1">small model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.428.1">
explore_properties(sentence, small_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.429.1">This is </span><span><span class="kobospan" id="kobo.430.1">the result:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.431.1">All emotions
Noun chunk start and end    0    2
Noun chunk sentence: All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind.
</span><span class="kobospan1" id="kobo.431.2">Noun chunk root: emotions
Noun chunk similarity to 'emotions' 0.4026421588260174
his cold, precise but admirably balanced mind
Noun chunk start and end    11    19
Noun chunk sentence: All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind.
</span><span class="kobospan1" id="kobo.431.3">Noun chunk root: mind
Noun chunk similarity to 'emotions' -0.036891259527462
Similarity of the sentence 'All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind.' </span><span class="kobospan1" id="kobo.431.4">to 'emotions': 0.03174900767577446</span></pre><p class="calibre3"><span class="kobospan" id="kobo.432.1">You will also see a warning message </span><a id="_idIndexMarker084" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.433.1">similar to this one due to the fact that the small model does not ship with word vectors of </span><span><span class="kobospan" id="kobo.434.1">its own:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.435.1">/tmp/ipykernel_1807/2430050149.py:10: UserWarning: [W007] The model you're using has no word vectors loaded, so the result of the Span.similarity method will be based on the tagger, parser and NER, which may not give useful similarity judgements. </span><span class="kobospan1" id="kobo.435.2">This may happen if you're using one of the small models, e.g. </span><span class="kobospan1" id="kobo.435.3">`en_core_web_sm`, which don't ship with word vectors and only use context-sensitive tensors. </span><span class="kobospan1" id="kobo.435.4">You can always add your own word vectors, or use one of the larger models instead if available.
</span><span class="kobospan1" id="kobo.435.5">  print(f"Noun chunk similarity to '{other_span}'", noun_chunk.similarity(other_doc))</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.436.1">Now, let’s apply the same function to the same sentence with the </span><span><span class="kobospan" id="kobo.437.1">large model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.438.1">
sentence = "All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind."
</span><span class="kobospan1" id="kobo.438.2">explore_properties(sentence, large_model)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.439.1">The large model does come with its own word vectors and does not result in </span><span><span class="kobospan" id="kobo.440.1">a warning:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.441.1">All emotions
Noun chunk start and end    0    2
Noun chunk sentence: All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind.
</span><span class="kobospan1" id="kobo.441.2">Noun chunk root: emotions
Noun chunk similarity to 'emotions' 0.6302678068015664
his cold, precise but admirably balanced mind
Noun chunk start and end    11    19
Noun chunk sentence: All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind.
</span><span class="kobospan1" id="kobo.441.3">Noun chunk root: mind
Noun chunk similarity to 'emotions' 0.5744456705692561
Similarity of the sentence 'All emotions, and that one particularly, were abhorrent to his cold, precise but admirably balanced mind.' </span><span class="kobospan1" id="kobo.441.4">to 'emotions': 0.640366414527618</span></pre><p class="calibre3"><span class="kobospan" id="kobo.442.1">We see that the similarity of the </span><strong class="source-inline"><span class="kobospan" id="kobo.443.1">All emotions</span></strong><span class="kobospan" id="kobo.444.1"> noun chunk is high in relation to the word </span><strong class="source-inline"><span class="kobospan" id="kobo.445.1">emotions</span></strong><span class="kobospan" id="kobo.446.1">, as compared</span><a id="_idIndexMarker085" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.447.1"> to the similarity of the </span><strong class="source-inline"><span class="kobospan" id="kobo.448.1">his cold, precise but admirably balanced mind</span></strong> <span><span class="kobospan" id="kobo.449.1">noun chunk.</span></span></p></li>			</ol>
			<p class="callout-heading"><span class="kobospan" id="kobo.450.1">Important note</span></p>
			<p class="callout"><span class="kobospan" id="kobo.451.1">A larger </span><strong class="source-inline1"><span class="kobospan" id="kobo.452.1">spaCy</span></strong><span class="kobospan" id="kobo.453.1"> model, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.454.1">en_core_web_lg</span></strong><span class="kobospan" id="kobo.455.1">, takes up more space but is </span><span><span class="kobospan" id="kobo.456.1">more precise.</span></span></p>
			<h2 id="_idParaDest-57" class="calibre5"><a id="_idTextAnchor058" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.457.1">See also</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.458.1">The topic of semantic similarity will be explored in more detail in </span><a href="B18411_03.xhtml#_idTextAnchor067" class="calibre6 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.459.1">Chapter 3</span></em></span></a><span><span class="kobospan" id="kobo.460.1">.</span></span></p>
			<h1 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor059" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.461.1">Extracting subjects and objects of the sentence</span></h1>
			<p class="calibre3"><span class="kobospan" id="kobo.462.1">Sometimes, we might need to find </span><a id="_idIndexMarker086" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.463.1">the subject and direct objects of the sentence, and that is easily accomplished with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.464.1">spaCy</span></strong></span><span><span class="kobospan" id="kobo.465.1"> package.</span></span></p>
			<h2 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor060" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.466.1">Getting ready</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.467.1">We will be using the dependency tags from </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">spaCy</span></strong><span class="kobospan" id="kobo.469.1"> to find subjects and objects. </span><span class="kobospan" id="kobo.469.2">The code uses the </span><strong class="source-inline"><span class="kobospan" id="kobo.470.1">spaCy</span></strong><span class="kobospan" id="kobo.471.1"> engine to parse the sentence. </span><span class="kobospan" id="kobo.471.2">Then, the subject function loops through the tokens, and if the dependency tag contains </span><strong class="source-inline"><span class="kobospan" id="kobo.472.1">subj</span></strong><span class="kobospan" id="kobo.473.1">, it returns that token’s subtree, a </span><strong class="source-inline"><span class="kobospan" id="kobo.474.1">Span</span></strong><span class="kobospan" id="kobo.475.1"> object. </span><span class="kobospan" id="kobo.475.2">There are different subject tags, including </span><strong class="source-inline"><span class="kobospan" id="kobo.476.1">nsubj</span></strong><span class="kobospan" id="kobo.477.1"> for regular subjects and </span><strong class="source-inline"><span class="kobospan" id="kobo.478.1">nsubjpass</span></strong><span class="kobospan" id="kobo.479.1"> for subjects of passive sentences, thus we want to look </span><span><span class="kobospan" id="kobo.480.1">for both.</span></span></p>
			<h2 id="_idParaDest-60" class="calibre5"><a id="_idTextAnchor061" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.481.1">How to do it…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.482.1">We will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">subtree</span></strong><span class="kobospan" id="kobo.484.1"> attribute of tokens to find the complete noun chunk that is the subject or direct object of the verb (see the </span><em class="italic"><span class="kobospan" id="kobo.485.1">Getting the dependency parse</span></em><span class="kobospan" id="kobo.486.1"> recipe). </span><span class="kobospan" id="kobo.486.2">We will define functions to find the subject, direct object, dative phrase, and </span><span><span class="kobospan" id="kobo.487.1">prepositional phrases:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.488.1">Run the file and language </span><span><span class="kobospan" id="kobo.489.1">utility notebooks:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.490.1">
%run -i "../util/file_utils.ipynb"
%run -i "../util/lang_utils.ipynb"</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.491.1">We will use two functions to find the subject and the direct object of the sentence. </span><span class="kobospan" id="kobo.491.2">These functions will loop through the tokens and return the subtree that contains the token with </span><strong class="source-inline1"><span class="kobospan" id="kobo.492.1">subj</span></strong><span class="kobospan" id="kobo.493.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.494.1">dobj</span></strong><span class="kobospan" id="kobo.495.1"> in the dependency tag, respectively. </span><span class="kobospan" id="kobo.495.2">Here is the subject function. </span><span class="kobospan" id="kobo.495.3">It looks for the token that has a dependency tag that contains </span><strong class="source-inline1"><span class="kobospan" id="kobo.496.1">subj</span></strong><span class="kobospan" id="kobo.497.1"> and then returns the subtree that contains that token. </span><span class="kobospan" id="kobo.497.2">There are several subject dependency tags, including </span><strong class="source-inline1"><span class="kobospan" id="kobo.498.1">nsubj</span></strong><span class="kobospan" id="kobo.499.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.500.1">nsubjpass</span></strong><span class="kobospan" id="kobo.501.1"> (for the subject of a passive sentence), so we look for the most </span><span><span class="kobospan" id="kobo.502.1">general pattern:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.503.1">
def get_subject_phrase(doc):
    for token in doc:
        if ("subj" in token.dep_):
            subtree = list(token.subtree)
            start = subtree[0].i
            end = subtree[-1].i + 1
            return doc[start:end]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.504.1">Here is the direct object function. </span><span class="kobospan" id="kobo.504.2">It works similarly to </span><strong class="source-inline1"><span class="kobospan" id="kobo.505.1">get_subject_phrase</span></strong><span class="kobospan" id="kobo.506.1"> but looks for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.507.1">dobj</span></strong><span class="kobospan" id="kobo.508.1"> dependency tag instead of a tag that contains </span><strong class="source-inline1"><span class="kobospan" id="kobo.509.1">subj</span></strong><span class="kobospan" id="kobo.510.1">. </span><span class="kobospan" id="kobo.510.2">If the</span><a id="_idIndexMarker087" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.511.1"> sentence does not have a direct object, it will </span><span><span class="kobospan" id="kobo.512.1">return </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.513.1">None</span></strong></span><span><span class="kobospan" id="kobo.514.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.515.1">
def get_object_phrase(doc):
    for token in doc:
        if ("dobj" in token.dep_):
            subtree = list(token.subtree)
            start = subtree[0].i
            end = subtree[-1].i + 1
            return doc[start:end]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.516.1">Assign a list of sentences to a variable, loop through them, and use the preceding functions to print out their subjects </span><span><span class="kobospan" id="kobo.517.1">and objects:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.518.1">
sentences = [
    "The big black cat stared at the small dog.",
    "Jane watched her brother in the evenings.",
    "Laura gave Sam a very interesting book."
</span><span class="kobospan1" id="kobo.518.2">]
for sentence in sentences:
    doc = small_model(sentence)
    subject_phrase = get_subject_phrase(doc)
    object_phrase = get_object_phrase(doc)
    print(sentence)
    print("\tSubject:", subject_phrase)
    print("\tDirect object:", object_phrase)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.519.1">The result will be as follows. </span><span class="kobospan" id="kobo.519.2">Since the first sentence does not have a direct object, </span><strong class="source-inline"><span class="kobospan" id="kobo.520.1">None</span></strong><span class="kobospan" id="kobo.521.1"> is printed out. </span><span class="kobospan" id="kobo.521.2">For the </span><a id="_idIndexMarker088" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.522.1">sentence </span><strong class="source-inline"><span class="kobospan" id="kobo.523.1">The big black cat stared at the small dog</span></strong><span class="kobospan" id="kobo.524.1">, the subject is </span><strong class="source-inline"><span class="kobospan" id="kobo.525.1">the big black cat</span></strong><span class="kobospan" id="kobo.526.1"> and there is no direct object (</span><strong class="source-inline"><span class="kobospan" id="kobo.527.1">the small dog</span></strong><span class="kobospan" id="kobo.528.1"> is the object of the preposition </span><strong class="source-inline"><span class="kobospan" id="kobo.529.1">at</span></strong><span class="kobospan" id="kobo.530.1">). </span><span class="kobospan" id="kobo.530.2">For the sentence </span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">Jane watched her brother in the evenings</span></strong><span class="kobospan" id="kobo.532.1">, the subject is </span><strong class="source-inline"><span class="kobospan" id="kobo.533.1">Jane</span></strong><span class="kobospan" id="kobo.534.1"> and the direct object is </span><strong class="source-inline"><span class="kobospan" id="kobo.535.1">her brother</span></strong><span class="kobospan" id="kobo.536.1">. </span><span class="kobospan" id="kobo.536.2">In the sentence </span><strong class="source-inline"><span class="kobospan" id="kobo.537.1">Laura gave Sam a very interesting book</span></strong><span class="kobospan" id="kobo.538.1">, the subject is </span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">Laura</span></strong><span class="kobospan" id="kobo.540.1"> and the direct object is </span><strong class="source-inline"><span class="kobospan" id="kobo.541.1">a very </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.542.1">interesting book</span></strong></span><span><span class="kobospan" id="kobo.543.1">:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.544.1">The big black cat stared at the small dog.
</span><span class="kobospan1" id="kobo.544.2">  Subject: The big black cat
  Direct object: None
Jane watched her brother in the evenings.
</span><span class="kobospan1" id="kobo.544.3">  Subject: Jane
  Direct object: her brother
Laura gave Sam a very interesting book.
</span><span class="kobospan1" id="kobo.544.4">  Subject: Laura
  Direct object: a very interesting book</span></pre></li>			</ol>
			<h2 id="_idParaDest-61" class="calibre5"><a id="_idTextAnchor062" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.545.1">There’s more…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.546.1">We can look for other objects, for example, the dative objects of verbs such as </span><em class="italic"><span class="kobospan" id="kobo.547.1">give</span></em><span class="kobospan" id="kobo.548.1"> and objects of prepositional phrases. </span><span class="kobospan" id="kobo.548.2">The functions will look very similar, with the main difference being the dependency tags: </span><strong class="source-inline"><span class="kobospan" id="kobo.549.1">dative</span></strong><span class="kobospan" id="kobo.550.1"> for the dative object function, and </span><strong class="source-inline"><span class="kobospan" id="kobo.551.1">pobj</span></strong><span class="kobospan" id="kobo.552.1"> for the prepositional object function. </span><span class="kobospan" id="kobo.552.2">The prepositional object function will return a list since there can be more than one prepositional phrase in </span><span><span class="kobospan" id="kobo.553.1">a sentence:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.554.1">The dative object</span><a id="_idIndexMarker089" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.555.1"> function checks the tokens for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.556.1">dative</span></strong><span class="kobospan" id="kobo.557.1"> tag. </span><span class="kobospan" id="kobo.557.2">It returns </span><strong class="source-inline1"><span class="kobospan" id="kobo.558.1">None</span></strong><span class="kobospan" id="kobo.559.1"> if there are no </span><span><span class="kobospan" id="kobo.560.1">dative objects:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.561.1">
def get_dative_phrase(doc):
    for token in doc:
        if ("dative" in token.dep_):
            subtree = list(token.subtree)
            start = subtree[0].i
            end = subtree[-1].i + 1
            return doc[start:end]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.562.1">We can also combine the subject, object, and dative functions into one with an argument that specifies which object to </span><span><span class="kobospan" id="kobo.563.1">look for:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.564.1">
def get_phrase(doc, phrase):
    # phrase is one of "subj", "obj", "dative"
    for token in doc:
        if (phrase in token.dep_):
            subtree = list(token.subtree)
            start = subtree[0].i
            end = subtree[-1].i + 1
            return doc[start:end]</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.565.1">Let us now define a sentence with a dative object and run the function for all three types </span><span><span class="kobospan" id="kobo.566.1">of phrases:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.567.1">
sentence = "Laura gave Sam a very interesting book."
</span><span class="kobospan1" id="kobo.567.2">doc = small_model(sentence)
subject_phrase = get_phrase(doc, "subj")
object_phrase = get_phrase(doc, "obj")
dative_phrase = get_phrase(doc, "dative")
print(sentence)
print("\tSubject:", subject_phrase)
print("\tDirect object:", object_phrase)
print("\tDative object:", dative_phrase)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.568.1">The result will be as</span><a id="_idIndexMarker090" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.569.1"> follows. </span><span class="kobospan" id="kobo.569.2">The dative object </span><span><span class="kobospan" id="kobo.570.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">Sam</span></strong></span><span><span class="kobospan" id="kobo.572.1">:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.573.1">Laura gave Sam a very interesting book.
</span><span class="kobospan1" id="kobo.573.2">  Subject: Laura
  Direct object: a very interesting book
  Dative object: Sam</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.574.1">Here is the prepositional object function. </span><span class="kobospan" id="kobo.574.2">It returns a list of objects of prepositions, which will be empty if there </span><span><span class="kobospan" id="kobo.575.1">are none:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.576.1">
def get_prepositional_phrase_objs(doc):
    prep_spans = []
    for token in doc:
        if ("pobj" in token.dep_):
            subtree = list(token.subtree)
            start = subtree[0].i
            end = subtree[-1].i + 1
            prep_spans.append(doc[start:end])
    return prep_spans</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.577.1">Let’s define a list of sentences and run the two functions </span><span><span class="kobospan" id="kobo.578.1">on them:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.579.1">
sentences = [
    "The big black cat stared at the small dog.",
    "Jane watched her brother in the evenings."
</span><span class="kobospan1" id="kobo.579.2">]
for sentence in sentences:
    doc = small_model(sentence)
    subject_phrase = get_phrase(doc, "subj")
    object_phrase = get_phrase(doc, "obj")
    dative_phrase = get_phrase(doc, "dative")
    prepositional_phrase_objs = \
        get_prepositional_phrase_objs(doc)
    print(sentence)
    print("\tSubject:", subject_phrase)
    print("\tDirect object:", object_phrase)
    print("\tPrepositional phrases:", prepositional_phrase_objs)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.580.1">The result will be </span><a id="_idIndexMarker091" class="calibre6 pcalibre pcalibre1"/><span><span class="kobospan" id="kobo.581.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.582.1">The big black cat stared at the small dog.
</span><span class="kobospan1" id="kobo.582.2">  Subject: The big black cat
  Direct object: the small dog
  Prepositional phrases: [the small dog]
Jane watched her brother in the evenings.
</span><span class="kobospan1" id="kobo.582.3">  Subject: Jane
  Direct object: her brother
  Prepositional phrases: [the evenings]</span></pre><p class="calibre3"><span class="kobospan" id="kobo.583.1">There is one prepositional phrase in each sentence. </span><span class="kobospan" id="kobo.583.2">In the sentence </span><strong class="source-inline"><span class="kobospan" id="kobo.584.1">The big black cat stared at the small dog</span></strong><span class="kobospan" id="kobo.585.1">, it is </span><strong class="source-inline"><span class="kobospan" id="kobo.586.1">at the small dog</span></strong><span class="kobospan" id="kobo.587.1">, and in the sentence </span><strong class="source-inline"><span class="kobospan" id="kobo.588.1">Jane watched her brother in the evenings</span></strong><span class="kobospan" id="kobo.589.1">, it is </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">in </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.591.1">the evenings</span></strong></span><span><span class="kobospan" id="kobo.592.1">.</span></span></p></li>			</ol>
			<p class="calibre3"><span class="kobospan" id="kobo.593.1">It is left as an exercise for you</span><a id="_idIndexMarker092" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.594.1"> to find the actual prepositional phrases with prepositions intact instead of just the noun phrases that are dependent on </span><span><span class="kobospan" id="kobo.595.1">these prepositions.</span></span></p>
			<h1 id="_idParaDest-62" class="calibre7"><a id="_idTextAnchor063" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.596.1">Finding patterns in text using grammatical information</span></h1>
			<p class="calibre3"><span class="kobospan" id="kobo.597.1">In this section, we will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.598.1">spaCy</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.599.1">Matcher</span></strong><span class="kobospan" id="kobo.600.1"> object to find patterns in the text. </span><span class="kobospan" id="kobo.600.2">We will use the grammatical properties of</span><a id="_idIndexMarker093" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.601.1"> the words to create these patterns. </span><span class="kobospan" id="kobo.601.2">For example, we might be looking for verb phrases instead of noun phrases. </span><span class="kobospan" id="kobo.601.3">We can specify grammatical patterns to match </span><span><span class="kobospan" id="kobo.602.1">verb phrases.</span></span></p>
			<h2 id="_idParaDest-63" class="calibre5"><a id="_idTextAnchor064" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.603.1">Getting ready</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.604.1">We will be using the </span><strong class="source-inline"><span class="kobospan" id="kobo.605.1">spaCy</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.606.1">Matcher</span></strong><span class="kobospan" id="kobo.607.1"> object to specify and find patterns. </span><span class="kobospan" id="kobo.607.2">It can match different properties, not just grammatical. </span><span class="kobospan" id="kobo.607.3">You can find out more in the documentation </span><span><span class="kobospan" id="kobo.608.1">at </span></span><a href="https://spacy.io/usage/rule-based-matching/" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.609.1">https://spacy.io/usage/rule-based-matching/</span></span></a><span><span class="kobospan" id="kobo.610.1">.</span></span></p>
			<h2 id="_idParaDest-64" class="calibre5"><a id="_idTextAnchor065" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.611.1">How to do it…</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.612.1">Your steps should be formatted </span><span><span class="kobospan" id="kobo.613.1">like so:</span></span></p>
			<ol class="calibre13">
				<li class="calibre14"><span class="kobospan" id="kobo.614.1">Run the file and language </span><span><span class="kobospan" id="kobo.615.1">utility notebooks:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.616.1">
%run -i "../util/file_utils.ipynb"
%run -i "../util/lang_utils.ipynb"</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.617.1">Import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.618.1">Matcher</span></strong><span class="kobospan" id="kobo.619.1"> object and initialize it. </span><span class="kobospan" id="kobo.619.2">We need to put in the vocabulary object, which is the same as the vocabulary of the model we will be using to process </span><span><span class="kobospan" id="kobo.620.1">the text:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.621.1">
from spacy.matcher import Matcher
matcher = Matcher(small_model.vocab)</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.622.1">Create a list of patterns and add them to the matcher. </span><span class="kobospan" id="kobo.622.2">Each pattern is a list of dictionaries, where each dictionary describes a token. </span><span class="kobospan" id="kobo.622.3">In our patterns, we only specify the part of speech for each token. </span><span class="kobospan" id="kobo.622.4">We then add these patterns to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.623.1">Matcher</span></strong><span class="kobospan" id="kobo.624.1"> object.  </span><span class="kobospan" id="kobo.624.2">The patterns we will be using are a verb by itself (for example, </span><em class="italic"><span class="kobospan" id="kobo.625.1">paints</span></em><span class="kobospan" id="kobo.626.1">), an auxiliary followed by a verb (for example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.627.1">was observing</span></strong><span class="kobospan" id="kobo.628.1">), an auxiliary</span><a id="_idIndexMarker094" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.629.1"> followed by an adjective (for example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.630.1">were late</span></strong><span class="kobospan" id="kobo.631.1">), and an auxiliary followed by a verb and a preposition (for example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.632.1">were staring at</span></strong><span class="kobospan" id="kobo.633.1">). </span><span class="kobospan" id="kobo.633.2">This is not an exhaustive list; feel free to come up with </span><span><span class="kobospan" id="kobo.634.1">other examples:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.635.1">
patterns = [
    [{"POS": "VERB"}],
    [{"POS": "AUX"}, {"POS": "VERB"}],
    [{"POS": "AUX"}, {"POS": "ADJ"}],
    [{"POS": "AUX"}, {"POS": "VERB"}, {"POS": "ADP"}]
]
matcher.add("Verb", patterns)</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.636.1">Read in the small part of the </span><em class="italic"><span class="kobospan" id="kobo.637.1">Sherlock Holmes</span></em><span class="kobospan" id="kobo.638.1"> text and process it using the </span><span><span class="kobospan" id="kobo.639.1">small model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.640.1">
sherlock_holmes_part_of_text = read_text_file("../data/sherlock_holmes_1.txt")
doc = small_model(sherlock_holmes_part_of_text)</span></pre></li>				<li class="calibre14"><span class="kobospan" id="kobo.641.1">Now, we find the matches using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.642.1">Matcher</span></strong><span class="kobospan" id="kobo.643.1"> object and the processed text. </span><span class="kobospan" id="kobo.643.2">We then loop through the matches and print out the match ID, the string ID (the identifier of the pattern), the start and end of the match, and the text of </span><span><span class="kobospan" id="kobo.644.1">the match:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.645.1">
matches = matcher(doc)
for match_id, start, end in matches:
    string_id = small_model.vocab.strings[match_id]
    span = doc[start:end]
    print(match_id, string_id, start, end, span.text)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.646.1">The result will be</span><a id="_idIndexMarker095" class="calibre6 pcalibre pcalibre1"/> <span><span class="kobospan" id="kobo.647.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.648.1">14677086776663181681 Verb 14 15 heard
14677086776663181681 Verb 17 18 mention
14677086776663181681 Verb 28 29 eclipses
14677086776663181681 Verb 31 32 predominates
14677086776663181681 Verb 43 44 felt
14677086776663181681 Verb 49 50 love
14677086776663181681 Verb 63 65 were abhorrent
14677086776663181681 Verb 80 81 take
14677086776663181681 Verb 88 89 observing
14677086776663181681 Verb 94 96 has seen
14677086776663181681 Verb 95 96 seen
14677086776663181681 Verb 103 105 have placed
14677086776663181681 Verb 104 105 placed
14677086776663181681 Verb 114 115 spoke
14677086776663181681 Verb 120 121 save
14677086776663181681 Verb 130 132 were admirable
14677086776663181681 Verb 140 141 drawing
14677086776663181681 Verb 153 154 trained
14677086776663181681 Verb 157 158 admit
14677086776663181681 Verb 167 168 adjusted
14677086776663181681 Verb 171 172 introduce
14677086776663181681 Verb 173 174 distracting
14677086776663181681 Verb 178 179 throw
14677086776663181681 Verb 228 229 was</span></pre></li>			</ol>
			<p class="calibre3"><span class="kobospan" id="kobo.649.1">The code finds some of the verb </span><a id="_idIndexMarker096" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.650.1">phrases in the text. </span><span class="kobospan" id="kobo.650.2">Sometimes, it finds a partial match that is part of another match. </span><span class="kobospan" id="kobo.650.3">Weeding out these partial matches is left as </span><span><span class="kobospan" id="kobo.651.1">an exercise.</span></span></p>
			<h2 id="_idParaDest-65" class="calibre5"><a id="_idTextAnchor066" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.652.1">See also</span></h2>
			<p class="calibre3"><span class="kobospan" id="kobo.653.1">We can use other attributes apart from parts of speech. </span><span class="kobospan" id="kobo.653.2">It is possible to match on the text itself, its length, whether it is alphanumeric, the punctuation, the word’s case, the </span><strong class="source-inline"><span class="kobospan" id="kobo.654.1">dep_</span></strong><span class="kobospan" id="kobo.655.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.656.1">morph</span></strong><span class="kobospan" id="kobo.657.1"> attributes, lemma, entity type, and others. </span><span class="kobospan" id="kobo.657.2">It is also possible to use regular expressions on the patterns. </span><span class="kobospan" id="kobo.657.3">For </span><a id="_idIndexMarker097" class="calibre6 pcalibre pcalibre1"/><span class="kobospan" id="kobo.658.1">more information, see the spaCy </span><span><span class="kobospan" id="kobo.659.1">documentation: </span></span><a href="https://spacy.io/usage/rule-based-matching" class="calibre6 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.660.1">https://spacy.io/usage/rule-based-matching</span></span></a><span><span class="kobospan" id="kobo.661.1">.</span></span></p>
		</div>
	</body></html>