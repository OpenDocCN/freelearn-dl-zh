- en: Navigation Behavior and Pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be explaining in detail how the AI character moves around
    and understands where he can go and where he cannot. For different types of games,
    there are different solutions and we'll be addressing those solutions in this
    chapter, exploring common methods that can be used to develop a character that
    can move correctly on the map. Also we want our character to calculate the best
    trajectory to arrive at a certain destination, avoiding obstacles and accomplishing
    goals while doing it. We will introduce how to create a simple navigation behavior,
    then we will move on to a point to point movement and finally explore in depth
    how to create a more complex point to point movement (RTS/RPG system).
  prefs: []
  type: TYPE_NORMAL
- en: Navigation behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about navigation behavior, we are referring to the actions of a
    character that is confronted with a situation where they need to calculate where
    to go or what to do. A map can have many points where it is necessary to jump
    or climb stairs in order to arrive at the final destination. The character should
    know how to use these actions to keep moving correctly; otherwise, he will fall
    down a hole or keep walking into a wall where he should be climbing some stairs.
    To avoid that, we need to plan all of the possibilities available for the character
    while he is moving, making sure that he can jump or perform any other movement
    necessary to keep moving into the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a new direction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important aspect that the AI character should have is choosing a new direction
    when he is confronted by an object that is blocking his way and that he cannot
    pass through. The character should be aware of the objects that are in front of
    him and, if he cannot keep moving forward in that direction, he should be able
    to choose a new direction, avoid colliding against the object and keep walking
    away from it.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid walking against walls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If our character is facing a wall, he will need to know that he cannot pass
    through that wall and should choose another option. Unless we allow the character
    to climb the wall or destroy it, the character will need to face a new direction
    that is not blocked and walk in that new unblocked direction.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a simple approach that i can be often very useful, and is
    perhaps the best option, depending on the type of game that we are creating. In
    the example that we'll be demonstrating, the character in question needs to keep
    moving around the level just like the *PAC-MAN*Â enemies. Starting with a basic
    example, we give our character the freedom to choose which direction to move in,
    and later on we will add more information to our character's AI so he can pursue
    a specific objective on the map using this method.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1044c2cb-d14c-43bf-9beb-d54c1d9d09a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have created a grid and painted in black the squares where the character
    AI is not allowed to walk. Now we are going to program our character to move forward
    until he finds a black square in front of him; then, he will need to choose to
    turn right or left, making that decision randomly. This will allow our character
    to move freely on the map without any specific pattern. The code for this is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we added colliders to the black squares to let the character
    know when he is touching them. This way, he will keep moving until colliding with
    a black square, and at that point there will be three options: turn left, turn
    right, or go back. To know which directions are unblocked, we created two separate
    colliders and added them to our character. Each collider has a script that gives
    the information to the character to let it know whether that side is free or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `availableLeft` Boolean corresponds to the left side, and `availableRight`
    corresponds to the right side. If the left or right collider is in contact with
    the black square, the value is set to `false`. Otherwise, it is set to `true`.
    We are using `aLeft` and `aRight` simply to check in real time if the values are
    working correctly. This way, we can see whether there are any issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we start the game, we can see that the character AI starts moving around
    on the white tiles and turning left or right every time he faces a black tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f29b9264-8591-40c3-9cdc-52281032dae7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But if we let the game run for a couple of minutes, we realize that the character
    keeps making the same decisions, and for that reason he will just be walking around
    a small portion of the map. This is due to the fact that he only makes a decision
    when colliding with a black tile, ignoring the other opportunities to turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfb84437-f25a-47b9-b07c-7c50461bf207.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding image, the character always follows the same
    pattern, not an ideal situation if we want him to constantly choose different
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an alternative path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our character successfully chooses a new direction every time that he approaches
    a wall, and now we want him to be able to move around all over the map. To make
    that happen, we are going to add more information into the character to let him
    know that if there''s an available option to turn to the left or right, even if
    the forward path is free, the character is free to turn. We can use probabilities
    to determine whether the character is going to turn or not, and for this example
    we have chosen to give a 90% chance of choosing a new direction if one is available.
    That way, we can see the results happening very quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After adding the variables we can move on to the `Start` method, everything
    that will be called on the first frame of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then we can move on the the `Update` method, everything that will be called
    every frame of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we add the trigger functions, what happens when he enters/collides against
    a 2D object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have added four new variables to our character AI script, the `probabilityTurnLeft`
    static variable, which calculates the probability of the character turning left;
    `probabilityTurnRight`, which calculates the probability of the character turning
    right; a new probability generator, `probabilitySides`, which will decide which
    way to turn when both are available and the forward path is blocked; and finally,
    a Boolean, `forwardBlocked`, to check whether the forward path is blocked or not.
    The character needs to check whether the forward path is blocked to know if he
    can turn or not. This will prevent the character from turning more than once when
    he is facing a black tile.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8e0b1d1-430f-4dd3-9c13-91a37af048fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the script that controls the side triggers, we added a new variable called
    `probabilityTurn`, which gives the character information about the probabilities.
    Every time the trigger exits the collider, he calculates the probability and sends
    a message to the character telling it that the side is free and he can make the
    decision to turn to that side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we play the game, we can see the new changes implemented to the character.
    Now he is unpredictable, choosing different paths every time and moving all around
    the map, contrary to what we had before. Once this is completed, we can create
    as many maps as we wish because the character will always find the right path
    and avoid colliding with the walls.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a282a072-4894-4427-b877-fd1ab9918f5d.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing on a bigger map, the character reacts the same way, moving around the
    whole map. This means that our main objective has been completed and now we can
    easily create new maps and use the character as the main enemy of the game so
    that he will always move differently and does not follow any pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfa3060c-b95e-4edd-a81d-da54e7035429.png)'
  prefs: []
  type: TYPE_IMG
- en: We can adjust the percentage values according to the way we want the character
    to react, and also implement more variables to make it unique to our game idea.
  prefs: []
  type: TYPE_NORMAL
- en: Point to point movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand the basics of how to create a character that can move
    freely in a maze genre game, we will take a look at the opposite: how to create
    a movement pattern from point to point. This is also an important aspect of AI
    movement, because later on we can combine both techniques to create a character
    that goes from one point to another, avoiding walls and obstacles.'
  prefs: []
  type: TYPE_NORMAL
- en: Tower defense genre
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once again, the principle that we will be using to make our character move
    from one point to another can be applied to both 2D and 3D games. In this example,
    we''ll explore how to create the main characteristic of a Tower Defense game:
    the enemy pattern. The objective is to have the enemies spawning at a start point
    and following a path so they can reach the final point. The enemies in a tower
    defense game usually just have this in mind, so it is a perfect example to test
    how to create point to point movement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *Tower Defense* game usually consists of two areas: the area where the enemies
    walk from their start position to the final position, and the area where the player
    is allowed to build towers that attack the enemies, trying to stop them reaching
    the final position. Because the player is not allowed to build anything inside
    the path where the enemies will pass, the AI does not need to be aware of its
    surroundings because it will always be free to pass through, and because of that
    we only need to focus on the point to point movement of the characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff945f5-0dd0-4235-a563-dd77b0ba2ae8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After importing the map and characters that we'll be using in the game, we need
    to configure the **waypoints** that will be used by the character so they know
    where they need to go. We can do this by manually adding the coordinates into
    our code, but to simplify the process we'll create objects in the scene that will
    serve as waypoints and we delete the 3D mesh because it won't be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we group all the waypoints that we have created and name the group waypoints.
    Once we have the waypoints in place and grouped together, we can start creating
    the code that will tell our character how many waypoints it needs to follow. This
    code is very useful because we can create different maps, using as many waypoints
    we need, without needing to update the character''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code will be assigned to the group that we have created, and will count
    the number of waypoints that he has inside of it and ordering them.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b56bafd3-551f-4ce2-b4f3-539bbee33ed9.png)'
  prefs: []
  type: TYPE_IMG
- en: The blue spheres that we can see in the preceding image represent the 3D meshes
    that we have used as waypoints. For this example, the character will follow eight
    points until he finishes the path. Now let's move on to the AI character code
    and see how we can make the character move from point to point using the points
    that we have created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the basic functions of the character, the health and speed.
    Then we can create a new variable that will tell the character the next position
    that he needs to move to, and another variable that will be used show which waypoint
    it needs to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the basic variables that are needed to make an enemy character
    move from point to point until he dies or reaches the end. Let''s see how to use
    these to make it playable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `Start` function, the first waypoint that the characters needs to follow
    is the waypoint number zero, that is, the first on the Transform list that we
    created in the `waypoints` code. Also, we have determined the velocity of the
    character, and for this example we have chosen `10f.`
  prefs: []
  type: TYPE_NORMAL
- en: Then in the `Update` function the character will calculate the distance between
    the next position and the current position, using the Vector 3 `dir`. The character
    will constantly be moving, so we have created a line of code that serves as movement
    for the character, `transform.Translate` in this case. Knowing the distance and
    the speed information, the character will know how far it is from the next position,
    and once he reaches the desirable distance from that point, he can then move on
    to the next point. To make this happen, we create an `if` statement that will
    tell to the character that, if he reaches 0.4f (for this example) from the point
    that he is moving towards, it means that he has already arrived at that destination
    and can start moving on to the next point, `GetNextWaypoint()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GetNextWaypoint()` function, the character will try to confirm if he
    has arrived at the final destination. If the character has arrived at the final
    waypoint, then the object can be destroyed; if not, it can continue to the next
    waypoint. Here, `wavepointIndex++` will add one number to the index every time
    the character arrives at a waypoint, moving from 0>1>2>3>4>5, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we assign the code to our character and place the character on the start
    position and test the game to see if it is working properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/216e5d9a-70eb-4a37-b137-12e0f07f1112.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything is working as expected: the character will move from one point to
    another until he arrives at the last one, and then he disappears from the game.
    However, there are still some improvements we need to make, because the character
    is facing always the same direction; he does not rotate when he changes direction.
    Let''s take the opportunity to also create the instantiating code that will keep
    spawning enemies into the map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way we created an object to define the waypoint, we''ll do the
    same for the start position, creating an object that will simply serve as position,
    so we can spawn the enemies from that point. To make that happen, we create a
    simple code just to test the gameplay without it being necessary to manually add
    the characters to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At this moment, we already have a `wave spawner` working as well, spawning a
    new wave of enemies every three seconds. This will help us visualize the gameplay
    that we are creating for our AI character. We have five variables. `enemyPrefab`
    is the character that we are creating, so the code can spawn him. `timeBetweenWaves`
    represents the time that it will wait before spawning a new wave. The `spawnPoint`
    variable determines the position where the character will appear, the start position.
    Here, `countdown` is the time that we wait before the first wave appears. `waveNumber`
    is the last variable, and serves to count the current wave (usually, this is used
    to differentiate the enemy difficulty from one wave to another).
  prefs: []
  type: TYPE_NORMAL
- en: If we run the game now, we can see that the number of characters appearing in
    the game is much more than just one, increasing every three seconds. Doing this
    at the same time as we develop our AI character is very useful, because if our
    characters have special abilities or if they have different speeds, we can fix
    it right away while we are developing them. Because we are just creating a small
    example, it is expected to work smoothly without any bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it out now to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7e68b0e-c3d4-46fe-b3c2-5e83cbf6f08a.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks much more interesting now! We can see that the point to point movement
    is working as intended, and all the characters spawned into the game know where
    they need to go, following the right path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update the character code so it can turn to face the next point
    position while going around corners. To create this, we add a few more lines to
    the enemy code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we have added a new variable called `speedTurn`,
    which will represent the velocity of our character when turning, and in the `start`
    function we have determined the speed value as `0.2f`. Then, in the update function,
    we calculate the velocity by multiplying this number by `Time.deltaTime`, giving
    a constant value regardless of the `FPS` number that the player is experiencing.
    Then we have created a new `Vector3` variable called `newDir`, which will make
    our character turn towards the target position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we test the game once more, we can see that the characters turn towards
    their next point position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1642b11f-90fc-45b4-963c-77087671c1fb.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we can see that the AI characters are reacting correctly, moving
    from point to point as intended and turning towards their next position. Now we
    have the basics of a tower defense game and, we could add unique code to create
    a new and enjoyable game.
  prefs: []
  type: TYPE_NORMAL
- en: Racing genre
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Point to point movement is a method that can be applied to practically any game
    genre and it has been extensively used over the years. Our next example is a racing
    game, where the AI drivers use point to point movement to compete against the
    player. To create this, we would need a road and a driver and then we'll place
    the waypoints on the road and tell our AI driver to follow that path. It's very
    similar to what we have done before but with some behavior differences in our
    character because we don't want it to look rigid when he is turning and also there
    will be other drivers on the same map and they cannot overlap one on top of another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado let''s start, first we need to establish the map, which
    in this case is the race track:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c07ab290-7a8e-49e6-b4e4-85875acb3f11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After designing our race track, we need to define every point position that
    our drivers need to go to, and because we have a lot of curves, we need to create
    more point positions than we had before so that the car follows the road smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have done the same process as before, creating objects inside the game and
    using them as position references only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b80e6720-a2e8-49bd-b363-a49d2197a342.png)'
  prefs: []
  type: TYPE_IMG
- en: This is our map with the waypoints in place, and as we can see, there are more
    points on the curves. This is very important if we want to achieve a smooth transition
    from one point to another.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's group all the waypoints again, and this time we'll create a different
    code. Instead of creating a code that manages the waypoints, we will be implementing
    that calculation inside of our AI driver code and creating a simple code to apply
    to each waypoint to specify the next position to follow.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways that we can develop our code, and depending on our preferences
    or the game genre that we are working on, some methods can work better than others.
    In this case, we have found that using the code we developed for our Tower Defense
    character does not fit with this game genre.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the AI driver code, we have used ten variables, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first one, `raceStarted`, is a static Boolean that will tell our driver
    whether the race has started. This takes into consideration the fact that the
    race only begins when the green light appears; if not, `raceStarted` is set to
    `false`. Next, we have `aiSpeed`, which represents the velocity of the car. This
    is a simplified version for test proposes; otherwise, we would need speed functions
    to determine how fast can the car is going according to the gear that is set.
    `aiTurnSpeed` represents the velocity of the car when he is turning, how fast
    we want the car to steer when he is facing a new direction. Next, we have the
    `waypointController`, which will be linked to the waypoints group; and the `waypoints`
    list, which will be taken from that group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `currentWaypoint` will tell our driver which waypoint number he is currently
    following. The `currentSpeed` variable will show the current velocity of the car.
    Finally, `currentWaypointPosition` is the Vector 3 position of the waypoint that
    the car will be following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `start` function, we have only three lines of code: `GetWaypoints()`,
    which will access all of the waypoints that exist inside of the group, and `resetAISpeed`
    and `resetAITurnSpeed`, which reset the speed values because they will influence
    the rigid body placed on the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the update function, we have a simple `if` statement that checks whether
    the race has started or not. If the race has started, then he can proceed to the
    next step, which is the most important for our AI driver, `MoveTowardWaypoints()`.
    For this example, we have not stated anything while the car is waiting for the
    green light, but we could have implemented the engine starting and the pre-acceleration
    of the car, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have `GetWaypoints()`, which was instantiated in the `Start` function.
    Here, we access the `waypointController` group and retrieve all the position information
    regarding the waypoints that are stored inside it. Because we will be ordering
    the waypoints in a different code, we don''t need to do that here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have the `MoveTowardsWaypoints()` function. Because the car has
    more depth in terms of mobility than a simple Tower Defense character, we decided
    to expand and implement more content in this part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we retrieve the Vector 3 position of the current waypoint that is being
    used. We have chosen to retrieve this information and assign the axis separately,
    and for that reason we have `currentWaypointX` for the X axis, `currentWaypointY`
    for the Y axis, and `currentWaypointZ` for the Z axis.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create a new Vector 3 direction called `relativeWaypointPosition`, which
    will calculate the distance between the waypoint and the current position of the
    car and convert from World Space to Local, and in this case we have used `InverseTransformDirection`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eca4daa4-b5f5-4418-8cf1-342bca678f56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see represented on the preceding graphic, we want to calculate the
    distance in local space between the car and the waypoint. This will tell to our
    driver if the waypoint is at his right or left side. This is recommended because
    the wheels command the car speed and they have an independent rotation value and
    if we kept working on this game, it would be one feature that would still need
    to be developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To smooth the rotation between one waypoint to another, we have used the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an updated version of what we used in the Tower Defense. It will make
    our car move smoothly towards the waypoint that the car is traveling toward. This
    gives the effect of the car turning; otherwise, he would turn right away towards
    the waypoint and it would look unrealistic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b510d9d0-00a0-4fa9-8628-e0cb9c7aa616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, straight lines do not fit the genre that we are currently creating.
    It works perfectly in other genres, like Tower Defense game, but for a racing
    game it is necessary to redefine the code to adjust to the situation that we are
    creating.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is exactly that, adjustments for the situation that we
    are creating, which is a car moving on a race track. There are force elements
    such as `drag`, which is the friction between the car and the road, represented
    in this code. When we turn the car, it will slide according to the velocity of
    the car at that moment, and these details are taken into consideration here, creating
    a more realistic point to point movement where we can see that the car is reacting
    according to physics.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the full code that we have used in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we start the game and test it, we can see that he is working fine. The car
    drives by itself, turns smoothly, and completes the track as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the basic point to point movement completed, we could implement
    more functions for the AI driver and start developing the game as we want. It
    is always recommended to start with the main functions of the gameplay before
    developing any details. This will help identify any ideas that we had planned
    for the game that do not work as well as we thought.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e69f4df7-1a8d-444c-82d0-5d93aab94edd.png)'
  prefs: []
  type: TYPE_IMG
- en: MOBA genre
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Point to point movement is one of the most commonly used methods to control
    the movement of a character. It is self-explanatory why it is widely used, because
    the character moves from one point to another and usually that's we want; we want
    the character to arrive at certain destination or follow another character. One
    game genre that also requires this type of movement is the Multiplayer Online
    Battle Arena (MOBA) games that have become very popular recently. Usually, there
    are NPC characters that spawn at the start position and follow a predetermined
    path towards the enemy towers, similar to the Tower Defense enemies, but in this
    case the AI characters move in the same terrain as the players and can interfere
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map is divided into two equal parts, where one side needs to fight the
    other, and for each part it spawns a different platoon that is composed of small
    enemies called Minions or Creeps. When they are following their path, if one platoon
    finds the other, they stop moving forward and start attacking. After the battle,
    the survivors keep moving forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56c70510-4439-4e49-8f62-2511f17d9324.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example we are going to re-create that portion of the game, where the
    platoon spawns at the start position, follows their path, stops when they find
    the enemies and keep moving towards their next direction until they win the fight.
    Then we will create the basic movement of the hero character that is controlled
    by the player or the computer: both have the freedom to move around the map and
    the characters needs to follow the direction that is directed by the player or
    computer while avoiding all obstacles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by importing the map into our game. We have chosen a generic
    MOBA style map, like we can see on the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bc9983d-7af5-4eb5-b1da-4106f407a258.png)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to create waypoints in the map. Here we will have six different
    waypoints groups, because each team has three different paths and each platoon
    can only follow one path. We start from the base position and then we add more
    waypoints until we reach the enemy base. The following image shows an example
    of what we have created.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/113a359a-2c3d-495b-85fe-944a0a3d2418.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to create three different waypoint groups for each team, because there
    will be three different spawn positions as well; they will work independently
    from one another. After setting the waypoints, we can group them and assign the
    code that will gather the position information and the order that the platoon
    should follow. For this example, we can use the same code that we used for the
    Tower Defense waypoints, because the way that the enemies follow their path is
    similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have six different waypoint groups, it is necessary to duplicate
    the same code six times and rename them accordingly. Our `spawnable` enemies will
    later access the right path for them, so it is recommended to rename the groups
    and codes so that we can easily understand which group represents which lane,
    for example, 1_Top/1_Middle/1_Bottom and 2_Top/2_Middle/2_Bottom. The number represents
    their team and the position name represents the position. In this case, we change
    the name `points` in our code to the correct names that represent each lane:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lane Team 1 Top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Lane Team 1 Middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lane Team 1 Bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lane Team 2 Top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lane Team 2 Middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lane Team 2 Bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created all the groups and codes for each of them, we can
    move on to the character AI that will follow their path towards the enemy base.
    We can choose to duplicate the code for each team or integrate everything inside
    the same code, using `if` statements to decide which path the character should
    follow. For this example, we have chosen to integrate everything in the same code.
    That way, we can update the character code once and it will work for both teams
    at the same time. Once again, we can start by using the same code that we used
    in the enemies from the Tower Defense game. We can change the code so he will
    fit in the game that we are currently creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we can make the character follow the path and turn smoothly
    when changing from one point to another. At this point we just need to change
    the code to make him fit the game genre that we are creating. To do that the first
    thing we need to consider is changing the name points to the names that we've
    previously created, and add `if` statements to choose which side the character
    needs to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the information that distinguish the characters of one
    team from another. To do that, we need to create two new Boolean variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let us decide if the character is from Team1 or Team2, both cannot
    be true at the same time. Now we can implement more details into the character
    code, to let him know which lane he should walk on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have added three more Booleans that will indicate the lane that the character
    needs to follow. After working out which team the character is spawning from,
    another `if` statement will be added to determine the lane that the character
    will follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have added those variables, we need to assign the waypoint groups that
    we created before according to the lane that the character will follow. We can
    implement that right in the `start` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows the character to question the team that it is representing, the
    lane where it spawned, and the path that he will follow. We need to adjust the
    rest of the code so it will work for this example. The next modification will
    be in the `GetNextWaypoint()` function. We need to add the `if` statements to
    let the character know the correct next waypoint that he needs to follow, similar
    to what we did in the `Start` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, if we add a character to the game and assign it the AI code,
    it will follow the chosen path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4be59aba-e3d4-40d2-b4ed-ae187f2fe767.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is working properly, and we are ready to implement more features to create
    the perfect platoon that follows a path toward the enemy tower and that stops
    to fight the other platoon or the hero. Any details or uniqueness that we want
    to add to our platoon can be applied now that we have the basic movement working.
    Here, we have attached the complete code for the platoon AI character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the variables in the preceding code we can move on to the `Start`
    method that will be called on the first frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Update` method that will be called every frame of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Another important aspect of a MOBA game is the hero's movement. Even if it's
    controlled by the player, the character has AI to determine the path that he needs
    to follow in order to arrive at the chosen destination. To complete this task,
    we will introduce the point to point method first; then we will continue the same
    example but using an advanced method that will make our character decide the best
    path to arrive at the final destination without implementing any waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will also serve as an example of how to create a character that
    follows the player. To do this, we need to set all the possible paths that the
    character is allowed follow. We want the AI to avoid colliding with objects or
    passing through walls, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03647230-0824-4d25-8e17-fc604ca2b630.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's focus on this area of the map. As we can see, there are walls and trees
    blocking a portion of the map, and the characters should not be allowed to pass
    through them. Using the waypoints method, we will create points on the map that
    the character should follow if he wants to reach a certain destination. he won't
    have any specific order like the previous examples that we have created, because
    the character can move in any direction, and for that reason we cannot predict
    the path that it will choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by positioning the waypoints on the walkable positions. This will
    prevent the character from moving on the non-walkable area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1894131-e2ba-4822-8573-2cc0a0ae09d0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The stars that we see on the map represent the waypoints that we have created,
    so we should only place them in the areas that the character is able to walk in.
    If the character wants to move from one position to another, it must follow the
    waypoints until it gets to the closest waypoint to the desired destination.
  prefs: []
  type: TYPE_NORMAL
- en: In the gameplay mechanics, we can choose why the character needs to reach a
    certain destination, such as following the player, going to the base to recover
    health points, moving towards the enemy wall to destroy it, and many others choices.
    Independently of what the character AI needs to achieve, it needs to move correctly
    on the map, and this waypoints system will work in any circumstance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we can find the full code that will make this work. Then we''ll explain
    everything in detail to better understand how to replicate this code so it can
    work in a different game genre:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we assign this code into our character and hit the play button, we can test
    the game and see that what we have created works perfectly. The character should
    use the waypoint positions to move across the map to reach the desired destination.
    This method can be used for NPC characters and playable characters as well, because
    for both cases the characters need to avoid colliding with the wall and obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9c1db85-e8e7-4e57-b927-b52fb4e025b8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we continue the example and expand the waypoints across the whole map, we
    have a basic MOBA game working properly, with a platoon of monsters spawning at
    each base and following the right path, and hero characters that can move freely
    on the map without colliding with walls.
  prefs: []
  type: TYPE_NORMAL
- en: Point to point movement and avoiding dynamic objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have characters that can follow the right path and avoid static
    objects, we are ready to move on to the next level and make those characters avoid
    dynamic objects while moving from point to point. We will revise the three different
    examples created in this chapter and see how we can add the avoiding technique
    to the AI characters in those examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those three methods should cover almost every game genre that uses point to
    point movement as their primary method of locomotion, and we will be able to create
    new ideas with these examples as a guideline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20bf6ea9-cf58-48ad-a4a4-0ff9999b85eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with the racing game, where we have a car that drives around the
    track until he finishes the race. If the car drives alone and there's nothing
    obstructing the path, it won't be necessary to avoid any obstacles, but usually
    obstacles make the game more interesting or challenging, especially when they
    are spontaneous and we don't expect them. A great example of this is the Mario
    Kart game, where they throw bananas and other objects to destabilize the opposing
    players, and the objects don't have any pre-defined position so the characters
    can't predict where they're going to be. So it is important for the drivers to
    have the necessary functions to avoid colliding with those objects and be able
    to do that in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that two objects appeared unexpectedly on the road while the AI character
    was following the next waypoint, we want the character to anticipate the collision
    and turn around to avoid crashing against the object. The method that we will
    be using here is a combination of the waypoint movement with the maze movement.
    The character can only obey one order at a time, he can either respect the waypoint
    movement or the maze movement, and that''s exactly what we need to add on to our
    code so the character AI can choose the best option according the current situation
    that he is facing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the preceding variables, we can move on to the `Start` method.
    This will be called in the first frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Update` method that will be called every frame of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added four new static variables to our code: `isBlocked`, `isBlockedFront`,
    `isBlockedRight`, and `isBlockedLeft`. This will check if the path in front of
    the car is free from obstacles or not. The car will continue following the waypoint
    path until something appears and the car needs to turn left or right to pass the
    obstacle. To make this work, we need to add at least three sensors in front of
    the car. When they interact with some object, the sensor gives that information
    to the AI driver, and at this point it will choose the best option according to
    that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/531474be-12b7-41b5-b7be-e0927c7c62d1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding image, the car now has three sensors attached
    to it. In this example, the right sensor will report that it is blocked by an
    obstacle and the driver will turn left until that side is free again. Once the
    three sensors report that nothing is obstructing the driver's path, the car will
    return to following the waypoint that it was previously moving towards. If we
    notice that the driver doesn't recognize some obstacles, it is recommended to
    increase the number of sensors to cover a larger area.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the platoon characters that we created for the MOBA example.
    Here, we will need to create a different method, because the characters will move
    towards the next waypoint until they find something, but this time we don't want
    them to move away. Instead, we want the character to move towards the character
    that they have found.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b05980d-03bd-42d0-bf1c-52706cf2b4e2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create this, we will add a circular or spherical collider to our character.
    This will serve as detection. If something triggers that zone, the character will
    stop moving towards its waypoint and use the position of the hero that triggered
    the collider as a waypoint to pursue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the preceding variables, we can move on to the `Start` method,
    which will be called on the first frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Update` method that will be called every frame of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This `GetNextWaypoint` method is used to gather the information regarding the
    next waypoint that the character needs to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `GetHeroWaypoint` method, we set what happens when the character needs
    to follow the Hero direction, like attacking or any other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We've added a spherical collider to the character that gives the trigger information
    to the character, to know if a hero character has entered that zone. If no hero
    triggered that zone, the character will continue following the waypoint, otherwise
    it will focus his attention to the hero and use him as a target point.
  prefs: []
  type: TYPE_NORMAL
- en: With this example we learned the core features of the artificial intelligence
    movement that can be found in a MOBA game and now we can re-create this popular
    game genre. From this chapter onwards we can create simple to complex navigation
    systems and use them to make our AI character more active in the game, constantly
    pursuing an objective even if that objective is moving.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced point to point movement, a method that is
    widely used in many games today, and we can adapt the codes that we have created
    to work in practically any game. At this point ,we are able to re-create many
    popular games and add our personal touch to them. In the next chapter, we'll continue
    talking about movement, but we will be focusing on an advanced aspect called the
    Theta algorithm. This will serve as a continuation of what we have learned in
    this chapter, and we will be able to create a character AI that, without any previous
    information or positions, will be able to find for itself the best path to follow
    in order to arrive at a certain destination.
  prefs: []
  type: TYPE_NORMAL
