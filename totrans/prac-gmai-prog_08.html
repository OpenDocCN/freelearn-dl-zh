<html><head></head><body>
        

                            
                    <h1 class="header-title">Crowd Interactions</h1>
                
            
            
                
<p class="mce-root">After understanding how to develop an AI character that can move freely around the map, searching for the best paths to arrive at certain destinations, we can start working on the interaction between characters. In this chapter, we will be looking at realistic crowd interactions, how to develop a believable crowd behavior, and how a character should perceive the rest of the group. The goal of this chapter is to keep giving information to our AI character about the environment, and in this particular case, about the other intelligent agents of the game. On this chapter, we will be talking about AI coordination, communication and crowd collision avoidance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is crowd interaction</h1>
                
            
            
                
<p class="mce-root">Crowd interaction is a real-life subject that usually refers to multiple organisms sharing the same space. One big example is the human life, how humans interact with other humans and also other species. The decisions that we make most of the time involve other people, from the simple decisions to the most advanced and complicated ones. Let's assume that we want to buy a ticket for the cinema and the movie starts at 3pm. If we were the only ones interested in watching that movie, we could arrive only 2 minutes before it starts to buy a ticket and we would be on time to watch the movie. But if more than 100 people are interested in watching that same movie, we need to anticipate that and arrive much earlier at the cinema so we have time to buy the ticket. Once we arrive at the cinema, there are rules about how we should wait until it is our turn to buy the ticket. Usually we wait behind the last person that is in the line. This behavior is an example of crowd interactions. We live surrounded by other humans, and for that reason we need to adapt our goals accordingly.</p>
<p class="mce-root">In video games, we also can find this type of interaction, and can go from simple behaviors to advanced and complex ones. If we have more than one AI character in the game and they share the same space, there will be times where one will collide with another. It's up to the creators to think about that, about what would happen if two characters try to do the same thing at the same time, if it makes sense or if it will result in bugs. To solve these problems, we need to think about them and implement decisions that will help characters share the same space together, avoiding errors and behaving more realistically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Video games and crowd interactions</h1>
                
            
            
                
<p>As we have discovered before, crowd interactions are a real-life matter, but it can be found in video games, especially those that relies on human-like aspects. Because of the popularity of open-world maps, crowd interactions became a very important aspect when developing the game, because the AI agents of the game are constantly sharing the same space. This means that almost every open world game has the necessity to plan a crowd interaction system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Assassin's Creed</h1>
                
            
            
                
<p>A very popular case of crowd interaction system on a video game can be found in the Assassin's Creed series. The non-playable characters walk around the map in groups, and in a simple way they avoid collisions and interact with the environment. This helps create a realistic atmosphere to the game, a crucial point that can make the game believable and submerging the player into a virtual world:</p>
<div><img class="image-border" src="img/52444350-b868-4ab5-97b1-3a826afe3222.jpg"/></div>
<p>Not only can we see group interaction in the general population of the game, but also in the guards and especially in the combat. From time to time, the player needs to fight against a few guards, and usually there is more than one guard ready to attack the player. One interesting point is that the guards don't attack at the same time; they evaluate the situation and wait for a better opportunity to attack.</p>
<p>This concept gives a sense of interaction between the multiple non-playable characters:</p>
<div><img class="image-border" src="img/f2ad65ed-e933-45e8-aa94-d7ca1e6f8741.jpg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Grand Theft Auto (GTA)</h1>
                
            
            
                
<p>The Grand Theft Auto game series is a source of many interesting lessons that we can learn with it. The constant seek to keep improving the game every time by trying to make it more realistic and believable changed the focus of the player to the surroundings, instead of simply looking at the main character. To make the surroundings more appealing and realistic, the creators of the game started to spend more time developing AI agents, how they move, how they react, and how they interact. The interaction between the AI characters was groundbreaking at the time.</p>
<p>The player could see characters stopping to talk with each other, confronting physically with each other in more dramatic events, and all of that made the environment much more alive:</p>
<div><img class="image-border" src="img/21a41ff4-8535-4980-b5d8-7d1bd150ddc3.jpg"/></div>
<p>As we can see on the preceding screenshot, the streets of the game are populated by distinct individuals that are interacting with each other. We can see a man taking his dog for a walk, two girls talking, a young woman taking a picture of another woman, and all of this does not contribute in any way to the gameplay but it makes the experience much more vivid and realistic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Sims</h1>
                
            
            
                
<p>Another great example of crowd interaction can be found in the real-life simulator game, <em>The Sims</em>. Once again we are mentioning this game because it shaped the way developers create their games, and in terms of AI, they have contributed a lot about it.</p>
<p>Non-playable characters do not mean that they simply need to be in idle position, waiting for something to happen. Here we can see that all the characters have unique personalities and that they interact with each other. Even if the player sets aside the controller and just watches the game, there will be many interesting things going on, and all of that comes from the AI characters:</p>
<div><img class="image-border" src="img/1605c596-5a81-48d4-81ef-299150733b38.jpg"/></div>
<p>Previously in this book we have analyzed the priorities of <em>The Sims</em> characters, and we know that they can decide not to do one thing if another is more important at the time. And now that we know how pathfinding works, we can even implement a more advanced system into the characters, for example, letting them organize their priorities, taking in consideration the time that its necessary for them in order to reach the specific destination that lets them conclude the task. But all of that will be explored in a moment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">FIFA/Pro evolution soccer</h1>
                
            
            
                
<p>Another example that is extremely important to mention is the AI character that can be found in multiple sports games. Even if from the outside it doesn't look a game genre that is complex, sports games are probably the most advanced in terms of AI development.</p>
<p>The reason is that the games are based on real-life sports, and many of them are team sports. The difficulties in developing a realistic and functional team sports game are numerous, and for that reason it is a great case study:</p>
<div><img class="image-border" src="img/2cb015b7-8035-4e2e-beaa-86203143963e.jpg"/></div>
<p>The preceding screenshot shows gameplay footage of FIFA 17. Here we can see that only one character has the possession of the ball, while all the others are spread apart, either waiting for the character to pass the ball or anticipating the character's position in order to attempt win the ball from him. In total, that makes one ball for twenty-two characters in the game (eleven for each side). This is the reason why sports games require well-developed AI characters, because they are constantly working even if they don't have the ball. Individually, they have a position/role that they play, defending or attacking, left, right, or middle position, and many more. In the group, they all need to follow a strategy together and obey the rules of the game. If our teammate has the ball and is running forward, we can support him by running in the same direction, making it easy for him to pass, or we can stay behind because if that player loses the ball, someone needs to catch it back.</p>
<p>The interactions between the other characters are happening constantly, and it's not only about running after the ball to see who can get it first, it's about sharing a lot of information between them and trying to win the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning crowd interactions</h1>
                
            
            
                
<p>Sometimes we put aside the planning phase while creating a game and think that all we need to create an awesome game is to have an idea and everything will flow smoothly from our head. Successful games are successful because every step of the development is planned to the smallest detail, and we should remember that when creating our own games. At this point, we have a strong technical knowledge to develop a challenging and interesting game with plenty of AI features in it, so our next step is to combine the ability to create games with a plan to make them look better.</p>
<p>Now that we've analyzed some popular examples of crowd interaction systems in video games, we can take a look at how to plan these types of interaction. We will follow the examples from before and see how we can plan similar crowd interaction into our games.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Group fight</h1>
                
            
            
                
<p>Let's create a scenario where we have multiple AI characters fighting the player. We start by implementing the combat features into the character code, such as attacking with one hand, attacking with two hands, defending, going after the player, and all of that. Once we have that implemented, the character is able to fight the player and that's the starting point. If we didn't plan anything and we had four characters fighting the player, they all would attack at the same time to defeat the player.</p>
<p>That would have worked with a few bugs here and there, but it would do the job if we didn't have time to create a better system. What we are looking for is to get some interaction between the AI characters so they won't look stupid attacking the player at the same time without analyzing the situation:</p>
<div><img class=" image-border" src="img/8a39d025-1b69-4b1c-bd63-f1160e9bbd32.png"/></div>
<p>So, now that we have the game running and we have enemy characters that follow the player and attack him, we want to plan the interaction between the AI characters to let them decide who should attack first and when the others can attack too.</p>
<p>We can choose from numerous factors that the characters will have in consideration to make this decision, and the more we plan, more developed and challenging the AI character become:</p>
<div><img class=" image-border" src="img/402773a6-d468-4987-9fa4-bea1699958cd.png"/></div>
<p>For this example, we used the distance between the AI characters and the player to determine which one will attack first. We want the closest character to attack first and all the others will wait until that one has low HP. Once that character has low HP, the second closest character will intervene in the fight and attack the player.</p>
<p>Now that we have our first criteria set on our characters to decide which one should be the first to attack, we can move on to determine what happens to the other characters while they are waiting. We also need to take into consideration that the player can decide to attack any other character at any time, and we don't want the AI character to stay on idle position just because it's not his time to attack. So the idea is to think about different situations that can happen and plan how the AI would behave in those situations, in particular, especially how they will interact with each other:</p>
<pre> public static int attackOrder;<br/> public bool nearPlayer;<br/> public float distancePlayer;<br/> public static int charactersAttacking;<br/> private bool Attack;<br/> private bool Defend;<br/> private bool runAway;<br/> private bool surpriseAttack;<br/><br/> void Update () <br/> {<br/><br/>     if(distancePlayer &lt; 30f)<br/>     {<br/>          nearPlayer = true;<br/>     } 
 
     if(distancePlayer &gt; 30f) 
     { 
         nearPlayer = false; 
      }<br/><br/>      if(nearPlayer == true &amp;&amp; attackOrder == 1)<br/>      {<br/>          Attack = true;<br/>      }<br/><br/>      else <br/>      {<br/>         Defend = true;<br/>      } 
 
 }  </pre>
<p>We can start with a simple code just to determine the behavior of the character according to the situation that we are working with, and then we can keep adding more content as necessary to make it work as we want to. For this example, we have created a static integer called <kbd>attackOrder</kbd> that will contain the attack order of each character, so they know if it's their time to attack or not. After that, we have a public Boolean called <kbd>nearPlayer</kbd>, which will check whether the player is close the player character or not. We can have 30 characters on the map but we just want the closest ones to attack the characters. For this example, the others will simply ignore the player. To determine whether the AI character is near or not, we have a public float called <kbd>distancePlayer</kbd>, which will be the result of the distance between the AI character and the player. Then we have added a public static <kbd>int</kbd> called <kbd>charactersAttacking</kbd>, where the number will increase each time a new character arrives near the player. We can use this to give information to the other characters about how many skeletons are currently attacking the player.</p>
<p>A small and simple code such as this one can make a huge difference for the crowd interaction that we are working on, because we can use the information about how many characters are attacking the player to decide what they will do. For example, we can determine that if there's only two characters attacking, one will constantly defend the player's attacks while the other attacks, and when the player switches from one character to another, they will do the same thing and swap their roles, making it harder for the player to defeat the enemies:</p>
<div><img class=" image-border" src="img/1261c301-06be-4e0c-9059-7881464163ed.png"/></div>
<p>This can be seen in the preceding screenshot, where one of the skeletons tells the other that it will be defending and that the other one can attack the player from behind. This is exactly what crowd interaction is, one character giving information to another about what it can do or how it should behave. The more information the characters share with the others, the more options they have of what they can do, and the more realistic their interactions will look because they are not acting alone.</p>
<p>As we can see, even with simple codes we can achieve complex results, but it's necessary to think about it and plan everything ahead, and obviously the code will get bigger every time we add more details and options to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication (attention zones)</h1>
                
            
            
                
<p>Continuing with the same example, where we have a few skeletons on the map that will start attacking the player if the player gets near them, we can add one more feature that will make them interact even more one with another. Another thing that will make the characters behave like a group instead of single characters placed on the game is the communication. For example, here we have the skeletons that will only attack if the player is near, but what happens if one of the skeletons that is near the player yells that he saw the player character? We can assume that all the AI characters around that area will hear the yell and will start running in that direction in order to help their friend.</p>
<p>Once again, we can use simple lines of code in order to achieve this, but if we don't plan the interactions and how the characters should behave has a group, this type of element will be missing from the AI characters and they will behave independently, which will make it not so smart.</p>
<div><img height="322" width="573" class=" image-border" src="img/ddf1011a-737e-41e4-81ff-9da3af333044.png"/></div>
<p>As we can see, this is the system that we have right now. The AI characters don't communicate with each other and so the only skeletons that are aware of the player's position are the ones that are close enough to the player. If we are trying to create a crowd system, we need to plan situations like this one. Just because the other ones don't see the player character, doesn't necessarily mean that they have to react like nothing is happening.</p>
<p>Let's think about a real-life situation. For example, we have one person inside a house and another one outside. The person that is outside of the house sees an incredible beautiful bird while the person that is inside doesn't see it, so it will remain inside of the house. If the person that saw the bird doesn't communicate with the other one, the person that is inside the house will never know about it. So, normally what would happen is the person that sees the bird will call the other one to come outside so it can see the beautiful bird as well. This is a realistic behavior that can be implemented in our crowd interaction system.</p>
<p>To change this non-interaction situation to a more realistic version, we need to add one more feature to our characters that will make them communicate with each other. At this point, we just need simple communication, and we could use a similar code to what we have used to determine if the character can see the player or not:</p>
<div><img height="292" width="519" class=" image-border" src="img/1d7f0886-1d48-4e06-a4c3-38c0ab660c71.png"/></div>
<p>So now we have a AI character that has entered on the player trigger area, and for that reason he will yell so the others AI characters that are near are aware of the player's position as well. In the preceding diagram, we can see that now not only the player has a trigger area, but the enemy that has spotted the player has one as well. This new trigger area will serve to alert the other characters, and it's meant to represent a yell. So when we play the game, and the enemy spots us, we will hear a yell that will give a sense of communication between the AI characters:</p>
<pre> public static int attackOrder;<br/> public bool nearPlayer;<br/> public bool nearEnemyAttacked;<br/> public float distancePlayer;<br/> public static int charactersAttacking;<br/> private bool Attack;<br/> private bool Defend;<br/> private bool runAway;<br/> private bool surpriseAttack;<br/><br/> void Update () <br/>{<br/><br/>    if(distancePlayer &lt; 30f)<br/>    {<br/>          nearPlayer = true;<br/>    }<br/><br/>    if(distancePlayer &gt; 30f)<br/>    {<br/>           nearPlayer = false;<br/>    }<br/><br/>            if(nearPlayer == true &amp;&amp; attackOrder == 1)<br/>                 {<br/>                     Attack = true;<br/>                 }<br/><br/>             else <br/>                 {<br/>                     Defend = true;<br/>                 }<br/><br/>         if(nearEnemyAttacked == true)<br/>         {<br/>             runPlayerDirection();<br/>         }<br/>     }</pre>
<p>To make this happen, we simply added new Boolean called <kbd>nearEnemyAttacked</kbd>. In conjunction with this, we add a trigger detection to check if there are some skeletons near that have spotted the player. If it's triggered, the Boolean turns true; otherwise, it will remain false.</p>
<p>Once it gets triggered, it's time for that same AI character to call for any other ones that are around:</p>
<div><img class=" image-border" src="img/c6916b02-6981-4e05-971b-b09d393e5732.png"/></div>
<p>As we can see in the preceding diagram, due to the communication system we have implemented, we now have three characters that are fully aware of the player's position. The last character will also yell, trying to tell others about the player's position, but if the trigger area doesn't overlap an AI character, nothing will happen:</p>
<div><img class=" image-border" src="img/66e30258-f099-46f9-8db1-adbc18b111f5.png"/></div>
<p>For example, ENEMY 4 is far too away to be affected by the trigger zone, so it will remain in that position until the player gets near his location; otherwise, he won't know what is happening.</p>
<p>The trick of this example is to have characters talking to each other, yelling or trying to get the attention of characters that are near. This will give a sense of communication turning simple and individual actions into a more appealing group interaction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication (talking to other AI characters)</h1>
                
            
            
                
<p>There are many other examples that can be shown in terms of communication, because it's always possible to find new ways to communicate between characters; just like in real life, we are constantly finding new ways of communicating. But for now, we will stick to the basic form of communication, talking.</p>
<p>If we plan to have a lot of AI characters in the game, it will rapidly take a big part of the game, where the focus of the player will be set directly or indirectly to them. Probably not every game that we will be creating will have characters that react instantly to the presence of the player, and maybe the player could be just one more character in the game, and for that reason could be ignored. So in this section, will be excluding the player part and we will exclusively plan the AI character interactions:</p>
<div><img class=" image-border" src="img/638efc24-46aa-4970-8a79-dea07294d710.png"/></div>
<p>Let's create a city with a lot of people and assign a few details to them so they can behave like a realistic crowd. We can start by adding basic movement information into our character, such as walking, running, idle, and pathfinding. With that implemented in our character, we have an individual character that can walk around the city that avoids colliding with the buildings and walks on the sidewalk.</p>
<p>Now our first suggestion for this example is to add a simple trigger detection so the characters are aware when another characters passes nearby:</p>
<div><img class=" image-border" src="img/6fe41764-6a25-493b-b103-a7f30abe984a.png"/></div>
<p>After adding the trigger area to the characters, we can advance to the next step and work on the interaction between them. Our plan here is to have a probability map to determine a probability to find a known person that can start a conversation with:</p>
<pre>If(probabilityFriendly &gt; 13) 
{  
  // We have 87% of chance
  talkWith(); 
}   </pre>
<p>To make this work, we added an integer function that for this example we called it <kbd>probabilityFriendly</kbd>. This refers to the probability of finding a friendly person. When a new character enters the trigger area, the calculation will be made randomly, and if the number fits our percentage, both characters will stop walking around and will start a conversation. After that, we can keep adding more details to this situation, such as when they end the conversation, we could make them walk side by side while talking, and endless other options that could derive from this small trigger detection and probability map.</p>
<p>The idea behind this is to have characters that can interact with each other randomly. From the player's point of view, it would look like the characters are friends and they simply have stopped to talk because they know each other. This helps create a realistic atmosphere, and it's not so much about a technical point but instead about planning every possible interaction between characters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Team sports</h1>
                
            
            
                
<p>As we saw previously while explaining some popular examples of crowd interaction systems in video games, sports games have a well-developed AI system that works specifically well in team sports. Now we will take an in-depth look at some of the core features of team sports video games and see how they have achieved some interesting results, making the AI characters of those games very challenging and realistic.</p>
<p>If we analyze the real-life sport football, we have two teams each composed of eleven individual players. In order to win the game, the team needs to score more goals than the opponent, so the game can be divided into two basic forms: attacking, where the focus is scoring goals; and defending, where the focus is avoiding conceding goals. There is just one ball in the game, so a lot of the players' time is spent without having the possession of the ball, and that time can be very important to the end result of the game. Either the player tries to take the ball from the opponent or get in a good position to receive the ball. That's the two basic forms when the player doesn't have the possession of the ball.</p>
<p>The video game tries to mimic every detail of the sport, and because it is a team sport, there is a lot of work on the development of the AI group interaction. The mindset of the AI characters needs to be more on team play and less on simple individual play. So they only make certain decisions, if those decisions follow the group objectives.</p>
<p>If we watch a football match, we can hear the players talking to each other to pass them the ball, to move forward, to go backwards, and so on. The idea is to have that type of communication inside of the video game as well. It does not necessarily need to be about verbal communication, but the rather about actions that makes the game much more realistic.</p>
<p>Let's analyze step-by-step the basic AI decisions that the characters make while playing the game. We will start by taking a look the organization of the characters on the field, as shown in the following diagram:</p>
<div><img height="246" width="177" class=" image-border" src="img/5bbd7b0f-5dae-4fa1-a25e-21f40e36d377.png"/></div>
<p>This is one example of a simple formation of a football team on the field. At the bottom, we can see just one circle, and that represents the goalkeeper, the one that is responsible for defending the goal. This character is the only one that remains constantly around this area; all the others can move freely if they want to. Now that we have a visual representation of how a football team is distributed on the field, we can move on with the example.</p>
<p>Each character in the game has an individual objective. This may be passing the ball to the offensive players, shooting as much as possible to try to score goals, simply staying behind to defend, and so on. While they have these individual objectives, they also need to think about the team objectives and decide if one objective or another is more important at a certain point, and if the decision that they are making will help to achieve the objective successfully.</p>
<p>Let's move on to the creation of an individual player. We start from the basics, running after the ball. To create this, we can use techniques that were explained earlier in the book, such as walking towards an object's position:</p>
<pre>  public float speed;<br/>  public Transform ball;<br/>  public bool hasBall;<br/><br/>  void Start ()<br/> {<br/>     speed = 1f;<br/>  }<br/><br/>  void Update ()<br/> {<br/><br/>     if(hasBall == false)<br/>     {<br/>        Vector3 positionA = this.transform.position;<br/>        Vector3 positionB = ball.transform.position;<br/>        this.transform.position = Vector3.Lerp(positionA, positionB, <br/>          Time.deltaTime * speed);<br/>     }<br/><br/>     if(hasBall == true)<br/>     {<br/><br/>     }<br/> } </pre>
<p>Here we have the code that makes the character running after the ball. At this moment, we will be working on just one character and then we'll gradually add team interactions in order to have at least a basic form of what we can see on a fully developed sports game. So if we play the game with only this code, we can see that the character will move towards the ball's position, and that is the basics of the football game, to reach the ball:</p>
<div><img height="304" width="219" class=" image-border" src="img/7be935a8-c620-4d76-931d-a160eb5dcf6b.png"/></div>
<p>At the moment, we have an individual player working properly, and that is want we expected for now. If we added more characters into the game, all of them would run towards the ball, ignoring everything else, so no communication or interaction would be happening in the game:</p>
<div><img height="294" width="212" class=" image-border" src="img/66a8a47f-3f5c-4f02-83bb-b6b9d3c37fcf.png"/></div>
<p>If we had all the characters in the game running towards the ball's position, as we can see in the preceding diagram, it will be like the characters don't have a perception of the others around them. So to avoid this situation, we can get the character that is closest to the ball to communicate that to the other characters, so they don't need to run for the ball as well. To create that, we can have a constant calculation between the distance of each character and the ball:</p>
<pre> public float speed;<br/> public Transform ball;<br/> public bool hasBall;<br/> public float ballDistance;<br/><br/> void Start () <br/> {<br/>     speed = 1f;<br/> }<br/><br/>  void Update () <br/>{<br/><br/>      if(hasBall == false)<br/>      {<br/>          Vector3 positionA = this.transform.position;<br/>          Vector3 positionB = ball.transform.position;<br/>          this.transform.position = Vector3.Lerp(positionA, <br/>             positionB, Time.deltaTime * speed);<br/>      }<br/><br/>      if(hasBall == true)<br/>      {<br/><br/>      }<br/><br/>      ballDistance =Vector3.Distance(transform.position,ball.position); <br/><br/>} </pre>
<p>To achieve this, we have used the distance calculation that we have explored previously on the book. So now we have three new variables on the code, <kbd>ballDistance</kbd> that is a float that will be the measurement of how far the character is from the ball.</p>
<p>Now that we have this set we need to have the character verifying if he is the closest of them all from the ball and if so, he can then move on and run towards the ball position:</p>
<pre>  public float speed;<br/>  public Transform ball;<br/>  public bool hasBall;<br/>  public float ballDistance;<br/>  public static float teamDistance;<br/><br/>  void Start () <br/>  {<br/>     speed = 1f;<br/>  }<br/><br/>  void Update () <br/> {<br/><br/>     if(hasBall == false)<br/>     {<br/>         Vector3 positionA = this.transform.position;<br/>         Vector3 positionB = ball.transform.position;<br/>         this.transform.position = Vector3.Lerp(positionA, positionB, <br/>            Time.deltaTime * speed);<br/>     }<br/><br/>     if(hasBall == true)<br/>     {<br/><br/>     }<br/><br/>     ballDistance =Vector3.Distance(transform.position,ball.position); <br/><br/>     if(teamDistance &lt; ballDistance)<br/>     {<br/>          teamDistance = ballDistance;<br/>     }<br/><br/> } </pre>
<p>For this example, we decided to simply add a variable that will be shared for all the characters, so we added a static float variable called <kbd>teamDistance</kbd>. This will store the value of the character that is closest to the ball. At this point, the characters will know if they are the ones that are closest to the ball. From this point, it is simple to move to the next step and have the character check if it is the closest one, and if so, it can run towards the ball. This will be the first team element that we'll be adding to our AI characters. They will check with the others to see which one should get the ball, and as we planned, it makes more sense to be the one that is closest to the ball, but we can break it down further so they can check which one will get to the ball first. However, for this example we'll stick with the principle that all of the characters run at the same velocity:</p>
<pre>   public float speed;<br/>   public Transform ball;<br/>   public bool hasBall;<br/>   public float ballDistance;<br/>   public static float teamDistance;<br/>   public bool nearTheBall;<br/><br/>   public float teamdist;<br/><br/>   void Start () <br/>   {<br/>        speed = 0.1f;<br/>        teamDistance = 10;<br/>   }<br/><br/>   void Update () <br/>  {<br/>      teamdist = teamDistance;<br/><br/>      if(hasBall == false &amp;&amp; nearTheBall == true)<br/>      {<br/>          Vector3 positionA = this.transform.position;<br/>          Vector3 positionB = ball.transform.position;<br/>          this.transform.position = Vector3.Lerp(positionA, positionB, <br/>             Time.deltaTime * speed);<br/>      }<br/><br/>      if(hasBall == true)<br/>      {<br/><br/>      }<br/><br/>      ballDistance =Vector3.Distance(transform.position,ball.position);<br/><br/>      if(teamDistance &gt; ballDistance)<br/>      {<br/>          teamDistance = ballDistance;<br/>      }<br/><br/>      if(teamDistance == ballDistance)<br/>      {<br/>          nearTheBall = true;<br/>      }<br/><br/>      if(teamDistance &lt; ballDistance)<br/>      {<br/>         nearTheBall = false;    <br/>      }<br/><br/> } </pre>
<div><img height="281" width="202" class=" image-border" src="img/d0b5bff4-c9f4-4e83-b5d2-1af953176255.png"/></div>
<p>st the , we can see that only one character is running after the ball. All the other characters have the perception that one of their team is closer to the ball, so that one will get the ball. At this moment, we already have a simple form of group interaction and we are on the right track.</p>
<p>The next thing that we need to work on is that the ball will be moving throughout the game, and our code works in a static scenario, but if the ball gets moved, the team distance check should be reset. The reason is that the value will be getting lower when the character AI gets closer to the ball, and that value never increases, so we need to update it. We start by creating a new script for the ball:</p>
<pre>  public Vector2 curPos;<br/>  public Vector2 lastPos;<br/><br/>  public bool ballMoving;<br/><br/>  void Update () <br/> {<br/><br/>     curPos = transform.position;<br/><br/>     if(curPos == lastPos)<br/>     {<br/>          ballMoving = false;<br/>     }<br/><br/>     else<br/>     {<br/>          ballMoving = true;<br/>          characterAI.teamDistance = 10;<br/>     }<br/><br/>     lastPos = curPos;<br/> } </pre>
<p>After adding this script to the ball, the distance check of the players will get updated every time the ball get's moved. Now let's make sure that the ball moves. To make this happen, we need to allow the character to kick the ball.</p>
<p>First, we will update the ball script that we just created. We want to add a variable that will store the position where the ball will land after the character shooting it:</p>
<pre>   public Vector2 curPos;<br/>   public Vector2 lastPos;<br/>   public static Transform characterPos;<br/>   public float speed;<br/><br/>   public bool ballMoving;<br/><br/>   void Start () <br/>   {<br/><br/>      characterPos = this.transform;<br/>      speed = 2f;<br/>   }<br/><br/>   void Update () <br/>   {<br/><br/>       curPos = transform.position;<br/><br/>       if(curPos == lastPos)<br/>       {<br/>           ballMoving = false;<br/>       }<br/><br/>       else<br/>       {<br/>           ballMoving = true;<br/>           characterAI.teamDistance = 10;<br/>       }<br/><br/>       lastPos = curPos;<br/><br/>       Vector2 positionA = this.transform.position;<br/>       Vector2 positionB = characterPos.transform.position;<br/>       this.transform.position = Vector2.Lerp(positionA, positionB, <br/>          Time.deltaTime * speed);<br/> } </pre>
<p>So, what we have done here is give information about the landing position of the ball. To make this happen, we added a <kbd>public static Transform</kbd> variable called <kbd>characterPos</kbd>. We have chosen to have character positions here for the test, because we want the characters to pass the ball and not simply kick it:</p>
<pre> public float speed;<br/> public Transform ball;<br/> public bool hasBall;<br/> public float ballDistance;<br/> public static float teamDistance;<br/> public bool nearTheBall;<br/> public List&lt;Transform&gt; teamCharacters;<br/> public int randomChoice;<br/> public float teamdist;  </pre>
<p>Then we updated the variables of the character AI script. Here, we have a list that will contain all the players' coordinates of the team. The idea is to have the character choosing a friendly teammate to pass the ball and shoot it in that direction.</p>
<p>So for this example, we have chosen to use the coordinates of the characters as a waypoint for the ball. To make this feature more realistic, we can add more details about the trajectory of the ball being affected by gravity or wind:</p>
<pre>void Update () <br/>{<br/>     teamdist = teamDistance;<br/><br/>     if(hasBall == false &amp;&amp; nearTheBall == true)<br/>     {<br/>         Vector3 positionA = this.transform.position;<br/>         Vector3 positionB = ball.transform.position;<br/>         this.transform.position = Vector3.Lerp(positionA, positionB, <br/>            Time.deltaTime * speed);<br/>     }<br/><br/>     if(ballDistance &lt; 0.1)<br/>     {<br/>         hasBall = true;<br/>     }<br/><br/>     if(hasBall == true)<br/>     {<br/>          passBall();<br/>          hasBall = false;<br/>     }<br/><br/>     ballDistance =Vector3.Distance(transform.position,ball.position);<br/><br/>     if(teamDistance &gt; ballDistance)<br/>     {<br/>         teamDistance = ballDistance;<br/>     }<br/><br/>     if(teamDistance == ballDistance)<br/>     {<br/>         nearTheBall = true;<br/>     }<br/><br/>     if(teamDistance &lt; ballDistance)<br/>     {<br/>          nearTheBall = false;    <br/>     }<br/><br/>}<br/><br/>void passBall ()<br/>{<br/>      randomChoice = Random.Range(0, 9);<br/>      ballScript.characterPos = teamCharacters[randomChoice];<br/>} </pre>
<p>Then we use the variables that we just added to our code to send the new direction to the ball when the character AI gets close enough to the ball. <kbd>void passBall ()</kbd> is the function that we created that will be called every time the character wants to pass the ball. At this moment, we just want the characters to pass the ball to each other, so we have assigned a random number to select a character from the list.</p>
<div><img height="350" width="252" class=" image-border" src="img/37eb57dc-f559-4080-8d72-59c3cdb0585d.png"/></div>
<p>If we test the game, we can see that there is a lot more movement and interaction going on. So what we can see is that the closest character will get near the ball and when that happens, he will pass the ball to another character. The ball will move towards the character and the character will get closer to the ball so he can pass the ball to another character. Currently, this will happen forever in a loop, a character gets the ball, passes, another one gets the ball and passes, and so on.</p>
<p>Now we have the foundation of a simple football game, and we can simply keep adding more features like the ones we just created to make them communicate to see who's going to get the ball and pass the ball to the teammates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Crowd collision avoidance</h1>
                
            
            
                
<p>To finalize this chapter, we'll be talking about crowd collision avoidance. The idea of having a lot of characters in the same map is becoming a standard for open world games. But this often brings a problem, collision avoidance:</p>
<div><img class=" image-border" src="img/dd12ac37-9842-4739-9b53-df26f789e93c.png"/></div>
<p>We have already discovered how advanced pathfinding works, and we know that is a powerful system when developing AI movement. But if we have a lot of characters trying to reach the same position at the same time, it will cause them to collide with each other and they will probably block the path that is needed to reach that destination. As we can see in the preceding screenshot, everything is running smoothly and without any abnormal situation because the characters are following different directions and rarely do they interfere with the others.</p>
<p>But what happens if all the characters try to access the same position at the same time, for example trying to get inside the house. It is only possible for one character at a time to go through the door, and that means that plenty of other characters will wait in line to enter.</p>
<p>The solution for this problem is still being explored, and there is not a definite answer, but there are some ways to get around this.</p>
<div><img class="image-border" src="img/b5570415-5b5b-446e-9734-dc993b55797a.jpg"/></div>
<p>Currently crowd dynamics solutions usually involve two different layers, one for the pathfinding and another one for the local collision avoidance. Using this approach, we have a few benefits, it will produce a high quality movement and also it will have avoidance on a small scale, it is a very common method used on multiple games.</p>
<p>There are different alternatives to achieve this with a satisfactory result. A popular choice for many games is the combination of the Theta Algorithm A* with the velocity obstacle. This allow us to calculate the distance between our character and the other one that will collide against us.</p>
<p>In high-density crowd situations, solely relying on local collision avoidance and idealized pathfinding will cause agents to pile up at popular, shared path waypoints. Collision avoidance algorithms only help to avoid local collisions in the pursuit of following the ideal path. Often, games rely on these algorithms to divert agents to less-congested, less-direct routes in high-density situations. In certain situations, collision avoidance can lead to this desired behavior, though it is always a side effect of the system and not a deliberate consideration.</p>
<p>Work has been done in incorporating aggregate crowd movement and crowd density into pathfinding computations. Approaches that augment pathing via crowd density do not take into account the aggregate movement or direction of movement of the crowd, which leads to overcorrection of the phenomenon, which can be seen in the following image:</p>
<div><img height="257" width="457" class=" image-border" src="img/9a88bcad-a166-4171-8bc9-def9c3d9faa5.png"/></div>
<p>Congestion maps are similar in many ways to existing cooperative pathfinding algorithms, such as Direction Maps (DMs), but they differ in a few key respects. DMs use average crowd motion over time to encourage agents to move with the crowd. Because of this, many of the oscillations present in the congestion map approach are smoothly resolved. Conversely, this temporal smoothing prevents DMs from quickly and accurately reacting to changes in the environment and crowd behavior. Both congestion maps and DMs apply the aggregate crowd movement information to the path planning process in much the same way; however, congestion maps handle agents of varying size and shape, while DMs traditionally assume homogeneity.</p>
<p>The final major difference between DMs and congestion maps is that congestion maps weight movement penalties proportional to the density of the crowd. Without taking density into account, DMs display overly pessimistic pathfinding behavior, where agents are encouraged to path around sparse groups of agents blocking the ideal path.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we explored some popular examples of crowd interaction systems used on popular video games and we saw how important is to plan every interaction that we can think of because this is what will turn a few simple lines of code into a realistic-looking game. To conclude the chapter, we revisited the advanced pathfinding system and we saw how multiple characters in the game can share the same final destination, taking an alternative path to avoid colliding, and waiting in line for other characters to move forward.</p>
<p>In the next chapter, we'll be looking at AI planning and decision making. We'll see how we can have AI anticipating things, knowing in advance what it will do when arriving at a certain position or facing a certain problem.</p>


            

            
        
    </body></html>