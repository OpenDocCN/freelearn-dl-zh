<html><head></head><body>
<div aria-label="223" epub:type="pagebreak" id="page1-8" role="doc-pagebreak"/>
<div id="_idContainer090">
<h1 class="chapterNumber"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 class="chapterTitle" id="_idParaDest-145"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.2.1">Advanced Applications and Multi-Agent Systems</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In the previous chapter, we defined what an agent is. </span><span class="koboSpan" id="kobo.3.2">But how do we design and build a high-performing agent? </span><span class="koboSpan" id="kobo.3.3">Unlike the prompt engineering techniques we’ve previously explored, developing effective agents involves several distinct design patterns every developer should be familiar with. </span><span class="koboSpan" id="kobo.3.4">In this chapter, we’re going to discuss key architectural patterns behind agentic AI. </span><span class="koboSpan" id="kobo.3.5">We’ll look into multi-agentic architectures and the ways to organize communication between agents. </span><span class="koboSpan" id="kobo.3.6">We will develop an advanced agent with self-reflection that uses tools to answer complex exam questions. </span><span class="koboSpan" id="kobo.3.7">We will learn about additional LangChain and LangGraph APIs that are useful when implementing agentic architectures, such as details about LangGraph streaming and ways to implement handoff as part of advanced control flows.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">Then, we’ll briefly touch on the LangGraph platform and discuss how to develop adaptive systems, by including humans in the loop, and what kind of prebuilt building blocks LangGraph offers for this. </span><span class="koboSpan" id="kobo.4.2">We will also look</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.5.1"> into the </span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">Tree-of-Thoughts</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.8.1">ToT</span></strong><span class="koboSpan" id="kobo.9.1">) pattern and develop a ToT agent ourselves, discussing further ways to improve it by implementing advanced trimming mechanisms. </span><span class="koboSpan" id="kobo.9.2">Finally, we’ll learn about advanced long-term memory mechanisms on LangChain and LangGraph, such as caches and stores.</span></p>
<div aria-label="224" epub:type="pagebreak" id="page2-8" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.10.1">In all, we’ll touch on the following topics in this chapter:</span></p>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.11.1">Agentic architectures</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.12.1">Multi-agent architectures</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.13.1">Building adaptive systems</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.14.1">Exploring reasoning paths</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.15.1">Agent memory</span><a id="_idTextAnchor276"/></li>
</ul>
<h1 class="heading-1" id="_idParaDest-146"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.16.1">Agentic architectures</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.17.1">As we learned in </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.19.1">, agents </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.20.1">help humans solve tasks. </span><span class="koboSpan" id="kobo.20.2">Building an agent involves balancing two elements. </span><span class="koboSpan" id="kobo.20.3">On one side, it’s very similar to application development in the sense that you’re combining APIs (including calling foundational models) with production-ready quality. </span><span class="koboSpan" id="kobo.20.4">On the other side, you’re helping LLMs think and solve a task.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.21.1">As we discussed in </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.22.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.23.1">, agents don’t have a specific algorithm to follow. </span><span class="koboSpan" id="kobo.23.2">We give an LLM partial control over the execution flow, but to guide it, we use various tricks that help us as humans to reason, solve tasks, and think clearly. </span><span class="koboSpan" id="kobo.23.3">We should not assume that an LLM can magically figure everything out itself; at the current stage, we should guide it by creating reasoning workflows. </span><span class="koboSpan" id="kobo.23.4">Let’s recall the ReACT agent we learned about in </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.25.1">, an example of a tool-calling pattern:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.26.1"><img alt="Figure 6.1: A prebuilt REACT workflow on LangGraph" src="../Images/B32363_06_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.27.1">Figure 6.1: A prebuilt REACT workflow on LangGraph</span></p>
<div aria-label="225" epub:type="pagebreak" id="page3-8" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Let’s look at a few relatively simple design patterns that help with building well-performing agents. </span><span class="koboSpan" id="kobo.28.2">You will see these patterns in various combinations across different domains and agentic architectures:</span></p>
<div aria-label="226" epub:type="pagebreak" id="page4-8" role="doc-pagebreak"/>
<ul>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.29.1">Tool calling</span></strong><span class="koboSpan" id="kobo.30.1">: LLMs are </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.31.1">trained to do controlled generation via tool calling. </span><span class="koboSpan" id="kobo.31.2">Hence, wrap your problem as a tool-calling problem when appropriate instead of creating complex prompts. </span><span class="koboSpan" id="kobo.31.3">Keep in mind that tools should have clear descriptions and property names, and experimenting with them is part of the prompt engineering exercise. </span><span class="koboSpan" id="kobo.31.4">We discussed this pattern in </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.32.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.33.1">. </span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.34.1">Task decomposition</span></strong><span class="koboSpan" id="kobo.35.1">: Keep your prompts relatively simple. </span><span class="koboSpan" id="kobo.35.2">Provide specific instructions with few-shot examples and split complex tasks into smaller steps. </span><span class="koboSpan" id="kobo.35.3">You can give an LLM partial control over the task decomposition and planning process, managing the flow by an external orchestrator. </span><span class="koboSpan" id="kobo.35.4">We used this pattern in </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.37.1"> when we built a plan-and-solve agent.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.38.1">Cooperation and diversity</span></strong><span class="koboSpan" id="kobo.39.1">: Final outputs on complex tasks can be improved if you introduce cooperation between multiple instances of LLM-enabled agents. </span><span class="koboSpan" id="kobo.39.2">Communicating, debating, and sharing different perspectives helps, and you can also benefit from various skill sets by initiating your agents with different system prompts, available toolsets, etc. </span><span class="koboSpan" id="kobo.39.3">Natural language is a native way for such agents to communicate since LLMs were trained on natural language tasks.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.40.1">Reflection and adaptation</span></strong><span class="koboSpan" id="kobo.41.1">: Adding implicit loops of reflection generally improves the quality of end-to-end reasoning on complex tasks. </span><span class="koboSpan" id="kobo.41.2">LLMs get feedback from the external environment by calling the tools (and these calls might fail or produce unexpected results), but at the same time, LLMs can continue iterating and self-recover from their mistakes. </span><span class="koboSpan" id="kobo.41.3">As an exaggeration, remember that we often use the same LLM-as-a-judge, so adding a loop when we ask an LLM to evaluate its own reasoning and find errors often helps it to recover. </span><span class="koboSpan" id="kobo.41.4">We will learn how to build adaptive systems later in this chapter.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.42.1">Models are nondeterministic and can generate multiple candidates</span></strong><span class="koboSpan" id="kobo.43.1">: Do not focus on a single output; explore different reasoning paths by expanding the dimension of potential options to try out when an LLM interacts with the external environment when looking for the solution. </span><span class="koboSpan" id="kobo.43.2">We will investigate this pattern in more detail in the section below when we discuss ToT</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.44.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">Language Agent Tree Search</span></strong><span class="koboSpan" id="kobo.46.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.47.1">LATS</span></strong><span class="koboSpan" id="kobo.48.1">) examples.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.49.1">Code-centric problem framing</span></strong><span class="koboSpan" id="kobo.50.1">: Writing code is very natural for an LLM, so try to frame the problem as a code-writing problem if possible. </span><span class="koboSpan" id="kobo.50.2">This might become a very powerful way of solving the task, especially if you wrap it with a code-executing sandbox, a loop for</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.51.1"> improvement based on the output, access to various powerful libraries for data analysis or visualization, and a generation step afterward. </span><span class="koboSpan" id="kobo.51.2">We will go into more detail in </span><a href="E_Chapter_7.xhtml#_idTextAnchor327"><em class="italic"><span class="koboSpan" id="kobo.52.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.53.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.54.1">Two important comments: first, develop your agents aligned with the best software development practices, and make them agile, modular, and easily configurable. </span><span class="koboSpan" id="kobo.54.2">That would allow you to put multiple specialized agents together, and give users the opportunity to easily tune each agent based on their specific task.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.55.1">Second, we want to emphasize (once again!) the importance of evaluation and experimentation. </span><span class="koboSpan" id="kobo.55.2">We will talk about evaluation in more detail in </span><a href="E_Chapter_9.xhtml#_idTextAnchor448"><em class="italic"><span class="koboSpan" id="kobo.56.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">But it’s important to keep in mind that there is no clear path to success. </span><span class="koboSpan" id="kobo.57.3">Different patterns work better on different types of tasks. </span><span class="koboSpan" id="kobo.57.4">Try things, experiment, iterate, and don’t forget to evaluate the results of your work. </span><span class="koboSpan" id="kobo.57.5">Data, such as tasks and expected outputs, and simulators, a safe way for LLMs to interact with tools, are key to building really</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.58.1"> complex and effective agents.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.59.1">Now that we have created a mental map of various design patterns, we’ll look deeper into these principles by discussing various agentic architectures and looking at examples. </span><span class="koboSpan" id="kobo.59.2">We will start by enhancing the RAG architecture we discussed in </span><a href="E_Chapter_4.xhtml#_idTextAnchor152"><em class="italic"><span class="koboSpan" id="kobo.60.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.61.1"> with an agentic appro</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.62.1">ach.</span></p>
<h2 class="heading-2" id="_idParaDest-147"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.63.1">Agentic RAG</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.64.1">LLMs enable the </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.65.1">development of intelligent agents capable of tackling complex, non-repetitive tasks that defy description as deterministic workflows. </span><span class="koboSpan" id="kobo.65.2">By splitting reasoning into steps in different ways and orchestrating them in a relatively simple way, agents can demonstrate a significantly higher task completion rate on complex open tasks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.66.1">This agent-based approach can be applied across numerous domains, including RAG systems, which we discussed in </span><a href="E_Chapter_4.xhtml#_idTextAnchor152"><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">As a reminder, what exactly is </span><em class="italic"><span class="koboSpan" id="kobo.69.1">agentic RAG</span></em><span class="koboSpan" id="kobo.70.1">? </span><span class="koboSpan" id="kobo.70.2">Remember, a classic pattern for a RAG system is to retrieve chunks given the query, combine them into the context, and ask an LLM to generate an answer given a system prompt, combined context, and the question.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">We can improve each of these steps using the principles discussed above (decomposition, tool calling, and adaptation):</span></p>
<div aria-label="227" epub:type="pagebreak" id="page5-8" role="doc-pagebreak"/>
<ul>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.72.1">Dynamic retrieval</span></strong><span class="koboSpan" id="kobo.73.1"> hands over the retrieval query generation to the LLM. </span><span class="koboSpan" id="kobo.73.2">It can decide itself whether to use sparse embeddings, hybrid methods, keyword search, or web search. </span><span class="koboSpan" id="kobo.73.3">You can wrap retrievals as tools and orchestrate them as a LangGraph graph.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.74.1">Query expansion</span></strong><span class="koboSpan" id="kobo.75.1"> tasks an LLM to generate multiple queries based on initial ones, and then you combine search outputs based on reciprocal fusion or another technique.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.76.1">Decomposition of reasoning on retrieved chunks</span></strong><span class="koboSpan" id="kobo.77.1"> allows you to ask an LLM to evaluate each individual chunk given the question (and filter it out if it’s irrelevant) to compensate for retrieval inaccuracies. </span><span class="koboSpan" id="kobo.77.2">Or you can ask an LLM to summarize each chunk by keeping only information given for the input question. </span><span class="koboSpan" id="kobo.77.3">Anyway, instead of throwing a huge piece of context in front of an LLM, you perform many smaller reasoning steps in parallel first.This can not only improve the RAG quality by itself but also increase the amount of initially retrieved chunks (by decreasing the relevance threshold) or expand each individual chunk with its neighbors. </span><span class="koboSpan" id="kobo.77.4">In other words, you can overcome some retrieval challenges with LLM reasoning. </span><span class="koboSpan" id="kobo.77.5">It might increase the overall performance of your application, but of course, it comes with latency and potential cost implications.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.78.1">Reflection steps and iterations</span></strong><span class="koboSpan" id="kobo.79.1"> task LLMs to dynamically iterate on retrieval and query expansion by evaluating the outputs after each iteration. </span><span class="koboSpan" id="kobo.79.2">You can also use additional grounding and attribution tools as a separate step in your workflow and, based on that, reason whether you need to continue working on the answer or the answer can be returned to the user.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Based on our definition from the previous chapters, RAG becomes agentic RAG when you have shared partial control with the LLM over the execution flow. </span><span class="koboSpan" id="kobo.80.2">For example, if the LLM decides how to retrieve, reflects on retrieved chunks, and adapts based on the first version of the answer, it becomes agentic RAG. </span><span class="koboSpan" id="kobo.80.3">From our perspective, at this point, it starts making sense to migrate to LangGraph since it’s designed specifically for building such applications, but of course, you can stay with LangChain or any other framework you prefer (compare how we implemented map-reduce video</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.81.1"> summarization with LangChain and LangGraph separately in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.82.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.83.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-148"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.84.1">Multi-agent architectures</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.85.1">In </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.86.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.87.1">, we learned</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.88.1"> that decomposing a complex task into simpler subtasks typically increases LLM performance. </span><span class="koboSpan" id="kobo.88.2">We built a plan-and-solve agent that goes a step further than CoT and encourages the LLM to generate a plan and follow it. </span><span class="koboSpan" id="kobo.88.3">To a certain extent, this architecture was a multi-agent one since the research agent (which was responsible for generating and following the plan) invoked another agent that focused on a different type of task – solving very specific tasks with provided tools. </span><span class="koboSpan" id="kobo.88.4">Multi-agentic workflows orchestrate multiple agents, allowing them to enhance each other and at the same time keep agents modular (which makes it easier to test and reuse them).</span></p>
<div aria-label="228" epub:type="pagebreak" id="page6-8" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.89.1">We will look into a few core agentic architectures in the remainder of this chapter, and introduce some important LangGraph interfaces (such as streaming details and handoffs) that are useful to develop agents. </span><span class="koboSpan" id="kobo.89.2">If you’re interested, you can find more examples and tutorials on the LangChain documentation page at </span><a href="https://langchain-ai.github.io/langgraph/tutorials/#agent-architectures"><span class="url"><span class="koboSpan" id="kobo.90.1">https://langchain-ai.github.io/langgraph/tutorials/#agent-architectures</span></span></a><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">We’ll begin with discussing the importance of specialization in multi-agentic systems, including what the consensus mechanism is and the different consensus mech</span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.92.1">anisms.</span></p>
<h2 class="heading-2" id="_idParaDest-149"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.93.1">Agent roles and specialization</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.94.1">When working on a</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.95.1"> complex task, we as humans know that usually, it’s beneficial to have a team with diverse skills and backgrounds. </span><span class="koboSpan" id="kobo.95.2">There is much evidence from research and experiments that suggests this is also true for generative AI agents. </span><span class="koboSpan" id="kobo.95.3">In fact, developing specialized agents offers several advantages for complex AI systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.96.1">First, specialization improves performance on specific tasks. </span><span class="koboSpan" id="kobo.96.2">This allows you to:</span></p>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.97.1">Select the optimal set of tools for each task type.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.98.1">Craft tailored prompts and workflows.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.99.1">Fine-tune hyperparameters such as temperature for specific contexts.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.100.1">Second, specialized agents help manage complexity. </span><span class="koboSpan" id="kobo.100.2">Current LLMs struggle when handling too many tools at once. </span><span class="koboSpan" id="kobo.100.3">As a best practice, limit each agent to 5-15 different tools, rather than overloading a single agent with all available tools. </span><span class="koboSpan" id="kobo.100.4">How to group tools is still an open question; typically, grouping them into toolkits to create coherent specialized agents helps.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.101.1"><img alt="Figure 6.2: A supervisor pattern" src="../Images/B32363_06_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.102.1">Figure 6.2: A supervisor pattern</span></p>
<div aria-label="229" epub:type="pagebreak" id="page7-7" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.103.1">Besides becoming </span><em class="italic"><span class="koboSpan" id="kobo.104.1">specialized</span></em><span class="koboSpan" id="kobo.105.1">, keep your agents </span><em class="italic"><span class="koboSpan" id="kobo.106.1">modular</span></em><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">It becomes easier to maintain and improve such agents. </span><span class="koboSpan" id="kobo.107.3">Also, by working on enterprise assistant use cases, you will eventually end up with many different agents available for users and developers within your organization that can be composed</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.108.1"> together. </span><span class="koboSpan" id="kobo.108.2">Hence, keep in mind that you should make such specialized agents configurable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.109.1">LangGraph allows you to easily compose graphs by including them as a subgraph in a larger graph. </span><span class="koboSpan" id="kobo.109.2">There are two ways of doing this:</span></p>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.110.1">Compile an agent as a graph and pass it as a callable when defining a node of another agent:</span><p class="snippet-code-one"><span class="koboSpan" id="kobo.111.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.112.1">"pay"</span></span><span class="koboSpan" id="kobo.113.1">, payments_agent)</span></p></li>
<li class="b lletList"><span class="koboSpan" id="kobo.114.1">Wrap the child agent’s invocation with a Python function and use it within the definition of the parent’s node:</span><p class="snippet-code-one"><span class="hljs-keyword"><span class="koboSpan" id="kobo.115.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.116.1">_run_payment</span></span><span class="koboSpan" id="kobo.117.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.118.1">state</span></span><span class="koboSpan" id="kobo.119.1">):</span></p><p class="snippet-code-one"><span class="koboSpan" id="kobo.120.1">  result = payments_agent.invoke({</span><span class="hljs-string"><span class="koboSpan" id="kobo.121.1">"client_id"</span></span><span class="koboSpan" id="kobo.122.1">; state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.123.1">"client_id"</span></span><span class="koboSpan" id="kobo.124.1">]})</span></p><p class="snippet-code-one"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.125.1">return</span></span><span class="koboSpan" id="kobo.126.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.127.1">"payment status"</span></span><span class="koboSpan" id="kobo.128.1">: ...}</span></p><p class="snippet-code-one"><span class="koboSpan" id="kobo.129.1">...</span></p><p class="snippet-code-one"><span class="koboSpan" id="kobo.130.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.131.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.132.1">pay"</span></span><span class="koboSpan" id="kobo.133.1">, _run_payment)</span></p></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.134.1">Note, that your agents might have different schemas (since they perform different tasks). </span><span class="koboSpan" id="kobo.134.2">In the first case, the parent agent would pass the same keys in schemas with the child agent when invoking it. </span><span class="koboSpan" id="kobo.134.3">In turn, when the child agent finishes, it would update the parent’s state and send back the values corresponding to matching keys in both schemas. </span><span class="koboSpan" id="kobo.134.4">At the same time, the second option gives you full control over how you construct a state that is passed to the child agent, and how the state of the </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.135.1">parent agent should be updated as a result. </span><span class="koboSpan" id="kobo.135.2">For more information, take a look at the documentation at </span><a href="https://langchain-ai.github.io/langgraph/how-tos/subgraph/"><span class="url"><span class="koboSpan" id="kobo.136.1">https://langchain-ai.github.io/langgraph/how-tos/subgraph/</span></span></a><span class="koboSpan" id="kobo.137.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-150"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.138.1">Consensus mechanism</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.139.1">We can let multiple </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.140.1">agents work on the same tasks in</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.141.1"> parallel as well. </span><span class="koboSpan" id="kobo.141.2">These agents might have a different “personality” (introduced by their system prompts; for example, some of them might be more curious and explorative, and others might be more strict and heavily grounded) or even varying architectures. </span><span class="koboSpan" id="kobo.141.3">Each of them independently works on getting a solution for the problem, and then you use a consensus mechanism to choose the best solution from a few drafts.</span></p>
<div aria-label="230" epub:type="pagebreak" id="page8-7" role="doc-pagebreak"/>
<figure class="mediaobject"><span class="koboSpan" id="kobo.142.1"><img alt="Figure 6.3: A parallel execution of the task with a final consensus step" src="../Images/B32363_06_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.143.1">Figure 6.3: A parallel execution of the task with a final consensus step</span></p>
<p class="normal"><span class="koboSpan" id="kobo.144.1">We saw an example of implementing a consensus mechanism based on majority voting in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.145.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">You can wrap it as a separate LangGraph node, and there are alternative ways of coming to a consensus across multiple agents:</span></p>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.147.1">Let each agent see other solutions and score each of them on a scale of 0 to 1, and then take the solution with the maximum score.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.148.1">Use an alternative voting mechanism.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.149.1">Use majority voting. </span><span class="koboSpan" id="kobo.149.2">It typically works for classification or similar tasks, but it might be difficult to implement majority voting if you have a free-text output. </span><span class="koboSpan" id="kobo.149.3">This is the fastest and the cheapest (in terms of token consumption) mechanism since you don’t need to run any additional prompts.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.150.1">Use an external oracle if it exists. </span><span class="koboSpan" id="kobo.150.2">For instance, when solving a mathematical equation, you can easily verify if the solution is feasible. </span><span class="koboSpan" id="kobo.150.3">Computational costs depend on the problem but typically are low.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.151.1">Use another (maybe more powerful) LLM as a judge to pick the best solution. </span><span class="koboSpan" id="kobo.151.2">You can ask an LLM to come up with a score for each solution, or you can task it with a multi-class classification problem by presenting all of them and asking it to pick the best one.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.152.1">Develop another agent that excels at the task of selecting the best solution for a general task from a set of solutions.</span></li>
</ul>
<div aria-label="231" epub:type="pagebreak" id="page9-6" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.153.1">It’s worth mentioning that a consensus mechanism has certain latency and cost implications, but typically they’re negligible relative to the costs of solving a task itself. </span><span class="koboSpan" id="kobo.153.2">If you task N agents with the same task, your token consumption increases N times, and the consensus mechanism adds a relatively small overhead on top of that difference.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.154.1">You can also implement your own consensus mechanism. </span><span class="koboSpan" id="kobo.154.2">When you do this, consider the following:</span></p>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.155.1">Use few-shot prompting when using an LLM as a judge.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.156.1">Add examples demonstrating how to score different input-output pairs.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.157.1">Consider including scoring rubrics for different types of responses.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.158.1">Test the mechanism on diverse outputs to ensure consistency.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.159.1">One important</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.160.1"> note on parallelization – when you let LangGraph</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.161.1"> execute nodes in parallel, updates are applied to the main state in the same order as you’ve added nodes to</span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.162.1"> your graph.</span></p>
<h2 class="heading-2" id="_idParaDest-151"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.163.1">Communication protocols</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.164.1">The third architecture</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.165.1"> option is to let agents</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.166.1"> communicate and work collaboratively on a task. </span><span class="koboSpan" id="kobo.166.2">For example, the agents might benefit from various personalities configured through system prompts. </span><span class="koboSpan" id="kobo.166.3">Decomposition of a complex task into smaller subtasks also helps you retain control over your application and how your agents c</span><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.167.1">ommunicate.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.168.1"><img alt="Figure 6.4: Reflection pattern" src="../Images/B32363_06_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.169.1">Figure 6.4: Reflection pattern</span></p>
<div aria-label="232" epub:type="pagebreak" id="page10-6" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.170.1">Agents can work collaboratively on a task by providing critique and reflection. </span><span class="koboSpan" id="kobo.170.2">There are multiple reflection patterns starting from self-reflection, when the agent analyzes its own steps and identifies areas for improvements (but as mentioned above, you might initiate the reflecting agent with a slightly different system prompt); cross-reflection, when you use another agent (for example, using another foundational model); or even reflection, which includes </span><strong class="keyWord"><span class="koboSpan" id="kobo.171.1">Human-in-the-Loop</span></strong><span class="koboSpan" id="kobo.172.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.173.1">HIL</span></strong><span class="koboSpan" id="kobo.174.1">) on</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.175.1"> critical checkpoints (we’ll see in the next section how to build adaptive systems of this kind).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.176.1">You can keep one agent </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.177.1">as a supervisor, allow agents to communicate </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.178.1">in a network (allowing them to decide which agent to send a message or a task), introduce a certain hierarchy, or develop more complex flows (for inspiration, take a look at some diagrams on the LangGraph documentation page at </span><a href="https://langchain-ai.github.io/langgraph/concepts/multi_agent/"><span class="url"><span class="koboSpan" id="kobo.179.1">https://langchain-ai.github.io/langgraph/concepts/multi_agent/</span></span></a><span class="koboSpan" id="kobo.180.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.181.1">Designing multi-agent workflows is still an open area of research and experimentation, and you need to answer a lot of questions:</span></p>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.182.1">What and how many agents should we include in our system?</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.183.1">What roles should we assign to these agents?</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.184.1">What tools should each agent have access to?</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.185.1">How should agents interact with each other and through which mechanism?</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.186.1">What specific parts of the workflow should we automate?</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.187.1">How do we evaluate our automation and how can we collect data for this evaluation? </span><span class="koboSpan" id="kobo.187.2">Additionally, what are our success criteria?</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.188.1">Now that we’ve examined some core considerations and open questions around multi-agent communication, let’s explore two practical mechanisms to structure and facilitate agent interactions: </span><em class="italic"><span class="koboSpan" id="kobo.189.1">semantic routing</span></em><span class="koboSpan" id="kobo.190.1">, which directs tasks intelligently based on their content, and </span><em class="italic"><span class="koboSpan" id="kobo.191.1">organizing interaction</span></em><span class="koboSpan" id="kobo.192.1">, detailing the </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.193.1">specific formats and structures that agents can use to effectively exch</span><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.194.1">ange information.</span></p>
<h3 class="heading-3" id="_idParaDest-152"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.195.1">Semantic router</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.196.1">Among many different ways to organize communication between agents in a true multi-agent setup, an important one is a semantic router. </span><span class="koboSpan" id="kobo.196.2">Imagine developing an enterprise assistant. </span><span class="koboSpan" id="kobo.196.3">Typically it becomes more and more complex because it starts dealing with various types of questions – general questions (requiring public data and general knowledge), questions about the company (requiring access to the proprietary company-wide data sources), and questions specific to the user (requiring access to the data provided by the user itself). </span><span class="koboSpan" id="kobo.196.4">Maintaining such an application as a</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.197.1"> single agent becomes very difficult very soon. </span><span class="koboSpan" id="kobo.197.2">Again, we can apply our design patterns – decomposition and collaboration!</span></p>
<div aria-label="233" epub:type="pagebreak" id="page11-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.198.1">Imagine we have implemented three types of agents – one answering general questions grounded on public data, another one grounded on a company-wide dataset and knowing about company specifics, and the third one specialized on working with a small source of user-provided documents. </span><span class="koboSpan" id="kobo.198.2">Such specialization helps us to use patterns such as few-shot prompting and controlled generation. </span><span class="koboSpan" id="kobo.198.3">Now we can add a semantic router – the first layer that asks an LLM to classify the question and routes it to the corresponding agent based on classification results. </span><span class="koboSpan" id="kobo.198.4">Each agent (or some of them) might even use a self-consistency approach, as we learned in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.199.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.200.1">, to increase the LLM classification accuracy.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.201.1"><img alt="Figure 6.5: Semantic router pattern" src="../Images/B32363_06_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.202.1">Figure 6.5: Semantic router pattern</span></p>
<p class="normal"><span class="koboSpan" id="kobo.203.1">It’s worth mentioning that a task might fall into two or more categories – for example, I can ask, “</span><em class="italic"><span class="koboSpan" id="kobo.204.1">What is X and how can I do Y? </span></em><span class="koboSpan" id="kobo.205.1">“ This might not be such a common use case in an assistant setting, and you can decide what to do in that case. </span><span class="koboSpan" id="kobo.205.2">First of all, you might just educate the user by replying with an explanation that they should task your application with a single problem per turn. </span><span class="koboSpan" id="kobo.205.3">Sometimes developers tend to be too focused on trying to solve everything programmatically. </span><span class="koboSpan" id="kobo.205.4">But some product features are relatively easy to solve via the UI, and users (especially in the enterprise setup) are ready to provide their input. </span><span class="koboSpan" id="kobo.205.5">Maybe, instead of solving a classification problem on the prompt, just add a simple checkbox in the UI, or let the system double-check if the level of confidence is low.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.206.1">You can also use tool calling or other controlled generation techniques we’ve learned about to extract both goals and route the execution to two specialized agents with different tasks.</span></p>
<div aria-label="234" epub:type="pagebreak" id="page12-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.207.1">Another important aspect of semantic routing is that the performance of your application depends a lot on </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.208.1">classification accuracy. </span><span class="koboSpan" id="kobo.208.2">You can use all the techniques we have discussed in the book to improve it – few-shot prompting (including dynamic one), incorporating user feedback, sam</span><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.209.1">pling, and others.</span></p>
<h3 class="heading-3" id="_idParaDest-153"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.210.1">Organizing interactions</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.211.1">There are two ways to organize communication in multi-agent systems:</span></p>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.212.1">Agents communicate via specific structures that force them to put their thoughts and reasoning traces in a specific form, as we saw in the </span><em class="italic"><span class="koboSpan" id="kobo.213.1">plan-and-solve</span></em><span class="koboSpan" id="kobo.214.1"> example in the previous chapter. </span><span class="koboSpan" id="kobo.214.2">We saw how our planning node communicated with the ReACT agent via a Pydantic model with a well-structured plan (which, in turn, was a result of an LLM’s controlled generation).</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.215.1">On the other hand, LLMs were trained to take natural language as input and produce an output in the same format. </span><span class="koboSpan" id="kobo.215.2">Hence, it’s a very natural way for them to communicate via messages, and you can implement a communication mechanism by applying messages from different agents to the shared list of messages!.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.216.1">When communicating with messages, you can share all messages via a so-called </span><em class="italic"><span class="koboSpan" id="kobo.217.1">scratchpad</span></em><span class="koboSpan" id="kobo.218.1"> – a shared list of messages. </span><span class="koboSpan" id="kobo.218.2">In that case, your context can grow relatively quickly and you might need to use some of the mechanisms to trim the chat memory (like preparing running summaries) that we discussed in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.219.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">But as general advice, if you need to filter or prioritize messages in the history of communication between multiple agents, go with the first approach and let them communicate through a controlled output. </span><span class="koboSpan" id="kobo.220.3">It would give you more control of the state of your workflow at any given point in time. </span><span class="koboSpan" id="kobo.220.4">Also, you might end up with a situation where you have a complicated sequence of messages, for example, </span><em class="italic"><span class="koboSpan" id="kobo.221.1">[SystemMessage, HumanMessage, AIMessage, ToolMessage, AIMessage, AIMessage, SystemMessage, …]</span></em><span class="koboSpan" id="kobo.222.1">. </span><span class="koboSpan" id="kobo.222.2">Depending on the foundational model you’re using, double-check that the model’s provider supports such sequences, since previously, many providers supported only relatively simple sequences – SystemMessages followed by alternating HumanMessage and AIMessage (maybe with a ToolMessage instead of a human one if a tool invocation was decided).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.223.1">Another alternative is to share only the final results of each execution. </span><span class="koboSpan" id="kobo.223.2">This keeps the list of messages relatively short.</span></p>
<div aria-label="235" epub:type="pagebreak" id="page13-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.224.1">Now it’s time to</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.225.1"> look at a practical example. </span><span class="koboSpan" id="kobo.225.2">Let’s develop a research agent that uses tools to answer complex multiple-choice questions based on the public MMLU dataset (we’ll use high school geography questions). </span><span class="koboSpan" id="kobo.225.3">First, we need to grab a dataset from Hugging Face:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.226.1">from</span></span><span class="koboSpan" id="kobo.227.1"> datasets </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.228.1">import</span></span><span class="koboSpan" id="kobo.229.1"> load_dataset</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.230.1">ds = load_dataset(</span><span class="hljs-string"><span class="koboSpan" id="kobo.231.1">"cais/mmlu"</span></span><span class="koboSpan" id="kobo.232.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.233.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.234.1">high_school_geography"</span></span><span class="koboSpan" id="kobo.235.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.236.1">ds_dict = ds[</span><span class="hljs-string"><span class="koboSpan" id="kobo.237.1">"test"</span></span><span class="koboSpan" id="kobo.238.1">].take(</span><span class="hljs-number"><span class="koboSpan" id="kobo.239.1">2</span></span><span class="koboSpan" id="kobo.240.1">).to_dict()</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.241.1">print</span></span><span class="koboSpan" id="kobo.242.1">(ds_dict[</span><span class="hljs-string"><span class="koboSpan" id="kobo.243.1">"question"</span></span><span class="koboSpan" id="kobo.244.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.245.1">0</span></span><span class="koboSpan" id="kobo.246.1">])</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.247.1">&gt;&gt; The main factor preventing subsistence economies from advancing economically is the lack of</span></p>
<p class="normal"><span class="koboSpan" id="kobo.248.1">These are our answer options:</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.249.1">print</span></span><span class="koboSpan" id="kobo.250.1">(ds_dict[</span><span class="hljs-string"><span class="koboSpan" id="kobo.251.1">"choices"</span></span><span class="koboSpan" id="kobo.252.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.253.1">0</span></span><span class="koboSpan" id="kobo.254.1">])</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.255.1">&gt;&gt; ['a currency.', 'a well-connected transportation infrastructure.', 'government activity.', 'a banking service.']</span></p>
<p class="normal"><span class="koboSpan" id="kobo.256.1">Let’s start with a ReACT agent, but let’s deviate from a default system prompt and write our own prompt. </span><span class="koboSpan" id="kobo.256.2">Let’s focus this agent on being creative and working on an evidence-based solution (please note that we used elements of CoT prompting, which we discussed in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.257.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.258.1">):</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.259.1">from</span></span><span class="koboSpan" id="kobo.260.1"> langchain.agents </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">import</span></span><span class="koboSpan" id="kobo.262.1"> load_tools</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.263.1">from</span></span><span class="koboSpan" id="kobo.264.1"> langgraph.prebuilt </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.265.1">import</span></span><span class="koboSpan" id="kobo.266.1"> create_react_agent</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.267.1">research_tools = load_tools(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.268.1">  tool_names=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.269.1">"ddg-search"</span></span><span class="koboSpan" id="kobo.270.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.271.1">"arxiv"</span></span><span class="koboSpan" id="kobo.272.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.273.1">"wikipedia"</span></span><span class="koboSpan" id="kobo.274.1">],</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.275.1">  llm=llm)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.276.1">system_prompt = (</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.277.1">"You're a hard-working, curious and creative student. </span><span class="koboSpan" id="kobo.277.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.278.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.279.1">You're preparing an answer to an exam quesion. </span><span class="koboSpan" id="kobo.279.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.280.1">"Work hard, think step by step."</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.281.1">"Always provide an argumentation for your answer. </span><span class="koboSpan" id="kobo.281.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.282.1">"Do not assume anything, use available tools to search "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.283.1">"for evidence and supporting statements."</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.284.1">)</span></p>
<div aria-label="236" epub:type="pagebreak" id="page14-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.285.1">Now, let’s create the agent itself. </span><span class="koboSpan" id="kobo.285.2">Since we have a custom prompt for the agent, we need a prompt template that includes a system message, a template that formats the first user message based on a question and answers provided, and a placeholder for further messages to be added to the graph’s state. </span><span class="koboSpan" id="kobo.285.3">We</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.286.1"> also redefine the default agent’s state by inheriting from </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">AgentState</span></code><span class="koboSpan" id="kobo.288.1"> and adding additional keys to it:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.289.1">from</span></span><span class="koboSpan" id="kobo.290.1"> langchain_core.prompts </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.291.1">import</span></span><span class="koboSpan" id="kobo.292.1"> ChatPromptTemplate, PromptTemplate</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.293.1">from</span></span><span class="koboSpan" id="kobo.294.1"> langgraph.graph </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.295.1">import</span></span><span class="koboSpan" id="kobo.296.1"> MessagesState</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.297.1">from</span></span><span class="koboSpan" id="kobo.298.1"> langgraph.prebuilt.chat_agent_executor </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.299.1">import</span></span><span class="koboSpan" id="kobo.300.1"> AgentState</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.301.1">raw_prompt_template = (</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.302.1">"Answer the following multiple-choice question. </span><span class="koboSpan" id="kobo.302.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.303.1">"\nQUESTION:\n{question}\n\nANSWER OPTIONS:\n{option}\n"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.304.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.305.1">prompt = ChatPromptTemplate.from_messages(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.306.1">   [(</span><span class="hljs-string"><span class="koboSpan" id="kobo.307.1">"system"</span></span><span class="koboSpan" id="kobo.308.1">, system_prompt),</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.309.1">    (</span><span class="hljs-string"><span class="koboSpan" id="kobo.310.1">"user"</span></span><span class="koboSpan" id="kobo.311.1">, raw_prompt_template),</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.312.1">    (</span><span class="hljs-string"><span class="koboSpan" id="kobo.313.1">"placeholder"</span></span><span class="koboSpan" id="kobo.314.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.315.1">"{messages}"</span></span><span class="koboSpan" id="kobo.316.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.317.1">    ]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.318.1">)</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.319.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.320.1">MyAgentState</span></span><span class="koboSpan" id="kobo.321.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.322.1">AgentState</span></span><span class="koboSpan" id="kobo.323.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.324.1"> question: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.325.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.326.1"> options: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.327.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.328.1">research_agent = create_react_agent(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.329.1">  model=llm_small, tools=research_tools, state_schema=MyAgentState,</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.330.1">  prompt=prompt)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.331.1">We could have stopped here, but let’s go further. </span><span class="koboSpan" id="kobo.331.2">We used a specialized research agent based on the ReACT pattern (and we slightly adjusted its default configuration). </span><span class="koboSpan" id="kobo.331.3">Now let’s add a reflection step to it, and use another role profile for an agent who will actionably criticize our “student’s” work:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.332.1">reflection_prompt = (</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.333.1">"You are a university professor and you're supervising a student who is "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.334.1">"working on multiple-choice exam question. </span><span class="koboSpan" id="kobo.334.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.335.1">"nQUESTION: {question}.\nANSWER OPTIONS:\n{options}\n."</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.336.1">"STUDENT'S ANSWER:\n{answer}\n"</span></span></p>
<div aria-label="237" epub:type="pagebreak" id="page15-5" role="doc-pagebreak"/>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.337.1">"Reflect on the answer and provide a feedback whether the answer "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.338.1">"is right or wrong. </span><span class="koboSpan" id="kobo.338.2">If you think the final answer is correct, reply with "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.339.1">"the final answer. </span><span class="koboSpan" id="kobo.339.2">Only provide critique if you think the answer might "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.340.1">"be incorrect or there are reasoning flaws. </span><span class="koboSpan" id="kobo.340.2">Do not assume anything, "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.341.1">"evaluate only the reasoning the student provided and whether there is "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.342.1">"enough evidence for their answer."</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.343.1">)</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.345.1">Response</span></span><span class="koboSpan" id="kobo.346.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.347.1">BaseModel</span></span><span class="koboSpan" id="kobo.348.1">):</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.349.1">"""A final response to the user."""</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.350.1">   answer: </span><span class="hljs-type"><span class="koboSpan" id="kobo.351.1">Optional</span></span><span class="koboSpan" id="kobo.352.1">[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.353.1">str</span></span><span class="koboSpan" id="kobo.354.1">] = Field(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.355.1">       description=</span><span class="hljs-string"><span class="koboSpan" id="kobo.356.1">"The final answer. </span><span class="koboSpan" id="kobo.356.2">It should be empty if critique has been provided."</span></span><span class="koboSpan" id="kobo.357.1">,</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.358.1">       default=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.359.1">None</span></span><span class="koboSpan" id="kobo.360.1">,</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.361.1">   )</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.362.1">   critique: </span><span class="hljs-type"><span class="koboSpan" id="kobo.363.1">Optional</span></span><span class="koboSpan" id="kobo.364.1">[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.365.1">str</span></span><span class="koboSpan" id="kobo.366.1">] = Field(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.367.1">       description=</span><span class="hljs-string"><span class="koboSpan" id="kobo.368.1">"A critique of the initial answer. </span><span class="koboSpan" id="kobo.368.2">If you think it might be incorrect, provide an actionable feedback"</span></span><span class="koboSpan" id="kobo.369.1">,</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.370.1">       default=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.371.1">None</span></span><span class="koboSpan" id="kobo.372.1">,</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.373.1">   )</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.374.1">reflection_chain = PromptTemplate.from_template(reflection_prompt) | llm.with_structured_output(Response)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.375.1">Now we need</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.376.1"> another research agent that takes not only question and answer options but also the previous answer and the feedback. </span><span class="koboSpan" id="kobo.376.2">The research agent is tasked with using tools to improve the answer and address the critique. </span><span class="koboSpan" id="kobo.376.3">We created a simplistic and illustrative example. </span><span class="koboSpan" id="kobo.376.4">You can always improve it by adding error handling, Pydantic validation (for example, checking that either an answer or critique is provided), or handling conflicting or ambiguous feedback (for example, structure prompts that help the agent prioritize feedback points when there are multiple criticisms).</span></p>
<div aria-label="238" epub:type="pagebreak" id="page16-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.377.1">Note that we use a less capable LLM for our ReACT agents, just to demonstrate the power of the reflection approach (otherwise the graph might finish in a single iteration since the agent would figure out the correct answer with the first attempt):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.378.1">raw_prompt_template_with_critique = (</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.379.1">"You tried to answer the exam question and you get feedback from your "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.380.1">"professor. </span><span class="koboSpan" id="kobo.380.2">Work on improving your answer and incorporating the feedback. </span><span class="koboSpan" id="kobo.380.3">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.381.1">"\nQUESTION:\n{question}\n\nANSWER OPTIONS:\n{options}\n\n"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.382.1">"INITIAL ANSWER:\n{answer}\n\nFEEDBACK:\n{feedback}"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.383.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.384.1">prompt = ChatPromptTemplate.from_messages(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.385.1">   [(</span><span class="hljs-string"><span class="koboSpan" id="kobo.386.1">"system"</span></span><span class="koboSpan" id="kobo.387.1">, system_prompt),</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.388.1">    (</span><span class="hljs-string"><span class="koboSpan" id="kobo.389.1">"user"</span></span><span class="koboSpan" id="kobo.390.1">, raw_prompt_template_with_critique),</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.391.1">    (</span><span class="hljs-string"><span class="koboSpan" id="kobo.392.1">"placeholder"</span></span><span class="koboSpan" id="kobo.393.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.394.1">"{messages}"</span></span><span class="koboSpan" id="kobo.395.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.396.1">    ]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.397.1">)</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.398.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.399.1">ReflectionState</span></span><span class="koboSpan" id="kobo.400.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.401.1">ResearchState</span></span><span class="koboSpan" id="kobo.402.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.403.1"> answer: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.404.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.405.1"> feedback: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.406.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.407.1">research_agent_with_critique = create_react_agent(model=llm_small, tools=research_tools, state_schema=ReflectionState, prompt=prompt)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.408.1">When defining the</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.409.1"> state of our graph, we need to keep track of the question and answer options, the current answer, and the critique. </span><span class="koboSpan" id="kobo.409.2">Also note that we track the amount of interaction between a </span><em class="italic"><span class="koboSpan" id="kobo.410.1">student</span></em><span class="koboSpan" id="kobo.411.1"> and a </span><em class="italic"><span class="koboSpan" id="kobo.412.1">professor</span></em><span class="koboSpan" id="kobo.413.1"> (to avoid infinite cycles between them) and we use a custom reducer for that (which summarizes old steps and new steps on each run). </span><span class="koboSpan" id="kobo.413.2">Let’s define the full state, nodes, and conditional edges:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.414.1">from</span></span><span class="koboSpan" id="kobo.415.1"> typing </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.416.1">import</span></span><span class="koboSpan" id="kobo.417.1"> Annotated, </span><span class="hljs-type"><span class="koboSpan" id="kobo.418.1">Literal</span></span><span class="koboSpan" id="kobo.419.1">, TypedDict</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.420.1">from</span></span><span class="koboSpan" id="kobo.421.1"> langchain_core.runnables.config </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.422.1">import</span></span><span class="koboSpan" id="kobo.423.1"> RunnableConfig</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.424.1">from</span></span><span class="koboSpan" id="kobo.425.1"> operator </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.426.1">import</span></span><span class="koboSpan" id="kobo.427.1"> add</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.428.1">from</span></span><span class="koboSpan" id="kobo.429.1"> langchain_core.output_parsers </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.430.1">import</span></span><span class="koboSpan" id="kobo.431.1"> StrOutputParser</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.432.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.433.1">ReflectionAgentState</span></span><span class="koboSpan" id="kobo.434.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.435.1">TypedDict</span></span><span class="koboSpan" id="kobo.436.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.437.1">   question: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.438.1">str</span></span></p>
<div aria-label="239" epub:type="pagebreak" id="page17-5" role="doc-pagebreak"/>
<p class="snippet-code"><span class="koboSpan" id="kobo.439.1">   options: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.440.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.441.1">   answer: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.442.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.443.1">   steps: Annotated[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.444.1">int</span></span><span class="koboSpan" id="kobo.445.1">, add]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.446.1">   response: Response</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.448.1">_should_end</span></span><span class="koboSpan" id="kobo.449.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.450.1">state: AgentState, config: RunnableConfig</span></span><span class="koboSpan" id="kobo.451.1">) -&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.452.1">Literal</span></span><span class="koboSpan" id="kobo.453.1">[</span><span class="hljs-string"><span class="koboSpan" id="kobo.454.1">"research"</span></span><span class="koboSpan" id="kobo.455.1">, END]:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.456.1">   max_reasoning_steps = config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.457.1">"configurable"</span></span><span class="koboSpan" id="kobo.458.1">].get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.459.1">"max_reasoning_steps"</span></span><span class="koboSpan" id="kobo.460.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.461.1">10</span></span><span class="koboSpan" id="kobo.462.1">)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.463.1">if</span></span><span class="koboSpan" id="kobo.464.1"> state.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.465.1">"response"</span></span><span class="koboSpan" id="kobo.466.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.467.1">and</span></span><span class="koboSpan" id="kobo.468.1"> state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.469.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.470.1">response"</span></span><span class="koboSpan" id="kobo.471.1">].answer:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.472.1">return</span></span><span class="koboSpan" id="kobo.473.1"> END</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">if</span></span><span class="koboSpan" id="kobo.475.1"> state.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.476.1">"steps"</span></span><span class="koboSpan" id="kobo.477.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.478.1">1</span></span><span class="koboSpan" id="kobo.479.1">) &gt; max_reasoning_steps:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.480.1">return</span></span><span class="koboSpan" id="kobo.481.1"> END</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.483.1">"research"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.484.1">reflection_chain = PromptTemplate.from_template(reflection_prompt) | llm.with_structured_output(Response)</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.485.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.486.1">_reflection_step</span></span><span class="koboSpan" id="kobo.487.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.488.1">state</span></span><span class="koboSpan" id="kobo.489.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.490.1">   result = reflection_chain.invoke(state)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.491.1">return</span></span><span class="koboSpan" id="kobo.492.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.493.1">"response"</span></span><span class="koboSpan" id="kobo.494.1">: result, </span><span class="hljs-string"><span class="koboSpan" id="kobo.495.1">"steps"</span></span><span class="koboSpan" id="kobo.496.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.497.1">1</span></span><span class="koboSpan" id="kobo.498.1">}</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.499.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.500.1">_research_start</span></span><span class="koboSpan" id="kobo.501.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.502.1">state</span></span><span class="koboSpan" id="kobo.503.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.504.1"> answer = research_agent.invoke(state)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.505.1">return</span></span><span class="koboSpan" id="kobo.506.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.507.1">"answer"</span></span><span class="koboSpan" id="kobo.508.1">: answer[</span><span class="hljs-string"><span class="koboSpan" id="kobo.509.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.510.1">messages"</span></span><span class="koboSpan" id="kobo.511.1">][-</span><span class="hljs-number"><span class="koboSpan" id="kobo.512.1">1</span></span><span class="koboSpan" id="kobo.513.1">].content}</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.514.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.515.1">_research</span></span><span class="koboSpan" id="kobo.516.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.517.1">state</span></span><span class="koboSpan" id="kobo.518.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.519.1"> agent_state = {</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.520.1">"answer"</span></span><span class="koboSpan" id="kobo.521.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.522.1">"answer"</span></span><span class="koboSpan" id="kobo.523.1">],</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.524.1">"question"</span></span><span class="koboSpan" id="kobo.525.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.526.1">"question"</span></span><span class="koboSpan" id="kobo.527.1">],</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.528.1">"options"</span></span><span class="koboSpan" id="kobo.529.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.530.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.531.1">options"</span></span><span class="koboSpan" id="kobo.532.1">],</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.533.1">"feedback"</span></span><span class="koboSpan" id="kobo.534.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.535.1">"response"</span></span><span class="koboSpan" id="kobo.536.1">].critique</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.537.1"> }</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.538.1"> answer = research_agent_with_critique.invoke(agent_state)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">return</span></span><span class="koboSpan" id="kobo.540.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.541.1">"answer"</span></span><span class="koboSpan" id="kobo.542.1">: answer[</span><span class="hljs-string"><span class="koboSpan" id="kobo.543.1">"messages"</span></span><span class="koboSpan" id="kobo.544.1">][-</span><span class="hljs-number"><span class="koboSpan" id="kobo.545.1">1</span></span><span class="koboSpan" id="kobo.546.1">].content}</span></p>
<div aria-label="240" epub:type="pagebreak" id="page18-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.547.1">Let’s put it</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.548.1"> all together and create our graph:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.549.1">builder = StateGraph(ReflectionAgentState)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.550.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.551.1">"research_start"</span></span><span class="koboSpan" id="kobo.552.1">, _research_start)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.553.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.554.1">"research"</span></span><span class="koboSpan" id="kobo.555.1">, _research)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.556.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.557.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.558.1">reflect"</span></span><span class="koboSpan" id="kobo.559.1">, _reflection_step)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.560.1">builder.add_edge(START, </span><span class="hljs-string"><span class="koboSpan" id="kobo.561.1">"research_start"</span></span><span class="koboSpan" id="kobo.562.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.563.1">builder.add_edge(</span><span class="hljs-string"><span class="koboSpan" id="kobo.564.1">"research_start"</span></span><span class="koboSpan" id="kobo.565.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.566.1">"reflect"</span></span><span class="koboSpan" id="kobo.567.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.568.1">builder.add_edge(</span><span class="hljs-string"><span class="koboSpan" id="kobo.569.1">"research"</span></span><span class="koboSpan" id="kobo.570.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.571.1">"reflect"</span></span><span class="koboSpan" id="kobo.572.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.573.1">builder.add_conditional_edges(</span><span class="hljs-string"><span class="koboSpan" id="kobo.574.1">"reflect"</span></span><span class="koboSpan" id="kobo.575.1">, _should_end)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.576.1">graph = builder.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.577.1">compile</span></span><span class="koboSpan" id="kobo.578.1">()</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.579.1">display(Image(graph.get_graph().draw_mermaid_png()))</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.580.1"><img alt="Figure 6.6: A research agent with reflection" src="../Images/B32363_06_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.581.1">Figure 6.6: A research agent with reflection</span></p>
<p class="normal"><span class="koboSpan" id="kobo.582.1">Let’s run it </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.583.1">and inspect what’s happening:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.584.1">question = ds_dict[</span><span class="hljs-string"><span class="koboSpan" id="kobo.585.1">"question"</span></span><span class="koboSpan" id="kobo.586.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.587.1">0</span></span><span class="koboSpan" id="kobo.588.1">]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.589.1">options = </span><span class="hljs-string"><span class="koboSpan" id="kobo.590.1">"\n"</span></span><span class="koboSpan" id="kobo.591.1">.join(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.592.1">  [</span><span class="hljs-string"><span class="koboSpan" id="kobo.593.1">f"</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.594.1">{i}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.595.1">. </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.596.1">{a}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.597.1">"</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.598.1">for</span></span><span class="koboSpan" id="kobo.599.1"> i, a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.601.1">enumerate</span></span><span class="koboSpan" id="kobo.602.1">(ds_dict[</span><span class="hljs-string"><span class="koboSpan" id="kobo.603.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.604.1">choices"</span></span><span class="koboSpan" id="kobo.605.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.606.1">0</span></span><span class="koboSpan" id="kobo.607.1">])])</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">for</span></span><span class="koboSpan" id="kobo.610.1"> _, event </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.611.1">in</span></span><span class="koboSpan" id="kobo.612.1"> graph.astream({</span><span class="hljs-string"><span class="koboSpan" id="kobo.613.1">"question"</span></span><span class="koboSpan" id="kobo.614.1">: question, </span><span class="hljs-string"><span class="koboSpan" id="kobo.615.1">"options"</span></span><span class="koboSpan" id="kobo.616.1">: options}, stream_mode=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.617.1">"updates"</span></span><span class="koboSpan" id="kobo.618.1">]):</span></p>
<p class="snippet-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.619.1">print</span></span><span class="koboSpan" id="kobo.620.1">(event)</span></p>
<div aria-label="241" epub:type="pagebreak" id="page19-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.621.1">We have omitted the full output here (you’re welcome to take the code from our GitHub repository and experiment with it yourself), but the first answer was wrong:</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.622.1">Based on the DuckDuckGo search results, none of the provided statements are entirely true.  </span><span class="koboSpan" id="kobo.622.2">The searches reveal that while there has been significant progress in women's labor force participation globally,  it hasn't reached a point where most women work in agriculture, nor has there been a worldwide decline in participation.  </span><span class="koboSpan" id="kobo.622.3">Furthermore, the information about working hours suggests that it's not universally true that women work longer hours than men in most regions. </span><span class="koboSpan" id="kobo.622.4">Therefore, there is no correct answer among the options provided.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.623.1">After five iterations, the weaker LLM was able to figure out the correct answer (keep in mind that the “professor” only evaluated the reasoning itself and it didn’t use external tools or its own knowledge). </span><span class="koboSpan" id="kobo.623.2">Note that, technically speaking, we implemented cross-reflection and not self-reflection (since we’ve used a different LLM for reflection than the one we used for the reasoning). </span><span class="koboSpan" id="kobo.623.3">Here’s an example of the feedback provided during the first round:</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.624.1">The student's reasoning relies on outside search results which are not provided, making it difficult to assess the accuracy of their claims. </span><span class="koboSpan" id="kobo.624.2">The student states that none of the answers are entirely true, but multiple-choice questions often have one best answer even if it requires nuance. </span><span class="koboSpan" id="kobo.624.3">To properly evaluate the answer, the search results need to be provided, and each option should be evaluated against those results to identify the most accurate choice, rather than dismissing them all. </span><span class="koboSpan" id="kobo.624.4">It is possible one of the options is more correct than the others, even if not perfectly true. </span><span class="koboSpan" id="kobo.624.5">Without the search results, it's impossible to determine if the student's conclusion that no answer is correct is valid. </span><span class="koboSpan" id="kobo.624.6">Additionally, the student should explicitly state what the search results were.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.625.1">Next, let’s </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.626.1">discuss an alternative communication style for a multi-agent setup, via a shared list of messages. </span><span class="koboSpan" id="kobo.626.2">But before that, we should discuss the LangGraph handoff mechanism and dive into some details of s</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.627.1">treaming with LangGraph.</span></p>
<h2 class="heading-2" id="_idParaDest-154"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.628.1">LangGraph streaming</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.629.1">LangGraph streaming</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.630.1"> might sometimes be a source of </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.631.1">confusion. </span><span class="koboSpan" id="kobo.631.2">Each graph has not only a </span><code class="inlineCode"><span class="koboSpan" id="kobo.632.1">stream</span></code><span class="koboSpan" id="kobo.633.1"> and a corresponding asynchronous </span><code class="inlineCode"><span class="koboSpan" id="kobo.634.1">astream</span></code><span class="koboSpan" id="kobo.635.1"> method, but also an </span><code class="inlineCode"><span class="koboSpan" id="kobo.636.1">astream_events</span></code><span class="koboSpan" id="kobo.637.1">. </span><span class="koboSpan" id="kobo.637.2">Let’s dive into the difference.</span></p>
<div aria-label="242" epub:type="pagebreak" id="page20-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.638.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">Stream</span></code><span class="koboSpan" id="kobo.640.1"> method allows you to stream changes to the graph’s state after each super-step. </span><span class="koboSpan" id="kobo.640.2">Remember, we discussed what a super-step is in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.641.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.642.1">, but to keep it short, it’s a single iteration over the graph where parallel nodes belong to a single super-step while sequential nodes belong to different super-steps. </span><span class="koboSpan" id="kobo.642.2">If you need actual streaming behavior (like in a chatbot, so that users feel like something is happening and the model is actually thinking), you should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.643.1">astream</span></code><span class="koboSpan" id="kobo.644.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">messages</span></code><span class="koboSpan" id="kobo.646.1"> mode.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.647.1">You have five modes with </span><code class="inlineCode"><span class="koboSpan" id="kobo.648.1">stream/astream</span></code><span class="koboSpan" id="kobo.649.1"> methods (of course, you can combine multiple modes):</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-6">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.650.1">Mode</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.651.1">Description</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.652.1">Output</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.653.1">updates</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.654.1">Streams only updates to the graph produced by the node</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.655.1">A dictionary where each node name maps to its corresponding state update)</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.656.1">values</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.657.1">Streams the full state of the graph after each super-step</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.658.1">A dictionary with the entire graph’s state</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.659.1">debug</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.660.1">Attempts to stream as much information as possible in the debug mode</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.661.1">A dictionary with a timestamp, task_type, and all the corresponding information for every event</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.662.1">custom</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.663.1">Streams events emitted by the node using a StreamWriter</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.664.1">A dictionary that was written from the node to a custom writer </span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.665.1">messages</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.666.1">Streams full events (for example, ToolMessages) or its chunks in a streaming node if possible (e.g., AI Messages)</span></p>
</td>
<td class="No-Table-Style">
<p class="normal"><span class="koboSpan" id="kobo.667.1">A tuple with token or message segment and a dictionary containing metadata from the node</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.668.1">Table 6.1: Different streaming modes for LangGraph</span></p>
<p class="normal"><span class="koboSpan" id="kobo.669.1">Let’s look at an </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.670.1">example. </span><span class="koboSpan" id="kobo.670.2">If we take the ReACT agent we used in </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.671.1">the section above and stream with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">values</span></code><span class="koboSpan" id="kobo.673.1"> mode, we’ll get the full state returned after every super-step (you can see that the total number of messages is always increasing):</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.674.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.675.1">for</span></span><span class="koboSpan" id="kobo.676.1"> _, event </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.677.1">in</span></span><span class="koboSpan" id="kobo.678.1"> research_agent.astream({</span><span class="hljs-string"><span class="koboSpan" id="kobo.679.1">"question"</span></span><span class="koboSpan" id="kobo.680.1">: question, </span><span class="hljs-string"><span class="koboSpan" id="kobo.681.1">"options"</span></span><span class="koboSpan" id="kobo.682.1">: options}, stream_mode=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.683.1">"values"</span></span><span class="koboSpan" id="kobo.684.1">]):</span></p>
<p class="snippet-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.685.1">print</span></span><span class="koboSpan" id="kobo.686.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.687.1">len</span></span><span class="koboSpan" id="kobo.688.1">(event[</span><span class="hljs-string"><span class="koboSpan" id="kobo.689.1">"messages"</span></span><span class="koboSpan" id="kobo.690.1">]))</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.691.1">&gt;&gt; 0</span></p>
<p class="snippet-con"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.692.1">1</span></p>
<p class="snippet-con"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.693.1">3</span></p>
<p class="snippet-con"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.694.1">4</span></p>
<div aria-label="243" epub:type="pagebreak" id="page21-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.695.1">If we switch to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.696.1">update</span></code><span class="koboSpan" id="kobo.697.1"> mode, we’ll get a dictionary where the key is the node’s name (remember that parallel nodes can be called within a single super-step) and a corresponding update to the state sent by this node:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.698.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.699.1">for</span></span><span class="koboSpan" id="kobo.700.1"> _, event </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.701.1">in</span></span><span class="koboSpan" id="kobo.702.1"> research_agent.astream({</span><span class="hljs-string"><span class="koboSpan" id="kobo.703.1">"question"</span></span><span class="koboSpan" id="kobo.704.1">: question, </span><span class="hljs-string"><span class="koboSpan" id="kobo.705.1">"options"</span></span><span class="koboSpan" id="kobo.706.1">: options}, stream_mode=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.707.1">"updates"</span></span><span class="koboSpan" id="kobo.708.1">]):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.709.1"> node = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.710.1">list</span></span><span class="koboSpan" id="kobo.711.1">(event.keys())[</span><span class="hljs-number"><span class="koboSpan" id="kobo.712.1">0</span></span><span class="koboSpan" id="kobo.713.1">]</span></p>
<p class="snippet-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.714.1">print</span></span><span class="koboSpan" id="kobo.715.1">(node, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.716.1">len</span></span><span class="koboSpan" id="kobo.717.1">(event[node].get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.718.1">"messages"</span></span><span class="koboSpan" id="kobo.719.1">, [])))</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.720.1">&gt;&gt; agent 1</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.721.1">tools 2</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.722.1">agent 1</span></p>
<p class="normal"><span class="koboSpan" id="kobo.723.1">LangGraph </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">stream</span></code><span class="koboSpan" id="kobo.725.1"> always emits a tuple where the first value is a stream mode (since you can pass multiple modes by adding them to the list).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.726.1">Then you need an </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">astream_events </span></code><span class="koboSpan" id="kobo.728.1">method that streams back events happening within the nodes – not just tokens generated by the LLM but any event available for a callback:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.729.1">seen_events = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.730.1">set</span></span><span class="koboSpan" id="kobo.731.1">([])</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.732.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.733.1">for</span></span><span class="koboSpan" id="kobo.734.1"> event </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">in</span></span><span class="koboSpan" id="kobo.736.1"> research_agent.astream_events({</span><span class="hljs-string"><span class="koboSpan" id="kobo.737.1">"question"</span></span><span class="koboSpan" id="kobo.738.1">: question, </span><span class="hljs-string"><span class="koboSpan" id="kobo.739.1">"options"</span></span><span class="koboSpan" id="kobo.740.1">: options}, version=</span><span class="hljs-string"><span class="koboSpan" id="kobo.741.1">"v1"</span></span><span class="koboSpan" id="kobo.742.1">):</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.743.1">if</span></span><span class="koboSpan" id="kobo.744.1"> event[</span><span class="hljs-string"><span class="koboSpan" id="kobo.745.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.746.1">event"</span></span><span class="koboSpan" id="kobo.747.1">] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.748.1">not</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.749.1">in</span></span><span class="koboSpan" id="kobo.750.1"> seen_events:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.751.1">   seen_events.add(event[</span><span class="hljs-string"><span class="koboSpan" id="kobo.752.1">"event"</span></span><span class="koboSpan" id="kobo.753.1">])</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.754.1">print</span></span><span class="koboSpan" id="kobo.755.1">(seen_events)</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.756.1">&gt;&gt; {'on_chat_model_end', 'on_chat_model_stream', 'on_chain_end', 'on_prompt_end', 'on_tool_start', 'on_chain_stream', 'on_chain_start', 'on_prompt_start', 'on_chat_model_start', 'on_tool_end'}</span></p>
<p class="normal"><span class="koboSpan" id="kobo.757.1">You can</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.758.1"> find</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.759.1"> a full list of the events at </span><a href="https://python.langchain.com/docs/concepts/callbacks/#callback-even﻿ts"><span class="url"><span class="koboSpan" id="kobo.760.1">https://python.langchain.com/docs/concepts/callbacks/#callback-even</span><span id="_idTextAnchor296"/><span class="koboSpan" id="kobo.761.1">ts</span></span></a><span class="koboSpan" id="kobo.762.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-155"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.763.1">Handoffs</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.764.1">So far, we have</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.765.1"> learned that a node in LangGraph does a chunk of work and sends updates to a common state, and an edge controls the flow – it decides which node to invoke next (in a deterministic manner or based on the current state). </span><span class="koboSpan" id="kobo.765.2">When implementing multi-agent architectures, your nodes can be not only functions but other agents, or subgraphs (with their own state). </span><span class="koboSpan" id="kobo.765.3">You might need to combine state updates and flow controls.</span></p>
<div aria-label="244" epub:type="pagebreak" id="page22-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.766.1">LangGraph allows you to do that with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.767.1">Command</span></code><span class="koboSpan" id="kobo.768.1"> – you can update your graph’s state and at the same time invoke another agent by passing a custom state to it. </span><span class="koboSpan" id="kobo.768.2">This is called a </span><em class="italic"><span class="koboSpan" id="kobo.769.1">handoff</span></em><span class="koboSpan" id="kobo.770.1"> – since an agent hands off control to another one. </span><span class="koboSpan" id="kobo.770.2">You need to pass an </span><code class="inlineCode"><span class="koboSpan" id="kobo.771.1">update</span></code><span class="koboSpan" id="kobo.772.1"> – a dictionary with an update of the current state to be sent to your graph – and </span><code class="inlineCode"><span class="koboSpan" id="kobo.773.1">goto</span></code><span class="koboSpan" id="kobo.774.1"> – a name (or list of names) of the nodes to hand off control to:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.775.1">from</span></span><span class="koboSpan" id="kobo.776.1"> langgraph.types </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.777.1">import</span></span><span class="koboSpan" id="kobo.778.1"> Command</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.779.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.780.1">_make_payment</span></span><span class="koboSpan" id="kobo.781.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.782.1">state</span></span><span class="koboSpan" id="kobo.783.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.784.1">  ...</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.785.1">if</span></span><span class="koboSpan" id="kobo.786.1"> ...:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.787.1">return</span></span><span class="koboSpan" id="kobo.788.1"> Command(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.789.1">     update={</span><span class="hljs-string"><span class="koboSpan" id="kobo.790.1">"payment_id"</span></span><span class="koboSpan" id="kobo.791.1">: payment_id},</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.792.1">     goto=</span><span class="hljs-string"><span class="koboSpan" id="kobo.793.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.794.1">refresh_balance"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.795.1">  )</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.796.1">  ...</span></p>
<p class="normal"><span class="koboSpan" id="kobo.797.1">A destination agent can be a node from the current or a parent (</span><code class="inlineCode"><span class="koboSpan" id="kobo.798.1">Command.PARENT</span></code><span class="koboSpan" id="kobo.799.1">) graph. </span><span class="koboSpan" id="kobo.799.2">In other words, you can change the control flow only within the current graph, or you can pass it back to the workflow that initiated this one (for example, you can’t pass control to any random workflow by ID). </span><span class="koboSpan" id="kobo.799.3">You can also invoke a </span><code class="inlineCode"><span class="koboSpan" id="kobo.800.1">Command</span></code><span class="koboSpan" id="kobo.801.1"> from a tool, or wrap a </span><code class="inlineCode"><span class="koboSpan" id="kobo.802.1">Command </span></code><span class="koboSpan" id="kobo.803.1">as a tool, and then an LLM can decide to hand off control to a specific agent. </span><span class="koboSpan" id="kobo.803.2">In </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.804.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.805.1">, we discussed the map-reduce pattern and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.806.1">Send</span></code><span class="koboSpan" id="kobo.807.1"> class, which allowed us to invoke a node in the graph by passing a specific input state to it. </span><span class="koboSpan" id="kobo.807.2">We can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.808.1">Command</span></code><span class="koboSpan" id="kobo.809.1"> together with </span><code class="inlineCode"><span class="koboSpan" id="kobo.810.1">Send</span></code><span class="koboSpan" id="kobo.811.1"> (in this example, the destination agent</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.812.1"> belongs to the parent gr</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.813.1">aph):</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.814.1">from</span></span><span class="koboSpan" id="kobo.815.1"> langgraph.types </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.816.1">import</span></span><span class="koboSpan" id="kobo.817.1"> Send</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.818.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.819.1">_make_payment</span></span><span class="koboSpan" id="kobo.820.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.821.1">state</span></span><span class="koboSpan" id="kobo.822.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.823.1">  ...</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.824.1">if</span></span><span class="koboSpan" id="kobo.825.1"> ...:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.826.1">return</span></span><span class="koboSpan" id="kobo.827.1"> Command(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.828.1">     update={</span><span class="hljs-string"><span class="koboSpan" id="kobo.829.1">"payment_id"</span></span><span class="koboSpan" id="kobo.830.1">: payment_id},</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.831.1">     goto=[Send(</span><span class="hljs-string"><span class="koboSpan" id="kobo.832.1">"refresh_balance"</span></span><span class="koboSpan" id="kobo.833.1">, {</span><span class="hljs-string"><span class="koboSpan" id="kobo.834.1">"payment_id"</span></span><span class="koboSpan" id="kobo.835.1">: payment_id}, ...],</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.836.1">     graph=Command.PARENT</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.837.1">  )</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.838.1">  ...</span></p>
<div aria-label="245" epub:type="pagebreak" id="page23-5" role="doc-pagebreak"/>
<h3 class="heading-3" id="_idParaDest-156"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.839.1">Communication via a shared messages list</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.840.1">A few chapters </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.841.1">earlier, we discussed how two agents can communicate via controlled output (by sending each other special Pydantic instances). </span><span class="koboSpan" id="kobo.841.2">Now let’s go back to the communication topic and illustrate how agents can communicate with native LangChain messages. </span><span class="koboSpan" id="kobo.841.3">Let’s take the research agent with a cross-reflection and make it work with a shared list of messages. </span><span class="koboSpan" id="kobo.841.4">First, the research agent itself looks simpler – it has a default state since it gets a user’s question as a HumanMessage:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.842.1">system_prompt = (</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.843.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.844.1">You're a hard-working, curious and creative student. </span><span class="koboSpan" id="kobo.844.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.845.1">"You're working on exam quesion. </span><span class="koboSpan" id="kobo.845.2">Think step by step."</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.846.1">"Always provide an argumentation for your answer. </span><span class="koboSpan" id="kobo.846.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.847.1">"Do not assume anything, use available tools to search "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.848.1">"for evidence and supporting statements."</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.849.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.850.1">research_agent = create_react_agent(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.851.1">  model=llm_small, tools=research_tools, prompt=system_prompt)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.852.1">We also need to slightly modify the reflection prompt:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.853.1">reflection_prompt = (</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.854.1">"You are a university professor and you're supervising a student who is "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.855.1">"working on multiple-choice exam question. </span><span class="koboSpan" id="kobo.855.2">Given the dialogue above, "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.856.1">"reflect on the answer provided and give a feedback "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.857.1">" if needed. </span><span class="koboSpan" id="kobo.857.2">If you think the final answer is correct, reply with "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.858.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.859.1">an empty message. </span><span class="koboSpan" id="kobo.859.2">Only provide critique if you think the last answer "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.860.1">"might be incorrect or there are reasoning flaws. </span><span class="koboSpan" id="kobo.860.2">Do not assume anything, "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.861.1">"evaluate only the reasoning the student provided and whether there is "</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.862.1">"enough evidence for their answer."</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.863.1">)</span></p>
<div aria-label="246" epub:type="pagebreak" id="page24-5" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.864.1">The nodes themselves also look simpler, but we add </span><code class="inlineCode"><span class="koboSpan" id="kobo.865.1">Command</span></code><span class="koboSpan" id="kobo.866.1"> after the reflection node since we decide what to call </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.867.1">next with the node itself. </span><span class="koboSpan" id="kobo.867.2">Also, we don’t wrap a ReACT research agent as a node anymore:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">from</span></span><span class="koboSpan" id="kobo.869.1"> langgraph.types </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.870.1">import</span></span><span class="koboSpan" id="kobo.871.1"> Command</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.872.1">question_template = PromptTemplate.from_template(</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.873.1">"QUESTION:\n{question}\n\nANSWER OPTIONS:\n{options}\n\n"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.874.1">)</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.875.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.876.1">_ask_question</span></span><span class="koboSpan" id="kobo.877.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.878.1">state</span></span><span class="koboSpan" id="kobo.879.1">):</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.880.1">return</span></span><span class="koboSpan" id="kobo.881.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.882.1">"messages"</span></span><span class="koboSpan" id="kobo.883.1">: [(</span><span class="hljs-string"><span class="koboSpan" id="kobo.884.1">"human"</span></span><span class="koboSpan" id="kobo.885.1">, question_template.invoke(state).text)]}</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.886.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.887.1">_give_feedback</span></span><span class="koboSpan" id="kobo.888.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.889.1">state, config: RunnableConfig</span></span><span class="koboSpan" id="kobo.890.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.891.1"> messages = event[</span><span class="hljs-string"><span class="koboSpan" id="kobo.892.1">"messages"</span></span><span class="koboSpan" id="kobo.893.1">] + [(</span><span class="hljs-string"><span class="koboSpan" id="kobo.894.1">"human"</span></span><span class="koboSpan" id="kobo.895.1">, reflection_prompt)]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.896.1"> max_messages = config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.897.1">"configurable"</span></span><span class="koboSpan" id="kobo.898.1">].get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.899.1">"max_messages"</span></span><span class="koboSpan" id="kobo.900.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.901.1">20</span></span><span class="koboSpan" id="kobo.902.1">)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.903.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.904.1">len</span></span><span class="koboSpan" id="kobo.905.1">(messages) &gt; max_messages:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.906.1">return</span></span><span class="koboSpan" id="kobo.907.1"> Command(update={}, goto=END)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.908.1"> result = llm.invoke(messages)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.909.1">if</span></span><span class="koboSpan" id="kobo.910.1"> result.content:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.911.1">return</span></span><span class="koboSpan" id="kobo.912.1"> Command(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.913.1">     update={</span><span class="hljs-string"><span class="koboSpan" id="kobo.914.1">"messages"</span></span><span class="koboSpan" id="kobo.915.1">: [(</span><span class="hljs-string"><span class="koboSpan" id="kobo.916.1">"assistant"</span></span><span class="koboSpan" id="kobo.917.1">, result.content)]},</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.918.1">     goto=</span><span class="hljs-string"><span class="koboSpan" id="kobo.919.1">"research"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.920.1"> )</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.921.1">return</span></span><span class="koboSpan" id="kobo.922.1"> Command(update={}, goto=END)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.923.1">The graph itself also looks very simple:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.924.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.925.1">ReflectionAgentState</span></span><span class="koboSpan" id="kobo.926.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.927.1">MessagesState</span></span><span class="koboSpan" id="kobo.928.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.929.1"> question: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.930.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.931.1"> options: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.932.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.933.1">builder = StateGraph(ReflectionAgentState)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.934.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.935.1">"ask_question"</span></span><span class="koboSpan" id="kobo.936.1">, _ask_question)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.937.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.938.1">"research"</span></span><span class="koboSpan" id="kobo.939.1">, research_agent)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.940.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.941.1">"reflect"</span></span><span class="koboSpan" id="kobo.942.1">, _give_feedback)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.943.1">builder.add_edge(START, </span><span class="hljs-string"><span class="koboSpan" id="kobo.944.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.945.1">ask_question"</span></span><span class="koboSpan" id="kobo.946.1">)</span></p>
<div aria-label="247" epub:type="pagebreak" id="page25-4" role="doc-pagebreak"/>
<p class="snippet-code"><span class="koboSpan" id="kobo.947.1">builder.add_edge(</span><span class="hljs-string"><span class="koboSpan" id="kobo.948.1">"ask_question"</span></span><span class="koboSpan" id="kobo.949.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.950.1">"research"</span></span><span class="koboSpan" id="kobo.951.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.952.1">builder.add_edge(</span><span class="hljs-string"><span class="koboSpan" id="kobo.953.1">"research"</span></span><span class="koboSpan" id="kobo.954.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.955.1">"reflect"</span></span><span class="koboSpan" id="kobo.956.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.957.1">graph = builder.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.958.1">compile</span></span><span class="koboSpan" id="kobo.959.1">()</span></p>
<p class="normal"><span class="koboSpan" id="kobo.960.1">If we run it, we will </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.961.1">see that at every stage, the graph operates on the same (and growing) list of m</span><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.962.1">essages.</span></p>
<h2 class="heading-2" id="_idParaDest-157"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.963.1">LangGraph platform</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.964.1">LangGraph and </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.965.1">LangChain, as you know, are open-source </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.966.1">frameworks, but LangChain as a company offers the LangGraph platform – a commercial solution that helps you develop, manage, and deploy agentic applications. </span><span class="koboSpan" id="kobo.966.2">One component of the LangGraph platform is LangGraph Studio – an IDE that helps you visualize and debug your agents – and another is LangGraph Server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.967.1">You can read more about the LangGraph platform at the official website (</span><a href="https://langchain-ai.github.io/langgraph/concepts/#langgraph-platform"><span class="url"><span class="koboSpan" id="kobo.968.1">https://langchain-ai.github.io/langgraph/concepts/#langgraph-platform</span></span></a><span class="koboSpan" id="kobo.969.1">), but let’s discuss a few key concepts for a better understanding of what it means to develop an agent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.970.1">After you’ve developed an agent, you can wrap it as an HTTP API (using Flask, FastAPI, or any other web framework). </span><span class="koboSpan" id="kobo.970.2">The LangGraph platform offers you a native way to deploy agents, and it wraps them with a unified API (which makes it easier for your applications to use these agents). </span><span class="koboSpan" id="kobo.970.3">When you’ve built your agent as a LangGraph graph object, you deploy an </span><em class="italic"><span class="koboSpan" id="kobo.971.1">assistant</span></em><span class="koboSpan" id="kobo.972.1"> – a specific deployment that includes an instance of your graph coupled together with a configuration. </span><span class="koboSpan" id="kobo.972.2">You can easily version and configure assistants in the UI, but it’s important to keep parameters configurable (and pass them as </span><code class="inlineCode"><span class="koboSpan" id="kobo.973.1">RunnableConfig</span></code><span class="koboSpan" id="kobo.974.1"> to your nodes and tools).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.975.1">Another important concept is a </span><em class="italic"><span class="koboSpan" id="kobo.976.1">thread</span></em><span class="koboSpan" id="kobo.977.1">. </span><span class="koboSpan" id="kobo.977.2">Don’t be confused, a LangGraph thread is a different concept from a Python thread (and when you pass a </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">thread_id</span></code><span class="koboSpan" id="kobo.979.1"> in your </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">RunnableConfig</span></code><span class="koboSpan" id="kobo.981.1">, you’re passing a LangGraph thread ID). </span><span class="koboSpan" id="kobo.981.2">When you think about LangGraph threads, think about conversation or Reddit threads. </span><span class="koboSpan" id="kobo.981.3">A thread represents a session between your assistant (a graph with a specific configuration) and a user. </span><span class="koboSpan" id="kobo.981.4">You can add per-thread persistence using the checkpointing mechanism we discussed in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.982.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.983.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.984.1">A </span><em class="italic"><span class="koboSpan" id="kobo.985.1">run</span></em><span class="koboSpan" id="kobo.986.1"> is an invocation of an assistant. </span><span class="koboSpan" id="kobo.986.2">In most cases, runs are executed on a thread (for persistence). </span><span class="koboSpan" id="kobo.986.3">LangGraph Server also allows you to schedule stateless runs – they are not assigned to any thread, and because of that, the history of interactions is not persisted. </span><span class="koboSpan" id="kobo.986.4">LangGraph Server allows you to schedule long-running runs, scheduled runs (a.k.a. </span><span class="koboSpan" id="kobo.986.5">crons), etc., and it also offers a</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.987.1"> rich mechanism for webhooks attached to </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.988.1">runs and polling results back to the user.</span></p>
<div aria-label="248" epub:type="pagebreak" id="page26-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.989.1">We’re not going to discuss the LangGraph Server API in this book. </span><span class="koboSpan" id="kobo.989.2">Please take a look at the documentat</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.990.1">ion instead.</span></p>
<h1 class="heading-1" id="_idParaDest-158"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.991.1">Building adaptive systems</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.992.1">Adaptability is a great </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.993.1">attribute of agents. </span><span class="koboSpan" id="kobo.993.2">They should adapt to external and user feedback and correct their actions accordingly. </span><span class="koboSpan" id="kobo.993.3">As we discussed in </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.994.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.995.1">, generative AI agents are adaptive through:</span></p>
<ul>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.996.1">Tool interaction</span></strong><span class="koboSpan" id="kobo.997.1">: They incorporate feedback from previous tool calls and their outputs (by including </span><code class="inlineCode"><span class="koboSpan" id="kobo.998.1">ToolMessages</span></code><span class="koboSpan" id="kobo.999.1"> that represent tool-calling results) when planning the next steps (like our ReACT agent adjusting based on search results).</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1000.1">Explicit reflection</span></strong><span class="koboSpan" id="kobo.1001.1">: They can be instructed to analyze current results and deliberately adjust their behavior.</span></li>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1002.1">Human feedback</span></strong><span class="koboSpan" id="kobo.1003.1">: They can incorporate user input at critical dec</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.1004.1">ision points.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-159"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.1005.1">Dynamic behavior adjustment</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1006.1">We saw how to add a</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.1007.1"> reflection step to our plan-and-solve agent. </span><span class="koboSpan" id="kobo.1007.2">Given the initial plan, and the output of the steps performed so far, we’ll ask the LLM to reflect on the plan and adjust it. </span><span class="koboSpan" id="kobo.1007.3">Again, we continue reiterating the key idea – such reflection might not happen naturally; you might add it as a separate task (decomposition), and you keep partial control over the execution flow by designing its gener</span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.1008.1">ic components.</span></p>
<h2 class="heading-2" id="_idParaDest-160"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.1009.1">Human-in-the-loop</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1010.1">Additionally, when</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.1011.1"> developing agents with complex reasoning trajectories, it might be beneficial to incorporate human feedback at a certain point. </span><span class="koboSpan" id="kobo.1011.2">An agent can ask a human to approve or reject certain actions (for example, when it’s invoking a tool that is irreversible, like a tool that makes a payment), provide additional context to the agent, or give a specific input by modifying the graph’s state.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1012.1">Imagine we’re developing an agent that searches for job postings, generates an application, and sends this application. </span><span class="koboSpan" id="kobo.1012.2">We might want to ask the user before submitting an application, or the logic might be more complex – the agent might be collecting data about the user, and for some job postings, it might be missing relevant context about past job experience. </span><span class="koboSpan" id="kobo.1012.3">It should ask the user and persist this knowledge in long-term memory for better long-term adaptation.</span></p>
<div aria-label="249" epub:type="pagebreak" id="page27-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1013.1">LangGraph has a special </span><code class="inlineCode"><span class="koboSpan" id="kobo.1014.1">interrupt</span></code><span class="koboSpan" id="kobo.1015.1"> function to implement </span><strong class="keyWord"><span class="koboSpan" id="kobo.1016.1">HIL</span></strong><span class="koboSpan" id="kobo.1017.1">-type interactions. </span><span class="koboSpan" id="kobo.1017.2">You should include this function in the node, and by the first execution, it would throw a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1018.1">GraphInterrupt</span></code><span class="koboSpan" id="kobo.1019.1"> exception (the value of which would be presented to the user). </span><span class="koboSpan" id="kobo.1019.2">To resume the execution of the graph, a client should use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">Command</span></code><span class="koboSpan" id="kobo.1021.1"> class, which we discussed earlier in this chapter. </span><span class="koboSpan" id="kobo.1021.2">LangGraph would start from the same node, re-execute it, and return corresponding values as a result of the node invoking the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1022.1">interrupt</span></code><span class="koboSpan" id="kobo.1023.1"> function (if there are multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.1024.1">interrupts</span></code><span class="koboSpan" id="kobo.1025.1"> in your node, LangGraph would keep an ordering). </span><span class="koboSpan" id="kobo.1025.2">You can also use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">Command</span></code><span class="koboSpan" id="kobo.1027.1"> to route to different nodes based on the user’s input. </span><span class="koboSpan" id="kobo.1027.2">Of course, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1028.1">interrupt</span></code><span class="koboSpan" id="kobo.1029.1"> only when a checkpointer is provided to the graph since its state should be persisted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1030.1">Let’s construct a very simple graph with only the node that asks a user for their home address:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1031.1">from</span></span><span class="koboSpan" id="kobo.1032.1"> langgraph.types </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1033.1">import</span></span><span class="koboSpan" id="kobo.1034.1"> interrupt, Command</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1035.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1036.1">State</span></span><span class="koboSpan" id="kobo.1037.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1038.1">MessagesState</span></span><span class="koboSpan" id="kobo.1039.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1040.1">   home_address: </span><span class="hljs-type"><span class="koboSpan" id="kobo.1041.1">Optional</span></span><span class="koboSpan" id="kobo.1042.1">[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1043.1">str</span></span><span class="koboSpan" id="kobo.1044.1">]</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1045.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1046.1">_human_input</span></span><span class="koboSpan" id="kobo.1047.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1048.1">state: State</span></span><span class="koboSpan" id="kobo.1049.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1050.1">   address = interrupt(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1051.1">"What is your address?"</span></span><span class="koboSpan" id="kobo.1052.1">)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1053.1">return</span></span><span class="koboSpan" id="kobo.1054.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1055.1">"home_address"</span></span><span class="koboSpan" id="kobo.1056.1">: address}</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1057.1">builder = StateGraph(State)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1058.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1059.1">"human_input"</span></span><span class="koboSpan" id="kobo.1060.1">, _human_input)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1061.1">builder.add_edge(START, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1062.1">"human_input"</span></span><span class="koboSpan" id="kobo.1063.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1064.1">checkpointer = MemorySaver()</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1065.1">graph = builder.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1066.1">compile</span></span><span class="koboSpan" id="kobo.1067.1">(checkpointer=checkpointer)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1068.1">config = {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1069.1">"configurable"</span></span><span class="koboSpan" id="kobo.1070.1">: {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1071.1">"thread_id"</span></span><span class="koboSpan" id="kobo.1072.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1073.1">"1"</span></span><span class="koboSpan" id="kobo.1074.1">}}</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1075.1">for</span></span><span class="koboSpan" id="kobo.1076.1"> chunk </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1077.1">in</span></span><span class="koboSpan" id="kobo.1078.1"> graph.stream({</span><span class="hljs-string"><span class="koboSpan" id="kobo.1079.1">"messages"</span></span><span class="koboSpan" id="kobo.1080.1">: [(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1081.1">"human"</span></span><span class="koboSpan" id="kobo.1082.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1083.1">"What is weather today?"</span></span><span class="koboSpan" id="kobo.1084.1">)]}, config):</span></p>
<p class="snippet-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1085.1">print</span></span><span class="koboSpan" id="kobo.1086.1">(chunk)</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.1087.1">&gt;&gt; {'__interrupt__': (Interrupt(value='What is your address?', resumable=True, ns=['human_input:b7e8a744-b404-0a60-7967-ddb8d30b11e3'], when='during'),)}</span></p>
<div aria-label="250" epub:type="pagebreak" id="page28-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1088.1">The graph returns us a special </span><code class="inlineCode"><span class="koboSpan" id="kobo.1089.1">__interrupt__</span></code><span class="koboSpan" id="kobo.1090.1"> state and stops. </span><span class="koboSpan" id="kobo.1090.2">Now our application (the client) should ask the user this question, and then we can resume. </span><span class="koboSpan" id="kobo.1090.3">Please note that we’re providing the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.1091.1">thread_id</span></code><span class="koboSpan" id="kobo.1092.1"> to restore from the checkpoint:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1093.1">for</span></span><span class="koboSpan" id="kobo.1094.1"> chunk </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1095.1">in</span></span><span class="koboSpan" id="kobo.1096.1"> graph.stream(Command(resume=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1097.1">"Munich"</span></span><span class="koboSpan" id="kobo.1098.1">), config):</span></p>
<p class="snippet-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1099.1">print</span></span><span class="koboSpan" id="kobo.1100.1">(chunk)</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.1101.1">&gt;&gt; {'human_input': {'home_address': 'Munich'}}</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1102.1">Note that the graph continued to execute the human_input node, but this time the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">interrupt</span></code><span class="koboSpan" id="kobo.1104.1"> function returned the result, and the graph’s state was updated.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1105.1">So far, we’ve</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.1106.1"> discussed a few architectural patterns on how to develop an agent. </span><span class="koboSpan" id="kobo.1106.2">Now let’s take a look at another interesting one that allows LLMs to run multiple simulations while they’re looking</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.1107.1"> for a solution.</span></p>
<h1 class="heading-1" id="_idParaDest-161"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.1108.1">Exploring reasoning paths</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1109.1">In </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.1110.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.1111.1">, we discussed</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.1112.1"> CoT prompting. </span><span class="koboSpan" id="kobo.1112.2">But with CoT prompting, the LLM creates a reasoning path within a single turn. </span><span class="koboSpan" id="kobo.1112.3">What if we combine the decomposition pattern and the adaptation pattern by splitting this reaso</span><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.1113.1">ning into pieces?</span></p>
<h2 class="heading-2" id="_idParaDest-162"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.1114.1">Tree of Thoughts</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1115.1">Researchers from </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.1116.1">Google DeepMind and Princeton University </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.1117.1">introduced</span><strong class="keyWord"><span class="koboSpan" id="kobo.1118.1"> the ToT </span></strong><span class="koboSpan" id="kobo.1119.1">technique in December 2023. </span><span class="koboSpan" id="kobo.1119.2">They generalize the CoT pattern and use thoughts as intermediate steps in the exploration process toward the global solution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1120.1">Let’s return to the plan-and-solve agent we built in the previous chapter. </span><span class="koboSpan" id="kobo.1120.2">Let’s use the non-deterministic nature of LLMs to improve it. </span><span class="koboSpan" id="kobo.1120.3">We can generate multiple candidates for the next action in the plan on every step (we might need to increase the temperature of the underlying LLM). </span><span class="koboSpan" id="kobo.1120.4">That would help the agent to be more adaptive since the next plan generated will take into account the outputs of the previous step.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1121.1">Now we can build a tree of various options and explore this tree with the depth-for-search or breadth-for-search method. </span><span class="koboSpan" id="kobo.1121.2">At the end, we’ll get multiple solutions, and we’ll use some of the consensus mechanisms discussed above to pick the best one (for example, LLM-as-a-judge).</span></p>
<div aria-label="251" epub:type="pagebreak" id="page29-4" role="doc-pagebreak"/>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1122.1"><img alt="Figure 6.7: Solution path exploration with ToT" src="../Images/B32363_06_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1123.1">Figure 6.7: Solution path exploration with ToT</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1124.1">Please note that the model’s provider should support the generation of multiple candidates in the response (not all providers support this feature).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1125.1">We would like to highlight (and we’re not tired of doing this repeatedly in this chapter) that there’s nothing entirely new in the ToT pattern. </span><span class="koboSpan" id="kobo.1125.2">You take what algorithms and patterns have been used already in other areas, and you use them to build capable agents.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1126.1">Now it’s time to do some coding. </span><span class="koboSpan" id="kobo.1126.2">We’ll take the same components of the plan-and-solve agents we developed in </span><a href="E_Chapter_5.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.1127.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.1128.1"> – a planner that creates an initial plan and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1129.1">execution_agent</span></code><span class="koboSpan" id="kobo.1130.1">, which is a research agent with access to tools and works on a specific step in the plan. </span><span class="koboSpan" id="kobo.1130.2">We can make our execution agent simpler since we don’t need a custom state:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1131.1">execution_agent = prompt_template | create_react_agent(model=llm, tools=tools)</span></p>
<div aria-label="252" epub:type="pagebreak" id="page30-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1132.1">We also need a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1133.1">replanner</span></code><em class="italic"> </em><span class="koboSpan" id="kobo.1134.1">component, which will take care of adjusting the plan based on previous </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.1135.1">observations</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.1136.1"> and generating multiple candidates for the next action:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1137.1">from</span></span><span class="koboSpan" id="kobo.1138.1"> langchain_core.prompts </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1139.1">import</span></span><span class="koboSpan" id="kobo.1140.1"> ChatPromptTemplate</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1141.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1142.1">ReplanStep</span></span><span class="koboSpan" id="kobo.1143.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1144.1">BaseModel</span></span><span class="koboSpan" id="kobo.1145.1">):</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1146.1">"""Replanned next step in the plan."""</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1147.1">   steps: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1148.1">list</span></span><span class="koboSpan" id="kobo.1149.1">[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1150.1">str</span></span><span class="koboSpan" id="kobo.1151.1">] = Field(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1152.1">       description=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1153.1">"different options of the proposed next step"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1154.1">   )</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1155.1">llm_replanner = llm.with_structured_output(ReplanStep)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1156.1">replanner_prompt_template = (</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1157.1">"Suggest next action in the plan. </span><span class="koboSpan" id="kobo.1157.2">Do not add any superfluous steps.\n"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1158.1">"If you think no actions are needed, just return an empty list of steps. </span><span class="koboSpan" id="kobo.1158.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1159.1">"TASK: {task}\n PREVIOUS STEPS WITH OUTPUTS: {current_plan}"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1160.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1161.1">replanner_prompt = ChatPromptTemplate.from_messages(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1162.1">   [(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1163.1">"system"</span></span><span class="koboSpan" id="kobo.1164.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1165.1">"You're a helpful assistant. </span><span class="koboSpan" id="kobo.1165.2">You goal is to help with planning actions to solve the task. </span><span class="koboSpan" id="kobo.1165.3">Do not solve the task itself."</span></span><span class="koboSpan" id="kobo.1166.1">),</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1167.1">    (</span><span class="hljs-string"><span class="koboSpan" id="kobo.1168.1">"user"</span></span><span class="koboSpan" id="kobo.1169.1">, replanner_prompt_template)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1170.1">   ]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1171.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1172.1">replanner = replanner_prompt | llm_replanner</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1173.1">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.1174.1">replanner</span></code><span class="koboSpan" id="kobo.1175.1"> component is crucial for our ToT approach. </span><span class="koboSpan" id="kobo.1175.2">It takes the current plan state and generates multiple potential next steps, encouraging exploration of different solution paths rather than following a single linear sequence.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1176.1">To track our exploration path, we need a tree data structure. </span><span class="koboSpan" id="kobo.1176.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1177.1">TreeNode</span></code><span class="koboSpan" id="kobo.1178.1"> class below helps us maintain it:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1179.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1180.1">TreeNode</span></span><span class="koboSpan" id="kobo.1181.1">:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1182.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1183.1">__init__</span></span><span class="koboSpan" id="kobo.1184.1">(</span></p>
<div aria-label="253" epub:type="pagebreak" id="page31-4" role="doc-pagebreak"/>
<p class="snippet-code"><span class="hljs-params"><span class="koboSpan" id="kobo.1185.1">       self,</span></span></p>
<p class="snippet-code"><span class="hljs-params"><span class="koboSpan" id="kobo.1186.1">       node_id: </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1187.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1188.1">,</span></span></p>
<p class="snippet-code"><span class="hljs-params"><span class="koboSpan" id="kobo.1189.1">       step: </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1190.1">str</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1191.1">,</span></span></p>
<p class="snippet-code"><span class="hljs-params"><span class="koboSpan" id="kobo.1192.1">       step_output: </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1193.1">Optional</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1194.1">[</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1195.1">str</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1196.1">] = </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1197.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1198.1">,</span></span></p>
<p class="snippet-code"><span class="hljs-params"><span class="koboSpan" id="kobo.1199.1">       parent: </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1200.1">Optional</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1201.1">[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1202.1">"TreeNode"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1203.1">] = </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1204.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1205.1">,</span></span></p>
<p class="snippet-code"><span class="hljs-params"> </span><span class="koboSpan" id="kobo.1206.1">):</span></p>
<p class="snippet-code"> <span class="hljs-variable"><span class="koboSpan" id="kobo.1207.1">self</span></span><span class="koboSpan" id="kobo.1208.1">.node_id = node_id</span></p>
<p class="snippet-code"> <span class="hljs-variable"><span class="koboSpan" id="kobo.1209.1">self</span></span><span class="koboSpan" id="kobo.1210.1">.step = step</span></p>
<p class="snippet-code"> <span class="hljs-variable"><span class="koboSpan" id="kobo.1211.1">self</span></span><span class="koboSpan" id="kobo.1212.1">.step_output = step_output</span></p>
<p class="snippet-code"> <span class="hljs-variable"><span class="koboSpan" id="kobo.1213.1">self</span></span><span class="koboSpan" id="kobo.1214.1">.parent = parent</span></p>
<p class="snippet-code"> <span class="hljs-variable"><span class="koboSpan" id="kobo.1215.1">self</span></span><span class="koboSpan" id="kobo.1216.1">.children = []</span></p>
<p class="snippet-code"> <span class="hljs-variable"><span class="koboSpan" id="kobo.1217.1">self</span></span><span class="koboSpan" id="kobo.1218.1">.final_response = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1219.1">None</span></span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1220.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1221.1">__repr__</span></span><span class="koboSpan" id="kobo.1222.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1223.1">self</span></span><span class="koboSpan" id="kobo.1224.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1225.1">   parent_id = </span><span class="hljs-variable"><span class="koboSpan" id="kobo.1226.1">self</span></span><span class="koboSpan" id="kobo.1227.1">.parent.node_id </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1228.1">if</span></span> <span class="hljs-variable"><span class="koboSpan" id="kobo.1229.1">self</span></span><span class="koboSpan" id="kobo.1230.1">.parent </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">else</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1232.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1233.1">None"</span></span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1234.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1235.1">f"Node_id: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1236.1">{self.node_id}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1237.1">, parent: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1238.1">{parent_id}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1239.1">, </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1240.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1241.1">len</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1242.1">(self.children)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1243.1"> children."</span></span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1244.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1245.1">get_full_plan</span></span><span class="koboSpan" id="kobo.1246.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1247.1">self</span></span><span class="koboSpan" id="kobo.1248.1">) -&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1249.1">str</span></span><span class="koboSpan" id="kobo.1250.1">:</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1251.1">"""Returns formatted plan with step numbers and past results."""</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1252.1">   steps = []</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1253.1">   node = </span><span class="hljs-variable"><span class="koboSpan" id="kobo.1254.1">self</span></span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1255.1">while</span></span><span class="koboSpan" id="kobo.1256.1"> node.parent:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1257.1">     steps.append((node.step, node.step_output))</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1258.1">     node = node.parent</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1259.1">   full_plan = []</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1260.1">for</span></span><span class="koboSpan" id="kobo.1261.1"> i, (step, result) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1262.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1263.1">enumerate</span></span><span class="koboSpan" id="kobo.1264.1">(steps[::-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1265.1">1</span></span><span class="koboSpan" id="kobo.1266.1">]):</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1267.1">if</span></span><span class="koboSpan" id="kobo.1268.1"> result:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1269.1">       full_plan.append(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1270.1">f"# </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1271.1">{i+</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1272.1">1</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1273.1">}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1274.1">. </span><span class="koboSpan" id="kobo.1274.2">Planned step: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1275.1">{step}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1276.1">\nResult: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1277.1">{result}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1278.1">\n"</span></span><span class="koboSpan" id="kobo.1279.1">)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1280.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1281.1">"\n"</span></span><span class="koboSpan" id="kobo.1282.1">.join(full_plan)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1283.1">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.1284.1">TreeNode</span></code><span class="koboSpan" id="kobo.1285.1"> tracks its identity, current step, output, parent relationship, and children. </span><span class="koboSpan" id="kobo.1285.2">We also created a method </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.1286.1">to get a formatted full plan (we’ll substitute it in </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.1287.1">place of the prompt’s template), and just to make debugging more convenient, we overrode a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1288.1">__repr__</span></code><span class="koboSpan" id="kobo.1289.1"> method that returns a readable description of the node.</span></p>
<div aria-label="254" epub:type="pagebreak" id="page32-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1290.1">Now we need to implement the core logic of our agent. </span><span class="koboSpan" id="kobo.1290.2">We will explore our tree of actions in a depth-for-search mode. </span><span class="koboSpan" id="kobo.1290.3">This is where the real power of the ToT pattern comes into play:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1291.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1292.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1293.1">_run_node</span></span><span class="koboSpan" id="kobo.1294.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1295.1">state: PlanState, config: RunnableConfig</span></span><span class="koboSpan" id="kobo.1296.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1297.1"> node = state.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1298.1">"next_node"</span></span><span class="koboSpan" id="kobo.1299.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1300.1"> visited_ids = state.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1301.1">"visited_ids"</span></span><span class="koboSpan" id="kobo.1302.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1303.1">set</span></span><span class="koboSpan" id="kobo.1304.1">())</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1305.1"> queue = state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1306.1">"queue"</span></span><span class="koboSpan" id="kobo.1307.1">]</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1308.1">if</span></span><span class="koboSpan" id="kobo.1309.1"> node </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1310.1">is</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1311.1">None</span></span><span class="koboSpan" id="kobo.1312.1">:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1313.1">while</span></span><span class="koboSpan" id="kobo.1314.1"> queue </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1315.1">and</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1316.1">not</span></span><span class="koboSpan" id="kobo.1317.1"> node:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1318.1">     node = state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1319.1">"queue"</span></span><span class="koboSpan" id="kobo.1320.1">].popleft()</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1321.1">if</span></span><span class="koboSpan" id="kobo.1322.1"> node.node_id </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1323.1">in</span></span><span class="koboSpan" id="kobo.1324.1"> visited_ids:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1325.1">       node = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1326.1">None</span></span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1327.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1328.1">not</span></span><span class="koboSpan" id="kobo.1329.1"> node:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1330.1">return</span></span><span class="koboSpan" id="kobo.1331.1"> Command(goto=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1332.1">"vote"</span></span><span class="koboSpan" id="kobo.1333.1">, update={})</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1334.1"> step = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1335.1">await</span></span><span class="koboSpan" id="kobo.1336.1"> execution_agent.ainvoke({</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1337.1">"previous_steps"</span></span><span class="koboSpan" id="kobo.1338.1">: node.get_full_plan(),</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1339.1">"step"</span></span><span class="koboSpan" id="kobo.1340.1">: node.step,</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1341.1">"task"</span></span><span class="koboSpan" id="kobo.1342.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1343.1">"task"</span></span><span class="koboSpan" id="kobo.1344.1">]})</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1345.1"> node.step_output = step[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1346.1">"messages"</span></span><span class="koboSpan" id="kobo.1347.1">][-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1348.1">1</span></span><span class="koboSpan" id="kobo.1349.1">].content</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1350.1"> visited_ids.add(node.node_id)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1351.1">return</span></span><span class="koboSpan" id="kobo.1352.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1353.1">"current_node"</span></span><span class="koboSpan" id="kobo.1354.1">: node, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1355.1">"queue"</span></span><span class="koboSpan" id="kobo.1356.1">: queue, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1357.1">"visited_ids"</span></span><span class="koboSpan" id="kobo.1358.1">: visited_ids, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1359.1">"next_node"</span></span><span class="koboSpan" id="kobo.1360.1">: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1361.1">None</span></span><span class="koboSpan" id="kobo.1362.1">}</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1363.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1364.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1365.1">_plan_next</span></span><span class="koboSpan" id="kobo.1366.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1367.1">state: PlanState, config: RunnableConfig</span></span><span class="koboSpan" id="kobo.1368.1">) -&gt; PlanState:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1369.1"> max_candidates = config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1370.1">"configurable"</span></span><span class="koboSpan" id="kobo.1371.1">].get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1372.1">"max_candidates"</span></span><span class="koboSpan" id="kobo.1373.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1374.1">1</span></span><span class="koboSpan" id="kobo.1375.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1376.1"> node = state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1377.1">"current_node"</span></span><span class="koboSpan" id="kobo.1378.1">]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1379.1"> next_step = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1380.1">await</span></span><span class="koboSpan" id="kobo.1381.1"> replanner.ainvoke({</span><span class="hljs-string"><span class="koboSpan" id="kobo.1382.1">"task"</span></span><span class="koboSpan" id="kobo.1383.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1384.1">"task"</span></span><span class="koboSpan" id="kobo.1385.1">], </span><span class="hljs-string"><span class="koboSpan" id="kobo.1386.1">"current_plan"</span></span><span class="koboSpan" id="kobo.1387.1">: node.get_full_plan()})</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1388.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1389.1">not</span></span><span class="koboSpan" id="kobo.1390.1"> next_step.steps:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1391.1">return</span></span><span class="koboSpan" id="kobo.1392.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1393.1">"is_current_node_final"</span></span><span class="koboSpan" id="kobo.1394.1">: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1395.1">True</span></span><span class="koboSpan" id="kobo.1396.1">}</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1397.1"> max_id = state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1398.1">"max_id"</span></span><span class="koboSpan" id="kobo.1399.1">]</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1400.1">for</span></span><span class="koboSpan" id="kobo.1401.1"> step </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1402.1">in</span></span><span class="koboSpan" id="kobo.1403.1"> next_step.steps[:max_candidates]:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1404.1">   child = TreeNode(node_id=max_id+</span><span class="hljs-number"><span class="koboSpan" id="kobo.1405.1">1</span></span><span class="koboSpan" id="kobo.1406.1">, step=step, parent=node)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1407.1">   max_id += </span><span class="hljs-number"><span class="koboSpan" id="kobo.1408.1">1</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1409.1">   node.children.append(child)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1410.1">   state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1411.1">"queue"</span></span><span class="koboSpan" id="kobo.1412.1">].append(child)</span></p>
<div aria-label="255" epub:type="pagebreak" id="page33-4" role="doc-pagebreak"/>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1413.1">return</span></span><span class="koboSpan" id="kobo.1414.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1415.1">"is_current_node_final"</span></span><span class="koboSpan" id="kobo.1416.1">: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1417.1">False</span></span><span class="koboSpan" id="kobo.1418.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1419.1">"next_node"</span></span><span class="koboSpan" id="kobo.1420.1">: child, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1421.1">"max_id"</span></span><span class="koboSpan" id="kobo.1422.1">: max_id}</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1423.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1424.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1425.1">_get_final_response</span></span><span class="koboSpan" id="kobo.1426.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1427.1">state: PlanState</span></span><span class="koboSpan" id="kobo.1428.1">) -&gt; PlanState:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1429.1"> node = state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1430.1">"current_node"</span></span><span class="koboSpan" id="kobo.1431.1">]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1432.1"> final_response = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1433.1">await</span></span><span class="koboSpan" id="kobo.1434.1"> responder.ainvoke({</span><span class="hljs-string"><span class="koboSpan" id="kobo.1435.1">"task"</span></span><span class="koboSpan" id="kobo.1436.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1437.1">"task"</span></span><span class="koboSpan" id="kobo.1438.1">], </span><span class="hljs-string"><span class="koboSpan" id="kobo.1439.1">"plan"</span></span><span class="koboSpan" id="kobo.1440.1">: node.get_full_plan()})</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1441.1"> node.final_response = final_response</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1442.1">return</span></span><span class="koboSpan" id="kobo.1443.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1444.1">"paths_explored"</span></span><span class="koboSpan" id="kobo.1445.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1446.1">1</span></span><span class="koboSpan" id="kobo.1447.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1448.1">"candidates"</span></span><span class="koboSpan" id="kobo.1449.1">: [final_response]}</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1450.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1451.1">_run_node</span></code><span class="koboSpan" id="kobo.1452.1"> function executes the current step, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1453.1">_plan_next</span></code><span class="koboSpan" id="kobo.1454.1"> generates new candidate steps and adds</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.1455.1"> them </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.1456.1">to our exploration queue. </span><span class="koboSpan" id="kobo.1456.2">When we reach a final node (one where no further steps are needed), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1457.1">_get_final_response</span></code><span class="koboSpan" id="kobo.1458.1"> generates a final solution by picking the best one from multiple candidates (originating from different solution paths explored). </span><span class="koboSpan" id="kobo.1458.2">Hence, in our agent’s state, we should keep track of the root node, the next node, the queue of nodes to be explored, and the nodes we’ve already explored:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1459.1">import</span></span><span class="koboSpan" id="kobo.1460.1"> operator</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1461.1">from</span></span><span class="koboSpan" id="kobo.1462.1"> collections </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1463.1">import</span></span><span class="koboSpan" id="kobo.1464.1"> deque</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1465.1">from</span></span><span class="koboSpan" id="kobo.1466.1"> typing </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1467.1">import</span></span><span class="koboSpan" id="kobo.1468.1"> Annotated</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1469.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1470.1">PlanState</span></span><span class="koboSpan" id="kobo.1471.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.1472.1">TypedDict</span></span><span class="koboSpan" id="kobo.1473.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1474.1">   task: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1475.1">str</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1476.1">   root: TreeNode</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1477.1">   queue: deque[TreeNode]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1478.1">   current_node: TreeNode</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1479.1">   next_node: TreeNode</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1480.1">   is_current_node_final: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1481.1">bool</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1482.1">   paths_explored: Annotated[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1483.1">int</span></span><span class="koboSpan" id="kobo.1484.1">, operator.add]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1485.1">   visited_ids: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1486.1">set</span></span><span class="koboSpan" id="kobo.1487.1">[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1488.1">int</span></span><span class="koboSpan" id="kobo.1489.1">]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1490.1">   max_id: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1491.1">int</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1492.1">   candidates: Annotated[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1493.1">list</span></span><span class="koboSpan" id="kobo.1494.1">[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1495.1">str</span></span><span class="koboSpan" id="kobo.1496.1">], operator.add]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1497.1">   best_candidate: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1498.1">str</span></span></p>
<p class="normal"><span class="koboSpan" id="kobo.1499.1">This state structure keeps track of everything we need: the original task, our tree structure, exploration queue, path metadata, and candidate solutions. </span><span class="koboSpan" id="kobo.1499.2">Note the special </span><code class="inlineCode"><span class="koboSpan" id="kobo.1500.1">Annotated</span></code><span class="koboSpan" id="kobo.1501.1"> types that use custom reducers (like</span><code class="inlineCode"><span class="koboSpan" id="kobo.1502.1"> operator.add</span></code><span class="koboSpan" id="kobo.1503.1">) to handle merging state values properly.</span></p>
<div aria-label="256" epub:type="pagebreak" id="page34-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1504.1">One important thing to keep in mind is that LangGraph doesn’t allow you to modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.1505.1">state</span></code><span class="koboSpan" id="kobo.1506.1"> directly. </span><span class="koboSpan" id="kobo.1506.2">In other words, if we execute something like the following within a node, it won’t have an effect on the actual queue in the agent’s state:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1507.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1508.1">my_node</span></span><span class="koboSpan" id="kobo.1509.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1510.1">state</span></span><span class="koboSpan" id="kobo.1511.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1512.1">  queue = state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1513.1">"queue"</span></span><span class="koboSpan" id="kobo.1514.1">]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1515.1">  node = queue.pop()</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1516.1">  ...</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1517.1">  queue.append(another_node)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1518.1">return</span></span><span class="koboSpan" id="kobo.1519.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1520.1">"key"</span></span><span class="koboSpan" id="kobo.1521.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1522.1">"value"</span></span><span class="koboSpan" id="kobo.1523.1">}</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1524.1">If we want to </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.1525.1">modify the queue that belongs to the state itself, we should </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.1526.1">either use a custom reducer (as we discussed in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.1527.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.1528.1">) or return the queue object to be replaced (since under the hood, LangGraph always created deep copies of the state before passing it to the node).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1529.1">We need to define the final step now – the consensus mechanism to choose the final answer based on multiple generated candidates:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1530.1">prompt_voting = PromptTemplate.from_template(</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1531.1">"Pick the best solution for a given task. </span><span class="koboSpan" id="kobo.1531.2">"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1532.1">"\nTASK:{task}\n\nSOLUTIONS:\n{candidates}\n"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1533.1">)</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1534.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1535.1">_vote_for_the_best_option</span></span><span class="koboSpan" id="kobo.1536.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1537.1">state</span></span><span class="koboSpan" id="kobo.1538.1">):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1539.1"> candidates = state.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1540.1">"candidates"</span></span><span class="koboSpan" id="kobo.1541.1">, [])</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1542.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1543.1">not</span></span><span class="koboSpan" id="kobo.1544.1"> candidates:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">return</span></span><span class="koboSpan" id="kobo.1546.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1547.1">"best_response"</span></span><span class="koboSpan" id="kobo.1548.1">: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1549.1">None</span></span><span class="koboSpan" id="kobo.1550.1">}</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1551.1"> all_candidates = []</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1552.1">for</span></span><span class="koboSpan" id="kobo.1553.1"> i, candidate </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1554.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1555.1">enumerate</span></span><span class="koboSpan" id="kobo.1556.1">(candidates):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1557.1">   all_candidates.append(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1558.1">f"OPTION </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1559.1">{i+</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1560.1">1</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1561.1">}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1562.1">: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1563.1">{candidate}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1564.1">"</span></span><span class="koboSpan" id="kobo.1565.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1566.1"> response_schema = {</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1567.1">"type"</span></span><span class="koboSpan" id="kobo.1568.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1569.1">"STRING"</span></span><span class="koboSpan" id="kobo.1570.1">,</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1571.1">"enum"</span></span><span class="koboSpan" id="kobo.1572.1">: [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1573.1">str</span></span><span class="koboSpan" id="kobo.1574.1">(i+</span><span class="hljs-number"><span class="koboSpan" id="kobo.1575.1">1</span></span><span class="koboSpan" id="kobo.1576.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1577.1">for</span></span><span class="koboSpan" id="kobo.1578.1"> i </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1579.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1580.1">range</span></span><span class="koboSpan" id="kobo.1581.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1582.1">len</span></span><span class="koboSpan" id="kobo.1583.1">(all_candidates))]}</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1584.1"> llm_enum = ChatVertexAI(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1585.1">     model_name=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1586.1">"gemini-2.0-flash-001"</span></span><span class="koboSpan" id="kobo.1587.1">, response_mime_type=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1588.1">"text/x.enum"</span></span><span class="koboSpan" id="kobo.1589.1">,</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1590.1">     response_schema=response_schema)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1591.1"> result = (prompt_voting | llm_enum | StrOutputParser()).invoke(</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1592.1">     {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1593.1">"candidates"</span></span><span class="koboSpan" id="kobo.1594.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1595.1">"\n"</span></span><span class="koboSpan" id="kobo.1596.1">.join(all_candidates), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1597.1">"task"</span></span><span class="koboSpan" id="kobo.1598.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1599.1">"task"</span></span><span class="koboSpan" id="kobo.1600.1">]}</span></p>
<div aria-label="257" epub:type="pagebreak" id="page35-4" role="doc-pagebreak"/>
<p class="snippet-code"><span class="koboSpan" id="kobo.1601.1"> )</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1602.1">return</span></span><span class="koboSpan" id="kobo.1603.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1604.1">"best_candidate"</span></span><span class="koboSpan" id="kobo.1605.1">: candidates[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1606.1">int</span></span><span class="koboSpan" id="kobo.1607.1">(result)-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1608.1">1</span></span><span class="koboSpan" id="kobo.1609.1">]}</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1610.1">This voting mechanism presents all candidate solutions to the model and asks it to select the best one, leveraging the model’s ability to evaluate and compare options. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1611.1">Now let’s add the remaining nodes and edges of the agent. </span><span class="koboSpan" id="kobo.1611.2">We need two nodes – the one that creates an initial plan and another that evaluates the final output. </span><span class="koboSpan" id="kobo.1611.3">Alongside these, we define two corresponding </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.1612.1">edges that evaluate whether the agent should continue on</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.1613.1"> its exploration and whether it’s ready to provide a final response to the user:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1614.1">from</span></span><span class="koboSpan" id="kobo.1615.1"> typing </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1616.1">import</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1617.1">Literal</span></span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1618.1">from</span></span><span class="koboSpan" id="kobo.1619.1"> langgraph.graph </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1620.1">import</span></span><span class="koboSpan" id="kobo.1621.1"> StateGraph, START, END</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1622.1">from</span></span><span class="koboSpan" id="kobo.1623.1"> langchain_core.runnables </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1624.1">import</span></span><span class="koboSpan" id="kobo.1625.1"> RunnableConfig</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1626.1">from</span></span><span class="koboSpan" id="kobo.1627.1"> langchain_core.output_parsers </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1628.1">import</span></span><span class="koboSpan" id="kobo.1629.1"> StrOutputParser</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1630.1">from</span></span><span class="koboSpan" id="kobo.1631.1"> langgraph.types </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1632.1">import</span></span><span class="koboSpan" id="kobo.1633.1"> Command</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1634.1">final_prompt = PromptTemplate.from_template(</span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1635.1">"You're a helpful assistant that has executed on a plan."</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1636.1">"Given the results of the execution, prepare the final response.\n"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1637.1">"Don't assume anything\nTASK:\n{task}\n\nPLAN WITH RESUlTS:\n{plan}\n"</span></span></p>
<p class="snippet-code"> <span class="hljs-string"><span class="koboSpan" id="kobo.1638.1">"FINAL RESPONSE:\n"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1639.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1640.1">responder = final_prompt | llm | StrOutputParser()</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1641.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1642.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1643.1">_build_initial_plan</span></span><span class="koboSpan" id="kobo.1644.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1645.1">state: PlanState</span></span><span class="koboSpan" id="kobo.1646.1">) -&gt; PlanState:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1647.1"> plan = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1648.1">await</span></span><span class="koboSpan" id="kobo.1649.1"> planner.ainvoke(state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1650.1">"task"</span></span><span class="koboSpan" id="kobo.1651.1">])</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1652.1"> queue = deque()</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1653.1"> root = TreeNode(step=plan.steps[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1654.1">0</span></span><span class="koboSpan" id="kobo.1655.1">], node_id=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1656.1">1</span></span><span class="koboSpan" id="kobo.1657.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1658.1"> queue.append(root)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1659.1"> current_root = root</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1660.1">for</span></span><span class="koboSpan" id="kobo.1661.1"> i, step </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1662.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1663.1">enumerate</span></span><span class="koboSpan" id="kobo.1664.1">(plan.steps[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1665.1">1</span></span><span class="koboSpan" id="kobo.1666.1">:]):</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1667.1">   child = TreeNode(node_id=i+</span><span class="hljs-number"><span class="koboSpan" id="kobo.1668.1">2</span></span><span class="koboSpan" id="kobo.1669.1">, step=step, parent=current_root)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1670.1">   current_root.children.append(child)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1671.1">   queue.append(child)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1672.1">   current_root = child</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1673.1">return</span></span><span class="koboSpan" id="kobo.1674.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1675.1">"root"</span></span><span class="koboSpan" id="kobo.1676.1">: root, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1677.1">"queue"</span></span><span class="koboSpan" id="kobo.1678.1">: queue, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1679.1">"max_id"</span></span><span class="koboSpan" id="kobo.1680.1">: i+</span><span class="hljs-number"><span class="koboSpan" id="kobo.1681.1">2</span></span><span class="koboSpan" id="kobo.1682.1">}</span></p>
<div aria-label="258" epub:type="pagebreak" id="page36-4" role="doc-pagebreak"/>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1683.1">async</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1684.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1685.1">_get_final_response</span></span><span class="koboSpan" id="kobo.1686.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1687.1">state: PlanState</span></span><span class="koboSpan" id="kobo.1688.1">) -&gt; PlanState:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1689.1"> node = state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1690.1">"current_node"</span></span><span class="koboSpan" id="kobo.1691.1">]</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1692.1"> final_response = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1693.1">await</span></span><span class="koboSpan" id="kobo.1694.1"> responder.ainvoke({</span><span class="hljs-string"><span class="koboSpan" id="kobo.1695.1">"task"</span></span><span class="koboSpan" id="kobo.1696.1">: state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1697.1">"task"</span></span><span class="koboSpan" id="kobo.1698.1">], </span><span class="hljs-string"><span class="koboSpan" id="kobo.1699.1">"plan"</span></span><span class="koboSpan" id="kobo.1700.1">: node.get_full_plan()})</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1701.1"> node.final_response = final_response</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1702.1">return</span></span><span class="koboSpan" id="kobo.1703.1"> {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1704.1">"paths_explored"</span></span><span class="koboSpan" id="kobo.1705.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1706.1">1</span></span><span class="koboSpan" id="kobo.1707.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1708.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1709.1">candidates"</span></span><span class="koboSpan" id="kobo.1710.1">: [final_response]}</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1711.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1712.1">_should_create_final_response</span></span><span class="koboSpan" id="kobo.1713.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1714.1">state: PlanState</span></span><span class="koboSpan" id="kobo.1715.1">) -&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.1716.1">Literal</span></span><span class="koboSpan" id="kobo.1717.1">[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1718.1">"run"</span></span><span class="koboSpan" id="kobo.1719.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1720.1">"generate_response"</span></span><span class="koboSpan" id="kobo.1721.1">]:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1722.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1723.1">"generate_response"</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1724.1">if</span></span><span class="koboSpan" id="kobo.1725.1"> state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1726.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1727.1">is_current_node_final"</span></span><span class="koboSpan" id="kobo.1728.1">] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1729.1">else</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1730.1">"run"</span></span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1731.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1732.1">_should_continue</span></span><span class="koboSpan" id="kobo.1733.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1734.1">state: PlanState, config: RunnableConfig</span></span><span class="koboSpan" id="kobo.1735.1">) -&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.1736.1">Literal</span></span><span class="koboSpan" id="kobo.1737.1">[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1738.1">"run"</span></span><span class="koboSpan" id="kobo.1739.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1740.1">"vote"</span></span><span class="koboSpan" id="kobo.1741.1">]:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1742.1"> max_paths = config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1743.1">"configurable"</span></span><span class="koboSpan" id="kobo.1744.1">].get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1745.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1746.1">max_paths"</span></span><span class="koboSpan" id="kobo.1747.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1748.1">30</span></span><span class="koboSpan" id="kobo.1749.1">)</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1750.1">if</span></span><span class="koboSpan" id="kobo.1751.1"> state.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1752.1">"paths_explored"</span></span><span class="koboSpan" id="kobo.1753.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1754.1">1</span></span><span class="koboSpan" id="kobo.1755.1">) &gt; max_paths:</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1756.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1757.1">"vote"</span></span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1758.1">if</span></span><span class="koboSpan" id="kobo.1759.1"> state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1760.1">"queue"</span></span><span class="koboSpan" id="kobo.1761.1">] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1762.1">or</span></span><span class="koboSpan" id="kobo.1763.1"> state.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1764.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1765.1">next_node"</span></span><span class="koboSpan" id="kobo.1766.1">):</span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1767.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1768.1">"run"</span></span></p>
<p class="snippet-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1769.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1770.1">"vote"</span></span></p>
<p class="normal"><span class="koboSpan" id="kobo.1771.1">These functions round out our implementation by defining the initial plan creation, final response</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.1772.1"> generation, and </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.1773.1">flow control logic. </span><span class="koboSpan" id="kobo.1773.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1774.1">_should_create_final_response</span></code><span class="koboSpan" id="kobo.1775.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1776.1">_should_continue</span></code><span class="koboSpan" id="kobo.1777.1"> functions determine when to generate a final response and when to continue exploration. </span><span class="koboSpan" id="kobo.1777.2">With all the components in place, we construct the final state graph:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1778.1">builder = StateGraph(PlanState)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1779.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1780.1">"initial_plan"</span></span><span class="koboSpan" id="kobo.1781.1">, _build_initial_plan)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1782.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1783.1">"run"</span></span><span class="koboSpan" id="kobo.1784.1">, _run_node)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1785.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1786.1">"plan_next"</span></span><span class="koboSpan" id="kobo.1787.1">, _plan_next)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1788.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1789.1">"generate_response"</span></span><span class="koboSpan" id="kobo.1790.1">, _get_final_response)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1791.1">builder.add_node(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1792.1">"vote"</span></span><span class="koboSpan" id="kobo.1793.1">, _vote_for_the_best_option)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1794.1">builder.add_edge(START, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1795.1">"initial_plan"</span></span><span class="koboSpan" id="kobo.1796.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1797.1">builder.add_edge(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1798.1">"initial_plan"</span></span><span class="koboSpan" id="kobo.1799.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1800.1">"run"</span></span><span class="koboSpan" id="kobo.1801.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1802.1">builder.add_edge(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1803.1">"run"</span></span><span class="koboSpan" id="kobo.1804.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1805.1">"plan_next"</span></span><span class="koboSpan" id="kobo.1806.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1807.1">builder.add_conditional_edges(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1808.1">"plan_next"</span></span><span class="koboSpan" id="kobo.1809.1">, _should_create_final_response)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1810.1">builder.add_conditional_edges(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1811.1">"generate_response"</span></span><span class="koboSpan" id="kobo.1812.1">, _should_continue)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1813.1">builder.add_edge(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1814.1">"vote"</span></span><span class="koboSpan" id="kobo.1815.1">, END)</span></p>
<div aria-label="259" epub:type="pagebreak" id="page37-4" role="doc-pagebreak"/>
<p class="snippet-code"><span class="koboSpan" id="kobo.1816.1">graph = builder.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1817.1">compile</span></span><span class="koboSpan" id="kobo.1818.1">()</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1819.1">from</span></span><span class="koboSpan" id="kobo.1820.1"> IPython.display </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1821.1">import</span></span><span class="koboSpan" id="kobo.1822.1"> Image, display</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1823.1">display(Image(graph.get_graph().draw_mermaid_png()))</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1824.1">This creates our finished agent with a complete execution flow. </span><span class="koboSpan" id="kobo.1824.2">The graph begins with initial planning, proceeds through execution and replanning steps, generates responses for completed paths, and finally selects the best solution through voting. </span><span class="koboSpan" id="kobo.1824.3">We can visualize the flow using the Mermaid diagram </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.1825.1">generator, giving us a clear picture of our agent’s </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.1826.1">decision-making process:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1827.1"><img alt="Figure 6.8: LATS agent" src="../Images/B32363_06_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1828.1">Figure 6.8: LATS agent</span></p>
<div aria-label="260" epub:type="pagebreak" id="page38-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1829.1">We can control the maximum number of super-steps, the maximum number of paths in the tree to be explored (in particular, the maximum number of candidates for the final solution to be generated), and the number of candidates per step. </span><span class="koboSpan" id="kobo.1829.2">Potentially, we could extend our config and control the maximum depth of the tree. </span><span class="koboSpan" id="kobo.1829.3">Let’s run our graph:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1830.1">task = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1831.1">"Write a strategic one-pager of building an AI startup"</span></span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1832.1">result = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1833.1">await</span></span><span class="koboSpan" id="kobo.1834.1"> graph.ainvoke({</span><span class="hljs-string"><span class="koboSpan" id="kobo.1835.1">"task"</span></span><span class="koboSpan" id="kobo.1836.1">: task}, config={</span><span class="hljs-string"><span class="koboSpan" id="kobo.1837.1">"recursion_limit"</span></span><span class="koboSpan" id="kobo.1838.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1839.1">10000</span></span><span class="koboSpan" id="kobo.1840.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1841.1">"configurable"</span></span><span class="koboSpan" id="kobo.1842.1">: {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1843.1">"max_paths"</span></span><span class="koboSpan" id="kobo.1844.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1845.1">10</span></span><span class="koboSpan" id="kobo.1846.1">}})</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1847.1">print</span></span><span class="koboSpan" id="kobo.1848.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1849.1">len</span></span><span class="koboSpan" id="kobo.1850.1">(result[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1851.1">"candidates"</span></span><span class="koboSpan" id="kobo.1852.1">]))</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1853.1">print</span></span><span class="koboSpan" id="kobo.1854.1">(result[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1855.1">"best_candidate"</span></span><span class="koboSpan" id="kobo.1856.1">])</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1857.1">We can also </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.1858.1">visualize the explored tree:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1859.1"><img alt="Figure 6.9: Example of an explored execution tree" src="../Images/B32363_06_09-01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1860.1">Figure 6.9: Example of an explored execution tree</span></p>
<div aria-label="261" epub:type="pagebreak" id="page39-4" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1861.1">We limited the number of candidates, but we can potentially increase it and add additional pruning logic (which </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.1862.1">will prune the leaves that are not promising). </span><span class="koboSpan" id="kobo.1862.2">We can</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.1863.1"> use the same LLM-as-a-judge approach, or use some other heuristic for pruning. </span><span class="koboSpan" id="kobo.1863.2">We can also explore more advanced pruning strategies; we’ll talk about</span><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.1864.1"> one of them in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-163"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.1865.1">Trimming ToT with MCTS</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1866.1">Some of you might</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.1867.1"> remember AlphaGo – the first</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.1868.1"> computer program that </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.1869.1">defeated humans in a game of Go. </span><span class="koboSpan" id="kobo.1869.2">Google DeepMind developed it back in 2015, and it used </span><strong class="keyWord"><span class="koboSpan" id="kobo.1870.1">Monte Carlo Tree Search</span></strong><span class="koboSpan" id="kobo.1871.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1872.1">MCTS</span></strong><span class="koboSpan" id="kobo.1873.1">) as the core decision-making algorithm. </span><span class="koboSpan" id="kobo.1873.2">Here’s a simple idea of how it works. </span><span class="koboSpan" id="kobo.1873.3">Before taking the next move in a game, the algorithm builds a decision tree with potential future moves, with nodes representing your moves and your opponent’s potential responses (this tree expands quickly, as you can imagine). </span><span class="koboSpan" id="kobo.1873.4">To keep the tree from expanding too fast, they used MCTS to search only through the most promising paths that lead to a better state in the game.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1874.1">Now, coming back to the ToT pattern we learned about in the previous chapter. </span><span class="koboSpan" id="kobo.1874.2">Think about the fact that the dimensionality of the ToT we’ve been building in the previous section might grow really fast. </span><span class="koboSpan" id="kobo.1874.3">If, on every step, we’re generating 3 candidates and there are only 5 steps in the workflow, we’ll end up with 3</span><sup class="superscript"><span class="koboSpan" id="kobo.1875.1">5</span></sup><span class="koboSpan" id="kobo.1876.1">=243 steps to evaluate. </span><span class="koboSpan" id="kobo.1876.2">That incurs a lot of cost and time. </span><span class="koboSpan" id="kobo.1876.3">We can trim the dimensionality in different ways, for example, by using MCTS. </span><span class="koboSpan" id="kobo.1876.4">It includes selection and simulation components:</span></p>
<ul>
<li class="b lletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1877.1">Selection</span></strong><span class="koboSpan" id="kobo.1878.1"> helps you pick the next node when analyzing the tree. </span><span class="koboSpan" id="kobo.1878.2">You do that by balancing exploration and exploitation (you estimate the most promising node but add some randomness to this process).</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.1879.1">After you </span><strong class="keyWord"><span class="koboSpan" id="kobo.1880.1">expand</span></strong><span class="koboSpan" id="kobo.1881.1"> the tree by adding a new child to it, if it’s not a terminal node, you need to simulate the consequences of it. </span><span class="koboSpan" id="kobo.1881.2">This might be done just by randomly playing all the next moves until the end, or using more sophisticated simulation approaches. </span><span class="koboSpan" id="kobo.1881.3">After evaluating the child, you backpropagate the results to all the parent nodes by adjusting their probability scores for the next round of selection.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1882.1">We’re not aiming to go into the details and teach you MCTS. </span><span class="koboSpan" id="kobo.1882.2">We only want to demonstrate how you apply already-existing algorithms to agentic workflows to increase their performance. </span><span class="koboSpan" id="kobo.1882.3">One such example is a </span><strong class="keyWord"><span class="koboSpan" id="kobo.1883.1">LATS</span></strong><span class="koboSpan" id="kobo.1884.1"> approach suggested by</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.1885.1"> Andy Zhou and colleagues in June 2024 in their paper </span><em class="italic"><span class="koboSpan" id="kobo.1886.1">Language Agent Tree Search Unifies Reasoning, Acting, and Planning in Language Models</span></em><span class="koboSpan" id="kobo.1887.1">. </span><span class="koboSpan" id="kobo.1887.2">Without going into too much detail (you’re welcome to look at the original paper or the corresponding tutorials), the authors added MCTS on top of ToT, and they demonstrated an increased performance on complex tasks by getting number 1 on the HumanEval benchmark. </span></p>
<div aria-label="262" epub:type="pagebreak" id="page40-3" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1888.1">The key idea was that instead of exploring the whole tree, they use an LLM to evaluate the quality of the solution you get at every step (by looking at the sequence of all the steps on these specific reasoning steps and the outputs you’ve got so far).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1889.1">Now, as we’ve discussed some more advanced architectures that allow us to build better agents, there’s one last component</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.1890.1"> to</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.1891.1"> briefly touch on – memory. </span><span class="koboSpan" id="kobo.1891.2">Helping agents to retain and</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.1892.1"> retrieve relevant information from long-term interactions helps us to d</span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.1893.1">evelop more advanced and helpful agents.</span></p>
<h1 class="heading-1" id="_idParaDest-164"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.1894.1">Agent memory</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1895.1">We discussed memory </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.1896.1">mechanisms in </span><a href="E_Chapter_3.xhtml#_idTextAnchor107"><em class="italic"><span class="koboSpan" id="kobo.1897.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.1898.1">. </span><span class="koboSpan" id="kobo.1898.2">To recap, LangGraph has the notion of short-term memory via the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1899.1">Checkpointer</span></code><span class="koboSpan" id="kobo.1900.1"> mechanism, which saves checkpoints to persistent storage. </span><span class="koboSpan" id="kobo.1900.2">This is the so-called per-thread persistence (remember, we discussed earlier in this chapter that the notion of a thread in LangGraph is similar to a conversation). </span><span class="koboSpan" id="kobo.1900.3">In other words, the agent remembers our interactions within a given session, but it starts from scratch each time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1901.1">As you can imagine, for complex agents, this memory mechanism might be inefficient for two reasons. </span><span class="koboSpan" id="kobo.1901.2">First, you might lose important information about the user. </span><span class="koboSpan" id="kobo.1901.3">Second, during the exploration phase when looking for a solution, an agent might learn something important about the environment that it forgets each time – and it doesn’t look efficient. </span><span class="koboSpan" id="kobo.1901.4">That’s why there’s the concept</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.1902.1"> of </span><strong class="keyWord"><span class="koboSpan" id="kobo.1903.1">long-term memory</span></strong><span class="koboSpan" id="kobo.1904.1">, which helps an agent to accumulate knowledge and gain from historical experiences, and enables its continuous improvement on the long horizon.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1905.1">How to design and use long-term memory in practice is still an open question. </span><span class="koboSpan" id="kobo.1905.2">First, you need to extract useful information (keeping in mind privacy requirements too; more about that in </span><a href="E_Chapter_9.xhtml#_idTextAnchor448"><em class="italic"><span class="koboSpan" id="kobo.1906.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.1907.1">) that you want to store during the runtime and then you need to extract it during the next execution. </span><span class="koboSpan" id="kobo.1907.2">Extraction is close to the retrieval problem we discussed while talking about RAG since we need to extract only knowledge relevant to the given context. </span><span class="koboSpan" id="kobo.1907.3">The last component is the compaction of memory – you probably want to periodically self-reflect on what you have learned, optimize it, and forget irrelevant facts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1908.1">These are key considerations to take into account, but we haven’t seen any great practical implementations of long-term memory for agentic workflows yet. </span><span class="koboSpan" id="kobo.1908.2">In practice, these days people typically use two components – a built-in </span><strong class="keyWord"><span class="koboSpan" id="kobo.1909.1">cache</span></strong><span class="koboSpan" id="kobo.1910.1"> (a mechanism to cache LLMs responses), a built-in </span><strong class="keyWord"><span class="koboSpan" id="kobo.1911.1">store</span></strong><span class="koboSpan" id="kobo.1912.1"> (a persistent key-value store), and a custom cache or database. </span><span class="koboSpan" id="kobo.1912.2">Use the custom option when:</span></p>
<div aria-label="263" epub:type="pagebreak" id="page41-3" role="doc-pagebreak"/>
<ul>
<li class="b lletList"><span class="koboSpan" id="kobo.1913.1">You need additional flexibility for how you organize memory – for example, you would like to keep track of all memory states.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.1914.1">You need advanced read or write access patterns when working with this memory.</span></li>
<li class="b lletList"><span class="koboSpan" id="kobo.1915.1">You need to keep the memory distributed and across multiple workers, and you’d lik</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.1916.1">e to use a database other than PostgreSQL.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-165"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.1917.1">Cache</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1918.1">Caching allows you to</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.1919.1"> save and retrieve key values. </span><span class="koboSpan" id="kobo.1919.2">Imagine you’re working on an enterprise question-answering assistance application, and in the UI, you ask a user whether they like the answer. </span><span class="koboSpan" id="kobo.1919.3">If the answer is positive, or if you have a curated dataset of question-answer pairs for the most important topics, you can store these in a cache. </span><span class="koboSpan" id="kobo.1919.4">When the same (or a similar) question is asked later, the system can quickly return the cached response instead of regenerating it from scratch.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1920.1">LangChain allows you to set a global cache for LLM responses in the following way (after you have initialized the cache, the LLM’s response will be added to the cache, as we’ll see below):</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1921.1">from</span></span><span class="koboSpan" id="kobo.1922.1"> langchain_core.caches </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1923.1">import</span></span><span class="koboSpan" id="kobo.1924.1"> InMemoryCache</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1925.1">from</span></span><span class="koboSpan" id="kobo.1926.1"> langchain_core.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1927.1">globals</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1928.1">import</span></span><span class="koboSpan" id="kobo.1929.1"> set_llm_cache</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1930.1">cache = InMemoryCache()</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1931.1">set_llm_cache(cache)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1932.1">llm = ChatVertexAI(model=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1933.1">"gemini-2.0-flash-001"</span></span><span class="koboSpan" id="kobo.1934.1">, temperature=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1935.1">0.5</span></span><span class="koboSpan" id="kobo.1936.1">)</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1937.1">llm.invoke(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1938.1">"What is the capital of UK?"</span></span><span class="koboSpan" id="kobo.1939.1">)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1940.1">Caching with LangChain works as follows: Each vendor’s implementation of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1941.1">ChatModel</span></code><span class="koboSpan" id="kobo.1942.1"> inherits from the base class, and the base class first tries to look up a value in the cache during generation. </span><span class="koboSpan" id="kobo.1942.2">cache is a global variable that we can expect (of course, only after it has been initialized). </span><span class="koboSpan" id="kobo.1942.3">It caches responses based on the key that consists of a string representation of the prompt and the string representation of the LLM instance (produced by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1943.1">llm._get_llm_string</span></code><span class="koboSpan" id="kobo.1944.1"> method).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1945.1">This means the LLM’s generation parameters (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1946.1">stop_words</span></code><span class="koboSpan" id="kobo.1947.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1948.1">temperature</span></code><span class="koboSpan" id="kobo.1949.1">) are included in the cache key:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1950.1">import</span></span><span class="koboSpan" id="kobo.1951.1"> langchain</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1952.1">print</span></span><span class="koboSpan" id="kobo.1953.1">(langchain.llm_cache._cache)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1954.1">LangChain supports in-memory and SQLite caches out of the box (they form part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1955.1">langchain_core.caches</span></code><span class="koboSpan" id="kobo.1956.1">), and there are also many vendor integrations – available through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1957.1">langchain_community.cache</span></code><span class="koboSpan" id="kobo.1958.1"> subpackage at </span><a href="https://python.langchain.com/api_reference/community/cache.html"><span class="url"><span class="koboSpan" id="kobo.1959.1">https://python.langchain.com/api_reference/community/cache.html</span></span></a><span class="koboSpan" id="kobo.1960.1"> or through specific vendor integrations (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1961.1">langchain-mongodb</span></code><span class="koboSpan" id="kobo.1962.1"> offers cache integration for MongoDB: </span><a href="https://langchain-mongodb.readthedocs.io/en/latest/langchain_mongodb/api_docs.html"><span class="url"><span class="koboSpan" id="kobo.1963.1">https://langchain-mongodb.readthedocs.io/en/latest/langchain_mongodb/api_docs.html</span></span></a><span class="koboSpan" id="kobo.1964.1">).</span></p>
<div aria-label="264" epub:type="pagebreak" id="page42-2" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.1965.1">We recommend introducing a separate LangGraph node instead that hits an actual cache (based on Redis or another database), since it allows you to control whether you’d like to search for similar questions using the embedding mechanism we discussed i</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.1966.1">n </span><a href="E_Chapter_4.xhtml#_idTextAnchor152"><em class="italic"><span class="koboSpan" id="kobo.1967.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.1968.1"> when we were talking about RAG.</span></p>
<h2 class="heading-2" id="_idParaDest-166"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.1969.1">Store</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1970.1">As we have learned</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.1971.1"> before, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">Checkpointer</span></code><span class="koboSpan" id="kobo.1973.1"> mechanism allows you to enhance your workflows with a thread-level persistent memory; by thread-level, we mean a conversation-level persistence. </span><span class="koboSpan" id="kobo.1973.2">Each conversation can be started where it stops, and the workflow executes the previously collected context.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1974.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.1975.1">BaseStore</span></code><span class="koboSpan" id="kobo.1976.1"> is a persistent key-value storage system that organizes your values by namespace (hierarchical tuples of string paths, similar to folders. </span><span class="koboSpan" id="kobo.1976.2">It supports standard operations such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1977.1">put</span></code><span class="koboSpan" id="kobo.1978.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1979.1">delete</span></code><span class="koboSpan" id="kobo.1980.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1981.1">get</span></code><span class="koboSpan" id="kobo.1982.1"> operations, as well as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1983.1">search</span></code><span class="koboSpan" id="kobo.1984.1"> method that implements different semantic search capabilities (typically, based on the embedding mechanism) and accounts for a hierarchical nature of namespaces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1985.1">Let’s initialize a store and add some values to it:</span></p>
<p class="snippet-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1986.1">from</span></span><span class="koboSpan" id="kobo.1987.1"> langgraph.store.memory </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1988.1">import</span></span><span class="koboSpan" id="kobo.1989.1"> InMemoryStore</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1990.1">in_memory_store = InMemoryStore()</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.1991.1">in_memory_store.put(namespace=(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1992.1">"users"</span></span><span class="koboSpan" id="kobo.1993.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1994.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1995.1">user1"</span></span><span class="koboSpan" id="kobo.1996.1">), key=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1997.1">"fact1"</span></span><span class="koboSpan" id="kobo.1998.1">, value={</span><span class="hljs-string"><span class="koboSpan" id="kobo.1999.1">"message1"</span></span><span class="koboSpan" id="kobo.2000.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.2001.1">"My name is John."</span></span><span class="koboSpan" id="kobo.2002.1">})</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.2003.1">in_memory_store.put(namespace=(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2004.1">"users"</span></span><span class="koboSpan" id="kobo.2005.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2006.1">"user1"</span></span><span class="koboSpan" id="kobo.2007.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2008.1">"conv1"</span></span><span class="koboSpan" id="kobo.2009.1">), key=</span><span class="hljs-string"><span class="koboSpan" id="kobo.2010.1">"address"</span></span><span class="koboSpan" id="kobo.2011.1">, value={</span><span class="hljs-string"><span class="koboSpan" id="kobo.2012.1">"message"</span></span><span class="koboSpan" id="kobo.2013.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.2014.1">"I live in Berlin."</span></span><span class="koboSpan" id="kobo.2015.1">})</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2016.1">We can easily query the value:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.2017.1">in_memory_store.get(namespace=(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2018.1">"users"</span></span><span class="koboSpan" id="kobo.2019.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2020.1">"user1"</span></span><span class="koboSpan" id="kobo.2021.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2022.1">"conv1"</span></span><span class="koboSpan" id="kobo.2023.1">), key=</span><span class="hljs-string"><span class="koboSpan" id="kobo.2024.1">"address"</span></span><span class="koboSpan" id="kobo.2025.1">)</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.2026.1">&gt;&gt;  Item(namespace=['users', 'user1'], key='fact1', value={'message1': 'My name is John.'}, created_at='2025-03-18T14:25:23.305405+00:00', updated_at='2025-03-18T14:25:23.305408+00:00')</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2027.1">If we query it by a partial </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.2028.1">path of the namespace, we won’t get any results (we need a full matching namespace). </span><span class="koboSpan" id="kobo.2028.2">The following would return no results:</span></p>
<p class="snippet-code"><span class="koboSpan" id="kobo.2029.1">in_memory_store.get(namespace=(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2030.1">"users"</span></span><span class="koboSpan" id="kobo.2031.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2032.1">"user1"</span></span><span class="koboSpan" id="kobo.2033.1">), key=</span><span class="hljs-string"><span class="koboSpan" id="kobo.2034.1">"conv1"</span></span><span class="koboSpan" id="kobo.2035.1">)</span></p>
<div aria-label="265" epub:type="pagebreak" id="page43-1" role="doc-pagebreak"/>
<p class="normal"><span class="koboSpan" id="kobo.2036.1">On the other side, when using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2037.1">search</span></code><span class="koboSpan" id="kobo.2038.1">, we can use a partial namespace path:</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2039.1">print</span></span><span class="koboSpan" id="kobo.2040.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2041.1">len</span></span><span class="koboSpan" id="kobo.2042.1">(in_memory_store.search((</span><span class="hljs-string"><span class="koboSpan" id="kobo.2043.1">"users"</span></span><span class="koboSpan" id="kobo.2044.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2045.1">"user1"</span></span><span class="koboSpan" id="kobo.2046.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2047.1">"conv1"</span></span><span class="koboSpan" id="kobo.2048.1">), query=</span><span class="hljs-string"><span class="koboSpan" id="kobo.2049.1">"name"</span></span><span class="koboSpan" id="kobo.2050.1">)))</span></p>
<p class="snippet-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2051.1">print</span></span><span class="koboSpan" id="kobo.2052.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2053.1">len</span></span><span class="koboSpan" id="kobo.2054.1">(in_memory_store.search((</span><span class="hljs-string"><span class="koboSpan" id="kobo.2055.1">"users"</span></span><span class="koboSpan" id="kobo.2056.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2057.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2058.1">user1"</span></span><span class="koboSpan" id="kobo.2059.1">), query=</span><span class="hljs-string"><span class="koboSpan" id="kobo.2060.1">"name"</span></span><span class="koboSpan" id="kobo.2061.1">)))</span></p>
<p class="snippet-con"><span class="koboSpan" id="kobo.2062.1">&gt;&gt; 1</span></p>
<p class="snippet-con"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.2063.1">2</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2064.1">As you can see, we were able to retrieve all relevant facts stored in memory by using a partial search.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2065.1">LangGraph has built-in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2066.1">InMemoryStore</span></code><span class="koboSpan" id="kobo.2067.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2068.1">PostgresStore</span></code><span class="koboSpan" id="kobo.2069.1"> implementations. </span><span class="koboSpan" id="kobo.2069.2">Agentic memory mechanisms are still evolving. </span><span class="koboSpan" id="kobo.2069.3">You can build your own implementation from available components, but we </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.2070.1">should see a lot o</span><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.2071.1">f progress in the coming years or even months.</span></p>
<h1 class="heading-1" id="_idParaDest-167"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.2072.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2073.1">In this chapter, we dived deep into advanced applications of LLMs and the architectural patterns that enable them, leveraging LangChain and LangGraph. </span><span class="koboSpan" id="kobo.2073.2">The key takeaway is that effectively building complex AI systems goes beyond simply prompting an LLM; it requires careful architectural design of the workflow itself, tool usage, and giving an LLM partial control over the workflow. </span><span class="koboSpan" id="kobo.2073.3">We also discussed different agentic AI design patterns and how to develop agents that leverage LLMs’ tool-calling abilities to solve complex tasks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2074.1">We explored how LangGraph streaming works and how to control what information is streamed back during execution. </span><span class="koboSpan" id="kobo.2074.2">We discussed the difference between streaming state updates and partial streaming answer tokens, learned about the Command interface as a way to hand off execution to a specific node within or outside the current LangGraph workflow, looked at the LangGraph platform and its main capabilities, and discussed how to implement HIL with LangGraph. </span><span class="koboSpan" id="kobo.2074.3">We discussed how a thread on LangGraph differs from a traditional Pythonic definition (a thread is somewhat similar to a conversation instance), and we learned how to add memory to our workflow per-thread and with cross-thread persistence. </span><span class="koboSpan" id="kobo.2074.4">Finally, we learned how to expand beyond basic LLM applications and build robust, adaptive, and intelligent systems by leveraging the advanced capabilities of LangChain and LangGraph.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2075.1">In the next chapter, we’ll take a look at how generative AI transforms the software engineering industry by as</span><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.2076.1">sisting in code development and data analysis.</span></p>
<div aria-label="266" epub:type="pagebreak" id="page44-1" role="doc-pagebreak"/>
<h1 class="heading-1" id="_idParaDest-168"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.2077.1">Questions</span></h1>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2078.1">Name at least three design patterns to consider when building generative AI agents.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2079.1">Explain the concept of “dynamic retrieval” in the context of agentic RAG.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2080.1">How can cooperation between agents improve the outputs of complex tasks? </span><span class="koboSpan" id="kobo.2080.2">How can you increase the diversity of cooperating agents, and what impact on performance might it have?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2081.1">Describe examples of reaching consensus across multiple agents’ outputs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2082.1">What are the two main ways to organize communication in a multi-agent system with LangGraph?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2083.1">Explain the differences between stream, astream, and astream_events in LangGraph.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2084.1">What is a command in LangGraph, and how is it related to handoffs? </span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2085.1">Explain the concept of a thread in the LangGraph platform. </span><span class="koboSpan" id="kobo.2085.2">How is it different from Pythonic threads?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2086.1">Explain the core idea behind the Tree of Thoughts (ToT) technique. </span><span class="koboSpan" id="kobo.2086.2">How is ToT related to the decomposition pattern?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2087.1">Describe the difference between short-term and long-term memory in the context of agentic systems.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-169"><a id="_idTextAnchor325"/><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.2088.1">Subscribe to our weekly newsletter</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2089.1">Subscribe to AI_Distilled, the go-to newsletter for AI professionals, researchers, and innovators, at </span><a href="E_Chapter_6.xhtml"><span class="url"><span class="koboSpan" id="kobo.2090.1">https://packt.link/Q5UyU</span></span></a><span class="koboSpan" id="kobo.2091.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2092.1"><img alt="" src="../Images/Newsletter_QRcode1.jpg"/></span></p>
</div>
</body></html>