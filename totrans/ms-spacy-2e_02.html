<html><head></head><body>
  <div id="_idContainer022">
   <h1 class="chapter-number" id="_idParaDest-29">
    <a id="_idTextAnchor028">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     2
    </span>
   </h1>
   <h1 id="_idParaDest-30">
    <a id="_idTextAnchor029">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Core Operations with spaCy
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In this chapter, you will learn about core operations with spaCy, such as creating a language pipeline, tokenizing the text, and breaking the text into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      its sentences.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     First, you’ll learn what a language processing pipeline is and also explore the pipeline components.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We’ll continue with general spaCy conventions – important classes and class organization – to help you to better understand spaCy and develop a solid understanding of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      library itself.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     You will then learn about the first pipeline
    </span>
    <a id="_idIndexMarker043">
    </a>
    <span class="koboSpan" id="kobo.8.1">
     component –
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      Tokenizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     .
    </span>
    <span class="koboSpan" id="kobo.10.2">
     You’ll also learn about an important linguistic concept –
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.11.1">
      lemmatization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.12.1">
     – along
    </span>
    <a id="_idIndexMarker044">
    </a>
    <span class="koboSpan" id="kobo.13.1">
     with its
    </span>
    <a id="_idIndexMarker045">
    </a>
    <span class="koboSpan" id="kobo.14.1">
     applications in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.15.1">
      Natural Language Understanding
     </span>
    </strong>
    <span class="koboSpan" id="kobo.16.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.17.1">
      NLU
     </span>
    </strong>
    <span class="koboSpan" id="kobo.18.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.18.2">
     Following
    </span>
    <a id="_idIndexMarker046">
    </a>
    <span class="koboSpan" id="kobo.19.1">
     that, we will cover
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.20.1">
      container
     </span>
    </strong>
    <strong class="bold">
    </strong>
    <strong class="bold">
     <span class="koboSpan" id="kobo.21.1">
      classes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.22.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.23.1">
      spaCy data structures
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     in detail.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     We will finish the chapter
    </span>
    <a id="_idIndexMarker047">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     with useful spaCy features that you’ll use in everyday
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.26.1">
      NLP development.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     We’re going to cover the following main topics in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      this chapter:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.29.1">
      Overview of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.30.1">
       spaCy conventions
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.31.1">
       Introducing tokenization
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.32.1">
       Understanding lemmatization
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.33.1">
      spaCy
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       container objects
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.35.1">
      More spaCy
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.36.1">
       token features
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-31">
    <a id="_idTextAnchor030">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     The code of this chapter can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.40.1">
       https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-32">
    <a id="_idTextAnchor031">
    </a>
    <span class="koboSpan" id="kobo.42.1">
     Overview of spaCy conventions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     Calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.44.1">
      nlp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.45.1">
     on our
    </span>
    <a id="_idIndexMarker048">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     text makes spaCy run a pipeline consisting of many processing steps.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     The first one is the tokenization to produce a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.47.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.48.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     Then, depending on the spaCy components we choose to add to our pipeline, the text can be further processed by components
    </span>
    <a id="_idIndexMarker049">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     such as a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.50.1">
      tagger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.51.1">
     , a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.52.1">
      parser
     </span>
    </strong>
    <span class="koboSpan" id="kobo.53.1">
     , and an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.54.1">
      entity recognizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.55.1">
     .
    </span>
    <span class="koboSpan" id="kobo.55.2">
     We
    </span>
    <a id="_idIndexMarker050">
    </a>
    <span class="koboSpan" id="kobo.56.1">
     call this a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.57.1">
      language processing pipeline
     </span>
    </strong>
    <span class="koboSpan" id="kobo.58.1">
     .
    </span>
    <span class="koboSpan" id="kobo.58.2">
     Each
    </span>
    <a id="_idIndexMarker051">
    </a>
    <span class="koboSpan" id="kobo.59.1">
     pipeline is built using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.60.1">
      components
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     .
    </span>
    <span class="koboSpan" id="kobo.61.2">
     Each
    </span>
    <a id="_idIndexMarker052">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     component returns the processed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.63.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.64.1">
     and then passes it to the next component.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     This process is showcased in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      following diagram:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer017">
     <span class="koboSpan" id="kobo.66.1">
      <img alt="Figure 2.1 – A high-level view of the processing pipeline" src="image/B22441_02_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.67.1">
     Figure 2.1 – A high-level view of the processing pipeline
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     A spaCy pipeline object is created when we load a language model.
    </span>
    <span class="koboSpan" id="kobo.68.2">
     In the following code segment, we load an English model and initialize
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      a pipeline:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.70.1">
      First, we import spaCy and use
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.71.1">
       spacy.load
      </span>
     </strong>
     <span class="koboSpan" id="kobo.72.1">
      to return a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.73.1">
       Language
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.74.1">
       class instance:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.75.1">
import spacy
nlp = spacy.load("en_core_web_md")</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.76.1">
      Now we can use this
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.77.1">
       Language
      </span>
     </strong>
     <span class="koboSpan" id="kobo.78.1">
      instance to get the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.79.1">
        Doc
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.80.1">
       object:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.81.1">
doc = nlp("I went there")</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.83.1">
      Language
     </span>
    </strong>
    <span class="koboSpan" id="kobo.84.1">
     class applies all the pipeline steps to the input sentence behind the scenes.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     After applying
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.85.1">
      nlp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.86.1">
     to the sentence, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.87.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.88.1">
     object contains tokens that are tagged, lemmatized, and marked as entities if the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.89.1">
      token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     is an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.91.1">
      entity
     </span>
    </strong>
    <span class="koboSpan" id="kobo.92.1">
     (we will go into detail about the entities in
    </span>
    <a href="B22441_05.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.93.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.94.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.95.1">
      Extracting Semantic Representations with
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.96.1">
       spaCy Pipelines
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.98.1">
     Each pipeline component has a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.99.1">
      well-defined task:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.100.1">
       Tokenizer (tokenizer)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.101.1">
      : Segment text
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.102.1">
       into tokens
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.103.1">
       Tagger (tagger)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.104.1">
      : Assign
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.105.1">
       part-of-speech tags
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.106.1">
       DependencyParser (parser)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.107.1">
      : Assign
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.108.1">
       dependency labels
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.109.1">
       EntityRecognizer (ner)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.110.1">
      : Detect and label
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.111.1">
       named entities
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.112.1">
     The spaCy language processing pipeline
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.113.1">
      always depends on the statistical model
     </span>
    </em>
    <span class="koboSpan" id="kobo.114.1">
     that powers the component.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     Each component corresponds to a spaCy class.
    </span>
    <span class="koboSpan" id="kobo.114.3">
     spaCy classes have self-explanatory names such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.115.1">
      Language
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.119.1">
      Vocab
     </span>
    </strong>
    <span class="koboSpan" id="kobo.120.1">
     .
    </span>
    <span class="koboSpan" id="kobo.120.2">
     You can see a list of all spaCy pipeline components here:
    </span>
    <a href="https://spacy.io/usage/spacy-101/#architecture-pipeline">
     <span class="koboSpan" id="kobo.121.1">
      https://spacy.io/usage/spacy-101/#architecture-pipeline
     </span>
    </a>
    <span class="koboSpan" id="kobo.122.1">
     .
    </span>
    <span class="koboSpan" id="kobo.122.2">
     There are also data structure classes to represent text and language data.
    </span>
    <span class="koboSpan" id="kobo.122.3">
     We’re already familiar
    </span>
    <a id="_idIndexMarker053">
    </a>
    <span class="koboSpan" id="kobo.123.1">
     with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.124.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     class, but we also have these other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      container classes:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.127.1">
       Doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.128.1">
      : A container object in spaCy that represents the entire processed text, holding the structure of the document and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.129.1">
       its tokens.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.130.1">
       Token
      </span>
     </strong>
     <span class="koboSpan" id="kobo.131.1">
      : A single unit of text within a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.132.1">
       Doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.133.1">
      object, such as a word, punctuation mark,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.134.1">
       or symbol.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.135.1">
       Span
      </span>
     </strong>
     <span class="koboSpan" id="kobo.136.1">
      : A continuous slice of tokens within a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.137.1">
       Doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.138.1">
      object, representing a portion of the text, such as a phrase or
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.139.1">
       named entity.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.140.1">
       Lexeme
      </span>
     </strong>
     <span class="koboSpan" id="kobo.141.1">
      : An object that stores lexical information about a word, such as its base form, spelling, and attributes, independent of its context in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.142.1">
       the text.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.143.1">
     Finally, spaCy provides helper classes for vectors, language vocabulary, and annotations.
    </span>
    <span class="koboSpan" id="kobo.143.2">
     We’ll see the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.144.1">
      Vocab
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     class often in this book.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      Vocab
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     represents a language’s vocabulary.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     The spaCy library’s backbone data structures are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      Vocab
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     .
    </span>
    <span class="koboSpan" id="kobo.151.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     object abstracts the text by owning the sequence of tokens and all their properties.
    </span>
    <span class="koboSpan" id="kobo.153.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      Vocab
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     object provides a centralized set of strings and lexical attributes to all the other classes.
    </span>
    <span class="koboSpan" id="kobo.155.2">
     This way, spaCy avoids storing multiple copies of linguistic data.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.156.1">
       Figure 2
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.157.1">
      .2
     </span>
    </em>
    <span class="koboSpan" id="kobo.158.1">
     shows how all spaCy containers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.159.1">
      work together.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer018">
     <span class="koboSpan" id="kobo.160.1">
      <img alt="Figure 2.2 – spaCy architecture" src="image/B22441_02_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.161.1">
     Figure 2.2 – spaCy architecture
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     spaCy does all the
    </span>
    <a id="_idIndexMarker054">
    </a>
    <span class="koboSpan" id="kobo.163.1">
     text processing operations for us behind the scenes, allowing us to concentrate on our own application’s development.
    </span>
    <span class="koboSpan" id="kobo.163.2">
     Let’s start
    </span>
    <a id="_idIndexMarker055">
    </a>
    <span class="koboSpan" id="kobo.164.1">
     with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.165.1">
       Tokenizer
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      class.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-33">
    <a id="_idTextAnchor032">
    </a>
    <span class="koboSpan" id="kobo.167.1">
     Introducing Tokenization
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.168.1">
     We saw in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.169.1">
       Figure 2
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.170.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.171.1">
     that the
    </span>
    <a id="_idIndexMarker056">
    </a>
    <span class="koboSpan" id="kobo.172.1">
     first step in a text processing pipeline is tokenization.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.173.1">
      Tokenization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     is always the first operation because all the other operations
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      require tokens.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.176.1">
     Tokenization simply means splitting the sentence into its tokens.
    </span>
    <span class="koboSpan" id="kobo.176.2">
     You can think of a token as the smallest meaningful part of a piece of text.
    </span>
    <span class="koboSpan" id="kobo.176.3">
     Tokens can be words, numbers, punctuation, currency symbols, and any other meaningful symbols that are the building blocks of a sentence.
    </span>
    <span class="koboSpan" id="kobo.176.4">
     The following are examples
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      of tokens:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.178.1">
USA
N.Y.
</span><span class="koboSpan" id="kobo.178.2">City
33
3rd
!
</span><span class="koboSpan" id="kobo.178.3">…
?
</span><span class="koboSpan" id="kobo.178.4">'s</span></pre>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     Input to the spaCy tokenizer is Unicode text and the result is a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     The following code shows the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      tokenization process:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.183.1">
      First, we import the library and load the English
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.184.1">
       language model:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.185.1">
import spacy
nlp = spacy.load("en_core_web_md")</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.186.1">
      Next, we apply the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.187.1">
       nlp
      </span>
     </strong>
     <span class="koboSpan" id="kobo.188.1">
      object to a sentence to create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.189.1">
       Doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.190.1">
      object.
     </span>
     <span class="koboSpan" id="kobo.190.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.191.1">
       Doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.192.1">
      object is the container for a sequence of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.193.1">
       Token
      </span>
     </strong>
     <span class="koboSpan" id="kobo.194.1">
      objects.
     </span>
     <span class="koboSpan" id="kobo.194.2">
      We then print the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.195.1">
       token texts:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.196.1">
doc = nlp("I own a ginger cat.")
print([token.text for token in doc])
&gt;&gt;&gt; ['I', 'own', 'a', 'ginger', 'cat', '.']</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.197.1">
       Figure 2
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.198.1">
      .3
     </span>
    </em>
    <span class="koboSpan" id="kobo.199.1">
     shows the tokens we’ve split along with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      their indexes.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer019">
     <span class="koboSpan" id="kobo.201.1">
      <img alt="Figure 2.3 – Tokenization of “I own a ginger cat.”" src="image/B22441_02_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.202.1">
     Figure 2.3 – Tokenization of “I own a ginger cat.”
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.203.1">
     Tokenization can
    </span>
    <a id="_idIndexMarker057">
    </a>
    <span class="koboSpan" id="kobo.204.1">
     be tricky.
    </span>
    <span class="koboSpan" id="kobo.204.2">
     There are many aspects we should pay attention to – punctuation, whitespaces, numbers, and so on.
    </span>
    <span class="koboSpan" id="kobo.204.3">
     Splitting from the whitespaces with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.205.1">
      text.split(" ")
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     might be tempting and looks like it works for the example sentence
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.207.1">
      I own a
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.208.1">
       ginger cat
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.209.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     How about the sentence
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      "It's been a crazy week!!!"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     ?
    </span>
    <span class="koboSpan" id="kobo.212.2">
     If we make a split(
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      " "
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     ), the resulting tokens would be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      It's
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.217.1">
      been
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.219.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.221.1">
      crazy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      week!!!
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     , which is not what you want.
    </span>
    <span class="koboSpan" id="kobo.224.2">
     First of all,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      It's
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     is not one token, it’s two tokens:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      it
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.229.1">
      's
     </span>
    </strong>
    <span class="koboSpan" id="kobo.230.1">
     .
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      week!!!
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     is not a valid token as the punctuation is not split correctly.
    </span>
    <span class="koboSpan" id="kobo.232.2">
     Moreover,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.233.1">
      !!!
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     should be tokenized per symbol and should generate three
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.235.1">
      !
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     ’s.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     This may not look like an important detail, but it is important for sentiment analysis.
    </span>
    <span class="koboSpan" id="kobo.236.3">
     Let’s see what the spaCy tokenizer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      has generated:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.238.1">
import spacy
nlp = spacy.load("en_core_web_md")
doc = nlp("It's been a crazy week!!!")
print([token.text for token in doc])
&gt;&gt;&gt; ['It', "'s", 'been', 'a', 'crazy', 'week', '!', '!', '!']</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.239.1">
       Figure 2
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.240.1">
      .4
     </span>
    </em>
    <span class="koboSpan" id="kobo.241.1">
     shows the tokens and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.242.1">
      their indexes.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer020">
     <span class="koboSpan" id="kobo.243.1">
      <img alt="Figure 2.4 – Tokenization of apostrophe and punctuation marks" src="image/B22441_02_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.244.1">
     Figure 2.4 – Tokenization of apostrophe and punctuation marks
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.245.1">
     How does spaCy know
    </span>
    <a id="_idIndexMarker058">
    </a>
    <span class="koboSpan" id="kobo.246.1">
     where to split the sentence?
    </span>
    <span class="koboSpan" id="kobo.246.2">
     Unlike other parts of the pipeline, the tokenizer doesn’t need a statistical model.
    </span>
    <span class="koboSpan" id="kobo.246.3">
     Tokenization is based on
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.247.1">
      language-specific rules
     </span>
    </em>
    <span class="koboSpan" id="kobo.248.1">
     .
    </span>
    <span class="koboSpan" id="kobo.248.2">
     You can see examples the language specific data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      here:
     </span>
    </span>
    <a href="https://github.com/explosion/spaCy/tree/master/spacy/lang">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.250.1">
       https://github.com/explosion/spaCy/tree/master/spacy/lang
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.252.1">
     Tokenizer exceptions define rules for exceptions, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.253.1">
      it's
     </span>
    </strong>
    <span class="koboSpan" id="kobo.254.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.255.1">
      don't
     </span>
    </strong>
    <span class="koboSpan" id="kobo.256.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.257.1">
      won't
     </span>
    </strong>
    <span class="koboSpan" id="kobo.258.1">
     , abbreviations, and so on.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     If you look at the rules for English (
    </span>
    <a href="https://github.com/explosion/spaCy/blob/master/spacy/lang/en/tokenizer_exceptions.py">
     <span class="koboSpan" id="kobo.259.1">
      https://github.com/explosion/spaCy/blob/master/spacy/lang/en/tokenizer_exceptions.py
     </span>
    </a>
    <span class="koboSpan" id="kobo.260.1">
     ), you will see that rules look like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.261.1">
      {ORTH: "n't", LEMMA: "not"}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     , which describes the splitting rule for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      n't
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.265.1">
      the tokenizer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.266.1">
     The prefixes, suffixes, and infixes mostly describe how to deal with punctuation – for example, we split at a period if it is at the end of the sentence, otherwise, most probably it’s part of an abbreviation such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.267.1">
      N.Y.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.268.1">
     and we shouldn’t touch it.
    </span>
    <span class="koboSpan" id="kobo.268.2">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.269.1">
      ORTH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.270.1">
     means the text and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      LEMMA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     means the base word forms without any inflections.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.273.1">
       Figure 2
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.274.1">
      .5
     </span>
    </em>
    <span class="koboSpan" id="kobo.275.1">
     shows you the execution of the spaCy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.276.1">
      tokenization algorithm:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer021">
     <span class="koboSpan" id="kobo.277.1">
      <img alt="Figure 2.5 – spaCy performing tokenization with exception rules, source:  https://spacy.io/usage/linguistic-features#tokenization" src="image/B22441_02_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.278.1">
     Figure 2.5 – spaCy performing tokenization with exception rules, source:
    </span>
    <a href="https://spacy.io/usage/linguistic-features#tokenization">
     <span class="koboSpan" id="kobo.279.1">
      https://spacy.io/usage/linguistic-features#tokenization
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     Tokenization rules
    </span>
    <a id="_idIndexMarker059">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     depend on the grammatical rules of the individual language.
    </span>
    <span class="koboSpan" id="kobo.281.2">
     Punctuation rules such as splitting periods, commas, or exclamation marks are similar for many languages; however, some rules are specific to the individual language, such as abbreviation words and apostrophe usage.
    </span>
    <span class="koboSpan" id="kobo.281.3">
     spaCy supports each language having its own specific rules by allowing hand-coded data and rules, as each language has its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      own subclass.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.283.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.284.1">
     spaCy provides non-destructive tokenization, which means that we always will be able to recover the original text from the tokens.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     Whitespace and punctuation information is preserved during tokenization, so the input text is preserved as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.285.1">
      it is.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     Every
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.287.1">
      Language
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     object contains a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.289.1">
      Tokenizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.290.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.291.1">
      Tokenizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     class is the class that performs the tokenization.
    </span>
    <span class="koboSpan" id="kobo.292.2">
     You don’t often call this class directly when you create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.293.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.294.1">
     class instance, while the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.295.1">
      Tokenizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.296.1">
     class acts behind the scenes.
    </span>
    <span class="koboSpan" id="kobo.296.2">
     When we want to customize the
    </span>
    <a id="_idIndexMarker060">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     tokenization, we need to interact with this class.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     Let’s see how it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      is done.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-34">
    <a id="_idTextAnchor033">
    </a>
    <span class="koboSpan" id="kobo.299.1">
     Customizing the tokenizer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     When we work
    </span>
    <a id="_idIndexMarker061">
    </a>
    <span class="koboSpan" id="kobo.301.1">
     with a specific domain such as medicine, insurance, or finance, we often come across words, abbreviations, and entities that need special attention.
    </span>
    <span class="koboSpan" id="kobo.301.2">
     Most domains that you’ll process have characteristic words and phrases that need custom tokenization rules.
    </span>
    <span class="koboSpan" id="kobo.301.3">
     Here’s how to add a special case rule to an existing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.302.1">
      Tokenizer
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      class instance:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.304.1">
      First, let’s import spaCy and the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.305.1">
       ORTH
      </span>
     </strong>
     <span class="koboSpan" id="kobo.306.1">
      symbol, which
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.307.1">
       means orthography:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.308.1">
import spacy
from spacy.symbols import ORTH</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.309.1">
      Now we instantiate the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.310.1">
       Language
      </span>
     </strong>
     <span class="koboSpan" id="kobo.311.1">
      object as usual, process the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.312.1">
       Doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.313.1">
      object, and print
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.314.1">
       the tokens:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.315.1">
nlp = spacy.load("en_core_web_sm")
doc = nlp("lemme that")
print([w.text for w in doc])
&gt;&gt;&gt; ['lemme', 'that']</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.316.1">
      Finally, we can define the special case where the word
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.317.1">
       lemme
      </span>
     </strong>
     <span class="koboSpan" id="kobo.318.1">
      should be tokenized as two tokens,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.319.1">
       lem
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.320.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.321.1">
        me
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.322.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.323.1">
special_case = [{ORTH: "lem"}, {ORTH: "me"}]
nlp.tokenizer.add_special_case("lemme", special_case)
print([w.text for w in nlp("lemme that")])
&gt;&gt;&gt; ['lem', 'me', 'that']</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     When defining custom rules, the default punctuation splitting rules will still be applied.
    </span>
    <span class="koboSpan" id="kobo.324.2">
     Even if the special case is surrounded by punctuation, it will still be recognized.
    </span>
    <span class="koboSpan" id="kobo.324.3">
     The tokenizer will handle the punctuation step by step and apply the same process to the remaining substring, as in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      this example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.326.1">
print([w.text for w in nlp("lemme!")])
&gt;&gt;&gt; ['lem', 'me', '!']</span></pre>
   <p>
    <span class="koboSpan" id="kobo.327.1">
     You should modify the tokenizer by adding new rules only if you really need to.
    </span>
    <span class="koboSpan" id="kobo.327.2">
     Trust me, you can get quite unexpected results with custom rules.
    </span>
    <span class="koboSpan" id="kobo.327.3">
     Especially if you have social media text, first feed
    </span>
    <a id="_idIndexMarker062">
    </a>
    <span class="koboSpan" id="kobo.328.1">
     some sentences into the spaCy NLP pipeline and see how the tokenization works out.
    </span>
    <span class="koboSpan" id="kobo.328.2">
     Let’s see how to debug the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      tokenizer component.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-35">
    <a id="_idTextAnchor034">
    </a>
    <span class="koboSpan" id="kobo.330.1">
     Debugging the tokenizer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     spaCy has a tool for
    </span>
    <a id="_idIndexMarker063">
    </a>
    <span class="koboSpan" id="kobo.332.1">
     debugging:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.333.1">
      nlp.tokenizer.explain(sentence)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.334.1">
     .
    </span>
    <span class="koboSpan" id="kobo.334.2">
     It returns tuples (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.335.1">
      tokenizer rule/pattern, token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.336.1">
     ) to help us understand what happened exactly during the tokenization.
    </span>
    <span class="koboSpan" id="kobo.336.2">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.337.1">
      an example:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.338.1">
      Let’s process the text
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.339.1">
       as usual:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.340.1">
import spacy
nlp = spacy.load("en_core_web_sm")
text = "Let's go!"
</span><span class="koboSpan" id="kobo.340.2">doc = nlp(text)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.341.1">
      Now we can ask the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.342.1">
       Tokenizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.343.1">
      class instance of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.344.1">
       Language
      </span>
     </strong>
     <span class="koboSpan" id="kobo.345.1">
      object for an explanation of the tokenization in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.346.1">
       this sentence:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.347.1">
tok_exp = nlp.tokenizer.explain(text)
for t in tok_exp:
    print(t[1], "\t", t[0])
&gt;&gt;&gt; Let  SPECIAL-1
's  SPECIAL-2
go  TOKEN
! </span><span class="koboSpan" id="kobo.347.2">SUFFIX</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      nlp.tokenizer.explain()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     method explained the rules that the tokenizer used one by one.
    </span>
    <span class="koboSpan" id="kobo.350.2">
     After
    </span>
    <a id="_idIndexMarker064">
    </a>
    <span class="koboSpan" id="kobo.351.1">
     splitting a sentence into its tokens, it’s time to split a text into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.352.1">
      its sentences.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-36">
    <a id="_idTextAnchor035">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     Sentence segmentation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.354.1">
     We saw that breaking a
    </span>
    <a id="_idIndexMarker065">
    </a>
    <span class="koboSpan" id="kobo.355.1">
     sentence into its tokens is not a straightforward task at all.
    </span>
    <span class="koboSpan" id="kobo.355.2">
     How about breaking a text into sentences?
    </span>
    <span class="koboSpan" id="kobo.355.3">
     It’s indeed a bit more complicated to mark where a sentence starts and ends due to the same reasons of punctuation, abbreviations, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.356.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.357.1">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.358.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     object’s sentences are available via the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.360.1">
       doc.sents
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      property:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.362.1">
import spacy
nlp = spacy.load("en_core_web_sm")
text = "I flied to N.Y yesterday. </span><span class="koboSpan" id="kobo.362.2">It was around 5 pm."
</span><span class="koboSpan" id="kobo.362.3">doc = nlp(text)
for sent in doc.sents:
    print(sent.text)
&gt;&gt;&gt; I flied to N.Y yesterday.
</span><span class="koboSpan" id="kobo.362.4">It was around 5 pm.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.363.1">
     Determining sentence boundaries is a more complicated task than tokenization.
    </span>
    <span class="koboSpan" id="kobo.363.2">
     As a result, spaCy uses
    </span>
    <a id="_idIndexMarker066">
    </a>
    <span class="koboSpan" id="kobo.364.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.365.1">
      dependency parser
     </span>
    </strong>
    <span class="koboSpan" id="kobo.366.1">
     to perform sentence segmentation.
    </span>
    <span class="koboSpan" id="kobo.366.2">
     This is a unique feature of spaCy – no other library puts such a sophisticated idea into practice.
    </span>
    <span class="koboSpan" id="kobo.366.3">
     The results are very accurate in general, unless you process text of a very specific genre, such as from the conversation domain, or social
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      media text.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.368.1">
     Now that we know how to segment a text into sentences and tokenize the sentences, let’s start with lemmatization, a
    </span>
    <a id="_idIndexMarker067">
    </a>
    <span class="koboSpan" id="kobo.369.1">
     commonly used operation in semantics and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      sentiment analysis.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-37">
    <a id="_idTextAnchor036">
    </a>
    <span class="koboSpan" id="kobo.371.1">
     Understanding lemmatization
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.372.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.373.1">
      lemma
     </span>
    </strong>
    <span class="koboSpan" id="kobo.374.1">
     is the base
    </span>
    <a id="_idIndexMarker068">
    </a>
    <span class="koboSpan" id="kobo.375.1">
     form of a
    </span>
    <a id="_idIndexMarker069">
    </a>
    <span class="koboSpan" id="kobo.376.1">
     token.
    </span>
    <span class="koboSpan" id="kobo.376.2">
     You can think of a lemma as the form in which the token appears in a dictionary.
    </span>
    <span class="koboSpan" id="kobo.376.3">
     For instance, the lemma of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.377.1">
      eating
     </span>
    </em>
    <span class="koboSpan" id="kobo.378.1">
     is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.379.1">
      eat
     </span>
    </em>
    <span class="koboSpan" id="kobo.380.1">
     ; the lemma of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.381.1">
      eats
     </span>
    </em>
    <span class="koboSpan" id="kobo.382.1">
     is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.383.1">
      eat
     </span>
    </em>
    <span class="koboSpan" id="kobo.384.1">
     ; ate similarly maps to eat.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.385.1">
      Lemmatization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     is the process of reducing word forms to their lemmas.
    </span>
    <span class="koboSpan" id="kobo.386.2">
     The following code is a quick example of how to do lemmatization
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      with spaCy:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.388.1">
import spacy
nlp = spacy.load("en_core_web_sm")
doc = nlp("I went there for working and worked for 3 years.")
for token in doc:
    print(token.text, token.lemma_)
&gt;&gt;&gt; I I
went go
there there
for for
working work
and and
worked work
for for
3 3
years year
. </span><span class="koboSpan" id="kobo.388.2">.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     By now, you should be familiar with what the first three lines of the code do.
    </span>
    <span class="koboSpan" id="kobo.389.2">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.390.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.391.1">
     loop, we print each
    </span>
    <a id="_idIndexMarker070">
    </a>
    <span class="koboSpan" id="kobo.392.1">
     token,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      text
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      lemma_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     .
    </span>
    <span class="koboSpan" id="kobo.396.2">
     Let’s see lemmatization in action with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      real-world example.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-38">
    <a id="_idTextAnchor037">
    </a>
    <span class="koboSpan" id="kobo.398.1">
     Lemmatization in NLU
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.399.1">
     Lemmatization is
    </span>
    <a id="_idIndexMarker071">
    </a>
    <span class="koboSpan" id="kobo.400.1">
     an important step in NLU.
    </span>
    <span class="koboSpan" id="kobo.400.2">
     We’ll go over an example in this
    </span>
    <a id="_idIndexMarker072">
    </a>
    <span class="koboSpan" id="kobo.401.1">
     subsection.
    </span>
    <span class="koboSpan" id="kobo.401.2">
     Suppose that you design an NLP pipeline for a ticket booking system.
    </span>
    <span class="koboSpan" id="kobo.401.3">
     Your application processes a customer’s sentence, extracts necessary information from it, and then passes it to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      booking API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.403.1">
     The NLP pipeline wants to extract the form of travel (a flight, bus, or train), the destination city, and the date.
    </span>
    <span class="koboSpan" id="kobo.403.2">
     The first thing the application needs to verify is the means
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.404.1">
      of travel:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.405.1">
       Fly
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.406.1">
       Flight
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.407.1">
       Airway
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.408.1">
       Airplane
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.409.1">
       Plane
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.410.1">
       Bus
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.411.1">
       Railway
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.412.1">
       Train
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     We have this list of keywords, and we want to recognize the means of travel by searching the tokens in the keywords list.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     The most compact way of doing this search is by looking up the token’s
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.414.1">
      lemma
     </span>
    </strong>
    <span class="koboSpan" id="kobo.415.1">
     .
    </span>
    <span class="koboSpan" id="kobo.415.2">
     Consider the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.416.1">
      customer sentences:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.417.1">
List me all flights to Atlanta.
</span><span class="koboSpan" id="kobo.417.2">I need a flight to NY.
</span><span class="koboSpan" id="kobo.417.3">I flew to Atlanta yesterday evening and forgot my baggage.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     Here, we don’t need to include all word forms of the verb
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.419.1">
      fly
     </span>
    </em>
    <span class="koboSpan" id="kobo.420.1">
     (
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.421.1">
      fly
     </span>
    </em>
    <span class="koboSpan" id="kobo.422.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.423.1">
      flying
     </span>
    </em>
    <span class="koboSpan" id="kobo.424.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.425.1">
      flies
     </span>
    </em>
    <span class="koboSpan" id="kobo.426.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.427.1">
      flew
     </span>
    </em>
    <span class="koboSpan" id="kobo.428.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.429.1">
      flown
     </span>
    </em>
    <span class="koboSpan" id="kobo.430.1">
     ) in the keywords list, and similar for the word
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      flight
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     ; we reduced all possible variants to the base forms –
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.433.1">
      fly
     </span>
    </em>
    <span class="koboSpan" id="kobo.434.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.435.1">
      flight
     </span>
    </em>
    <span class="koboSpan" id="kobo.436.1">
     .
    </span>
    <span class="koboSpan" id="kobo.436.2">
     Don’t think of English only; languages such as Portuguese, German, and Finnish have many word forms from a single lemma
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.437.1">
      as well.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.438.1">
     Lemmatization also comes in handy when we want to recognize the destination city.
    </span>
    <span class="koboSpan" id="kobo.438.2">
     There are many nicknames available for global cities, such as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.439.1">
      Angeltown
     </span>
    </em>
    <span class="koboSpan" id="kobo.440.1">
     for
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.441.1">
      Los Angeles
     </span>
    </em>
    <span class="koboSpan" id="kobo.442.1">
     .
    </span>
    <span class="koboSpan" id="kobo.442.2">
     The default tokenizer and lemmatizer won’t know the difference between the official name and the nickname.
    </span>
    <span class="koboSpan" id="kobo.442.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      AttributeRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     component lets us set custom token attributes using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     patterns (we will learn more
    </span>
    <a id="_idIndexMarker073">
    </a>
    <span class="koboSpan" id="kobo.447.1">
     about
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.448.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.449.1">
     in
    </span>
    <a href="B22441_04.xhtml#_idTextAnchor056">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.450.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.451.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     Let’s add a special rule to
    </span>
    <a id="_idIndexMarker074">
    </a>
    <span class="koboSpan" id="kobo.453.1">
     set the
    </span>
    <a id="_idIndexMarker075">
    </a>
    <span class="koboSpan" id="kobo.454.1">
     lemma of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.455.1">
      Angeltown
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     as
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.457.1">
       Los Angeles
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.458.1">
      :
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.459.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.460.1">
       nlp.get_pipe()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.461.1">
      method returns a pipeline component.
     </span>
     <span class="koboSpan" id="kobo.461.2">
      We’ll get the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.462.1">
       AttributeRuler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.463.1">
      component and add the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.464.1">
       special rule:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.465.1">
import spacy
nlp = spacy.load("en_core_web_sm")
nlp.get_pipe("attribute_ruler").add([[{
    "TEXT": "Angeltown"}]], {"LEMMA": "Los Angeles"})</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.466.1">
      Let’s see if this worked by processing the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.467.1">
       doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.468.1">
      and printing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.469.1">
       the lemmas:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.470.1">
doc = nlp("I am flying to Angeltown")
for token in doc:
    print(token.text, token.lemma_)
&gt;&gt;&gt; I I
am be
flying fly
to to
Angeltown Los Angeles</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.471.1">
     Now that we’ve learned
    </span>
    <a id="_idIndexMarker076">
    </a>
    <span class="koboSpan" id="kobo.472.1">
     about the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.473.1">
      tokenizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.474.1">
     and
    </span>
    <a id="_idIndexMarker077">
    </a>
    <span class="koboSpan" id="kobo.475.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.476.1">
      lemmatizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.477.1">
     components (usually the two
    </span>
    <a id="_idIndexMarker078">
    </a>
    <span class="koboSpan" id="kobo.478.1">
     components of a
    </span>
    <a id="_idIndexMarker079">
    </a>
    <span class="koboSpan" id="kobo.479.1">
     processing pipeline), let’s go ahead and learn more about spaCy
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.480.1">
       container objects
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.481.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-39">
    <a id="_idTextAnchor038">
    </a>
    <span class="koboSpan" id="kobo.482.1">
     spaCy container objects
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     At the beginning
    </span>
    <a id="_idIndexMarker080">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     of this chapter, we saw a list of container objects including
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.485.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.486.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.487.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.488.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.489.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.490.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.491.1">
      Lexeme
     </span>
    </strong>
    <span class="koboSpan" id="kobo.492.1">
     .
    </span>
    <span class="koboSpan" id="kobo.492.2">
     In this section, we’ll see the properties of container objects
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.493.1">
      in detail.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.494.1">
     Using container objects, we can access the linguistic properties that spaCy assigns to text.
    </span>
    <span class="koboSpan" id="kobo.494.2">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.495.1">
      container object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.496.1">
     is a logical representation of text units such as a document, a token, or a slice of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.497.1">
      a document.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.498.1">
     Container objects in spaCy follow the natural structure of the text: a document is composed of sentences and sentences are composed of tokens.
    </span>
    <span class="koboSpan" id="kobo.498.2">
     We most widely use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.499.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.500.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.501.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.502.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.503.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.504.1">
     objects in development, which represent a document, a single token, and a phrase, respectively.
    </span>
    <span class="koboSpan" id="kobo.504.2">
     A container can contain other containers – for instance, a document contains tokens
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.505.1">
      and spans.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.506.1">
     Let’s explore each class and its useful properties one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.507.1">
      by one.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-40">
    <a id="_idTextAnchor039">
    </a>
    <span class="koboSpan" id="kobo.508.1">
     Doc
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.509.1">
     We created
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.510.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.511.1">
     objects in
    </span>
    <a id="_idIndexMarker081">
    </a>
    <span class="koboSpan" id="kobo.512.1">
     our code to represent the text, so
    </span>
    <a id="_idIndexMarker082">
    </a>
    <span class="koboSpan" id="kobo.513.1">
     you might have already figured out that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.514.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.515.1">
     represents a text.
    </span>
    <span class="koboSpan" id="kobo.515.2">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.516.1">
      doc.text
     </span>
    </strong>
    <span class="koboSpan" id="kobo.517.1">
     returns a Unicode representation of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.518.1">
      document text:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.519.1">
doc = nlp("I like cats.")
print(doc.text)
&gt;&gt;&gt; I like cats.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.520.1">
     The building block of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.521.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.522.1">
     object is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.523.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.524.1">
     , hence when you iterate a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.525.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.526.1">
     object, you get token objects
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      as items:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.528.1">
for token in doc:
    print(token.text)
&gt;&gt;&gt; I
like
cats
.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.529.1">
     The same logic applies
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.530.1">
      to indexing:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.531.1">
print(doc[1])
&gt;&gt;&gt; like</span></pre>
   <p>
    <span class="koboSpan" id="kobo.532.1">
     The length of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.533.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.534.1">
     object is the number of tokens
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.535.1">
      it includes:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.536.1">
print(len(doc))
&gt;&gt;&gt; 4</span></pre>
   <p>
    <span class="koboSpan" id="kobo.537.1">
     As for the text’s sentences,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      doc.sents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     returns an iterator to the list of sentences.
    </span>
    <span class="koboSpan" id="kobo.539.2">
     Each sentence is a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.540.1">
       Span
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.541.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.542.1">
doc = nlp("This is a sentence. </span><span class="koboSpan" id="kobo.542.2">This is the second sentence")
sentences = list(doc.sents)
print(sentences)
&gt;&gt;&gt; [This is a sentence., This is the second sentence]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.543.1">
     The named
    </span>
    <a id="_idIndexMarker083">
    </a>
    <span class="koboSpan" id="kobo.544.1">
     entities in the text are provided by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.545.1">
      doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.546.1">
     .
    </span>
    <span class="koboSpan" id="kobo.546.2">
     The
    </span>
    <a id="_idIndexMarker084">
    </a>
    <span class="koboSpan" id="kobo.547.1">
     result is a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.549.2">
     We’ll look at named entities in detail later in the book – for now, think of them as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      proper nouns:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.551.1">
doc = nlp("I flied to New York with Ashley.")
print(doc.ents)
&gt;&gt;&gt; (New York, Ashley)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     Another syntactic property is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.553.1">
      doc.noun_chunks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.554.1">
     .
    </span>
    <span class="koboSpan" id="kobo.554.2">
     It yields the noun phrases found in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      the text:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.556.1">
doc = nlp("Sweet brown fox jumped over the fence.")
print(list(doc.noun_chunks))
&gt;&gt;&gt; [Sweet brown fox, the fence]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     The property
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      doc.lang_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     returns the language of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.560.1">
      doc created:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.561.1">
print(doc.lang_)
&gt;&gt;&gt; en</span></pre>
   <p>
    <span class="koboSpan" id="kobo.562.1">
     A useful method for
    </span>
    <a id="_idIndexMarker085">
    </a>
    <span class="koboSpan" id="kobo.563.1">
     serialization is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.564.1">
      doc.to_json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.565.1">
     .
    </span>
    <span class="koboSpan" id="kobo.565.2">
     This is
    </span>
    <a id="_idIndexMarker086">
    </a>
    <span class="koboSpan" id="kobo.566.1">
     how to convert a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.567.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.568.1">
     object
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.569.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.570.1">
       JSON
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.571.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.572.1">
from pprint import pprint
doc = nlp("Hi")
json_doc = doc.to_json()
pprint(json_doc)
&gt;&gt;&gt; {'ents': [],
'sents': [{'end': 2, 'start': 0}],
'text': 'Hi',
'tokens': [{'dep': 'ROOT',
            'end': 2,
            'head': 0,
            'id': 0,
            'lemma': 'hi',
            'morph': '',
            'pos': 'INTJ',
            'start': 0,
            'tag': 'UH'}]}</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.573.1">
     Pro tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.574.1">
     You might have noticed that we call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.575.1">
      doc.lang_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.576.1">
     , not
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.577.1">
      doc.lang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.578.1">
     .
    </span>
    <span class="koboSpan" id="kobo.578.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.579.1">
      doc.lang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.580.1">
     call returns the language ID, whereas
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.581.1">
      doc.lang_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.582.1">
     returns the Unicode string of the language, that is, the name of the language.
    </span>
    <span class="koboSpan" id="kobo.582.2">
     You can see the same convention with token features in the following:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.583.1">
      token.lemma_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.584.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.585.1">
      token.tag_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.586.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.587.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.588.1">
       token.pos_
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.589.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.590.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.591.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.592.1">
     object has very useful properties with which you can understand a sentence’s syntactic
    </span>
    <a id="_idIndexMarker087">
    </a>
    <span class="koboSpan" id="kobo.593.1">
     properties
    </span>
    <a id="_idIndexMarker088">
    </a>
    <span class="koboSpan" id="kobo.594.1">
     and use them in your own applications.
    </span>
    <span class="koboSpan" id="kobo.594.2">
     Let’s move on to the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.595.1">
      Token object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     and see what
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.597.1">
      it offers.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-41">
    <a id="_idTextAnchor040">
    </a>
    <span class="koboSpan" id="kobo.598.1">
     Token
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.599.1">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.600.1">
      token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.601.1">
     object represents
    </span>
    <a id="_idIndexMarker089">
    </a>
    <span class="koboSpan" id="kobo.602.1">
     a word.
    </span>
    <span class="koboSpan" id="kobo.602.2">
     Token objects are the
    </span>
    <a id="_idIndexMarker090">
    </a>
    <span class="koboSpan" id="kobo.603.1">
     building blocks of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.604.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.606.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.607.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.607.2">
     In this section, we will cover the following properties of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.608.1">
       Token
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.609.1">
      class:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.610.1">
        token.text
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.611.1">
        token.text_with_ws
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.612.1">
        token.i
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.613.1">
        token.idx
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.614.1">
        token.doc
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.615.1">
        token.sent
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.616.1">
        token.is_sent_start
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.617.1">
        token.ent_type
       </span>
      </strong>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.618.1">
     We usually don’t construct an object of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.619.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     class directly, rather we construct a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.621.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.622.1">
     object and then access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.623.1">
      its tokens:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.624.1">
doc = nlp("Hello Madam!")
print(doc[0])
&gt;&gt;&gt; Hello</span></pre>
   <p>
    <span class="koboSpan" id="kobo.625.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.626.1">
      token.text
     </span>
    </strong>
    <span class="koboSpan" id="kobo.627.1">
     property is similar to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.628.1">
      doc.text
     </span>
    </strong>
    <span class="koboSpan" id="kobo.629.1">
     and provides the underlying Unicode string.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.630.1">
      token.text_with_ws
     </span>
    </strong>
    <span class="koboSpan" id="kobo.631.1">
     is a similar property.
    </span>
    <span class="koboSpan" id="kobo.631.2">
     It provides the text with a trailing whitespace if it’s present in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.632.1">
       doc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.634.1">
print(doc[0].text_with_ws)
print(doc[2].text_with_ws)
&gt;&gt;&gt; 'Hello '
'!'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.635.1">
     Finding the length of a token is similar to finding the length of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.636.1">
      Python string:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.637.1">
print(len(doc[0]))
&gt;&gt;&gt; 5</span></pre>
   <p>
    <span class="koboSpan" id="kobo.638.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.639.1">
      token.i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.640.1">
     property gives the index of the token in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.641.1">
       doc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.642.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.643.1">
token = doc[2]
print(token.i)
&gt;&gt;&gt; 2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.644.1">
     The token’s
    </span>
    <a id="_idIndexMarker091">
    </a>
    <span class="koboSpan" id="kobo.645.1">
     character
    </span>
    <a id="_idIndexMarker092">
    </a>
    <span class="koboSpan" id="kobo.646.1">
     offset (the character position) in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.647.1">
      doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.648.1">
     object is provided by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.649.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.650.1">
       token.idx
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.652.1">
print(doc[0].idx)
print(doc[1].idx)
&gt;&gt;&gt; 0
6</span></pre>
   <p>
    <span class="koboSpan" id="kobo.653.1">
     Another cool property of tokens is that we can also access the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.654.1">
      doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.655.1">
     object that created the token
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.656.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.657.1">
token = doc[0]
print(token.doc)
&gt;&gt;&gt; Hello Madam!</span></pre>
   <p>
    <span class="koboSpan" id="kobo.658.1">
     This also works for getting the sentence that the token
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.659.1">
      belongs to:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.660.1">
token = doc[1]
print(token.sent)
&gt;&gt;&gt; Hello Madam!</span></pre>
   <p>
    <span class="koboSpan" id="kobo.661.1">
     Another useful property is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.662.1">
      token.is_sent_start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.663.1">
     ; it returns a Boolean indicating whether the token starts
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.664.1">
      a sentence:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.665.1">
doc = nlp("He entered the room. </span><span class="koboSpan" id="kobo.665.2">Then he nodded.")
print(doc[0].is_sent_start)
&gt;&gt;&gt; True
print(doc[5].is_sent_start)
&gt;&gt;&gt; True
print(doc[6].is_sent_start)
&gt;&gt;&gt; False</span></pre>
   <p>
    <span class="koboSpan" id="kobo.666.1">
     These are the basic properties of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.667.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.668.1">
     object that you’ll use every day.
    </span>
    <span class="koboSpan" id="kobo.668.2">
     There is another set of
    </span>
    <a id="_idIndexMarker093">
    </a>
    <span class="koboSpan" id="kobo.669.1">
     properties that are more related to syntax
    </span>
    <a id="_idIndexMarker094">
    </a>
    <span class="koboSpan" id="kobo.670.1">
     and semantics.
    </span>
    <span class="koboSpan" id="kobo.670.2">
     We already saw how to calculate the token lemma in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.671.1">
      previous section:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.672.1">
doc = nlp("I went there.")
print(doc[1].lemma_)
&gt;&gt;&gt; go</span></pre>
   <p>
    <span class="koboSpan" id="kobo.673.1">
     You already learned that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.674.1">
      doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.675.1">
     property gives the named entities of the document.
    </span>
    <span class="koboSpan" id="kobo.675.2">
     If you want to learn what sort of entity the token is,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.676.1">
      use
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.677.1">
       token.ent_type_
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.678.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.679.1">
doc = nlp("The Brazilian president visited Beijing")
print(doc.ents)
&gt;&gt;&gt; (Brazilian, Beijing)
print(doc[1].ent_type_, spacy.explain(doc[1].ent_type_))
&gt;&gt;&gt; NORP Nationalities or religious or political groups</span></pre>
   <p>
    <span class="koboSpan" id="kobo.680.1">
     Two syntactic features related to POS tagging are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.681.1">
      token.pos_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.682.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.683.1">
      token.tag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.684.1">
     .
    </span>
    <span class="koboSpan" id="kobo.684.2">
     We’ll learn what they are and how to use them in the next chapter.
    </span>
    <span class="koboSpan" id="kobo.684.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.685.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.686.1">
     object has a rich set of features, enabling us to process the text from head to toe.
    </span>
    <span class="koboSpan" id="kobo.686.2">
     Let’s move on to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.687.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.688.1">
     object
    </span>
    <a id="_idIndexMarker095">
    </a>
    <span class="koboSpan" id="kobo.689.1">
     and
    </span>
    <a id="_idIndexMarker096">
    </a>
    <span class="koboSpan" id="kobo.690.1">
     see what it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.691.1">
      offers us.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-42">
    <a id="_idTextAnchor041">
    </a>
    <span class="koboSpan" id="kobo.692.1">
     Span
    </span>
   </h2>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.693.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.694.1">
     objects
    </span>
    <a id="_idIndexMarker097">
    </a>
    <span class="koboSpan" id="kobo.695.1">
     represent phrases or segments
    </span>
    <a id="_idIndexMarker098">
    </a>
    <span class="koboSpan" id="kobo.696.1">
     of the text.
    </span>
    <span class="koboSpan" id="kobo.696.2">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.697.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.698.1">
     object must be a contiguous sequence of tokens.
    </span>
    <span class="koboSpan" id="kobo.698.2">
     We usually don’t initialize
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.699.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.700.1">
     objects, rather we slice a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.701.1">
       Doc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.702.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.703.1">
import spacy
nlp = spacy.load("en_core_web_sm")
doc = nlp("All my moves are coldly calculated.")
print(doc[4:6])
&gt;&gt;&gt; coldly calculated</span></pre>
   <p>
    <span class="koboSpan" id="kobo.704.1">
     Trying to slice an invalid index will raise an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.705.1">
      IndexError
     </span>
    </strong>
    <span class="koboSpan" id="kobo.706.1">
     .
    </span>
    <span class="koboSpan" id="kobo.706.2">
     Most indexing and slicing rules of Python strings are applicable to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.707.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.708.1">
     slicing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.709.1">
      as well:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.710.1">
doc = nlp("All my moves are coldly calculated.")
print(doc[5:]) # end index empty means rest of the string calculated.
</span><span class="koboSpan" id="kobo.710.2">print(doc[4:-1]) # minus indexes are supported
&gt;&gt;&gt; calculated.
</span><span class="koboSpan" id="kobo.710.3">coldly calculated</span></pre>
   <p>
    <span class="koboSpan" id="kobo.711.1">
     There is one more way to create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.712.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.713.1">
     object – we can make a character-level slice of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.714.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.715.1">
     object with
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.716.1">
       char_span([start_idx, end_idx])
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.717.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.718.1">
doc = nlp("Recife has a thousand charms, it's a little piece of Brazil.")
print(doc.char_span(37, 59))
&gt;&gt;&gt; little piece of Brazil</span></pre>
   <p>
    <span class="koboSpan" id="kobo.719.1">
     The building blocks of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.720.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.721.1">
     object are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.722.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.723.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.723.2">
     If you iterate over a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.724.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.725.1">
     object, you get
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.726.1">
       Token
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.727.1">
      objects:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.728.1">
doc = nlp("You went there after you saw me")
span = doc[2:4]
for token in span:
    print(token)
&gt;&gt;&gt; there
after</span></pre>
   <p>
    <span class="koboSpan" id="kobo.729.1">
     You can think of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.730.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.731.1">
     object as a junior
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.732.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.733.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.733.2">
     Hence, most of the features of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.734.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.735.1">
     are applicable to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.736.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.737.1">
     as well.
    </span>
    <span class="koboSpan" id="kobo.737.2">
     For instance,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.738.1">
      len
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.739.1">
      is identical:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.740.1">
doc = nlp("Hi Lorena!!")
span = doc[:2]
len(span)
&gt;&gt;&gt; 2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.741.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     object
    </span>
    <a id="_idIndexMarker099">
    </a>
    <span class="koboSpan" id="kobo.744.1">
     also supports indexing.
    </span>
    <span class="koboSpan" id="kobo.744.2">
     The result of
    </span>
    <a id="_idIndexMarker100">
    </a>
    <span class="koboSpan" id="kobo.745.1">
     slicing a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.746.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.747.1">
     object is another
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.748.1">
       Span
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.749.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.750.1">
doc = nlp("You went there after you saw me")
span = doc[2:6]
print(span)
&gt;&gt;&gt; there after you saw
print(span[1:3])
&gt;&gt;&gt; after you</span></pre>
   <p>
    <span class="koboSpan" id="kobo.751.1">
     Just like a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.752.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.753.1">
     knows the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.754.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.755.1">
     object it’s created from,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     also knows the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.758.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.759.1">
     object it’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.760.1">
      created from:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.761.1">
doc = nlp("You went there after you saw me")
span = doc[2:6]
print(span.doc)
&gt;&gt;&gt; You went there after you saw me
print(span.sent)
&gt;&gt;&gt; You went there after you saw me</span></pre>
   <p>
    <span class="koboSpan" id="kobo.762.1">
     We can also locate the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.763.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.764.1">
     object in the original
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.765.1">
       Doc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.766.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.767.1">
doc = nlp("You went there after you saw me")
span = doc[2:6]
print(span.start) # index of the first token of the Span
&gt;&gt;&gt; 2
print(span.end)
&gt;&gt;&gt; 6
print(span.start_char) # start offset of the Span at character level
&gt;&gt;&gt; 9
print(span.end_char)
&gt;&gt;&gt; 28</span></pre>
   <p>
    <span class="koboSpan" id="kobo.768.1">
     If you want a brand-new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.769.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.770.1">
     object, you can call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.771.1">
      span.as_doc()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.772.1">
     .
    </span>
    <span class="koboSpan" id="kobo.772.2">
     It copies the data into a new
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.773.1">
       Doc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.774.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.775.1">
doc = nlp("You went there after you saw me")
span = doc[2:6]
small_doc = span.as_doc()
print(type(small_doc))
&gt;&gt;&gt; &lt;class 'spacy.tokens.doc.Doc'&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.776.1">
     The
    </span>
    <a id="_idIndexMarker101">
    </a>
    <span class="koboSpan" id="kobo.777.1">
     properties
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.778.1">
      span.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.779.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.780.1">
      span.sent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.781.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.782.1">
      span.text
     </span>
    </strong>
    <span class="koboSpan" id="kobo.783.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.784.1">
      span.text_with_ws
     </span>
    </strong>
    <span class="koboSpan" id="kobo.785.1">
     are
    </span>
    <a id="_idIndexMarker102">
    </a>
    <span class="koboSpan" id="kobo.786.1">
     similar to their corresponding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.787.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.788.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.789.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.790.1">
     methods.
    </span>
    <span class="koboSpan" id="kobo.790.2">
     We’ll now go through a few more features and methods for more detailed text analysis in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.791.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-43">
    <a id="_idTextAnchor042">
    </a>
    <span class="koboSpan" id="kobo.792.1">
     More spaCy Token features
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.793.1">
     Most NLP development
    </span>
    <a id="_idIndexMarker103">
    </a>
    <span class="koboSpan" id="kobo.794.1">
     is token and span oriented; that is, it processes tags, dependency relations, tokens themselves, and phrases.
    </span>
    <span class="koboSpan" id="kobo.794.2">
     We apply transformations like eliminating small words and words without much meaning, processing URLs taking into account the protocol and subdomain parts, and so on.
    </span>
    <span class="koboSpan" id="kobo.794.3">
     These actions sometimes depend on the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.795.1">
      token shape
     </span>
    </em>
    <span class="koboSpan" id="kobo.796.1">
     (for example, if the token is a short word or if the token looks like a URL string) or more semantical features (such as the token is an article, or the token is a conjunction).
    </span>
    <span class="koboSpan" id="kobo.796.2">
     In this section, we will see these features of tokens with some examples.
    </span>
    <span class="koboSpan" id="kobo.796.3">
     We’ll start with features related to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.797.1">
      token shape:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.798.1">
doc = nlp("Hello, hi!")
print(doc[0].lower_)
&gt;&gt;&gt; hello</span></pre>
   <p>
    <span class="koboSpan" id="kobo.799.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.800.1">
      token.lower_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.801.1">
     feature turns the token in lowercase.
    </span>
    <span class="koboSpan" id="kobo.801.2">
     The return value is a Unicode string and this feature is equivalent
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.802.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.803.1">
       token.text.lower()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.804.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.805.1">
     The features
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.806.1">
      is_lower
     </span>
    </strong>
    <span class="koboSpan" id="kobo.807.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.808.1">
      is_upper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.809.1">
     are similar to their Python string method counterparts,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.810.1">
      islower()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.811.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.812.1">
      isupper()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.813.1">
     .
    </span>
    <span class="koboSpan" id="kobo.813.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.814.1">
      is_lower
     </span>
    </strong>
    <span class="koboSpan" id="kobo.815.1">
     feature returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.816.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.817.1">
     if all the characters are lowercase, while
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.818.1">
      is_upper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.819.1">
     does the same
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.820.1">
      with uppercase.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.821.1">
     The feature
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.822.1">
      is_alpha
     </span>
    </strong>
    <span class="koboSpan" id="kobo.823.1">
     returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.824.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.825.1">
     if all the characters of the token are alphabetic letters.
    </span>
    <span class="koboSpan" id="kobo.825.2">
     Examples of nonalphabetic characters are numbers, punctuation,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.826.1">
      and whitespace:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.827.1">
doc = nlp("Cat and Cat123")
print(doc[0].is_alpha)
&gt;&gt;&gt; True
print(doc[2].is_alpha)
&gt;&gt;&gt;False</span></pre>
   <p>
    <span class="koboSpan" id="kobo.828.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.829.1">
      is_ascii
     </span>
    </strong>
    <span class="koboSpan" id="kobo.830.1">
     feature returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.831.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.832.1">
     if all the characters of the token are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.833.1">
      ASCII characters:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.834.1">
doc = nlp("UR7 and Várzea")
print(doc[0].is_ascii)
&gt;&gt;&gt;True
print(doc[2].is_ascii)
&gt;&gt;&gt;False</span></pre>
   <p>
    <span class="koboSpan" id="kobo.835.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.836.1">
      is_digit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.837.1">
     feature returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.838.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.839.1">
     if all the characters of the token
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.840.1">
      are numbers:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.841.1">
doc = nlp("Cat Cat123 123")
print(doc[0].is_digit)
&gt;&gt;&gt;False
print(doc[1].is_digit)
&gt;&gt;&gt;False
print(doc[2].is_digit)
&gt;&gt;&gt; True</span></pre>
   <p>
    <span class="koboSpan" id="kobo.842.1">
     The feature
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.843.1">
      is_punct
     </span>
    </strong>
    <span class="koboSpan" id="kobo.844.1">
     returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.845.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.846.1">
     if the
    </span>
    <a id="_idIndexMarker104">
    </a>
    <span class="koboSpan" id="kobo.847.1">
     token is a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.848.1">
      punctuation mark:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.849.1">
doc = nlp("You, him and Sally")
print(doc[1])
&gt;&gt;&gt;,
print(doc[1].is_punct)
&gt;&gt;&gt;True</span></pre>
   <p>
    <span class="koboSpan" id="kobo.850.1">
     The features
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.851.1">
      is_left_punct
     </span>
    </strong>
    <span class="koboSpan" id="kobo.852.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.853.1">
      is_right_punct
     </span>
    </strong>
    <span class="koboSpan" id="kobo.854.1">
     return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.855.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.856.1">
     if the token is a left punctuation mark or right punctuation mark, respectively.
    </span>
    <span class="koboSpan" id="kobo.856.2">
     A right punctuation mark can be any mark that closes a left punctuation mark, such as right brackets,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.857.1">
      &gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.858.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.859.1">
      »
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     .
    </span>
    <span class="koboSpan" id="kobo.860.2">
     Left punctuation marks are similar, with the left brackets
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.861.1">
      &lt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.862.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.863.1">
      «
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.865.1">
      some examples:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.866.1">
doc = nlp("( [ He said yes. </span><span class="koboSpan" id="kobo.866.2">] )")
print(doc[0])
&gt;&gt;&gt; (
print(doc[0].is_left_punct)
&gt;&gt;&gt;True
print(doc[-2])
&gt;&gt;&gt;]
print(doc[-2].is_right_punct)
&gt;&gt;&gt;True</span></pre>
   <p>
    <span class="koboSpan" id="kobo.867.1">
     The methods
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.868.1">
      like_url
     </span>
    </strong>
    <span class="koboSpan" id="kobo.869.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.870.1">
      like_num
     </span>
    </strong>
    <span class="koboSpan" id="kobo.871.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.872.1">
      like_email
     </span>
    </strong>
    <span class="koboSpan" id="kobo.873.1">
     capture information about the token shape and return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.874.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.875.1">
     if the token looks like a URL, a number, or an email, respectively.
    </span>
    <span class="koboSpan" id="kobo.875.2">
     These
    </span>
    <a id="_idIndexMarker105">
    </a>
    <span class="koboSpan" id="kobo.876.1">
     methods are very handy when we want to process social media text and scraped
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.877.1">
      web pages:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.878.1">
doc = nlp("I emailed you at least 100 times")
print(doc[-2])
&gt;&gt;&gt;100
print(doc[-2].like_num)
&gt;&gt;&gt;True
doc = nlp("I emailed you at least hundred times")
print(doc[-2])
&gt;&gt;&gt;hundred
print(doc[-2].like_num)
&gt;&gt;&gt;True
doc = nlp("His email is hello@hello.com and his website is https://nicewebsite.com")
print(doc[3])
&gt;&gt;&gt;hello@hellp.com
print(doc[3].like_email)
&gt;&gt;&gt;True
print(doc[8])
&gt;&gt;&gt;https://nicewebsite.com
print(doc[8].like_url)
&gt;&gt;&gt;True</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.879.1">
      token.shape_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.880.1">
     is an unusual feature – there is nothing similar in other NLP libraries.
    </span>
    <span class="koboSpan" id="kobo.880.2">
     It returns a string that shows a token’s orthographic features.
    </span>
    <span class="koboSpan" id="kobo.880.3">
     Numbers are replaced with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.881.1">
      d
     </span>
    </strong>
    <span class="koboSpan" id="kobo.882.1">
     , uppercase letters are replaced with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.883.1">
      X
     </span>
    </strong>
    <span class="koboSpan" id="kobo.884.1">
     , and lowercase letters are replaced with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.885.1">
      x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.886.1">
     .
    </span>
    <span class="koboSpan" id="kobo.886.2">
     You can use the result string as a feature in your machine learning algorithms, and token shapes can be correlated to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.887.1">
      text sentiment:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.888.1">
doc = nlp("Girl called Kathy has a nickname Cat123.")
for token in doc:
    print(token.text, token.shape_)
&gt;&gt;&gt;Girl Xxxx
called xxxx
Kathy Xxxxx
has xxx
a x
nickname xxxx
Cat123 Xxxddd
. </span><span class="koboSpan" id="kobo.888.2">.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.889.1">
     The feature
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.890.1">
      is_stop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     is frequently
    </span>
    <a id="_idIndexMarker106">
    </a>
    <span class="koboSpan" id="kobo.892.1">
     used by machine learning algorithms.
    </span>
    <span class="koboSpan" id="kobo.892.2">
     Often, we filter words that do not carry much meaning, such as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.893.1">
      the
     </span>
    </em>
    <span class="koboSpan" id="kobo.894.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.895.1">
      a
     </span>
    </em>
    <span class="koboSpan" id="kobo.896.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.897.1">
      an
     </span>
    </em>
    <span class="koboSpan" id="kobo.898.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.899.1">
      and
     </span>
    </em>
    <span class="koboSpan" id="kobo.900.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.901.1">
      just
     </span>
    </em>
    <span class="koboSpan" id="kobo.902.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.903.1">
      with
     </span>
    </em>
    <span class="koboSpan" id="kobo.904.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.904.2">
     Such words are called stop words.
    </span>
    <span class="koboSpan" id="kobo.904.3">
     Each language has its own stop word list, and you can access English stop words
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.905.1">
      at
     </span>
    </span>
    <a href="https://github.com/explosion/spaCy/blob/master/spacy/lang/en/stop_words.py">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.906.1">
       https://github.com/explosion/spaCy/blob/master/spacy/lang/en/stop_words.py
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.907.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.908.1">
doc = nlp("One step forward, and you're no longer in the same place.")
for token in doc:
    print(token, token.is_stop)
&gt;&gt;&gt;One True
step False
forward False
, False
and True
you True
're True
no True
longer False
in True
the True
same True
place False
. </span><span class="koboSpan" id="kobo.908.2">False</span></pre>
   <p>
    <span class="koboSpan" id="kobo.909.1">
     We’re finally done with some of spaCy’s syntactic, semantic, and orthographic features.
    </span>
    <span class="koboSpan" id="kobo.909.2">
     Many of those methods
    </span>
    <a id="_idIndexMarker107">
    </a>
    <span class="koboSpan" id="kobo.910.1">
     focused on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.911.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.912.1">
     object as a token is the syntactic unit of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.913.1">
      a text.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-44">
    <a id="_idTextAnchor043">
    </a>
    <span class="koboSpan" id="kobo.914.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.915.1">
     This chapter gave you a comprehensive picture of spaCy library classes and methods.
    </span>
    <span class="koboSpan" id="kobo.915.2">
     We took a deep dive into language processing pipelines and learned about pipeline components.
    </span>
    <span class="koboSpan" id="kobo.915.3">
     We also covered a basic yet important syntactic task: tokenization.
    </span>
    <span class="koboSpan" id="kobo.915.4">
     We continued with the linguistic concept of lemmatization and you learned about a real-world application of this spaCy feature.
    </span>
    <span class="koboSpan" id="kobo.915.5">
     We explored spaCy container classes in detail and finalized the chapter by looking at precise and useful spaCy features.
    </span>
    <span class="koboSpan" id="kobo.915.6">
     In the next chapter, we will dive into spaCy’s full linguistic power.
    </span>
    <span class="koboSpan" id="kobo.915.7">
     You’ll discover linguistic features including spaCy’s most used features: the POS tagger, dependency parser, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.916.1">
      named entities.
     </span>
    </span>
   </p>
  </div>
 

  <div class="Content" epub:type="part" id="_idContainer023">
   <h1 id="_idParaDest-45" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor044">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 2: Advanced Linguistic and Semantic Analysis
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.2.1">
     Building on the fundamentals, this section explores advanced techniques for analyzing and extracting information from text using spaCy’s linguistic and rule-based tools.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     You'll learn how to perform sophisticated parsing and matching and even develop your own custom components to handle
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.3.1">
      complex tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.4.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.5.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B22441_03.xhtml#_idTextAnchor045">
      <em class="italic">
       <span class="koboSpan" id="kobo.6.1">
        Chapter 3
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.7.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.8.1">
       Extracting Linguistic Features
      </span>
     </em>
    </li>
    <li>
     <a href="B22441_04.xhtml#_idTextAnchor056">
      <em class="italic">
       <span class="koboSpan" id="kobo.9.1">
        Chapter 4
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.10.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.11.1">
       Mastering Rule-Based Matching
      </span>
     </em>
    </li>
    <li>
     <a href="B22441_05.xhtml#_idTextAnchor074">
      <em class="italic">
       <span class="koboSpan" id="kobo.12.1">
        Chapter 5
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.13.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.14.1">
       Extracting Semantic Representations with spaCy Pipelines
      </span>
     </em>
    </li>
    <li>
     <a href="B22441_06.xhtml#_idTextAnchor087">
      <em class="italic">
       <span class="koboSpan" id="kobo.15.1">
        Chapter 6
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.16.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.17.1">
       Utilizing spaCy with Transformers
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer024">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer025">
   </div>
  </div>
 </body></html>