- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Essential Components of Intelligent Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive into the essential components that make up the core
    of intelligent agents. Just as the human body has a skeleton that provides structure
    and support, intelligent agents have certain fundamental elements that allow them
    to adapt, act independently, and pursue goals in complex environments.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at the important pieces that bring agents to life – how they represent
    and store knowledge, the reasoning processes that guide their decision-making,
    the algorithms that help them learn and grow, and the mechanisms for choosing
    the right actions to take. You’ll also see how the exciting field of generative
    AI can supercharge these components, giving agents more powerful abilities to
    understand their surroundings, learn from experiences, and interact meaningfully
    with the world around them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge representation in intelligent agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasoning in intelligent agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning mechanisms for adaptive agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision-making and planning in agentic systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing agent capabilities with generative AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand knowledge representation methods
    in intelligent agents, reasoning and learning mechanisms, decision-making, and
    planning techniques, as well as having explored a generative AI-powered enhanced
    agent example.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Building-Agentic-AI-Systems](https://github.com/PacktPublishing/Building-Agentic-AI-Systems)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge representation in intelligent agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to store and manipulate information is fundamental for any intelligent
    agent. Knowledge representation provides the mechanisms for encoding an agent’s
    understanding of its environment into formats amenable to reasoning and decision-making
    processes. It is the most basic way to enable an intelligent agent to build a
    model of its surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge representation can be formally defined as the method of structuring
    and organizing data in such a way that an agent can effectively utilize that information
    for tasks such as drawing inferences, solving problems, and determining a course
    of action. There are several well-established approaches to knowledge representation,
    each with its own strengths and ideal applications, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Semantic networks provide one of the most intuitive and flexible approaches
    for representing knowledge within intelligent agents. At their core, semantic
    networks are graph-based structures composed of nodes that represent concepts,
    entities, events, or states in the world. These nodes are connected by labeled
    edges that explicitly define the semantic relationships between the represented
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplicity yet expressiveness of semantic networks allows them to naturally
    capture the rich, diverse relationships and interconnections that exist in our
    complex world. For example, a node representing the concept of “ *dog* ” could
    be connected to the “ *animal* ” node via an “ *is-a* ” relation edge, indicating
    that dogs are a type of animal. That same “ *dog* ” node may also be connected
    to nodes for “ *mammal* ,” “ *domesticated* ,” “ *canine* ,” and “ *pet* ” via
    other typed relationship links:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Semantic network representing “Dog” relationships
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike strict logic or rigid database schemas, semantic networks provide a
    flexible knowledge representation where any concept can be associated with any
    other concept through an appropriate semantic relation. This flexibility enables
    semantic networks to represent incredibly nuanced domains in an intuitive graphical
    form. As a real-world example, a medical semantic network could model diseases,
    symptoms, treatments, and anatomical concepts with relation types such as “ *causes*
    ,” “ *is-diagnosed-by* ,” “ *interacts-with* ,” and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Semantic network representing “Disease” relationships
  prefs: []
  type: TYPE_NORMAL
- en: Semantic networks gain much of their power from their ability to perform generalization
    through the inheritance of properties along relationship paths. If the network
    specifies that dogs are a subclass of animals and that animals breathe air, then
    an agent can semantically infer that dogs also breathe air through inheritance.
    Algorithms can traverse the graph, chaining sequences of relations together to
    derive new facts and conclusions from the represented knowledge. For instance,
    in a semantic network for family relations, one could infer that a person’s spouse’s
    parents are also their in-laws.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, semantic networks integrate naturally with other symbolic reasoning
    techniques. Their graph-based structure maps well to deductive methods such as
    **first-order logic** , where nodes become constants or predicates and edges become
    relations that can participate in logical proofs and inference rules. An intelligent
    tutoring system could use this combined representational power for logic-based
    explanations and teach students new concepts based on their semantic knowledge
    graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic networks provide a robust yet intuitive mechanism for intelligent agents
    to build rich, expressive models of their environment. Their inherent support
    for capturing interconnected concepts and deriving new knowledge through relation
    composition and inheritance makes them an extremely powerful knowledge representation
    formalism across many real-world domains.
  prefs: []
  type: TYPE_NORMAL
- en: Frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The frame knowledge representation paradigm provides a structured way for intelligent
    agents to model concepts and their associated attributes. In this formalism, knowledge
    about objects, situations, or events is stored in data structures called **frames**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Each frame consists of a collection of attribute-value pairs that describe the
    properties and characteristics of the concept being represented. For example,
    a frame for the concept “ *Car* ” may contain attributes such as “ *make* ,” “
    *model* ,” “ *year* ,” “ *color* ,” “ *fuel type* ,” and so on with corresponding
    values providing specifics for a particular car instance.
  prefs: []
  type: TYPE_NORMAL
- en: Frames are organized hierarchically, allowing for the inheritance of attributes
    from higher-level, more general frames down to their specialized sub-frames. The
    “ *Car* ” frame could inherit properties from a parent “ *Vehicle* ” frame while
    adding new attributes unique to cars. This hierarchical taxonomy facilitates efficient
    knowledge storage by avoiding redundant attribute definitions across related concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key advantage of frames is their flexibility to represent procedural knowledge
    alongside factual information. In addition to simple attribute-value slots, frames
    can contain procedures that supply attribute values dynamically or model operations
    relevant to the represented concept. For instance, the “ *Car* ” frame could have
    methods for calculating fuel efficiency or querying service records. The following
    figure illustrates the concept of frames with our vehicle example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Frames representing “Vehicle” and “Car” relationships
  prefs: []
  type: TYPE_NORMAL
- en: Frames provide an intuitive model for representation that mirrors how humans
    conceptualize knowledge about the world. Their hierarchical nature aligns with
    how people form conceptual abstractions and categorize ideas based on shared attributes
    and relations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In real-world applications, frame representations are widely used in areas
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Natural language processing** : Linguistic frames model semantic concepts,
    roles, and relations extracted from text data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expert systems** : Frames capture domain expertise and rules for knowledge-based
    reasoning engines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-oriented programming** : Classes in OOP languages are essentially
    frame-like structures encapsulating attributes and methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computer vision** : Object detection systems use frame hierarchies to identify
    and describe visual entities based on attributes such as shape, color, texture,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robotics** : Frames enable robots to represent objects/environments along
    with associated actions, motion models, and constraints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frame knowledge representation formalism offers an efficient, structured,
    and human-compatible way for intelligent agents to capture rich conceptual information
    suitable for knowledge-based reasoning and decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: Logic-based representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While semantic networks and frames offer visually intuitive ways to represent
    knowledge, the logic-based approach takes a more formal, mathematical route. Logic-based
    knowledge representation employs the machinery of symbolic logic to encode facts,
    rules, and axioms about a domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this paradigm, statements representing knowledge are translated into well-formed
    formulae in formal logical languages such as **propositional logic** , **first-order
    logic** , or **specialized modal/temporal logics** . See this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: “ *All humans are mortal* ” can be represented as *∀* *x (Human(x) → Mortal(x))*
    in first-order logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “ *It is raining or it is sunny* ” can be expressed as *Rain* *∨* *Sunny* in
    propositional logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “ *Eventually, the system will stabilize* ” can be modeled as *◇* *Stable* in
    temporal logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**∀** **x** : Universal quantifier meaning “ *for* *all x* .”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example** : *∀* *x (Human(x) → Mortal(x))* . Translation: *For all x, if
    x is a human, then x* *is mortal* .'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**∨** : Logical disjunction meaning “ *or* .”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example** : *Rain* *∨* *Sunny* . Translation: *It is either raining* *or
    sunny* .'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**◇** : Diamond operator in temporal logic meaning “ *eventually* .”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example** : *◇* *Stable* . Translation: *Eventually, the system* *will stabilize*
    .'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These logical formulae act as the building blocks for constructing a comprehensive
    knowledge base using strict logical deductive systems with clearly defined axioms,
    inference rules, and formal semantics. An inference engine can then derive new
    facts and conclusions from the existing knowledge by applying the rules of logical
    reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key advantage of logic-based representations is their formal rigor and associated
    strong theoretical properties. Systems built on logical foundations can provide
    guarantees around soundness (only deriving logically valid conclusions) and completeness
    (deriving all possible valid conclusions). This mathematical grounding makes logic
    attractive for knowledge representation in safety-critical domains. Logic-based
    representations find widespread use in many real-world applications, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expert systems** : Rule-based expert system engines are essentially theorem
    provers operating over a logical knowledge base encoding domain expertise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database systems** : Relational databases use relational algebra/calculus
    – subsets of first-order logic – as the mathematical foundations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated reasoning** : From software verification to robot planning, logic
    provides the representational underpinnings for automated reasoning systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legal/regulatory domains** : Laws, policies, and regulations can be precisely
    represented as logical rules amenable to formal analysis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semantic web** : Description logics such as OWL (Web Ontology Language) form
    the knowledge representation backbone of ontologies and the Semantic Web'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While logic-based representations aren’t as intuitive as semantic networks or
    frames, their mathematical rigor and ability to support sound, automated reasoning
    make them invaluable in applications where formal verification, consistency, and
    completeness guarantees are essential.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the foundational structures of knowledge representation, which
    form the basis of an agent’s knowledge base, we now turn to examine how intelligent
    agents harness these representations to perform reasoning tasks, draw inferences,
    and solve complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning in intelligent agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By employing the language of logic, intelligent agents can build robust knowledge
    bases, enabling sophisticated querying, deductive inference, and reasoning that
    are not possible with less expressive representational formalisms. Once an intelligent
    agent has a robust way to represent its knowledge, reasoning mechanisms allow
    it to intelligently manipulate and make use of that information. Reasoning capabilities
    enable agents to derive new insights, draw logical conclusions, explain observations,
    and ultimately make informed decisions to achieve their goals.
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning in intelligent agents is rarely a singular, monolithic process. Sophisticated
    agent architectures tend to employ a multi-faceted reasoning approach that combines
    different reasoning styles and data-driven, analytical, and learned components.
    For instance, a question-answering system could use semantic parsing to map questions
    to logical forms, apply deductive reasoning over a logical knowledge base, and
    then invoke a neural sequence-to-sequence model to render the final answer fluently.
    There are several fundamental reasoning paradigms, namely, deductive, inductive,
    and abductive reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: Deductive reasoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Deductive reasoning** is a fundamental form of logical reasoning that follows
    a top-down approach. In deductive reasoning, an intelligent agent starts with
    general premises or rules about a domain and applies them to derive specific,
    logically inescapable conclusions. The classic example illustrating deductive
    reasoning is the following popular syllogism:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“All men* *are mortal.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Socrates is* *a man.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Therefore, Socrates* *is mortal.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the initial premises (“ *All men are mortal* ” and “ *Socrates is a man*
    ”) are true, then the conclusion “ *Socrates is mortal* ” follows inescapably
    from applying the rules of deductive logic. Deduction provides a way to reach
    irrefutable conclusions as long as the original premises and rules are correct
    and factual. The following figure illustrates deductive reasoning with the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Deductive reasoning – from general premises to specific conclusions
  prefs: []
  type: TYPE_NORMAL
- en: 'Deductive reasoning finds application across many domains, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathematics/geometry** : Formal mathematical proofs are quintessential examples
    of deductive reasoning, deriving specific theorems from general axioms and previously
    proven statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Law** : Legal reasoning applies codified laws and precedents to derive judgments
    about particular cases through deduction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software verification** : Formal verification techniques use deductive reasoning
    over logical specifications to prove correctness properties of hardware/software
    systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network routing** : Routing protocols determine optimal paths by deductively
    applying rules/constraints about network topology, bandwidth, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deductive reasoning is particularly powerful when combined with other forms
    of reasoning such as abduction or induction. For example, a medical diagnosis
    system could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abduce** possible disease hypotheses from symptoms (inference to the best
    explanation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deduce** expected findings for each hypothesis using rules about disease
    models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compare** deduced findings to actual patient data to confirm/reject hypotheses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While deduction alone cannot acquire entirely new knowledge, it is indispensable
    for intelligent agents to logically expand their knowledge, enforcing consistency
    and enabling rational decision-making. Deductive reasoning provides the rigor
    to ensure the trustworthiness of an agent’s conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: Inductive reasoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast to the top-down approach of deductive reasoning, inductive reasoning
    follows a bottom-up methodology. Inductive reasoning involves making generalizations
    or deriving probable conclusions from a set of specific observations or data points.
    The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“The Sun has risen every day for the past* *million days.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Therefore, the sun will likely rise* *again tomorrow.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the repeated instances of the sun rising, an inductive reasoning process
    allows an intelligent agent to hypothesize or induce that the sun will continue
    rising in the future. However, unlike deduction, **inductive conclusions** are
    not logically guaranteed to be true – they merely suggest a likely *possibility*
    based on the observed evidence. The following figure illustrates the concept with
    the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Inductive reasoning – from specific observations to general conclusions
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive reasoning has immense applicability in the following real-world domains
    where data-driven learning and theory formation are crucial:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scientific method** : The process of formulating scientific laws/theories
    relies heavily on inductively generalizing from experimental observations and
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Machine learning** : ML algorithms essentially perform inductive reasoning,
    inferring general models from training data that can make predictions on new instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern recognition** : Computer vision, signal processing, and other pattern
    recognition tasks use inductive techniques to classify inputs based on detected
    statistical regularities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data mining** : Approaches such as association rule mining inductively identify
    frequently occurring patterns, correlations, or relationships in large datasets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Natural language acquisition** : Children learn grammar rules and language
    models through inductive generalization from the linguistic inputs they receive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While powerful, purely inductive reasoning has limitations since conclusions
    can be incorrect if the observed instances are an imperfect sample not representative
    of the entire space. As such, it is often combined with other reasoning approaches
    such as abduction (inference to the best explanation) and deduction (validating
    hypotheses) in intelligent agent architectures. Despite not guaranteeing truth,
    inductive reasoning’s ability to extract knowledge, recognize patterns, and formulate
    theories from specific data makes it indispensable for intelligent agents operating
    in noisy, uncertain environments where knowledge is not fully available upfront.
  prefs: []
  type: TYPE_NORMAL
- en: Abductive reasoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Abductive reasoning is a form of reasoning that works backward – attempting
    to find the most plausible explanations or premises that could account for a given
    set of observations or data. It is often described as *inference to the best explanation*
    . Unlike deductive reasoning, which starts with general rules and arrives at guaranteed
    specific conclusions, abduction begins with observed effects or phenomena and
    hypothesizes the most likely underlying causes based on current knowledge. An
    example of abductive reasoning is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“The lawn* *is wet.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*A plausible explanation: It rained* *last night.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the observed effect is a wet lawn. Abductive reasoning allows an intelligent
    agent to rationally deduce or infer that the most likely explanation, based on
    past experience, is that it rained the previous night, even though that was not
    directly observed. The following figure illustrates this concept of backward reasoning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Abductive reasoning – inference to the best explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Abductive reasoning is extremely useful in diagnostic domains and applications
    where root cause analysis is critical, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Medical diagnosis** : Given a set of symptoms, physicians abduce and investigate
    the most probable diseases or conditions that could explain those symptoms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault detection** : Monitoring systems in manufacturing use abduction to
    isolate the most likely faults or failures that led to observed anomalies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forensics/criminal investigation** : From crime scene evidence, detectives
    abduce possible scenarios and suspect profiles to determine what transpired'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AI planning** : For agents to achieve desired goals, they must abduce sequences
    of viable actions by reasoning backward from those goals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scientific discovery** : New scientific theories are often initially inferred
    by finding explanatory hypotheses for currently unexplained observations or phenomena'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key advantage of abductive reasoning is its ability to generate new plausible
    premises that deductive or inductive methods cannot produce solely from existing
    knowledge and data. It facilitates thinking outside the box and exploring novel
    possible explanations. However, abduction does not guarantee correct explanations
    – there may be multiple possible hypotheses consistent with the observations.
    This is why abductive reasoning is commonly used in tandem with deductive reasoning
    to validate the consistency and plausibility of the explanatory hypotheses formed.
  prefs: []
  type: TYPE_NORMAL
- en: Points to remember here are that implementing abductive reasoning in agentic
    systems is challenging due to its computational complexity, as generating and
    evaluating multiple hypotheses can be resource-intensive. It also deals with uncertainty
    and incomplete data, making it difficult to determine the most plausible explanations.
    Proper knowledge representation is crucial but difficult to maintain, and evaluating
    hypotheses often requires subjective criteria. Integrating abductive reasoning
    with other reasoning modes can lead to conflicts, and scalability becomes an issue
    as the domain grows. Additionally, handling dynamic environments and ensuring
    explainability for users may add further complexity to the process. However, by
    applying abductive reasoning, intelligent agents can exhibit deeper understanding,
    creativity in postulating tentative explanations, and an increased ability to
    operate effectively in uncertain environments with partial observability and information.
    Through robust knowledge representation formalisms and multi-faceted reasoning
    capabilities, intelligent agents gain the power to build rich models of their
    environment, draw insights, explain observations, and ultimately make well-informed
    decisions about how to interact with the world. These capabilities form the bedrock
    for more advanced agent functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Learning mechanisms for adaptive agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learning mechanisms are key to enabling intelligent agents to adapt to changes
    in their environment or to improve over time. The ability to learn allows agents
    to continuously refine their knowledge and behavior based on new experiences and
    data. There are numerous approaches to learning, each with its own strengths and
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supervised learning** : This learning paradigm involves training an agent
    on a dataset where the inputs are paired with corresponding labeled outputs or
    target values. The aim is for the agent to learn a mapping function that accurately
    predicts outputs for new unseen inputs. Supervised learning is widely used for
    classification and regression tasks across domains such as these:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image classification (for example, identifying objects and digits in images)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Spam detection (classifying emails as spam or not spam)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine translation (learning to map text in one language to another)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Medical diagnosis (mapping patient symptoms/tests to disease labels
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsupervised learning** : Here, the agent is trained on unlabeled data without
    any associated target outputs. The goal is to discover inherent patterns, correlations,
    or groupings within the data itself in an unsupervised manner. Key applications
    include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer segmentation (grouping customers based on purchasing behavior)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Anomaly detection (identifying unusual data points that differ from the norm)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Topic modeling (extracting topics/themes from collections of documents)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimensionality reduction (finding lower-dimensional representations of high-dimensional
    data)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reinforcement learning** : This learning approach is inspired by how humans
    and animals learn – through trial and error using feedback from the environment
    in the form of rewards or punishments. An RL agent learns optimal behaviors/policies
    by trying out different actions and updating its strategy based on the observed
    rewards. RL has seen great success in domains such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game playing (learning to master games such as chess, Go, and video games)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Robotics (learning control policies for robot navigation and manipulation)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Supply chain optimization (finding policies to maximize efficiency)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic signal control (learning timing policies to improve traffic flow)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transfer learning** : This technique focuses on transferring knowledge learned
    in one setting to facilitate learning in a different but related setting. By leveraging
    previously learned patterns and representations, transfer learning can significantly
    accelerate training speed and sample efficiency for new tasks. Applications span
    areas such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural language processing (transferring language models across domains)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer vision (using pre-trained models as initialization for new vision tasks)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation systems (transferring user/product embeddings across platforms)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These learning mechanisms, often used in hybrid combinations, equip intelligent
    agents with the ability to continuously expand their knowledge, refine their behaviors,
    and grow their problem-solving capabilities – the key hallmarks of intelligence.
    As learning algorithms advance, agents will only become more adaptable and robust
    when facing new challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the learning mechanisms that enable adaptive agents to acquire
    knowledge and skills, we now turn our attention to how these agents leverage this
    learning to make decisions and plan their actions in complex environments.
  prefs: []
  type: TYPE_NORMAL
- en: Decision-making and planning in agentic systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decision-making and planning are critical capabilities for intelligent agents
    to achieve their goals effectively in complex environments. Agents need to analyze
    various possible scenarios, evaluate outcomes, and select the action(s) that will
    lead to the most desirable outcome based on their preferences and constraints.
    Although utility functions (tools) and planning will be discussed in detail in
    later chapters, we will discuss these key components involved in agent decision-making
    at a high level in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Utility function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A utility function quantifies an agent’s preferences by mapping outcomes to
    utility values, enabling the agent to compare and choose actions that maximize
    expected utility. Utility functions play a central role in decision-making for
    intelligent agents by providing a quantitative way to represent and reason about
    preferences over different outcomes or states of the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'A utility function maps any given state or outcome to a real-numbered utility
    value , reflecting the desirability or preference for that state according to
    the agent’s goals, rewards, and penalties. Formally, this is mathematically expressed
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This expression may look a little intimidating at first, but the concept is
    really straightforward. Let us use some example Python code to explain this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To explain this utility function, let us go back to our travel booking example.
    The given Python utility function evaluates travel options based on price, convenience,
    and comfort. Lines 2,3, and 4 of the function assign a real numbered utility for
    price, comfort, and convenience respectively. The numbers 0.05, 10, and 15 are
    completely arbitrary but are in the order of magnitude of importance of each of
    the three factors in a person’s travel decision-making. For example, in line 2,
    we assign the price utility to a number; note that we subtract the price from
    an arbitrary value of **1000** , since the lower the price the better, which means
    a lower price contributes to more utility. Thus, the price utility number would
    be higher if the price is lower, that is, an inverse relationship. Similarly,
    the comfort and convenience utilities are assigned respective utility scores.
    The comfort and convenience scores are often user provided. For example, travel
    review websites such as Tripadvisor allow users to post detailed reviews about
    their travel experience via star ratings.
  prefs: []
  type: TYPE_NORMAL
- en: Applying our utility function to a few travel options will give us a clear picture
    of how this function works. Let us apply the utility function to two travel options
    a *Budget Airline* vs *Road Trip* .
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample input to the utility function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output of the utility function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output clearly shows that the road trip option scores a higher utility score
    due to higher convenience, comfort, and lower price compared to the budget airline.
    The full code is available in the **Chapter_03.ipynb** Python notebook in our
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utility functions encode an agent’s preferences by mapping states or outcomes
    to utility values, allowing any two states to be ranked or compared based on their
    assigned utilities. Higher utility values correspond to more preferred states
    or outcomes. This enables rational agents to select actions that maximize their
    expected utility, which is calculated as the probability-weighted sum of utilities
    over all possible outcome states resulting from those actions. By quantifying
    preferences in this way, utility functions provide a systematic mechanism for
    agents to make rational decisions in pursuit of the most desirable outcomes according
    to the specified utility measure. Utility functions can take many mathematical
    forms depending on the domain, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple scoring functions that apply weights to quantify preferences between
    attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraint satisfaction functions that are maximized when all hard constraints
    are met
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Economic utility functions modeling pricing, profits, costs, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplicative functions modeling preferences between outcomes with independent
    utility impacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More sophisticated utility functions can model uncertainty, risk preferences,
    multi-attribute tradeoffs, changing preferences over time, and dependencies between
    attributes. In the case of **multi-attribute tradeoffs** , an agent must weigh
    different attributes (for example, cost, quality, time, or safety) when making
    decisions. These attributes often conflict, and an agent must find a balance between
    them, such as choosing between a faster but more expensive option versus a slower,
    cheaper one. The challenge here lies in quantifying how much an agent values each
    attribute relative to others, and how changes in one attribute influence the overall
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an accurate quantitative utility function that captures all of an agent’s
    preferences is often a major challenge because preferences are often complex and
    context-dependent. Agents may have different attitudes toward risk (for example,
    risk-averse or risk-seeking), and preferences may change based on the situation
    or over time. Additionally, dependencies between attributes – such as how the
    increase in one attribute (e.g., speed) may negatively affect another (for example,
    cost) – can complicate the modeling process. Moreover, the uncertainty in predicting
    outcomes or preferences under changing conditions further complicates the task
    of creating a utility function that fully reflects the agent’s decision-making
    process. Techniques such as preference elicitation, inverse reinforcement learning,
    and learning from human feedback are used in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: Planning algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Planning algorithms are algorithms that derive sequences of actions for an agent
    to take in order to achieve its goals from a given initial state. Some of the
    most common planning approaches include **graph-based planning** , **heuristic
    search** , **Monte Carlo tree search** ( **MCTS** ), **hierarchical planning**
    , and **constraint satisfaction** . Let’s discuss each of these planning algorithms
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Graph-based planning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graph-based planning represents a planning problem as a graph, where the nodes
    correspond to possible states or configurations, and the edges represent actions
    or transitions that can be taken to move between states. A fundamental concept
    within graph-based planning algorithms is the **state-space graph** , which is
    a graph representation where nodes represent all possible states in the problem
    domain. In such a representation, the edges represent the actions or transitions
    between the states. This graph representation effectively maps out the entire
    “space” of possible situations and how they connect with each other via edges.
  prefs: []
  type: TYPE_NORMAL
- en: An **edge cost** is a property of an edge in a weighted graph. Each edge can
    have an associated cost (or weight) that represents some measure of the “expense”
    of taking that action or making that transition. Costs could represent factors
    such as distance, time, energy consumption, financial cost, or any other relevant
    metric appropriate for the use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using state-space graphs, edges, and edge costs, there are two broad categories
    of graph-based planning algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph search** : In graph search, the planning process involves searching
    this graph data structure to find a path from the initial state to one of the
    goal states. The path defines the sequence of actions for the agent to execute
    to transition between states and reach the goal. Some of the most common algorithms
    under this category are **depth-first search** ( **DFS** ), **breadth-first search**
    ( **BFS** ), and Dijkstra’s algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimal path finding** : This is a specific type of graph search that aims
    to find not just any path, but the best path according to some criteria (usually
    minimizing total edge cost). Two of the algorithms in this category are the Bellman-Ford
    algorithm and the A* search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downsides of using graph-based planning algorithms include fixing the state
    representation (state space) upfront, and the potential for exponential growth
    in the number of states to represent and store as problems get more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Graph-based planning techniques find numerous real-world applications across
    domains, where finding optimal sequences of actions to achieve goals is crucial.
    These applications include navigation and route planning, such as GPS systems
    using graph representations of road networks to find optimal routes minimizing
    travel time or distance. Logistics and supply chain applications involve planning
    optimal sequences of operations for manufacturing products or finding least-cost
    shipping routes and delivery schedules. AI planning employs graph-based methods
    for game AI move sequencing in chess, video games, and real-time strategy games,
    as well as for task planning in AI assistants.
  prefs: []
  type: TYPE_NORMAL
- en: Heuristic search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Heuristic search techniques are widely used when finding optimal solutions through
    exhaustive search is computationally intractable due to the exponential growth
    of the search space. By using heuristic functions to guide the search toward promising
    areas, these methods can find reasonably good approximate solutions much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Heuristic search techniques find widespread use in route planning and navigation
    applications. When finding truly optimal routes is computationally too expensive,
    heuristics such as estimating the straight-line distance to the destination can
    effectively guide the search toward reasonably short driving routes. AI agents
    in video games also commonly employ heuristic pathfinding algorithms to navigate
    virtual environments efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit of heuristic search is the ability to trade off optimality for
    computational efficiency, making larger problem instances solvable within limited
    time/memory constraints by finding approximate solutions. Heuristic design remains
    a critical challenge tailored to each application domain.
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo tree search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core idea behind MCTS is to iteratively build an asymmetric search tree
    by running many random simulations (playouts) from the current state. An asymmetric
    tree means that the tree is not balanced or uniform in its structure. The results
    of these simulations are used to guide the growth of the most promising branches
    in the tree at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: MCTS has seen widespread adoption across various real-world applications involving
    sequential decision-making under uncertainty. This algorithm has particular benefits
    in AI agents in situations that are likely to encounter uncertainties, and contain
    large state spaces, that is, a large number of possible outcomes. MCTS is found
    to produce reasonable results even with limited computational resources.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantages of MCTS are anytime behavior, the ability to handle large
    action spaces, and reasoning about long-term outcomes through simulations. However,
    its efficiency depends on having an effective simulation model and designing good
    exploration strategies tailored to the domain. Some of the common drawbacks of
    this algorithm include the computational intensity required for simulations of
    complex problems and the difficult-to-tune tree policy that helps with outcome
    selection during simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical planning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hierarchical planning approaches breaking down complex problems into hierarchies
    of higher-level tasks or goals, and subtasks or subgoals that achieve those higher-level
    objectives. This hierarchical decomposition allows reasoning about problems more
    abstractly and reusing solutions to common subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core advantages of hierarchical approaches include computational efficiency
    via reusing subplan solutions, knowledge representation at multiple abstraction
    levels, and increased scalability to handle highly complex problems through hierarchical
    reasoning, though not always optimally. This structure also aligns well with how
    humans conceptualize and tackle complex tasks. The core advantages of hierarchical
    approaches include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Computational efficiency by reusing subplan solutions and avoiding reasoning
    about all details simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge representation at multiple levels of abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased scalability to handle very complex problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While not always optimal, hierarchical plans can provide good approximations
    for large problems where optimal solutions may be computationally unmanageable.
    The structure also maps well to how humans tend to conceptualize and tackle complex
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Constraint satisfaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Constraint satisfaction problems** ( **CSPs** ) involve formulating the problem
    as a set of constraints that must be satisfied, and then using constraint propagation
    techniques to eliminate inconsistent possibilities from the search space. CSPs
    represent a powerful framework in AI for solving a wide variety of complex problems.
    At their core, CSPs involve defining a problem in terms of variables that need
    to be assigned values, under a set of constraints that restrict the possible combinations
    of these values. This approach allows for a natural representation of many real-world
    problems, from scheduling and resource allocation to puzzle-solving and configuration
    tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of CSPs lies in their ability to separate the problem representation
    from the solving method. Once a problem is formulated as a CSP, a variety of general-purpose
    algorithms can be applied to find a solution. This separation allows researchers
    and practitioners to focus on accurately modeling the problem without worrying
    about the intricacies and complexities of the solving algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent agents require flexible decision-making capabilities that can weigh
    constraints, handle uncertainty, learn from experience, and scale to complex real-world
    problems in pursuit of their goals. Advances in planning, search, reasoning, and
    learning algorithms continue enhancing these crucial cognitive abilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having examined the foundational aspects of intelligent agents – from knowledge
    representation and reasoning to learning mechanisms and decision-making processes
    – we now turn our attention to a cutting-edge development that promises to significantly
    expand these capabilities: the integration of generative AI into agent systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing agent capabilities with generative AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generative AI is transforming the development of intelligent agents by enhancing
    learning efficiency, improving their understanding of environments, and enabling
    more complex interactions through generative models. Some of the major developments
    in ushering generative AI in the space of intelligent agents are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data augmentation** : Creating synthetic training data with generative models
    supplements datasets, improving the robustness and efficiency of machine learning
    agents. For example, self-driving car agents can use generated scene images to
    learn better object detection and navigation policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding of context** : Generative AI constructs simulations modeling
    real-world complexities in fine detail, aiding agents in contextual understanding
    for informed decisions. For example, virtual assistants such as chatbots can use
    generative AI to simulate conversations in diverse contexts, helping them better
    understand user intent and provide more accurate, context-aware responses before
    interacting with real users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Natural language processing** : Generative language models ease human-agent
    interaction by improving understanding and generation capabilities. Virtual assistants
    such as Alexa and chatbots leverage generative NLP for natural conversations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creative problem solving** : By generating diverse possible solutions, generative
    AI allows agents to explore creative ideas and evaluate their feasibility. This
    could allow AI architects to creatively design innovative building layouts while
    adhering to structural constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The deep integration of generative AI with knowledge representation, learning
    mechanisms, and decision-making processes yields highly responsive and adaptive
    intelligent agents capable of operating effectively in dynamic, complex environments.
    Some examples of how this synergistic combination can enable advanced capabilities
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning** : Agents can gather data from various sources such as sensors,
    human interactions, or simulations to build models based on their operating environment
    through machine learning techniques such as reinforcement learning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge representation** : The learned environmental data is structured
    into usable representations such as semantic networks, logical rules, or probabilistic
    graphical models to capture relationships, constraints, and uncertainties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decision processes** : Based on the represented knowledge, agents use planning
    and decision-making algorithms (for example, Markov decision processes and MCTS)
    to derive sequences of actions aiming to achieve their objectives optimally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generative models** : Provide contextual simulations to enhance agents’ understanding
    through generated scenarios accounting for complexities such as noisy sensor data,
    stochastic dynamics, or extraneous factors absent from training data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback loops** : Allow continuous adaptation by feeding real-world interaction
    outcomes back into the learning mechanisms to refine the agent’s knowledge and
    decision models based on experience'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start building agentic AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned quite a lot about the characteristics of intelligent agents,
    how they are built, how they work with different algorithms, and their essential
    components. It is now time for a gentle introduction to the world of agentic AI
    and to start building applications using different frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In subsequent chapters of this book, we will make extensive use of several open
    source frameworks. The most popular framework for building agentic and multi-agent
    AI systems is LangChain’s LangGraph framework, although some of the other noteworthy
    frameworks (as of this writing) include AutoGen, CrewAI, and MetaGPT. This is
    not an exhaustive list of open source frameworks; these are only the most popular
    frameworks that allow you to build agentic and multi-agent systems with LLMs.
    Note that although some of these frameworks support different programming languages,
    we will primarily use Python programming language for our purposes. For consistency,
    we will use LangGraph and OpenAI GPT models throughout the book; however; there
    are a number of other LLMs that can be used with agentic AI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Although the code samples are created specifically with OpenAI GPT models, you
    can use any model of your choice that is supported by LangGraph. LangGraph also
    works with LLMs offered via several cloud providers such as **Amazon Web Services**
    ( **AWS** ), **Microsoft Azure** , and **Google Cloud Platform** ( **GCP** ).
    Using AI models or cloud platforms may incur some costs. Refer to the respective
    AI model documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the overview of frameworks and LLMs out of the way, let’s
    start with building our basic travel agent booking. At this stage, we only want
    the model to respond back with greetings and any follow-up questions. For example,
    if we ask the agent to “ *Book a flight for me* ”, then we want the model to respond
    back with a follow-up question about travel cities, dates, and so on. For the
    following code, we will directly use OpenAI’s Python SDK to build this functionality
    and use its function calling feature, that is the LLM model’s ability to call
    a function on the user’s behalf. Here’s the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let us break down what is happening in this code snippet. We first define a
    **book_flight** function in line 3 – at the moment, this function just returns
    a message that says that the flight booking is complete. The **travel_agent**
    function in line 12 is where we call the LLM, in this case, OpenAI’s **gpt-4-turbo**
    model. We call the LLM’s API using the OpenAI SDK in line 15, which is where we
    pass in the user’s message, the model’s name, and a set of tools. Note that we
    are using our **book_flight** function as a *tool* for our intelligent agent and
    the API takes **tools** as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss tools in greater detail in the subsequent chapters, but for
    now, it is sufficient to understand that *tools* are a mechanism by which your
    intelligent agent can interact with the external world (or external systems) to
    complete a task. In this case, the task is booking a flight ticket. The LLM is
    smart enough to indicate to us when to call the **book_flight** tool function
    when it has all the details from the passenger. In a more complete solution as
    we will see in future chapters, functions such as **book_flight** will be used
    to interact with external systems, such as calling APIs to complete the flight
    booking and so on. Here’s how a possible conversation using this code looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – A sample conversation with the AI agent
  prefs: []
  type: TYPE_NORMAL
- en: 'A few things to note here: after the first user message, our agent doesn’t
    directly call the **book_flight** function because it doesn’t have all the parameter
    values to call the function successfully. In a typical heuristics-based approach,
    you could use string parsing to find out whether the user has provided their name,
    travel cities, and date of travel. But such logic can be overly complicated and
    error-prone. This is where the beauty of an intelligent agent comes in. The LLM
    has better language understanding capabilities and can know when to call the **book_flight**
    function during the conversation, and if the required values are not provided
    by the user, it can prompt them to provide these values, that is, their name,
    travel cities, and date of travel. It can also accurately extract these values
    from the user’s response, which allows us to call the **book_flight** function.
    For the full code of the intelligent agent, refer to the **Chapter_03.ipynb**
    Python notebook in the GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed several aspects and key components of intelligent
    agents. We started with the understanding and importance of various knowledge
    representation mechanisms such as semantic networks, frames, and logic-based representations.
    We also learned about various reasoning techniques such as deductive, inductive,
    and abductive reasoning to understand how intelligent agents may use these techniques
    for decision-making to accomplish tasks. We briefly looked at some of the learning
    mechanisms that intelligent agents may use to adapt themselves to various use
    cases and explored agent decision-making via utility functions and various planning
    algorithms. Finally, we wrapped up this chapter with an introduction to intelligent
    agents with generative AI using an LLM and discussed a simple intelligent agent
    that is capable of gathering information from user queries for our travel booking
    agent example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into the advanced intelligent agent
    concepts such as reflection and introspection. We will learn how reflection and
    introspection influence an intelligent agent’s decision-making capabilities. Before
    we conclude this chapter, take a moment and try to answer the questions listed
    in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the three main types of knowledge representation discussed in the chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does inductive reasoning differ from deductive reasoning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a utility function in agent decision-making?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does generative AI enhance the capabilities of intelligent agents?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of “tools” in AI frameworks such as the one demonstrated in
    the travel agent example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three main types of knowledge representation discussed are semantic networks,
    frames, and logic-based representations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inductive reasoning follows a bottom-up approach, making generalizations from
    specific observations, while deductive reasoning follows a top-down approach,
    deriving specific conclusions from general premises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A utility function quantifies an agent’s preferences by mapping outcomes to
    utility values, enabling the agent to compare and choose actions that maximize
    expected utility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generative AI enhances agent capabilities through data augmentation, improved
    context understanding, better natural language processing, and enabling creative
    problem-solving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tools in AI frameworks allow agents to interact with external systems or perform
    specific functions, such as booking a flight in the travel agent example, enhancing
    the agent’s ability to complete complex tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our communities on Discord and Reddit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have questions about the book or want to contribute to discussions on Generative
    AI and LLMs? Join our Discord server at [https://packt.link/I1tSU](https://packt.link/I1tSU)
    and our Reddit channel at [https://packt.link/ugMW0](https://packt.link/ugMW0)
    to connect, share, and collaborate with like-minded enthusiasts.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31483_Discord_QR_new.jpg)![img](img/qrcode_Reddit_Channel.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Part 2: Designing and Implementing Generative AI-Based Agents'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part equips you with practical techniques and approaches for designing
    and implementing generative AI-based agentic systems, enabling you to create adaptive,
    self-aware, and collaborative intelligent agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B31483_04.xhtml#_idTextAnchor086) , *Reflection and Introspection
    in Agents*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B31483_05.xhtml#_idTextAnchor114) , *Enabling Tool Use and Planning
    in Agents*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B31483_06.xhtml#_idTextAnchor138) , *Exploring the Coordinator,
    Worker, and Delegator Approach*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B31483_07.xhtml#_idTextAnchor159) , *Effective Agentic System
    Design Techniques*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
