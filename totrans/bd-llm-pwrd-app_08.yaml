- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using LLMs with Structured Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover yet another great capability of **large
    language models** (**LLMs**): the ability to handle structured, tabular data.
    We will see how, thanks to plugins and an agentic approach, we can use LLMs as
    a natural language interface between us and our structured data, reducing the
    gap between the business user and the structured information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'During this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the main structured data systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tools and plugins to connect LLMs to tabular data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a database copilot with LangChain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to build your own natural language
    interface for your data estate and be able to combine unstructured with structured
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the tasks in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Hugging Face account and user access token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OpenAI account and user access token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.7.1 or later version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python packages: Make sure to have the following Python packages installed:
    `langchain`, `python-dotenv`, `huggingface_hub`, `streamlit`, and `sqlite3`. Those
    can be easily installed via `pip install` in your terminal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find all the code and examples in the book’s GitHub repository at [https://github.com/PacktPublishing/Building-LLM-Powered-Applications](Chapter_08.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: What is structured data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we focused on how LLMs can handle textual data. In fact,
    those models are, as the name suggests, “language” models, meaning that they have
    been trained and are able to handle unstructured text data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, unstructured data only refers to a portion of the overall data
    realm that applications can handle. Generally, data can be categorized into three
    types, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unstructured data**: This refers to data that doesn’t have a specific or
    predefined format. It lacks a consistent structure, making it challenging to organize
    and analyze using traditional databases. Examples of unstructured data include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Text documents: Emails, social media posts, articles, and reports.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multimedia: Images, videos, audio recordings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Natural language text: Chat logs, transcriptions of spoken conversations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binary data: Files without a specific data format, such as proprietary file
    formats.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to storing unstructured data, NoSQL databases play a crucial role,
    due to their flexible schema-less design, which allows them to handle various
    data types like text, images, and videos efficiently. The term “NoSQL” originally
    stood for “non-SQL” or “not only SQL” to emphasize that these databases don’t
    rely solely on the traditional **Structured Query Language** (**SQL**) to manage
    and query data. NoSQL databases emerged as a response to the limitations of relational
    databases, particularly their rigid schema requirements and difficulties in scaling
    horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a NoSQL database is MongoDB, a document-oriented NoSQL database,
    which stores data in JSON-like documents, making it highly effective for managing
    diverse unstructured content; similarly, Cassandra, with its wide-column store
    model, excels at handling large volumes of data across many commodity servers,
    providing high availability without compromising performance. This flexibility
    enables NoSQL databases to adapt to the volume, variety, and velocity of unstructured
    data, accommodating rapid changes and scaling easily. Traditional relational databases,
    with their rigid schema requirements, struggle to manage such diversity and volume
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured data**: This type of data is organized and formatted with a clear
    structure, typically into rows and columns. It follows a fixed schema, making
    it easy to store, retrieve, and analyze using relational databases. Examples of
    structured data include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relational databases: Data stored in tables with predefined columns and data
    types.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spreadsheets: Data organized in rows and columns in software like Microsoft
    Excel.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sensor data: Recorded measurements like temperature, pressure, and time in
    a structured format.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Financial data: Transaction records, balance sheets, and income statements.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semi-structured data**: This falls between the two categories. While it doesn’t
    adhere to a rigid structure like structured data, it has some level of organization
    and may contain tags or other markers that provide context. Examples of semi-structured
    data include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eXtensible Markup Language** (**XML**) files: They use tags to structure
    data, but the specific tags and their arrangement can vary.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**): This is used for data interchange
    and allows for nested structures and key-value pairs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NoSQL databases: Storing data in a format that doesn’t require a fixed schema,
    allowing for flexibility.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, unstructured data lacks a defined format, structured data follows
    a strict format, and semi-structured data has some level of structure but is more
    flexible than structured data. The distinction between these types of data is
    important as it impacts how they are stored, processed, and analyzed in various
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, regardless of its nature, querying structured data involves using a
    query language or methods specific to that database technology. For example, for
    SQL databases, SQL is used to interact with relational databases. Henceforth,
    to extract data from tables, you need to know this specific language.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to ask questions in natural language to our structured
    data? What if our application could provide us not only with a sterile numeric
    answer but rather with a conversational answer, which also gives us context about
    the number? This is exactly what we will try to achieve in the next sections with
    our LLM-powered applications. More specifically, we are going build something
    that we’ve already defined in *Chapter 2*: a **copilot**. Since we are going to
    mount our copilot to a relational database, we will name our application **DBCopilot**.
    First, let’s look at what relational databases are.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with relational databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of relational databases was first proposed by E.F. Codd, an IBM
    researcher, in 1970\. He defined the rules and principles of the relational model,
    which aimed to provide a simple and consistent way of accessing and manipulating
    data. He also introduced SQL, which became the standard language for querying
    and manipulating relational databases. Relational databases have become widely
    used in various domains and applications, such as e-commerce, inventory management,
    payroll, **customer relationship management** (**CRM**), and **business intelligence**
    (**BI**).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to cover the main aspects of a relational database.
    Then, we will start working with the sample database we will use in our DBCopilot,
    the Chinook database. We will inspect this database and explore how to connect
    to remote tables using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to relational databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A relational database is a type of database that stores and organizes data in
    structured tables with rows and columns. Each row represents a record, and each
    column represents a field or attribute. The relationships between tables are established
    through keys, primarily the primary key and foreign key. This allows for efficient
    querying and manipulation of data using SQL. These databases are commonly used
    for various applications like websites and business management systems, due to
    their ability to manage structured data effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a better understanding of relational databases, let’s consider an example
    of a database of a library. We’ll have two tables: one for books and another for
    authors. The relationship between them will be established using primary and foreign
    keys.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition**'
  prefs: []
  type: TYPE_NORMAL
- en: A primary key is like the unique fingerprint of each record in a table. It’s
    a special column that holds a value that’s distinct for each row in that table.
    Think of it as the “identity” of a record. Having a primary key is important because
    it guarantees that no two records in the same table will share the same key. This
    uniqueness makes it easy to locate, modify, and manage individual records in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: A foreign key is a bridge between two tables. It’s a column in one table that
    references the primary key column in another table. This reference creates a link
    between the data in the two tables, establishing a relationship. The purpose of
    the foreign key is to maintain data consistency and integrity across related tables.
    It ensures that if a change is made in the primary key table, the related data
    in the other table remains accurate. By using foreign keys, you can retrieve information
    from multiple tables that are connected, enabling you to understand how different
    pieces of data are related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at our example, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: An example of the relationship between two tables in a database'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the Authors table contains information about authors, including
    their ID, name, and birth year. The Books table includes details about books,
    including the book’s ID, title, and a foreign key called AuthorID, which references
    the corresponding author in the Authors table (with AuthorID as the primary key).
    This way, you can use SQL queries to retrieve information like finding all books
    written by a specific author or the birth year of an author based on the book
    they wrote. The relational structure allows for efficient management and retrieval
    of data in a structured manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the main database systems in the market include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL databases**: These are **relational database management systems** (**RDBMS**)
    that use SQL for data manipulation and querying. Examples include MySQL, PostgreSQL,
    and Microsoft SQL Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle Database**: A widely-used RDBMS that offers advanced features and
    scalability for large-scale applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLite:** A self-contained, serverless, and zero-configuration SQL database
    engine commonly used in embedded systems and mobile applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IBM Db2**: A family of data management products, including relational database
    servers, developed by IBM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Web Services (AWS) RDS**: A managed relational database service offered
    by Amazon, providing options for various databases like MySQL, PostgreSQL, SQL
    Server, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud SQL**: A managed database service by Google Cloud Platform,
    supporting MySQL, PostgreSQL, and SQL Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis**: An open-source, in-memory data structure store that can be used
    as a database, cache, and message broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to use SQLite database, which also offers a seamless
    integration with Python. But before we do that, let’s understand the database
    we’ll be using.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Chinook database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chinook database is a sample database that can be used for learning and
    practicing SQL. It is based on a fictional digital media store and contains data
    about artists, albums, tracks, customers, invoices, and more. The Chinook database
    is available for various database management systems, such as SQL Server, Oracle,
    MySQL, PostgreSQL, SQLite, and DB2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some features of this database:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses real data from an iTunes library, which makes it more realistic and
    interesting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a clear and simple data model, which makes it easy to understand and
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It covers more features of SQL, such as subqueries, joins, views, and triggers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is compatible with multiple database servers, which makes it more versatile
    and portable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the configuration instructions at [https://database.guide/2-sample-databases-sqlite/](https://database.guide/2-sample-databases-sqlite/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an illustration of the relationship among the database’s tables
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Diagram of Chinook Database (source: [https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python](https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python))'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are 11 tables, all related to each other with primary
    and foreign keys. In the upcoming paragraph, we will see how LLMs will be able
    to navigate among those tables, capturing their relationships and gathering relevant
    information. But before jumping to LLMs, let’s first inspect the Chinook database
    a bit more by setting up the connection with Python.
  prefs: []
  type: TYPE_NORMAL
- en: How to work with relational databases in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with relational databases in Python, you need to use a library that
    can connect to the database and execute SQL queries. Some of these libraries are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQLAlchemy`: This is an open-source SQL toolkit and **object-relational mapper**
    (**ORM**) for Python. It allows you to create, read, update, and delete data from
    relational databases using Python objects and methods. It supports many database
    engines, such as SQLite, MySQL, PostgreSQL, and Oracle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psycopg`: This is a popular database connector for PostgreSQL. It enables
    you to execute SQL queries and access PostgreSQL features from Python. It is fast,
    reliable, and thread-safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MySQLdb`: This is a database connector for MySQL. It allows you to interact
    with MySQL databases from Python using the DB-API 2.0 specification. It is one
    of the oldest and most widely used Python libraries for MySQL, but its development
    is mostly frozen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cx_Oracle`: This is a database connector for Oracle Database. It enables you
    to connect to Oracle databases and use SQL and PL/SQL features from Python. It
    supports advanced features such as object types, **Large Objects** (**LOBs**),
    and arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3`: This is a database connector for SQLite3, a widely used, lightweight,
    serverless, self-contained, and open-source relational database management system.
    You can use sqlite3 to create, query, update, and delete data from `SQLite` databases
    in your Python programs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we are going to work with SQLite, we will use the `sqlite3` module, which
    you will need to install via `pip install sqlite3`. Some of the features of sqlite3
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It follows the DB-API 2.0 specification, which defines a standard interface
    for Python database access modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports transactions, which allow you to execute multiple SQL statements
    as a single unit of work and roll back in case of errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to use Python objects as parameters and results for SQL queries,
    using various adapters and converters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports user-defined functions, aggregates, collations, and authorizers,
    which enable you to extend the functionality of SQLite with Python code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a built-in row factory, which returns query results as named tuples or
    dictionaries instead of plain tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example of this connection using our Chinook database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The database can be downloaded locally from [https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip](https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip).
    You will only need to unzip the `chinook.db` file and it will be ready to be consumed.
    In the following code, we are initializing a connection (`conn`) to our `chinook.db`,
    which will be used to interact with the database. Then, we will save our tables
    in a pandas object with the `read_sql` module, which allows you to run SQL queries
    against your database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output that we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a black screen  Description automatically generated](img/B21714_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: A list of tables within the Chinook database'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Column names might be slightly different as the online database is updated
    over time. To get up-to-date columns’ naming conventions, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also inspect the single table to gather some relevant data. For example,
    let’s say we want to see the top five countries per album sales:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a cellphone  Description automatically generated](img/B21714_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Top 5 countries with highest sales'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can also use the `matplotlib` Python library to create useful diagrams
    about the database’s statistics. In the following Python snippet, we are going
    to run an SQL query to extract the number of tracks grouped by genre, and then
    plot the result using `matplotlib` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph of tracks with blue bars  Description automatically generated](img/B21714_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Number of tracks by genre'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in order to gather relevant information from our database, we
    used the syntax of SQL. Our goal is to gather information by simply asking in
    natural language, and we are going to do so starting in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the DBCopilot with LangChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to cover the architecture and implementation steps
    behind a DBCopilot application, a natural language interface to chat with database-structured
    data. In the upcoming sections, we will explore how to achieve that by leveraging
    a powerful LangChain component called SQL Agent.
  prefs: []
  type: TYPE_NORMAL
- en: LangChain agents and SQL Agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 4*, we introduced the concept of LangChain agents, defining them
    as entities that drive decision making within LLM-powered applications.
  prefs: []
  type: TYPE_NORMAL
- en: Agents have access to a suite of tools and can decide which tool to call based
    on the user input and the context. Agents are dynamic and adaptive, meaning that
    they can change or adjust their actions based on the situation or the goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see agents in action, using the following LangChain
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_sql_agent`: An agent designed to interact with relational databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLDatabaseToolkit`: A toolkit to provide the agent with the required non-parametric
    knowledge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OpenAI`: An LLM to act as the reasoning engine behind the agent, as well as
    the generative engine to produce conversational results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with our implementation by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first initialize all the components and establish the connection to the
    Chinook database, using the `SQLDatabase` LangChain component (which uses `SQLAlchemy`
    under the hood and is used to connect to our database):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before running the agent, let’s first inspect its available tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Those tools have the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql_db_query`: This takes as input a detailed and correct SQL query, and it
    outputs a result from the database. If the query is not correct, an error message
    will be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql_db_schema`: This takes as input a comma-separated list of tables, and
    it outputs the schema and sample rows for those tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql_db_list_tables`: This takes as input an empty string, and it outputs a
    comma-separated list of tables in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql_db_query_checker`: This tool double-checks whether the query is correct
    before executing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now execute our agent with a simple query to describe the `playlisttrack`
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following output is then obtained (the output is truncated – you can find
    the full output in the book’s GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with a simple question in natural language, our agent was able
    to understand its semantics, translate it into an SQL query, extract the relevant
    information, and use it as context to generate the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how was it able to do all of that? Under the hood, the SQL agent comes
    with a default prompt template, which makes it tailored to this type of activity.
    Let’s see the default template of the LangChain component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this prompt template, the agent is able to use the proper tools and
    generate a SQL query, without modifying the underlying database (you can see the
    explicit rule not to run any **data manipulation language** (**DML**) statements).
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition**'
  prefs: []
  type: TYPE_NORMAL
- en: 'DML is a class of SQL statements that are used to query, edit, add, and delete
    row-level data from database tables or views. The main DML statements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT`: This is used to retrieve data from one or more tables or views based
    on specified criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSERT`: This is used to insert new data records or rows into a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE`: This is used to modify the values of existing data records or rows
    in a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This is used to remove one or more data records or rows from a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MERGE`: This is used to combine the data from two tables into one based on
    a common column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DML statements are used to store, modify, retrieve, delete, and update data
    in a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also see how the agent is able to correlate more than one table within
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the first lines of the chain, you can see that `Action Input` invokes
    two tables – track and genre:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the question is as follows: are we sure that we are getting the proper
    result? A nice way to double-check this would be to print the SQL query that the
    agent ran against the database. To do so, we can modify the default prompt to
    ask the agent to explicitly show us the reasoning behind its result.'
  prefs: []
  type: TYPE_NORMAL
- en: Prompt engineering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, pre-built LangChain agents and chains come
    with default prompts, which make it easier to tailor them toward their goals.
    Nevertheless, we can customize that prompt and pass it as a parameter to our component.
    For example, let’s say that we want our SQL agent to print the SQL query it used
    to return the result.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have to understand which kind of prompt chunks the SQL Agent
    is able to take as parameters. To do so, we can simply inspect the objects running
    `create_sql_agent`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21714_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: A screenshot of the description of the SQL agent'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Agent takes a prompt prefix and a format instruction, which are merged
    and constitute the default prompt we inspected in the previous section. To make
    our agent more self-explanatory, we will create two variables, `prefix` and `format_instructions`,
    which will be passed as parameters and that slightly modify the default prompt
    as follows (you can find the whole prompts in the GitHub repository at [https://github.com/PacktPublishing/Building-LLM-Powered-Applications](Chapter_08.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the `prompt_prefix`, which is already configured as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To this, we will add the following line of instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In `prompt_format_instructions`, we will add the following example of explanation
    using few-shot learning, which we covered in *Chapter 1*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]sql'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SELECT c.country AS Country, SUM(i.total) AS Sales
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FROM customer c
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JOIN invoice i ON c.customer_id = i.customer_id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GROUP BY Country
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ORDER BY Sales DESC
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LIMIT 5;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s pass those prompt chunks as parameters to our agent and print the
    result (I will omit the whole chain here, but you can see it in the GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the obtained output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]sql'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT al.title AS Album, ar.name AS Artist, SUM(i.total) AS Sales
  prefs: []
  type: TYPE_NORMAL
- en: FROM album al
  prefs: []
  type: TYPE_NORMAL
- en: JOIN invoice i ON al.album_id = i.invoice_id
  prefs: []
  type: TYPE_NORMAL
- en: JOIN artist ar ON al.artist_id = ar.artist_id
  prefs: []
  type: TYPE_NORMAL
- en: GROUP BY ar.name
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY Sales
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: from  langchain_experimental.tools.python.tool import PythonREPLTool
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from  langchain_experimental.python import PythonREPL
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from langchain.agents.agent_toolkits import FileManagementToolkit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: working_directory  = os.getcwd()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tools = FileManagementToolkit(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: root_dir=str(working_directory),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: selected_tools=["read_file", "write_file", "list_directory"],).get_tools()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: tools.append(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PythonREPLTool())
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: tools.extend(SQLDatabaseToolkit(db=db, llm=llm).get_tools())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from langchain.chat_models import ChatOpenAI
  prefs: []
  type: TYPE_NORMAL
- en: from langchain.agents import initialize_agent, Tool
  prefs: []
  type: TYPE_NORMAL
- en: from langchain.agents import AgentType
  prefs: []
  type: TYPE_NORMAL
- en: model = ChatOpenAI()
  prefs: []
  type: TYPE_NORMAL
- en: agent = initialize_agent(
  prefs: []
  type: TYPE_NORMAL
- en: tools, model, agent= AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: agent.run("generate a matplotlib bar chart of the top 5 countries for sales
    from the chinook database. Save the output in the current working directory as
    figure.png")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Entering new AgentExecutor chain...
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[…]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observation: [(''USA'', 10405.889999999912), (''Canada'', 5489.549999999994),
    (''Brazil'', 4058.999999999997), (''France'', 3972.869999999995), (''Germany'',
    3441.2399999999925)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[…]'
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully retrieved the top 5 countries for sales. We can now use
    matplotlib to create a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[…]'
  prefs: []
  type: TYPE_NORMAL
- en: Finished chain.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '''Here is the bar chart of the top 5 countries for sales from the Chinook database.
    It has been saved as figure.png in the current working directory. '''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: prompt_prefix = """ Your prefix here
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: prompt_format_instructions= """
  prefs: []
  type: TYPE_NORMAL
- en: Your instructions here.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: agent = initialize_agent(tools, model, agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose = True,
  prefs: []
  type: TYPE_NORMAL
- en: agent_kwargs={
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''prefix'':prompt_prefix,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '''format_instructions'': prompt_format_instructions })'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: import streamlit as st
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: st.set_page_config(page_title="DBCopilot", page_icon="![](img/Icon.png)")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: st.header('![](img/Icon.png) Welcome to DBCopilot, your copilot for structured
    databases.')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: load_dotenv()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#os.environ["HUGGINGFACEHUB_API_TOKEN"]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: openai_api_key = os.environ['OPENAI_API_KEY']
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: db = SQLDatabase.from_uri('sqlite:///chinook.db')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: llm = OpenAI()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: toolkit = SQLDatabaseToolkit(db=db, llm=llm)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: agent_executor = create_sql_agent(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prefix=prompt_prefix,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: format_instructions = prompt_format_instructions,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: llm=llm,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: toolkit=toolkit,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: verbose=True,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: top_k=10
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'if "messages" not in st.session_state or st.sidebar.button("Clear message history"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'st.session_state["messages"] = [{"role": "assistant", "content": "How can I
    help you?"}]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for msg in st.session_state.messages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: st.chat_message(msg["role"]).write(msg["content"])
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'if user_query:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'st.session_state.messages.append({"role": "user", "content": user_query})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: st.chat_message("user").write(user_query)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with st.chat_message("assistant"):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: st_cb = StreamlitCallbackHandler(st.container())
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: response = agent_executor.run(user_query, callbacks = [st_cb], handle_parsing_errors=True)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'st.session_state.messages.append({"role": "assistant", "content": response})'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: st.write(response)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can run your application in the terminal with the `streamlit run copilot.py`
    command. The final web page looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Screenshot of the front-end of DBCopilot'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the `StreamlitCallbackHandler` module, we can also expand each action
    the agent took, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Illustration of the agent’s actions during the chain'
  prefs: []
  type: TYPE_NORMAL
- en: With just a few lines of code, we were able to set up a simple front-end for
    our DBCopilot with a conversational user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we saw how LLMs are not only capable of interacting with textual
    and unstructured data, but also with structured and numeric data. This is made
    possible because of two main elements: the natural capabilities of LLMs and, more
    generally, LFMs for understanding a problem’s statement, planning a resolution,
    and acting as reasoning engines, as well as a set of tools that extend LLMs’ capabilities
    with domain-specific skills.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we mainly relied upon LangChain’s SQL Database toolkit, which
    connects the Agent to an SQL database with a curated prompt. Furthermore, we extended
    the Agent’s capabilities even further, making it able to generate matplotlib graphs,
    with the Python REPL tool, and save the output to our local file system with the
    File Management tool.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to delve even deeper into the analytical capabilities
    of LLMs. More specifically, we are going to cover their capabilities of working
    with code.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chinook Database: [https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources](https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LangChain File system tool: [https://python.langchain.com/docs/integrations/tools/filesystem](https://python.langchain.com/docs/integrations/tools/filesystem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LangChain Python REPL tool: [https://python.langchain.com/docs/integrations/toolkits/python](https://python.langchain.com/docs/integrations/toolkits/python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/llm](https://packt.link/llm)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code214329708533108046.png)'
  prefs: []
  type: TYPE_IMG
