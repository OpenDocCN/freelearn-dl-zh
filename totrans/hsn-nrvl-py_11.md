# ES-HyperNEAT与视网膜问题

在本章中，你将了解HyperNEAT方法的ES-HyperNEAT扩展，这是我们上章讨论过的。正如你在上章所学，HyperNEAT方法允许编码更大规模的**人工神经网络**（**ANN**）拓扑结构，这对于在输入数据具有大量维度的领域工作至关重要，例如计算机视觉。然而，尽管HyperNEAT方法功能强大，但它有一个显著的缺点——ANN基底的配置应该由人类建筑师事先设计。ES-HyperNEAT方法通过引入可进化基底的观念来解决这一问题，这使得我们能够在进化过程中自动产生适当的基底配置。

在熟悉ES-HyperNEAT方法的基础知识之后，你将有机会将此知识应用于解决模块化视网膜问题。在此任务中，我们将向你展示如何选择一个合适的初始基底配置，以帮助进化过程发现模块化结构。此外，我们还将讨论模块化视网膜问题求解器的源代码以及测试环境，这些可以用来评估每个检测ANN的适应性。

通过本章，你将获得使用MultiNEAT Python库应用ES-HyperNEAT方法的实践经验。

本章中，我们将涵盖以下主题：

+   神经节点拓扑的手动配置与基于进化的配置

+   四叉树信息提取和ES-HyperNEAT基础知识

+   模块化左右视网膜实验

+   实验结果讨论

# 技术要求

为了执行本章中描述的实验，应满足以下技术要求：

+   Windows 8/10, macOS 10.13或更新的版本，或现代Linux

+   Anaconda Distribution版本2019.03或更新的版本

本章的代码可以在[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter8)找到

# 神经节点拓扑的手动配置与基于进化的配置

我们在[第7章](21fb699f-605d-4156-aa5c-5ba501dc09cf.xhtml)“基于超立方体的NEAT进行视觉区分”中讨论的HyperNEAT方法，允许我们使用神经进化方法解决需要使用大规模ANN结构来找到解决方案的广泛类别的难题。这类问题跨越多个实际领域，包括视觉模式识别。所有这些问题的主要区别特征是输入/输出数据的高度维度。

在上一章中，你学习了如何定义判别器人工神经网络（ANN）的基底的配置来解决视觉判别任务。你也了解到，使用与目标问题搜索空间几何特征相匹配的适当基底配置至关重要。使用HyperNEAT方法，作为架构师的你需要事先定义基底配置，仅使用你对问题空间空间几何的理解。然而，并不总是可能了解特定问题空间背后隐藏的所有几何规律。

如果你手动设计基底，你会在其上绘制的权重模式上创建一个无意中的约束，这种模式是由连接**组合模式生成网络**（**CPPNs**）产生的。通过在基底中特定位置放置节点，你干扰了CPPN发现自然世界几何规律的能力。CPPN应该产生一个与提供的基底结构完美对齐的连接模式，并且只有该结构中的节点之间才能建立连接。这种限制导致了不必要的近似误差，当你使用演化的CPPN创建解决方案求解器ANN（表型）的拓扑结构时，这些误差会污染结果。

然而，为什么手动配置基底时引入的限制一开始就产生了？如果CPPN能够详细阐述基底中自动定位在正确位置的节点之间的连接模式会更好吗？似乎在基底中演化的连接模式提供了有价值的隐含提示，帮助我们估计下一轮演化的节点位置。在CPPN训练期间基底配置演化的方法得到了一个名字：**可演化基底**。

允许我们估计下一个节点位置的隐含数据是特定基底区域中连接模式编码的信息量。连接权重均匀分布的区域编码的信息量较小，因此在这些区域只需要少量基底节点。同时，连接权重梯度大的基底区域信息密集，可以从放置在这些区域内的额外节点中受益。当你将额外的节点放置在基底这样的区域时，你允许CPPN表示自然世界的更细粒度的编码。因此，节点的放置和连接模式可以由连接权重的分布来规定，而CPPN在进化过程中产生连接权重。

HyperNEAT将基底中两个节点之间的每个连接表示为四维超立方体中的一个点。可进化基底HyperNEAT算法通过自动在连接权重变化较小的超立方体区域放置较少的超点来扩展HyperNEAT。因此，ES-HyperNEAT在进化过程中确定基底拓扑时，将信息密度作为主要的指导原则。

在下一节中，我们将讨论ES-HyperNEAT算法的细节。

# 四叉树信息提取和ES-HyperNEAT基础知识

为了有效计算基底的连接模式中的信息密度，我们需要使用适当的数据结构。我们需要使用一种数据结构，允许在不同粒度级别上有效地搜索二维基底空间。在计算机科学中，存在一种数据结构完美符合这些要求。这种结构就是**四叉树**。

四叉树是一种数据结构，允许我们通过将任何感兴趣的区域分割成四个子区域来有效地在二维空间中进行搜索。每个子区域随后成为树的叶子，根节点代表初始区域。

ES-HyperNEAT使用四叉树数据结构，从数据科学家预定义的输入和输出节点开始，迭代地寻找基底中的新连接和节点。使用四叉树搜索新连接和节点比在超立方体的四维空间中搜索要计算效率高得多。

以下图表显示了使用四叉树结构的信息提取方案：

![图片](img/e7cca6a3-0382-4424-b28f-3b759c53f33e.png)

信息提取方案

图中所示的信息提取方法有两个主要部分：

1.  **划分和初始化**阶段在图表的上部部分展示。在这个阶段，通过递归划分初始基底区域（从(*-1*, *-1*）到(*1, 1*)），创建四叉树。当达到所需的四叉树深度时，划分停止。现在我们有几个子空间被拟合到基底中，确定初始基底分辨率(*r*)。接下来，对于四叉树中中心在(![](img/7b9cf86d-a9b4-429d-bc7e-faa039aa599c.png),![](img/058e9c7f-9dc4-42db-9c59-311c42c52554.png))的每个节点，我们查询CPPN以找到该节点与特定输入或输出神经元在坐标(*a, b*)之间的连接权重(*w*)。当我们计算出四叉树子树中*k*个叶子节点的连接权重后，我们就可以计算四叉树中节点*p*的信息方差，如下所示：

![图片](img/4c372061-3f19-40ba-90fe-8c7d3773a415.png)

![](img/806e14e4-960c-4327-bd4c-d6c048112dd3.png)是*k*个叶节点之间的平均连接权重，![](img/7567b3d8-2e17-4436-9d1b-8bc18199c6ee.png)是每个叶节点的连接权重。

我们可以使用这个估计的方差值作为信息密度在基质特定子区域中的启发式指标。这个值越高，信息密度就越高。可以通过引入**分割阈值**常量来使用方差来管理基质特定子区域的信息密度。如果方差大于分割阈值，则重复分割阶段，直到达到所需的信息密度。

在这个阶段，我们创建一个指示性结构，使CPPN能够决定在给定的基质中连接的位置。处理阶段的下一阶段使用创建的四叉树结构放置所有必要的连接。

1.  **修剪和提取**阶段在图的下部表示。在这个阶段，我们使用前一阶段创建的填充四叉树结构来找到高方差区域，并确保这些区域的节点之间有更多的连接。我们以深度优先的方式遍历四叉树，并在具有小于给定**方差阈值**的方差值的节点处停止遍历（![](img/00f974a1-7ad2-4378-a76b-079f334dc42b.png))或当当前节点没有子节点（即，方差为零）时。对于通过深度优先搜索找到的每个四叉树节点，我们表达节点中心(*x*, *y*)与每个已确定的父节点之间的连接。父节点可以是建筑师（输入/输出节点）确定的，也可以在信息提取方法的前一轮次中找到，即从ES-HyperNEAT方法已创建的隐藏节点中找到。当这个阶段完成时，基质配置将在信息密集的基质区域有更多的节点，而在编码少量信息的区域有较少的节点。

在下一节中，我们将讨论如何使用我们刚刚描述的ES-HyperNEAT算法来解决模块化视网膜问题。

关于ES-HyperNEAT算法的更多详细信息，请参阅[第1章](f59c6396-55e5-4495-95c0-7af9a42c2f20.xhtml)，*神经进化方法概述*。

# 模块化视网膜问题基础知识

层次模块结构是复杂生物体的基本组成部分，在它们的进化中起着不可或缺的作用。模块化增强了可进化性，允许在进化过程中重组各种模块。模块组件的进化层次启动了进化过程，允许对一组复杂结构进行操作，而不是基本基因。之后，神经进化过程不需要再次从头开始进化类似的功能。相反，现成的模块组件可以作为构建块来构建非常复杂的神经网络。

在本章中，我们将使用ES-HyperNEAT算法实现视网膜问题的解决方案。视网膜问题涉及同时识别人工视网膜左侧和右侧的有效的2x2模式，该人工视网膜的分辨率为4x2。因此，检测器ANN必须决定视网膜左侧和右侧呈现的模式是否对应视网膜的相应侧（左侧或右侧）。

在视网膜问题中，左右问题组件被完美地分离到不同的功能单元中。同时，一些组件可以出现在视网膜的每一侧，而其他组件则仅限于视网膜的特定部分。因此，为了产生一个成功的检测器ANN，神经进化过程需要分别发现左右检测区域的模块结构。

视网膜问题方案如下所示：

![图片](img/6015ae45-08dd-4dcd-afcf-3af1767e3ab2.png)

视网膜问题方案

如前图所示，人工视网膜被表示为一个分辨率为4x2像素的2D网格。表示视网膜上绘制的模式的二维数组的值构成了检测器ANN的输入。数组中的填充像素的值为`1.0`，空像素的值为`0.0`。在给定的分辨率下，可以为视网膜的左右两侧绘制16种不同的2x2模式。因此，视网膜的左侧有八个有效模式，右侧也有八个有效模式。所提到的某些模式对视网膜的两侧都有效。

在视网膜问题领域中，检测器ANN的决策方案如下：

![图片](img/4a0213e3-11fc-47ec-a951-e49296ae65fc.png)

检测器ANN的决策方案

检测器人工神经网络（ANN）有八个输入来接受视网膜两边的输入数据模式，并且有两个输出节点。每个输出节点产生一个值，可以用来分类视网膜每边的模式的有效性。第一个输出节点分配给左侧，第二个节点分配给视网膜的右侧。输出节点的激活值大于或等于`0.5`时，将视网膜相关侧的模式分类为有效。如果激活值小于`0.5`，则模式被认为无效。为了进一步简化检测，我们根据图中的舍入方案对输出节点的值进行舍入。因此，检测器ANN的每个输出节点作为相关视网膜部分的二元分类器，产生`0.0`或`1.0`的值来相应地标记输入模式为无效或有效。

# 目标函数定义

检测器ANN的任务是通过产生具有`0.0`或`1.0`值的二元输出向量，正确地将视网膜左右两侧的输入分类为有效或无效。输出向量的长度为2，等于输出节点的数量。

我们可以将检测误差定义为真实值向量与ANN输出值向量之间的欧几里得距离，如下公式所示：

![图片](img/264a3ace-8838-4bf8-a668-371867d9bc28.png)

![图片](img/9132f8c9-c333-422f-a337-a3652a762eae.png)是单个试验的平方检测误差，![图片](img/75051026-cfcc-4719-9751-778e01da36aa.png)是检测器ANN的输出向量，而![图片](img/a1fbc606-d1ef-4b6e-9a30-29a33ff88b84.png)是真实值向量。

在进化的每一代中，我们评估每个检测器ANN（表型）对所有256种可能的4x4视网膜模式组合，这些模式是通过将每侧视网膜的16个不同的2x2模式组合而产生的。因此，为了得到特定检测器ANN的最终检测误差值，我们计算视网膜模式配置获得的256个误差值的总和，如下公式所示：

![图片](img/4c0370c0-7e99-48b6-a17e-607e740979a1.png)

![图片](img/653fbe3d-5f27-475f-b9c4-f46b68d9ce66.png)是256次试验期间获得的所有误差的总和，而![图片](img/debe4e93-4cab-486d-bc3e-8161c06bf4af.png)是特定试验的平方检测误差。

适应度函数可以被定义为从所有256次试验中获取的所有可能的视网膜模式误差之和的倒数，如下公式所示：

![图片](img/da755433-17e7-417d-8e5d-0cb93ed122fe.png)

我们将`1.0`加到分母中错误的和（![图片](img/bd661974-d4b9-45c8-b734-3585e3f849ef.png)）以避免在所有试验均无错误的情况下除以0。因此，根据适应度函数公式，我们实验中适应度分数的最大值为`1000.0`，我们将在稍后将其用作适应度阈值值。

# 模块化视网膜实验设置

在本节中，我们讨论了旨在创建模块化视网膜问题成功求解器的实验的细节。在我们的实验中，我们将此问题作为基准来测试ES-HyperNEAT方法在表型ANN中发现模块化拓扑结构的能力。

# 初始基底配置

如本章前面所述，视网膜的尺寸为4x2，有两个2x2区域，一个在左侧，一个在右侧。视网膜几何的细节必须在初始基底配置的几何中表示。在我们的实验中，我们使用三维基底，如下所示：

![图片](img/8a75c354-2a52-42a3-ba74-c43d033e7e8f.png)

初始基底配置

如图中所示，输入节点位于XZ平面内，该平面垂直于XY平面。它们分为两组，每组四个节点用于描述视网膜的左右两侧。两个输出和偏置节点位于XY平面内，该平面将Z平面一分为二，与输入节点相邻。基底的演变在输出节点所在的同一XY平面中创建了新的隐藏节点。演化的连接性CPPN绘制了基底内所有节点之间的连接模式。我们的最终目标是演化CPPN和基底配置，从而产生检测器ANN的适当模块化图。此图应包括两个模块，每个模块代表二进制分类器的适当配置，这是我们之前讨论过的。现在让我们看看模块化视网膜问题的测试环境。

# 模块化视网膜问题的测试环境

首先，我们需要创建一个测试环境，用于评估旨在创建成功的检测器ANN的神经进化过程的成果。测试环境应创建一个数据集，包括视网膜上所有可能的像素模式。此外，它还应提供评估检测器ANN与数据集中每个模式的功能。因此，测试环境可以分为两个主要部分：

+   用于存储视网膜左侧、右侧或两侧视觉模式的数结构

+   存储数据集并提供检测器ANN评估功能的测试环境

在以下章节中，我们提供了每个部分的详细描述。

# 视觉对象定义

视网膜空间特定部分的像素允许配置的每种配置都可以表示为一个单独的视觉对象。封装相关功能的Python类命名为`VisualObject`，并在`retina_experiment.py`文件中定义。它具有以下构造函数：

[PRE0]

构造函数接收一个特定视觉对象的配置字符串，以及该对象在视网膜空间中的有效位置。之后，它将接收到的参数分配给内部字段，并创建一个二维数据数组，用于存储视觉对象中像素的状态。

通过以下方式解析视觉对象配置字符串以获取像素的状态：

[PRE1]

视觉对象配置字符串由四个字符组成，不包括换行符，这些字符定义了视觉对象中相应像素的状态。如果配置行中特定位置的符号是`o`，则将视觉对象中相应位置的像素设置为开启状态，并将值`1.0`保存到数据数组中的该位置。

# 视网膜环境定义。

视网膜环境创建并存储由所有可能的视觉对象组成的数据集，并提供评估检测器ANN适应度的函数。它具有以下主要实现部分。

# 创建包含所有可能视觉对象的数据集的功能。

在此函数中，我们按照以下方式创建数据集的视觉对象：

[PRE2]

上述代码创建了视网膜左侧的视觉对象。右侧的视觉对象可以以类似的方式创建：

[PRE3]

创建的对象被添加到视觉对象列表中，定义为评估从基底产生的神经进化过程中检测器ANN适应度的数据集。

# 评估检测器ANN针对两个特定视觉对象的功能。

此功能评估检测器ANN针对两个给定的视觉对象（每个视觉对象对应视网膜空间的一侧）的性能。对于完整的源代码，请参阅在[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py)中定义的`def _evaluate(self, net, left, right, depth, debug=False)`函数。

函数的源代码具有以下基本部分：

1.  首先，我们按照在基底配置中定义的顺序准备检测器人工神经网络（ANN）的输入。

[PRE4]

`inputs`数组以左侧数据开始，然后继续添加右侧数据。之后，将偏差值附加到`inputs`数组的末尾，并将数组数据作为输入提供给检测器ANN。

1.  在检测器ANN激活特定次数之后，获得输出并四舍五入。

[PRE5]

1.  接下来，我们需要计算平方检测错误，这是输出向量与真实值向量之间的欧几里得距离。因此，我们首先创建以下具有真实值的向量：

[PRE6]

如果视觉对象对于视网膜的给定侧面或两侧都是有效的，则将相应的真实值设置为`1.0`。否则，将其设置为`0.0`以指示视觉对象位置不正确。

1.  最后，计算平方检测错误如下：

[PRE7]

该函数返回检测错误和检测器ANN的输出。在下一节中，我们将讨论视网膜实验运行器的实现。

对于完整的实现细节，请参阅[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py)中的`retina_environment.py`文件。

# 实验运行器

为了解决模块化视网膜问题，我们需要使用一个提供ES-HyperNEAT算法实现的Python库。如果你已经阅读了上一章，你应该已经熟悉了MultiNEAT Python库，它也实现了ES-HyperNEAT算法。因此，我们可以使用这个库来创建视网膜实验运行器的实现。

让我们讨论实现中的基本组件。

对于完整的实现细节，请参阅[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_experiment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_experiment.py)中的`retina_experiment.py`文件。

# 实验运行器函数

`run_experiment`函数使用提供的超参数和一个初始化的测试环境来运行实验，评估发现的检测器ANN相对于可能的视网膜配置。函数实现具有以下显著部分：

1.  首先是初始化初始CPPN基因组的种群：

[PRE8]

首先，前面的代码将随机种子值设置为我们在通过顺序运行许多实验试验以生成成功解决方案时发现的有用值。之后，我们创建适合视网膜实验的底物配置，考虑到视网膜空间的几何形状。

接下来，我们使用已有的底物配置创建初始CPPN基因组。CPPN基因组需要具有与底物配置兼容的输入和输出节点数。此外，我们使用具有高斯激活函数的两个隐藏节点初始化初始CPPN基因组，以正确方向促进神经进化过程。高斯隐藏节点以偏向产生特定检测器ANN拓扑结构的方式开始神经进化搜索。通过这些隐藏节点，我们将对称性原则引入底物的连接模式中，这正是我们期望在成功检测器ANN拓扑结构中实现的。对于视网膜问题，我们需要发现一个包含两个对称分类模块的对称检测器ANN配置。

1.  接下来，我们准备中间变量来保存实验执行结果以及统计收集器。之后，我们运行进化循环，进行一定数量的代数：

[PRE9]

1.  在进化循环内部，我们获取当前种群中属于当前种群的基因组列表，并按照以下方式对其进行测试环境评估：

[PRE10]

`eval_genomes`函数返回一个元组，包含以下组件：最佳拟合基因组、所有评估基因组的最高适应度分数以及每个评估基因组的检测错误列表。我们将适当的参数保存到统计收集器中，并将获得的适应度分数与搜索终止标准进行比较，该标准定义为`FITNESS_THRESHOLD`常量，其值为`1000.0`。如果种群中的最佳适应度分数大于或等于`FITNESS_THRESHOLD`值，进化搜索将成功终止。

1.  如果找到了成功的解决方案，或者当前种群的最佳适应度分数高于之前达到的最高适应度分数，我们将按照以下方式保存最佳CPPN基因组和当前适应度分数：

[PRE11]

1.  之后，如果`solution_found`变量的值被设置为`True`，我们将终止进化循环：

[PRE12]

1.  如果进化未能产生成功的解决方案，我们将打印当前代的统计数据，并移动到下一个时代：

[PRE13]

实验运行器代码的其余部分以不同的格式报告实验结果。

1.  我们使用进化循环中收集的统计数据，以文本和视觉格式报告实验结果。此外，可视化结果也以SVG矢量格式保存到本地文件系统中：

[PRE14]

代码的前三行打印了关于实验执行的通用统计数据，例如达到的最高适应度分数、实验执行所花费的时间以及随机生成器的种子值。

1.  代码的下一部分是关于可视化实验结果，这是最有信息量的部分，你应该特别注意。我们从可视化在进化过程中找到的最佳基因组创建的CPPN网络开始：

[PRE15]

1.  之后，我们可视化使用最佳CPPN基因组和视网膜基板创建的检测器ANN拓扑结构：

[PRE16]

1.  此外，我们还打印了前述代码创建的检测器ANN对完整数据集和两个随机选择的视觉对象的评估结果：

[PRE17]

最后，我们将实验期间收集的统计数据以如下方式呈现：

[PRE18]

这里提到的所有可视化图表都可以在本地文件系统的 `trial_out_dir` 目录中实验执行后找到。现在，让我们讨论基板构建函数的实现。

# 基板构建函数

ES-HyperNEAT方法运行神经进化过程，这包括CPPN基因组的进化以及基板配置的进化。然而，尽管基板在进化过程中也在进化，但从一个适当的初始基板配置开始是非常有益的。这个配置应该对应于问题空间的几何形状。

对于视网膜实验，适当的基板配置创建如下：

1.  首先，我们创建基板输入层的配置。如您在“*初始基板配置*”部分所记得，输入层的八个节点放置在XZ平面内，该平面垂直于XY平面。此外，为了反映视网膜空间的几何形状，左侧对象的节点需要放置在平面的左侧，右侧对象的节点相应地放置在平面的右侧。偏置节点应位于输入节点平面的中心。因此，输入层创建如下：

[PRE19]

两个输出节点位于XY平面内，该平面垂直于输入平面。这种基板配置通过将发现的隐藏节点放置在XY平面内，允许基板自然进化。

1.  输出层创建如下：

[PRE20]

1.  接下来，我们定义基板的一般配置参数如下：

[PRE21]

我们允许基板从输入到隐藏层、隐藏层到隐藏层以及隐藏层到输出节点之间有连接。我们指定隐藏节点应使用带符号的Sigmoid激活函数，而输出节点应使用无符号的Sigmoid激活函数。我们选择无符号的Sigmoid激活函数用于输出节点，以便检测器ANN的输出值在范围 `[0,1]` 内。

在下一节中，我们将讨论评估解决方案适应性的函数实现。

# 适应性评估

神经进化过程需要一种方法来评估每一代进化中基因组群体的适应性。在我们的实验中，适应性评估包括两个部分，我们在这里进行讨论。

# `eval_genomes` 函数

此函数评估整体群体的适应性。它具有以下定义：

[PRE22]

`eval_genomes`函数接受当前种群中的CPPN基因组列表、底物配置、初始化的测试环境和ES-HyperNEAT超参数作为参数。

在代码的开始部分，我们创建一个中间对象来收集每个特定基因组的评估结果：

[PRE23]

之后，我们开始循环遍历所有基因组，并对每个基因组进行给定测试环境的评估：

[PRE24]

最后，函数返回一个元组，其中包含最佳基因组、最高适应度分数以及每个评估基因组的所有检测错误列表。

# `eval_individual`函数

此函数评估每个个体的适应度，其定义如下：

[PRE25]

它接受要评估的CPPN基因组、底物配置、测试环境和ES-HyperNEAT超参数作为参数。使用提供的参数，我们创建检测器ANN的神经网络配置，并对其在给定的测试环境中进行评估。然后，该函数返回评估结果。

# 模块化视网膜实验

现在，我们准备开始针对模拟模块化视网膜问题空间的测试环境进行实验。在接下来的小节中，你将了解如何选择合适的超参数以及如何设置环境和运行实验。之后，我们将讨论实验结果。

# 超参数选择

超参数定义为`Parameters` Python类，MultiNEAT库引用它以获取必要的配置选项。在实验运行脚本源代码中，我们定义了一个名为`create_hyperparameters`的专用函数，它封装了超参数初始化的逻辑。以下，我们将描述最关键的超参数以及选择这些特定值的原因：

1.  我们决定使用中等大小的CPPN基因组种群。这样做是为了通过从一开始就提供大量解决方案搜索选项来增强进化。种群的大小定义如下：

[PRE26]

1.  接下来，我们在`[5,15]`范围内定义在进化过程中要保留的物种数量，并将物种停滞设置为`100`代。这种配置使我们能够在物种之间保持健康的多样性，并让它们存活足够长的时间，以产生我们正在寻找的解决方案：

[PRE27]

1.  我们对生成一个非常紧凑的CPPN基因组配置感兴趣。因此，我们为控制新节点和连接在基因组中引入的频率设置了非常小的概率值：

[PRE28]

1.  ES-HyperNEAT方法是HyperNEAT方法的一个扩展。因此，在进化过程中，它会改变隐藏和输出节点中激活函数的类型。在这个实验中，为了产生适当的底物配置，我们对以下激活类型感兴趣，这些类型以相等的概率被选中：

[PRE29]

1.  最后，我们定义了 ES-HyperNEAT 特定的超参数，这些参数控制着基质的进化方式。以下超参数控制着在进化过程中，基质内节点和连接创建的动态：

[PRE30]

`params.DivisionThreshold` 控制在每一代进化中引入基质的新节点和连接的数量。`params.VarianceThreshold` 确定在修剪和提取阶段后允许保留在基质中的节点和连接的数量。有关这些阈值的更多详细信息，请参阅 *Quadtree 信息提取和 ES-HyperNEAT 基础* 部分。

# 工作环境设置

在这个实验中，我们使用提供 ES-HyperNEAT 算法实现的 MultiNEAT Python 库。因此，我们需要创建一个适当的 Python 环境，其中包括 MultiNEAT Python 库和所有必要的依赖项。这可以通过在命令行中执行以下命令来完成：

[PRE31]

这些命令创建并激活了 Python 3.5 的 `rt_multineat` 虚拟环境。之后，它们安装了最新版本的 MultiNEAT Python 库，以及我们代码用于结果可视化的依赖项。

# 运行模块化视网膜实验

在这个阶段，我们已经在 `retina_experiment.py` Python 脚本中完全定义了实验运行脚本。你可以通过克隆相应的 Git 仓库并运行以下命令来开始实验：

[PRE32]

不要忘记使用以下命令激活适当的虚拟环境：

**`conda activate rt_multineat`**

前面的命令开始了一个实验，该实验进行了 1,000 代进化的试验。在特定的代数之后，应该找到成功的解决方案，你将在控制台看到以下输出：

[PRE33]

如你在输出中看到的那样，成功的解决方案是在第 `949` 代找到的。它是由一个具有 21 个节点和 22 个节点之间连接的 CPPN 基因组产生的。同时，确定检测器 ANN 拓扑结构的基质有 15 个节点和它们之间的 28 个连接。成功的解决方案是使用随机种子值 `1569777981` 产生的。使用其他随机种子值可能无法产生成功的解决方案，或者它将需要更多代的进化。

接下来，观察进化过程中的平均适应度和误差的图表是很有趣的：

![](img/cbf8d9e1-8200-4f88-816c-a7fa49166931.png)

每代的平均适应度和误差

你可以在前面的图表中看到，在大多数进化代数中，适应度得分非常小（大约为 20），但突然，找到了成功的 CPPN 基因组，它仅在一代内产生了立即的进化飞跃。

成功的 CPPN 基因组的配置如下所示：

![](img/3f032f44-2073-4c2d-b375-9b60f090b918.png)

成功基因的CPPN表型图

该图非常有趣，因为，正如你所看到的，成功的CPPN基因配置没有使用所有可用的输入（灰色方块）来产生输出。更重要的是，它甚至更加令人困惑，因为它在决定是否在这些基底层节点之间暴露连接时，只使用了输入（节点#0）的*x*坐标和隐藏（节点#3）基底层节点的*y*坐标。同时，基底层输出节点的*x*和*y*坐标都参与了决策过程（节点#4和#5）。

当你查看我们之前提出的初始基底层配置时，你会发现我们提到的特性完全由基底层拓扑结构证实。我们将输入节点放置在XZ平面内。因此，对于它们来说，*y*坐标根本不重要。同时，位于XY平面内的隐藏节点，*y*坐标决定了从输入平面到节点的距离。最后，输出节点也位于XY平面内。它们的*x*坐标决定了每个输出节点相关的视网膜侧面。因此，对于输出节点来说，自然地，*x*和*y*坐标都包含在内。

在CPPN表型图中，输入节点用方块标记，输出节点用实心圆圈标记，偏置节点用菱形标记，隐藏节点用空心圆圈标记。

CPPN图中两个输出节点有以下含义：

+   第一个节点（8）提供了连接的权重。

+   第二个节点（9）确定连接是否表达。

CPPN的输入节点定义为以下：

+   前两个节点（0和1）设置了基底层输入层中的点坐标（*x*，*z*）。

+   接下来的两个节点（2和3）设置了基底层隐藏层中的点坐标（*x*，*y*）。

+   接下来的两个节点（4和5）设置了基底层输出层中的点坐标（*x*，*y*）。

+   最后一个节点（6）设置了输入层中点与坐标原点的欧几里得距离。

然而，你可以在下面的图中看到实验结果中最激动人心的部分。它代表了成功检测器ANN的配置：

![图片](img/ed3cd3e3-ba05-4ea1-9434-257132dfc46b.png)

检测器ANN的配置

与之前的图表一样，我们用方块标记输入节点，用实心圆圈标记输出节点，用菱形标记偏置节点，用空心圆圈标记隐藏节点。

正如你所见，我们在图的左右两侧有两个明显分离的模块化结构。每个模块都与视网膜左侧（节点#0、#1、#2和#3）和右侧（节点#4、#5、#6和#7）的相应输入相连。两个模块具有相同数量的隐藏节点，这些节点连接到相应的输出节点：视网膜左侧的节点#9和右侧的节点#10。你还可以看到左右模块的连接模式相似。左侧的隐藏节点#11具有与右侧节点#14相似的连接模式，同样，节点#12和#13也是如此。

真是令人惊叹，随机进化过程能够发现如此简单而优雅的解决方案。通过这个实验的结果，我们完全证实了我们的假设，即视网膜问题可以通过创建模块化检测ANN拓扑结构来解决。

更多关于模块化视网膜问题的详细信息可以在原始论文[http://eplex.cs.ucf.edu/papers/risi_alife12.pdf](http://eplex.cs.ucf.edu/papers/risi_alife12.pdf)中找到。

# 练习

1.  尝试运行一个实验，改变`retina_experiment.py`脚本中第101行可以更改的随机种子生成器的不同值。看看你是否可以用其他值找到成功的解决方案。

1.  尝试通过调整`params.PopulationSize`超参数的值将初始种群大小增加到1,000。这如何影响了算法的性能？

1.  尝试通过将选择概率设置为0来改变在进化过程中使用的激活函数类型的数量。当排除`ActivationFunction_SignedGauss_Prob`和`ActivationFunction_SignedStep_Prob`激活类型时，观察会发生什么特别有趣。

# 摘要

在本章中，我们学习了神经进化方法，该方法允许在寻找问题解决方案的过程中使底物配置进化。这种方法使人类设计师从创建适合的最小细节的底物配置的负担中解放出来，使我们能够仅定义主要轮廓。算法将在进化过程中自动学习底物配置的剩余细节。

此外，你学习了可以使用模块化人工神经网络结构来解决各种问题，包括模块化视网膜问题。模块化ANN拓扑结构是一个非常强大的概念，它允许多次重用成功的表型ANN模块来构建复杂的分层拓扑。此外，你还有机会通过使用MultiNEAT Python库实现相应的解决方案来磨练你的Python编程技能。

在下一章中，我们将讨论协同进化的迷人概念以及如何将其用于同时协同进化用于优化的求解器和目标函数。我们将讨论解决方案和适应度演化的方法，并教会你如何将其应用于修改后的迷宫求解实验。
