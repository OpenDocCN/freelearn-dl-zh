["```py\nusing UnityEngine; \nusing System.Collections; \n\n[System.Serializable] \npublic abstract class Node { \n\n    /* Delegate that returns the state of the node.*/ \n    public delegate NodeStates NodeReturn(); \n\n    /* The current state of the node */ \n    protected NodeStates m_nodeState; \n\n    public NodeStates nodeState { \n        get { return m_nodeState; } \n    } \n\n    /* The constructor for the node */ \n    public Node() {} \n\n    /* Implementing classes use this method to evaluate the desired set of conditions */ \n    public abstract NodeStates Evaluate(); \n\n} \n```", "```py\nusing UnityEngine; \nusing System.Collections; \nusing System.Collections.Generic; \n\npublic class Selector : Node { \n    /** The child nodes for this selector */ \n    protected List<Node> m_nodes = new List<Node>(); \n\n    /** The constructor requires a lsit of child nodes to be  \n     * passed in*/ \n    public Selector(List<Node> nodes) { \n        m_nodes = nodes; \n    } \n\n    /* If any of the children reports a success, the selector will \n     * immediately report a success upwards. If all children fail, \n     * it will report a failure instead.*/ \n    public override NodeStates Evaluate() { \n        foreach (Node node in m_nodes) { \n            switch (node.Evaluate()) { \n                case NodeStates.FAILURE: \n                    continue; \n                case NodeStates.SUCCESS: \n                    m_nodeState = NodeStates.SUCCESS; \n                    return m_nodeState; \n                case NodeStates.RUNNING: \n                    m_nodeState = NodeStates.RUNNING; \n                    return m_nodeState; \n                default: \n                    continue; \n            } \n        } \n        m_nodeState = NodeStates.FAILURE; \n        return m_nodeState; \n    } \n} \n```", "```py\nusing UnityEngine; \nusing System.Collections; \nusing System.Collections.Generic; \n\npublic class Sequence : Node { \n    /** Children nodes that belong to this sequence */ \n    private List<Node> m_nodes = new List<Node>(); \n\n    /** Must provide an initial set of children nodes to work */ \n    public Sequence(List<Node> nodes) { \n        m_nodes = nodes; \n    } \n\n    /* If any child node returns a failure, the entire node fails. Whence all  \n     * nodes return a success, the node reports a success. */ \n    public override NodeStates Evaluate() { \n        bool anyChildRunning = false; \n\n        foreach(Node node in m_nodes) { \n            switch (node.Evaluate()) { \n                case NodeStates.FAILURE: \n                    m_nodeState = NodeStates.FAILURE; \n                    return m_nodeState;                     \n                case NodeStates.SUCCESS: \n                    continue; \n                case NodeStates.RUNNING: \n                    anyChildRunning = true; \n                    continue; \n                default: \n                    m_nodeState = NodeStates.SUCCESS; \n                    return m_nodeState; \n            } \n        } \n        m_nodeState = anyChildRunning ? NodeStates.RUNNING : NodeStates.SUCCESS; \n        return m_nodeState; \n    } \n} \n```", "```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class Inverter : Node { \n    /* Child node to evaluate */ \n    private Node m_node; \n\n    public Node node { \n        get { return m_node; } \n    } \n\n    /* The constructor requires the child node that this inverter decorator \n     * wraps*/ \n    public Inverter(Node node) { \n        m_node = node; \n    } \n\n    /* Reports a success if the child fails and \n     * a failure if the child succeeds. Running will report \n     * as running */ \n    public override NodeStates Evaluate() { \n        switch (m_node.Evaluate()) { \n            case NodeStates.FAILURE: \n                m_nodeState = NodeStates.SUCCESS; \n                return m_nodeState; \n            case NodeStates.SUCCESS: \n                m_nodeState = NodeStates.FAILURE; \n                return m_nodeState; \n            case NodeStates.RUNNING: \n                m_nodeState = NodeStates.RUNNING; \n                return m_nodeState; \n        } \n        m_nodeState = NodeStates.SUCCESS; \n        return m_nodeState; \n    } \n}\n```", "```py\nusing System; \nusing UnityEngine; \nusing System.Collections; \n\npublic class ActionNode : Node { \n    /* Method signature for the action. */ \n    public delegate NodeStates ActionNodeDelegate(); \n\n    /* The delegate that is called to evaluate this node */ \n    private ActionNodeDelegate m_action; \n\n    /* Because this node contains no logic itself, \n     * the logic must be passed in in the form of  \n     * a delegate. As the signature states, the action \n     * needs to return a NodeStates enum */ \n    public ActionNode(ActionNodeDelegate action) { \n        m_action = action; \n    } \n\n    /* Evaluates the node using the passed in delegate and  \n     * reports the resulting state as appropriate */ \n    public override NodeStates Evaluate() { \n        switch (m_action()) { \n            case NodeStates.SUCCESS: \n                m_nodeState = NodeStates.SUCCESS; \n                return m_nodeState; \n            case NodeStates.FAILURE: \n                m_nodeState = NodeStates.FAILURE; \n                return m_nodeState; \n            case NodeStates.RUNNING: \n                m_nodeState = NodeStates.RUNNING; \n                return m_nodeState; \n            default: \n                m_nodeState = NodeStates.FAILURE; \n                return m_nodeState; \n        } \n    } \n} \n```", "```py\nusing UnityEngine; \nusing UnityEngine.UI; \nusing System.Collections; \nusing System.Collections.Generic; \n\npublic class MathTree : MonoBehaviour { \n    public Color m_evaluating; \n    public Color m_succeeded; \n    public Color m_failed; \n\n    public Selector m_rootNode; \n\n    public ActionNode m_node2A; \n    public Inverter m_node2B; \n    public ActionNode m_node2C; \n    public ActionNode m_node3; \n\n    public GameObject m_rootNodeBox; \n    public GameObject m_node2aBox; \n    public GameObject m_node2bBox; \n    public GameObject m_node2cBox; \n    public GameObject m_node3Box; \n\n    public  int m_targetValue = 20; \n    private int m_currentValue = 0; \n\n    [SerializeField] \n    private Text m_valueLabel; \n```", "```py\n    /* We instantiate our nodes from the bottom up, and assign the children \n     * in that order */ \n   void Start () { \n        /** The deepest-level node is Node 3, which has no children. */ \n        m_node3 = new ActionNode(NotEqualToTarget); \n\n        /** Next up, we create the level 2 nodes. */ \n        m_node2A = new ActionNode(AddTen); \n\n        /** Node 2B is a selector which has node 3 as a child, so we'll pass  \n         * node 3 to the constructor */ \n        m_node2B = new Inverter(m_node3); \n\n        m_node2C = new ActionNode(AddTen); \n\n        /** Lastly, we have our root node. First, we prepare our list of children \n         * nodes to pass in */ \n        List<Node> rootChildren = new List<Node>(); \n        rootChildren.Add(m_node2A); \n        rootChildren.Add(m_node2B); \n        rootChildren.Add(m_node2C); \n\n        /** Then we create our root node object and pass in the list */ \n        m_rootNode = new Selector(rootChildren); \n\n        m_valueLabel.text = m_currentValue.ToString(); \n\n        m_rootNode.Evaluate(); \n\n        UpdateBoxes(); \n   }\n```", "```py\nprivate void UpdateBoxes() { \n        /** Update root node box */ \n        if (m_rootNode.nodeState == NodeStates.SUCCESS) { \n            SetSucceeded(m_rootNodeBox); \n        } else if (m_rootNode.nodeState == NodeStates.FAILURE) { \n            SetFailed(m_rootNodeBox); \n        } \n\n        /** Update 2A node box */ \n        if (m_node2A.nodeState == NodeStates.SUCCESS) { \n            SetSucceeded(m_node2aBox); \n        } else if (m_node2A.nodeState == NodeStates.FAILURE) { \n            SetFailed(m_node2aBox); \n        } \n\n        /** Update 2B node box */ \n        if (m_node2B.nodeState == NodeStates.SUCCESS) { \n            SetSucceeded(m_node2bBox); \n        } else if (m_node2B.nodeState == NodeStates.FAILURE) { \n            SetFailed(m_node2bBox); \n        } \n\n        /** Update 2C node box */ \n        if (m_node2C.nodeState == NodeStates.SUCCESS) { \n            SetSucceeded(m_node2cBox); \n        } else if (m_node2C.nodeState == NodeStates.FAILURE) { \n            SetFailed(m_node2cBox); \n        } \n\n        /** Update 3 node box */ \n        if (m_node3.nodeState == NodeStates.SUCCESS) { \n            SetSucceeded(m_node3Box); \n        } else if (m_node3.nodeState == NodeStates.FAILURE) { \n            SetFailed(m_node3Box); \n        } \n    } \n```", "```py\nprivate NodeStates NotEqualToTarget() {         \n        if (m_currentValue != m_targetValue) { \n            return NodeStates.SUCCESS; \n        } else { \n            return NodeStates.FAILURE; \n        } \n    } \n\n    private NodeStates AddTen() { \n        m_currentValue += 10; \n        m_valueLabel.text = m_currentValue.ToString(); \n        if (m_currentValue == m_targetValue) { \n            return NodeStates.SUCCESS; \n        } else { \n            return NodeStates.FAILURE; \n        } \n    } \n```", "```py\npublic enum NodeStates { \n    SUCCESS, \n    FAILURE, \n    RUNNING, \n} \n```", "```py\nusing UnityEngine;\n\npublic class Game : MonoBehaviour {\n    [SerializeField]\n    private Animator stateMachine;\n    [SerializeField]\n    private PlayerController playerController;\n    [SerializeField]\n    private EnemyBehaviorTree enemyBehaviorTree;\n    [SerializeField]\n    private Player humanPlayer;\n    [SerializeField]\n    private Player aiPlayer;\n    [SerializeField]\n    private UIController uiController;\n    private int turn = 0;\n\n    private void Awake() {\n        enemyBehaviorTree.SetPlayerData(humanPlayer, aiPlayer);\n        enemyBehaviorTree.onTreeExecuted += EndTurn;\n        playerController.onActionExecuted += EndTurn;\n    }\n\n    public void EvaluateAITree() {\n        enemyBehaviorTree.Evaluate(); \n    }\n\n    private void EndTurn() {\n        if(humanPlayer.CurrentHealth <= 0 || aiPlayer.CurrentHealth <= 0) {\n            stateMachine.SetTrigger(\"EndGame\");\n            uiController.EndGame();\n            return;\n        }\n        stateMachine.SetTrigger(\"EndTurn\");\n        turn ^= 1;\n        uiController.SetTurn(turn);\n    }\n}\n```", "```py\nusing UnityEngine;\n\npublic class Player : MonoBehaviour {\n    [SerializeField]\n    private int maxHealth = 20;\n\n    [SerializeField]\n    private int currentHealth;\n\n    [SerializeField]\n    private int lowHealthThreshold = 7;\n\n    [Header(\"Ability Parameters\")]\n    private int minHealAmount = 2;\n    private int maxHealAmount = 5;\n\n    private int minDamage = 2;\n    private int maxDamage = 5;\n\n    private bool isBuffed = false;\n\n    public int CurrentHealth {\n        get { return currentHealth; }\n    }\n\n    public bool IsBuffed {\n        get { return isBuffed; }\n    }\n\n    public bool HasLowHealth {\n        get { return currentHealth < lowHealthThreshold; }\n    }\n\n    private void Awake() {\n        currentHealth = maxHealth;\n    }\n\n    public bool Buff() {\n        isBuffed = true;\n        return isBuffed;\n    }\n\n    public int Heal() {\n        int healAmount = Random.Range(minHealAmount, maxHealAmount);\n        currentHealth += healAmount;\n        return currentHealth;\n    }\n\n    public int Damage() {\n        int damageAmount = Random.Range(minDamage, maxDamage);\n        if(isBuffed) {\n            damageAmount /= 2;\n            isBuffed = false;\n        } \n        currentHealth -= damageAmount;\n        return currentHealth;\n    }\n}\n```", "```py\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class PlayerController : MonoBehaviour {\n    [SerializeField]\n    private Player ownData;\n    [SerializeField]\n    private Player enemyData;\n\n    [Header(\"Buttons\")]\n    [SerializeField]\n    private Button defendButton;\n    [SerializeField]\n    private Button healButton;\n    [SerializeField]\n    private Button attackButton;\n\n    public delegate void ActionExecuted();\n    public event ActionExecuted onActionExecuted;\n\n  void Awake () {\n        defendButton.onClick.AddListener(Defend);\n        healButton.onClick.AddListener(Heal);\n        attackButton.onClick.AddListener(Attack);\n  }\n\n    private void Attack() {\n        enemyData.Damage();\n        EndTurn();\n    }\n\n    private void Heal() {\n        ownData.Heal();\n        EndTurn();\n    }\n\n    private void Defend() {\n        ownData.Buff();\n        EndTurn();\n    }\n\n    private void EndTurn() {\n        if(onActionExecuted != null) {\n            onActionExecuted();\n        }\n    }\n}\n```", "```py\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class EnemyBehaviorTree : MonoBehaviour {\n\n    private Player playerData; \n    private Player ownData;\n\n    public RandomBinaryNode buffCheckRandomNode;\n    public ActionNode buffCheckNode;\n    public ActionNode healthCheckNode;\n    public ActionNode attackCheckNode;\n    public Sequence buffCheckSequence;\n    public Selector rootNode;\n```", "```py\nusing UnityEngine;\n\npublic class RandomBinaryNode : Node {\n    public override NodeStates Evaluate() {\n        var roll = Random.Range(0, 2);\n        return (roll == 0 ? NodeStates.SUCCESS : NodeStates.FAILURE);\n    }\n}\n```", "```py\npublic delegate void TreeExecuted();\npublic event TreeExecuted onTreeExecuted;\n```", "```py\nvoid Start () { \n    healthCheckNode = new ActionNode(CriticalHealthCheck);\n\n    attackCheckNode = new ActionNode(CheckPlayerHealth);\n\n    buffCheckRandomNode = new RandomBinaryNode();\n    buffCheckNode = new ActionNode(BuffCheck);\n    buffCheckSequence = new Sequence(new List<Node> {\n        buffCheckRandomNode,\n        buffCheckNode,\n    });\n\n    rootNode = new Selector(new List<Node> {\n        healthCheckNode,\n        attackCheckNode,\n        buffCheckSequence,\n    });\n}\n```", "```py\nprivate NodeStates CriticalHealthCheck() {\n    if(ownData.HasLowHealth) {\n        return NodeStates.SUCCESS;\n    } else {\n        return NodeStates.FAILURE;\n    }\n}\n```", "```py\nprivate NodeStates CheckPlayerHealth() {\n    if(playerData.HasLowHealth) {\n        return NodeStates.SUCCESS;\n    } else {\n        return NodeStates.FAILURE;\n    }\n}\n```", "```py\nprivate NodeStates BuffCheck() {\n    if(!ownData.IsBuffed) {\n        return NodeStates.SUCCESS;\n    } else {\n        return NodeStates.FAILURE;\n    }\n}\n```", "```py\nprivate IEnumerator Execute() {\n    Debug.Log(\"The AI is thinking...\");\n    yield return new WaitForSeconds(2.5f);\n\n    if(healthCheckNode.nodeState == NodeStates.SUCCESS) {\n        Debug.Log(\"The AI decided to heal itself\");\n        ownData.Heal();\n    } else if(attackCheckNode.nodeState == NodeStates.SUCCESS) {\n        Debug.Log(\"The AI decided to attack the player!\");\n        playerData.Damage();\n    } else if (buffCheckSequence.nodeState == NodeStates.SUCCESS) {\n        Debug.Log(\"The AI decided to defend itself\");\n        ownData.Buff();\n    } else {\n        Debug.Log(\"The AI finally decided to attack the player\");\n        playerData.Damage();\n    }\n    if(onTreeExecuted != null) {\n        onTreeExecuted();\n    }\n}\n```", "```py\noverride public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {\n    Debug.Log(\"********************* \\n Strating the enemy's turn!\");\n    animator.gameObject.GetComponent<Game>().EvaluateAITree();\n}\n```", "```py\noverride public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {\n    Debug.Log(\"Ending the enemy's turn. \\n *********************\");\n}\n```"]