- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Exploring Advanced Knowledge Graph Capabilities with Neo4j
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Neo4j 探索高级知识图谱功能
- en: By building on the foundational knowledge from the previous chapter, where we
    introduced basic search functionalities, we will now explore more sophisticated
    techniques for knowledge exploration, graph reasoning, and performance optimization.
    In this chapter, we will utilize the advanced capabilities of Neo4j, focusing
    on integrating these capabilities with Haystack to create a more intelligent,
    AI-powered search system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在前一章建立的基础知识，其中我们介绍了基本的搜索功能，我们现在将探索更复杂的知识探索、图推理和性能优化技术。在本章中，我们将利用 Neo4j 的高级功能，重点关注将这些功能与
    Haystack 集成，以创建一个更智能、AI 驱动的搜索系统。
- en: By the end of this chapter, you will be able to unlock deeper insights from
    your knowledge graph, leverage advanced search functionalities, and ensure your
    AI-powered search system is both performant and sustainable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够从您的知识图谱中解锁更深入的见解，利用高级搜索功能，并确保您的 AI 驱动的搜索系统既高效又可持续。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring advanced Haystack functionalities for knowledge exploration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索高级 Haystack 功能以进行知识探索
- en: Graph reasoning with Haystack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Haystack 进行图推理
- en: Scaling your Haystack and Neo4j integration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展您的 Haystack 和 Neo4j 集成
- en: Best practices for maintaining and monitoring your AI-powered search system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护和监控您的 AI 驱动的搜索系统的最佳实践
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before diving into this chapter, ensure that your development environment is
    set up with the necessary technologies and tools. Also, your Neo4j instance should
    be loaded with the data from `Ch4` and embeddings from `Ch5`. Here are the technical
    requirements for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本章内容之前，请确保您的开发环境已设置好必要的技术和工具。此外，您的 Neo4j 实例应加载了来自 `Ch4` 的数据和来自 `Ch5` 的嵌入。以下是本章的技术要求：
- en: '**Neo4j (v5.x or higher)**: You will need Neo4j installed and running on your
    local machine or server. You can download it from [https://neo4j.com/download/](https://neo4j.com/download/).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j (v5.x 或更高版本)**: 您需要在您的本地机器或服务器上安装并运行 Neo4j。您可以从 [https://neo4j.com/download/](https://neo4j.com/download/)
    下载它。'
- en: '**Haystack (v1.x)**: We will be using the Haystack framework for integrating
    AI-powered search capabilities. Make sure to install Haystack by following the
    instructions at [https://docs.haystack.deepset.ai/docs/installation](https://docs.haystack.deepset.ai/docs/installation).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Haystack (v1.x)**: 我们将使用 Haystack 框架来集成 AI 驱动的搜索功能。请确保按照 [https://docs.haystack.deepset.ai/docs/installation](https://docs.haystack.deepset.ai/docs/installation)
    中的说明安装 Haystack。'
- en: '**Python (v3.8 or higher)**: Ensure that you have Python installed. You can
    download it from [https://www.python.org/downloads/](https://www.python.org/downloads/).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python (v3.8 或更高版本)**: 确保您已安装 Python。您可以从 [https://www.python.org/downloads/](https://www.python.org/downloads/)
    下载它。'
- en: '**OpenAI API key**: To successfully generate embeddings using GPT-based models,
    you will need an OpenAI API key:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAI API 密钥**: 要成功使用基于 GPT 的模型生成嵌入，您需要一个 OpenAI API 密钥：'
- en: Obtain the API Key by signing up for an account at OpenAI ([https://platform.openai.com/signup](https://platform.openai.com/signup))
    if you do not have one
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您还没有，请在 OpenAI ([https://platform.openai.com/signup](https://platform.openai.com/signup))
    上注册账户以获取 API 密钥
- en: '**Note**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A free-tier API key will not work for most use cases in this project. You will
    need an active paid OpenAI subscription to access the necessary endpoints and
    usage limits.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 免费层 API 密钥在本项目的多数用例中都不会工作。您需要一个有效的付费 OpenAI 订阅来访问必要的端点和使用限制。
- en: Once logged in, navigate to the API Keys section ([https://platform.openai.com/api-keys](https://platform.openai.com/api-keys))
    in your OpenAI dashboard and generate a new API key
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录后，导航到您的 OpenAI 控制台中的 API 密钥部分 ([https://platform.openai.com/api-keys](https://platform.openai.com/api-keys))
    并生成一个新的 API 密钥
- en: If you have followed the setup from the previous chapters, you can skip these
    requirements, as they will have already been installed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经遵循了前几章的设置，您可以跳过这些要求，因为它们已经安装好了。
- en: 'All the code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch6](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch6).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch6](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch6)。
- en: This folder contains all the necessary scripts, files, and configurations required
    to implement the Neo4j and Haystack integration with advanced knowledge graph
    capabilities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含实现Neo4j和Haystack集成以及高级知识图谱功能所需的所有必要脚本、文件和配置。
- en: Make sure to clone or download the repository so you can follow along with the
    code examples throughout this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保克隆或下载存储库，以便您可以在本章中跟随代码示例。
- en: Exploring advanced Haystack functionalities for knowledge exploration
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索高级Haystack功能以进行知识探索
- en: In this section, we will dive into more advanced search capabilities using Haystack.
    You integrated embeddings into your Neo4j graph in [*Chapter 5*](Chapter_03.xhtml#_idTextAnchor021).
    It is now time to explore how to enhance search beyond basic similarity matching.
    The goal here is to move from simple retrieval-based embeddings to a more nuanced,
    multi-layered exploration of knowledge in your graph.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨使用Haystack的更高级搜索功能。您在[*第五章*](Chapter_03.xhtml#_idTextAnchor021)中集成了嵌入到Neo4j图中。现在是时候探索如何超越基本的相似度匹配来增强搜索了。这里的目的是从简单的基于检索的嵌入转向对图中知识的更细致、多层次的探索。
- en: We will explore techniques such as context-based reasoning and optimizing your
    search functionalities for specific use cases to deliver highly relevant and intelligent
    results.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨诸如基于上下文的推理和针对特定用例优化搜索功能以提供高度相关和智能结果的技术。
- en: Let us first talk about context-based reasoning.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先谈谈基于上下文的推理。
- en: Context-aware search
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于上下文的搜索
- en: Now, we will build on the embedding-based approach in the *Connecting Haystack
    to Neo4j for advanced vector search* section of the previous chapter, by integrating
    multi-hop reasoning across the Neo4j graph with Haystack’s similarity search capabilities.
    This approach allows the search engine to traverse multiple relationships between
    nodes while utilizing advanced AI-based retrieval methods. Instead of simply retrieving
    nodes or documents based on direct matches, we will leverage Haystack to explore
    paths between related nodes, adding layers of context and uncovering deeper insights.
    This combination of graph-based reasoning and similarity understanding enables
    more intelligent and relevant search results.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在前一章的*将Haystack连接到Neo4j进行高级向量搜索*部分的基础上构建基于嵌入的方法，通过将多跳推理集成到Neo4j图和Haystack的相似度搜索功能中。这种方法允许搜索引擎在利用基于AI的高级检索方法的同时遍历节点之间的多个关系。我们不会仅仅根据直接匹配检索节点或文档，而是利用Haystack探索相关节点之间的路径，增加层次化的上下文并揭示更深入的见解。这种基于图推理和相似度理解的结合使得搜索结果更加智能和相关性更强。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Note**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The title is being passed as the value of the `title` variable in the main program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标题作为`title`变量在主程序中的值传递。
- en: 'After retrieving these related movies, Haystack is used to analyze and rank
    the results based on a similar query, demonstrating a multi-hop search that combines
    graph-based relationships with advanced similarity retrieval:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到这些相关电影后，Haystack用于根据相似查询分析和排名结果，展示了结合基于图的关系和高级相似度检索的多跳搜索：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, since we imported only a fraction of the original dataset, it does
    not have one-to-many relationships. Where a director has directed multiple movies,
    the search will likely result in output such as `No related movies found for Inception`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们只导入了一小部分原始数据集，它没有一对一的关系。当一个导演指导了多部电影时，搜索可能会产生类似`Inception没有找到相关电影`的输出。
- en: You may try updating the script to import the entire dataset (after upgrading
    from AuraDB Free to AuraDB Professional or AuraDB Business Critical or in the
    Neo4j Desktop version) and see how multi-hop reasoning is performed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试更新脚本以导入整个数据集（在从AuraDB Free升级到AuraDB Professional或AuraDB Business Critical或在Neo4j
    Desktop版本中）并查看多跳推理是如何执行的。
- en: Dynamic search queries with flexible search filters
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态搜索查询与灵活的搜索过滤器
- en: One of the strengths of a knowledge graph is the ability to apply filters dynamically
    during search queries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 知识图谱的一个优势是在搜索查询期间动态应用过滤器。
- en: 'In the following code snippet, we will demonstrate how to incorporate filters
    and constraints into your Haystack queries, allowing users to refine search results
    based on specific parameters (e.g., time range, categories, or relationships between
    entities). This flexibility is crucial for building more interactive and contextually
    rich search systems:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将演示如何将过滤器和约束条件纳入您的Haystack查询中，使用户能够根据特定参数（例如时间范围、类别或实体之间的关系）细化搜索结果。这种灵活性对于构建更互动和上下文丰富的搜索系统至关重要：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Search optimization: tailoring search for specific use cases'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索优化：针对特定用例定制搜索
- en: Not all search systems are built the same. Whether you are building a recommendation
    engine or a domain-specific search tool, different optimizations are required.
    In this section, we will explore how to tailor Haystack’s search configuration
    for your unique use case, ensuring the best performance and relevance for your
    specific data. We will also cover the importance of tuning models and indexing
    for high-scale environments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有搜索系统都是相同的。无论您是在构建推荐引擎还是特定领域的搜索工具，都需要不同的优化。在本节中，我们将探讨如何根据您的独特用例定制Haystack的搜索配置，确保针对您特定数据的最优性能和相关性。我们还将讨论调整模型和索引以适应高规模环境的重要性。
- en: 'Have a look at the following code block:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码块：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code shows how to adjust parameters, such as `top_k`, to fine-tune the
    number of top results returned by the search query —not the model itself. The
    `top_k` parameter determines how many top results are retrieved based on vector
    similarity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了如何调整参数，如`top_k`，以微调搜索查询返回的前N个结果的数量——而不是模型本身。`top_k`参数决定了基于向量相似度检索多少个前N个结果。
- en: '**Note**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'These are just the snippets of the code. The full version is available in the
    GitHub repository: [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/beyond_basic_search.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/beyond_basic_search.py).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是代码片段。完整版本可在GitHub仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/beyond_basic_search.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/beyond_basic_search.py)。
- en: With Haystack’s similarity retrieval capabilities (such as context-aware search
    methods to dynamic filtering), you can now create more accurate AI-powered search
    systems and better search optimization. However, *search* is just the beginning.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Haystack的相似度检索能力（如上下文感知搜索方法和动态过滤），您现在可以创建更精确的AI驱动搜索系统，并实现更好的搜索优化。然而，*搜索*只是开始。
- en: In the next section, we will move beyond search to graph-based reasoning by
    utilizing the reasoning power of Haystack and relationships within the Neo4j knowledge
    graph.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将利用Haystack的推理能力和Neo4j知识图中的关系，将推理扩展到基于图的方法。
- en: Graph reasoning with Haystack
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Haystack的图推理
- en: In this section, we will explore how to extend Haystack’s capabilities beyond
    basic search by integrating it with the powerful graph reasoning features of Neo4j.
    While traditional search methods retrieve results based on text similarity, graph
    reasoning allows you to uncover deeper insights by leveraging the rich relationships
    between entities in your knowledge graph. By combining the similarity understanding
    of Haystack with the structured data in Neo4j, you can perform more complex queries
    that traverse multiple connections, reveal hidden patterns, and unlock contextually
    enriched insights.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何通过将Haystack与Neo4j强大的图推理功能集成，扩展Haystack的能力，使其超越基本搜索。虽然传统搜索方法基于文本相似度检索结果，但图推理允许您通过利用知识图中实体之间丰富的关联来揭示更深入的洞察。通过结合Haystack的相似度理解和Neo4j中的结构化数据，您可以执行更复杂的查询，遍历多个连接，揭示隐藏的模式，并解锁上下文丰富的洞察。
- en: This section will guide you through the process of building these advanced reasoning
    capabilities, transforming your search system into an intelligent, knowledge-driven
    tool.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您构建这些高级推理能力，将您的搜索系统转变为一个智能的、知识驱动的工具。
- en: Traversing multiple relationships to reveal hidden insights
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过遍历多个关系来揭示隐藏的洞察
- en: While graph traversal helps discover connections between entities, traversing
    across multiple relationships and different types of relationships can reveal
    hidden patterns in your knowledge graph. By moving across various paths in Neo4j—whether
    it is between movies, actors, directors, or genres—you can generate deeper insights
    that go beyond direct relationships. This multi-step traversal allows you to explore
    data in ways that basic search cannot, revealing connections that might otherwise
    be overlooked.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的图遍历有助于发现实体之间的联系，但跨多个关系和不同类型的关系遍历可以揭示你的知识图谱中的隐藏模式。通过在Neo4j中跨越各种路径——无论是电影、演员、导演还是类型之间——你可以生成超越直接关系的更深入见解。这种多步遍历允许你以基本搜索无法实现的方式探索数据，揭示可能被忽视的联系。
- en: We will now explore how to use multiple relationship types and multi-hop queries
    to retrieve more complex results. We will then combine them with Haystack’s similarity
    search capabilities for refinement and ranking.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何使用多种关系类型和多跳查询来检索更复杂的结果。然后我们将结合Haystack的相似度搜索功能进行精炼和排序。
- en: 'Here is an example; you want to find movies that have both the same actors
    and director as *Jurassic Park*, allowing you to uncover not just direct collaborations
    but also indirect connections:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子；你想找到既有与《侏罗纪公园》相同的演员又有相同导演的电影，这样你不仅可以发现直接合作，还可以发现间接联系：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unlocking insights through path queries
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过路径查询解锁见解
- en: Another powerful feature of graph reasoning is the ability to query for specific
    paths between nodes. For instance, finding out how two movies are connected through
    a series of collaborations can reveal surprising insights.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图推理的另一个强大功能是能够查询节点之间的特定路径。例如，通过一系列合作找出两部电影是如何连接的，可以揭示令人惊讶的见解。
- en: 'Have a look at the following query:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的查询：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This query finds how *Inception* and another movie are connected by shared actors,
    spanning three levels of relationships.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询找到了《盗梦空间》和另一部电影通过共享演员连接，跨越了三个层次的关系。
- en: '![Figure 6.1 — Illustration of a three-hop path traversal in a movie graph](img/B31107_06_01.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 — 电影图中三跳路径遍历的插图](img/B31107_06_01.png)'
- en: Figure 6.1 — Illustration of a three-hop path traversal in a movie graph
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 — 电影图中三跳路径遍历的插图
- en: The illustration in this figure shows a three-hop path traversal in a movie
    graph, starting from the movie *Inception* and reaching *Movie C* through a chain
    of actor collaborations. This path is the result of a Cypher query that explores
    connections between movies using the `ACTED_IN` relationship repeated three times.
    In the depicted example, *Inception* is connected to *Movie B* via *Actor A*,
    and *Movie B* is further linked to *Movie C* through *Actor B*. Each hop represents
    a transition from a movie to an actor, or vice versa, forming a three-hop undirected
    traversal. This visualization highlights how multi-hop reasoning in Neo4j can
    uncover deeper, indirect relationships—valuable for applications such as content
    discovery, recommendation systems, and collaboration network analysis.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本图中的插图显示了一个电影图中的三跳路径遍历，从电影《盗梦空间》开始，通过一系列演员合作链达到《电影C》。这条路径是使用重复三次的`ACTED_IN`关系探索电影之间连接的Cypher查询的结果。在所描述的示例中，《盗梦空间》通过演员A与《电影B》相连，而《电影B》又通过演员B进一步与《电影C》相连。每跳代表从电影到演员或反之的转换，形成一个三跳的无向遍历。这种可视化突出了Neo4j中的多跳推理如何揭示更深层次的间接关系——这对于内容发现、推荐系统和协作网络分析等应用非常有价值。
- en: '**Note**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: These are just the snippets of the code. The full version is available in the
    GitHub repository at [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/graph_reasoning.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/graph_reasoning.py).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是代码片段。完整版本可在GitHub仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/graph_reasoning.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch6/graph_reasoning.py)。
- en: By combining Neo4j’s graph reasoning and Haystack’s similarity understanding,
    we have been able to capture meaningful connections in our data, such as relationships
    between movies and actors, understanding multi-hop director collaborations, and
    uncovering complex paths between entities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合Neo4j的图推理和Haystack的相似度理解，我们已经能够捕捉到数据中的有意义联系，例如电影和演员之间的关系、理解多跳导演合作，以及揭示实体之间的复杂路径。
- en: Next, we will explore how to optimize these processes to ensure high performance
    as your graph grows in complexity and scale.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何优化这些过程，以确保随着图在复杂性和规模上的增长，保持高性能。
- en: Scaling your Haystack and Neo4j integration
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的Haystack和Neo4j集成
- en: As your system scales, so do the demands on both Haystack and Neo4j. Optimizing
    performance becomes crucial, especially when dealing with larger datasets, more
    complex graph structures, and advanced search capabilities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的系统扩展，对Haystack和Neo4j的需求也会增加。优化性能变得至关重要，尤其是在处理大型数据集、更复杂的图结构和高级搜索功能时。
- en: In this section, we will focus on best practices and techniques to ensure that
    your Haystack and Neo4j integration can handle increased loads efficiently. We
    will look into query optimization, caching strategies, indexing improvements,
    and techniques for scaling out your infrastructure to meet performance needs without
    sacrificing speed or accuracy in the following subsections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注最佳实践和技术，以确保您的Haystack和Neo4j集成能够高效地处理增加的负载。我们将探讨查询优化、缓存策略、索引改进以及扩展基础设施的技术，以满足性能需求，同时不牺牲速度或准确性，以下各小节将进行详细说明。
- en: Optimizing Neo4j queries for large graphs
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化大型图上的Neo4j查询
- en: 'As your Neo4j graph grows in size and complexity, query performance can degrade,
    especially when traversing multiple relationships or working with large datasets.
    Here are a few techniques to improve the performance of your Neo4j queries:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的Neo4j图的大小和复杂性增加，查询性能可能会下降，尤其是在遍历多个关系或处理大型数据集时。以下是一些提高Neo4j查询性能的技术：
- en: '**Use indexes and constraints**: Ensure that frequently queried properties
    such as `title` and `name` are indexed. Indexing speeds up node lookups and makes
    traversal more efficient:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用索引和约束**：确保经常查询的属性，如`title`和`name`，被索引。索引可以加快节点查找速度，并使遍历更高效：'
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Profile and optimize queries**: Use Neo4j’s `PROFILE` or `EXPLAIN` keywords
    to analyze the performance of your queries. This helps you understand which parts
    of the query are slowing down and where you can optimize:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置和优化查询**：使用Neo4j的`PROFILE`或`EXPLAIN`关键字来分析查询的性能。这有助于您了解查询的哪些部分正在减慢速度，以及您可以在哪里进行优化：'
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Limit Results Early**: If you are dealing with large result sets, limit the
    number of returned nodes early in the query to avoid over-fetching data:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽早限制结果数量**：如果您正在处理大型结果集，请在查询的早期阶段限制返回的节点数量，以避免过度获取数据：'
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Caching embeddings and query results
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存嵌入和查询结果
- en: 'When scaling Haystack and Neo4j, caching can help reduce redundant computations
    and network calls, significantly boosting performance. By caching both embeddings
    and query results, you can enhance the efficiency of your search system, especially
    when handling high volumes of queries. Here is how these caching strategies can
    make a difference:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展Haystack和Neo4j时，缓存可以帮助减少冗余计算和网络调用，显著提高性能。通过缓存嵌入和查询结果，您可以提高搜索系统的效率，尤其是在处理大量查询时。以下是这些缓存策略如何产生差异的示例：
- en: '**Cache embeddings**: Store embeddings generated by Haystack in Neo4j or a
    separate cache layer (such as Redis). By caching embeddings, you avoid recomputing
    them for frequently asked queries:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存嵌入**：将Haystack生成的嵌入存储在Neo4j或单独的缓存层（如Redis）中。通过缓存嵌入，您可以避免为频繁询问的查询重新计算它们：'
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Cache query results**: For frequently executed Neo4j queries, consider caching
    query results in memory or using a cache such as Redis or Memcached. This reduces
    the load on Neo4j by returning cached results for popular queries:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存查询结果**：对于频繁执行的Neo4j查询，考虑在内存中缓存查询结果或使用缓存（如Redis或Memcached）。这通过为常用查询返回缓存结果来减少对Neo4j的负载：'
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Efficient use of vector indexing
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效使用向量索引
- en: 'As your vector-based search capabilities expand, optimizing vector indexes
    in Neo4j is critical for maintaining performance. You can do this as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着基于向量的搜索能力扩展，优化Neo4j中的向量索引对于保持性能至关重要。您可以这样做：
- en: '**Configure vector indexes for high performance**: Ensure that your vector
    index in Neo4j is configured optimally, based on your embedding dimensions and
    search requirements:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置向量索引以实现高性能**：确保您的Neo4j中的向量索引根据嵌入维度和搜索需求进行优化配置：'
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Batch write operations**: When writing many embeddings into Neo4j, use batch
    operations to reduce the overhead of individual writes:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量写入操作**：当将许多嵌入写入Neo4j时，使用批量操作以减少单个写入的开销：'
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Load balancing and horizontal scaling
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡和水平扩展
- en: 'To handle increased traffic and load on both Haystack and Neo4j, horizontal
    scaling and load balancing are essential. By implementing load balancing and horizontal
    scaling, you can ensure your system remains responsive and resilient under heavy
    traffic. Here is how each approach contributes to scalability:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 Haystack 和 Neo4j 上的增加的交通和负载，水平扩展和负载均衡是必不可少的。通过实施负载均衡和水平扩展，你可以确保在大量交通下，你的系统保持响应性和弹性。以下是每种方法如何贡献于可扩展性的说明：
- en: '**Scale Neo4j**: Leveraging Neo4j AuraDB or a Neo4j cluster enables you to
    distribute your database workload across multiple instances, enhancing read and
    write capabilities. This is especially beneficial for applications requiring fast
    data retrieval and processing at scale.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展 Neo4j**：利用 Neo4j AuraDB 或 Neo4j 集群，你可以将你的数据库工作负载分配到多个实例，增强读写能力。这对于需要快速数据检索和大规模处理的应用程序特别有益。'
- en: '**Load balance Haystack**: Distributing incoming search queries across multiple
    Haystack instances with a load balancer prevents any single instance from being
    overwhelmed. This approach maintains consistent performance and ensures high availability,
    even as the demand grows.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡 Haystack**：通过负载均衡器将传入的搜索查询分配到多个 Haystack 实例，可以防止任何单个实例过载。这种方法保持了一致的性能，并确保了高可用性，即使需求增长也是如此。'
- en: '**Use Kubernetes**: Deploying Haystack on Kubernetes with containerized instances
    allows you to scale effortlessly by adjusting the number of replicas based on
    traffic. Kubernetes orchestrates these replicas dynamically, ensuring that resources
    align with demand and that your system can efficiently handle peaks in usage.
    Here is an example of a Kubernetes deployment configuration to scale Haystack,
    where multiple replicas are created to handle increased traffic efficiently:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Kubernetes**：通过容器化实例在 Kubernetes 上部署 Haystack 允许你根据流量调整副本数量，轻松地进行扩展。Kubernetes
    动态编排这些副本，确保资源与需求相匹配，并且你的系统可以有效地处理使用高峰。以下是一个 Kubernetes 部署配置示例，用于扩展 Haystack，其中创建了多个副本以有效地处理增加的交通：'
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By implementing these optimization strategies, you can ensure that your Haystack
    and Neo4j integration remains performant and scalable as your data and query complexity
    grow. Whether through caching, efficient indexing, or scaling infrastructure horizontally,
    these techniques will help you maintain speed and accuracy under increasing loads.
    As your system grows, optimizing performance is essential, but maintaining and
    monitoring the health of your AI-powered search system is just as critical.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些优化策略，你可以确保随着你的数据和查询复杂性的增长，Haystack 和 Neo4j 的集成保持高性能和可扩展性。无论是通过缓存、高效的索引还是水平扩展基础设施，这些技术都将帮助你保持速度和准确性，即使在不断增长的负载下。随着你的系统增长，优化性能是至关重要的，但维护和监控你的
    AI 驱动的搜索系统的健康状况同样关键。
- en: '**Note**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Interested in understanding how Neo4j achieves industry-leading speed and scalability,
    especially as your data and query complexity grow? Explore this blog post: *Achieve
    Unrivaled Speed and Scalability with Neo4j* ([https://neo4j.com/blog/machine-learning/achieve-unrivaled-speed-and-scalability-neo4j/](https://neo4j.com/blog/machine-learning/achieve-unrivaled-speed-and-scalability-neo4j/)).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解 Neo4j 如何实现行业领先的速度和可扩展性，尤其是在你的数据和查询复杂性增长时？请探索这篇博客文章：*使用 Neo4j 实现无与伦比的速度和可扩展性*
    ([https://neo4j.com/blog/machine-learning/achieve-unrivaled-speed-and-scalability-neo4j/](https://neo4j.com/blog/machine-learning/achieve-unrivaled-speed-and-scalability-neo4j/))。
- en: In the next section, we will explore best practices for keeping your system
    running smoothly over time, focusing on how to monitor performance, set up alerts,
    and ensure long-term stability and reliability beyond the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨保持你的系统长期平稳运行的最佳实践，重点关注如何监控性能、设置警报，并确保代码之外的长远稳定性和可靠性。
- en: Best practices for maintaining and monitoring your AI-powered search system
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护和监控你的 AI 驱动的搜索系统的最佳实践
- en: Building a powerful AI-driven search system is only the beginning. To ensure
    its long-term success, you need to go beyond the initial setup and focus on maintaining
    and monitoring your system over time. Regular performance checks, proactive monitoring,
    and a solid logging strategy are essential for identifying bottlenecks, preventing
    system failures, and optimizing resource usage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个强大的 AI 驱动的搜索系统只是开始。为了确保其长期成功，你需要超越初始设置，并专注于随着时间的推移维护和监控你的系统。定期的性能检查、主动监控和坚实的日志策略对于识别瓶颈、防止系统故障和优化资源使用至关重要。
- en: We now talk about the best practices for keeping your Haystack and Neo4j integration
    running smoothly, including monitoring key performance metrics, setting up alerts
    for critical issues, and implementing a sustainable maintenance routine to ensure
    that your search system remains reliable and efficient, even as it scales.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈保持 Haystack 和 Neo4j 集成平稳运行的最佳实践，包括监控关键性能指标、设置关键问题的警报以及实施可持续的维护流程，以确保您的搜索系统即使在扩展时也能保持可靠和高效。
- en: Performance optimization is not a one-time activity. We need to continuously
    monitor and collect metrics to identify bottlenecks and areas for improvement.
    Let us see how we can achieve this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化不是一个一次性活动。我们需要持续监控和收集指标，以识别瓶颈和改进区域。让我们看看我们如何实现这一点。
- en: Monitoring Neo4j and Haystack performance
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控 Neo4j 和 Haystack 性能
- en: 'Regularly tracking query response times, database performance, and overall
    system health is essential for maintaining an AI-powered search system. Set up
    monitoring for Neo4j and Haystack to track key metrics, identify bottlenecks,
    and ensure smooth operation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 定期跟踪查询响应时间、数据库性能和整体系统健康对于维护 AI 驱动的搜索系统至关重要。为 Neo4j 和 Haystack 设置监控以跟踪关键指标、识别瓶颈并确保平稳运行：
- en: '**Neo4j monitoring**: Leverage Neo4j’s built-in metrics and integration with
    tools such as Prometheus and Grafana to visualize query performance and monitor
    system load.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j 监控**：利用 Neo4j 内置的指标以及与 Prometheus 和 Grafana 等工具的集成，可视化查询性能并监控系统负载。'
- en: '**Haystack monitoring**: Use Grafana and Prometheus to monitor query throughput,
    latency, and response times in Haystack.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Haystack 监控**：使用 Grafana 和 Prometheus 监控 Haystack 中的查询吞吐量、延迟和响应时间。'
- en: 'Here is an example of monitoring the query response time:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个监控查询响应时间的示例：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting up alerts for critical issues
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置关键问题的警报
- en: Setting up automated alerts ensures you are notified when performance or system
    failures occur. By using Prometheus with Alertmanager or Grafana, you can set
    threshold-based alerts for slow queries, failed searches, or increased load.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自动警报可以确保在性能或系统故障发生时您会收到通知。通过使用 Prometheus 与 Alertmanager 或 Grafana，您可以设置基于阈值的警报，用于慢查询、失败的搜索或增加的负载。
- en: For instance, you can create alerts that trigger when Neo4j query response times
    exceed a certain threshold or when Haystack’s search latency increases beyond
    acceptable limits.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以为当 Neo4j 查询响应时间超过某个阈值或当 Haystack 的搜索延迟超出可接受范围时触发的警报。
- en: 'You can read more on Neo4j monitoring and alerts here: [https://neo4j.com/docs/operations-manual/current/monitoring/](https://neo4j.com/docs/operations-manual/current/monitoring/).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://neo4j.com/docs/operations-manual/current/monitoring/](https://neo4j.com/docs/operations-manual/current/monitoring/)
    上了解更多关于 Neo4j 监控和警报的信息。
- en: Implementing a logging strategy
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施日志策略
- en: Detailed logs help troubleshoot issues and understand the root cause of failures
    or performance degradation. Implement logging in both Haystack and Neo4j, including
    logging query execution times, failures, and system resource usage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 详细日志有助于排查问题并了解失败或性能下降的根本原因。在 Haystack 和 Neo4j 中实施日志记录，包括记录查询执行时间、失败和系统资源使用情况。
- en: Read more on Neo4j logging at [https://neo4j.com/docs/operations-manual/current/logging/](https://neo4j.com/docs/operations-manual/current/logging/).
    For more on Haystack logging and debugging, visit [https://docs.haystack.deepset.ai/docs/debug](https://docs.haystack.deepset.ai/docs/debug).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://neo4j.com/docs/operations-manual/current/logging/](https://neo4j.com/docs/operations-manual/current/logging/)
    上了解更多关于 Neo4j 日志的信息。有关 Haystack 日志和调试的更多信息，请访问 [https://docs.haystack.deepset.ai/docs/debug](https://docs.haystack.deepset.ai/docs/debug)。
- en: Establishing a regular maintenance routine
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立定期的维护流程
- en: 'Regularly scheduled maintenance ensures your AI-powered search system continues
    to perform optimally over time. This includes the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定期安排的维护确保您的 AI 驱动的搜索系统随着时间的推移继续以最佳性能运行。这包括以下内容：
- en: '**Neo4j**: Perform regular index rebuilding, data consistency checks, and disk
    space monitoring. Read more on Neo4j maintenance here: [https://neo4j.com/docs/operations-manual/current/backup-restore/maintenance/](https://neo4j.com/docs/operations-manual/current/backup-restore/maintenance/).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j**：执行定期的索引重建、数据一致性检查和磁盘空间监控。有关 Neo4j 维护的更多信息，请参阅 [https://neo4j.com/docs/operations-manual/current/backup-restore/maintenance/](https://neo4j.com/docs/operations-manual/current/backup-restore/maintenance/)。'
- en: '**Haystack**: Monitor embedding quality, update models as needed, and manage
    document store growth to avoid performance degradation. Read more on Haystack
    optimization and maintenance here: [https://docs.haystack.deepset.ai/docs/pipelineoptimization](https://docs.haystack.deepset.ai/docs/pipelineoptimization).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Haystack**：监控嵌入质量，根据需要更新模型，并管理文档存储增长以避免性能下降。有关 Haystack 优化和维护的更多信息，请参阅[https://docs.haystack.deepset.ai/docs/pipelineoptimization](https://docs.haystack.deepset.ai/docs/pipelineoptimization)。'
- en: By implementing these best practices, you ensure that your AI-powered search
    system remains robust, reliable, and adaptable to changing demands. Proactive
    monitoring, effective logging, and regular maintenance allow you to identify issues
    before they impact performance and ensure smooth operation as your data and query
    loads grow. These strategies not only prevent downtime and inefficiencies but
    also allow your system to evolve and scale seamlessly. As you continue to build
    and refine your AI-driven search, ongoing attention to monitoring and maintenance
    will be the key to sustaining its long-term success.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些最佳实践，你确保你的 AI 驱动搜索系统保持稳健、可靠，并能适应不断变化的需求。主动监控、有效的日志记录和定期的维护使你能够在问题影响性能之前发现它们，并确保随着数据和查询负载的增长，系统运行平稳。这些策略不仅防止了停机和不效率，还使你的系统能够无缝地发展和扩展。随着你继续构建和改进你的
    AI 驱动搜索，对监控和维护的持续关注将是维持其长期成功的关键。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how to optimize the performance of your Haystack
    and Neo4j integration and established best practices for maintaining and monitoring
    your AI-powered search system. You learned about key strategies for caching, efficient
    indexing, query optimization, and scaling your infrastructure to handle growing
    data and query loads. We also emphasized the importance of monitoring system performance,
    setting up alerts, and implementing a solid logging strategy to keep your system
    running smoothly over time. This knowledge is a crucial first step to creating
    a fast, reliable, and scalable search system as your data and complexity increase.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何优化你的 Haystack 和 Neo4j 集成，并确立了维护和监控你的 AI 驱动搜索系统的最佳实践。你学习了关于缓存、高效索引、查询优化以及扩展你的基础设施以处理增长的数据和查询负载的关键策略。我们还强调了监控系统性能、设置警报以及实施坚实的日志策略以保持系统长期平稳运行的重要性。随着数据和复杂性的增加，这些知识是创建快速、可靠和可扩展的搜索系统的关键第一步。
- en: As we wrap up the Haystack portion of this journey, the next part of this book
    will shift focus to integrating Spring AI frameworks and LangChain4j with Neo4j.
    In the following chapters, you will explore how these technologies can come together
    to build sophisticated recommendation systems, further enhancing the capabilities
    of your AI-powered applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束 Haystack 的这部分旅程，本书的下一部分将转向将 Spring AI 框架和 LangChain4j 与 Neo4j 集成。在接下来的章节中，你将探索这些技术如何结合在一起来构建复杂的推荐系统，进一步增强你的
    AI 驱动应用程序的功能。
