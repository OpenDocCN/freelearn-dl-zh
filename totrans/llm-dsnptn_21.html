<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer044">
			<h1 id="_idParaDest-249" class="chapter-number"><a id="_idTextAnchor315"/>21</h1>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor316"/>Tree-of-Thoughts Prompting</h1>
			<p><strong class="bold">Tree-of-thoughts</strong> (<strong class="bold">ToT</strong>) prompting is a technique that was developed to enhance the problem-solving <a id="_idIndexMarker972"/>capabilities of LLMs by enabling more structured exploration of different <span class="No-Break">reasoning paths.</span></p>
			<p>The formal ToT approach was introduced in a 2023 research paper titled <em class="italic">Tree of Thoughts: Deliberate Problem Solving with Large Language Models</em> by Yao et al. (researchers from Princeton University, Google DeepMind, and Google Research). Also <span class="No-Break">visit </span><a href="https://arxiv.org/abs/2305.10601"><span class="No-Break">https://arxiv.org/abs/2305.10601</span></a><span class="No-Break">.</span></p>
			<p>The primary inspiration for ToT came from how humans approach complex problems—we often consider multiple possible solution paths, evaluate their promise, backtrack when necessary, and explore alternatives. Traditional prompting techniques such as CoT (see <a href="B31249_20.xhtml#_idTextAnchor305"><span class="No-Break"><em class="italic">Chapter 20</em></span></a>) allowed step-by-step reasoning but lacked the ability to explore multiple paths or reconsider <span class="No-Break">earlier steps.</span></p>
			<p>ToT builds on <span class="No-Break">several techniques:</span></p>
			<ul>
				<li>CoT prompting, which enables <span class="No-Break">step-by-step reasoning</span></li>
				<li>Self-consistency methods that generate multiple <span class="No-Break">reasoning paths</span></li>
				<li>Human problem-solving approaches that involve exploration <span class="No-Break">and backtracking</span></li>
			</ul>
			<p>The key innovation of ToT is treating thinking as a tree search problem, where at each step, the model can generate and evaluate multiple “thoughts” (intermediate reasoning steps) and then select the most promising paths to continue exploring. This allows for more sophisticated problem-solving that includes exploration, evaluation, and <span class="No-Break">backtracking capabilities.</span></p>
			<p>In this chapter, you’ll learn how to implement ToT prompting to tackle complex reasoning tasks with <span class="No-Break">your LLMs.</span></p>
			<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Designing <span class="No-Break">ToT prompts</span></li>
				<li><span class="No-Break">Search strategies</span></li>
				<li>Pruning <span class="No-Break">and evaluation</span></li>
				<li>Applying ToT to solve a <span class="No-Break">multi-step problem</span></li>
				<li>Challenges <span class="No-Break">in implementation</span></li>
				<li><span class="No-Break">Future directions</span></li>
			</ul>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor317"/>Designing ToT prompts</h1>
			<p>To create <a id="_idIndexMarker973"/>effective ToT prompts, you should do <span class="No-Break">the following:</span></p>
			<ol>
				<li><strong class="bold">Encourage branching thoughts</strong>: This creates a non-linear exploration process where multiple possible solution paths can be considered simultaneously. By explicitly asking the model to generate several different initial approaches or perspectives, you prevent it from committing too early to a single line of reasoning that might lead to <span class="No-Break">suboptimal results.</span></li>
				<li><strong class="bold">Provide a clear problem statement</strong>: A well-defined problem statement gives the model a concrete goal and constraints to work within. This clarity helps the model understand exactly what it needs to solve and provides the foundation for generating relevant thought branches. Without this, the branching process could become unfocused <span class="No-Break">and inefficient.</span></li>
				<li><strong class="bold">Guide the model to explore alternative paths</strong>: This ensures the model doesn’t prematurely converge on an apparently promising but ultimately suboptimal solution. By explicitly requesting the exploration of different approaches, you help the model overcome potential bias in its reasoning and discover novel solutions it might <span class="No-Break">otherwise miss.</span></li>
				<li><strong class="bold">Include evaluation mechanisms</strong>: This component enables the model to assess the quality of different branches and make informed decisions about which paths to pursue further. Without evaluation criteria, the model would have no systematic way to determine which branches are most promising, potentially wasting computational resources on <span class="No-Break">unpromising paths.</span></li>
			</ol>
			<p>ToT is particularly powerful for complex reasoning tasks because it mimics human problem-solving approaches where we often mentally explore multiple possibilities before committing to a solution. The explicit branching and evaluation structure helps language models overcome limitations in their sequential <span class="No-Break">reasoning abilities.</span></p>
			<p>Here’s an <a id="_idIndexMarker974"/>example of implementing a basic <span class="No-Break">ToT prompt:</span></p>
			<pre class="source-code">
def tot_prompt(question, num_branches=3):
    prompt = f"""Solve the following problem using a Tree-of-Thoughts approach:
Problem: {question}
Let's explore multiple reasoning paths:
Path 1:
1) First, we could...
2) Then, we might...
3) This leads us to...
Path 2:
1) Alternatively, we could start by...
2) Following this approach...
3) This results in...
Path 3:
1) Another perspective is...
2) If we consider this...
3) The outcome would be...
Now, let's evaluate these paths and determine the most promising solution:
Evaluation:
1) Path 1: ...
2) Path 2: ...
3) Path 3: ...
Based on this evaluation, the most promising solution is...
Therefore, the final answer is...
Now, apply this Tree-of-Thoughts approach to solve the given problem:
{question}
Let's explore multiple reasoning paths:
"""
    return prompt
Let's look at an example usage:
problem = "What is the most efficient way to sort a list of a million integers?"
prompt = tot_prompt(problem)
print(prompt)</pre>			<p>This function generates a ToT prompt for a given problem (<strong class="source-inline">"What is the most efficient way to sort a list of a million integers?"</strong>), providing a structure for exploring and evaluating multiple <span class="No-Break">reasoning paths.</span></p>
			<p>This code creates a ToT prompt template by implementing four key principles: it encourages branching thoughts through explicit path structures with different starting phrases and <a id="_idIndexMarker975"/>numbered steps, ensuring the model explores multiple distinct solution approaches; it provides clarity by framing the problem twice to establish context and refocus attention before solution generation; it guides exploration of alternative approaches through contrasting language and separate reasoning paths; and it facilitates evaluation through a dedicated comparison section with prompts for selecting the most promising solution. The overall structure creates a cognitive scaffold that helps language models overcome linear thinking tendencies by forcing them to generate, develop, and critically compare multiple solution paths before reaching a conclusion—mimicking how humans tackle complex problems through divergent thinking followed by <span class="No-Break">critical evaluation.</span></p>
			<p>Implementing effective search strategies is crucial for navigating the ToT. Let’s check out two of them in the <span class="No-Break">following section.</span></p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor318"/>Search strategies</h1>
			<p>We have <a id="_idIndexMarker976"/>two commonly used <span class="No-Break">search strategies:</span></p>
			<ul>
				<li><strong class="bold">Depth-first search (DFS)</strong>: This is a graph traversal algorithm that explores as far as <a id="_idIndexMarker977"/>possible along each branch before backtracking. In the <a id="_idIndexMarker978"/>context of a tree of thoughts, DFS systematically dives deep into one path, exploring each thought or branch completely before moving to the next. It works by starting at the root, pushing each node’s children onto a stack, and then recursively exploring the deepest node first. This approach is particularly useful when you want to fully explore a line of reasoning or investigate the most profound or complex thoughts before branching out, making it valuable for problem-solving, decision-making, and understanding complex <span class="No-Break">conceptual landscapes.</span></li>
				<li><strong class="bold">Breadth-first search (BFS)</strong>: In contrast to DFS, BFS explores the tree of thoughts <a id="_idIndexMarker979"/>by systematically examining all <a id="_idIndexMarker980"/>neighboring nodes at the present depth before moving to nodes at the next depth level. Using a queue data structure, BFS starts at the root and explores all immediate connections before going deeper. In the context of thought exploration, BFS is particularly effective when you want to get a broad, panoramic view of different ideas and their immediate interconnections. This strategy is ideal for understanding the width and diversity of thoughts, finding the shortest path between concepts, or when you need to explore multiple potential reasoning paths simultaneously before diving deep into any single branch (see <span class="No-Break"><em class="italic">Figure 21</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">).</span></li>
			</ul>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Image96457.jpg" alt="Figure 21.1 – DFS versus BFS" width="1141" height="598"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 21.1 – DFS versus BFS</p>
			<p>As an example, let’s implement a simple <span class="No-Break">DFS strategy:</span></p>
			<pre class="source-code">
from transformers import AutoModelForCausalLM, AutoTokenizer
def dfs_tot(model, tokenizer, problem, max_depth=3, max_branches=2):
    def explore_branch(current_thought, depth):
        if depth == max_depth:
            return current_thought
        prompt = f"{current_thought}\n\nLet's explore further:\n"
        inputs = tokenizer(prompt, return_tensors="pt")
        outputs = model.generate(
            inputs, max_length=len(prompt) + 100,
            num_return_sequences=max_branches
        )
        branches = [
            tokenizer.decode(
                output[len(inputs['input_ids'][0]):],
                skip_special_tokens=True
            ) for output in outputs
        ]
        results = []
        for branch in branches:
            results.append(
                explore_branch(
                    current_thought + branch, depth + 1
                )
            )
        return max(
            results, key=lambda x: evaluate_thought(x)
        )  # Select the best branch
    initial_prompt = tot_prompt(problem)
    return explore_branch(initial_prompt, 0)
def evaluate_thought(thought):
    # Implement logic to evaluate the quality of a thought
    # This could involve coherence, relevance, depth of reasoning, etc.
    pass</pre>			<p>This code <a id="_idIndexMarker981"/>implements a DFS algorithm to explore a ToT generated by a language model. It starts with an initial problem and then uses the model to generate multiple potential continuations (branches). The code recursively explores each branch, extending the “thought” until it reaches a maximum depth. At each step, generated text is turned into model inputs, and the model outputs are decoded back <span class="No-Break">into text.</span></p>
			<p>The <strong class="source-inline">evaluate_thought</strong> function, which <a id="_idIndexMarker982"/>is a key part of the selection process, is intended to score the quality of each generated thought. The code utilizes this scoring to decide which branches to explore further, effectively navigating the ToT toward a potentially optimal solution. The final result is the highest-scoring thought found during <span class="No-Break">the DFS.</span></p>
			<p>Here’s an example usage of the preceding <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
model_name = "gpt2-large"  # Replace with your preferred model
model = AutoModelForCausalLM.from_pretrained(model_name)
tokenizer = AutoTokenizer.from_pretrained(model_name)
problem = "What are the potential long-term effects of artificial intelligence on employment?"
solution = dfs_tot(model, tokenizer, problem)
print(solution)</pre>			<p>This code snippet demonstrates how to use a pre-trained GPT-2 LLM to generate a solution to a <a id="_idIndexMarker983"/>given problem using the previously described <strong class="source-inline">dfs_tot</strong> function. First, it specifies the model to be used (<strong class="source-inline">"gpt2-large"</strong>) and loads both the model and its associated tokenizer using <strong class="source-inline">AutoModelForCausalLM</strong> and <strong class="source-inline">AutoTokenizer</strong> from the <strong class="source-inline">transformers</strong> library. This ensures the text is correctly processed for <span class="No-Break">the model.</span></p>
			<p>Then, it defines the problem as a question about the long-term effects of AI on employment. The <strong class="source-inline">dfs_tot</strong> function is <a id="_idIndexMarker984"/>called with the loaded model, tokenizer, and the problem as input, initiating the depth-first search for a solution. The returned <strong class="source-inline">solution</strong>, which represents the model’s generated response after exploring various “thoughts”, is finally printed to <span class="No-Break">the console.</span></p>
			<p>Next, we will discuss pruning and evaluation within the ToT framework to improve efficiency and focus the search. Pruning is essential for managing the computational cost associated with exploring numerous thought branches, while evaluation provides the criteria for deciding which branches <span class="No-Break">to discard.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor319"/>Pruning and evaluation</h1>
			<p>Pruning in the ToT approach <a id="_idIndexMarker985"/>is an effective mechanism for managing cognitive complexity by systematically reducing the search space. The process involves selectively eliminating less promising thought branches through intelligent evaluation techniques, using heuristic scoring methods that assess each potential path’s likelihood of leading to an optimal solution. By dynamically filtering out low-potential thoughts and focusing computational resources on the most promising reasoning trajectories, ToT pruning enables more efficient and targeted problem solving, balancing exploration breadth with <span class="No-Break">reasoning depth.</span></p>
			<ol>
				<li>Let’s implement <a id="_idIndexMarker986"/>a basic pruning strategy by defining a simple <span class="No-Break">pruning function:</span><pre class="source-code">
def pruning_tot(
    model, tokenizer, problem, max_depth=3,
    max_branches=3, prune_threshold=0.5
):
    def explore_and_prune(current_thought, depth):
        if depth == max_depth:
            return current_thought
        prompt = f"{current_thought}\n\nLet's explore further:\n"
        inputs = tokenizer(prompt, return_tensors="pt")
        outputs = model.generate(
            inputs, max_length=len(prompt) + 100,
            num_return_sequences=max_branches
        )
        branches = [
            tokenizer.decode(
                output[len(inputs['input_ids'][0]):],
                skip_special_tokens=True
            ) for output in outputs
        ]</pre><p class="list-inset">The core of the logic is in the <strong class="source-inline">explore_and_prune</strong> function, which handles the recursive search through the reasoning tree. The code works by generating multiple possible continuations (branches) from the current thought using LLM. The function is designed to explore the reasoning tree up to a specified maximum depth, with each level containing a controlled number of branches. When the maximum depth is reached, the code returns the current thought as the final result. The pruning <a id="_idIndexMarker987"/>mechanism is illustrative and should not be used <span class="No-Break">for production.</span></p></li>				<li>Once we’ve defined our function, we evaluate and <span class="No-Break">prune branches:</span><pre class="source-code">
        evaluated_branches = [
            (branch, evaluate_thought(current_thought + branch))
            for branch in branches
        ]
        pruned_branches = [
            b for b, score in evaluated_branches
            if score &gt; prune_threshold
        ]
        if not pruned_branches:
            return current_thought  # If all branches are pruned, return current thought
        results = []
        for branch in pruned_branches:
            results.append(
                explore_and_prune(current_thought + branch,
                    depth + 1)
            )
        return max(results, key=lambda x: evaluate_thought(x))
    initial_prompt = tot_prompt(problem)
    return explore_and_prune(initial_prompt, 0)</pre><p class="list-inset">First, the code evaluates <a id="_idIndexMarker988"/>each generated branch by pairing it with a score from the <strong class="source-inline">evaluate_thought</strong> function, which assesses the quality of the reasoning path. It then filters out low-quality branches by keeping only those scoring above the defined threshold. If all branches are pruned (none meet the threshold), the algorithm returns the current thought without further exploration. For the remaining promising branches, the code recursively explores each one by calling the same function at an increased depth level. Finally, it selects the best overall reasoning path by returning the result with the highest evaluation score from all explored paths. The outer function initializes the search with a formatted prompt containing the original <span class="No-Break">problem statement.</span></p></li>				<li>Define an <strong class="source-inline">evaluate_thought</strong> function. This function evaluates a given thought or branch of reasoning by scoring it based on its complexity (length) and linguistic diversity (the number of unique words used), returning a normalized score between <strong class="source-inline">0</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span><pre class="source-code">
def evaluate_thought(branch, threshold=0.5):
    """
    Simple evaluation function for ToT branch assessment
    Args:
        branch (str): The branch/thought to evaluate
        threshold (float): Minimum score for considering a branch viable
    Returns:
        float: Evaluation score
    """
    # Basic heuristics for evaluation
    complexity_score = len(branch.split()) / 20  # Reward moderate complexity
    uniqueness_score = len(
        set(branch.split())) / len(branch.split()
    )  # Reward unique words
    # Combined score, normalized
    score = (complexity_score + uniqueness_score) / 2
    return min(1.0, max(0.0, score))</pre></li>				<li>Let’s <a id="_idIndexMarker989"/>look at <span class="No-Break">an example:</span><pre class="source-code">
problem = "What are the ethical implications of genetic engineering in humans?"
solution = pruning_tot(model, tokenizer, problem)
print(solution)</pre></li>			</ol>
			<p>This implementation adds a pruning step to remove low-quality branches, focusing the search on the most <span class="No-Break">promising paths.</span></p>
			<p>Now, let’s apply ToT to solve a <span class="No-Break">multi-step problem.</span></p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor320"/>Applying ToT to solve a multi-step problem</h1>
			<p>ToT <a id="_idIndexMarker990"/>can be particularly effective for complex reasoning tasks. Let’s implement a ToT approach for multi-step <span class="No-Break">problem solving:</span></p>
			<pre class="source-code">
def multi_step_tot(model, tokenizer, problem_steps):
    full_solution = ""
    for step, question in enumerate(problem_steps):
        prompt = f"""Step {step + 1} of the problem:
{question}
Previous steps solution:
{full_solution}
Let's use Tree-of-Thoughts to solve this step:
"""
        step_solution = pruning_tot(model, tokenizer, prompt)
        full_solution += (
            f"\n\nStep {step + 1} Solution:\n"
            f"{step_solution}"
        )
    return full_solution
# Example usage
problem_steps = [
    "What are the main factors contributing to climate change?",
    "How do these factors interact with each other?",
    "What are potential solutions to mitigate climate change?",
    "What are the challenges in implementing these solutions?"
]
solution = multi_step_tot(model, tokenizer, problem_steps)
print(solution)</pre>			<p>This <a id="_idIndexMarker991"/>code implements a multi-step problem solver using the ToT reasoning approach. The <strong class="source-inline">multi_step_tot</strong> function <a id="_idIndexMarker992"/>breaks down complex problems into sequential steps and solves them one at a time, building upon <span class="No-Break">previous solutions.</span></p>
			<p>For each step in the provided problem sequence, the function creates a prompt that includes the current question, the accumulated solutions from previous steps, and instructions <a id="_idIndexMarker993"/>to use ToT reasoning. It then calls the previously defined <strong class="source-inline">pruning_tot</strong> function to generate a solution for that specific step. Each step’s solution is appended to a growing <strong class="source-inline">full_solution</strong> string, creating a comprehensive answer that maintains continuity of thought across the entire problem. The example demonstrates how this approach could be applied to analyze climate change through a sequence of progressively deeper questions, from identifying causes to exploring implementation challenges of <span class="No-Break">potential solutions.</span></p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor321"/>Challenges in implementation</h1>
			<p>While <a id="_idIndexMarker994"/>powerful, ToT faces <span class="No-Break">several challenges:</span></p>
			<ul>
				<li><strong class="bold">Computational complexity</strong>: Exploring multiple paths can be <span class="No-Break">computationally expensive</span></li>
				<li><strong class="bold">Evaluation difficulty</strong>: Determining the quality of different thought paths can <span class="No-Break">be challenging</span></li>
				<li><strong class="bold">Coherence across branches</strong>: Ensuring consistency when combining insights from <span class="No-Break">different branches</span></li>
				<li><strong class="bold">Prompt design complexity</strong>: Creating effective ToT prompts requires <span class="No-Break">careful consideration</span></li>
			</ul>
			<p>To address the computational complexity, consider implementing a parallel processing approach. Parallel processing can improve the ToT reasoning approach by addressing its inherent <a id="_idIndexMarker995"/>computational bottlenecks. The following code implements concurrent exploration of multiple reasoning branches simultaneously rather than sequentially, which can dramatically reduce the total computation time for <span class="No-Break">complex problems:</span></p>
			<pre class="source-code">
import concurrent.futures
def parallel_tot(model, tokenizer, problem, max_workers=3):
    def explore_branch(branch):
        return pruning_tot(model, tokenizer, branch)
    initial_branches = generate_initial_branches(problem, max_workers)
    with concurrent.futures.ThreadPoolExecutor(
        max_workers=max_workers
    ) as executor:
        futures = [
            executor.submit(explore_branch, branch)
            for branch in initial_branches
        ]
        results = [
            f.result()
            for f in concurrent.futures.as_completed(futures)
        ]
    return max(results, key=lambda x: evaluate_thought(x))
def generate_initial_branches(problem, num_branches):
    # Implement logic to generate initial branches for the problem
    pass
# Example usage
problem = "What are the potential implications of quantum computing on cryptography?"
solution = parallel_tot(model, tokenizer, problem)
print(solution)</pre>			<p>In the <a id="_idIndexMarker996"/>preceding code, the implementation uses Python’s <strong class="source-inline">concurrent.futures</strong> module with a <strong class="source-inline">ThreadPoolExecutor</strong> to distribute the workload across multiple workers. Each worker independently explores a different initial branch of the reasoning tree, effectively searching multiple promising paths in parallel. This approach is particularly valuable for ToT reasoning since the branching nature of the algorithm creates numerous independent subproblems that can be solved concurrently without dependencies on each other’s intermediate results. The final step consolidates these parallel explorations by selecting the highest-quality solution from all <span class="No-Break">completed branches.</span></p>
			<p>This implementation uses parallel processing to explore multiple branches simultaneously, potentially reducing computation time for complex <span class="No-Break">ToT problems.</span></p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor322"/>Future directions</h1>
			<p>As ToT <a id="_idIndexMarker997"/>continues to evolve, several promising <span class="No-Break">directions emerge:</span></p>
			<ul>
				<li><strong class="bold">Dynamic tree structures</strong>: Adapting <a id="_idIndexMarker998"/>the tree structure based on the <span class="No-Break">problem complexity.</span></li>
				<li><strong class="bold">Hybrid ToT-CoT approaches</strong>: Combining <a id="_idIndexMarker999"/>the strengths of both techniques  (<a href="https://arxiv.org/html/2409.17433v1"><span class="No-Break">https://arxiv.org/html/2409.17433v1</span></a><span class="No-Break">).</span></li>
				<li><strong class="bold">Meta-learning for ToT</strong>: Training <a id="_idIndexMarker1000"/>LLMs to generate effective ToT structures automatically. This approach has not been explored by <span class="No-Break">anyone yet.</span></li>
				<li><strong class="bold">Incorporating external knowledge</strong>: Integrating domain-specific knowledge into ToT <span class="No-Break">reasoning (</span><a href="https://arxiv.org/html/2407.00653v1"><span class="No-Break">https://arxiv.org/html/2407.00653v1</span></a><span class="No-Break">).</span></li>
			</ul>
			<p>Here’s a conceptual implementation of a dynamic <span class="No-Break">ToT structure:</span></p>
			<pre class="source-code">
def dynamic_tot(model, tokenizer, problem, max_depth=5):
    def adapt_structure(current_thought, depth):
        if depth == max_depth:
            return current_thought
        complexity = assess_complexity(current_thought)
        num_branches = determine_branches(complexity)
        branches = generate_branches(
            model, tokenizer, current_thought, num_branches
        )
        results = []
        for branch in branches:
            results.append(
                adapt_structure(
                    current_thought + branch, depth + 1
                )
            )
        return max(results, key=lambda x: evaluate_thought(x))
    def assess_complexity(thought):
        # Implement logic to assess the complexity of the current thought
        pass
    def determine_branches(complexity):
        # Determine the number of branches based on complexity
        return max(2, min(5, int(complexity  10)))
    def generate_branches(model, tokenizer, thought, num_branches):
        # Generate branches using the model
        pass
    initial_prompt = tot_prompt(problem)
    return adapt_structure(initial_prompt, 0)</pre>			<p>The preceding code implements a dynamic ToT approach that adapts its exploration strategy based on the complexity of the current reasoning path. The core function <strong class="source-inline">adapt_structure</strong> recursively builds a solution by examining the complexity of the current thought at each step and dynamically determining how many branches to explore. Unlike fixed branching strategies, this adaptive approach allocates more computational resources (more branches) to complex reasoning paths that might benefit from <a id="_idIndexMarker1001"/>broader exploration, while using fewer branches for simpler concepts. The implementation includes helper functions to assess thought complexity, determine the appropriate number of branches, and generate new thought continuations using the language model. The algorithm terminates when reaching the maximum depth and returns the highest-scoring complete <span class="No-Break">reasoning path.</span></p>
			<p>Here’s an example of how to use the preceding code to solve a problem such as “<strong class="source-inline">How might advancements in nanotechnology impact medicine in the </strong><span class="No-Break"><strong class="source-inline">next decade?</strong></span><span class="No-Break">”:</span></p>
			<pre class="source-code">
problem = "How might advancements in nanotechnology impact medicine in the next decade?"
solution = dynamic_tot(model, tokenizer, problem)
print(solution)</pre>			<p>This dynamic ToT approach adapts the tree structure based on the assessed complexity of each thought, allowing the more flexible and efficient exploratio<a id="_idTextAnchor323"/>n of complex <span class="No-Break">problem spaces.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor324"/>Summary</h1>
			<p>In this chapter, you learned how to design and implement ToT prompts for LLMs, including strategies for managing the branching thought processes. We covered search techniques and methods for pruning and evaluating different reasoning paths. By implementing the strategies and considerations discussed here, you can significantly enhance your LLM’s ability to handle ambiguous, multi-faceted problems and generate more robust and <span class="No-Break">insightful solutions.</span></p>
			<p>Revisiting <a href="B31249_20.xhtml#_idTextAnchor305"><span class="No-Break"><em class="italic">Chapter 20</em></span></a>, which focuses on CoT, let’s compare CoT and ToT from a use case perspective. Use CoT prompting when the task involves linear, sequential reasoning that can be decomposed into intermediate steps with a single, dominant solution path. CoT is particularly effective in math word problems, deductive reasoning, basic logical puzzles, and step-by-step procedural tasks. It works well when the problem has low branching complexity and does not require exploration of multiple alternatives. CoT is computationally cheaper because it produces a single chain of reasoning in a forward, deterministic manner. This technique is most helpful when the LLM needs a scaffold to “think aloud” and make its intermediate steps explicit to prevent hallucinations or faulty leaps <span class="No-Break">in logic.</span></p>
			<p>Use ToT prompting when the task involves multi-step reasoning with branching decision points, especially where multiple solution paths are possible and need to be evaluated in parallel. ToT is suited for creative problem-solving, planning tasks, theorem proving, code synthesis, and decision-making under uncertainty. It becomes advantageous when the problem space can be structured as a search tree, where intermediate reasoning nodes can be revisited, evaluated, and compared. ToT often incorporates strategies such as self-consistency sampling, lookahead evaluation, and value-based selection among branches. It is computationally more intensive because it maintains and expands multiple reasoning paths in parallel, potentially involving rollouts, backtracking, or <span class="No-Break">node scoring.</span></p>
			<p>If the problem is constrained and well-formed (e.g., SAT-style questions or straightforward derivations), CoT is usually sufficient and more efficient. If the problem is open-ended, has multiple conflicting goals, or if optimal solutions require comparing alternative paths (as in planning routes, game moves, or formal proofs), ToT yields better performance by simulating exploration <span class="No-Break">and deliberation.</span></p>
			<p>In practice, CoT can serve as a base technique, while ToT builds on it by orchestrating multiple chains. For example, ToT nodes may each use CoT internally to generate coherent thoughts. Therefore, the two are not mutually exclusive but hierarchically related in terms of complexity <span class="No-Break">and structure.</span></p>
			<p>In the upcoming chapter, we will explore the <strong class="bold">Reasoning and Acting</strong> (<strong class="bold">ReAct</strong>) pattern, which is commonly used in many agentic <span class="No-Break">AI applications.</span></p>
		</div>
	</div></div></body></html>