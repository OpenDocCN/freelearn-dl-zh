<html><head></head><body>
		<div id="_idContainer026">
			<h1 id="_idParaDest-15"><a id="_idTextAnchor015"/><a id="_idTextAnchor016"/><em class="italic">Chapter 1</em>: Introduction to AI</h1>
			<p>This book aims to teach you the basics of <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) programming for video games using one of the most popular commercial game engines available: Unity3D. In the upcoming chapters, you will learn how to implement many of the foundational techniques of any modern game, such as behavior trees and finite state machines.</p>
			<p>Before that, though, you must have a little background on AI in terms of its broader, academic, traditional domain, which we will provide in this introductory chapter. Then, we'll learn how the applications and implementations of AI in games are different from other domains and the essential and unique requirements for AI in games. Finally, we'll explore the basic techniques of AI that are used in games. </p>
			<p>In this chapter, we'll cover the following topics:</p>
			<ul>
				<li>Understanding AI</li>
				<li>AI in video games</li>
				<li>AI techniques for video games</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor017"/>Understanding AI</h1>
			<p>Intelligence is <a id="_idIndexMarker000"/>a natural and necessary aspect of life for all living organisms, such as animals and humans. Without intelligence – mentioned in the broadest way possible here – animals would not be able to look for food, bees would not be able to find flowers, and we humans would have never been able to craft objects or light fires, let alone develop games in Unity! On the contrary, computers are just electronic devices that can accept data, perform logical and mathematical operations at high speeds, and output the results. They lack any kind of intelligence. Computers would stay still and lifeless forever like rocks without someone telling them what to do and how to do it.</p>
			<p>From this point of view, AI is essentially the field that studies how to give machines the spark of natural intelligence. It's a discipline that teaches computers how to think and decide like living organisms to achieve any goal without human intervention.</p>
			<p>As you can imagine, this is a vast subject. There's no way that such a small book will be able to cover everything related to AI. Fortunately, for the goal of game AI, we do not need a comprehensive knowledge of AI. We only need to grasp the basic concepts and master the basic <a id="_idIndexMarker001"/>techniques. And this is what we will do in this book<a id="_idTextAnchor018"/><a id="_idTextAnchor019"/>.</p>
			<p>But before we move on to game-specific techniques, let's look at some of the main research areas for AI:</p>
			<ul>
				<li><strong class="bold">Computer vision</strong>: This<a id="_idIndexMarker002"/> is the ability to take visual input from visual sources – such as videos and photos – and analyze them to identify objects (object recognition), faces (face recognition), text in handwritten documents (optical character recognition), or even to reconstruct 3D models from stereoscopic images.</li>
				<li><strong class="bold">Natural Language Processing</strong> (<strong class="bold">NLP</strong>): This allows a machine to read and understand human languages – that is, how we write and speak. The problem is that human languages are difficult for machines to understand. Language ambiguity is the main problem: there are many ways to say the same thing, and the same sentence can have different meanings based on the context. NLP is a significant cognitive step for machines since they need to understand the languages and expressions we use before processing them and responding accordingly. Fortunately, many datasets are available on the web to help researchers train machines for this complex task.</li>
				<li><strong class="bold">Machine learning</strong>: This branch of AI studies how machines can learn how to perform a task using only raw data and experience, with or without human intervention. Such tasks span from identifying if a picture contains the image of a cat, to playing board games (such as the AlphaGo software, which, in 2017, was able to beat the number one ranked player of the world in the game of Go), to perfectly interpolating the faces of famous actors in our homemade videos (so-called <strong class="bold">deepfakes</strong>). Machine learning is a vast field that spans all other AI fields. We will talk more about it in <a href="B17984_11_Epub.xhtml#_idTextAnchor587"><em class="italic">Chapter 11</em></a>, <em class="italic">Machine Learning in Unity</em>.</li>
				<li><strong class="bold">Common sense reasoning</strong>: There is a type of knowledge that is almost innate in human beings. For instance, we trivially know that <em class="italic">things fall on the ground if they're not supported</em> or that <em class="italic">we cannot put a big thing into a smaller one</em>. However, this kind of knowledge and reasoning (also called <strong class="bold">common sense knowledge</strong>) is entirely undecipherable for computers. At the time of writing, nobody <a id="_idIndexMarker003"/>knows how to teach machines such trivial – for us – things. Nevertheless, it is a very active (and frustrating) research direction.</li>
			</ul>
			<p>Fortunately for us, game AI has <a id="_idIndexMarker004"/>a much narrower scope. Instead, as we will see in the next section, game AI has a single but essential goal: to make the game fun to p<a id="_idTextAnchor020"/><a id="_idTextAnchor021"/>lay.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor022"/>AI in video games</h1>
			<p>Different<a id="_idIndexMarker005"/> from<a id="_idIndexMarker006"/> general AI, game AI only needs to provide the <em class="italic">illusion of intelligence</em>. Its goal is not to offer human-like intelligent agents but characters that are smart enough to make a game fun to play.</p>
			<p>Of course, making a game <em class="italic">fun to play</em> is no trivial matter, and to be fair, a good AI is just one part of the problem. Nevertheless, if a good AI is not enough to make a game <em class="italic">fun</em>, a bad AI can undermine even the most well-designed game. If you are interested in the problem of <em class="italic">what makes a game fun</em>, I suggest that you read a good book on game design, such as <em class="italic">The Art of Game Design</em>, by Jesse Schell. </p>
			<p>However, for what concerns us, it is sufficient to say that it's essential to provide an adequate level of challenge to the player. A fair challenge, in this case, means the game should not be so difficult that the player can't beat the opponent, nor too easy that winning becomes a tedious task. Thus, finding the right challenge level is the key to making a game fun to<a id="_idTextAnchor023"/><a id="_idTextAnchor024"/> play.</p>
			<p>And that's where AI kicks in. The role of AI in games is to make it fun by providing challenging opponents <a id="_idIndexMarker007"/>and interesting <strong class="bold">Non-Player Characters</strong> (<strong class="bold">NPCs</strong>) that behave appropriately in the game world. So, the objective here is not to replicate the whole thought process of humans or animals but to make the NPCs seem intelligent by reacting to the changing situations in the game world so that they make sense to the player. This, as we mentioned previously, provides the illusion of intelligence.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">It is essential to mention that AI in games is not limited to modeling NPC's behaviors. AI is also used to generate game content (as we will see in <a href="B17984_10_Epub.xhtml#_idTextAnchor527"><em class="italic">Chapter 10</em></a>, <em class="italic">Procedural Content Generation</em>) to control the story events and the narrative pace (a notable example is given by the AI director in the <em class="italic">Left 4 Dead</em> series) or even to invent entire narrative arcs.</p>
			<p>Note that a good game AI doesn't need to be a complex AI. A recurring example is the AI of the original <em class="italic">Pac-Man</em> arcade game. By any modern standard, the algorithm that governs<a id="_idIndexMarker008"/> the<a id="_idIndexMarker009"/> behavior of the four ghosts chasing Pac-Man can barely be considered AI. Each ghost uses a really simple rule to decide where to move next: measure the distance between the ghost and a <em class="italic">target tile</em> and choose the direction to minimize the distance.</p>
			<p>The <em class="italic">target tile</em> might<a id="_idIndexMarker010"/> be the location of Pac-Man itself (as in the case of the Red Ghost), but it can also be something in front of Pac-Man (such as the Pink Ghost) or some other tile. By simply changing the target tile's position, the Pac-Man arcade game can give each ghost a distinctive personality and an AI that challenges us even after 40 years!</p>
			<p>The golden rule is to use the smallest amount of AI necessary to achieve the game's design goal. Of course, we may take this rule to the extreme and use no AI if we find out that it is unnecessary. For instance, in <em class="italic">Portal</em> and <em class="italic">Portal 2</em>, all the characters are completely scripted and there is no AI involved, yet nobody complained about the lack of AI.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">If you are interested in diving deeper into the Pac-Man AI, I suggest that you watch this very detailed video from the <em class="italic">Retro Game Mechanics Explained</em> YouTube channel: <a href="https://www.youtube.com/watch?v=ataGotQ7ir8">https://www.youtube.com/watch?v=ataGotQ7ir8</a>.</p>
			<p class="callout">Alternatively, if you prefer to read, you can go to this very informative web page: <a href="https://gameinternals.com/understanding-pac-man-ghost-behavior">https://gameinternals.com/understanding-pac-man-ghost-behavior</a>.</p>
			<p>Another challenge for game AI is that other operations, such as graphics rendering and physics simulation, need to share the processing power that's required for AI. And don't forget that they are all happening in real time, so it's critical to achieve a steady frame rate throughout the game. This means that game AI needs to be designed to not overtake the computational resources. This is usually done by designing an algorithm that can be interrupted and spread over multiple frames.</p>
			<p>In general AI, many companies invest in a dedicated processor for AI calculations called an AI accelerator (such as Google's Tensor Processing Unit). However, until games have widespread access to such dedicated AI processors, we game AI developers still need to <a id="_idIndexMarker011"/>pay<a id="_idIndexMarker012"/> attention to our algorithms' performance.</p>
			<p>The next section will provide a general introduction to the most popular AI techniques that are used in <a id="_idTextAnchor025"/><a id="_idTextAnchor026"/>video games.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor027"/>AI techniques for video games</h1>
			<p>In this section, we <a id="_idIndexMarker013"/>will look at some of the AI techniques that are commonly used in different types of games. We'll learn how to implement each of these features in Unity in the upcoming chapters. Since this book does not focus on AI techniques themselves but on implementing these techniques inside Unity, we won't look at them in too much detail here. So, let's just take this as a crash course before diving into the implementation details. </p>
			<p>If you want to learn more about AI for games, there are some great books, such as <em class="italic">Programming Game AI by Example</em>, by Mat Buckland, and <em class="italic">Artificial Intelligence for Games</em>, by Ian Millington and John Funge. In addition, the <em class="italic">AI Game Programming Wisdom and Game AI Pro</em> series also contain a lot of valuable resources and articles on <a id="_idTextAnchor028"/>the latest A<a id="_idTextAnchor029"/><a id="_idTextAnchor030"/>I techniques.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor031"/>Finite state machines</h2>
			<p><strong class="bold">Finite State Machines</strong> (<strong class="bold">FSMs</strong>) are <a id="_idIndexMarker014"/>probably<a id="_idIndexMarker015"/> one of the simplest, most used, and most discussed AI models and, for most games, they represent the only AI technique. A state machine consists of a finite number of <strong class="bold">states</strong> that are connected by one or more <strong class="bold">transitions</strong>, resulting in a data structure <a id="_idIndexMarker016"/>known as a <strong class="bold">graph</strong>. Each game entity starts with an initial state. Then, environment events trigger specific rules that will make the entity move into another state. Such triggering rules are <a id="_idIndexMarker017"/>called <strong class="bold">transitions</strong>. A game entity can only be in one state a<a id="_idTextAnchor032"/><a id="_idTextAnchor033"/>t any given time.</p>
			<p>For example, let's consider an AI guard character in a typical shooting game. Its states could be as simple as <em class="italic">patrolling</em>, <em class="italic">chasing</em>, and <em class="italic">shooting</em>:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B17984_01_01.jpg" alt="Figure 1.1 – A simple FSM for an AI guard character&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – A simple FSM for an AI guard character</p>
			<p>There are four components in a simple FSM:</p>
			<ul>
				<li><strong class="bold">States</strong>: This component<a id="_idIndexMarker018"/> defines a set of states that a game entity or an NPC can choose from (<strong class="bold">Patrol</strong>, <strong class="bold">Chase</strong>, and <strong class="bold">Shoot</strong>).</li>
				<li><strong class="bold">Transitions</strong>: This component defines the relationships between different states.</li>
				<li><strong class="bold">Rules</strong>: This component defines when to perform a state transition (<strong class="bold">Player in sight</strong>, <strong class="bold">Close enough to attack</strong>, and <strong class="bold">Lost/killed player</strong>).</li>
				<li><strong class="bold">Events</strong>: This is the<a id="_idIndexMarker019"/> component that will trigger to check the rules (the guard's visible area, distance to the player, and so on).</li>
			</ul>
			<p>So, a monster in <em class="italic">Quake 2</em> may have the following states: standing, walking, running, dodging, attacking, idle, and searching.</p>
			<p>FSMs are<a id="_idIndexMarker020"/> widely used in games because they are simple to implement using only a bunch of <em class="italic">if</em> or <em class="italic">switch</em> statements, but they are still powerful enough for simple and somewhat complex games. On the other hand, they can get messy when we need a lot of states and transitions. We'll learn how to manage a simple FSM i<a id="_idTextAnchor034"/><a id="_idTextAnchor035"/><a id="_idTextAnchor036"/><a id="_idTextAnchor037"/><a id="_idTextAnchor038"/>n the next chapter.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor039"/>Randomness and probability in AI</h2>
			<p>Imagine an<a id="_idIndexMarker021"/> enemy bot in a <strong class="bold">First-Person Shooter</strong> (<strong class="bold">FPS</strong>) game<a id="_idIndexMarker022"/> that can always kill the player with a headshot or an opponent in a racing game who always chooses the best route and never collides with any obstacle. Such a level of <em class="italic">intelligence</em> will make the game so hard that it will become almost impossible to win and, as a consequence, it will be frustrating to play. On the opposite side of the spectrum, imagine an enemy that chooses the same predictable route whenever it tries to escape from the player. After a couple of games, the player will learn the enemy's pattern, and the game will feel boring. AI-controlled entities that behave the same way every time the player encounters them make the game predictable, easy to win, and therefore dull.</p>
			<p>Of course, there are some cases in which <em class="italic">intentional predictability</em> is a desired feature. In stealth games, for instance, we want the players to be able to predict the path of the enemies so that the players can plan a sneaking route. But in other cases, <em class="italic">unintentional predictability</em> can interfere with the game's engagement and make the player feel like the game is not challenging or fair enough. One way to fix these <em class="italic">too-perfect</em> or <em class="italic">too-stupid</em> AIs is to introduce intentional mistakes in their behavior. In games, we introduce randomness and probability in the decision-making process of AI calculations.</p>
			<p>There are multiple scenarios where we may want to introduce a bit of randomness. The most straightforward case is when the NPC has no information and/or it doesn't matter what decision it makes. For instance, in a shooting game, an enemy under fire may want to decide where to cover. So, instead of always moving it to the closest cover, we may wish to instruct the NPCs to sometimes choose a slightly far-away cover.</p>
			<p>In other cases, we can use randomness for the outcomes of a decision. For example, we can use randomness for hit probabilities, add or subtract random bits of damage to/from base<a id="_idIndexMarker023"/> damage, or make an NPC hesitate befor<a id="_idTextAnchor040"/><a id="_idTextAnchor041"/>e they start shooting.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor042"/>The sensor system</h2>
			<p>Our AI characters <a id="_idIndexMarker024"/>need to know their surroundings and the world they interact with to make a particular decision. Such information includes the following:</p>
			<ul>
				<li><strong class="bold">The position of the player</strong>: This is used to decide whether to attack or chase or keep patrolling.</li>
				<li><strong class="bold">Buildings and nearby objects</strong>: This is used to hide or take cover.</li>
				<li><strong class="bold">The player's health and the AI's health</strong>: This is used to decide whether to retreat or advance.</li>
				<li><strong class="bold">Location of resources on the map in a Real-Time Strategy (RTS) game</strong>: This is used to occupy and collect resources that are required to update and/or produce other units.</li>
			</ul>
			<p>As you can imagine, choosing the correct method to collect game information can vary a lot, depending on the type of game we are trying to build. In the next few sections, we'll look at two basic strategies: <strong class="bold">polling</strong> and <strong class="bold">m<a id="_idTextAnchor043"/><a id="_idTextAnchor044"/>essage (event) systems</strong>.</p>
			<h3>Polling</h3>
			<p>One method <a id="_idIndexMarker025"/>to collect <a id="_idIndexMarker026"/>such information is <strong class="bold">polling</strong>. Polling consists of directly checking for the preceding information in Unity's <strong class="source-inline">FixedUpdate</strong> method of our AI character. In this way, AI characters can just poll the information they are interested in from the game world, do the checks, and take action accordingly. Polling works great if there aren't too many things to check.</p>
			<p>To make this method more efficient, we may want to program the characters to poll the world states at different rates so that we do not have all the characters checking everything at once. For instance, we may divide the polling agents into 10 groups (G1, G2, G3, and so on) and assign the polling for each group at different frames (for example, G1 will poll at frame 0, 60, 120, and so on; G2 will poll at frame 10, 70, 130, and so on).</p>
			<p>As another example, we may decide to change the polling frequency based on the enemy's type or state. For instance, enemies that are disengaged and far away may poll every 3-4 seconds, while enemies closer to the player and under attack may want to poll every 0.5 seconds.</p>
			<p>However, polling is no longer enough as soon as the game gets bigger. Therefore, in more massive <a id="_idIndexMarker027"/>games with more complex AI<a id="_idIndexMarker028"/> syste<a id="_idTextAnchor045"/><a id="_idTextAnchor046"/>ms, we need to implement an event-driven method using<a id="_idTextAnchor047"/><a id="_idTextAnchor048"/> a global messagin<a id="_idTextAnchor049"/>g system.</p>
			<h3>Messaging systems</h3>
			<p>In a messaging <a id="_idIndexMarker029"/>system, the <a id="_idIndexMarker030"/>game communicates events between the AI entity and the player, the world, or the other AI entities through asynchronous messages. For example, when the player attacks an enemy unit inside a group of patrol guards, the other AI units need to know about this incident so that they can start searching for and attacking the player.</p>
			<p>If we were using the polling method, our AI entities would need to check the state of all of the other AI entities to find out if one of them has been attacked. However, we can implement this in a more manageable and scalable fashion: we can register the AI characters that are interested in a particular event as listeners of that event; then, if that event occurs, our messaging system will broadcast this information to all listeners. The AI entities can then take the appropriate acti<a id="_idTextAnchor050"/>ons or perform further checks.</p>
			<p>This event-driven system does not necessarily provide a faster mechanism than polling. Still, it provides a convenient, central checking system that senses the world and informs the interested AI agents, rather than having each agent check the same event in every frame. In reality, both polling and messaging systems are used together most of the time. For example, the AI may poll for more detailed information w<a id="_idTextAnchor051"/>hen it receives an eve<a id="_idTextAnchor052"/><a id="_idTextAnchor053"/>nt<a id="_idIndexMarker031"/> from the <a id="_idIndexMarker032"/>messaging system.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor054"/>Flocking, swarming, and herding</h2>
			<p>Many living<a id="_idIndexMarker033"/> beings <a id="_idIndexMarker034"/>such <a id="_idIndexMarker035"/>as birds, fish, insects, and land animals perform specific operations such as moving, hunting, and foraging in groups. They stay and hunt in groups because it makes them stronger and safer from predators than pursuing goals individually. So, let's say you want a group of birds flocking, swarming around in the sky; it'll cost too much time and effort for animators to design the movement and animations of each bird. However, if we apply some simple rules for each bird to follow, we can achieve an emergent intelligence for the whole group with complex, global behavior.</p>
			<p>One pioneer of this concept is Craig Reynolds, who presented such a flocking algorithm in his 1987 SIGGRAPH paper, <em class="italic">Flocks, Herds, and Schools – A Distributed Behavioral Model</em>. He coined the<a id="_idIndexMarker036"/> term <strong class="bold">boid</strong>, which sounds like "bird" but refers to a bird-like object. He proposed three simple rules to apply to each unit:</p>
			<ul>
				<li><strong class="bold">Separation</strong>: Each boid needs to maintain a minimum distance from neighboring boids to avoid hitting them (short-range repulsion).</li>
				<li><strong class="bold">Alignment</strong>: Each boid needs to align itself with the average direction of its neighbors and then move in the same velocity with them as a flock. </li>
				<li><strong class="bold">Cohesion</strong>: Each boid is attracted to the group's cent<a id="_idTextAnchor055"/>er of mass (long-range attraction).</li>
			</ul>
			<p>These three simple rules are all we need to implement a realistic and reasonably complex flocking behavior for birds. This doesn't only work with birds. Flocking behaviors are useful for modeling a crowd or even a couple of NPCs that will follow the player during the game. </p>
			<p>We'll learn how to implement such a flocking sys<a id="_idTextAnchor056"/><a id="_idTextAnchor057"/><a id="_idTextAnchor058"/><a id="_idTextAnchor059"/>tem in Unity in <a href="B17984_05_Epub.xhtml#_idTextAnchor332"><em class="italic">Chapter 5</em></a>, <em class="italic">Flocking</em>.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor060"/>Path following and steering</h2>
			<p>Sometimes, we <a id="_idIndexMarker037"/>want our AI characters to<a id="_idIndexMarker038"/> roam the game world and follow a roughly guided or thoroughly defined path. For example, in a racing game, the AI opponents need to navigate a road. In that case, simple reactive algorithms, such as our flocking boid algorithm, are not powerful enough to solve this problem. Still, in the end, it all comes down to dealing with actual movements and steering behaviors. Steering behaviors for AI characters has been a research topic for a couple of decades now. </p>
			<p>One notable paper in this field is <em class="italic">Steering Behaviors for Autonomous Characters</em>, again by Craig Reynolds, presented in 1999 at the <strong class="bold">Game Developers Conference</strong> (<strong class="bold">GDC</strong>). He <a id="_idIndexMarker039"/>categorized steering behaviors into the following three layers:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17984_01_02.jpg" alt="Figure 1.2 – Hierarchy of motion behaviors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Hierarchy of motion behaviors</p>
			<p>To understand <a id="_idIndexMarker040"/>these <a id="_idIndexMarker041"/>layers, let's look at an example. Imagine that you are working at your desk on a hot summer afternoon. You are thirsty, and you want a cold glass of iced tea. So, we start from the first layer: we want a cold glass of iced tea (setting the goal), and we plan out what we need to do to get it. We probably need to go to the kitchen (unless you have a mini-fridge under your desk), fetch an empty glass, and then move to the fridge, open it, and get the iced tea (we have made a high-level plan).</p>
			<p>Now, we move to the second layer. Unless your kitchen is a direct straight line from your desk, you need to determine a path: go around the desk, move through a corridor, navigate around the kitchen furniture until you reach the cabinet with the glasses, and so on. Now that you have a path, it is time to move to the third layer: walking the path. In this example, the third layer is represented by your body, skeleton, and muscles moving you along the path.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Don't worry – you don't need to master all three layers. As an AI programmer, you only need to focus on the first two. The third layer is usually handled by graphic p<a id="_idTextAnchor061"/><a id="_idTextAnchor062"/>rogrammers – in particular, animators. </p>
			<p>After describing these three layers, Craig Reynolds explains how to design and implement <a id="_idIndexMarker042"/>standard steering behaviors for<a id="_idIndexMarker043"/> individual AI characters. Such behaviors include <em class="italic">seek</em> and <em class="italic">flee</em>, <em class="italic">pursue</em> and <em class="italic">evade</em>, <em class="italic">wander</em>, <em class="italic">arrival</em>, <em class="italic">obstacle avoidance</em>, <em class="italic">wall following</em>, and <em class="italic">path following</em>.</p>
			<p>We'll implement some of these behaviors in Unity in <a href="B17984_06_Epub.xhtml#_idTextAnchor375"><em class="italic">Chapter 6</em></a>, <em class="italic">Path Following and Steering Behaviors</em>.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor063"/>A* pathfinding</h2>
			<p>There are <a id="_idIndexMarker044"/>many games where you can find <a id="_idIndexMarker045"/>monsters or enemies that follow the player or move to a particular point while avoiding obstacles. For example, let's take a look at a typical RTS game. You can select a group of units and click a location where you want them to move or click on the enemy units to attack them.</p>
			<p>Then, your units need to find a way to reach the goal without colliding with the obstacles. Of course, the enemy units also need to be able to do the same. The barriers could be different for different units. For example, an airforce unit may pass over a mountain, while the ground or artillery units need to find a way around it.</p>
			<p><strong class="bold">A*</strong> (pronounced <em class="italic">A-star</em>) is a pathfinding algorithm that's widely used in games because of its performance, accuracy, and ease of implementation. Let's look at an example to see how it works. Let's say we want our unit to move from point <strong class="bold">A</strong> to point <strong class="bold">B</strong>, but there's a wall in the way, and it can't go straight toward the target. So, it needs to find a way to point <strong class="bold">B</strong> while avoiding the wall:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B17984_01_03.jpg" alt="Figure 1.3 – Top-down view of our map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Top-down view of our map</p>
			<p>This is a simple 2D example, but we can apply the same idea to 3D environments. To find the path from point <strong class="bold">A</strong> to point <strong class="bold">B</strong>, we need to know more about the map, such as the position of <a id="_idIndexMarker046"/>obstacles. For that, we can split our whole map into small tiles that represent the entire map in a grid format, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B17984_01_04.jpg" alt="Figure 1.4 – Map represented in a 2D grid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Map represented in a 2D grid</p>
			<p>The tiles can also<a id="_idIndexMarker047"/> be of other shapes, such as hexagons or triangles. Each shape comes with its advantages. For instance, hexagonal tiles are convenient because they do not have the problem of <em class="italic">diagonal moves</em> (all the hexagons surrounding a target hexagon are at the same distance). In this example, though, we have used square tiles because they are the more intuitive shape that comes to mind<a id="_idIndexMarker048"/> when we think about <strong class="bold">grids</strong>.</p>
			<p>Now, we can reference our map in a small 2D array.</p>
			<p>We can represent our map with a 5x5 grid of square tiles for a total of 25 tiles. Now, we can start searching for the best path to reach the target. How do we do this? By calculating the movement score of each tile that's adjacent to the starting tile that is not occupied by an obstacle, and then choosing the tile with the lowest cost.</p>
			<p>If we don't consider the diagonal movements, there are four possible adjacent tiles to the player. Now, we need to use two numbers to calculate the movement score for each of those tiles. Let's call them <em class="italic">G</em> and <em class="italic">H</em>, where <em class="italic">G</em> is the cost to move from the starting tile to the current tile, and <em class="italic">H</em> is the estimated cost to <a id="_idTextAnchor064"/><a id="_idTextAnchor065"/>reach the target tile from the current tile.</p>
			<p>Let's call <em class="italic">F</em> the sum of <em class="italic">G</em> and <em class="italic">H</em>, (<em class="italic">F = G + H</em>) – that is, the final score of that tile:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B17984_01_05.jpg" alt="Figure 1.5 – Valid adjacent tiles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Valid adjacent tiles</p>
			<p>In our <a id="_idIndexMarker049"/>example, to<a id="_idIndexMarker050"/> estimate <em class="italic">H</em>, we'll use a simple<a id="_idIndexMarker051"/> method called <strong class="bold">Manhattan length</strong> (also known <a id="_idIndexMarker052"/>as <strong class="bold">taxicab geometry</strong>). According to this method, the distance (cost) between <strong class="bold">A</strong> and <strong class="bold">B</strong> is the number of horizontal tiles, <strong class="bold">A</strong> and <strong class="bold">B</strong>, plus the number of vertical tiles between <strong class="bold">A</strong> and <strong class="bold">B</strong>:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B17984_01_06.jpg" alt="Figure 1.6 – Calculating G&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Calculating G</p>
			<p>The <em class="italic">G</em> value, on the other hand, represents the <em class="italic">cost so far</em> during the search. The preceding diagram shows the calculations of <em class="italic">G</em> with two different paths. To compute the current <em class="italic">G</em>, we must add <strong class="source-inline">1</strong> (the cost of moving one tile) to the previous tile's <em class="italic">G</em> score. However, we<a id="_idIndexMarker053"/> can give different costs to different tiles. For example, we may want to set a higher movement cost for diagonal movements (if we are considering them) or, for instance, to tiles occupied by a pond or a muddy road.</p>
			<p>Now that we know how to get <em class="italic">G</em>, let's learn how to calculate <em class="italic">H</em>. The following diagram shows the <em class="italic">H</em> value for different starting tiles. Even in this case, we use the Manhattan distance:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B17984_01_07.jpg" alt="Figure 1.7 – Calculating H&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Calculating H</p>
			<p>So, now that we <a id="_idIndexMarker054"/>know how to get <em class="italic">G</em> and <em class="italic">H</em>, let's go back to our original example to figure out the shortest path from <strong class="bold">A</strong> to <strong class="bold">B</strong>. First, we must choose the starting tile and collect all its adjacent tiles, as shown in the following diagram. Then, we must calculate each tile's <em class="italic">G</em> and <em class="italic">H</em> scores, as shown in the tile's lower left and right corners. Finally, we must get the final score, <em class="italic">F</em>, by adding <em class="italic">G</em> and <em class="italic">H</em> together. You can <a id="_idTextAnchor066"/><a id="_idTextAnchor067"/>see the <em class="italic">F</em> score in the tile's top-left corner. </p>
			<p>Now, we must choose the tile with the lowest <em class="italic">F</em> score as our next tile and store the previous tile as its parent. Note that keeping records of each tile's parents is crucial because we will use this backlink later to trace the sequence of nodes from the end to the start to obtain the final path. In this example, we must choose the tile to the right of the starting<a id="_idIndexMarker055"/> position and consider it the current tile:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B17984_01_08.jpg" alt="Figure 1.8 – Starting position&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Starting position</p>
			<p>From the current tile, we repeat this process, starting with collecting the valid adjacent tiles. There are only two free adjacent tiles this time: the one above the current tile and the one at the <a id="_idIndexMarker056"/>bottom (in fact, the left tile is the starting tile – which we've already examined – and the obstacle occupies the right tile). We calculate <em class="italic">G</em> and <em class="italic">H</em>, and then the <em class="italic">F</em> score of those new adjacent tiles.</p>
			<p>This time, we have four tiles on our map, all with the same score: six. Therefore, we can choose any of them. In fact, in the end, we will find the shortest path independently of which tile we explore first (proving the math behind this statement is outside the scope of this book):</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B17984_01_09.jpg" alt="Figure 1.9 – Second step&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Second step</p>
			<p>In this example, from the group of tiles with a cost of <strong class="source-inline">6</strong>, we chose the tile at the top left as the starting position. Again, we must examine the adjacent tiles. In this step, there's only one new adjacent tile with a calculated <em class="italic">F</em> score of <strong class="source-inline">8</strong>. Because the lowest score is still <strong class="source-inline">6</strong> right<a id="_idIndexMarker057"/> now, we <a id="_idIndexMarker058"/>can choose any tile with a score of <strong class="source-inline">6</strong>:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B17984_01_10.jpg" alt="Figure 1.10 – Third step&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Third step</p>
			<p>If we repeat this process until we reach our target tile, we'll end up with a board that shows all the scores for each free tile:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B17984_01_11.jpg" alt="Figure 1.11 – Reach target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Reach target</p>
			<p>There is only one step left. Do you remember the parent links that we stored in each node? Now, starting<a id="_idIndexMarker059"/> from the target tile, we must<a id="_idIndexMarker060"/> use the stored parent tile to trace back a list of tiles. The resulting list will be a path that looks somet<a id="_idTextAnchor068"/><a id="_idTextAnchor069"/>hing like this:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B17984_01_12.jpg" alt="Figure 1.12 – Path traced back&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Path traced back</p>
			<p>What we explained here is the essence of the A* pathfinding algorithm, which is the basic founding block of any pathfinding algorithm. Fortunately, since Unity 3.5, a couple of new features such as automatic navigation mesh generation and the NavMesh Agent make implementing pathfinding in your games much more accessible. As a result, you may not even need to know anything about A* to implement pathfinding for your AI characters. Nonetheless, knowing how the system works behind the scenes is essential to<a id="_idIndexMarker061"/> becoming <a id="_idIndexMarker062"/>a solid AI programmer.</p>
			<p>We'll talk about NavMesh in th<a id="_idTextAnchor070"/><a id="_idTextAnchor071"/>e next section and th<a id="_idTextAnchor072"/><a id="_idTextAnchor073"/>en in more detail in <a href="B17984_08_Epub.xhtml#_idTextAnchor447"><em class="italic">Chapter 8</em></a>, <em class="italic">Navigation Mesh</em>.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor074"/>Navigation meshes</h2>
			<p>Now that you <a id="_idIndexMarker063"/>know the basics of the A* pathfinding<a id="_idIndexMarker064"/> algorithm, you may notice that using a grid in A* requires many steps to get the shortest path between the start and target position. It may not seem notable but searching for a path tile-by-tile for huge maps with thousands of mostly empty tiles is a severe waste of computational power. So, games often use waypoints as a guide to move the AI characters as a simple and effective way to use fewer computation resources.</p>
			<p>Let's say we want to move our AI character from point <strong class="bold">A</strong> to point <strong class="bold">B</strong>, and we've set up three waypoints, as shown <a id="_idTextAnchor075"/><a id="_idTextAnchor076"/>in the following diagram:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B17984_01_13.jpg" alt="Figure 1.13 – Waypoints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Waypoints</p>
			<p>All we have to do now is apply the A* algorithm to the waypoints (there are fewer of these compared to the number of tiles) and then simply move the character in a straight line from waypoint to waypoint.</p>
			<p>However, waypoints are not without issues. What if we want to update the obstacles in our map? We'll have to place the waypoints again for the updated map, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B17984_01_14.jpg" alt="Figure 1.14 – New waypoints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – New waypoints</p>
			<p>Moreover, following each node to the target produces characters that look unrealistic. For instance, they <a id="_idIndexMarker065"/>move in straight lines, followed by <a id="_idIndexMarker066"/>an abrupt change of direction, much like the mechanical puppets in a theme park's attraction. Or the path that connects two waypoints may be too close to the obstacles. For example, look at the preceding diagrams; the AI character will likely collide with the wall where the path is close to the wall.</p>
			<p>If that happens, our AI will keep trying to go through the wall to reach the next target, but it won't be able to, and it will get stuck there. Sure, we could make the path more realistic by smoothing out the zigzag path using splines, or we could manually check each path to avoid grazing the edges of obstacles. However, the problem is that the waypoints don't contain any information about the environment ot<a id="_idTextAnchor077"/>her than the trajectory that's connecting two nodes.</p>
			<p>To address such situations, we're going to need a tremendous number of waypoints, which are very hard to manage. So, for everything other than straightforward games, we must exchange the computational cost of a grid with the men<a id="_idTextAnchor078"/>tal and design cost of managing hundreds of waypoints.</p>
			<p>Fortunately, there is a better solution: using a navigation mesh. A <strong class="bold">navigation mesh</strong> (often called <strong class="bold">NavMesh</strong>) is another graph structure that we can use to represent our world, similar to square tile-based grids and waypoint graphs:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B17984_01_15.jpg" alt="Figure 1.15 – Navigation mesh&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15 – Navigation mesh</p>
			<p>A NavMesh uses convex polygons to represent the areas in the map where an AI entity can travel. The most crucial benefit of using a NavMesh is that it contains much more information about the environment than a waypoint system. With a NavMesh, we can automatically adjust our path safely because we know that our AI entities can move freely inside a region. Another advantage of using a NavMesh is that we can use the same mesh for different types of AI entities. Different AI entities can have different properties such as size, speed, and movement abilities. For instance, a set of waypoints may be suitable for human characters, but they may not work nicely for flying creatures or AI-controlled vehicles. Those may need different sets of waypoints (with all the problems that this adds).</p>
			<p>However, programmatically generating a NavMesh based on a scene is a somewhat complicated <a id="_idIndexMarker067"/>process. Fortunately, Unity includes a built-in <a id="_idIndexMarker068"/>NavMesh generator.</p>
			<p>Since this is not a book on core AI techniques, we won't go into how to generate such NavMeshes. Instead, we'll learn how to efficiently use Unity's Na<a id="_idTextAnchor079"/><a id="_idTextAnchor080"/><a id="_idTextAnchor081"/><a id="_idTextAnchor082"/><a id="_idTextAnchor083"/>vMesh to implement pathfinding for our AI characters.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor084"/>Behavior trees</h2>
			<p><strong class="bold">Behavior trees</strong> are<a id="_idIndexMarker069"/> another technique that's <a id="_idIndexMarker070"/>used to represent and control the logic behind AI characters' decisions. They have become popular for their applications in AAA games such as <em class="italic">Halo</em> and <em class="italic">Spore</em>. We <a id="_idIndexMarker071"/>briefly <a id="_idIndexMarker072"/>covered FSMs earlier in this chapter, which is a straightforward way to define the logic of AI characters based on the transition between different states in reaction to game events. However, FSMs have two main issues: they are challenging to scale and reuse.</p>
			<p>To support all the scenarios where we want our characters to be, we need to add a lot of states and hardwire many transitions. So, we need something that scales better with more extensive problems. Behavior trees represent a sensible step in the right direction. </p>
			<p>As its name suggests, the essence of a behavior tree is a tree-like data structure. The leaves of such trees<a id="_idIndexMarker073"/> are called <strong class="bold">tasks</strong>, and they represent our character's actions (for instance, <em class="italic">attack</em>, <em class="italic">chase</em>, <em class="italic">patrol</em>, <em class="italic">hide</em>, and so on) or sensory input (for example, <em class="italic">Is the player near?</em> or <em class="italic">Am I close enough to attack?</em>). Instead, the internal nodes of the trees are represented by control flow nodes, which guide the execution of the tree. <strong class="bold">Sequence</strong>, <strong class="bold">Selector</strong>, and <strong class="bold">Parallel Decorator</strong> are commonly used control flow nodes. </p>
			<p>Now, let's try to <a id="_idIndexMarker074"/>reimplement the example from<a id="_idIndexMarker075"/> the <em class="italic">Finite state machines</em> section using a behavior tree. First, we can break all the tra<a id="_idTextAnchor085"/><a id="_idTextAnchor086"/>nsitions and states into basic tasks:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B17984_01_16.jpg" alt="Figure 1.16 – Tasks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16 – Tasks</p>
			<p>Now, let's look at a Selector node. We represent a Selector with a circle with a question mark inside it. When executed, a Selector node tries to execute all the child tasks/sub-trees in sequential order until the first one that returns with success. In other words, if we have a Selector with four children (for example, A, B, C, and D), the Selector node executes A first. If A fails, then the Selector executes B. If B fails, then it executes C, and so on. If <em class="italic">any</em> of the tasks return a Success, then the Sequence returns a Success as soon as that task completes.</p>
			<p>In the following example, the Selector node first chooses to attack the player. If the <strong class="bold">Attack</strong> task returns a Success (that is, if the player is in attack range), the Selector node stops the execution and returns with a Success to its parent node – if there is one. Instead, if the <strong class="bold">Attack</strong> task returns with a failure, the Selector node moves to the <strong class="bold">Chase</strong> task. Here, we repeat what we did previously: if the <strong class="bold">Chase</strong> task succeeds, the Selector node<a id="_idIndexMarker076"/> succeeds; if the <strong class="bold">Chase</strong> task fails, it <a id="_idIndexMarker077"/>tries the <strong class="bold">Patrol</strong> task, and so on:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B17984_01_17.jpg" alt="Figure 1.17 – Selector node&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17 – Selector node</p>
			<p>What about the other kind of tasks – the ones that check the game state? We use them with Sequence nodes, which are usually represented with a rectangle with an arrow inside them. A Sequence node is similar to a Selector node with a crucial difference: it only returns a Success message if every sub-tree returns with a Success. In other words, if we have a Sequence with four children (for example, A, B, C, and D), the Sequence node will execute A, then B, then C, and finally D. If <em class="italic">all</em> the tasks return a Success, then the Sequence returns a Success.</p>
			<p>In the following example, the first Sequence node checks whether the player character is close enough to attack. If this task succeeds, it will proceed to the next task: attacking the player. If the <strong class="bold">Attack</strong> task also returns with a Success message, the whole Sequence terminates with success. Instead, if the <strong class="bold">Close Enough to Attack?</strong> task fails, then the Sequence node does not proceed to the <strong class="bold">Attack</strong> task and returns a failed status to the parent Selector node. Then, the Selector chooses the next task in the Sequence, <strong class="bold">Lost or Killed Player</strong>, and the execution continues:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B17984_01_18.jpg" alt="Figure 1.18 – Sequence tasks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18 – Sequence tasks</p>
			<p>The other two common <a id="_idIndexMarker078"/>nodes are <strong class="bold">Parallel</strong> and <strong class="bold">Decorator</strong>. A Parallel node executes all of its <a id="_idIndexMarker079"/>child tasks simultaneously (while the Sequence and Selector nodes only execute their child trees one by one). A Decorator is another type of node that has only one child. It is used to change the behavior of its own single child's sub-tree, for instance, to run it multiple<a id="_idIndexMarker080"/> times or invert the subtree's result (if the <a id="_idIndexMarker081"/>subtree returns a Success message, the decorator returns a failure, and vice versa).</p>
			<p>We'll learn how to implement a ba<a id="_idTextAnchor087"/><a id="_idTextAnchor088"/><a id="_idTextAnchor089"/><a id="_idTextAnchor090"/><a id="_idTextAnchor091"/>sic behavior tree system in Unity in <a href="B17984_09_Epub.xhtml#_idTextAnchor487"><em class="italic">Chapter 9</em></a>, <em class="italic">Behavior Trees</em>.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor092"/>Locomotion</h2>
			<p>Animals (including humans) have<a id="_idIndexMarker082"/> a very complex musculoskeletal system that allows them to move around their environment. Animals also have sophisticated brains that tell them how to use such a system. For instance, we instinctively know where to put our steps when climbing a ladder, stairs, or uneven terrain, and we also know how to balance our bodies to stabilize all the fancy poses we want to make. We can do all this using a brain that controls our bones, muscles, joints, and other tissues, collectively described as our locomotor system.</p>
			<p>Now, let's put this in a game development perspective. Let's say we have a human character who needs to walk on uneven surfaces or small slopes, and we have only one animation for a walk cycle. With the lack of a locomotor system in our virtual character, this is what it would look like:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B17984_01_19.jpg" alt="Figure 1.19 – Climbing stairs without locomotion&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.19 – Climbing stairs without locomotion</p>
			<p>First, we play the<a id="_idIndexMarker083"/> walk animation and move the player forward. But now, the character is penetrating the surface. So, the collision detection system pulls the character above the surface to stop this impossible configuration. </p>
			<p>Now, let's look at how we walk upstairs in reality. We put our foot firmly on the staircase and, using force, we pull the rest of our body onto the next step. However, it's not simple to implement this level of realism in games. We'll need many animations for different scenarios, including climbing ladders, walking/running upstairs, and so on. So, in the past, only the large studios with many animators could pull t<a id="_idTextAnchor093"/><a id="_idTextAnchor094"/>his off. Nowadays, however, we have automated systems f<a id="_idTextAnchor095"/><a id="_idTextAnchor096"/>or this:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B17984_01_20.jpg" alt="Figure 1.20 – Unity extension for inverse kinematics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20 – Unity extension for inverse kinematics</p>
			<p>This system can automatically blend our animated walk/run cycles and adjust the movements of the bones in the player's legs to ensure that the player's feet step on the ground correctly (in literature, this<a id="_idIndexMarker084"/> is called <strong class="bold">inverse kinematics</strong>). It can also adjust the animations that <a id="_idIndexMarker085"/>were initially designed for a specific speed and direction, to any speed and direction on any surface, such as steps and slopes. In <a href="B17984_06_Epub.xhtml#_idTextAnchor375"><em class="italic">Chapter 6</em></a>, <em class="italic">Path Following and Steering Behaviors</em>, we'll learn how to use this lo<a id="_idTextAnchor097"/><a id="_idTextAnchor098"/>comotion system to apply realistic movement to our AI characters.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor099"/>Summary</h1>
			<p>In this chapter, we learned that game AI and academic AI have different objectives. Academic AI researchers try to solve real-world problems and develop AI algorithms that compete with human intelligence, with the ultimate goal of replacing humans in complex situations. On the other hand, game AI focuses on building NPCs with limited resources that seem to be intelligent to the player, with the ultimate goal of entertaining them. The objective of AI in games is to provide a challenging opponent that makes the game more fun to play.</p>
			<p>We also learned about the different AI techniques that are used in games, such as FSMs, randomness and probability, sensors, input systems, flocking and group behaviors, path following and steering behaviors, AI pathfinding, navigation mesh generation, and behavior trees. </p>
			<p>We'll learn how to implement these techniques inside the Unity engine in the following chapters. In the next chapter, we will start with the basics: FSMs.</p>
		</div>
	</body></html>