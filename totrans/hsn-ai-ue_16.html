<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Debugging Methods for AI - The Gameplay Debugger</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to face a powerful debugging tool. It is so powerful that it was worth having a separate chapter for it, and it is the best friend of any AI developer within Unreal. Actually, it's the best friend of any developer in Unreal, since it can have different uses, especially when it comes to covering <em>Gameplay</em> (although it has been mainly used for AI so far).</p>
<p>We are going to explore the <strong><em>Gameplay Debugger</em></strong> (as it is referred to in the official documentation), but sometimes people or books use <strong><em>Visual Debugger</em></strong> to refer to it. I presume that the reason it is called <em>Gameplay Debugger</em> is due to the fact that the tool has a <strong>great level of abstraction to debug any gameplay aspects (including AI)</strong>. However, the built-in categories of the <em>Gameplay Debugger</em> are AI-related, and this is the reason why it is included in this book.</p>
<div class="packt_infobox"><br/>
Do not confuse the Visual Logger with the Visual Debugger, which is the <strong><em>Gameplay Debugger</em></strong>!!</div>
<p>In particular, we are going to cover the following topics:</p>
<ul>
<li>Explore the <strong><em>anatomy of the Gameplay Debugger</em></strong></li>
<li>Learn about the <strong><em>Extensions and Categories</em></strong> of the Gameplay Debugger</li>
<li>Understand what kind of <strong><em>information each Category displays</em></strong></li>
<li>Create a custom module by <strong><em>creating a new plugin</em></strong> (we need this to extend the <em>Gameplay Debugger</em>)</li>
<li><strong><em>Extend the Gameplay Debugger</em></strong> by adding a new <em><strong>Category</strong></em></li>
<li><strong><em>Extend the Gameplay Debugger</em></strong> by adding a new <strong><em>Extension</em></strong></li>
</ul>
<p>This is the last technical part of this book before the last chapter, in which we will explore <em>Game AI</em> in broader terms. Thus, without further ado, let's dive in!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The anatomy of the Gameplay Debugger</h1>
                </header>
            
            <article>
                
<p>While the game is running, you can open the <strong><em>Gameplay Debugger</em></strong> (or <em>Visual Debugger</em>) by pressing the " ' " (apostrophe) key.</p>
<div class="packt_infobox">All the key bindings of the visual debugger can be changed/customized. We will see how we can change them in the <em>Project Settings</em> section, later in this chapter.</div>
<p>The <strong><em>Gameplay Debugger</em></strong> is divided into two: <strong><em>Extensions</em></strong> and <strong><em>Categories</em></strong>:</p>
<ul>
<li><strong><em>Extensions</em></strong> are specific key bindings (toggles) that trigger a specific function.</li>
<li><strong><em>Categories</em></strong> are <em>toggleable</em> pieces of information that appear on the screen (and also in 3D spaces) in regards to a specific system</li>
</ul>
<p>On-screen, the <strong><em>Gameplay Debugger</em></strong> is visually divided into two sections:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eac0d6f8-2ba6-4375-a614-4748009c59fa.png"/></p>
<p>The top section is the control section and shows which options are available. In particular, it displays which <em>Extensions</em> are available and highlights the active <em>Categories</em> that are displayed in the bottom part:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6273680f-db3c-4af6-b1d0-a19bdbb454fe.png" style="width:26.00em;height:3.75em;"/></p>
<p>The bottom section, instead, displays different information for each of the selected <em>Categories. </em><span>Here is an example with some Categories showing:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eaf51a68-f423-4c6a-820c-6f120fac26c0.png" style="width:25.92em;height:16.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gameplay Debugger Extensions</h1>
                </header>
            
            <article>
                
<p>The <em>Gameplay Debugger</em> has only two default <strong><em>Extensions</em></strong> and a built-in one, as you can see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae6b7938-cc4c-4fe4-b391-975943aa49ed.png" style="width:27.50em;height:3.92em;"/></p>
<p>The two default Extensions and a built-in one are as follows:</p>
<ul>
<li><span>The </span><strong><em>Spectator Extension</em></strong><span> allows you (at runtime, while the game is playing) to detach the control from the </span><em>Player Character</em><span> and control a </span><em>Spectator Pawn</em><span> so that you are free to fly over the level and have an external point of view. At any time, you can gain back control of the <em>Player Character</em> by toggling the </span><em>Spectator Extension</em><span> or by closing the </span><em>Gameplay Debugger</em><span>. The default key to toggle the <em>Spectator Extension</em> is the <em>Tab</em> key.</span></li>
<li>The <strong><em>HUD Extensions</em></strong> allows you to toggle the <em>HUD</em> on and off (in particular, the <em>HUD</em> class contained in the <em>Game Mode</em> instance). <span>The default</span><span> key to toggle the </span><em>HUD Extension</em><span> is <em>Ctrl + Tilde</em></span><span>.</span></li>
<li><strong><em>DebugMessages</em></strong> is the <em>built-in Extension</em>, and as its name suggests, it toggles the debug messages. <span>The default</span><span> key</span><span> is <em>Ctrl</em></span> + <span><em>Tab</em></span><span>.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gameplay Debugger categories</h1>
                </header>
            
            <article>
                
<p>The <em>Gameplay Debugger</em> is divided into different categories, which can be enabled and disabled (with the use of the <em>Keypad (or Numpad)</em>, not just the numbers of your keyboard).</p>
<div class="packt_tip">If you don't have a <em>Keypad/Numpad</em> (e.g. you are using a small laptop), later in this chapter, you will find the settings of the <em>Gameplay Debugger</em> in which you can change the key binding to something that your keyboard has.</div>
<p>The number next to the <strong><em>Category</em></strong> indicates its default position (and the number to press on the <em>Keypad</em> to activate it). However, this can be changed in the settings later.</p>
<p>To explore the <em>Categories</em>, I have created a simple test map, in which there should be a bit of everything so that we can see all the <em>Gameplay Debugger </em>categories in action. This test map is available in the project files associated with this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category 0 – Navmesh</h1>
                </header>
            
            <article>
                
<p>The first category is <strong><em>Navmesh</em></strong>, which is assigned to the "<strong><em>0</em></strong>" key by default.</p>
<p>Once you toggle it, you will be able to see the <strong><em>Navmesh</em></strong> directly on the map <span>– </span>simple as that. This is very useful when you need to check the <em>Nav Mesh</em> in real time, especially if you have dynamic obstacles so that the <em>Nav Mesh</em> is rebuilt at runtime. </p>
<p>This is how it appears when this category is enabled:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/759cd92d-e20d-4238-bcb6-314cd2861dd9.png" style="width:57.58em;height:27.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category 1 – AI</h1>
                </header>
            
            <article>
                
<p>This category, once enabled, shows a lot of information about the selected AI. By default, it is assign to the "<strong><em>1</em></strong>" key.</p>
<div class="packt_infobox">If no actor is selected, no information will be shown in this category. However, it will highlight the available AIs with their affiliation (in a 3D space).</div>
<p>When the category is toggled (and a <em>Debug Actor</em> is selected), it looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2c2b600-3516-48e3-938f-567cbab90595.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>In this category, all of the AIs on the map are displayed with their affiliation (in a 3D space), and the selected <em>Debug Actor</em> also has the name of the controller (always in a 3D space). However, the information that's displayed directly on the screen is of the single <em>Debug Actor</em>.</p>
<p>The following is the kind of information that this category displays (with a close-up of <em>Categories Information</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6784d451-7bc6-4e6f-a208-53f93dbb998b.png" style="width:21.25em;height:11.92em;"/></p>
<ul>
<li><strong>Controller Name</strong>: This displays the name of the <em>AI Controller</em> that possesses this <em>Pawn</em>.</li>
<li><strong>Pawn Name</strong>: This displays the name of the <em>Pawn</em> that is currently possessed by the <em>AI</em>.</li>
<li><strong>Movement Mode</strong>: If there is a <em>Character Movement Component</em> attached to the Pawn, then this displays the current movement mode (e.g. walking, running, swimming, flying, falling, etc…)</li>
<li><strong>Base</strong>: If there is a <em>Character Movement Component</em> attached to the Pawn, this displays on the base that the character is grounded on. In the case of walking or running, this is the mesh of the piece of floor where the AI is currently walking or running. In the case of falling, this is "<em>none</em>".</li>
<li><strong>NavData</strong>: This displays that <em>NavData</em> that the AI is currently using. Most likely, the value will be "<em>Default</em>", unless you gave a specific <em>NavData</em> to the AI character by using C++.</li>
<li><strong>Path following</strong>: This displays the state of the Path to follow when the AI character is moving. Information such as the <em>Dot-Product</em>, the <em>2D-Distance</em>, and the <em>Z</em><em>-Distance</em> are displayed as well. Here is an example when the character is moving:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88fd83f8-f69e-4d22-b63d-ce588b0fa5e2.png" style="width:31.50em;height:14.25em;"/></p>
<ul>
<li><strong>Behavior</strong>: This indicates whether there is a behavior running or not (e.g. is a <em>Behavior Tree</em> running on this <em>AI Controller</em>?).</li>
<li><strong>Tree</strong>: This indicates which <em>Behavior Tree</em> the AI is currently running (if a <em>Behavior</em> is running).</li>
<li><strong>Active Task</strong>: This indicates which <em>Behavior Tree Task</em> is currently executing, along with the <em>Task number</em> (the number that that Task is ordered in the Tree).</li>
</ul>
<div class="packt_infobox">For more information aregarding the current task in the <em>Behavior Tree Category</em>, see the next section.</div>
<ul>
<li><strong>Gameplay Tasks</strong>: This displays how many <em>Gameplay Tasks</em> are currently assigned to this AI.</li>
<li><strong>Montage</strong>: This displays the current montage that the Character is playing (if any).</li>
</ul>
<div class="packt_infobox">Although we didn't touch on this topic in this book, syncing AI actions with Animations is an in-between land for AI programmers and Animators.</div>
<p class="mce-root"><span>It is worth mentioning that if the AI is moving, even if the </span><em>Navmesh</em><span> category is not toggling, it will show the piece of the </span><em>Nav Mesh</em><span> that the AI is currently using to navigate, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99c4e67d-eb87-4eb6-98d5-63dbf3f82bdd.png" style="width:44.92em;height:21.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category 2 – Behavior Tree</h1>
                </header>
            
            <article>
                
<p>This category displays information about the <strong><em>Behavior Tree</em></strong> that's currently running on the AI. By default, it is assigned to the "<strong><em>2</em></strong>" key.</p>
<div class="packt_infobox"><br/>
If no <em>Behavior Tree</em> is running, this section will not display anything.</div>
<p>When activated, the <strong><em>Behavior Tree Category</em></strong> looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c165e2c-858c-41a2-9391-d541ced483d7.png" style="width:73.17em;height:35.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>This category only displays information on the screen (so nothing in the 3D space). In particular, it shows the following information on the left-hand side:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/14c31c9a-95cf-42be-84e6-45afbc491993.png" style="width:22.75em;height:11.00em;"/></p>
<ul>
<li><strong>Brain Component</strong>: This shows which kind of <em>Brain Component</em> the <em>AI Controller</em> is currently using, which will be of the <em>BTComponent</em> type.</li>
</ul>
<div class="packt_infobox">Since Unreal is developed with <em>modularity</em> in mind, a <em>Brain Component</em> is anything that can hold AI logic. At the time of writing, the only built-in <em>Brain Component</em> is the <em>Behavior Tree</em> (<em>BTComponent</em>).</div>
<ul>
<li><strong>Behavior Tree</strong>: This is the name of the <em>Behavior Tree</em> that the AI is using.</li>
<li><strong>Task Tree</strong>: After the <em>Behavior Tree</em> property, there is the all branch of the task that is currently being executed. This is the path from the root (with all the node names and their respective numbers) to the <em>Task</em> the AI is executing.</li>
</ul>
<p>This is very useful when you need to understand why a determined tasks has been chosen, rather than another, by following the path along the tree.</p>
<p>On the right, instead, the name of the <em>Blackboard</em> asset that's being used by the <em>Behavior Tree </em>is displayed. Below this, there's the keys of the <em>Blackboard</em> that's being used, along with their current value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4b302a24-3789-4cc8-9c7e-abddea763d45.png" style="width:21.50em;height:4.67em;"/></p>
<div class="packt_tip">The following example shows just two <em>Blackboard keys</em>, <em>Destination</em> and <em>Self Actor</em>. Try to test the <em>Gameplay Debugger</em> in the <em>Designing Behavior Tree Project</em> to see more and get a better feeling of what it is going on, since you have been building these structures from scratch. Here is a sneak peek of what you will see:<br/>
<br/>
<img src="assets/95f453a5-856d-478e-b700-c087d7dc1ba5.png"/><br/>
<br/>
<span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>Of course, this is very useful when you want to test that the right values in the <em>Blackboard</em> are set.</p>
<p>Here is one more example, showing the character moving:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e3c0028-6f79-4a16-b55e-c5d854738d36.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category 3 – EQS</h1>
                </header>
            
            <article>
                
<p>This category displays the <strong><em>Environmental Queries</em></strong> that the AI is currently performing. <span>By default, it is assigned to the "</span><strong><em>3</em></strong><span>" key.</span></p>
<div class="packt_infobox">If the AI is not performing any <em>Environment Query</em>, than this category will just show that the number of queries is zero.</div>
<p><span>When the </span><strong><em>EQS Category</em></strong><span> is activated, we get the following output on-screen:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f803fa22-0174-4306-82c2-49b63ee1bcda.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>From the preceding screenshot, we can see that this <em>Category</em> highlights the different points that are generated by the query, along with their score. Depending on the <em>Run Mode</em> of the query, it is possible to see which of these points is the winner (it has the highest score and its color is a brighter green than the other colors).</p>
<p>Furthermore, a red arrow on top of a point means that it has been selected (which means that it is the closest that you are looking at). This is useful because, in the information displayed on the side, it is possible to check at which place of the scoreboard that specific point has been ranked.</p>
<p>On the side, you will find some extra information about the query:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e62bce3-9199-42b6-8a7b-84e5840f83f5.png" style="width:23.42em;height:15.92em;"/></p>
<p>In particular, the following information is shown:</p>
<ul>
<li><strong><em>Queries</em></strong>: This is the number of queries that the <em>Debug Actor</em> is running.</li>
<li><strong><em>Query Name(s) and Run Mode</em></strong>: This displays which <em>Query</em> has been (or currently is being) executed. Then, after an underscore, it displays the <em>Run Mode</em> (in the preceding screenshot, it is <em>Single Result</em>).</li>
<li><strong><em>Time Stamp</em></strong>: This is the timestamp of when the <em>Query</em> was executed, along with how long ago this occurred.</li>
<li><strong><em>Options</em></strong>: This displays which the <em>Generator</em> for the Query.</li>
<li><strong><em>Selected Item</em></strong>: This displays the <em>position/rank</em> of the selected item in the scoreboard. In the preceding screenshot, the item we have selected is 11th on the scoreboard (from the full-screen screenshot, you can see that it has a score of <em>1.31</em>, against the winner point, which has a score of <em>2.00</em>). This is very useful for checking how the point you are looking at is ranked, since it gives you a quick idea of the relative score among the points.</li>
</ul>
<div class="packt_infobox">Keep in mind that when a point is ranked, <strong><em>the rank starts from zero</em></strong>, and so the <strong><em>Winner Point is ranked 0th</em></strong>. So, in the preceding screenshot, "<em>Selected Item: 11</em>" means that it is 11th on the scoreboard, but it is the 12th point in the list.</div>
<p>For your convenience, here is another example, in which the Selected Point is the Winner Point (notice that its rank is 0):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b522b6a7-9697-4c93-b3dd-399d46e2db8c.png" style="width:71.08em;height:34.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category 4 – Perception</h1>
                </header>
            
            <article>
                
<p>This category displays information regarding the <em>Perception</em> of the <em>AI agent</em> that has been selected. <span>By default, it is assigned to the "</span><strong><em>4</em></strong><span>" key, that is, unless the "<em>NavGrid</em>" <em>Category</em> is enabled; in that case, the default key is "<strong><em>5</em></strong>".</span></p>
<div class="packt_infobox">This category doesn't show anything if no Actor has been selected.</div>
<p><span>When activated, the </span><strong><em>Perception Category</em></strong><span> appears as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2b5dc888-a378-4179-8091-90ebff80a652.png" style="width:66.92em;height:32.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>On-screen, this category displays all the senses that have been implemented, along with their debug colors. Then, each sense can show additional information, depending on the implementation of their <kbd>DescribeSelfToGameplayDebugger()</kbd> function. For instance, in the case of Sight, there is the debug colors for <strong>RangeIn</strong> and <strong>RangeOut</strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a4d34e3f-1add-42da-a61e-472c9db23f62.png" style="width:25.58em;height:8.08em;"/></p>
<p class="mce-root"/>
<p>In the level, you will be able to see the stimuli of a given sense as a sphere (along with the name of the sense, the stimulus strength, and the age of the stimulus, which is zero when on sight). Then, there is a line connecting the AI Pawn to each of the <em>stimuli</em>, and a line connecting the single <em>stimulus</em> to the target (e.g. the <em>Player</em>) if the target is not on sight. This is how it appears in the case of Sight:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-1212 image-border" src="assets/80a36625-4a65-4ada-b8ec-c611589d9167.png" style="width:39.58em;height:18.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>To show off how it appears when the target (e.g. the <em>Player</em>) is not in sight, and thus the <em>stimulus</em> has an age greater than zero and it is possible to see the black line connecting the <em>stimulus</em> to the target, here is another screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-1213 image-border" src="assets/cfbf37ae-765e-4eea-ac49-d42aaaf832ae.png" style="width:39.58em;height:18.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>If we were to add the sense of <em>Hearing</em> as well, this is what it would look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/efe1d48d-7a23-488e-9639-8bf79fd89551.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<div class="packt_infobox">Please note that the <em>Hearing Sense</em> (in yellow) is displayed on a different level (z-axis) of the <em>Sight Sense</em>. As a result, even if we have the same value, like in the preceding screenshot where both have a range of 1500, they stack up nicely.</div>
<p> Of course, the information on the side gives you more information about the debug colors that are being displayed in the game world:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a36caf58-f35a-4e1f-8a4d-5fbda4337fe1.png" style="width:21.33em;height:7.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Nav Grid Category</h1>
                </header>
            
            <article>
                
<p>Depending on your settings, you might have enabled the <strong><em>Nav Grid</em></strong> Category, which is different from the <em>NavMesh</em> <em>Category</em>.</p>
<p>This <em>Category</em> should deal with grid movement, which we haven't covered in this book. However, if you activate this <em>Category</em> in our example map, it will just show that the number of sources is equal to zero:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/03d08b2d-a625-4230-85f7-d5d07d986498.png" style="width:27.75em;height:8.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple Categories on-screen</h1>
                </header>
            
            <article>
                
<p>We have seen how each of the categories behave individually. However, just to be clear, it is possible to have as many categories as you like on display. This means that you can have multiple categories showing up at the same time. Actually, often, you will need to see more that one system at the same time:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c225cd5-5cd2-472e-846a-2431722e573b.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>One thing that I personally like about the <em>Gameplay Debugger</em> is that once you get the hang of it, even with so many <em>Categories</em> open, the information is not overwhelming the screen, and is nicely displayed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More Categories</h1>
                </header>
            
            <article>
                
<p>Although it seems that we went through all the different <em>Categories</em>, we haven't. In fact, there are some extra <em>Gameplay Debugger Categories</em> built into the Engine, for instance, the ones related to <em>HTN Planner</em> or the <em>Ability System</em>.</p>
<p>Unfortunately, they are outside the scope of this book, but you can search for them in C++. You can start your research by searching for <em><strong>GameplayDebuggerCategory</strong></em> in the <em>Engine Source</em> to find out more about them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gameplay Debugger settings</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, it is possible to configure the <em>Gameplay Debugger</em> by changing its settings.</p>
<p>If you navigate to the <strong><em>Project Settings</em></strong>, it is possible to find a whole section dedicated to the <em>Gameplay Debugger</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8ad92e61-6ce9-4210-b806-483089824dfb.png"/></p>
<p>The <strong><em>Input</em></strong> tab allows you to override the default keys for opening and closing the <em>Gameplay Debugger</em> (the default is the " '<strong><em> </em></strong>" apostrophe key) and for triggering the different categories (by default, the numbers from 0 to 9 on the <em>keypad/numpad</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9233b8de-3eaa-4e05-be1d-2d6f3044e823.png" style="width:23.42em;height:26.75em;"/></p>
<p>The <strong><em>Display</em></strong> tab allows you to define some padding on so that you can show information about the <em>Gameplay Debugger</em>. By doing this, you don't have it attached to the screen. The default values are all <em>10</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a23ddea7-5951-4410-ba59-a9f82225a3d5.png" style="width:25.58em;height:9.92em;"/></p>
<p>The <strong><em>Add-Ons tab</em></strong>,allows you to configure the single settings for both <strong><em>Categories</em></strong> (when a category is enabled by default, and which key/number it is associated with) and <strong><em>Extension</em></strong> (to override their input key):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1221 image-border" src="assets/30aa8ce0-bd0e-41ef-8c2c-27fb89871255.png" style="width:20.33em;height:21.08em;"/></p>
<div class="packt_infobox">A value of "-1" for a <em>Category</em> means that the <em>number/position/key</em> of the <em>Category</em> has been assigned by the Editor, since this <em>Category</em> doesn't have a "<em>preference</em>" of its position on the screen.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending the Gameplay Debugger</h1>
                </header>
            
            <article>
                
<p>So far, we have seen how all the different categories of the <strong><em>Gameplay Debugger</em></strong> can help us understand how our <em>AI Character</em> is behaving. However, wouldn't it be awesome if we could have our own category so that we can visualize the data of a custom (sub-)system we have developed for our game?</p>
<p>The answer is yes, and this section explains how to do it.</p>
<div class="packt_infobox">Keep in mind that the tool is called <strong><em>Gameplay Debugger</em></strong>, so you can extend it not only for AI, but for anything in your game, especially related to <em>Gameplay</em> (since it is a real-time tool to visualize information). So far, it has been extensively used for AI, but it has the potential to be used for anything else!</div>
<p>As we already have seen, the <strong><em>Gameplay Debugger</em></strong> is divided into <strong><em>Categories</em></strong> and <strong><em>Extensions</em></strong>.</p>
<p class="mce-root"/>
<p>First, we will explore how to create a <em><strong>Custom Category</strong></em> in more detail, starting from creating a separate module for it, along with all the dependencies and compiler directives that we need. We will see how we can create the class that controls the <strong><em>Category</em></strong>, and how we can register it to the <em>Gameplay Debugger</em>. As a result, we will have a fully functioning <strong><em>Gameplay Debugger Category</em></strong> that will print the location of our <em>Debug Actor</em> on-screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1222 image-border" src="assets/ce1c0b50-9055-4ae5-bd70-002540853491.png" style="width:21.00em;height:4.83em;"/></p>
<p>Lastly, we will look at how to create a <strong><em>Custom Extension</em></strong> for the <strong><em>Gameplay Debugger</em></strong>, which will be able to print the Player's location when a specific key is pressed.</p>
<p>With this being said, let's get into creating a new <em>plugin</em>!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a module with the use of a new plugin</h1>
                </header>
            
            <article>
                
<p>To extend the <em>Gameplay Debugger</em> with a new <strong><em>Category</em></strong>, you will need a new module in your game. In fact, the engine is a collection of different modules, and your game is as well (usually, the game is just one module, especially if the game is small; it is created with only one module when you start a fresh project in C++, so you will need to add more if need be).</p>
<p>There are different ways in which we can create a module, and I'm not going to go into the details of how module works, and how to create one for your project. Rather, I will guide you on how to set up a custom module for running a new <strong><em>Gameplay Debugger Category</em></strong>.</p>
<p>The easiest way to create another module is to create a plugin. As a result, the code is separated from the rest of our game, which has good and bad implications. However, we aren't going to discuss this in this section. Instead, I will show you how to create a custom <strong><em>Gameplay Debugger Category</em></strong> that you will then adapt to your specific needs.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's start by opening the <strong><em>Plugins</em></strong> menu, from the <strong><em>Settings</em></strong> menu button on top of the <em>Viewport</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c5abd63-5d1b-4331-bfdd-377d2c35cd64.png" style="width:18.58em;height:47.92em;"/></p>
<p>Once the <em><strong>Plugins</strong></em> windows is open, you will need to click on the <span class="packt_screen">New Plugin</span> button in the bottom right-corner:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f12b9f5f-92d1-4f3b-9853-bf473a1a5982.png" style="width:72.00em;height:47.75em;"/></p>
<div class="packt_infobox">It is not the only way to create a <em>Plugin</em>, but this is the fastest, since Unreal contains a simple Wizard to create different templates of <em>Plugins</em>.</div>
<p>As a result, we will open the <strong><em>New Plugin</em></strong> windows, which is a wizard for creating new plugins:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe4c4f83-bb82-49b4-821e-be8b8ebc99c3.png" style="width:71.25em;height:53.67em;"/></p>
<p>We need to select the Blank template (since we just want a bare-bones a module to load). Then, we can fill in the <em>Name</em>, which in our case is <strong><em>GameplayDebugger_Locator</em></strong>. Next, there are input fields to fill for your plugin: <em>Author</em> and <em>Description</em>. I put myself as <em>Author</em>, and for the description, I inserted "<em>A custom Gameplay Debugger Category for visualizing the position of an Actor</em>". This is what the screen should look like now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/89d7ba34-cb35-404f-8b1c-d901cabeac10.png" style="width:64.50em;height:48.50em;"/></p>
<p>Press <span class="packt_screen">Create Plugin</span> and our plugin will be created. It might take some time to process, so be patient:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4d16dad0-59c8-4ad8-91a2-158654eb4513.png" style="width:42.50em;height:8.67em;"/></p>
<p>Once it has compiled, you will have the basic structure and code of the <em>Plugin</em> as a single module. You can check it out in <em>Visual Studio</em>. Under the <em>Plugins</em> folder, you should have the following structure:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-1228 image-border" src="assets/1fe85ef2-02b3-41cc-b163-a4c27600dd8e.png" style="width:26.42em;height:19.08em;"/></p>
<p>Also, if you go back to the <em>Plugin</em> window, you will be able to see our <em>Plugin</em> (and ensure that it is enabled):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/51dcf318-369b-4c70-aeb7-e135ce1534eb.png"/></p>
<p>Of course, you are free to "<em>edit</em>" the <em>Plugin</em>, for instance, to change its icon or the category.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the module to work with the Gameplay Debugger</h1>
                </header>
            
            <article>
                
<p>Before we add the code for a new category of our <em>Gameplay Debugger</em>, there are some considerations to make.</p>
<p>First of all, the <em>Gameplay Debugger</em> is, as its name suggests, a Debug tool. This means that it shouldn't be shipped with the game. As such, we need a way to strip away all the code related to the <em>Gameplay Debugger</em> if we are compiling a shipping version of the game. Of course, the <em>Plugin</em> we are creating only includes code for the <em>Gameplay Debugger</em>, but in your game, it is more likely that it lives in a broader context.</p>
<p>To strip away the code, you need to defy a compilation variable that can be used with compilation macros; however, we only want to define this variable as true (value equal to one) if the game is not being shipped. To achieve this, we need to navigate to our Plugin <strong><em>.build.cs</em></strong> file. In our case, it is called <strong><em>GameplayDebugger_Locator.build.cs</em></strong>, and you can find it within the hierarchy of files of our <em>Plugin</em> in <em>Visual Studio</em> (or the code editor of your choice). In fact, Unreal runs some tools before compiling (e.g. to generate reflection code and replace the macro in the C++ code), and these tools are written in C#. Therefore, we can modify their behavior with a piece of C# code.</p>
<p>Once you open the file, you will find one function, which defines the different dependencies of the module. At the end of this function, add the following code:</p>
<pre>        //Code added for a Custom Category of Gameplay Debugger<br/>        if (Target.bBuildDeveloperTools || (Target.Configuration != UnrealTargetConfiguration.Shipping &amp;&amp; Target.Configuration != UnrealTargetConfiguration.Test)) {<br/>            PrivateDependencyModuleNames.Add("GameplayDebugger");<br/>            Definitions.Add("WITH_GAMEPLAY_DEBUGGER=1");<br/>        } else {<br/>            Definitions.Add("WITH_GAMEPLAY_DEBUGGER=0");<br/>        }</pre>
<p>It is an if statement that checks whether <strong><em>BuildDeveloperTools</em></strong> is true OR the Target Configuration (the configuration we are going to compile the C++ code with) is different from <strong><em>Shipping</em></strong> or <strong><em>Test</em></strong>. If this condition is verified, then we add a <strong><em>Private Dependency</em></strong> for this module, that is, the <strong><em>GameplayDebugger</em></strong> module, and define the <kbd>WITH_GAMEPLAY_DEBUGGER</kbd> variable as true (for compiling C++ code). Otherwise, we just declare <span>the </span><kbd>WITH_GAMEPLAY_DEBUGGER</kbd><span> variable false.</span></p>
<p class="mce-root"/>
<p>As a result, we are able to use <span>the </span><kbd>WITH_GAMEPLAY_DEBUGGER</kbd><span> variable in our compiler directives to include of exclude (depending which kind of configuration we are building) specific code related to the <strong><em>Gameplay Debugger</em></strong>. So, from now on, when we write code for our <strong><em>Gameplay Debugger</em></strong> category, let's not forget to wrap it in the following compile directives:</span></p>
<pre>#if WITH_GAMEPLAY_DEBUGGER<br/>    //[CODE]<br/>#endif</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new Gameplay Debugger Category</h1>
                </header>
            
            <article>
                
<p>The next step is to create a new class for our <strong><em>Gameplay Debugger Category</em></strong>.</p>
<p>As usual, we can create a new C++ class, but this time, we will select <strong><em>None</em></strong> as the Parent class (we will write the class on our own and manually make the inheritance):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fd081aec-e7ce-4e66-a6e5-ec7836f47da8.png" style="width:69.08em;height:41.75em;"/></p>
<p class="mce-root"/>
<p>Then, we can rename it <strong><em>GameplayDebuggerCategory_Locator</em></strong> (which follows the convention of starting the class name with <em>GameplayDebuggerCategory_</em>, followed by the <em>Category Name</em>). Now, be careful and select the right module; next to the module's name, you can choose the module that the class belongs to. So far, we have always worked with one module, so we didn't have this problem. You need to select the <strong><em>GameplayDebugger_Locator (Runtime)</em></strong> module, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/37aedcf6-5206-409b-838b-66cb6b51c07a.png"/></p>
<p>Create the class, and wait until it is added to our <em>Plug</em><em>in</em>.</p>
<p>Now, it's time to actively start creating our class. Go into the header (<kbd>.h</kbd>) file of our newly created class and remove everything. We will start by including the engine minimal core, and then within the <kbd><span>#if WITH_GAMEPLAY_DEBUGGER</span></kbd> compiler directive, we will also include the <kbd>GameplayDebuggerCategory.h</kbd> file, since it will be our Parent class:</p>
<pre>#pragma once<br/><br/>#include "CoreMinimal.h"<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/><br/>#include "GameplayDebuggerCategory.h"<br/><br/><em>//[REST OF THE CODE]</em><br/><br/>#endif</pre>
<p class="mce-root"/>
<p>Then, we need to create the class itself. By following conventions, we can rename the class so it has the same name as the file, <strong><em>FGameplayDebuggerCategory_Locator</em></strong>, and make it inherit from <strong><em>FGameplayDebuggerCategory</em></strong>:</p>
<pre>class FGameplayDebuggerCategory_Locator : public FGameplayDebuggerCategory<br/>{<br/><em>    //[REST OF THE CODE]</em><br/>};</pre>
<p>The <em>Gameplay Debugger</em> is a powerful tool, and as such it as many functionalities. One of those is its ability to support replication. As a result, we need to set up a structure that supports that. If you open the source files (from the Engine) of the other <em>Gameplay Debugger Categories</em>, you will see that they follow the convention of declaring a protected structure named <strong><em>FRepData</em></strong>. Within this structure, we declare all the variables that we need in order to visualize the category. In our case, we just need a string, which we will call <strong><em>ActorLocationString</em></strong>. It is also important that this structure has a way to be serialized, so we need to add the <kbd>void Serialize(FArchive&amp; Ar)</kbd> function, or at least its declaration. Finally, we can create (always under "<em>protected</em>") a variable of the <strong><em>FRepData</em></strong> type named <strong><em>DataPack</em></strong>, as shown in the following code:</p>
<pre>protected:<br/>  struct FRepData<br/>  {<br/>    FString ActorLocationString;<br/><br/>    void Serialize(FArchive&amp; Ar);<br/>  };<br/><br/>  FRepData DataPack;</pre>
<p>Next, we will need to override some public functions to make our category to work. These functions are as follows:</p>
<ul>
<li><strong><em>Constructor</em></strong>: This sets the initial parameter of the class, and will set the data replication for the <em>DataPack</em>.</li>
<li><strong><em>MakeInstance()</em></strong>: This creates an instance of this category (using a shared reference). This is required from the <em>Gameplay Debugger</em> when we register our category at a later date (meaning that we will add it to the editor).</li>
</ul>
<ul>
<li><strong><em>CollectData()</em></strong>: This collects and stores the data that we would like to show, which we then store in the <em>DataPack</em> (which can be replicated). <span>It is given in input (so that we can use it), the </span><em>Player Controller</em><span>, and the <strong><em>DebugActor</em></strong> (if available), which is the Actor we have set the focus on in the <em>Gameplay Debugger</em> (remember that we selected a specific Character when we were analyzing its behavior; here, under the hood, it is passed as a parameter to the <kbd>CollectData()</kbd> function).</span></li>
<li><strong><em>DrawData()</em></strong>: This displays the data on-screen; we will use the <em>DataPack</em> variable to retrieve the data that was collected in the <kbd>CollectData()</kbd> function. It is given in input (so that we can use it), the <em>Player Controller</em>, and the <strong><em>CanvasContext</em></strong>, which is what we will use to actually display the data on-screen.</li>
</ul>
<p>Now, we can declare them in our header (<kbd>.h</kbd>) file:</p>
<pre>public:<br/><br/>  FGameplayDebuggerCategory_Locator();<br/><br/>  static TSharedRef&lt;FGameplayDebuggerCategory&gt; MakeInstance();<br/><br/>  virtual void CollectData(APlayerController* OwnerPC, AActor* DebugActor) override;<br/><br/>  virtual void DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext&amp; CanvasContext) override;</pre>
<p>This concludes what we need in the header (<kbd>.h</kbd>) file. For your convenience, here is the whole code for the header (<kbd>.h</kbd>) file:</p>
<pre>#pragma once<br/>#include "CoreMinimal.h"<br/>#if WITH_GAMEPLAY_DEBUGGER<br/>#include "GameplayDebuggerCategory.h"<br/>class FGameplayDebuggerCategory_Locator : public FGameplayDebuggerCategory<br/>{<br/>protected:<br/>  struct FRepData<br/>  {<br/>    FString ActorLocationString;<br/>    void Serialize(FArchive&amp; Ar);<br/>  };<br/>  FRepData DataPack;<br/>public:<br/>  FGameplayDebuggerCategory_Locator();<br/>  static TSharedRef&lt;FGameplayDebuggerCategory&gt; MakeInstance();<br/>  virtual void CollectData(APlayerController* OwnerPC, AActor* DebugActor) override;<br/>  virtual void DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext&amp; CanvasContext) override;<br/>};<br/>#endif</pre>
<p>The next step is to write the implementation. So, open the <kbd>.cpp</kbd> file and wipe everything off (if you haven't already) so that you can start clean.</p>
<p>Once again, we need to include some headers. Of course, we need to include the header file of our class itself (the header file we just edited). Then, under the <kbd>#if WITH_GAMEPLAY_DEBUGGER</kbd><span> </span>compiler directive, we need to include the <em>Actor</em> class, since we will need to retrieve the position of an <em>Actor</em>:</p>
<pre>#include "GameplayDebuggerCategory_Locator.h"<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/>#include "GameFramework/Actor.h"<br/><br/><em>//[REST OF THE CODE]</em><br/><br/>#endif</pre>
<p>Now, we can start implementing all of our functions. We will start from our <strong><em>Constructor</em></strong> of the main class. Here, we can set the default parameters of the <em>Gameplay Debugger Category</em>.</p>
<p>For instance, we can set <strong>bShowOnlyWithDebugActor</strong> to <strong><em>false</em></strong>, which, as its name suggests, allows this category to be displayed, even if we haven't selected a <em>Debug Actor</em>. In fact, even if our <em>Category</em> will need the <em>DebugActor</em> to show its location, we can still print other information (in our case, we will do a simple print). Of course, when you create your category, you can decide whether this bool will be true or not.</p>
<p>However, it is more important to set our <strong><em>DataPack</em></strong> variable for replication through the <kbd>SetDataPackReplication&lt;FRepData&gt;(&amp;DataPack)</kbd> function:</p>
<pre>FGameplayDebuggerCategory_Locator::FGameplayDebuggerCategory_Locator()<br/>{<br/>  bShowOnlyWithDebugActor = false;<br/>  SetDataPackReplication&lt;FRepData&gt;(&amp;DataPack);<br/>}</pre>
<p>Next, we need to implement our <kbd>Serialize()</kbd> function for our <strong><em>RepData</em></strong> structure. Since we just have a String, its implementation is quite straightforward; we just need to insert the <em>String</em> in the <em>Archive</em>:</p>
<pre>void FGameplayDebuggerCategory_Locator::FRepData::Serialize(FArchive&amp; Ar) {<br/>  Ar &lt;&lt; ActorLocationString;<br/>}</pre>
<p>To register this <em>Category</em> to the <em>Gameplay Debugger</em>, we have to implement the <kbd>MakeInstance()</kbd> function, which will return a shared reference to an instance of this <em>Category</em>. Hence, here, the code is quite straightforward as well; just create a new instance of this class as a shared reference and return the value:</p>
<pre>TSharedRef&lt;FGameplayDebuggerCategory&gt; FGameplayDebuggerCategory_Locator::MakeInstance()<br/>{<br/>  return MakeShareable(new FGameplayDebuggerCategory_Locator());<br/>}</pre>
<p>We have two more functions to implement. The former collects the data, while the latter displays it.</p>
<p>The <kbd>CollectData()</kbd> function already has the <em>DebugActor</em> passed as a parameter. Thus, after we have verified that the reference is valid, we can retrieve the <em>DebugActor's</em> position and assign it within the <strong><em>ActorLocationString</em></strong> variable inside the <em>FRepData</em> structure that's contained in the <strong><em>DataPack</em></strong> variable. It's easier to show this than explain it:</p>
<pre>void FGameplayDebuggerCategory_Locator::CollectData(APlayerController * OwnerPC, AActor * DebugActor)<br/>{<br/>  if (DebugActor) {<br/>    DataPack.ActorLocationString = DebugActor-&gt;GetActorLocation().ToString();<br/>  }<br/>}</pre>
<div class="packt_infobox">Of course, within the <kbd>CollectData()</kbd> function, you can run any logic to retrieve your own data. Just remember to store it within the <strong><em>DataPack</em></strong> variable, which is the pointer to the <strong><em>FRepData</em></strong> structure, which can be as complex as you like (and remember to serialize that as well).</div>
<p>Finally, the <kbd>DrawData()</kbd> function is responsible for actually displaying the information we have collected. In particular, we have a reference to the <strong><em>Canvas Context</em></strong>, which we will use to "<em>print</em>" the information. We even have some formatting options, such as coloring the text by prefixing it with "<em>{color}</em>".</p>
<p>First, we will print some text, and then print the location of the <em>DebugActor</em> (if available). We will use colors too, so let's learn about how to use them:</p>
<pre>void FGameplayDebuggerCategory_Locator::DrawData(APlayerController * OwnerPC, FGameplayDebuggerCanvasContext &amp; CanvasContext)<br/>{<br/>  CanvasContext.Printf(TEXT("If a DebugActor is selected, here below is its location:"));<br/>  CanvasContext.Printf(TEXT("{cyan}Location: {yellow}%s"), *DataPack.ActorLocationString);<br/>}</pre>
<p>This was the last function for our implementation (<kbd>.cpp</kbd>) file. For your convenience, here is the whole file:</p>
<pre>#include "GameplayDebuggerCategory_Locator.h"<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/>#include "GameFramework/Actor.h"<br/><br/>FGameplayDebuggerCategory_Locator::FGameplayDebuggerCategory_Locator()<br/>{<br/>  bShowOnlyWithDebugActor = false;<br/>  SetDataPackReplication&lt;FRepData&gt;(&amp;DataPack);<br/>}<br/><br/>void FGameplayDebuggerCategory_Locator::FRepData::Serialize(FArchive&amp; Ar) {<br/>  Ar &lt;&lt; ActorLocationString;<br/>}<br/><br/>TSharedRef&lt;FGameplayDebuggerCategory&gt; FGameplayDebuggerCategory_Locator::MakeInstance()<br/>{<br/>  return MakeShareable(new FGameplayDebuggerCategory_Locator());<br/>}<br/><br/>void FGameplayDebuggerCategory_Locator::CollectData(APlayerController * OwnerPC, AActor * DebugActor)<br/>{<br/>  if (DebugActor) {<br/>    DataPack.ActorLocationString = DebugActor-&gt;GetActorLocation().ToString();<br/>  }<br/>}<br/><br/>void FGameplayDebuggerCategory_Locator::DrawData(APlayerController * OwnerPC, FGameplayDebuggerCanvasContext &amp; CanvasContext)<br/>{<br/>  CanvasContext.Printf(TEXT("If a DebugActor is selected, here below is its location:"));<br/>  CanvasContext.Printf(TEXT("{cyan}Location: {yellow}%s"), *DataPack.ActorLocationString);<br/>}<br/><br/>#endif</pre>
<p>Now, we have our <em>Gameplay Debugger Category</em>, but we need to "<strong><em>register</em></strong>" it to make it appear in the <em>Gameplay Debugger</em>. So, without further ado, let's jump into the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering the Gameplay Debugger Category</h1>
                </header>
            
            <article>
                
<p>In the previous section, we created a <em>Gameplay Debugger Category</em>, but now we need to "<strong><em>register</em></strong>" it to the <em>Gameplay Debugger</em>.</p>
<p>The easiest way to do this is by registering the category inside the <kbd>StartupModule()</kbd> function of our module, so let's open the <kbd>GameplayDebugger_Locator.cpp</kbd> file.</p>
<p>The first thing we need to do is include the <em>Gameplay Debugger Module</em>, along with the <em>Gameplay Debugger Category</em> we have created. We need to surround the <kbd>#include</kbd> statements with <span>the </span><kbd>#if WITH_GAMEPLAY_DEBUGGER</kbd><span> compiler directive, as shown in the following piece of code:</span></p>
<pre>#if WITH_GAMEPLAY_DEBUGGER<br/>#include "GameplayDebugger.h"<br/>#include "GameplayDebuggerCategory_Locator.h"<br/>#endif</pre>
<p>Inside the <kbd>StartupModule()</kbd> function, we need to check whether the <em>Gameplay Debugger Module</em> is available, and if so, retrieve a reference to it. Then, we can use this reference to register our category with the <kbd>RegisterCategory()</kbd> function, which takes three parameters (the name of the <em>Category</em>, a reference to the function to create an instance of the category, and some options as enum). Finally, we need to notify the changes. Of course, once again, this code is wrapped up by the <kbd>#if WITH_GAMEPLAY_DEBUGGER</kbd> compiler directive:</p>
<pre>void FGameplayDebugger_LocatorModule::StartupModule()<br/>{<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/><br/>  if (IGameplayDebugger::IsAvailable())<br/>  {<br/>    IGameplayDebugger&amp; GameplayDebugger = IGameplayDebugger::Get();<br/><br/>    GameplayDebugger.RegisterCategory("Locator", IGameplayDebugger::FOnGetCategory::CreateStatic(&amp;FGameplayDebuggerCategory_Locator::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate);<br/><br/>    GameplayDebugger.NotifyCategoriesChanged();<br/>  }<br/><br/>#endif<br/>}</pre>
<p>So far, so good, but when we register something in a module, we also need to "<strong><em>unregister</em></strong>" when the module shuts down. Thus, in the <kbd>ShutdownModule()</kbd> function, we need to follow the same steps as before, but this time <em>unregister</em> the category. First, we need to check the validity of the <em>Gameplay Debugger Module</em>, and then we retrieve it, <em>unregister</em> the category, and notify the changes. Once again, <span>the code is wrapped up by the </span><kbd>#if WITH_GAMEPLAY_DEBUGGER</kbd><span> compiler directive:</span></p>
<pre>void FGameplayDebugger_LocatorModule::ShutdownModule()<br/>{<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/><br/>  if (IGameplayDebugger::IsAvailable())<br/>  {<br/>    IGameplayDebugger&amp; GameplayDebugger = IGameplayDebugger::Get();<br/><br/>    GameplayDebugger.UnregisterCategory("Locator");<br/><br/>    GameplayDebugger.NotifyCategoriesChanged();<br/>  }<br/>#endif<br/>}</pre>
<p>For your convenience, here is the full code of the file:</p>
<pre>#include "GameplayDebugger_Locator.h"<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/>#include "GameplayDebugger.h"<br/>#include "GameplayDebuggerCategory_Locator.h"<br/>#endif<br/><br/>#define LOCTEXT_NAMESPACE "FGameplayDebugger_LocatorModule"<br/><br/>void FGameplayDebugger_LocatorModule::StartupModule()<br/>{<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/><br/>  if (IGameplayDebugger::IsAvailable())<br/>  {<br/>    IGameplayDebugger&amp; GameplayDebugger = IGameplayDebugger::Get();<br/><br/>    GameplayDebugger.RegisterCategory("Locator", IGameplayDebugger::FOnGetCategory::CreateStatic(&amp;FGameplayDebuggerCategory_Locator::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate);<br/><br/>    GameplayDebugger.NotifyCategoriesChanged();<br/>  }<br/><br/>#endif<br/>}<br/><br/>void FGameplayDebugger_LocatorModule::ShutdownModule()<br/>{<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/><br/>  if (IGameplayDebugger::IsAvailable())<br/>  {<br/>    IGameplayDebugger&amp; GameplayDebugger = IGameplayDebugger::Get();<br/><br/>    GameplayDebugger.UnregisterCategory("Locator");<br/><br/>    GameplayDebugger.NotifyCategoriesChanged();<br/>  }<br/>#endif<br/>}<br/><br/>#undef LOCTEXT_NAMESPACE<br/>  <br/>IMPLEMENT_MODULE(FGameplayDebugger_LocatorModule, GameplayDebugger_Locator)</pre>
<p>Compile, and our code is ready to go. Also, ensure that the <em>Plugin</em> is activated, and then close and reopen the editor (sothat we are sure that our module has been loaded properly).</p>
<p>Let's explore how what we have created works in Unreal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing the custom Gameplay Debugger Category</h1>
                </header>
            
            <article>
                
<p>Once we have restarted the editor, our <em>Plugin</em> will be loaded as well, which means that our <strong><em>Gameplay Debugger Category</em></strong> has been loaded as well. To check this, we can navigate to the <em>Project Settings</em>, under the <em>Gameplay Debugger Section</em>. Here, we have all the options to configure the <em>Gameplay Debugger</em>, including the categories that have been loaded. Thus, if we scroll down, we should be able to find our <strong><em>Locator Category</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b4440423-5ce9-43cb-aeb3-ce5bd4005b19.png"/></p>
<p>As you can see, all the options are set to "<strong><em>Use Default</em></strong>", which we set when we passed the third parameter for registering the category. However, you can also override them here (for instance, by ensuring that it is always enabled). Optionally, you can change the key that this category is triggered on, or just leave the default settings as is if you don't have any preference. The <em>Editor</em> will assign one for you:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f04e8f4-1bc4-42ee-99c2-37ecd57ac1ee.png" style="width:58.17em;height:35.17em;"/></p>
<div class="packt_infobox"><span>If you are having trouble making the plugin load with the Gameplay Debugger available, you should navigate from the top menu of Unreal to </span><strong><em>Window | Developer Tools | Modules</em></strong><span>. From here, search for our Locator Module, and then press on Reload, as shown in the following screenshot:<br/>
<br/>
<img src="assets/f89065e7-18f5-4883-bc99-5220d10f9b86.png" style="width:36.50em;height:10.50em;"/><br/></span><br/>
<span>You may need to do this every time you load the editor in order to use your Categories and/or Extension.</span></div>
<p>Now, if we press play and activate the <em>Gameplay Debugger</em>, we will s<span>ee our category listed (it may be active or not by default, depending on the settings you set previously):</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/06bb15b5-bc3b-4080-a203-bdd4e42e18e6.png" style="width:31.58em;height:10.33em;"/></p>
<p>If we select another Actor, we will be able to see that the <strong><em>Locator Category</em></strong> will display its position:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12f908b1-44e9-4c9e-909f-1ebbc4d4eda7.png" style="width:54.58em;height:28.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>Here is a close-up:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/726e566f-1b8c-4476-bd90-b08be70dd47d.png" style="width:22.25em;height:5.17em;"/></p>
<p>This concludes our discussion on creating a <strong><em>Custom Gameplay Debugger Category</em></strong>. Of course, it was a very simple example, but you can easily imagine the potential of such a tool and how this can be used in your project workflow.</p>
<p>Before we conclude this chapter, as we mentioned previously, let's have a look at how we could extend the <em>Gameplay Debugger</em> by adding an <em>Extension</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Extension for the Gameplay Debugger</h1>
                </header>
            
            <article>
                
<p><span>As we mentioned previously, the </span><em>Gameplay Debugger</em><span> is composed of </span><em>Categories</em><span> (we have already seen how to create a custom one) and </span><strong><em>Extensions</em></strong><span>. Once again, creating an </span><strong><em>Extension</em></strong><span> is only available in C++.</span></p>
<p>Like the<span> </span><em>Gameplay Debugger Category</em>, an <em>Extension</em><span> </span>needs to live on a<span> </span><em>Custom Module</em>, but it can be the same one as the<span> </span><em>Category</em><span> </span>(or<span> </span><em>Categories</em>). Thus, I'm going to use the same plugin we just developed.</p>
<p>In particular, we are going to create a simple extension that, when we press a specific key, prints the position of the Player in the output log.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The structure of the Extension</h1>
                </header>
            
            <article>
                
<p>We need to create a new C++ class and inherit from <strong><em>GameplayDebuggerExtension</em></strong> (by starting from an empty class, like we did when extending the Categories, and then build on that). The naming convention that we'll be using here is "<em>GameplayDebuggerExtension_Name</em>" (however, keep in mind that there might be a limit of <em>32</em> characters for the file name). In our case, we will go for <strong><em>GameplayDebuggerExtension_Player</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/75791a25-7329-4479-b293-3ed45354e0e9.png"/></p>
<p>The structure of a <em>Gameplay Debugger Extension</em> is quite straightforward, since we will need to implement and/or override the following functions:</p>
<ul>
<li><strong><em>Constructor</em></strong>: This sets the default value for the extensions, including settings. More importantly, it sets the key binding for the extension (and passes a reference to the function you wish to bind).</li>
<li><strong><em>MakeInstance()</em></strong>: This creates an instance of the <em>Gameplay Debugger Extension</em> as a shared reference. This function is required when the <em>Extension</em> is registered.</li>
<li><strong><em>OnActivated()</em></strong>: This performs initialization when the <em>Extension</em> is activated (e.g. the <em>Gameplay Debugger</em> opens).</li>
<li><strong><em>OnDeactivated()</em></strong>: This cleans up when the <em>Extension</em> is deactivated (e.g. the <em>Gameplay Debugger</em> closes). For instance, the Spectator extension uses this function to destroy the spectator controller (if it exists) and return control to the <em>Player Controller</em> that was there before.</li>
<li><strong><em>GetDescription()</em></strong>: This describes the <em>Extension</em> to the <em>Gameplay Debugger</em>. This means that this function returns a <em>String</em> that's used to display the text in the Gameplay Debugger; the usual format with the color is allowed. Moreover, you are able to use <em><kbd>FGameplayDebuggerCanvasStrings::ColorNameEnabled</kbd></em> and <kbd><em>FGameplayDebuggerCanvasStrings::ColorNameDisabled</em></kbd> for the String that describes the colors of enabled or disabled for the extension, respectively. This is very useful if your <em>Extension</em> uses a toggle.</li>
<li><strong><em>Action Function</em></strong>: This performs the action that you want your <em>Extension</em> to do, so here, it can be whatever you want. This function will be passed to the Input Binding in the <em>Constructor</em>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Extension class</h1>
                </header>
            
            <article>
                
<p>Of course, we don't need all the functions we just looked at. In our case, we can start by declaring the <kbd>Constructor</kbd>, <kbd>GetDescription()</kbd>, and <kbd>MakeInstance()</kbd> functions in the header (<kbd>.h</kbd>) file:</p>
<pre>public:<br/>  GameplayDebuggerExtension_Player();<br/><br/>  //virtual void OnDeactivated() override;<br/>  virtual FString GetDescription() const override;<br/><br/>  static TSharedRef&lt;FGameplayDebuggerExtension&gt; MakeInstance();</pre>
<p>Next, we will need a protected function, which we will bind to a specific input:</p>
<pre>protected:<br/><br/>  void PrintPlayerLocation();</pre>
<p>Then, we will need some protected variables: a boolean variable to check if an input has been binded, another boolean variable to see if the description has been cached, and a third variable that contains the cached description itself:</p>
<pre>protected:<br/>  uint32 bHasInputBinding : 1;<br/>  mutable uint32 bIsCachedDescriptionValid : 1;<br/>  mutable FString CachedDescription;</pre>
<div class="packt_infobox">For performance reasons, it is always good practice to cache the description of a <em>Gameplay Debugger Extension</em>.</div>
<p>Of course, don't forget to enclose the whole class within the conditional compiler directive and the <kbd><em>WITH_GAMEPLAY_DEBUGGER</em></kbd> macro. This is what the header (<kbd>.h</kbd>) file should look like:</p>
<pre>#include "CoreMinimal.h"<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/>#include "GameplayDebuggerExtension.h"<br/><br/>/**<br/> * <br/> */<br/>class GAMEPLAYDEBUGGER_LOCATOR_API GameplayDebuggerExtension_Player : public FGameplayDebuggerExtension<br/>{<br/>public:<br/>  GameplayDebuggerExtension_Player();<br/><br/>  //virtual void OnDeactivated() override;<br/>  virtual FString GetDescription() const override;<br/><br/>  static TSharedRef&lt;FGameplayDebuggerExtension&gt; MakeInstance();<br/><br/>protected:<br/><br/>  void PrintPlayerLocation();<br/><br/>  uint32 bHasInputBinding : 1;<br/>  mutable uint32 bIsCachedDescriptionValid : 1;<br/>  mutable FString CachedDescription;<br/><br/>};<br/><br/>#endif</pre>
<p>For the implementation, we can start by adding the following <kbd>#include</kbd> statements, since we will need to have access to the Player Controller and its Pawn to retrieve the Player's location. Also, we will need to bind inputs, so we need to include the <em>Input Core Types</em> as well:</p>
<pre>#include "InputCoreTypes.h"<br/>#include "GameFramework/PlayerController.h"<br/>#include "GameFramework/Pawn.h"</pre>
<p>Next, we will implement our Constructor. Here is where we bind the input to a specific key. In our case, we can bind it to the <em>P</em> key. Of course, we will need a delegate, and we can pass our <kbd>PrintPlayerLocation()</kbd> function to do so:</p>
<pre>GameplayDebuggerExtension_Player::GameplayDebuggerExtension_Player()<br/>{<br/>  const FGameplayDebuggerInputHandlerConfig KeyConfig(TEXT("PrintPlayer"), EKeys::NumLock.GetFName());<br/>  bHasInputBinding = BindKeyPress(KeyConfig, this, &amp;GameplayDebuggerExtension_Player::PrintPlayerLocation);<br/>}</pre>
<p>As we mentioned previously, if you can, cache your description so that your <em>Extension</em> gains some performance. Here is the code structure for caching our description:</p>
<pre>FString GameplayDebuggerExtension_Player::GetDescription() const<br/>{<br/>  if (!bIsCachedDescriptionValid)<br/>  {<br/>    CachedDescription = <em>[SOME CODE HERE TO RETRIEVE THE DESCRIPTION]</em><br/><br/>    bIsCachedDescriptionValid = true;<br/>  }<br/><br/>  return CachedDescription;<br/>}</pre>
<p>Now, we need to get the Description. In this case, it can just be the Input Handler (so that we remember which key this Extension is bound to, and the word "Player" to remember that this is the Extension that retrieves the Player's location. As for the colors, the Gameplay Debugger Extension provides some shortcuts for accessing specific colors (for instance, for toggling different kinds of Extensions, the color can changed based on whether it is toggled or not). We won't pay much attention to colors at the moment, and we will use the default ones, assuming that everything is always enabled. As a result, this is the <kbd>GetDescription()</kbd> function:</p>
<pre>FString GameplayDebuggerExtension_Player::GetDescription() const<br/>{<br/>  if (!bIsCachedDescriptionValid)<br/>  {<br/>    CachedDescription = !bHasInputBinding ? FString() :<br/>      FString::Printf(TEXT("{%s}%s:{%s}Player"),<br/>        *FGameplayDebuggerCanvasStrings::ColorNameInput,<br/>        *GetInputHandlerDescription(0),<br/>        *FGameplayDebuggerCanvasStrings::ColorNameEnabled);<br/><br/>    bIsCachedDescriptionValid = true;<br/>  }<br/><br/>  return CachedDescription;<br/>}</pre>
<p>The <kbd>MakeInstance()</kbd> function, on the other hand, is pretty straightforward and very similar to the one we used for the <em>Gameplay Debugger Categories</em>; it just needs to return a shared reference to this Extension:</p>
<pre>TSharedRef&lt;FGameplayDebuggerExtension&gt; GameplayDebuggerExtension_Player::MakeInstance()<br/>{<br/>  return MakeShareable(new GameplayDebuggerExtension_Player());<br/>}</pre>
<p>Finally, in our <kbd>PrintPlayerPosition()</kbd> function, we can just use a <em>UE_LOG</em> to print the Player's location. However, in a <em>Gameplay Debugger Extension</em>, its in these kind of functions (which are bound to the input) that the real magic happens:</p>
<pre>void GameplayDebuggerExtension_Player::PrintPlayerLocation()<br/>{<br/>  UE_LOG(LogTemp, Warning, TEXT("Player's Location: %s"), *GetPlayerController()-&gt;GetPawn()-&gt;GetActorLocation().ToString());<br/>}</pre>
<p>Once again, don't forget to wrap your C++ class with the compiler directive.</p>
<p>As a result, this is the <kbd>.cpp</kbd> file of our class:</p>
<pre>#include "GameplayDebuggerExtension_Player.h"<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/>#include "InputCoreTypes.h"<br/>#include "GameFramework/PlayerController.h"<br/>#include "GameFramework/Pawn.h"<br/>//#include "GameplayDebuggerPlayerManager.h"<br/>//#include "Engine/Engine.h"<br/><br/>GameplayDebuggerExtension_Player::GameplayDebuggerExtension_Player()<br/>{<br/>  const FGameplayDebuggerInputHandlerConfig KeyConfig(TEXT("PrintPlayer"), EKeys::NumLock.GetFName());<br/>  bHasInputBinding = BindKeyPress(KeyConfig, this, &amp;GameplayDebuggerExtension_Player::PrintPlayerLocation);<br/>}<br/><br/>FString GameplayDebuggerExtension_Player::GetDescription() const<br/>{<br/>  if (!bIsCachedDescriptionValid)<br/>  {<br/>    CachedDescription = !bHasInputBinding ? FString() :<br/>      FString::Printf(TEXT("{%s}%s:{%s}Player"),<br/>        *FGameplayDebuggerCanvasStrings::ColorNameInput,<br/>        *GetInputHandlerDescription(0),<br/>        *FGameplayDebuggerCanvasStrings::ColorNameEnabled);<br/><br/>    bIsCachedDescriptionValid = true;<br/>  }<br/><br/>  return CachedDescription;<br/>}<br/><br/>TSharedRef&lt;FGameplayDebuggerExtension&gt; GameplayDebuggerExtension_Player::MakeInstance()<br/>{<br/>  return MakeShareable(new GameplayDebuggerExtension_Player());<br/>}<br/><br/>void GameplayDebuggerExtension_Player::PrintPlayerLocation()<br/>{<br/>  UE_LOG(LogTemp, Warning, TEXT("Player's Location: %s"), *GetPlayerController()-&gt;GetPawn()-&gt;GetActorLocation().ToString());<br/>}<br/><br/>#endif</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering the Extension</h1>
                </header>
            
            <article>
                
<p>Just like we did for <em>Gameplay Debugger Categories</em>, we need to register the <em>Extensions</em> as well.</p>
<p>However, before we do that, if we try to compile, we will get an error. In fact, since we handle inputs for the <em>Extension</em>, the module in which the <em>Extension</em> lives requires the <strong><em>Public Dependency</em></strong> to the "<strong><em>InputCore</em></strong>". Add the following line to your <kbd>.build.cs</kbd> file:</p>
<pre>PrivateDependencyModuleNames.Add("InputCore");</pre>
<p>Specifically, for our Locator Module, this is how you should insert this dependency in the <kbd>GameplayDebugger_Locator.build.cs</kbd> file:</p>
<pre>        if (Target.bBuildDeveloperTools || (Target.Configuration != UnrealTargetConfiguration.Shipping &amp;&amp; Target.Configuration != UnrealTargetConfiguration.Test)) {<br/>            PrivateDependencyModuleNames.Add("GameplayDebugger");<br/><strong>            PrivateDependencyModuleNames.Add("InputCore");</strong><br/>            Definitions.Add("WITH_GAMEPLAY_DEBUGGER=1");<br/>        } else {<br/>            Definitions.Add("WITH_GAMEPLAY_DEBUGGER=0");<br/>        }</pre>
<p>If you compile after this modification, you shouldn't get any errors.</p>
<p>Now, it's time to register the Extension and notify the <em>Gameplay Debugger</em> of this change. We need to use specific functions to do so. Thus, in our <kbd>StartupModule()</kbd> function (in the <kbd>GameplayDebugger_Locatot.cpp</kbd> file), we need to add the following bold lines of code so that we can register and notify the <em>Gameplay Debugger</em> accordingly (note that we need to do this for both <em>Extensions</em> and <em>Categories</em>, since they are two different functions):</p>
<pre> void FGameplayDebugger_LocatorModule::StartupModule()<br/>{<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/><br/>  UE_LOG(LogTemp, Warning, TEXT("Locator Module Loaded"));<br/><br/>  if (IGameplayDebugger::IsAvailable())<br/>  {<br/>    IGameplayDebugger&amp; GameplayDebugger = IGameplayDebugger::Get();<br/><br/><strong>    GameplayDebugger.RegisterExtension("Player", IGameplayDebugger::FOnGetExtension::CreateStatic(&amp;GameplayDebuggerExtension_Player::MakeInstance));</strong><br/><br/><strong>    GameplayDebugger.NotifyExtensionsChanged();</strong><br/><br/>    GameplayDebugger.RegisterCategory("Locator", IGameplayDebugger::FOnGetCategory::CreateStatic(&amp;FGameplayDebuggerCategory_Locator::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate);<br/><br/>    GameplayDebugger.NotifyCategoriesChanged();<br/><br/>    UE_LOG(LogTemp, Warning, TEXT("GameplayDebugger Registered"));<br/>  }<br/><br/>#endif<br/>}</pre>
<p>The same goes for unregistering the <em>Extension</em> when the module shuts down. Here is the code we need to add in the <kbd>ShutdownModule()</kbd> function:</p>
<pre>void FGameplayDebugger_LocatorModule::ShutdownModule()<br/>{<br/><br/>#if WITH_GAMEPLAY_DEBUGGER<br/><br/>  if (IGameplayDebugger::IsAvailable())<br/>  {<br/>    IGameplayDebugger&amp; GameplayDebugger = IGameplayDebugger::Get();<br/><br/><strong>    GameplayDebugger.UnregisterExtension("Player");</strong><br/><br/><strong>    GameplayDebugger.NotifyExtensionsChanged();</strong><br/><br/>    GameplayDebugger.UnregisterCategory("Locator");<br/><br/>    GameplayDebugger.NotifyCategoriesChanged();<br/><br/>  }<br/>#endif<br/>}</pre>
<p>Compile the code, and your plugin will be ready. You might need to restart the editor for the effects to take place.</p>
<div class="packt_infobox">If you are still having trouble making the plugin load with the Gameplay Debugger available, navigate from the top menu of Unreal to <strong><em>Window -&gt; Developer Tools | Modules</em></strong>. From here, search for our Locator Module and then press on Reload, as shown in the following screenshot:<br/>
<br/>
<img src="assets/5bd100ac-6a94-4806-b7e3-c32ef8201dca.png" style="width:28.42em;height:8.17em;"/><br/>
<br/>
You may need to do this every time you load the editor in order to use your Categories and/or Extension.</div>
<p>If you go into the <em>Gameplay Debugger Settings</em>, you will find our <em>Extension</em> listed (and you will be able to change the key bind if you wish):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8b1c68ab-fd44-4a62-8245-4f52a0a8c966.png" style="width:37.83em;height:33.17em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This is how it will appear in-game:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/380779c3-7e34-4d76-aef5-663bf986a9a2.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>This is a screenshot of the output. The other (blurred out) information is not important here</span></div>
<p>Here is a close-up:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c311ca72-1515-4acd-a8ce-155eeba46ee8.png" style="width:29.58em;height:14.25em;"/></p>
<p>If you press <em>P</em>, then the Extension will produce the following result in the <em>Output Log</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/02166dd5-76dc-41a0-970f-fdf03147d002.png" style="width:39.17em;height:23.42em;"/></p>
<div class="packt_infobox"><span>For more information about <em>Gameplay Debugger Extensions</em>, you should have a look at the classes contained in </span><kbd>GameplayDebuggerExtension.h</kbd><span> (the vase class to create an </span><em>Extension</em><span> of the </span><em>Gameplay Debugger</em><span>) and </span><kbd>GameplayDebuggerExtension_Spectator.h</kbd><span> (an implementation of an </span><em>Extension</em><span>, with an example of </span><em>Input Binding</em><span> and </span><em>Cached Description</em><span> as well).</span></div>
<p>This concludes our adventure into extending the <em>Gameplay Debugger</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we look at how to take advantage of the <strong><em>Gameplay Debugger</em></strong> for testing our AI systems. In particular, we looked at the default <strong><em>Categories and Extensions</em></strong> of the <em>Gameplay Debugger</em>, how they work, and which kind of information they display.</p>
<p>Then, we saw how it is possible to <strong><em>extend the Gameplay Debugger</em></strong> by <strong><em>creating a new Category</em></strong> and a <strong><em>new Extension</em></strong> within a <strong><em>Plugin</em></strong>. As a result, we unlocked great potential for debugging our own systems.</p>
<p>In the next chapter, we will explore <strong><em>AI in Games</em></strong> further, and see what's beyond.</p>


            </article>

            
        </section>
    </body></html>