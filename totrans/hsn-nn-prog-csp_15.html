<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Object Detection with TensorFlowSharp</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to introduce you to an open source package called TensorFlowSharp. More specifically, we will be using the TensorFlow[1] Object Detection API, which is an open source framework built on top of TensorFlow, which makes it easy to construct, train, and deploy various forms of object detection models.</p>
<p>For those not familiar with TensorFlow, the following is an excerpt from the TensorFlow website[2]:</p>
<div class="packt_quote">"TensorFlow is an open source software library for high performance numerical computation. Its flexible architecture allows easy deployment of computation across a variety of platforms (such as CPUs, GPUs, and TPUs), and from desktops to clusters of servers to mobile and edge devices. Originally developed by researchers and engineers from the Google Brain team within Google's AI organization, it comes with strong support for machine learning and deep learning and the flexible numerical computation core is used across many other scientific domains."</div>
<p>TensorFlowSharp provides .NET bindings to the TensorFlow library, which are published here in case you ever need them: <a href="https://github.com/tensorflow/tensorflow">https://github.com/tensorflow/tensorflow</a>.</p>
<p>The topics included in this chapter are as follows:</p>
<ul>
<li>Working with Tensors</li>
<li>TensorFlowSharp</li>
<li>Developing your own TensorFlow application</li>
<li>Detecting images</li>
<li>Minimum score for object highlighting</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have a basic knowledge of .NET development using Microsoft Visual Studio and C#. You will need to download the code for this chapter from this book's website: TensorFlowSharp (<a href="https://github.com/migueldeicaza/TensorFlowSharp">https://github.com/migueldeicaza/TensorFlowSharp</a>).</p>
<p><span>Check out the following video to see Code in Action: <a href="http://bit.ly/2pqEiZ9">http://bit.ly/2pqEiZ9</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Tensors</h1>
                </header>
            
            <article>
                
<p>Let's set the stage by talking about exactly what a Tensor is. To do so, we should also talk a little bit about vectors and matrices as well. You can skip this section if you are already familiar, but it is short and if you already know about matrices and vectors, who knows, you might remember something you've forgotten! So go ahead and read it anyway!</p>
<p>Now, before we talk, let me show you a graphic that may make things a tad easier to visualize:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/675f7f29-5fa7-4268-8de1-70d4d722e154.png" style="width:20.92em;height:7.42em;"/></p>
<p>A vector is an array of numbers, as you can see here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/72e88d89-376d-4efe-a1a9-a0407314fe14.png" style="width:6.67em;height:7.42em;"/></p>
<p>A matrix is a grid of <em>n x m</em> numbers, a two-dimensional array. We can do all kinds of neat operations on a matrix, such as addition and subtraction, so long as the sizes are compatible:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/67331aa6-3be7-4e38-86b0-61e5f3db8826.png" style="width:19.00em;height:6.92em;"/></p>
<p>We can multiply matrices if we so desire, like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d4ac0e9f-3907-417f-925c-ada51d5d6a8d.png" style="width:16.25em;height:7.50em;"/></p>
<p>And matrices can be added together, like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9855310d-b3b7-46a2-b71f-d4d2f74b268e.png" style="width:13.42em;height:24.83em;"/></p>
<p>In both cases, we are working within a two-dimensional space. So, what can we do if our requirement is to work out of an <em>n</em> dimensional space to where <em>n &gt; 2</em>? This where Tensors come in.</p>
<p>A Tensor is basically a matrix but is not two-dimensional (although it could be). It could be a three-dimensional matrix (a vector is a tensor is a matrix) or some incredibly crazy dimension that we do not yet know how to visualize. And to show you how powerful Tensors really are, a tensor can be covariant in one dimension and contravariant in another. The dimension of a tensor is usually called its <strong>rank</strong>.</p>
<p>More formally, a tensor is really what is called a <strong>mathematical entity</strong>, which lives inside a structure and interacts with other entities inside that structure. If one of the entities gets transformed, the tensor must obey what is referred to as a <strong>related transformation rule</strong>. This is really what differentiates a matrix from a tensor. The tensor must allow the entities to shift around when transformations occur.</p>
<p>Now that we've got that all squared away and under our belts, let's look at how we can work with Tensors by walking through a bit of example code:</p>
<pre>void BasicVariables ()<br/>{<br/>Console.WriteLine ("Using placerholders");<br/>using (var g = new TFGraph ())<br/>{<br/>var s = new TFSession (g);</pre>
<p>Notice the variable type must match the cast in the <kbd>TFTensor</kbd>:</p>
<pre>var var_a = g.Placeholder (TFDataType.<strong>Int16</strong>);<br/>var var_b = g.Placeholder (TFDataType.<strong>Int16</strong>);</pre>
<p>We are going to do addition and multiplication:</p>
<pre>var add = g.Add (var_a, var_b);<br/>var mul = g.Mul (var_a, var_b);<br/>var<strong>runner</strong> = s.GetRunner ();</pre>
<p>Let's add two Tensors together (<span>this is the variable type cast mentioned previously)</span>:</p>
<pre><strong>runner</strong>.AddInput (var_a, new TFTensor ((short)3));<br/><strong>runner</strong>.AddInput (var_b, new TFTensor ((short)2));<br/>Console.WriteLine ("a+b={0}", <strong>runner</strong>.Run (add).GetValue ());</pre>
<p>Now let's multiply two Tensors together:</p>
<pre><strong>runner</strong> = s.GetRunner ();<br/><strong>runner</strong>.AddInput (var_a, new TFTensor ((short)3));<br/><strong>runner</strong>.AddInput (var_b, new TFTensor ((short)2));<br/>Console.WriteLine ("a*b={0}", <strong>runner</strong>.Run (mul).GetValue ());<br/>}<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TensorFlowSharp</h1>
                </header>
            
            <article>
                
<p>Now that we've talked about and shown you Tensors, let's look at how we would typically use the TensorFlowSharp API itself.</p>
<p>Your application will typically create a graph (<kbd>TFGraph</kbd>), set up the operations there, then create a session from it (<kbd>TFSession</kbd>). This session will then use the session runner to set up inputs and outputs and execute the pipeline. Let's look at a quick example of how that might flow:</p>
<pre>using(var graph = new TFGraph ())<br/>{<br/>graph.Import (File.ReadAllBytes ("MySavedModel"));<br/>var session = new TFSession (graph);<br/>var runner = session.GetRunner ();<br/>runner.AddInput (graph ["input"] [0], tensor);<br/>runner.Fetch (graph ["output"] [0]);<br/>var output = runner.Run ();</pre>
<p>Fetch the results from the output:</p>
<pre>TFTensor result = output [0];<br/>}</pre>
<p>In scenarios where you do not need to set up the graph independently, the session will create one automatically for you. The following example shows how to use TensorFlow to compute the sum of two numbers. We will have the session automatically create the graph for us:</p>
<pre>using (var session = new TFSession())<br/>{<br/>var graph = session.Graph;<br/>var a = graph.Const(2);<br/>var b = graph.Const(3);<br/>Console.WriteLine("a=2 b=3");</pre>
<p>Add two constants:</p>
<pre>var addingResults = session.GetRunner().Run(graph.Add(a, b));<br/>var addingResultValue = addingResults.GetValue();<br/>Console.WriteLine("a+b={0}", addingResultValue);</pre>
<p>Multiply two constants:</p>
<pre>var multiplyResults = session.GetRunner().Run(graph.Mul(a, b));<br/>var multiplyResultValue = multiplyResults.GetValue();<br/>Console.WriteLine("a*b={0}", multiplyResultValue);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing your own TensorFlow application</h1>
                </header>
            
            <article>
                
<p>Now that we've shown you some preliminary code samples, let's move on to our example project—how to use TensorFlowSharp from a console application to detect objects within an image. This code is easy enough for you to be able to add into your solution if you so desire. Just tweak the input and output names, perhaps allow for user adjusted hyperparameters, and you're off!</p>
<p>To run this solution, you should have the source code for this chapter downloaded from the website and open in Microsoft Visual Studio. Please follow the instructions for downloading code for this book:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4032a2ef-1c63-4ca2-9984-697fc3b7d01c.png" style="width:20.42em;height:20.58em;"/></p>
<p>Before we dive into the code, let's talk about one very important variable:</p>
<pre>private static double MIN_SCORE_FOR_OBJECT_HIGHLIGHTING = 0.5;</pre>
<p>This variable is our threshold for identifying and highlighting objects in our base image. At 0.5, there is a reasonable synchronicity between detection reliability and accuracy. As we lower this number, we will find that more objects are identified, however, the identification accuracy begins to suffer. The lower we go, the greater the chance we have of identifying objects incorrectly. We will identify them, but they may not be what we intended, as you will see in a bit.</p>
<p>Now, let's have a quick look at the main function of this sample and walk through what it's doing:</p>
<pre>static void Main(string[] args)<br/>{</pre>
<p>Load the default model and data:</p>
<pre>_catalogPath = DownloadDefaultTexts(_currentDir);<br/>_modelPath = DownloadDefaultModel(_currentDir);<br/>_catalog = CatalogUtil.ReadCatalogItems(_catalogPath);<br/>var fileTuples = new List&lt;(string input, string output)&gt;() { (_input, _output) };<br/>string modelFile = _modelPath;</pre>
<p>Let's create our TensorFlowSharp graph object here:</p>
<pre>using (var graph = new TFGraph())<br/>{</pre>
<p>Read all of the data into our graph object:</p>
<pre>graph.Import(new TFBuffer(File.ReadAllBytes(modelFile)));</pre>
<p>Create a new TensorFlowSharp session to work with:</p>
<pre>using (var session = new TFSession(graph))<br/>{<br/>Console.WriteLine("Detecting objects", Color.Yellow);<br/>foreach (var tuple in fileTuples)<br/>{</pre>
<p>Create our tensor from our image file:</p>
<pre>var tensor = ImageUtil.CreateTensorFromImageFile(tuple.input, TFDataType.<strong>UInt8</strong>);<br/>var runner = session.GetRunner();<br/>runner.AddInput(graph["image_tensor"][0], tensor).Fetch(graph["detection_boxes"][0],graph["detection_scores"][0],graph["detection_classes"][0],graph["num_detections"][0]);var output = runner.Run();<br/>var boxes = (float[,,])output[0].GetValue();<br/>var scores = (float[,])output[1].GetValue();<br/>var classes = (float[,])output[2].GetValue();<br/>Console.WriteLine("Highlighting object...", Color.Green);</pre>
<p>After all variables are processed, let's identify and draw the boxes of the objects we have detected on our sample image:</p>
<pre>DrawBoxesOnImage(boxes, scores, classes, tuple.input, tuple.output, MIN_SCORE_FOR_OBJECT_HIGHLIGHTING);<br/>Console.WriteLine($"Done. See {_output_relative}. Press any key", Color.Yellow);<br/>Console.ReadKey();<br/>}<br/>}<br/>}</pre>
<p>Well, that is all well and good for a simple operation, but what if what we really need to do is a more complicated operation, let's say multiplying a matrix? We can do that as follows:</p>
<pre>void BasicMultidimensionalArray ()<br/>{</pre>
<p>Create our <kbd>TFGraph</kbd> object:</p>
<pre>using (var g = new TFGraph ())<br/>{</pre>
<p>Create our <kbd>TFSession</kbd> object:</p>
<pre>var s = new TFSession (g);</pre>
<p>Create a placeholder for our variable for multiplication:</p>
<pre>var var_a = g.Placeholder (TFDataType.<strong>Int32</strong>);<br/>var mul = g.Mul (var_a, g.Const (2));</pre>
<p>Do the multiplication:</p>
<pre>var a = new int[,,] { { { 0, 1 } , { 2, 3 } } , { { 4, 5 }, { 6, 7 } } };<br/>var result = s.GetRunner ().AddInput (var_a, a).Fetch (mul).Run () [0];</pre>
<p>Test the results:</p>
<pre>var actual = (int[,,])result.GetValue ();<br/>var expected = new int[,,] { { {0, 2} , {4, 6} } , { {8, 10}, {12, 14} } };<br/>Console.WriteLine ("Actual: " + RowOrderJoin (actual));<br/>Console.WriteLine ("Expected: " + RowOrderJoin (expected));<br/>Assert(expected.Cast&lt;int&gt; ().SequenceEqual (actual.Cast&lt;int&gt; ()));<br/>};<br/>}<br/>private static string RowOrderJoin(int[,,] array) =&gt; string.Join (", ", array.Cast&lt;int&gt; ());</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Detecting images</h1>
                </header>
            
            <article>
                
<p>Now it's time to move on to a real project. In this example, we are going to take our base image (seen as follows) and use it to have the computer detect objects in the image. As you can see, there are several instances of people and kites in the photograph. This is the same base image used in all TensorFlowSharp examples. You are going to see the detection and highlighting progresses changes as we change our minimum allowed threshold.</p>
<p>Here is our base sample image, a photograph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cdfdcd84-0e30-46a1-b76a-c466117b725d.jpg" style="width:41.25em;height:27.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Minimum score for object highlighting</h1>
                </header>
            
            <article>
                
<p>We talked before about the minimum score for highlighting. Let's see exactly what that means by taking a look at what happens when we use different minimum scores for object highlighting. Let's start out with a value of 0.5 and see what objects are detected within our photograph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e88cc8b7-1447-49a6-abc8-d95be6b31372.jpg" style="width:42.08em;height:28.00em;"/></p>
<p>As you can see, we have two kites selected with a fairly good accuracy score attached to each. The boxes are drawn in green to indicate high confidence targets. Not bad. But there are still a lot of objects out there that I think we should be picking up. There are a few more kites and several people that should be easy to detect. Why haven't we done so?</p>
<p>What if we lowered our minimum threshold to 0.3 instead of 0.5? Let's see the result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b74884a5-3af0-4975-8d81-5ac4c665919a.jpg" style="width:42.00em;height:28.00em;"/></p>
<p>Well, as you can see, we do pick up other kites, albeit with a lower confidence score due to their distance in the photograph, but we have also, more importantly, now started to recognize people. Any box drawn in red is a low confidence target, green is high, and yellow is medium.</p>
<p>Now, what if we went one step further and lowered our minimum threshold all the way down to 0.1? If our pattern follows, we should be able to identify more images, albeit with lower confidence scores, of course.</p>
<p>If you look at the following version of the photograph, you can see that we do, in fact, have many more objects selected. Unfortunately, the accuracy has diminished considerably, as we suspected. Kites were confused with people, and in one case a tree was confused with a person as well. But the positive note is that our recognition changes as we adjust our threshold. Could this be done adaptively in a more advanced application? Absolutely, and it's those kinds of thoughts I want to nurture so that you can embellish the code and make truly earth-shaking applications:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8871d473-738d-42c2-91bd-eeb01046dd72.jpg" style="width:41.75em;height:27.83em;"/></p>
<p>OK, there's one final example that I think you will like. In this example, I have dropped the minimum threshold down to 0.01. If our hunch is right, the screen should light up with low confidence targets now. Let's see whether we're right:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/15f03c40-9a83-4ed9-b873-72c01a3bcbb4.png" style="width:41.58em;height:27.58em;"/></p>
<p>It looks like our hunch was right. I know the screen labeling is cluttered, but the point is that we have increased our object detection, albeit for a lower confidence threshold.</p>
<p>You should now take some time and consider all of the exciting applications for such technology. From face and object detection to autonomous vehicles, Tensors are used everywhere today and it's something you should get familiar with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>TensorFlowSharp is an exciting open source project that makes working with Tensors and TensorFlow incredibly easy. In this chapter, we showed you what Tensors are and how you can work with them. We also built an incredibly powerful sample application that allows you to detect and label images within a picture.</p>
<p>In our next chapter, we will learn about long short-term memory networks and how you can use them to enhance your applications and processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<ul>
<li>[1]"Speed/accuracy trade-offs for modern convolutional object detectors."Huang J, Rathod V, Sun C, Zhu M, Korattikara A, Fathi A, Fischer I, Wojna Z, Song Y, Guadarrama S, Murphy K, CVPR 2017</li>
<li>[2] <a href="http://www.tensorflow.org">www.tensorflow.org</a></li>
<li>[3] JEAN, Hadrien. <em>Deep Learning Book Series 2.1 Scalars Vectors Matrices and Tensors</em> Web blog post. <a href="http://hadrienj.github.io">hadrienj.github.io</a>. 26 Mar. 2018.</li>
</ul>


            </article>

            
        </section>
    </body></html>