["```py\nusing UnityEngine;\npublic class Target : MonoBehaviour { \n    [SerializeField]\n    private float hOffset = 0.2f;\n    void Update () {\n        int button = 0;\n        //Get the point of the hit position when the mouse \n        //is being clicked \n        if(Input.GetMouseButtonDown(button)) {\n            Ray ray = Camera.main.ScreenPointToRay(\n              Input.mousePosition);\n            RaycastHit hitInfo;\n            if (Physics.Raycast(ray.origin, ray.direction,\n                out hitInfo)) {\n                Vector3 targetPosition = hitInfo.point;\n                transform.position = targetPosition + \n                  new Vector3(0.0f, hOffset, 0.0f);\n            }\n        }\n    }\n}\n```", "```py\nusing UnityEngine;\npublic class PlayerTank : MonoBehaviour { \n    public Transform targetTransform;\n    [SerializeField]\n    private float movementSpeed = 10.0f;\n    [SerializeField]\n    private float rotSpeed = 2.0f;\n    [SerializeField]\n    private float targerReactionRadius = 5.0f;\n    void Update () {\n        //Stop once you reached near the target position\n        if (Vector3.Distance(transform.position,\n          targetTransform.position) < targetReactionRadius) \n          return;\n        //Calculate direction vector from current position\n        // to target position\n\n        Vector3 tarPos = targetTransform.position;\n        tarPos.y = transform.position.y;\n        Vector3 dirRot = tarPos - transform.position;\n        //Build a Quaternion for this new rotation vector\n        //using LookRotation method\n        Quaternion tarRot = \n          Quaternion.LookRotation(dirRot);\n        //Move and rotate with interpolation\n        transform.rotation= Quaternion.Slerp(\n          transform.rotation, tarRot, \n          rotSpeed * Time.deltaTime);\n        transform.Translate(new Vector3(0, 0, \n          movementSpeed * Time.deltaTime));\n    }\n}\n```", "```py\nusing UnityEngine;\npublic class Aspect : MonoBehaviour {\n    public enum Affiliation {\n        Player,\n        Enemy\n    }\n    public Affiliation affiliation;\n}\n```", "```py\nusing UnityEngine;\nusing System.Collections;\npublic class Wander : MonoBehaviour { \n    private Vector3 tarPos;\n    [SerializeField]\n    private float movementSpeed = 5.0f;\n    [SerializeField]\n    private float rotSpeed = 2.0f;\n    [SerializeField]\n    private float minX = -45.0f;\n    [SerializeField]\n    private float maxX = 45.0f;\n    [SerializeField]\n    private float minZ = -45.0f;\n    [SerializeField]\n    private float maxZ = -45.0f;\n    [SerializeField]\n    private float targetReactionRadius = 5.0f;\n    [SerializeField]\n    private float targetVerticalOffset = 0.5f;\n    void Start () {\n        //Get Wander Position \n        GetNextPosition();\n    }\n    void Update () {\n        // Check if we're near the destination position\n        if (Vector3.Distance(tarPos, transform.position) <=\n          targetReactionRadius) GetNextPosition(); \n        // generate new random position\n        // Set up quaternion for rotation toward\n        // destination\n        Quaternion tarRot = Quaternion.LookRotation(\n          tarPos - transform.position);\n        // Update rotation and translation\n        transform.rotation = Quaternion.Slerp(\n          transform.rotation,\n          tarRot, rotSpeed * Time.deltaTime);\n        transform.Translate(new Vector3(0, 0, movementSpeed\n                            * Time.deltaTime));\n    }\n    void GetNextPosition() {\n        tarPos = new Vector3(Random.Range(minX, maxX),\n          targetVerticalOffset, Random.Range(minZ, maxZ));\n    }\n}\n```", "```py\nusing UnityEngine;\npublic class Sense : MonoBehaviour { \n    public bool bDebug = true;\n    public Aspect.Affiliation targetAffiliation = \n      Aspect.Affiliation.Enemy;\n    public float detectionRate = 1.0f;\n    protected float elapsedTime = 0.0f;\n    protected virtual void Initialize() { }\n    protected virtual void UpdateSense() { }\n    void Start () {\n        Initialize();\n    }\n    void Update () {\n        UpdateSense();\n    }\n}\n```", "```py\nusing UnityEngine;\npublic class Sight: Sense { \n    public int FieldOfView = 45; \n    public int ViewDistance = 100;\n    private Transform playerTrans;\n    private Vector3 rayDirection;\n    protected override void Initialize() {\n        //Find player position\n        playerTrans = GameObject.FindGameObjectWithTag(\n          \"Player\").transform;\n    }\n    protected override void UpdateSense() {\n        elapsedTime += Time.deltaTime;\n        // Detect perspective sense if within the detection \n        // rate\n        if (elapsedTime >= detectionRate) {\n            DetectAspect();\n            elapsedTime = 0.0f;\n        }\n    }\n    //Detect perspective field of view for the AI Character\n    void DetectAspect() {\n        //Direction from current position to player \n        //position\n        rayDirection = (playerTrans.position – \n                        transform.position).normalized;\n        //Check the angle between the AI character's \n        //forward vector and the direction vector between \n        //player and AI to detect if the Player is in the \n        //field of view.\n        if ((Vector3.Angle(rayDirection,\n             transform.forward)) < FieldOfView) {\n            RaycastHit hit;\n            if (Physics.Raycast(transform.position,\n                rayDirection, out hit, ViewDistance)) {\n                Aspect aspect =\n                  hit.collider.GetComponent<Aspect>();\n                if (aspect != null) {\n                    //Check the aspect\n                    if (aspect.affiliation == \n                        targetAffiliation) {\n                        print(\"Enemy Detected\");\n                    }\n                }\n            }\n        }\n    }\n```", "```py\n    void OnDrawGizmos() {\n        if (!Application.isEditor|| playerTrans == null)\n          return;\n        Debug.DrawLine(transform.position,\n                       playerTrans.position, Color.red);\n        Vector3 frontRayPoint = transform.position + \n          (transform.forward * ViewDistance);\n        //Approximate perspective visualization\n        Vector3 leftRayPoint = Quaternion.Euler(\n          0,FieldOfView * 0.5f ,0) * frontRayPoint;\n        Vector3 rightRayPoint = Quaternion.Euler(0, \n          - FieldOfView*0.5f, 0) * frontRayPoint;\n        Debug.DrawLine(transform.position, frontRayPoint,\n                       Color.green);\n        Debug.DrawLine(transform.position, leftRayPoint,\n                       Color.green);\n        Debug.DrawLine(transform.position, rightRayPoint, \n                       Color.green);\n    }\n}\n```", "```py\nusing UnityEngine;\npublic class Touch : Sense {\n    void OnTriggerEnter(Collider other) {\n        Aspect aspect = other.GetComponent<Aspect>();\n        if (aspect != null) {\n            //Check the aspect\n            if (aspect.affiliation == targetAffiliation) {\n                print(\"Enemy Touch Detected\");\n            }\n        }\n    }\n}\n```"]