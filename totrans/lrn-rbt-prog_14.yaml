- en: '*Chapter 12*: IMU Programming with Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern robots need to know their position relative to the world. In [*Chapter
    11*](B15660_11_Final_ASB_ePub.xhtml#_idTextAnchor219), *Programming Encoders with
    Python*, we looked at how encoders can get an idea of how much the robot has moved
    or turned. However, this turning was relative to where the robot was and had no
    absolute reference. Wheel slipping could lead to false readings. In this chapter,
    you will see more ways the robot can read changes in its position and measure
    its movements.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, an **inertial measurement unit** (**IMU**) can give absolute position
    measurements and not slip. In practice, they are complicated. This chapter is
    a small practical tour of adding an IMU to your robot. I will introduce the components
    of an IMU in this chapter. You will also learn how to solder in order to add headers
    to a breakout, a skill that opens up a world of additional robot parts.
  prefs: []
  type: TYPE_NORMAL
- en: We'll write some code to try the various functions and see the kind of output
    the sensors provides. We will then make animated visualizations of the sensor
    data. By the end of this chapter, you will be able to work with these advanced
    sensors, have some soldering experience, and put together dashboards for monitoring
    sensors. As you investigate more in robotics, you'll learn that animated dashboards
    will be vital if you want to see what your robot can see.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about inertial measurement units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soldering – attaching headers to the IMU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching the IMU to the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the gyroscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the magnetometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot from [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot code from [*Chapter 11*](B15660_11_Final_ASB_ePub.xhtml#_idTextAnchor219),
    *Programming Encoders with Python*, which can be found at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ICM20948 breakout board with headers, such as the Pimoroni PIM448 module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soldering iron and stand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soldering iron tip-cleaning wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solder – should be flux-cored solder for electronics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solder sucker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A well-lit bench for soldering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ventilated space or extractor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety goggles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2.5 mm standoff kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Female-to-female Dupont jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the complete code for this chapter, please go to [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/38FJgsr](https://bit.ly/38FJgsr)'
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about IMUs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IMU is a combination of sensors designed to sense a robot's movement in a
    3D space. These devices are found in drones, useful in floor-based robots, and
    critical for balancing robots. The IMU is not a single sensor, but a collection
    designed to be used together and have their readings combined.
  prefs: []
  type: TYPE_NORMAL
- en: These devices are tiny but have their roots in flight hardware with large spinning
    gyroscopes. IMUs use the **micro-electro-mechanical systems** (**MEMS**) technology
    to put mechanical devices on micro-scale chips. They do have tiny moving parts
    and use electronic sensors to measure their movements.
  prefs: []
  type: TYPE_NORMAL
- en: Since some measurements are analog (see [*Chapter 2*](B15660_02_Final_ASB_ePub.xhtml#_idTextAnchor033),
    *Exploring Controllers and I/O*, IMU modules often include an **analog to digital
    converter** (**ADC**) and communicate over I2C.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different combinations of sensors on an IMU. These sensors are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A temperature sensor, to account for temperature effects on other sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A gyroscope, which measures rates of rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accelerometer, which measures accelerations or forces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A magnetometer, which measures magnetic fields and can act as a compass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we work with each of these sensor types, we will learn more about them and
    their quirks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know a little about IMUs, let's learn how to choose one.
  prefs: []
  type: TYPE_NORMAL
- en: Suggested IMU models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IMUs can be constructed with a separate accelerometer, gyroscope, and magnetometer,
    along with devices to convert the output of the sensor. To reduce the wiring and
    space this needs, I suggest using a board with all the devices or a single chip
    solution. For the same reason, I recommend I2C or serial IMUs.
  prefs: []
  type: TYPE_NORMAL
- en: IMU systems use **degrees-of-freedom** (**DOF**) to denote how many sensor axes
    are present. A 9-DOF system has three axes (X, Y, and Z) for each sensor.
  prefs: []
  type: TYPE_NORMAL
- en: BNO sensors are easier to code for but are incompatible with the Raspberry Pi
    due to the way they use the I2C bus, and they may require an intermediate interface
    chip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to consider is if there is documentation (readme files and manuals)
    and a supported library to control the device from Python. The following picture
    shows a suggested IMU breakout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Photo of the ICM20948
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image is of the PIM448 breakout board for the ICM20948, a well-supported
    9-DOF sensor for Python libraries. It also has a temperature sensor. It is also
    well distributed. Since IMUs are complex devices, I strongly suggest choosing
    the PIM448 for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve explored what IMU devices are and how to choose one, it''s
    time to prepare a PIM448 for our robot with a new skill: soldering.'
  prefs: []
  type: TYPE_NORMAL
- en: Soldering – attaching headers to the IMU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most IMU breakouts, including the suggested PM448, are likely to come with
    headers in a bag, which you will need to solder onto the board. You are going
    to need a small bit of tuition if you want to solder on these headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Bare PIM448 with headers
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image shows the PIM448 as it comes out of the bag. On the left
    is the ICM20948 board with only holes and no headers. In the middle are the male
    headers, while the female headers are on the right. We will use the male headers
    since these are easier to hold in place when soldering.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the *Technical requirements* section, you need a soldering
    iron and solder, a soldering iron stand, safety goggles, an extractor or well-ventilated
    space, an additional breadboard, and a well-lit workspace. Soldering creates fumes
    that you do not want to breathe in.
  prefs: []
  type: TYPE_NORMAL
- en: Wear your safety goggles at this point. Heat the soldering iron; depending on
    the iron, this may take a few minutes. Pull out a bit of solder ready to use too.
  prefs: []
  type: TYPE_NORMAL
- en: Making a solder joint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are now ready to make a solder joint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows three of the stages of soldering the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Stages of soldering the PIM448
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a solder joint, perform the follow steps while looking at the preceding
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to ensure the part won't move while the solder dries. The preceding
    image shows the PIM448 lined up on the male headers, pushed into a breadboard
    on the bottom, with the female headers on the top. An excellent way to hold the
    part in place is to put the long side of the headers into the breadboard with
    our device on top. Since we are attaching male headers, we will use the female
    headers to prop up the other side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The soldering iron tip should be hot at about 300°C and tinned. Melt a little
    solder on the tip to test that it's warm enough. Before you can solder, you need
    to tin the tip. Tinning is where you put a small layer of solder onto the iron
    to improve its heat conductivity and protect the tip from oxidizing (getting rusty
    when hot). To tin the tip, push a little solder into the iron's tip, and it will
    stick to it. The solder should melt freely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the tip is clean – with the iron hot, push the tip of the iron into the
    brass cleaner, making a wiping motion with it in the wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Heat the pin from the header and the pad (the ring that the pin goes through).
    We'll start on the pin that reads **2-6V**. Heat both the pin and the pad to avoid
    a dry joint, where the solder will not flow properly over the pad. Dry joints
    are weak, both electrically and mechanically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a second or so, gently feed a little solder into the other side of the
    pin; when the pin is hot enough, the solder will melt and flow over the pad, making
    a rounded tent-like shape. This is just enough solder. You will see flux resin
    coming from the solder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding image shows the next step in the middle. Here, I've soldered two
    pins; things gets easier from here on out since the board can't move. Move on
    to the next pin and repeat – heat the pin and pad, then feed in the solder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've added too much solder, use a solder sucker to remove the excess. Push
    down the plunger, bring the sucker up close to the joint, melt the solder, and
    press the release button of the plunger for it to suck any solder away. You can
    remake this joint with a bit less solder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you find you've connected two pins with a blob of solder (bridged them),
    you can draw the hot iron down between the pins to divide them again. You may
    also need to remove any excess solder, as mentioned in *Step 7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the preceding steps for the remaining pins. The right-hand side of the
    preceding image shows what your IMU should look like once all the pins have been
    soldered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the sake of safety, ensure that you return the soldering iron to its stand
    and switch the iron off before you do anything else. A soldering iron can be a
    dangerous device, leading to burns or fires if left unattended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the part is cool, unplug it from the breadboard. Optionally, you can use
    isopropyl alcohol and a cotton bud to clean away flux residue for a better look.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we wire this, make the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: You have soldered all five pins in place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each soldered pin is like a silver "tent" shape. A bubble/round or flat shape
    is not right, and you will need to make that connection again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No two pins have solder *bridges* – blobs of solder connecting the pins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations – you have soldered your first part! This is a skill you will
    need again as you build more robotic and electronic devices. Now that you have
    soldered the ICM20948 module, let's attach it to your robot.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the IMU to the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can use the IMU and write code for it, we must securely mount it on
    the robot and wire it so that the Raspberry Pi can talk to it.
  prefs: []
  type: TYPE_NORMAL
- en: Physical placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IMU magnetometer is sensitive to magnetic fields and needs to be away from
    the motors. For this reason, it should be on a stalk above the robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The orientation of the IMU is essential for other experiments to make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Lining up the IMU with the robot
  prefs: []
  type: TYPE_NORMAL
- en: There is a diagram on top of the IMU. The preceding diagram shows how this diagram
    should line up with the robot. The X-axis should face forward, while the Z-axis
    should face up, with the little square on the IMU pointing upward. Finally, the
    Y-axis should point to the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sensor uses I2C. I2C is sensitive to wire distances, so we should mount
    it above the Raspberry Pi and motor control board where the wire distances are
    low. The following image shows the parts you will need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Parts needed to attach the IMU
  prefs: []
  type: TYPE_NORMAL
- en: 'For this step, you will need the parts shown in the preceding image:'
  prefs: []
  type: TYPE_NORMAL
- en: The IMU, with headers mounted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many long standoffs, M2.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x M2.5 nut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will assemble these parts using the standoffs to make a long post, as the
    following image shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Joining the standoff posts
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are intended to be used with the preceding image to help
    you mount the IMU:'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding image, you just need to screw the thread of one post
    into the socket of the other to end up with a long post. This should give the
    IMU a little distance so that it can stand above the robot. Aim to be just under
    the cable length:![](img/B15660_12_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.7 – Bolting the IMU to the post
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As shown in the preceding image, push a post thread through the hole opposite
    the axis markers on the IMU *(a)*. The headers *(b)* should be facing down into
    the post. The thread is quite a snug fit but should fit through. Use the nut on
    top *(c)* to secure it in place:![](img/B15660_12_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.8 – Bolting the IMU post to the Raspberry Pi
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding image shows the IMU post screwed onto a thread sticking up from
    the motor board. The motor board we suggested in [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Robot Building Basics – Wheels, Power, and Wiring*, has an I2C connector to the
    rear left of this board. We can bolt the IMU post to a hole near that:![](img/B15660_12_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.9 – The IMU ready for wiring
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding image shows the ICM20948 attached to the post, which you bolt
    into the top of the motor board, with its pins ready for wiring. Adjust it so
    that the X-axis points forward and the Y-axis points to the left while tightening
    the top nut. The closer this is to square with the robot, the better your results
    will be!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now mounted the IMU on the robot. You've lined up its axes, so we know
    what to expect from our sensors. Now that we have fitted this IMU module, it's
    firmly in place, but could be unbolted if we need to do that. The module is now
    ready for wiring.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the IMU to the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, you need to wire the IMU to the I2C pins on the Raspberry Pi. While this
    seems to be an easy job, you must watch out since some connections aren't straight
    through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The motor board''s handy I2C breakout should make this job a little easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – The wiring of ICM20948
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, the wiring is pretty straightforward: the
    **GND** from the IMU goes to the **GND** on the motor board I2C breakout, **SDA**
    goes to **SDA**, **SCL** goes to **SCL**, and **2-6V** goes to **5V** (in the
    2-6V range).'
  prefs: []
  type: TYPE_NORMAL
- en: The **GND** goes from the left of the motor board to the right of the IMU. The
    four wires have a bend, with the **5V** line crossing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, we would use a jumper cable strip of four wires, which is shown
    by the dashed lines in the preceding diagram. The end going to the IMU would go
    straight through. The end going to the motor board has the power cable crossing
    the other wires:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – ICM20948 IMU wired to the motor board
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding image, I''ve used a short female-to-female jumper wire to
    make the connections. The IMU board is at 90 degrees from its intended orientation
    to make the wiring more visible; it should have X facing forward. Notice that
    there is a twist in the wire, so the GND line (white here) ends up on the GND
    pin on the other side. Perform the following steps to make these connections:'
  prefs: []
  type: TYPE_NORMAL
- en: Carefully pull off a strip of four wires. Aim to find a darker color for GND
    and a bright/vivid color for the 5V line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug one side directly into the IMU, ensuring you skip the INT pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you bring the wire to the motor board below, put a small turn in so that
    the cable faces the other way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the GND in first, to set the orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the 5V line in next, which will need to cross the other two wires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final two wires should now be in the right orientation for SDA and SCL;
    plug in both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the wire colors to ensure you've made the right connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not intend to use the `INT` pin. This pin is designed to send an *interrupt*
    to the Pi, to notify us that there is a motion for wake-on-motion type behavior.
    However, use of this is beyond the scope of this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have wired this sensor in and attached it to our robot, you are
    ready to write some code. We'll start easy by reading the temperature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading the temperature
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: With the device wired and attached, you'll want to try some code on it to confirm
    we can talk to this device and get data out of it. Let's get some tools installed
    and make it work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing the software
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can start interacting with this device, as with most devices, we will
    install a helper library to communicate with it. Pimoroni, the suppliers of the
    ICM20948 module I've suggested, have made a handy library for Python to talk to
    it. I recommend taking their latest version from GitHub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Perform the following steps to install it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Boot up the Raspberry Pi on the robot. This Pi should have been used previously
    for the motor board and LED shim and have I2C enabled. If not, go back to [*Chapter
    7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131), *Drive and Turn – Moving
    Motors with Python*, and follow the steps for preparing the I2C.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type in `i2cdetect -y 1` to check that you''ve installed the device correctly.
    The output should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The device at 0x68 is our new device. If you do not see this, please power down
    the Raspberry Pi and check your wiring. The other two devices (0x6f and 0x70)
    are the motor board and the LED shim.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can install the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You've now verified that the ICM20948 device is on the robot's I2C bus and installed
    the Pimoroni Python library so that it can talk with it. You are now ready to
    talk to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also will add some new software to visualize our data in real time. There
    is a system called **Visual Python** (**VPython**) that''s been designed to create
    graphs and 3D representations in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, the device and library should be installed. If this didn't work for you,
    try looking at the *Troubleshooting* section, which is next.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Things can go wrong at this early stage. If you''ve not made things work so
    far, please try following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It is vital that the `i2cdetect` stage works here and shows the device at 0x68\.
    If not, check your wiring. *Nothing* should be hot here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure you have followed all the soldering checks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the libraries fail to install, ensure you get connected to the internet.
    You may need to have the most recent version of Raspbian for them to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have installed the device and checked for common issues, we can
    try our first experiment with it and read the temperature sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the temperature register
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to set up an interface for the IMU, and then add
    a real-time graph for the temperature data from the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with other sensors and outputs, we must create an interface because there
    are many IMU devices on the market. However, the same interface allows us to change
    them out without rewriting other behaviors using that interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `robot_imu.py`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by importing the Pimoroni device library – this will be different if
    you use another IMU device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll make an IMU class to represent our device. This sets up a single IMU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this exercise, we only need the temperature. Let''s simply wrap that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, the interface is ready. Now, we can use it to read the device's temperature.
  prefs: []
  type: TYPE_NORMAL
- en: What is VPython?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VPython or Visual Python is a system designed to make visual – even 3D – displays
    in Python. It comes from a scientific community and will become very useful throughout
    this chapter. It serves output to a browser, and with the specific version installed
    here, it can be run on a Raspberry Pi while showing the output on a computer or
    smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: It has a few quirks, with one of them being a slow startup time, but it is worth
    it for the results.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing the temperature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good way to observe temperature variations is by using a graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use VPython and create a graph showing the temperature of our IMU module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `plot_temperature.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by importing VPython and our robot IMU interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to plot temperature versus time on a graph, so we will need a
    time reference. Also, we will use logging to see what is going on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s configure logging so that we can see all the `INFO` level logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our IMU instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want a few things from the graph. Since the X-axis is time and is in seconds,
    setting the minimum to `0` and the maximum to `60` will show us a minute of data.
    We also want the graph to scroll so that it shows new data once we''ve recorded
    more than a minute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have a time reference, let''s record the start time before we get
    into the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main loop is a `while true` type. However, we need to use `vp.rate` to
    let VPython know we are animating and set a frame/update rate for our system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can capture our temperature, and while we are at it, we can log this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To put this into the graph, we need to get the elapsed time for the X-axis.
    We can get this by subtracting the start time from the current time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to plot this in our temperature graph, with the elapsed time
    as `x` and the temperature as `y`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code for plotting the temperature is now live. Let's run this on the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Running the temperature plotter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few steps we need to follow to run this once we''ve copied the
    files to the Raspberry Pi. Our Raspberry Pi is headless, so we will need to view
    VPython remotely. To do so, we need to let VPython know we are doing this, and
    use a network port to make its view available. We can then use a browser to look
    at this. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an SSH session to the Raspberry Pi, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ve chosen port `9020`, which is somewhat arbitrary but should be above
    `1000`. We will be using other web services later in this book on different ports,
    and this number is well clear of their ranges. When run, it should log a few messages
    to tell you it is ready:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that it shows a localhost address. We intend to use it remotely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, point your browser (Chrome, Firefox, or Safari) from your desktop to the
    Raspberry Pi with the port number. In my case, based on my robot's hostname, this
    would be `http://myrobot.local:9020`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, be prepared to wait a bit – it can take a bit of time for VPython to set
    up. After this, you will either see your graph or any errors/problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When it''s running, you''ll get a graph of the readings from the temperature
    sensor. You can experiment a little by carefully placing a finger on the sensor
    (the large black square on the PIM448) and watching the graph rise/fall in response
    to this. You could also find cold or hot objects, such as a hair dryer, to see
    how this manipulates it. However, be careful not to get the robot wet, and don''t
    let metal touch the pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – A temperature graph
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image is a graph that's showing temperature in degrees (Y-axis)
    versus time in seconds (X-axis). The thick black line indicates the current temperature
    reading. It wiggles a lot – this is a noisy system.
  prefs: []
  type: TYPE_NORMAL
- en: 'I placed my finger over the sensor at about 25 seconds. As shown in the preceding
    graph, the ambient temperature was 31 and raised to just under 34\. It takes a
    few seconds to warm up. Keeping my finger there longer would have made it increase
    more. I had a fan present, so there was a sharp drop-off – there can be far slower
    drop-offs depending on your conditions. The code also logs the temperatures to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot of noise in the decimal places that you can ignore here. When
    you close this browser tab, the code will stop graphing.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A warning about testing temperatures: Do not put metal objects on the sensor
    – this may short out the pins and damage the robot. Also, do not put wet items
    on it. Very cold objects may have condensation on them. Water will even short
    pins and damage the sensor, and possibly the Raspberry Pi.'
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are pulling two new components into our robot code here, so things may go
    wrong. Here are some things to check:'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that VPython can be slow, so it may take a long time to start. Try
    refreshing the browser tab after 30 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With VPython, it may take a long time to show an error message. Patience is
    needed when trying new code here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see I/O or communication errors, carefully check the wiring of the IMU.
    Please go back to the *Installing Software Troubleshooting* section for measures.
    I/O errors can also happen if you nudge a wire out while putting your finger on
    the sensor, or worse still if you try to cool it with a metal object and short
    the pins. DO NOT PUT A METAL OBJECT ON THE SENSOR!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, if you see import errors, check that you do not have typing errors
    in the imports and ensure you have checked the *Installing software troubleshooting*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the temperature reading takes time to change, note that the IMU has some
    insulation/thermal resistance, so it takes a while to warm up (but it will) and
    cool down. The board also has a thermal mass, meaning it will all heat up or cool
    down, slowing the time it takes to reach the same temperature as the one you are
    measuring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There can be a few reasons for the temperature reading not being accurate. For
    one, the IMU can produce some heat – we've already mentioned the thermal mass.
    It could have a calibration offset value applied to it to make it more accurate,
    but do not expect it to match a thermometer to a fraction of a degree perfectly.
    It should certainly be able to register a finger or palm as close to 37 degrees,
    but in practice, and with patience, I usually got to about 36 point something.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our example is now working, but we could make it a bit easier to start our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the VPython command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using VPython a lot in this chapter, and we don''t want to type
    in a mouthful of settings to run each Python file. Let''s create an alias (a command-line
    shortcut) to save us from having to type that stuff in every time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set it up for the current session. The `alias` command makes an alias
    we can reuse later. Here, it''s named `vpython`. It contains the settings and
    the `python3` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So that we can use it again at some point, we will put it into the current
    user''s `.bashrc` file – a file that Raspbian automatically runs when you `ssh`
    in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wrapping something in `echo` will write text out instead of running a command.
    `>>` appends this to a file – in this case, `.bashrc`. The `~` mark picks the
    current user's home.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can rerun the temperature demo with `vpython plot_temperature.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you received data from the IMU device and saw how it responds
    to temperature. This confirms that the IMU is responding. You logged the data
    and graphed it and were introduced to the VPython system in the process, which
    can be used as a powerful graphics display system. We will use both the IMU and
    VPython to do far more throughout this chapter. Next, we will look at the gyroscope
    so that we can see how our robot is turning.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the gyroscope in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to use the gyroscope in the IMU. We will use it
    to approximate where the robot is facing in three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: But before we do that, let's understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the gyroscope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A gyroscope measures rotation as a rate of change in angle, perhaps in degrees
    per second. At each measurement, it can determine the speed of rotation around
    each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Illustration of a gyroscope
  prefs: []
  type: TYPE_NORMAL
- en: A gyroscope is traditionally a mechanical system, as shown in the preceding
    image. It has a gimbal – a set of concentric rings – connected by pivots so that
    they can pivot around the X-axis, Y-axis, and Z-axis. The middle has a spinning
    mass, known as a rotor. When the rotor is spinning, moving the handle (shown as
    a stand at the bottom of the image) does not affect the spinning mass, which keeps
    its orientation, with the gimbals allowing it to turn freely.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a MEMS gyroscope, it moves a tiny mass back and forth (oscillates)
    very quickly. When the orientation of the gyroscope is changed, the mass will
    still be moving in another direction. This movement will change an electrical
    field that the sensor detects. In the original orientation, this movement appears
    to be a force, known as the Coriolis force.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can write some code so that we can work with the gyroscope, we need
    to understand coordinate systems – on the robot and in VPython.
  prefs: []
  type: TYPE_NORMAL
- en: Representing coordinate and rotation systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to be using coordinate and rotation systems in this chapter. The
    following diagram should help you understand them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – The robot body coordinate system
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows the different coordinate systems we will be using.
    Let''s take a look at the different sections of it:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the robot's **Body Coordinate System** – a stylized 3D sketch of the
    robot with three axis arrows. First, there's the X-axis, which points toward the
    front of the robot. Rotating about this X-axis is known as **roll**. Then, there's
    the Y-axis, which indicates to the left of the robot (your right as you view the
    robot). Rotating about this axis is known as **pitch**. Finally, pointing up through
    the robot is the Z-axis. Rotating about this axis is known as **heading** or **yaw**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The direction of rotation is important. There is a rule of thumb for this:
    take your right hand and put your thumb up. If your thumb is pointing along the
    axis, then the fingers on your fist have wrapped the way the rotation will go.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the VPython **World Coordinate System**. We display 3D images in VPython
    here. VPython's coordinate system is a rotation of the robot body system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding diagram, the Y-axis is going up, the X-axis is going to the
    right, and the Z-axis is pointing forward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will represent the coordinates in 3D as X, Y, and Z components – this is
    known as a **vector**.
  prefs: []
  type: TYPE_NORMAL
- en: When we apply our measurements to things in the VPython system, we will align
    our view with the robot coordinate system. When we're talking about a coordinate
    system relative to another, this is known as a **pose**. This is the robot's pose
    with respect to the VPython coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s represent this with a bit of code to help us out:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `robot_pose.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are manipulating the VPython view, so we need to import it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then add our function to set the view up; I''ve called it `robot_view`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we need to set the two properties that VPython uses to control
    camera orientation:![](img/B15660_12_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An axis tells us where to look along, but not which way *up* is. We need the
    camera to align its definition of up with the robot (which has Z pointing up);
    otherwise, the vectors could be upside down or to the side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use this pose more in later sections; however, for now, it's useful
    to see that the Z-axis is now up, as well as where we rotate around the different
    axes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's set up the gyroscope for reading.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the gyroscope to the interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can read the gyroscope, we''ll need to add it to our `robot_imu.py`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to be dealing with a few x, y, and z groups from our IMU. We will
    import a vector type to store these. I''ve highlighted the new code here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A vector is a representation of three component coordinate systems. Now, we
    need to fetch the gyroscope data from the underlying IMU library and store it
    in a vector:`ICM20948` library we are using does not have a call to return only
    gyroscope data, but it does have one that returns both accelerometer and gyroscope
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `ICM20948` library returns the data as a list of six items. In Python,
    when unpacking return values, the underscore character, `_`, can denote things
    to ignore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now put the three gyroscope values into a body vector to return them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The IMU library is now ready for us to read gyroscope data from it. Next, we
    are going to read it and plot the data on a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting the gyroscope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, the gyroscope measures the rate of rotation. It
    does so in degrees per second on each axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s graph the output of this device:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `plot_gyroscope.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll start with the imports, setting up logging, and the IMU, as we did previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set up three graphs for the three axes that the gyroscope outputs – X rotation,
    Y rotation, and Z rotation. Note that we give each graph a different color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The three graphs will overlay on the same line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to set a start time, start a loop, and measure the elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now read the IMU and put the three readings into the graphs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upload the files and run them with `vpython plot_gyroscope.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait a minute or so and then point a browser at `myrobot.local:9020` – it can
    take up to 1 minute for this to appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start to move the robot around – lift it and try tilting in each of the three
    axes. You should see something like the following graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B15660_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – VPython plot of gyroscope data
  prefs: []
  type: TYPE_NORMAL
- en: The preceding graph contains three lines. The Y-axis shows a movement rate in
    degrees per second, while the X-axis shows the time in seconds since the program
    started. On-screen, the graphs are in red, green, and blue.
  prefs: []
  type: TYPE_NORMAL
- en: The graph spikes when you make movements, and then returns to zero. Try pushing
    the front of the robot (the nose) down; this is positive around the Y-axis. The
    green line should move up (shown at about 3 seconds in the preceding graph). If
    you keep it there, the line will flatten. When you return the robot to flat, there
    will be a negative green spike on the line. Now, try lifting the left-hand side
    by turning it around the X-axis, creating a positive red spike on your graph.
    When you return it flat, you'll get a negative peak. Next, try turning the robot
    to the left; this will create a positive blue spike. Now, if you turn it to the
    right, a negative blue spike will be created. Move around the axes to get a feel
    for these measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you are spinning a robot constantly, you'll likely find that it's reasonably
    hard to keep up any turning force; this shows that the gyroscope data is a rate
    of turn, and not a measure of direction. What would be more useful is to approximate
    the heading of the robot. When we dive deeper, we'll learn how to use gyroscope
    data for this.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've seen the gyroscope and how it measures rotation rates
    via a graph demonstrating this principle. Now, let's move on to the accelerometer
    so that we can see the forces that are acting on our robot!
  prefs: []
  type: TYPE_NORMAL
- en: Reading an accelerometer in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use an accelerometer to measure forces
    acting on the robot, and most often, which way is down. Let's find out more about
    it, then write some code to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the accelerometer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An accelerometer measures acceleration or changes in speed, both in terms of
    size and direction. It does so by providing three values – one for each of the
    X, Y, and Z axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Accelerometer concept – mass with springs
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows a conceptual view of an accelerometer. Let''s take
    a look at it in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: This shows a ball (a mass) suspended by six springs in a box. When there are
    no forces on the box, the ball stays in the middle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This shows how this system behaves when the large arrow pushes it. The mass
    retains inertia by moving to the right, compressing the right spring and extending
    the left spring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measuring the position of the mass shows the direction and size of an acceleration.
    A MEMS accelerometer is similar to this device and is constructed with a tiny
    silicon mass and springs. This measures an electric field that changes as the
    mass moves.
  prefs: []
  type: TYPE_NORMAL
- en: While on Earth, a mass is pulled downward by gravity. This system behaves like
    a force is holding the box up, so an accelerometer will usually register an upward
    force. We can use this measurement to determine which way down is and sense the
    tilt of a robot.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the accelerometer to the interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by adding the accelerometer measurement to our `RobotImu` library:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `robot_imu.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to do the reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses the same library call as the gyroscope; however, it now discards the
    last three data items instead of the first three.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that the accelerometer is ready to read, we can render this to make the
    data visible.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the accelerometer as a vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The acceleration is a vector; it points to a 3D space with a direction and
    size. A great way to show this is as an arrow in 3D. To clarify where this vector
    is, we can plot an indicator for each of the X, Y, and Z axes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `accelerometer_vector.py`. Start it with some simple imports,
    including the robot view, the logging setup, and initializing the IMU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s look at this from the angle we tend to view the robot at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we want to define four arrows. VPython arrows point along an axis and
    can have their color and length set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start the main loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the accelerometer and log it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because bumps can knock our scale out, we will normalize the vector to so that
    its length is 1\. We need to put this in the arrow axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upload this to the Raspberry Pi and start it with `vpython accelerometer_vector.py`.
    Point your browser to it to see the following output:![](img/B15660_12_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.18 – The accelerometer vector
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding image shows the three colored arrows – red for the X-axis (pointing
    to the viewer), green for the Y-axis (pointing left), and blue for the Z-axis
    (pointing up). There is a gray arrow showing the accelerometer vector. The accelerometer
    points up, which shows what is holding it up against gravity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, if you tilt the robot, the arrow will tilt to show you which way up is
    relative to the robot. You can tilt the robot a few ways to see how this feels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is exciting – you have now shown where up is, relative to your robot. To
    use this to rotate things, we need to turn this vector into pitch and roll angles,
    which we'll learn how to do when we dive deeper.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how to read data from the accelerometer component
    and how to display it as a vector. Now, we will move on to the next element of
    the IMU, known as the magnetometer, and read the magnetic fields that are acting
    on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the magnetometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A magnetometer reads magnetic field strengths in 3D to produce a vector. Code
    you write can use this to find the magnetic north, in the same way as a compass.
    In this section, we'll look closer at the device, learn how to get a reading from
    it, and see what vectors it produces.
  prefs: []
  type: TYPE_NORMAL
- en: It may be useful to have a space with very few magnets present. Let's understand
    the magnetometer more.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the magnetometer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A compass measures a heading from the Earth''s magnetic field by using a magnetized
    needle or disk. The following image is of a compass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – A traditional compass
  prefs: []
  type: TYPE_NORMAL
- en: The compass shown in the preceding image has a rotating magnetized disk balanced
    on a center pin. This variety is a small *button compass*, which is about 25 mm
    in diameter.
  prefs: []
  type: TYPE_NORMAL
- en: Our chosen IMU contains a device known as a **magnetometer**. This electronically
    senses a magnetic field and can be used as a compass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most magnetometers pass electricity through a material that creates a current
    when it''s exposed to a magnetic field, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – A stylized picture of a Hall-effect sensor
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows an example of this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: This circuit passes an electric current from a battery (left) through a conducting
    plate (gray rectangle). The arrows demonstrate the electrons (negative charge
    carriers) that are moving around the circuit, from the top of the plate straight
    to the bottom. The small circle with a V inside it is a voltage (electric flow)
    sensor that's connected to the sides of the plate. The voltage sensor reads 0
    since there's no flow to the sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A magnet is above the plate, deflecting the electrons to one side. They give
    one side of the plate a negative charge, and the other side a positive charge.
    This difference in charge makes voltage flow through the sensor, as shown by the
    arrows. The reading below is now above zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Putting the magnet on the other side of the sensor changes the magnetic field;
    the electrons are deflected to the other side, causing reverse voltage to flow.
    The arrows going to the meter are going in the opposite direction, and the reading
    shows a voltage below zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is known as the Hall effect. By measuring three plates, you can measure
    magnetic fields in three dimensions. Magnetometers are sensitive to magnetic fields
    and metal objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quirk is that on some IMUs, the magnetometer''s axes are different
    from the other devices'':'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – The magnetometer's axes
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the axes we looked at previously are shown on the
    left for the gyroscope and accelerometer. On the right, we can see the axes for
    the magnetometer. Here, we can see that the Z-axis points downward and that the
    Y-axis now points backward. It's like we've rotated 180 degrees around the X-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add some code so that we can read this information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the magnetometer interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll wrap this the same way we wrapped the other readings; that is, by adding
    it to our interface library:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `robot_imu.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `RobotIMU` class, after the `read_gyroscope` method, add the new read
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unlike the accelerometer and gyroscope, this reads data from a separate call
    to the underlying device library. We wrap this up and return a vector. For a cheeky
    rotation by 180 degrees, we negate the Y and Z axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that this interface is ready to use, let's get some readings.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying magnetometer readings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way we can visualize this is to turn magnetometer output into a vector,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `magnetometer_vector.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the familiar imports and setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create an arrow for the magnetometer reading, along with the reference
    X, Y, and Z axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we start the main loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can read the magnetometer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s set an arrow''s axis that will match this vector. We can use
    the `.norm()` method to normalize this vector. We also need to print the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send this to the robot and run it with the usual VPython settings. You should
    see something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B15660_12_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.22 – The magnetometer's reading
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image shows a canvas with a red arrow for the X-axis pointing
    forward, a blue arrow for the Z-axis pointing up, and a green arrow for the Y-axis
    pointing right. There is a gray arrow showing the magnetometer vector (XZ only)
    pointing backward.
  prefs: []
  type: TYPE_NORMAL
- en: Yours may be pointing in a different direction compared to mine. This is because
    it is likely to be pointing to where the pin headers are on your IMU. Why is this?
  prefs: []
  type: TYPE_NORMAL
- en: Pin headers are usually made from magnetic metal. You can check this out for
    yourself by taking a magnet and seeing if it sticks to the headers (use some spares
    or do this when the power is off). You should also be able to observe what this
    does to the arrow. You could also take a bit of metal, such as a screwdriver,
    and wave it around the magnetometer. This should send the results all over the
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will need to compensate for nearby metal as it may be creating a large
    offset, large enough to overwhelm Earth's relatively weak magnetic field completely.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to read four sensors on an inertial measurement
    unit, as well as how to display or graph data. You then had your first experience
    with soldering – a vital skill when it comes to making robots. You also learned
    about robot coordinate systems.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, we will dive deeper into knitting the IMU sensors together
    to get an approximation of the robot's orientation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at computer vision; that is, how to extract
    information from a camera and make the robot respond to what it can see.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the temperature graph, you will notice a lot of noise in the graph and the
    output. The Python `round` function takes a number and the number of decimal places
    to keep, defaulting to 0\. Use this to round off the temperature to a more reasonable
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try putting the accelerometer values into an X, Y, and Z graph, as we did for
    the gyroscope. Observe the changes in the chart when you move the robot. Is it
    smooth, or is there noise?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could the gyroscope values be shown as a vector?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there other sensors that can be soldered that you might find interesting
    for your robot to use?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about VPython, take a look at the extensive help at [https://www.glowscript.org/docs/VPythonDocs/index.html](https://www.glowscript.org/docs/VPythonDocs/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Paul McWarter Arduino experiments with an IMU: [https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/](https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adafruit have guides on using IMUs with their libraries: [https://learn.adafruit.com/adafruit-sensorlab-magnetometer-calibration](https://learn.adafruit.com/adafruit-sensorlab-magnetometer-calibration).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This YouTube talk by Google contains excellent information on the subject of
    *Sensor Fusion on Android Devices: A Revolution in Motion Processing*: [https://www.youtube.com/watch?v=C7JQ7Rpwn2k](https://www.youtube.com/watch?v=C7JQ7Rpwn2k).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
