["```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class TankPatrolState : StateMachineBehaviour { \n\n   // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state \n   //override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n   // \n   //} \n\n   // OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks \n   //override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n   // \n   //} \n\n   // OnStateExit is called when a transition ends and the state machine finishes evaluating this state \n   //override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n   // \n   //} \n\n   // OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here \n   //override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n   // \n   //} \n\n   // OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here. \n   //override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n   // \n   //} \n}\n```", "```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class TankAi : MonoBehaviour { \n    // General state machine variables \n    private GameObject player; \n    private Animator animator; \n    private Ray ray; \n    private RaycastHit hit; \n    private float maxDistanceToCheck = 6.0f; \n    private float currentDistance; \n    private Vector3 checkDirection; \n\n    // Patrol state variables \n    public Transform pointA; \n    public Transform pointB; \n    public NavMeshAgent navMeshAgent; \n\n    private int currentTarget; \n    private float distanceFromTarget; \n    private Transform[] waypoints = null; \n\n    private void Awake() { \n        player = GameObject.FindWithTag(\"Player\"); \n        animator = gameObject.GetComponent<Animator>(); \n        pointA = GameObject.Find(\"p1\").transform; \n        pointB = GameObject.Find(\"p2\").transform; \n        navMeshAgent = gameObject.GetComponent<NavMeshAgent>(); \n        waypoints = new Transform[2] { \n            pointA, \n            pointB \n        }; \n        currentTarget = 0; \n        navMeshAgent.SetDestination(waypoints[currentTarget].position); \n    } \n\n    private void FixedUpdate() { \n        //First we check distance from the player  \n        currentDistance = Vector3.Distance(player.transform.position, transform.position); \n        animator.SetFloat(\"distanceFromPlayer\", currentDistance); \n\n        //Then we check for visibility \n        checkDirection = player.transform.position - transform.position; \n        ray = new Ray(transform.position, checkDirection); \n        if (Physics.Raycast(ray, out hit, maxDistanceToCheck)) { \n            if(hit.collider.gameObject == player){ \n                animator.SetBool(\"isPlayerVisible\", true); \n            } else { \n                animator.SetBool(\"isPlayerVisible\", false); \n            } \n        } else { \n            animator.SetBool(\"isPlayerVisible\", false); \n        } \n\n        //Lastly, we get the distance to the next waypoint target \n        distanceFromTarget = Vector3.Distance(waypoints[currentTarget].position, transform.position); \n        animator.SetFloat(\"distanceFromWaypoint\", distanceFromTarget); \n    } \n\n    public void SetNextPoint() { \n        switch (currentTarget) { \n            case 0: \n                currentTarget = 1; \n                break; \n            case 1: \n                currentTarget = 0; \n                break; \n        } \n        navMeshAgent.SetDestination(waypoints[currentTarget].position); \n    } \n}\n```", "```py\nTankAi tankAi = animator.gameObject.GetComponent<TankAi>();\ntankAi.SetNextPoint();\n```"]