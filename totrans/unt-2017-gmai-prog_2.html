<html><head></head><body>
        

                            
                    <h1 class="header-title">Finite State Machines and You</h1>
                
            
            
                
<p>In this chapter, we'll expand our knowledge of the FSM pattern and its uses in games and learn how to implement it in a simple Unity game. We will create a tank game with the sample code that comes with this book. We'll be dissecting the code and the components in this project. The topics we'll cover are as follows:</p>
<ul>
<li>Understanding Unity's state machine features</li>
<li>Creating our own states and transitions</li>
<li>Creating a sample scene using examples</li>
</ul>
<p>Unity 5 introduced state machine behaviors, which are a generic expansion of the Mecanim animation states that were introduced in the 4.x cycle. These new state machine behaviors, however, are independent of the animation system, and we will learn to leverage these new features to quickly implement a state-based AI system.</p>
<p>In our game, the player will be able to control a tank. The enemy tanks will be moving around in the scene with reference to four waypoints. Once the player tank enters their visible range, they will start chasing us, and once they are close enough to attack, they'll start shooting at our tank agent. This simple example will be a fun way to get our feet wet in the world of AI and state FSMs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding uses for FSMs</h1>
                
            
            
                
<p>Although we will primarily focus on using FSMs to implement AI in our game to make it more fun and interesting, it is important to point out that FSMs are widely used throughout game and software design and programming. In fact, the system in Unity 2017 that we'll be using was first introduced in the Mecanim animation system.</p>
<p>We can categorize many things into states in our daily lives. The most effective patterns in programming are those that mimic the simplicity of real-life designs, and FSMs are no different. Take a look around and you'll most likely notice a number of things in one of any number of possible states. For example, is there a light bulb nearby? A light bulb can be in one of two states—on or off (so long as we're not talking about one of those fancy dimming lights). Let's go back to grade school for a moment and think about the time when we were learning about the different states matter can be in. Water, for example, can be solid, liquid, or gas. Just as in the FSM pattern in programming where variables can trigger a state change, water's transition from one state to another is caused by heat:</p>
<div><img height="195" width="292" src="img/615ef79f-2b49-427c-8116-66f966d3f081.png"/></div>
<p>The three distinct states of water</p>
<p>Though there are no hard rules beyond those of our own implementation in programming design patterns, it is a characteristic of FSMs to be in one, and only one, state at any given time. With that said, transitions allow for a "hand-off", of sorts, between two states, just like ice slowly melts into water. Additionally, an agent can have multiple FSMs, driving any number of behaviors, and states can even contain state machines of their own—think Christopher Nolan's <em>Inception</em>, but with state machines instead of dreams.</p>
<p>There are many different implementations and variants of the FSM in C# and Unity, many of which can be found in the Unity Asset Store, but they share a few key features:</p>
<ul>
<li>They define the various states that an object can be in</li>
<li>They provide a mechanism for transitioning from one state to another</li>
<li>They provide a way to define the rules that govern transitions</li>
</ul>
<p>Unity's Mecanim system, though intended originally for driving animations in a state-based manner, fits the bill quite well as it provides a lesser-known, more generic set of FSM features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating state machine behaviors</h1>
                
            
            
                
<p>Now that we're familiar with the concept of a state machine, let's get our hands dirty and start implementing our very own.</p>
<p>As of Unity 2017.1, state machines are still part of the animation system, but worry not, they are flexible and no animations are actually required to implement them. Don't be alarmed or confused if you see code referencing the <kbd>Animator</kbd> component or the <kbd>AnimationController</kbd> asset as it's merely a quirk of the current implementation. It's possible that Unity will address this in a later version, but the concepts will likely not change.</p>
<p>Let's fire up Unity, create a new project, and get to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the AnimationController asset</h1>
                
            
            
                
<p>The <kbd>AnimationController</kbd> asset is a type of asset within Unity that handles states and transitions. It is, in essence, an FSM, but it also does much more. We'll focus on the FSM portion of its functionality. An animator controller can be created from the Assets menu, as shown in the following image:</p>
<div><img height="461" width="398" class="aligncenter size-full wp-image-402 image-border" src="img/588bcc19-3075-49ba-abde-8a43e3bd051b.png"/></div>
<p>Once you create the animator controller, it will pop up in your project assets folder, ready to be named. We'll name it <kbd>TankFsm</kbd>. When you select the animator controller, unlike most other asset types, the hierarchy is blank. That is because animation controllers use their own window. You can simply click on Open in the hierarchy to open up the Animator window, or open it in the Window menu, as you can see in the following screenshot:</p>
<div><img height="555" width="303" class="aligncenter size-full wp-image-403 image-border" src="img/5cb72492-d7de-491f-9468-8bb415e723f9.png"/></div>
<div><p>Be sure to select Animator and not Animation as these are two different windows and features entirely.</p>
<p>Let's familiarize ourselves with this window before moving forward.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Layers and parameters</h1>
                
            
            
                
<p>Layers, as the name implies, allow us to stack different state machine levels on top of each other. This panel allows us to organize the layers easily and have a visual representation. We will not be doing much in this panel for now as it primarily relates to animation, but it's good to be familiar with it. Refer to the following screenshot of the window to find your way around the layers:</p>
<div><img height="177" width="354" class="aligncenter size-full wp-image-404 image-border" src="img/ba0ba33e-7b0d-4b0e-a987-305b7d91f85b.png"/></div>
<p>Here is a summary of the items shown in the previous screenshot:</p>
<ul>
<li><strong>Add layer</strong>: The + button creates a new layer at the bottom of the list.</li>
<li><strong>Layer list</strong>: These are the layers currently inside the animator controller. You can click to select a layer and drag and drop layers to rearrange them.</li>
<li><strong>Layer settings</strong>: The gear icon brings up a menu to edit animation-specific settings for the layer.</li>
</ul>
<p>Second, we have the Parameters panel, which is far more relevant to our use of the animator controller. Parameters are variables that determine when to transition between states, and we can access them via scripts to drive our states. There are four types of parameters—<kbd>float</kbd>, <kbd>int</kbd>, <kbd>bool</kbd>, and <kbd>trigger</kbd>. You should already be familiar with the first three as they are primitive types in C#, but <kbd>trigger</kbd> is specific to the animator controller, not to be confused with physics triggers, which do not apply here. Triggers are just a means to trigger a transition between states explicitly.</p>
<p>The following screenshot shows the elements in the Parameters panel:</p>
<div><img height="183" width="365" class="aligncenter size-full wp-image-405 image-border" src="img/4b09e53f-d7b2-4e72-ae7c-2cd1688a305d.png"/></div>
<p>Here is a summary of the items depicted in the previous screenshot:</p>
<ul>
<li><strong>Search</strong>: We can quickly search through our parameters here. Simply type in the name and the list will populate with the search results.</li>
<li><strong>Add parameter</strong>: This button lets you add new parameters. When you click on it, you must select the parameter type.</li>
<li><strong>Parameter list</strong>: This is the list of parameters you've created. You can assign and view their values here. You can also reorder the parameters to your liking by dragging and dropping them in the correct order. This is merely for organization and does not affect functionality at all.</li>
</ul>
<p>Lastly, there is an eyeball icon, which you can click to hide the Layers and Parameters panels altogether. When the panels are closed, you can still create new layers by clicking on the Layers dropdown and selecting Create New Layer:</p>
<div><img height="157" width="280" src="img/00c538a4-b1c4-493e-9909-7c0d3eb58750.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The animation controller inspector</h1>
                
            
            
                
<p>The animation controller inspector is slightly different from the regular inspector found throughout Unity. While the regular inspector allows you to add components to the game objects, the animation controller inspector has a button labeled Add Behaviour, which allows you to add a <kbd>StateMachineBehaviour</kbd> to it. This is the main distinction between the two types of inspectors, but apart from this, it will display the serialized information for any selected state, substate, transition, or blend tree, just as the regular inspector displays the data for the selected game object and its components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bringing behaviors into the picture</h1>
                
            
            
                
<p>State machine behaviors are a unique, new concept in Unity 5. While states existed, conceptually, in the original implementation of Mecanim, transitions were handled behind the scenes and you did not have much control over what happened upon entering, transitioning, or exiting a state. Unity 5 addressed this issue by introducing behaviors; they provide the built-in functionality to handle typical FSM logic.</p>
<p>Behaviors are sly and tricky. Though their name might lead you to believe they are related to <kbd>MonoBehaviour</kbd>, do not fall for it; if anything, these two are distant cousins at best. In fact, behaviors derive from <kbd>ScriptableObject</kbd>, not <kbd>MonoBehaviour</kbd>, so they exist only as assets, which cannot be placed in a scene or added as components to a <kbd>GameObject</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our very first state</h1>
                
            
            
                
<p>Okay, so the header is not entirely true since Unity creates a few default states for us in our animator controller—New State, Any State, Entry, and Exit—but let's just agree that those don't count for now, okay? Let's take a look at some of the things we can do in our newly-created animation controller:</p>
<ul>
<li>You can select states in this window by clicking on them, and you can move them by dragging and dropping them anywhere in the canvas.</li>
<li>Select the state named New State and delete it by either right-clicking and then clicking on Delete or simply hitting the <em>Delete</em> key on your keyboard.</li>
<li>If you select the Any State state, you'll notice that you do not have the option to delete it. The same is true for the Entry state. These are required states in an animator controller and have unique uses, which we'll cover up ahead:</li>
</ul>
<div><img height="315" width="536" src="img/cf416931-af3a-43d0-baa3-d8aa4e90f39c.png"/></div>
<p>To create our (true) first state, right-click anywhere on the canvas and then select Create State, which opens up a few options, from which we'll select Empty. The other two options, From Selected Clip and From New Blend Tree, are not immediately applicable to our project, so we'll skip these. Now we've officially created our first state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transitioning between states</h1>
                
            
            
                
<p>You'll notice that upon creating our state, an arrow is created connecting the Entry state to it, and that its node is orange. Unity will automatically set default states to look orange to differentiate them from other states. When you only have one state, it is automatically selected as the default state, and as such, it is automatically connected to the entry state. You can manually select which state is the default state by right-clicking on it and then clicking on Set as Layer Default State. It will then become orange, and the entry state will automatically connect itself to it. The connecting arrow is a <strong>transition connector</strong>. Transition connectors allow us some control over how and when the transition occurs, but the connector from the entry state to the default state is unique in that it does not provide us with any options, since this transition happens automatically.</p>
<p>You can manually assign transitions between states by right-clicking on a state node and then selecting Make Transition. This will create a transition arrow from the state you selected to your mouse cursor. To select the destination of the transition, simply click on the destination node and that's it. Note that you cannot redirect the transitions though. We can only hope that the kind folks behind Unity add that functionality at a later point, but for now, you must remove a transition by selecting it and deleting it, and then assigning an all-new transition manually.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up our player tank</h1>
                
            
            
                
<p>Open up the sample project included with this book for this chapter.</p>
<p>It is a good idea to group similar assets together in your project folder to keep them organized. For example, you can group your state machines in a folder called <kbd>StateMachines</kbd>. The assets provided for this chapter are grouped for you already, so you can drop the assets and scripts you create during this chapter into the corresponding folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the enemy tank</h1>
                
            
            
                
<p>Let's go ahead and create an animator controller in your assets folder. This will be your enemy tank's state machine. Call it <kbd>EnemyFsm</kbd>.</p>
<p>This state machine will drive the tank's basic actions. As described earlier in our example, the enemy can patrol, chase, and shoot the player. Let's go ahead and set up our state machine. Select the <kbd>EnemyFsm</kbd> asset and open up the Animator window.</p>
<p>Now, we'll go ahead and create three empty states that will conceptually and functionally represent our enemy tank's states. Name them <kbd>Patrol</kbd>, <kbd>Chase</kbd>, and <kbd>Shoot</kbd>. Once they are created and named, we'll want to make sure we have the correct default state assigned. At the moment, this will vary depending on the order in which you created and named the states, but we want the Patrol state to be the default state, so right-click on it and select Set as Layer Default State. Now it is colored orange and the Entry state is connected to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing transitions</h1>
                
            
            
                
<p>At this point, we have to make some design and logic decisions regarding the way our states will flow into each other. When we map out these transitions, we also want to keep in mind the conditions that trigger the transitions to make sure they are logical and work from a design-standpoint. Out in the wild, when you're applying these techniques on your own, different factors will play into how these transitions are handled. In order to best illustrate the topic at hand, we'll keep our transitions simple and logical:</p>
<ul>
<li><strong>Patrol</strong>: From patrol, we can transition into chasing. We will use a chain of conditions to choose which state we'll transition into, if any. Can the enemy tank see the player? If yes, we go to the next step; if not, we continue with patrolling.</li>
<li><strong>Chase</strong>: From this state, we'll want to continue to check whether the player is within sight to continue chasing, close enough to shoot, or completely out of sight—that would send us back into the Patrol state.</li>
<li><strong>Shoot</strong>: As earlier, we'll want to check our range for shooting and then the line of sight to determine whether or not we can chase to get within the range.</li>
</ul>
<p>This particular example has a simple and clean set of transition rules. If we connect our states accordingly, we'll end up with a graph looking more or less similar to this one:</p>
<div><img height="290" width="529" class="aligncenter size-full wp-image-406 image-border" src="img/b1f507f9-25d0-4546-85dc-51f7d35777c2.png"/></div>
<p>Keep in mind that the placement of the nodes is entirely up to you, and it does not affect the functionality of the state machine in any way. You can try to place your nodes in a way that keeps them organized so that you can track your transitions visually.</p>
<p>Now that we have our states mapped out, let's assign some behaviors to them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making the cogs turn</h1>
                
            
            
                
<p>This is the part I'm sure you've been waiting for. I know, I've kept you waiting, but for good reason. As we now get ready to dive into the coding, we do so with a good understanding of the logical connection between the states in our FSM. Without further ado, select our Patrol state. In the hierarchy, you'll see a button labeled Add Behaviour. Clicking this gives you a context menu very similar to the Add Component button on regular game objects, but as we mentioned before, this button creates the oh-so-unique state machine behaviors.</p>
<p>Go ahead and name this behavior <kbd>TankPatrolState</kbd>. Doing so creates a script of the same name in your project and attaches it to the state we created it from. You can open this script via the project window, or by double-clicking on the name of the script in the inspector. What you'll find inside will look similar to this:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class TankPatrolState : StateMachineBehaviour { 
 
   // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state 
   //override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks 
   //override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateExit is called when a transition ends and the state machine finishes evaluating this state 
   //override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here 
   //override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here. 
   //override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
}</pre>
<p>Downloading the example code<br/><br/>
You can download the example code files from your account at <a href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.<br/></p>
<p>Before we begin, uncomment each method. Let's break it down step by step. Unity creates this file for you, but all the methods are commented out. Essentially, the commented code acts as a guide. Much like the methods provided for you in a <kbd>MonoBehaviour</kbd>, these methods are called for you by the underlying logic. You don't need to know what's going on behind the scenes to use them; you simply have to know when they are called to leverage them. Luckily, the commented code provides a brief description of when each method is called, and the names are fairly descriptive themselves. There are two methods here we don't need to worry about, <kbd>OnStateIK</kbd> and <kbd>OnStateMove</kbd>, which are animation messages, so go ahead and delete them and save the file.</p>
<p>To reiterate what's stated in the code's comments, the following things happen:</p>
<ul>
<li><kbd>OnStateEnter</kbd> is called when you enter the state, as soon as the<br/>
transition starts</li>
<li><kbd>OnStateUpdate</kbd> is called on each frame, after the <kbd>MonoBehaviors</kbd> update</li>
<li><kbd>OnStateExit</kbd> is called after the transition out of the state is finished</li>
</ul>
<p>The following two states, as we mentioned, are animation-specific, so we do not use those for our purposes:</p>
<ul>
<li><kbd>OnStateIK</kbd> is called just before the IK system gets updated; this is an animation and rig-specific concept</li>
<li><kbd>OnStateMove</kbd> is used on avatars that are set up to use root motion</li>
</ul>
<p>Another important piece of information to note is the parameters passed into these methods:</p>
<ul>
<li>The <kbd>animator</kbd> parameter is a reference to the animator that contains this animator controller, and therefore this state machine. By extension, you can fetch a reference to the game object that the animator controller is on, and from there, you can grab any other components attached to it. Remember, the state machine behavior exists only as an asset, and does not exist in the class, meaning this is the best way to get references to runtime classes, such as mono behaviors.</li>
<li>The animator state info provides information about the state you're currently in; however, the uses for this are primarily focused on animation state information, so it's not as useful for our application.</li>
<li>Lastly, we have the layer index, which is an integer telling us which layer within the state machine our state is in. The base layer is index zero, and each layer above that is a higher number.</li>
</ul>
<p>Now that we understand the basics of state machine behavior, let's get the rest of our components in order. Before we can actually see these behaviors in action, we have to go back to our state machine and add some parameters that will drive the states.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting conditions</h1>
                
            
            
                
<p>We will need to provide our enemy tank with a few conditions to transitions states. These are the actual parameters that will drive the functionality.</p>
<p>Let's begin with the Patrol state. In order for our enemy tank to go from Patrol to Shoot, we need to be in range of the player; in other words, we'll be checking the distance between the enemy and the player, which is best represented by a float value. So, in your Parameters panel, add a float and name it <kbd>distanceFromPlayer</kbd>. We can also use this parameter to determine whether or not to go into the Chase state.</p>
<p>The Shoot state and the Chase state will share a common condition, which is whether or not the player is visible. We'll determine this via a simple raycast, which will, in turn, tell us whether the player was in the line of sight or not. The best parameter for this is a Boolean, so create a Boolean and call it <kbd>isPlayerVisible</kbd>. Leave the parameter unchecked, which means false.</p>
<p>Now we'll assign the conditions via the transition connectors' inspector. To do this, simply select a connector. When selected, the inspector will display some information about the current transition and, most importantly, the conditions, which show up as a list. To add a condition, simply click on the + (plus) sign:</p>
<div><img height="243" width="493" src="img/0cfa3283-8ff5-4cf4-ac4b-27d90596b9ad.png"/></div>
<p>Let's tackle each transition one by one:</p>
<ul>
<li>Patrol to Chase
<ul>
<li>distanceFromPlayer &lt; 5</li>
<li>isPlayerVisible == true</li>
</ul>
</li>
</ul>
<div><img height="86" width="437" src="img/8ba46922-e348-4820-8a22-9a4f0f194a5c.png"/></div>
<p>The Patrol to Chase transition conditions</p>
<p>Chase to patrol gets a bit more interesting as we have two <em>separate</em> conditions that can trigger a transition. If we were to simply add two conditions to that transition, both would have to be evaluated to true in order for the transition to occur. But we want to check whether the player is out of range or out of sight. Luckily, we can have multiple transitions between the same two states. Simply add another transition connection as you normally would. Right-click on the Chase state and then make a transition to the Patrol state. You'll notice that you now have two transitions listed at the top of the inspector. In addition, your transition connection indicator shows multiple arrows instead of just one to indicate that there are multiple transitions between these two states. Selecting each transition in the inspector will allow you to give each one separate conditions:</p>
<ul>
<li>Chase to Patrol (A)
<ul>
<li>distanceFromPlayer &gt; 5</li>
</ul>
</li>
<li>Chase to Patrol (B)
<ul>
<li>isPlayerVisible == false</li>
</ul>
</li>
<li>Chase to Shoot
<ul>
<li>distanceFromPlayer &lt; 3</li>
<li>isPlayerVisible == true</li>
</ul>
</li>
<li>Shoot to Chase
<ul>
<li>distanceFromPlayer &gt; 3</li>
<li>distanceFromPlayer &lt; 5</li>
<li>isPlayerVisible == true</li>
</ul>
</li>
<li>Shoot to Patrol (A)
<ul>
<li>distanceFromPlayer &gt; 6</li>
</ul>
</li>
<li>Shoot to Patrol (B)
<ul>
<li>isPlayerVisible == false</li>
</ul>
</li>
</ul>
<p>We now have our states and transitions set. Next, we need to create the script that will drive these values. All we need to do is set the values, and the state machine will handle the rest.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Driving parameters via code</h1>
                
            
            
                
<p>Before going any further, we'll need a few things from the assets we imported earlier in the chapter. For starters, go ahead and open the <kbd>DemoScene</kbd> for this chapter. You'll notice the scene is fairly stripped down and only contains an environment prefab and some waypoint transforms. Go ahead and drop the <kbd>EnemyTankPlaceholder</kbd> prefab into the scene.</p>
<p>You may notice a few components that you may or may not be familiar with on the <kbd>EnemyTank</kbd>. We'll get a chance to thoroughly explore <kbd>NavMesh</kbd> and <kbd>NavMeshAgent</kbd> in <a href="503803fe-f343-4a0c-835f-463c98005182.xhtml">Chapter 4</a>, <em>Finding Your Way</em>, but for now, these are necessary components to make the whole thing work. What you will want to focus on is the <kbd>Animator</kbd> component which will house the state machine (animator controller) we created earlier. Go ahead and drop the state machine into the empty slot before continuing.</p>
<p>We will also need a placeholder for the player. Go ahead and drop in the <kbd>PlayerTankPlaceholder</kbd> prefab as well. We won't be doing much with this for now. As with the enemy tank placeholder prefab, the player tank placeholder prefab has a few components that we can ignore for now. Simply place it in the scene and continue.</p>
<p>Next, you'll want to add a new component to the <kbd>EnemyTankPlaceholder</kbd> game object—the <kbd>TankAi.cs</kbd> script, which is located in the <kbd>Chapter 2</kbd> scripts folder. If we open up the script, we'll find this inside it:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class TankAi : MonoBehaviour { 
    // General state machine variables 
    private GameObject player; 
    private Animator animator; 
    private Ray ray; 
    private RaycastHit hit; 
    private float maxDistanceToCheck = 6.0f; 
    private float currentDistance; 
    private Vector3 checkDirection; 
 
    // Patrol state variables 
    public Transform pointA; 
    public Transform pointB; 
    public NavMeshAgent navMeshAgent; 
     
    private int currentTarget; 
    private float distanceFromTarget; 
    private Transform[] waypoints = null; 
 
    private void Awake() { 
        player = GameObject.FindWithTag("Player"); 
        animator = gameObject.GetComponent&lt;Animator&gt;(); 
        pointA = GameObject.Find("p1").transform; 
        pointB = GameObject.Find("p2").transform; 
        navMeshAgent = gameObject.GetComponent&lt;NavMeshAgent&gt;(); 
        waypoints = new Transform[2] { 
            pointA, 
            pointB 
        }; 
        currentTarget = 0; 
        navMeshAgent.SetDestination(waypoints[currentTarget].position); 
    } 
 
    private void FixedUpdate() { 
        //First we check distance from the player  
        currentDistance = Vector3.Distance(player.transform.position, transform.position); 
        animator.SetFloat("distanceFromPlayer", currentDistance); 
 
        //Then we check for visibility 
        checkDirection = player.transform.position - transform.position; 
        ray = new Ray(transform.position, checkDirection); 
        if (Physics.Raycast(ray, out hit, maxDistanceToCheck)) { 
            if(hit.collider.gameObject == player){ 
                animator.SetBool("isPlayerVisible", true); 
            } else { 
                animator.SetBool("isPlayerVisible", false); 
            } 
        } else { 
            animator.SetBool("isPlayerVisible", false); 
        } 
 
        //Lastly, we get the distance to the next waypoint target 
        distanceFromTarget = Vector3.Distance(waypoints[currentTarget].position, transform.position); 
        animator.SetFloat("distanceFromWaypoint", distanceFromTarget); 
    } 
 
    public void SetNextPoint() { 
        switch (currentTarget) { 
            case 0: 
                currentTarget = 1; 
                break; 
            case 1: 
                currentTarget = 0; 
                break; 
        } 
        navMeshAgent.SetDestination(waypoints[currentTarget].position); 
    } 
}</pre>
<p>We have a series of variables that are required to run this script, so we'll run through what they're for in order:</p>
<ul>
<li><kbd>GameObject player</kbd>: This is a reference to the player placeholder prefab we dropped in earlier.</li>
<li><kbd>Animator animator</kbd>: This is the animator for our enemy tank, which contains the state machine we created.</li>
<li><kbd>Ray ray</kbd>: This is simply a declaration for a ray that we'll use in a raycast test on our <kbd>FixedUpdate</kbd> loop.</li>
<li><kbd>RaycastHit hit</kbd>: This is a declaration for the hit information we'll receive from our raycast test.</li>
<li><kbd>Float maxDistanceToCheck</kbd>: This number coincides with the value we set in our transitions inside the state machine earlier. Essentially, we are saying that we're only checking as far as this distance for the player. Beyond that, we can assume that the player is out of range.</li>
<li><kbd>Float currentDistance</kbd>: This is the current distance between the player and the enemy tanks.</li>
</ul>
<p>You'll notice we skipped a few variables. Don't worry, we'll come back to cover these later. These are the variables we'll be using for our Patrol state.</p>
<p>Our <kbd>Awake</kbd> method handles fetching the references to our player and animator variables. You can also declare the preceding variables as public or prefix them with the <kbd>[SerializeField]</kbd> attribute and set them via the inspector.</p>
<p>The <kbd>FixedUpdate</kbd> method is fairly straightforward; the first part gets the distance between the position of the player and the enemy tank. The part to pay special attention to is <kbd>animator.SetFloat("distanceFromPlayer", currentDistance)</kbd>, which passes the information from this script into the parameter we defined earlier for our state machine. The same is true for the preceding section of the code, which passes in the hit result of the raycast as a Boolean. Lastly, it sets the <kbd>distanceFromTarget</kbd> variable, which we'll be using for the Patrol state in the next section.</p>
<p>As you can see, none of the code concerns itself with how or why the state machine will handle transitions; it merely passes in the information the state machine needs, and the state machine handles the rest. Pretty cool, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making our enemy tank move</h1>
                
            
            
                
<p>You may have noticed in addition to the variables we didn't cover yet, that our tank has no logic in place for moving. This can be easily handled with a substate machine, which is a state machine within a state. This may sound confusing at first, but we can easily break down the Patrol state into substates. In our example, the Patrol state will be in one of the two substates—moving to the current waypoint or finding the next waypoint. A waypoint is essentially a destination for our agent to move toward. In order to make these changes, we'll need to go into our state machine again.</p>
<p>First, create a substate by clicking on an empty area on the canvas and then selecting Create Sub-State Machine. Since we already have our original Patrol state and all the connections that go with it, we can just drag and drop our Patrol state into our newly-created substate to merge the two. As you drag the Patrol state over the substate, you'll notice a plus sign appears by your cursor; this means you're adding one state to the other. When you drop the Patrol state in, the new substate will absorb it. Substates have a unique look: they are six-sided rather than rectangular. Go ahead and rename the substate to <kbd>Patrol</kbd>:</p>
<div><img height="193" width="377" src="img/2d2fd838-a0e7-48e1-93bc-17bf4dd0ba99.png"/></div>
<p>To enter a substate, simply double-click on it. Think of it as going a level lower into the substate. The window will look fairly similar, but you will notice a few things—your Patrol state is connected to a node called (Up) Base Layer, which essentially is the connection from this level to the upper level that the substate machine sits on. The Entry state connects directly to the Patrol state.</p>
<p>Unfortunately, this is not the functionality we want, as it's a closed loop that doesn't allow us to get in and out of the state into the individual waypoint states we need to create; so let's make some changes. First, we'll change the name of the substate to <kbd>PatrolEntry</kbd>. Next, we need to assign some transitions. When we enter this Entry state, we want to decide whether to continue moving to the current waypoint, or to find a new one. We'll represent each of the outcomes as a state, so create two states, <kbd>MovingToTarget</kbd> and <kbd>FindingNewTarget</kbd>, then create transitions from the PatrolEntry state to each one of the new states. Likewise, you'll want to create a transition between the two new states, meaning a transition from the <kbd>MovingToTarget</kbd> state to the <kbd>FindingNewTarget</kbd> state and vice versa. Now, add a new float parameter called <kbd>distanceFromWaypoint</kbd> and set up your conditions like this:</p>
<ul>
<li>PatrolEntry to MovingToTarget:
<ul>
<li>distanceFromWaypoint &gt; 1</li>
</ul>
</li>
<li>PatrolEntry to FindingNewTarget:
<ul>
<li>distanceFromWaypoint &lt; 1</li>
</ul>
</li>
<li>MovingToTarget to FindingNewTarget:
<ul>
<li>distanceFromWaypoint &lt; 1</li>
</ul>
</li>
</ul>
<p>You're probably wondering why we didn't assign the transition rule from the FindingNewTarget state to the MovingToTarget state. This is because we'll be executing some code via state machine behavior and then automatically going into the MovingToTarget state without requiring any conditions. Go ahead and select the FindingNewTarget state and add a behavior and call it <kbd>SelectWaypointState</kbd>.</p>
<p>Open up the new script and remove all the methods, except for <kbd>OnStateEnter</kbd>. Add the following functionality to it:</p>
<pre>TankAi tankAi = animator.gameObject.GetComponent&lt;TankAi&gt;();
tankAi.SetNextPoint();</pre>
<p>What we're doing here is getting a reference to our <kbd>TankAi</kbd> script and calling its <kbd>SetNextPoint()</kbd> method. Simple enough, right?</p>
<p>Lastly, we need to redo our outgoing connections. Our new states don't have transitions out of this level, so we need to add one, using the exact same conditions that our PatrolEntry state has, to the (Up) Base Layer state. This is where Any State comes in handy—it allows us to transition from any state to another state, regardless of individual transition connections, so that we don't have to add transitions from each state to the (Up) Base Layer state; we simply add it once to the Any State, and we're set! Add a transition from the Any State to the PatrolEntry state and use the same conditions the Entry state has to the (Up) Base Layer state. This is a workaround for not being able to connect directly from the Any State to the (Up) Base Layer state.</p>
<p>When you're done, your substate machine should look similar to this:</p>
<div><img height="264" width="426" src="img/69745fef-cf8a-4666-af80-ad859db55fae.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>Now, all we have to do is hit play and watch our enemy tank patrol back and forth between the two provided waypoints. If we place the player in the editor, in the enemy tank's path, we'll see the transition happen in the animator, out of the Patrol state and into the Chase state, and when we move the player out of range, back into the Patrol state. You'll notice our Chase and Shoot states are not fully fleshed out yet. This is because we'll be implementing these states via concepts we'll cover in <a href="25db39aa-6768-453c-855d-9f075da0e83e.xhtml">Chapter 3</a>, <em>Implementing Sensors</em>, and <a href="503803fe-f343-4a0c-835f-463c98005182.xhtml">Chapter 4</a>, <em>Finding Your Way</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to implement state machines in Unity 2017 using animator and controller-based state machines for what will be our tank game. We learned about state machine behaviors and transitions between states. With all of these concepts covered, we then applied the simple state machine to an agent, thus creating our first artificially intelligent entity!</p>
<p>In the next chapter, we'll continue to build our tank game and give our agent more complex methods for sensing the world around it.</p>


            

            
        
    </body></html>