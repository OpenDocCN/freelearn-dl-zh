<html><head></head><body>
        

                            
                    <h1 class="header-title">Designing Behavior Trees - Part III</h1>
                
            
            
                
<p>This chapter is a continuation of the previous one, and is the final part of <em>Designing Behavior Trees</em>. We will finish what we started. In particular, we will build the final <em>Behavior Tree</em> and make it run.</p>
<p>In particular, we will cover the following topics:</p>
<ul>
<li>Generating the <strong><em>Blackboard</em></strong> and the <strong><em>Behavior Tree</em></strong> assets</li>
<li>Setting up the <strong><em>Blackboard</em></strong> so that it can be used with the <em>Behavior Tree</em></li>
<li>Implementing the <strong><em>Behavior Tree </em></strong>(using either the Blueprint or C++ nodes) to make a Chasing Behavior</li>
<li><strong><em>Making the Behavior Tree running</em></strong> (both in a Blueprint or C++)</li>
<li><em><strong>Improving the C++ nodes</strong></em> of the Behavior Tree to better align with <em>best practices</em></li>
</ul>
<p>Once again, we will be implementing everything in both Blueprint and C++ to give you a broader idea of what you can use. Alternatively, if you already know what you want to use, you can just follow one of the two implementations.</p>
<p class="mce-root">This will conclude our journey of <em>Designing a Behavior Tree</em> from scratch, and at the end, we will have our Chasing Behavior complete.</p>
<p>So, without further ado, let's dive into building the <em>Behavior Tree</em>!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the Behavior Tree</h1>
                
            
            
                
<p>The last step in creating the Chasing Behavior is to build the Behavior Tree.</p>
<p>At this stage, if you feel like you have missed something, just revise the <strong><em>Expected Behavior</em></strong> (the one we have described in Chapter 8) and <em>do a checklist</em> of what you will need to build this <em>Behavior Tree</em>. However, even if you did miss something, don't worry – you can create it at a later stage.</p>
<p>Many developers start developing the <em>Behavior Tree</em> and then build the nodes when they need them. Unless you are really good or the tree is particularly simple, it is always advisable to plan a little bit ahead, like we have did in the last two chapters. By doing this, you will avoid many headaches later on, and by having a little work overhead at the beginning, you avoid a large, bug-fixing time cost. Of course, you will still need to do bug fixing, but planning should reduce the chance of introducing bugs, or achieving a different behavior from the one that was originally planned.</p>
<p>From this point onward, you can use the Blueprint and C++ implementations (in case you have been using both), or just stick to the one you have been using so far. I will use the names from the Blueprint implementation, but the concepts for using our C++ nodes are exactly the same. In the end, I'll show a screenshot of the <em>Behavior Tree</em> build with CPP nodes instead.</p>
<p>It's worth noting that we can also create a Mix tree. In fact, we can use both the C++ and the Blueprint nodes in the same tree. Since, in our case, we have a replica of each node in both Blueprint and C++, we should be free to use any as we like. However, this is not true, because we have made some nodes depending on the C++ AI controller, which was specific for that implementation. Thankfully in a project, you will not have replicas of everything, so if you have a specific AI Controller, both Blueprint and C++ node should refer to the same one.<br/>
During the development of your project, keep in mind that you can create some <em>Behavior Tree</em> nodes in C++ and some in Blueprint. Some developers prototype their nodes in Blueprint and then move the development to C++. Try to find the formula and the right balance between C++ and Blueprint that works best for you or your team.</p>
<p class="mce-root"/>
<p>To start, if you haven't already, create the <em>Behavior Tree Asset</em>, along with the <em>Blackboard</em>. In my case, I'm going to call the <em>Behavior Tree</em> <strong><em>BT_ChasingBehavior </em></strong>and the Blackboard <strong><em>BB_ChasingBlackboard</em></strong>. Both are placed in the AI folder (where we created our Blueprint nodes), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1339 image-border" src="img/5cade3b5-f974-4890-9650-0754da2a9345.png" style="width:56.25em;height:21.58em;"/></p>
<p>You can reorder the <kbd>AI</kbd> folder a bit by creating sub-folders. For instance, you can create a sub-folder for your Decorators, another for your Tasks, and a third for your Services. Either way, this is a relatively small example, so we will leave the folder as it is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the Blackboard</h1>
                
            
            
                
<p>Let's start by opening the <em>Blackboard Editor</em> (double-click on the asset). As you may recall, we need to have a Player reference.</p>
<p>Thus, create a <strong><em>New Key</em></strong> of type <strong><em>Object</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1340 image-border" src="img/e532a773-dcc8-4ecd-955f-baac6abd1e33.png" style="width:16.50em;height:24.75em;"/></p>
<p>Rename it <strong><em>Player</em></strong>, and in the <em>Details Panel</em>, under the <strong><em>Key Type</em></strong> (you might need to expand this), set the <strong><em>Base Class</em></strong> to be the Player Pawn of our choice (e.g. <strong><em>Player</em></strong>, the class we created at the beginning of this chapter), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1341 image-border" src="img/ac15c42a-77e9-46ef-bceb-d3e483b3b3db.png" style="width:30.67em;height:22.67em;"/></p>
<p>The next <em>Key</em> to add is the <strong><em>Destination</em></strong>, which is of type Vector. This will be useful for determining a goal when the player is not in sight. Speaking of which, we need a third Key of type <em>boolean</em> named <strong><em>CanSeePlayer</em></strong>, which is used to check if the Player is currently in sight or not. This is what the values of the <em>Blackboard</em> should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1342 image-border" src="img/64a60bea-219c-40e9-a02a-cb3db0977b0b.png" style="width:20.67em;height:17.00em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the Tree</h1>
                
            
            
                
<p>Double-click on the <strong><em>BT_ChasingBehavior</em></strong> asset to open the <em>Behavior Tree Editor</em>. Make sure that you have <strong><em>BB_ChasingBlackboard</em></strong> selected for the tree, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1344 image-border" src="img/12001228-7b7e-468b-9baa-572755f192f7.png" style="width:40.75em;height:16.25em;"/></p>
<p>From the <strong><em>Root</em></strong> node, we need to start with a <strong><em>Selector</em></strong>. This <em>Selector</em> will be where the tree will split into two branches: the one that will chase the Player when in sight, and the other when he/she isn't. On this very <em>Selector</em>, we need to attach our <strong><em>BTService_UpdateChasingBehavior</em></strong> Service (or if you wish, its C++ version, named <em><strong>UpdatedChasing</strong></em>). Don't forget to assign all the variables in the <em>Details Panel</em> (the <em>three Blackboard variables</em>), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1345 image-border" src="img/50795f33-f026-4ae8-ac85-e6d1556a6fd8.png" style="width:32.83em;height:30.67em;"/></p>
<p class="mce-root"/>
<p>In the C++ version, we also need to assign the Player Class, along with the Blackboard Variables (since this is the way we designed our Service in C++). Hence, you will have something similar to this:<br/>
<br/>
<img class="alignnone size-full wp-image-1346 image-border" src="img/2cca03a5-239b-473c-8753-50c0034ddca3.png" style="width:35.58em;height:32.00em;"/></p>
<p>Once we have assigned all the variables, then this is what our Service will look like in the <em>Behavior Tree</em> when attached to the <em>Selector</em> node:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1347 image-border" src="img/7311d9a9-0370-47f5-bf5a-fa12a802818b.png" style="width:36.58em;height:30.33em;"/></p>
<p>From the <em>Selector</em>, add two <strong><em>Sequence</em></strong> nodes (each representing the two branches of the tree). Which one the <em>Selector</em> chooses will depend on the decorators we are going to place on these two nodes.</p>
<p>Add both the <strong><em>Sequence</em></strong> nodes to <strong><em>BTDecorator_CheckBoolVariableBP</em></strong> (or the <strong><em>CheckBoolVariable</em></strong> C++ version of it). In the details panel, the <em>Bool Variable To Check</em> variable needs to be fed with the <strong><em>CanSeePlayer</em></strong> <em>Blackboard Key</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1348 image-border" src="img/3b5bf8ca-06f0-40ab-9044-a23555bf96f3.png" style="width:27.58em;height:22.58em;"/></p>
<p>However, for the sequence on the right, you should set the <strong><em>Inverse Condition</em></strong> checkbox to <em>true</em>. By doing this, we can check whether <strong><em>CanSeePlayer</em></strong> is set to <em>false</em>. This is a bit wordy, but here are the final results in the Details panel:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1349 image-border" src="img/e9c8747a-39e7-46a5-b415-a84913cbbbe0.png" style="width:26.50em;height:21.75em;"/></p>
<p class="mce-root"/>
<p>So far, our tree looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1350 image-border" src="img/c06bf2f1-4711-4ef4-8d16-bea6121e2b7f.png" style="width:78.67em;height:53.92em;"/></p>
<p class="mce-root"/>
<p>From the sequence node on the left, we just need to chase the player by using the <strong><em>Move To</em></strong> task. You need to select the <strong><em>Player</em> </strong>blackboard variable as the <em><strong>Blackboard Key</strong></em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1351 image-border" src="img/4ca131c0-5140-4585-bc01-ba82b4b15840.png" style="width:37.00em;height:35.83em;"/></p>
<p>This is the current stage of the tree:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1352 image-border" src="img/acf0f974-5619-466d-be05-030bfd37e6df.png" style="width:59.33em;height:49.08em;"/></p>
<p>From the <strong><em>Sequence</em></strong> node on the right, we need to have two tasks. The first one is <strong><em>Move To</em></strong> again, but this time select the <strong><em>Destination</em></strong> variable as the <em><strong>Blackboard Key</strong></em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1353 image-border" src="img/38b4bb64-3a50-4c54-86b6-a5f6c391ae4d.png" style="width:37.25em;height:35.92em;"/></p>
<p>This is what the tree looks like so far:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1354 image-border" src="img/f626e1a8-ac78-4682-8945-bdf9eee05168.png" style="width:53.83em;height:43.33em;"/></p>
<p>The second <em>Task</em> is the one we have already created, <strong><em>BTTask_FindRandomLocationBP</em></strong> (or the <strong><em>Find Random Location</em></strong> C++ version). We need to set the <strong><em>DestinationKey</em></strong> with the <strong><em>Destination</em></strong> <em>Blackboard variable</em>, and as for the <strong><em>Radius</em></strong>, we can choose a value (e.g. 30000, ten times more the default value). This is what the <em>Details</em> panel looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1355 image-border" src="img/dd525471-861b-472c-9a02-ecf30f330e69.png" style="width:30.33em;height:24.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This is what the complete tree should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1356 image-border" src="img/42e5cf86-f25d-485b-a208-c868f0a2fb0f.png" style="width:51.33em;height:39.83em;"/></p>
<p>It seems like we have finished, but we have one more thing to do. In fact, at the moment, the Decorators don't control the flow of the Sub-Tree once the AI is executing it. In fact, we would like to abort the Task of moving to the Player if he/she is not in sight anymore; on the other hand, if the agent is going to a random location, we want the agent to chase the Player if he/she is in sight again.</p>
<p>To achieve this, we need to select our <strong><em>Decorators</em></strong> (one at the time) and set <strong><em>Observer Abort</em></strong> to <strong><em>Self</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1357 image-border" src="img/e935bd39-f8bc-4771-97de-81ae5097d43d.png" style="width:38.08em;height:37.50em;"/></p>
<p>If the Decorator is still selected, the nodes that will be aborted are highlighted in the Tree:<br/>
<br/>
<img class="alignnone size-full wp-image-1358 image-border" src="img/1209ad61-9437-41ad-b166-34928c965f63.png" style="width:86.92em;height:65.92em;"/></p>
<p>The tree slightly changes to reflect this behavior (under the <strong><em>Decorators</em></strong>, the abort conditions are shown):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1359 image-border" src="img/f665e500-daf6-499b-bb61-d69566dd8f96.png" style="width:85.58em;height:66.17em;"/></p>
<p class="mce-root"/>
<p>If you have built the tree using C++ nodes, you will have something similar to this instead:<br/>
<img class="alignnone size-full wp-image-1360 image-border" src="img/493789be-3579-4c18-92ba-c1228813e109.png" style="width:63.83em;height:57.58em;"/><br/>
<br/>
Moreover, you should notice that, just down below the Node name, not all information are displayed (e.g. in the <em>Decorators</em>, it doesn't say if its condition is inverted and what the abort conditions are). Later in the chapter, we will tackle this issue as well.</p>
<p>As you can see, the structure is very simple (and I have seen the same behavior being implemented in different trees), but it contains all the main concepts for <strong><em>Designing a Behavior Tree</em></strong> (including creating a node of each type: <strong><em>Decorator</em></strong>, <strong><em>Service</em></strong>, and <strong><em>Task</em></strong>). The fact that the structure is simple doesn't mean that the behavior that represents it is simple too. In fact, what we have built is a very nice <strong><em>Chasing Behavior</em></strong>!</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We haven't touched upon Simple Parallel nodes, but those are used in more complicated trees for particular kind of behaviors with sub-trees. You don't have to worry – once you start mastering the art of creating <em>Behaviors Trees</em>, the use of Simple Parallel nodes will become natural.</p>
<p>The last thing that's left to do is make this <em>Behavior Tree</em> run and then to test it in the game!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the Behavior Tree</h1>
                
            
            
                
<p>We have already created the whole setup, including actors, controllers, perception, and navigation. However, we don't have any code that makes this Behavior Tree run on our agent. Of course, we will cover both the Blueprint case and the C++ one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the Behavior Tree using the Blueprint controller</h1>
                
            
            
                
<p>If we have a Blueprint controller set up, we can easily modify it to get the Behavior Tree running immediately.</p>
<p>In fact, once we open the Editor, we can add the <em>Run Behavior Tree</em> node after  overriding the <em>Event OnPossess </em>and choose the right <em>Behavior Tree</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1361 image-border" src="img/0bd4942e-a919-4dc0-ada3-7b7585860e55.png" style="width:56.83em;height:20.83em;"/></p>
<p>Save it, and you are good to go! Run the game and see if it works (of course, the AI controller needs to be set to <strong><em>BP_ChasingAIController</em></strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the Behavior Tree using the C++ controller</h1>
                
            
            
                
<p>Unluckily for C+,+ this is not as straightforward (as we already saw in <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a><em>, Behavior Trees and Blackboards</em>). In particular, we have two choices: we hardcode the value or we get a reference to the tree using blueprints.</p>
<p>The first option is not very practical for this kind of stuff and it is not a best practice.</p>
<p>For the second option, we have a variety of choices. In particular, I suggest that you create a <em>Behavior Tree</em> variable in the controller and use it so that it can be run on the <kbd>OnPossess()</kbd> function. Then, we can create a child of this class in the blueprint, where we can easily assign this variable. Finally, we can change the reference to the controller for our <strong><em>AIChasingAgent</em></strong>.</p>
<p>Alternatively, you can place the <em>Behavior Tree</em> on the <em>Character/Pawn</em> that the AI will control, like we did in <em>Chapter 2</em>. That would be the best approach; however, in this moment it is good to see different alternatives in case you are in a situation in which you will need the <em>Behavior Tree</em> directly on the controller.</p>
<p>Let's start by opening the header file of our C++ controller and adding the following public variable (with the <kbd>UPROPERTY()</kbd> macro, since it needs to be editable in Blueprint):</p>
<pre>  UPROPERTY(EditAnywhere)<br/>  UBehaviorTree* BehaviorTree;</pre>
<p>Then, we need to override the <kbd>OnPossess()</kbd> function:</p>
<pre>   virtual void OnPossess(class APawn* InPawn) override;</pre>
<p>Next, in the <kbd>.cpp</kbd> file, we need to include the <em>Behavior Tree class</em>, so we need to add the following statement:</p>
<pre>#include "BehaviorTree/BehaviorTree.h"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, in the <kbd>OnPossess()</kbd> implementation, we just run the Behavior Tree:</p>
<pre>void AChasingAIController::OnPossess(APawn * InPawn)<br/>{<br/>  Super::OnPossess(InPawn);<br/>  if (BehaviorTree != nullptr) {<br/>    RunBehaviorTree(BehaviorTree);<br/>  }<br/>}</pre>
<p>After compiling the code, we can right-click on the C++ controller and select <strong><em>Create Blueprint class based on ChasingAIController</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1362 image-border" src="img/cb0bb51d-17a8-4fe8-baa8-713577b61681.png" style="width:33.50em;height:29.50em;"/></p>
<p>Then, we can place this Blueprint inside the AI folder and name it <strong><em>CPP_ChasingAIController</em></strong> (to distinguish it from <em>BP_ChasingAIController</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1363 image-border" src="img/1c55c897-67e1-40ee-81b5-6975c2792598.png" style="width:78.25em;height:35.92em;"/></p>
<p>Its <em>Blueprint Editor</em> should open automatically (if not, just double-click on the asset to open it). Set the <strong><em>Behavior Tree</em></strong> variable in the <em>Details Panel</em>, as shown in the following screenshot (of course, we will need to set the <em>C++ version</em> of the <em>Behavior Tree</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1364 image-border" src="img/614c7993-25a9-40c7-85ad-2330b1f59755.png" style="width:43.00em;height:23.08em;"/></p>
<p class="mce-root"/>
<p>Compile and save the <em>Blueprint</em>.</p>
<p>Finally, in the <strong><em>AI_ChasingAgent</em></strong> blueprint, let's change its settings (from the <em>Details</em> panel in the <strong><em>Pawn</em></strong> tab) so that it will use the new controller:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1365 image-border" src="img/7581820f-462c-4dde-8c0d-fdf15a506759.png" style="width:38.17em;height:17.92em;"/></p>
<p>This concludes how to run the <em>Behavior Tree</em> on a <em>C++ controller</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bug Correction</h1>
                
            
            
                
<p>If you have though to have finished, well, that's not it. In fact, when designing a Behavior Tree, there must always be a phase of debugging and check if everything works as it should. Actually, on purpose I built the tree with something that doesn't work. Can you figure it out? Give it a try before keep reading.</p>
<p>The first problem is that, the Destination Key in the Blackboard, until the Player is not on sight, it will never get initialized. Moreover, there is another problem, when the AI enemy is seeking the Last Known Position of the player, but it is not reachable, it will fail the task. As a result, the sequence will not allow to go in the next Task to select a <em>Random Destination</em>. How can we fix this? Let's give it a try before we keep reading.</p>
<p>There are many approaches to this. For instance, you might have though to use the "<em>Force Success</em>" Decorator. It is not a bad idea at all, actually, this are the kind of cases in which you would use this Decorator (to add an optional Branch to the Sequence, so regardless if the Move To fails, we can still pick a Random Destination). Unfortunately, it doesn't work well with the setup we have with the other two decorators.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Thus, another solution is to modify the tree in the following way. We need to substitute the second Sequence with a Selector, with two Sequences as children. In the first Sequence, we place our Move To Task followed by the Find Random Destination one. In the other Sequence they are inverted. As result, in case the Task to follow the Last Known Player Position fails, the tree can revert back to Find a Random Location. If you wish, you could also remove the last Move To in the second Sequence, but I'm leaving it there for clarity; especially for those who struggle to grasp how <em>Behavior Tree</em> works. At the end, this is how it should look like the Behavior Tree (Blueprint version):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fd0fbae0-60ef-4684-9c35-161a98aba46c.png"/></p>
<p>And this is how the C++ version should change (the changes of the next section have already been implemented in this picture):<br/>
<br/>
<img src="img/2869bfc3-5bdd-49fe-a375-4f55f421631b.png"/></p>
<p>Of course the solution is not unique, and you may find better ways to do it. </p>
<p>What about our first problem of the <em>Destination</em> never be initialized? Well, we don't have this problem anymore with the proposed solution, since if the first <em>Sequence</em> (in the right-branch) fails, then the second one will set the <em>Destination</em> to a <em>Random Location</em>. In fact, when debugging Behavior Trees, you always need to be careful to each modification and how this affects the whole tree. Imagine this for a complex Behavior, and you can get an idea of the time required for such Task.</p>
<p>Once we have fixed this, we can always check for other bugs and/or try to improve the set up. Here a couple of other issues, which I leave you to fix, in order to practice with <em>Behavior Trees</em>:</p>
<ul>
<li>When the <em>Behavior Tree</em> starts its execution, the <em>Destination</em> is set to the zero vector. This means, that the AI, if doesn't see the Player, will go straight to the <em>World Origin</em>. Can you try to avoid it? Try to think, which are the different alternatives we have? The best would be to have a Random Destination In range. How can we achieve that?</li>
<li>At the moment, when we do the Cast in the Perception System, we just select a broader class of <em>BehaviorTreeDesignCharacter</em>. However, this causes problems if you have more than one AI in the level. How can you fix that? For sure, you can change the Cast into something more specific, so to reduce it only to the Player. But what if you cannot do that, because both Players and friendly AI must share the same class? You could try to use the different Teams to distinguish enemies, allies and neutral; recall from Chapter 5.</li>
</ul>
<p>Of course, this was just a very small example of <em>Behavior Tree</em>, yet it took three solid chapters to go through it in details. I will leave you exploring Behavior Trees for your games, but before that, the next section will talk about some suggestions on how to improve the C++ code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving further (C++ only)</h1>
                
            
            
                
<p>We have made a very nice Behavior Tree by programming the different nodes we have used. However, when you work on a big project or with other team members, you should ensure that your nodes are as solid as possible. In fact, in the C++ implementation, we added a static description to our nodes to show which variables were set, and that was fantastic. But we can do more!</p>
<p>This section will guide you through improving the C++ nodes even further.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Node Name</h1>
                
            
            
                
<p>Unreal does a good job in C++ Behavior Tree nodes by cutting out the prefix (e.g. "<strong><em>BTTask_</em></strong>") and directly showing the name of the Task (or Decorator or Service). In the blueprint, it keeps the whole prefix instead, as you see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1366 image-border" src="img/c3121d28-a5f2-48e1-82f6-f0d73f76f70e.png" style="width:55.25em;height:12.83em;"/></p>
<p>As we saw in the previous chapters, you can modify the name that will be displayed by changing the <strong><em>Node Name</em></strong> property in the <em>Details</em> panel:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1367 image-border" src="img/d3bae5b3-5897-4208-abcc-34a08b43038f.png" style="width:26.25em;height:18.08em;"/></p>
<p>This is reflected in the Behavior Tree:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1368 image-border" src="img/7928766e-7ce9-4487-aaea-e20bcf9a7281.png" style="width:56.17em;height:13.58em;"/></p>
<p>Thus, when you write a C++ node, it's good practice to give a default <strong><em>Node Name</em></strong>. You can do this by simply assigning it in the constructor. So, let's do this for all three C++ nodes we have created. </p>
<p>In the <em>Decorator</em> header file, we need to add the declaration of the constructor:</p>
<pre> UBTDecorator_CheckBoolVariable(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());</pre>
<p>Its implementation in the <kbd>.cpp</kbd> file is straightforward, since we just need to add the following:</p>
<pre>UBTDecorator_CheckBoolVariable::UBTDecorator_CheckBoolVariable(const FObjectInitializer &amp; ObjectInitializer)<br/>  : Super(ObjectInitializer)<br/>{<br/>  NodeName = "Check Bool Variable";<br/>}</pre>
<p>This is the final result:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1369 image-border" src="img/b09da5ce-8ccf-42b8-8e5d-320c004e630a.png" style="width:17.25em;height:10.25em;"/></p>
<p>We need to do this with our Task, too. So, let's declare the constructor in the header file:</p>
<pre> UBTTaskNode_FindRandomLocation(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());</pre>
<p>Its implementation in the <kbd>.cpp</kbd> file is as follows:</p>
<pre>UBTTaskNode_FindRandomLocation::UBTTaskNode_FindRandomLocation(const FObjectInitializer &amp; ObjectInitializer)<br/>  : Super(ObjectInitializer)<br/>{<br/>  NodeName = "Find Random Location";<br/>}</pre>
<p>This is how it looks in the Behavior Tree Editor:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1370 image-border" src="img/7c16018a-7b00-4895-8950-d2100ba9e137.png" style="width:18.50em;height:8.75em;"/></p>
<p class="mce-root"/>
<p>Finally, we already have a constructor for our Service, so we just need to add a line to its constructor in the <kbd>.cpp</kbd> file:</p>
<pre>UBTService_UpdateChasing::UBTService_UpdateChasing(const FObjectInitializer&amp; ObjectInitializer)<br/>  : Super(ObjectInitializer)<br/>{<br/><strong>  NodeName = "Update Chasing Behavior";</strong><br/><br/>  bNotifyBecomeRelevant = false;<br/>  bNotifyCeaseRelevant = true;<br/>}</pre>
<p>The service will appear with a nice name in the Behavior Tree Editor:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1371 image-border" src="img/ff5d104e-4add-4206-8724-4ad2d05cf3ec.png" style="width:29.67em;height:20.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">A better description for the Decorator</h1>
                
            
            
                
<p>As we mentioned previously, when we use the C++ version of the Decorator, we are unable to see whether the condition is reversed, or the aborts settings.</p>
<p>To add them into our static description, we need to change the code slightly. Fortunately, the header describing all of these properties is given in the parent class of our Decorator, and so we don't need to write the code from scratch. We need to store the return value of the parent function (by using the <kbd>Super::GetStaticDescription()</kbd> function) in a local FString Variable.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Then, we can add a couple of new lines and append the original Static Description we made. Finally, we return the new variable:</p>
<pre>FString UBTDecorator_CheckBoolVariable::GetStaticDescription() const<br/>{<br/>  FString ReturnDesc = Super::GetStaticDescription();<br/>  ReturnDesc += "\n\n";<br/>  ReturnDesc += FString::Printf(TEXT("%s: '%s'"), TEXT("Bool Variable to Check"), BoolVariableToCheck.IsSet() ? *BoolVariableToCheck.SelectedKeyName.ToString() : TEXT(""));<br/>  return ReturnDesc;<br/>}</pre>
<p>This is the final effect:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1372 image-border" src="img/c0170df2-400d-4730-91ee-4746531103e6.png" style="width:21.08em;height:16.75em;"/></p>
<p>Of course, you can use the <kbd>Super::GetStaticDescription()</kbd> function for Tasks and Services as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Filtering Blackboard Keys</h1>
                
            
            
                
<p>When we insert <em>Blackboard Keys</em> in the <em>Details Panel</em>, we can insert any key that's present in the <em>Bl</em><em>ackboard</em>. However, when we use our <strong><em>CheckBoolVariable</em></strong> Decorator, we only want boolean keys in the <strong><em>BoolVariableToCheck</em></strong>.</p>
<p>We can achieve this by adding some filters in the constructor, as we learned back in <a href="e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml">Chapter 6</a>, <em>Extending the Behavior Tree</em>. Let's do this for all three nodes.</p>
<p class="mce-root"/>
<p>In the implementation of the <em>Constructor</em> of our <strong><em>Check Bool Variable Decorator</em></strong> (<kbd>.cpp</kbd> file), we need to add the following filter so that it can only select boolean keys:</p>
<pre>UBTDecorator_CheckBoolVariable::UBTDecorator_CheckBoolVariable(const FObjectInitializer &amp; ObjectInitializer)<br/>  : Super(ObjectInitializer)<br/>{<br/>  NodeName = "Check Bool Variable";<br/><br/><strong>  BoolVariableToCheck.AddBoolFilter(this, GET_MEMBER_NAME_CHECKED(UBTDecorator_CheckBoolVariable, BoolVariableToCheck));</strong><br/>}</pre>
<p>Now, our <em>Decorator</em> will only be able to accept Boolean keys:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1373 image-border" src="img/28b60dbe-21ae-44b1-8a8f-b133b0cb7edc.png" style="width:25.33em;height:20.00em;"/></p>
<p>Likewise, we can do the same for our <em>Task</em> for the Destination Vector, which is of type Vector. In its <em>Constructor</em> (<kbd>.cpp</kbd> file), add the following:</p>
<pre>UBTTaskNode_FindRandomLocation::UBTTaskNode_FindRandomLocation(const FObjectInitializer &amp; ObjectInitializer)<br/>  : Super(ObjectInitializer)<br/>{<br/>  NodeName = "Find Random Location";<br/><br/><strong>  DestinationVector.AddVectorFilter(this, GET_MEMBER_NAME_CHECKED(UBTTaskNode_FindRandomLocation, DestinationVector));</strong><br/>}</pre>
<p>Now, our <strong><em>Find Random Location Task</em></strong> can only accept Vector Keys:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1374 image-border" src="img/3ce3ce9b-bd51-4056-81d9-3be4169ae8cf.png" style="width:28.58em;height:23.33em;"/></p>
<p>Finally, in our <strong><em>Update Chasing Behavior Service</em></strong>, we need to do the same, but for each of the three variables. In particular, in the <em>Object</em> filter, we need to specify a class. In this example, we can just filter based on <kbd>AActor</kbd>. So, in the <kbd>.cpp</kbd> file, add the following lines:</p>
<pre>UBTService_UpdateChasing::UBTService_UpdateChasing(const FObjectInitializer&amp; ObjectInitializer)<br/>  : Super(ObjectInitializer)<br/>{<br/>  NodeName = "Update Chasing Behavior";<br/><br/>  bNotifyBecomeRelevant = true;<br/>  bNotifyCeaseRelevant = false;<br/><br/><strong>  // Filter the Blackboard Key Selectors</strong><br/><strong>  PlayerKey.AddObjectFilter(this, GET_MEMBER_NAME_CHECKED(UBTService_UpdateChasing, PlayerKey), AActor::StaticClass());</strong><br/><strong>  LastKnownPositionKey.AddVectorFilter(this, GET_MEMBER_NAME_CHECKED(UBTService_UpdateChasing, LastKnownPositionKey));</strong><br/><strong>  CanSeePlayerKey.AddBoolFilter(this, GET_MEMBER_NAME_CHECKED(UBTService_UpdateChasing, CanSeePlayerKey));</strong><br/>}</pre>
<p>This is how it appears when we try to select a key for our <em>Service</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1375 image-border" src="img/e5283aee-c6af-41ff-a88f-a0b7bd6a606b.png" style="width:25.00em;height:22.83em;"/></p>
<p>This concludes this section and our journey of creating a <em>Behavior Tree</em> from scratch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have completed what we started in the previous two chapters. In fact, we have built a Behavior Tree from scratch, starting from the design phase, and implementing all the components we needed along the way (both in Blueprint and C++!).</p>
<p class="mce-root">In particular, in this chapter we have seen how to build the Behavior Tree, along with the Blackboard; make the Behavior Tree run (both in a Blueprint and C++ setup); and improved the C++ implementation of the nodes by assigning node names, placing a header in the Decorator, and filtering the <em>Blackboard Key</em> selectors based on their type.</p>
<p>This chapter concludes the main features of the Unreal Engine AI Framework. However, this doesn't mean that we are finished with this Framework just yet. In fact, we can now perform an extensive debugging of the AI, which is the topic we are going to face in the next chapters.</p>


            

            
        
    </body></html>