- en: '*Chapter 5*: Flocking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During early summer evenings, you have probably seen flocks of birds flying
    in the sky. You have probably noted how they seem to move as a single living object:
    they all move in a particular direction, turn around, and grow and shrink. A flocking
    system aims to replicate this behavior in games: we want to implement an algorithm
    to move many objects as an organic group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In games, we call each element of a flock a **boid**. To implement a flocking
    behavior, we do not need to equip each boid with a high-level complex decision-making
    system; instead, all we need to do is implement simple *reactive* rules for each
    boid that depend only on the state of the flock itself. Thus, flocking is an excellent
    example of emergent behavior: each boid reacts exclusively to its neighbor''s
    behaviors; nevertheless, the flock seems to move as if someone were coordinating
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn what these rules are and how to implement them
    in Unity3D. We will implement two variations of flocking in this chapter. The
    first one is based on an old flocking behavior demo that has been circulating
    in the Unity community since since the game engine was created.
  prefs: []
  type: TYPE_NORMAL
- en: The second variation is based on Craig Reynold's original flocking algorithm
    from 1986.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of basic flocking behavior and how to implement it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative implementation of flocking behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 5` folder in the book''s repository:
    [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Basic flocking behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we said in the introduction to this chapter, we can describe a flocking
    behavior by using just three intuitive properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation**: This property, also called *short-range repulsion*, represents
    the minimum distance between neighboring boids to avoid collisions. You can imagine
    this rule as a force that pushes a boid away from the others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment**: This property represents the likelihood for each boid to move
    in the same direction as the flock (we measure this as the average direction of
    all the individual boids).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion**: This property, also called *long-range attraction*, represents
    the likelihood for each boid to move toward the center of mass of the flock (we
    measure this by averaging the position of each boid in the flock). Thus, you can
    imagine this rule as a force that pushes a boid toward the center of the flock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this demo, we will create a scene with flocks of objects and implement the
    flocking behavior in C#. For this first version, we compute all the rules by ourselves.
    Also, we will create a boid commander that leads the crowd to control and track
    the general position of the flock easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the **Hierarchy** scene in the following screenshot. As you can
    see, we have several boid entities named **UnityFlock**, under a controller named
    **UnityFlockController**. **UnityFlock** entities are individual boid objects
    that refer to their parent **UnityFlockController** entity, using it as a leader.
    The controller updates the next destination point randomly once it reaches the
    current destination point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The scene hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_05_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The scene hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: '`UnityFlock` script. We can use any other mesh representation for this prefab
    to represent something more interesting, such as birds. You can add as many **UnityFlock**
    prefabs as you like. The algorithm will automatically check the number of children
    in the **UnityFlockController** object.'
  prefs: []
  type: TYPE_NORMAL
- en: Individual behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Boid* is a term coined by Craig Reynold that refers to bird-like objects.
    We use this term to describe each object in our flock. The boid behaviour consists
    of a group of objects, each having their individual position, velocity, and orientation.
    Now, let''s implement the boid behavior. You can find the behavior that controls
    each boid in the flock in the `UnityFlock.cs` script, which we''ll examine now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As public fields, we declare the input values for our algorithm. These can
    be set up and customized from within the Inspector. In this script, we perform
    the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the minimum movement speed (`minSpeed`) and rotation speed (`turnSpeed`)
    for our boid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `randomFreq` to determine how many times we want to update the `randomPush`
    value, based on the `randomForce` value. Then, we use this force to vary the single
    boid's velocity and make the flock's movement look more realistic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`toOriginRange` specifies how much we want the flock to spread out. In other
    words, it represents the maximum distance from the flock''s origin in which we
    want to maintain the boids (following the previously mentioned cohesion rule).
    We use the `avoidanceRadius` and `avoidanceForce` properties to maintain a minimum
    distance between individual boids (following the separation rule). Similarly,
    we use `followRadius` and `followVelocity` to keep a minimum distance between
    the leader or origin of the flock. The `origin` variable stores the parent object
    that controls the entire flock; in other words, it is the flock leader. The boids
    need to know about the other boids in the flock. Therefore, we use the `objects`
    and `otherFlocks` attributes to store the neighboring boid''s information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the initialization method for our boid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We set the parent of the object of our boid as origin, meaning that this is
    the controller object for the other boids to follow. Then, we grab all the other
    boids in the group and store them in the `otherFlocks` attribute for later reference.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, coroutines are *functions that can be paused*. With coroutines,
    you can run a method, pause the execution for a desired amount of time (for example,
    a single frame or several seconds), and then continue from the following line
    as if nothing happened. They have two primary use cases: to run a function after
    a specific interval (without keeping track of every frame of `elapsedTimes`, as
    we did in other examples) or to split the computation of some heavy algorithm
    over multiple frames (and, therefore, not incur in frame drops). Coroutines, it
    turns out, are a pretty helpful tool to master. You can read more at [https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement the `UpdateRandom` coroutine. As a coroutine, the function
    never actually terminates, but we run the body of the `while` loop for each random
    time interval:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `UpdateRandom` method as a coroutine by specifying the `IEnumerator`
    return type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UpdateRandom()` method updates the `randomPush` value throughout the game
    with an interval based on `randomFreq`. `Random.insideUnitSphere` returns a `Vector3`
    object with random *x*, *y*, and *z* values within a sphere, with a radius of
    the `randomForce` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We wait for a certain random amount of time before resuming `while(true)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop to update the `randomPush` value again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, here is our boid behavior''s `Update()` method, which helps the boid entity
    comply with the three rules of the flocking algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code implements the separation rule. First, we check the distance
    between the current boid and the other boids, and then we update the velocity
    accordingly, as explained in the comments in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now calculate the average velocity vector of the flock by dividing the current
    velocity vector by the number of boids in the flock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add up all the factors, such as `randomPush`, `originPush`, and `avgVelocity`,
    to calculate the final target velocity vector, `wantedVel`. We also update the
    current velocity to `wantedVel` with a linear interpolation by using the `Vector3.RotateTowards`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We move our boid based on the new velocity using the `Translate` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a final touch, we create a cube mesh, to which we add the `UnityFlock` script,
    and then save it as a prefab, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The UnityFlock prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_05_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The UnityFlock prefab
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it is time to create the controller class. This class updates its position
    so that the other individual boid objects know where to go. The `origin` variable
    in the preceding `UnityFlock` script contains a reference to this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code in the `UnityFlockController.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Update()` method, we check whether our controller object is near the
    target destination point. If it is, we update the `nextMovementPoint` variable
    again with the `CalculateNextMovementPoint()` method that we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `CalculateNextMovementPoint()` method finds the next random destination
    position in a range between the current position and the boundary vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we put all of this together, as shown in *Figure 5.1*, which should
    give you flocks of squares flying around realistically in the sunset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A demonstration of the ﬂocking behavior using the Unity seagull
    sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_05_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A demonstration of the ﬂocking behavior using the Unity seagull
    sample
  prefs: []
  type: TYPE_NORMAL
- en: The previous example gave you the basics of flocking behaviors. In the next
    section, we will explore a different implementation that makes use of Unity's
    `Rigidbody` component.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we use the Unity physics engine to simplify the code a bit.
    In fact, in this example, we attach a `Rigidbody` component to the boids to use
    the `Rigidbody` properties to translate and steer them. In addition, the `Rigidbody`
    component is also helpful in preventing the other boids from overlapping with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation, we have two components: the individual boid behavior
    and the controller behavior (the element referred to as the *flock controller*
    in the previous section). As before, the controller is the object that the rest
    of the boids follow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the `Flock.cs` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will create `FlockController` in a moment. In the meantime, in the `Update()`
    method in the previous code block, we calculate the boid's velocity using the
    `Steer()` method and apply the result to the boid's rigid-body velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether the current speed of the `Rigidbody` component falls
    inside our controller''s maximum and minimum velocity ranges. If not, we cap the
    velocity at the preset range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `steer()` method implements the *separation*, *cohesion*, *alignment*,
    and *follows the leader* rules of the flocking algorithm. Then, we add up all
    the factors with a random weight value. We use this *Flock* script together with
    the `Rigidbody` and `SphereCollider` components to create a Flock prefab, as shown
    in the following screenshot (make sure to disable the gravity by unchecking **Use
    Gravity**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Flock'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_05_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Flock
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to implement the final piece of the puzzle: the `FlockController`
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: FlockController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `FlockController` component is similar to the one in the previous example.
    In addition to controlling the flock''s speed and position, this script also instantiates
    the boids at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the `FlockController.cs` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We declare all the public properties to implement the flocking algorithm and
    then start generating the boid objects based on the flock size input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set up the controller class and the parent `Transform` object, as we did
    last time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add every boid object we create to the `flockList` array. The target variable
    accepts an entity to be used as a moving leader. In this example, we create a
    sphere entity as a moving target leader for our flock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Update` method, we keep updating the average center and velocity of
    the flock. These are the values referenced from the boid object and are used to
    adjust the cohesion and alignment properties with the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Flock Controller'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_05_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Flock Controller
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to implement our **Target** entity with the **Target Movement (Script)**.
    The movement script is the same as what we saw in our previous Unity3D sample
    controller''s movement script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The Target entity with the TargetMovement script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_05_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – The Target entity with the TargetMovement script
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how our `TargetMovement` script works: we pick a random point nearby
    for the target to move to, and when we get close to that point, we pick a new
    one. The code in the `TargetMovement.cs` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we put everything together, we should see a nice flock of cubic boids
    flying around in the scene, all chasing the spheric target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Flocking with Craig Reynold''s algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17984_05_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Flocking with Craig Reynold's algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have implemented flocking behavior in two different ways, we can
    experiment with different parameters and tweak the boids'' behavior until we find
    a movement we like. I want to conclude this chapter with an important takeaway:
    note that we do not need complex algorithms to have a natural-looking behavior.
    For that, we just need simple reactive rules and a way to combine them.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement flocking behaviors in two ways.
    First, we examined and learned how to implement a basic flocking algorithm using
    nothing other than our scripts. Next, we implemented the same algorithm using
    Unity's `Rigidbody` component to control the boid's movement and Sphere Collider
    to avoid collision with other boids.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we always referred to boids as bird-like entities. However,
    we can use flocking for many other applications: fishes swimming in the sea, sheep
    grazing on a plane, a swarm of insects, and even groups of people walking on the
    street can show flocking behavior. To adapt the algorithm to different scenarios,
    we just need to change the flocking rules'' values and eventually lock the movement
    to a plane.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go beyond random movement and look at how to follow
    a specific path. This is the first step toward learning how to avoid obstacles
    that are in your way.
  prefs: []
  type: TYPE_NORMAL
