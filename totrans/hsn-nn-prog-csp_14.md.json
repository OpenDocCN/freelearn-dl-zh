["```py\n// Set this close to 50 and a multiple of the number of processors, e.g. 8.\nstatic readonly int NumRuns = 64;\n// The total dimensions.\nstatic readonly int Dim = 5;\n// The dimension factor.\nstatic readonly int DimFactor = 2000;\n// The total number of times we will loop to determine optimal parameters.\nstatic readonly int NumIterations = DimFactor * Dim;\n```", "```py\n// The optimizer whose control parameters are to be tuned.\nstatic Optimizer Optimizer = new MOL();\n```", "```py\nstatic WeightedProblem[] WeightedProblems = new WeightedProblem[]\n{\nnew WeightedProblem(1.0, new Sphere(Dim, NumIterations)),\n};\nNext we have our settings for the meta-optimization layer.\nstatic readonly int MetaNumRuns = 5;\nstatic readonly int MetaDim = Optimizer.Dimensionality;\nstatic readonly int MetaDimFactor = 20;\nstatic readonly int MetaNumIterations = MetaDimFactor * MetaDim;\n```", "```py\nstatic SwarmOps.Optimizers.Parallel.MetaFitness MetaFitness = new SwarmOps.Optimizers.Parallel.MetaFitness(Optimizer, WeightedProblems, NumRuns, MetaNumIterations);\n```", "```py\nstatic Optimizer MetaOptimizer = new LUS(LogSolutions);\n```", "```py\nstatic readonly bool StatisticsOnlyFeasible = true;\nstatic Statistics Statistics = new Statistics(MetaOptimizer, StatisticsOnlyFeasible);\nstatic Repeat MetaRepeat = new RepeatMin(Statistics, MetaNumRuns);\n```", "```py\ndouble fitness = MetaRepeat.Fitness(MetaParameters);\n```", "```py\nStatistics.Compute();\n```", "```py\npublic override double Fitness(double[] parameters, double fitnessLimit)\n{\ndouble fitnessSum = 0;\n// Iterate over the problems.\nfor (int i = 0; i < ProblemIndex.Count && fitnessSum<fitnessLimit; i++)\n{\n// Assign the problem to the optimizer.\nOptimizer.Problem = ProblemIndex.GetProblem(i);\n// Get the weight associated with this problem.\ndouble weight = ProblemIndex.GetWeight(i);\n// Use another fitness summation because we need to keep\n// track of the performance on each problem.\ndouble fitnessSumInner = 0;\n// Perform a number of optimization runs.\nfor (int j = 0; j < NumRuns && fitnessSum < fitnessLimit; j++)\n{\n// Perform one optimization run on the problem.\nResult result = Optimizer.Optimize(parameters, fitnessLimit -fitnessSum);\n// Get the best fitness result from optimization and adjust it\n// by subtracting its minimum possible value.\ndouble fitness = result.Fitness;\ndouble fitnessAdjusted = fitness - Optimizer.MinFitness;\n// Ensure adjusted fitness is non-negative, otherwise Preemptive\n// Fitness Evaluation does not work.\nDebug.Assert(fitnessAdjusted >= 0);\n// Apply weight to the adjusted fitness.\nfitnessAdjusted *= weight;\n// Accumulate both fitness sums.\nfitnessSumInner += fitnessAdjusted;\nfitnessSum += fitnessAdjusted;\n}\n// Set the fitness result achieved on the problem.\n// This was why we needed an extra summation variable.\nProblemIndex.SetFitness(i, fitnessSumInner);\n}\n// Sort the optimization problems so that the worst\n// performing will be attempted optimized first, when\n// this method is called again.\nProblemIndex.Sort();\nreturn fitnessSum;\n}\n```", "```py\npublic abstract class Problem\n{\npublic Problem() : this(0, true)\n{\n}\npublic Problem(int maxIterations) : this(maxIterations, true)\n{\n}\npublic Problem(int maxIterations, bool requireFeasible)\n{\nMaxIterations = maxIterations;\nRequireFeasible = requireFeasible;\n}\n```", "```py\npublic int MaxIterations\n```", "```py\npublic bool RequireFeasible\n```", "```py\npublic abstract string Name\n```", "```py\npublic virtual string[] ParameterName => null;\n```", "```py\npublic abstract double[] LowerBound\n```", "```py\npublic abstract double[] UpperBound\n```", "```py\npublic virtual double[] LowerInit => LowerBound;\n```", "```py\npublic virtual double[] UpperInit => UpperBound;\n```", "```py\npublic virtual double MaxFitness => double.MaxValue;\n```", "```py\npublic abstract double MinFitness\n```", "```py\n\npublic virtual double AcceptableFitness => MinFitness;\n```", "```py\npublic abstract int Dimensionality\n```", "```py\npublic virtual bool HasGradient => false;\n```", "```py\npublic virtual double Fitness(double[] parameters)\n{\nreturn Fitness(parameters, true);\n}\n```", "```py\npublic virtual double Fitness(double[] parameters, double fitnessLimit){\nreturn Fitness(parameters);\n}\n```", "```py\npublic virtual double Fitness(double[] parameters, double fitnessLimit, bool oldFeasible, bool newFeasible)\n{\nreturn Tools.BetterFeasible(oldFeasible, newFeasible)? Fitness(parameters, fitnessLimit) : Fitness(parameters);\n}\n```", "```py\npublic virtual double Fitness(double[] parameters, bool feasible)\n{\nreturn Fitness(parameters, MaxFitness, feasible, feasible);\n}\n```", "```py\npublic virtual int Gradient(double[] x, ref double[] v)\n{\nthrow new NotImplementedException();\n}\n```", "```py\npublic virtual bool EnforceConstraints(ref double[] parameters)\n{\n```", "```py\nTools.Bound(ref parameters, LowerBound, UpperBound);\n```", "```py\nreturn Feasible(parameters);\n}\n```", "```py\npublic virtual bool Feasible(double[] parameters)\n{\nreturn Tools.BetweenBounds(parameters, LowerBound, UpperBound);\n}\n```", "```py\npublic virtual void BeginOptimizationRun()\n```", "```py\npublic virtual void EndOptimizationRun()\n```", "```py\npublic virtual bool Continue(int iterations, double fitness, bool feasible)\n{\nreturn (iterations < MaxIterations &&!(fitness <= AcceptableFitness && (!RequireFeasible || feasible)));\n}\n}\n```", "```py\n<summary>\na ~ 1.5937\nb ~ 2.5416\n </summary>\nClass CustomProblem :Problem\n{\npublic double GetA(double[] parameters)\n{\nreturn parameters[0];\n}\npublic double GetB(double[] parameters)\n{\nreturn parameters[1];\n}\n```", "```py\npublic override string Name => \"CustomProblem\";\n```", "```py\npublic override int Dimensionality => 2;\ndouble[] _lowerBound = { -100, -100 };\n```", "```py\npublic override double[] LowerBound => _lowerBound;\ndouble[] _upperBound = { 100, 100 };\n```", "```py\npublic override double[] UpperBound => _upperBound;\n```", "```py\npublic override double[] LowerInit => LowerBound;\n```", "```py\npublic override double[] UpperInit => UpperBound;\n```", "```py\npublic override double MinFitness => 0;\n```", "```py\npublic override double AcceptableFitness => 0.4;\nstring[] _parameterName = { \"a\", \"b\" };\n```", "```py\npublic override string[] ParameterName => _parameterName;\n```", "```py\npublic override double Fitness(double[] x)\n{\nDebug.Assert(x != null && x.Length == Dimensionality);\ndouble a = GetA(x);\ndouble b = GetB(x);\ndouble t1 = 1 - a;\ndouble t2 = b - a * a;\nreturn t1 * t1 + 100 * t2 * t2;\n}\n```", "```py\npublic override bool EnforceConstraints(ref double[] x)\n{\n// Enforce boundaries.\nSwarmOps.Tools.Bound(ref x, LowerBound, UpperBound);\nreturn Feasible(x);\n}\n// Evaluate constraints.\npublic override bool Feasible(double[] x)\n{\nDebug.Assert(x != null && x.Length == Dimensionality);\ndouble a = GetA(x);\ndouble b = GetB(x);\n// Radius.\ndouble r = Math.Sqrt(a * a + b * b);\nreturn ((r < 0.7) || ((r > 3) && (r < 5))) && (a < b * b);\n}\n}\n}\n```", "```py\nstatic Problem Problem = new CustomProblem();\n```", "```py\nstatic readonly int NumRuns = 50;\nstatic readonly int DimFactor = 4000;\nstatic readonly int Dim = Problem.Dimensionality;\nstatic readonly int NumIterations = DimFactor * Dim;\n```", "```py\nstatic Optimizer Optimizer = new DE(Problem);\n```", "```py\nstatic readonly double[] Parameters = Optimizer.DefaultParameters;\n```", "```py\nstatic readonly bool StatisticsOnlyFeasible = true;\nstatic Statistics Statistics = new Statistics(Optimizer, StatisticsOnlyFeasible); \n```", "```py\nstatic Repeat Repeat = new RepeatSum(Statistics, NumRuns);\nstatic void Main(string[] args)\n{\n```", "```py\nGlobals.Random = new RandomOps.MersenneTwister();\n```", "```py\nProblem.MaxIterations = NumIterations;\n```", "```py\nint NumMeanIntervals = 3000;\nFitnessTrace fitnessTrace = new FitnessTraceMean(NumIterations, NumMeanIntervals);\nFeasibleTrace feasibleTrace = new FeasibleTrace(NumIterations, NumMeanIntervals, fitnessTrace);\n```", "```py\nOptimizer.FitnessTrace = feasibleTrace;\n```", "```py\ndouble fitness = Repeat.Fitness(Parameters);\nif (Statistics.FeasibleFraction > 0)\n{\n```", "```py\nStatistics.Compute();\n```", "```py\nConsole.WriteLine(\"Best feasible solution found:\", Color.Yellow);\nTools.PrintParameters(Problem, Statistics.BestParameters);\nConsole.WriteLine();\nConsole.WriteLine(\"Result Statistics:\", Color.Yellow);\nConsole.WriteLine(\"\\tFeasible: \\t{0} of solutions found.\", Tools.FormatPercent(Statistics.FeasibleFraction), Color.Yellow);\nConsole.WriteLine(\"\\tBest Fitness: \\t{0}\", Tools.FormatNumber(Statistics.FitnessMin), Color.Yellow);\nConsole.WriteLine(\"\\tWorst: \\t\\t{0}\", Tools.FormatNumber(Statistics.FitnessMax), Color.Yellow);\nConsole.WriteLine(\"\\tMean: \\t\\t{0}\", Tools.FormatNumber(Statistics.FitnessMean), Color.Yellow);\nConsole.WriteLine(\"\\tStd.Dev.: \\t{0}\", Tools.FormatNumber(Statistics.FitnessStdDev), Color.Yellow);\nConsole.WriteLine();\nConsole.WriteLine(\"Iterations used per run:\", Color.Yellow);\nConsole.WriteLine(\"\\tMean: {0}\", Tools.FormatNumber(Statistics.IterationsMean), Color.Yellow);\n}\nelse\n{\nConsole.WriteLine(\"No feasible solutions found.\", Color.Red);\n}\n}\n```"]