- en: Advanced Pathfinding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级路径查找
- en: In this chapter, we will take a look at the advanced pathfinding methods that
    can be used in a wide range of games. The main objective of this chapter is to
    learn the foundations of how to create an advanced AI element that can analyze
    the map and process all the necessary information in order to decide the best
    path that needs to be taken. Advanced pathfinding methods can be found in many
    popular game titles that require the AI character to choose the best path in real
    time, and we will analyze some of the most famous examples and how can we replicate
    the same results.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可用于各种游戏的先进路径查找方法。本章的主要目标是学习如何创建一个能够分析地图并处理所有必要信息以决定最佳路径的先进AI元素的基础。在许多流行的游戏标题中，高级路径查找方法被用于使AI角色能够在实时中选择最佳路径，我们将分析一些最著名的例子以及我们如何复制相同的结果。
- en: Simple versus advanced pathfinding
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单与高级路径查找
- en: As we discovered in the previous chapter, pathfinding is used by AI characters
    to discover the direction that they need to move and how to do it correctly. Depending
    on the game that we are working on, we could use a simple pathfinding system or
    a complex one. Both can be very useful. There are situations where a simple pathfinding
    system is enough to accomplish the task that we are looking for, but in other
    cases we need a different alternative to the methods that we have covered before
    in order to achieve the complexity and realism that is necessary for our AI character.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中发现的，路径查找被AI角色用来发现它们需要移动的方向以及如何正确地移动。根据我们正在开发的游戏，我们可以使用简单的路径查找系统或复杂的路径查找系统。两者都可以非常有用。在某些情况下，简单的路径查找系统足以完成我们寻找的任务，但在其他情况下，我们需要一种不同于我们之前介绍的方法的替代方案，以便实现我们AI角色所需的复杂性和真实性。
- en: Before talking about any advanced system of creating a pathfinding method, let's
    discover why we need to use it and in what circumstances it is necessary to update
    our character and make it more intelligent and aware. Using our previous examples,
    we will be looking at the limitations that exist for a normal pathfinding method.
    Understanding the limitations of a simple pathfinding system will help us acknowledge
    what is missing and what challenges we will face when we are about to create a
    more complex system. So it is a good start to first learn how we can set up a
    simple pathfinding system and then we can move on to a more complex one. Because
    games have evolved at the same rate as the technology available to create them,
    our first example will be an older game, and then we'll see how the same game
    has evolved, in particular AI pathfinding.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论任何高级路径查找方法的系统之前，让我们先了解为什么我们需要使用它，以及在什么情况下需要更新我们的角色，使其更加智能和警觉。通过使用我们之前的例子，我们将探讨一个普通路径查找方法存在的局限性。了解简单路径查找系统的局限性将帮助我们认识到我们即将创建更复杂系统时所缺少的内容和面临的挑战。因此，首先学习我们如何设置一个简单的路径查找系统是一个很好的开始，然后我们可以继续研究更复杂的一个。由于游戏的发展速度与创造它们的技术的进步速度相同，我们的第一个例子将是一个较老的游戏，然后我们将看到这个游戏是如何演变的，特别是人工智能路径查找。
- en: Open world maps are now very common, and many games from different genres use
    this to create a rich experience, but it wasn't always like this. Let's take the
    first **Grand Theft Auto** (**GTA**) game as an example. Analyzing the pattern
    of the cars that are driving on the map, we can see that they don't have a complex
    system, and the drivers are stuck to the predefined route or lap that each of
    them is assigned to follow. Obviously, this AI pathfinding system was very advanced
    at that time and even if we play it today, we don't feel discouraged by the AI
    characters because it works wonderfully for that game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开放世界地图现在非常普遍，许多不同类型的游戏都使用它来创造丰富的体验，但并非总是如此。让我们以第一代**侠盗猎车手**（**GTA**）游戏为例。分析地图上行驶的汽车的模式，我们可以看到它们没有复杂的系统，驾驶员们被困在各自被分配的预定义路线或圈中。显然，在那个时代，这个AI路径查找系统非常先进，即使我们今天玩它，我们也不会因为AI角色而感到沮丧，因为它为那个游戏工作得非常好。
- en: The AI drivers follow their path and stop every time the player is in their
    way. This demonstrates that they have a collision detector in front of each car
    to tell them if there is something blocking the path. If there is something in
    front of the car, the driver stops immediately, and until the path is unblocked,
    it won't drive again. This is a sign that the drivers have some sort of pathfinding
    system that couldn't solve different situations where it was not possible for
    them to keep driving in the same direction. For that reason and to avoid any errors
    or glitches in the game, the programmers have chosen to make the drivers stop
    when that happens.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: AI驾驶员遵循他们的路径，每当玩家挡在他们面前时都会停下来。这表明他们每辆车前都有一个碰撞检测器，告诉他们是否有东西阻挡了路径。如果车前有东西，驾驶员会立即停车，直到路径畅通，他们才会再次驾驶。这是驾驶员拥有某种寻路系统的迹象，该系统无法解决他们无法继续以同一方向行驶的不同情况。因此，为了避免游戏中出现任何错误或漏洞，程序员选择让驾驶员在这种情况下停车。
- en: '![](img/d96ded83-37cb-4284-8fa1-2309735da118.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d96ded83-37cb-4284-8fa1-2309735da118.jpg)'
- en: The preceding case scenario, where the drivers stop when it's not possible for
    them to keep moving forward, became one of the biggest strengths in their future
    games. Many things have evolved in the GTA games, and the AI is definitely one
    of them. They have refined the AI drivers, making them aware of the situation
    and their surroundings. Let's analyze *GTA San Andreas,* which is also available
    to play on mobile phones. In this game, if we stop our car in front of the AI
    driver, the results are completely different. Depending on the personality of
    the AI driver, it will react differently; for example, some of them will simply
    honk the horn and wait a little bit, and if the player keeps blocking their way,
    the driver will outrun the player. Others might react more aggressively, getting
    out of the car to confront the player physically.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的案例场景，即驾驶员在无法继续前进时停车，成为他们未来游戏中最大的优势之一。在GTA游戏中，许多事物都发生了演变，AI无疑是其中之一。他们已经改进了AI驾驶员，使他们意识到情况及其周围环境。让我们分析一下*GTA
    San Andreas*，这款游戏也适用于手机。在这款游戏中，如果我们把车停在AI驾驶员面前，结果会完全不同。根据AI驾驶员的性格，他们的反应会有所不同；例如，其中一些驾驶员可能会简单地按喇叭并稍作等待，如果玩家继续阻挡他们的道路，驾驶员会超过玩家。其他人可能会更加激进，下车与玩家进行身体对抗。
- en: If the AI driver notices that the environment is getting dangerous by hearing
    shots, they speed up and choose the fastest path to get out of that situation.
    This type of behavior demonstrates that the AI characters have a more complex
    and refined pathfinding system in conjunction with a possibility map, where the
    surrounding situation will reflect which path they end up choosing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AI驾驶员通过听到枪声意识到环境变得危险，他们会加速并选择最快的路径逃离该情况。这种行为表明，AI角色在结合可能性地图的情况下，拥有更复杂和精细的寻路系统，周围的环境将反映他们最终选择的路径。
- en: '![](img/29e6ca7d-c2bb-45dc-aaad-a200b6e6cd79.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29e6ca7d-c2bb-45dc-aaad-a200b6e6cd79.jpg)'
- en: As we can see, the drivers now have a presence that's much more noticeable than
    in the first game. In the previous chapter, we studied how to create a simple
    pathfinding system, very similar to what we analyzed in the first GTA game. Now,
    we'll look in depth at how to create an AI character that can get away from any
    unexpected situation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，现在的驾驶员在游戏中的存在感比第一代游戏要明显得多。在前一章中，我们学习了如何创建一个简单的寻路系统，这与我们在第一代GTA游戏中分析的系统非常相似。现在，我们将深入探讨如何创建一个能够应对任何突发情况的AI角色。
- en: This is one of those things that still isn't perfect, and many developers are
    trying new ways of creating AI characters that can behave almost like a human
    person would if trapped in the same situation. Some companies are getting close
    to that--one big example is Rockstar Games with their GTA franchise, and for that
    reason we have chosen to start with their example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一些尚未完美解决的问题之一，许多开发者正在尝试新的方法来创建能够像被困在相同情况下的真人一样行为的AI角色。一些公司已经接近这一目标——一个很好的例子是Rockstar
    Games及其GTA系列，因此我们选择从他们的例子开始。
- en: A* search algorithm
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A*搜索算法
- en: Unpredictable situations usually lead to a large amount of hours coding the
    extensive possibilities that the characters have. For this reason, it was necessary
    to think on a new way to create a better pathfinding system, where the characters
    could analyze the surroundings for themselves in real time and choose the best
    path to take. One method that has become very popular for this effect is using
    **theta algorithms**, which allows the characters to constantly search for the
    best path without it being necessary to manually set which points they need to
    follow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不可预测的情况通常会导致大量时间用于编写角色可能性的广泛可能性。因此，有必要考虑一种新的方法来创建更好的寻路系统，其中角色可以自己实时分析周围环境并选择最佳路径。为此效果而变得非常流行的一种方法是使用**theta算法**，它允许角色不断搜索最佳路径，而无需手动设置它们需要遵循的点。
- en: The Theta search algorithm (A*) is a widely used search algorithm that can be
    used to find solutions for many problems and pathfinding is one of them. Using
    this algorithm to solve pathfinding problems is very common due to the uniform-cost
    search and heuristic search. The Theta search algorithm examines every corner
    of the map to help the character determine if it is possible to use that location
    or not, while trying to reach the desired destination.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Theta搜索算法（A*）是一种广泛使用的搜索算法，可用于解决许多问题，寻路就是其中之一。使用此算法解决寻路问题非常常见，因为它结合了均匀成本搜索和启发式搜索。Theta搜索算法检查地图的每个角落，以帮助角色确定是否可以使用该位置，同时试图达到目标地点。
- en: How it works
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The map or scene of the game needs to be prepared or pre-analyzed before the
    theta algorithm can work. The environment that includes all the assets of the
    map will be handled as a graph. This means that the map will be broken into different
    points and locations, which are called nodes. These nodes are used to record all
    the progress of the search. While memorizing the map location, each individual
    node has other attributes, such as fitness, goal, and heuristic, usually represented
    by the letters f, g, and h. The purpose of the fitness, goal, and heuristic attributes
    is to put in order how good a path is according to the current node.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在theta算法可以工作之前，游戏地图或场景需要准备或预先分析。包括地图所有资产的环境将被处理为一个图。这意味着地图将被分割成不同的点和位置，这些被称为节点。这些节点用于记录搜索的所有进度。在记住地图位置的同时，每个单独的节点都有其他属性，如适应性、目标和启发式，通常用字母f、g和h表示。适应性、目标和启发式属性的目的在于根据当前节点对路径的优劣进行排序。
- en: Different values are assigned to the paths between the nodes. These values usually
    represent the distances between the nodes. The value between the nodes doesn't
    necessarily have to be distance. The value can also be time; this will help us
    find the fastest path instead of the shortest one, for example. The Theta algorithm
    uses two lists, an open list and a closed list. The open list contains the nodes
    that were totally explored. Marker arrays can also be used to find out whether
    a state is in the open list or the closed list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间的路径被分配不同的值。这些值通常表示节点之间的距离。节点之间的值不一定是距离。它也可以是时间；这有助于我们找到最快的路径而不是最短的路径，例如。Theta算法使用两个列表，一个开放列表和一个关闭列表。开放列表包含已完全探索的节点。标记数组也可以用来确定某个状态是否在开放列表或关闭列表中。
- en: '![](img/7325c113-ad29-4aec-95ac-4dc68ba988a5.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7325c113-ad29-4aec-95ac-4dc68ba988a5.jpg)'
- en: This means that the character will constantly be searching for the best nodes
    to follow in order to achieve the fastest or shortest results. As we can see in
    the preceding screenshot, the map was pre-analyzed, the walkable area is represented
    by the small gray squares, while the big squares represent the area that is blocked
    by some object or environment asset. The AI character represented by the black
    and white circle needs to move node by node until it reaches the star object.
    If for some reason one of the nodes is blocked, the character will rapidly switch
    to the closest one and then continue on its way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着角色将不断搜索最佳节点以实现最快或最短的结果。正如我们在前面的截图中所见，地图已经预先分析过，可通行区域由小灰色方块表示，而大方块则代表被某些物体或环境资产阻挡的区域。由黑白圆圈表示的AI角色需要逐节点移动，直到到达星形物体。如果某个节点因某种原因被阻挡，角色将迅速切换到最近的节点，然后继续前进。
- en: As we can see, this pathfinding method's theory is very similar to what we have
    created before, where the character follows point by point until it arrives at
    the final destination. The main difference is that with the Theta algorithm, the
    points are generated automatically by the AI, making it the best choice when developing
    big or complex scenes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这种路径查找方法的原理与我们之前创建的非常相似，其中角色逐点跟随直到到达最终目的地。主要区别在于，使用Theta算法时，点是由AI自动生成的，这使得它成为开发大型或复杂场景时的最佳选择。
- en: Disadvantages of using A*
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用A*的缺点
- en: The Theta algorithm is not the perfect solution that can be used everywhere
    or in every game, and we should keep that thought in mind. Because the AI character
    is constantly searching for the best path to follow, a significant portion of
    the CPU is being used exclusively for that task. Because tablets and mobile devices
    are very popular gaming platforms nowadays, it is worth mentioning that developing
    a game for these platforms requires paying special attention to the CPU and GPU
    usage, and for that reason, A* pathfinding can be a disadvantage here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Theta算法并不是一个可以在任何地方或任何游戏中使用的完美解决方案，我们应该牢记这一点。因为AI角色一直在寻找最佳路径，所以CPU的大量资源被专门用于这项任务。鉴于平板电脑和移动设备现在是流行的游戏平台，值得提到的是，为这些平台开发游戏需要特别注意CPU和GPU的使用，因此，A*路径查找在这里可能是一个缺点。
- en: But hardware limitation isn't the only disadvantage. When we let the AI assume
    all the work without any human control, bugs are highly likely. That is one reason
    why modern games that prefer using open world maps encounter a lot of bugs and
    weird AI reactions, because it is extremely difficult to narrow down all the possible
    outcomes in a massive gameplay area.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但硬件限制并不是唯一的缺点。当我们让AI承担所有工作而不进行任何人工控制时，bug出现的可能性非常高。这也是为什么现代游戏更喜欢使用开放世界地图并遇到很多bug和奇怪的AI反应的原因之一，因为在庞大的游戏区域中很难缩小所有可能的结果。
- en: '" says bugs in the latest demo are natural for open world games"'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"在最新的演示中，开放世界游戏中的bug是自然的"'
- en: Final Fantasy XV director
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终幻想XV导演
- en: '![](img/d0b85096-b48d-4dea-9e47-44c982765b97.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0b85096-b48d-4dea-9e47-44c982765b97.jpg)'
- en: The director of Final Fantasy XV commented about this issue, stating that bugs
    are expected in every open world game. This summarizes perfectly why using theta
    algorithms for AI pathfinding is a popular and efficient approach when developing
    open world games, but it is not perfect and bugs will definitely occur.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最终幻想XV的导演对此问题进行了评论，表示在每一个开放世界游戏中都会出现bug。这完美地总结了为什么在开发开放世界游戏时使用theta算法进行AI路径查找是一个流行且有效的方法，但它并不完美，bug肯定会发生。
- en: Now that we have a basic understanding of the theta algorithm and the pros and
    cons of it, let's move on to the practical section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对theta算法及其优缺点有了基本的了解，让我们继续到实际部分。
- en: Going directly from A to B
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接从A到B
- en: We are going to start with a simple example, without any obstacles between one
    point and another. This will help us visualize how the algorithm finds the best
    path. Then we will be adding an obstacle and observing how the algorithm chooses
    the best path when contouring the obstacle at the same time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常简单的例子开始，一个点与另一个点之间没有任何障碍。这将帮助我们可视化算法如何找到最佳路径。然后我们将添加一个障碍物，并观察算法在同时绕过障碍物时如何选择最佳路径。
- en: '![](img/aad6a824-7609-45fa-8528-7fb8d1fcd22a.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aad6a824-7609-45fa-8528-7fb8d1fcd22a.jpg)'
- en: On this grid we have two points, **A** that is the starting point and **B**
    that is the end point. We want to find the shortest path between the two. To help
    us solve this problem, we will be using the A* algorithm and we'll see how it
    manages to find the shortest path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网格上，我们有两个点，**A** 是起点，**B** 是终点。我们想要找到这两个点之间的最短路径。为了帮助我们解决这个问题，我们将使用 A* 算法，并看看它是如何找到最短路径的。
- en: '![](img/93ce4d0d-9c3a-4b13-9bac-daf1e24f2006.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93ce4d0d-9c3a-4b13-9bac-daf1e24f2006.jpg)'
- en: So, the algorithm calculates every step to find the shortest one. To calculate
    this, the algorithm uses two nodes, as we discovered before, the G node and the
    H node. G represents the distance from the starting point, so it calculates how
    far it is from the **A** position. H represents the distance from the end point,
    so it calculates how far it is from the **B** position. If we sum both nodes (*G
    + H = F*), we get the F node value, which represents the shortest path.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，算法计算每一步以找到最短路径。为了计算这个，算法使用了之前发现的两个节点，G节点和H节点。G代表从起点到距离，因此它计算从**A**位置有多远。H代表从终点到距离，因此它计算从**B**位置有多远。如果我们把两个节点相加（*G
    + H = F*），我们得到F节点值，它代表最短路径。
- en: In this case, the shortest number is **42**, so we can move to that position
    and calculate again every available hypothesis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最短数字是**42**，因此我们可以移动到那个位置并再次计算所有可用的假设。
- en: '![](img/e7dbd57e-5e87-4f6b-9fa2-353608b3c063.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7dbd57e-5e87-4f6b-9fa2-353608b3c063.jpg)'
- en: Once again, the algorithm calculates the best options that are available from
    the position that we are in. We are getting close to B, and for that reason the
    values for the H nodes are getting smaller while the values for the G nodes are
    getting bigger, and that is perfectly fine. From all the possibilities that we
    currently have, the number **42** is once again the lowest number and the best
    option to take. So the natural decision is to move towards that position.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，算法计算从我们所在位置可用的最佳选项。我们接近B点，因此H节点的值正在变小，而G节点的值正在变大，这是完全正常的。在所有当前的可能性中，数字**42**再次是最低的，是最好的选择。所以自然的决定是朝着那个位置移动。
- en: '![](img/d07cdf49-4103-415c-83e7-41ef34ddff18.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d07cdf49-4103-415c-83e7-41ef34ddff18.jpg)'
- en: And finally, we have arrived at the **B** point. Once the algorithm finds that
    the H node value is zero, that means that it has already arrived at the desired
    destination and there's no need to keep searching for a better path.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了**B**点。一旦算法发现H节点值为零，这意味着它已经到达了目标位置，没有必要继续寻找更好的路径。
- en: From point A to B with obstacles in the way
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从点A到B，途中存在障碍物
- en: This is exactly how the A* pathfinding works; it goes from point to point evaluating
    the best options and pursuing the shortest path until it reaches the final destination.
    The earlier example was simple, and now we are going to make it more interesting
    to see how it works if we add obstacles to the map.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是A*路径查找的工作方式；它从一个点到另一个点评估最佳选项，追求最短路径，直到达到最终目的地。之前的例子很简单，现在我们将使其更有趣，看看如果我们在地图上添加障碍物会发生什么。
- en: '![](img/62751395-95a1-49b1-831a-868731b8a83d.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62751395-95a1-49b1-831a-868731b8a83d.jpg)'
- en: 'Using the same map, we have painted some squares in black, representing that
    those positions can''t be used. Now, it starts getting slightly more interesting,
    because if we try to guess what the best path to take would be, we might be wrong.
    Once again, let''s calculate what the best options are, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的地图，我们用黑色画了一些方格，表示这些位置不能使用。现在，这开始变得稍微有点意思，因为我们尝试猜测最佳路径时可能会出错。再次，让我们计算最佳选项如下：
- en: '![](img/2adcc2c2-b7bc-482a-a9f4-24de3f92f740.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2adcc2c2-b7bc-482a-a9f4-24de3f92f740.jpg)'
- en: The results that we get are exactly the same as the first test and this is normal,
    because none of the points that are surrounding the **A** position are positioned
    on the black squares. Once again, we can move towards the lowest number that is
    **42**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果与第一次测试完全相同，这是正常的，因为围绕**A**位置的所有点都没有位于黑格上。再次，我们可以朝着最低的数字**42**前进。
- en: '![](img/80c93264-b146-4336-a0e4-99b0b97c13b5.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80c93264-b146-4336-a0e4-99b0b97c13b5.jpg)'
- en: Now that we have made our first move and calculated the best options that are
    available from that point, we are in an interesting situation. At this moment,
    we have the three lowest numbers and we have to choose one. We need to find the
    shortest path that leads us to the **B** position and because the three lowest
    numbers are the same, we need to make the decision according to the H node only,
    which represents the distance between our current position and the B position.
    Two of the positions have the H value of **38** while just one of them has the
    value of **24**, making it the lowest H value of the three. So let's move on in
    that direction, which seems to be closer to the final destination.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做出了第一步，并计算了从那个点可以采取的最佳选项，我们处于一个有趣的情况。在这个时候，我们有三个最低的数字，我们必须选择一个。我们需要找到通往**B**位置的最短路径，因为三个最低的数字相同，我们需要根据H节点来做出决定，它代表我们当前位置和**B**位置之间的距离。两个位置有**38**的H值，而只有一个位置的值为**24**，这使得它成为三个中最低的H值。所以让我们朝那个方向前进，这似乎更接近最终目的地。
- en: '![](img/7a7b201a-6932-4130-b195-4c98124c81ef.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a7b201a-6932-4130-b195-4c98124c81ef.jpg)'
- en: From now on we can notice that the F values are getting higher, which represents
    the shortest path value. This is due to the black squares that we have added to
    the map. Because of them, we need to go around, increasing the length of the path
    that we need to take. This is how the AI will perceive the walls; they know for
    a fact that the final destination is close, but in order to arrive there, they
    can't pass through the wall, so they need to go around until they find an open
    door or something similar.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们可以注意到F值正在增加，这代表最短路径值。这是由于我们在地图上添加的黑方块。因为它们，我们需要绕行，增加我们需要采取的路径长度。这就是AI将感知墙壁的方式；他们知道最终目的地很近，但为了到达那里，他们不能穿过墙壁，所以他们需要绕行，直到找到一扇开放的门或类似的东西。
- en: Now, the lowest values are in the other direction, which means that we need
    to go back in order to find a better path. This is a very important aspect of
    the algorithm, because if we have the character walking around searching for the
    best path at the same time that it is walking, we will have a more human-like
    result. It will look like that he is searching for the correct path to arrive
    at the desired destination, like a person would if they didn't know the right
    path. On the other hand, the character can be programmed to make all the calculations
    before it starts moving, and in that case we would see a character going directly
    to the right path until it reaches the final point. Both methods are valid and
    can be used for different purposes and different games.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最低的值在另一个方向，这意味着我们需要返回以找到更好的路径。这是算法中的一个非常重要的方面，因为如果我们让角色在行走的同时搜索最佳路径，我们将得到更接近人类的结果。它看起来就像他在寻找正确的路径以达到目标地点，就像一个人不知道正确路径时一样。另一方面，角色可以被编程在开始移动之前完成所有计算，在这种情况下，我们会看到一个角色直接走向正确的路径，直到到达终点。这两种方法都是有效的，可以根据不同的目的和不同的游戏来使用。
- en: Continuing our pathfinding, we need to keep choosing the lowest value, so at
    this point we need to go back and choose between the two lowest values, **48**.
    Both have the same G and H values, so the only way to find out which is the best
    path to take is to randomly choose one of the points or pre-calculate them to
    see which of them will have the lowest value. So let's choose one randomly to
    see the values that come up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的寻路过程中，我们需要持续选择最小值，因此在这个点上，我们需要返回并在这两个最小值之间进行选择，**48**。它们都有相同的G和H值，所以找出最佳路径的唯一方法就是随机选择其中一个点，或者预先计算它们，看看哪一个会有最低的值。所以让我们随机选择一个点，看看会出现哪些值。
- en: '![](img/11b3a167-57a4-4c63-a903-1996d152010c.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11b3a167-57a4-4c63-a903-1996d152010c.jpg)'
- en: After choosing one of the two shortest possibilities, we found that the values
    are getting higher, and for that reason we need to go back and calculate the other
    value as well to see if there is a lower value after that. Because we can already
    see the map and we already know where the **B** point is placed, we know for a
    fact that the lowest value is actually further away than the **68** value that
    appeared just now. But if we didn't know where the B point was, we still needed
    to check that **48** value, to see if the destination point was near that position
    or not. That is what the AI character will decide in the gameplay it will constantly
    check the lowest F value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了两种最短可能性之一后，我们发现数值正在增加，因此我们需要回过头来计算另一个值，看看在那之后是否还有更低的数值。因为我们已经可以看到地图，并且已经知道**B**点的位置，所以我们确信最低的数值实际上比刚才出现的**68**数值还要远。但如果我们不知道B点的位置，我们仍然需要检查那个**48**数值，看看目标点是否接近那个位置。这就是AI角色在游戏过程中会不断检查最低F值的原因。
- en: '![](img/343ff24c-7d89-4093-a9f6-d08258520075.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/343ff24c-7d89-4093-a9f6-d08258520075.jpg)'
- en: After choosing the new position, we can see that it didn't provide any better
    opportunities, and we need to keep searching for a better path, which in this
    case is going to be a point that we have already discovered, but whose outcomes
    we didn't calculate. Once again, we have the two lowest F values and we will be
    choosing the lowest H value, that is, **20**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了新的位置之后，我们可以看到它并没有提供任何更好的机会，我们需要继续寻找更好的路径，在这种情况下，将是我们已经发现但尚未计算结果的点。再一次，我们有两个最低的F值，我们将选择最低的H值，即**20**。
- en: '![](img/87f40b8b-3f80-416d-9b77-8445089ec64b.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87f40b8b-3f80-416d-9b77-8445089ec64b.jpg)'
- en: After calculating the new possibilities, we notice that we need to choose **54**
    again to see if the final destination is closer to that point. This is exactly
    the process that will occur when we program the AI to find the shortest path that
    it will need to take in order to arrive at the final destination. The calculations
    need to be solved in real time, and as will start to notice, they can get very
    complex. This is why it consumes a significant portion of the CPU power, because
    it is the hardware component designated to this function (calculus).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算新的可能性之后，我们注意到我们需要再次选择**54**，看看最终目的地是否更接近那个点。这正是当我们编程AI寻找到达最终目的地的最短路径时会发生的过程。计算需要在实时完成，并且正如我们开始注意到的那样，它们可以变得非常复杂。这就是为什么它消耗了大量的CPU功率，因为它是由硬件组件指定的这个功能（计算）。
- en: Now, we will be selecting the number **54**, because it is the lowest number
    on the map.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将选择数字**54**，因为它是地图上最低的数字。
- en: '![](img/68864176-58de-44d5-8aab-249035f9b385.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68864176-58de-44d5-8aab-249035f9b385.jpg)'
- en: If we keep moving down, the values will get higher, which means that we are
    getting farther away from where we need to be. If we were the AI and didn't know
    that the final destination is at the top, we would need to check the number **60**,
    because it is the most promising of them all at the moment. So, let's calculate
    the outcomes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续向下移动，数值将会增加，这意味着我们正在远离我们需要到达的地方。如果我们是AI并且不知道最终目的地在顶部，我们就需要检查**60**这个数字，因为它在目前是最有希望的。所以，让我们计算结果。
- en: '![](img/4e973133-d4ea-46da-97f0-807b6cd896b3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e973133-d4ea-46da-97f0-807b6cd896b3.jpg)'
- en: Now, we can see that there are a lot of identical lowest numbers, which are
    **62**, so we need to explore them all and keep calculating until the character
    finds the right path. For the purposes of the example we will be moving to every
    lowest number that we can see on the map now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到有很多相同的最低数值，它们是**62**，所以我们需要探索它们所有，并继续计算，直到角色找到正确的路径。为了举例，我们将移动到地图上现在可以看到的所有最低数值。
- en: '![](img/f08211d8-9543-4434-b006-274a738a8f16.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f08211d8-9543-4434-b006-274a738a8f16.jpg)'
- en: After exploring all the lowest possibilities, we can see that we are getting
    closer to the final destination. At this point, the lowest value available is
    **68**, and after that it will be easy to reach the final point.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了所有最低的可能性之后，我们可以看到我们正在接近最终目的地。在这个时候，可用的最低值是**68**，在那之后到达最终点将变得容易。
- en: '![](img/cd6307c8-185a-43a2-a0a6-43bd9afe0a10.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd6307c8-185a-43a2-a0a6-43bd9afe0a10.jpg)'
- en: Finally, we have arrived at the point **B** destination. This is the visual
    aspect of A* algorithm, where the darker gray area represents the positions that
    the computer has visited and the lighter gray area represents the outcome calculations
    of those areas that we visited.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了点**B**目的地。这是A*算法的视觉方面，其中较深的灰色区域表示计算机已访问的位置，较浅的灰色区域表示我们已访问的区域的结果计算。
- en: The computer can calculate the best path in real time, or the developers can
    also choose to let the AI calculate the best options before exporting the game.
    So the AI will automatically know which path it needs to follow when the game
    starts, saving some CPU power.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以实时计算最佳路径，或者开发者也可以选择在导出游戏之前让AI计算最佳选项。这样，AI将自动知道游戏开始时需要遵循的路径，从而节省一些CPU功率。
- en: 'To explain how this works in the programming language, we will be using pseudo
    code to demonstrate this example. This way we can understand from start to finish
    how we can create the search method in any programming language and how we can
    adapt it ourselves:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释如何在编程语言中实现这一点，我们将使用伪代码来演示这个示例。这样我们可以从头到尾理解我们如何在任何编程语言中创建搜索方法，以及我们如何自己适应它：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s analyze each line of code that we used to create the example. We have
    divided the grid map into two different categories: `OPEN` and `CLOSED`. The `OPEN`
    ones are the squares that we have already explored, represented on the image by
    the dark gray blocks. While the `CLOSED` are the white blocks that we didn''t
    explore yet. This will allow the AI to distinguish between the explored and not
    explored blocks, going from point to point finding the best path:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下我们用来创建示例的每一行代码。我们将网格地图分为两个不同的类别：`OPEN`和`CLOSED`。`OPEN`的是我们已经探索的方块，在图像上由深灰色块表示。而`CLOSED`的是我们尚未探索的白色块。这将允许AI区分已探索和未探索的方块，从一点到另一点寻找最佳路径：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we assigned the first block that is considered `OPEN`; this will set the
    starting point and it will automatically start calculating the best options from
    that position:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分配了第一个被认为是`OPEN`的方块；这将设置起点，并会自动从这个位置开始计算最佳选项：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, we need to create a loop, and inside our loop we have a temporary
    variable called `current`; this is equal to the node in the `OPEN` list that has
    the lowest F cost. Then it will be removed from the `OPEN` list and added to the
    `CLOSED` list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要创建一个循环，并在循环内部有一个名为`current`的临时变量；这等于`OPEN`列表中具有最低F成本的节点。然后它将从`OPEN`列表中移除并添加到`CLOSED`列表中：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, if the current node is the target node, the code assumes that the final
    destination has been explored and we can just exit out of the loop:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果当前节点是目标节点，代码假设最终目的地已被探索，我们可以直接退出循环：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Otherwise, we must go through each of the `neighbor` nodes of the current node.
    If it is not traversable, meaning that we cannot pass that position or if it was
    previously explored and is on the `CLOSED` list, the code can skip to the next
    neighbor. This part sets where it is possible to move and also tells the AI to
    not take into consideration positions that were previously explored:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们必须遍历当前节点的每个`neighbor`节点。如果它不可遍历，意味着我们无法通过该位置，或者如果它之前已被探索并且位于`CLOSED`列表中，代码可以跳到下一个邻居。这部分设置了可以移动的位置，并告诉AI不要考虑之前已探索的位置：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If it is not the case, then we can move on and check a couple of things. If
    the new path to the `neighbor` is shorter than the old path or if the `neighbor`
    is not on the `OPEN` list, then we set the `f_cost` of the `neighbor` by calculating
    the `g_cost` and the `h_cost`. We see the new possible blocks have children from
    the current block, so we can trace the steps that are being taken. And finally,
    if the `neighbor` is not on the `OPEN` list, we can add it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是这种情况，那么我们可以继续前进并检查一些事情。如果新路径到`neighbor`比旧路径短，或者如果`neighbor`不在`OPEN`列表中，那么我们就通过计算`g_cost`和`h_cost`来设置`neighbor`的`f_cost`。我们看到新的可能方块有来自当前方块的孩子，因此我们可以追踪正在采取的步骤。最后，如果`neighbor`不在`OPEN`列表中，我们可以将其添加进去。
- en: Looping this, the code will constantly be searching for the best options and
    moving towards the closest values until it arrives at the target node value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式循环，代码将不断寻找最佳选项，并朝着最近的值移动，直到到达目标节点值。
- en: '![](img/b87cd73d-436e-405a-9656-47babb924f1f.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b87cd73d-436e-405a-9656-47babb924f1f.jpg)'
- en: The same principles that we have just learned can be found in pedestrians of
    the *GTA 5*. Many other games use this method, obviously, but we wanted to use
    this game as an example of the two pathfinding systems that can be found in most
    games. If we applied this system to AI police in order to search and find the
    player, we would have more or less the same results that can be seen in the actual
    gameplay.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学到的相同原理可以在 *GTA 5* 的行人中找到。显然，许多其他游戏也使用这种方法，但我们想用这个游戏作为大多数游戏中可以找到的两个寻路系统的例子。如果我们将这个系统应用于AI警察以搜索和找到玩家，我们就会得到在实际游戏玩法中可以看到的大致相同的结果。
- en: It takes more than just searching for the final destination, and this is just
    a small portion of the final code, but we would see an AI character avoiding walls
    and getting closer to the player position, step by step. On top of that, it would
    be necessary to add more content to the AI code, letting the character know what
    to do in multiple situations that can occur, such as having water in the middle
    of the path, stairs, moving cars, and many others.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了搜索最终目的地之外，这只是一个最终代码的小部分，但我们将会看到AI角色逐步避开墙壁并接近玩家位置。除此之外，还需要向AI代码中添加更多内容，让角色知道在可能出现的多种情况下应该做什么，例如路径中间有水、楼梯、移动的汽车等等。
- en: Generating grid nodes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成网格节点
- en: Now we are going to implement what we have learned so far into a practical exercise.
    Let's start by creating or importing our scene into the game editor.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把到目前为止学到的知识应用到实际练习中。让我们首先创建或导入我们的场景到游戏编辑器中。
- en: '![](img/4d89e5ee-c238-4908-a358-e69832b11670.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d89e5ee-c238-4908-a358-e69832b11670.png)'
- en: For this example, we are going to use buildings as non-walkable objects, but
    it can be anything that we choose, then we need to separate the objects that we
    just imported from the ground. To do this, we are going to assign them to a separate
    layer, and we are going to call it **unwalkable**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用建筑物作为不可行走对象，但可以是任何我们选择的东西，然后我们需要将我们刚刚导入的对象与地面分开。为此，我们将它们分配到一个单独的层，并将其命名为**不可行走**。
- en: 'Then we can start creating our first class of the game, and we are going to
    start from the `node` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始创建游戏的第一类，我们将从`节点`类开始：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have seen that the nodes have two different states, either they are walkable
    or non-walkable, so we can start by creating a Boolean called `walkable`. Then
    we need to know in what point in the world the node represents, so we create a
    `Vector 3` for the `worldPosition`. Now, we need some way to assign these values
    when we create a node, so we create the `Node` variable that will contain all
    the important information regarding the nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到节点有两种不同的状态，要么是可行走的，要么是不可行走的，所以我们可以从创建一个名为`walkable`的布尔值开始。然后我们需要知道节点在世界中的哪个点表示，因此我们创建一个`Vector
    3`用于`worldPosition`。现在，我们需要一种方法在创建节点时分配这些值，因此我们创建一个`Node`变量，它将包含有关节点的所有重要信息。
- en: 'After creating the essential part of this class, we can move on to the `grid`
    class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个类的必要部分之后，我们可以继续到`grid`类：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First of all, we need a two-dimensional array of nodes that represents our grid,
    so let's create a two-dimensional array of nodes, and we can call it `grid`. Then
    we can create a `Vector2` that will define the area in world coordinates that
    this grid covers and call it `gridWorldSize`. We also need a `float` variable
    to define how much space each individual node covers, which in this class is called
    `nodeRadius`. Then we need to create a `LayerMask` to define the area that is
    non-walkable and give it the name `unwalkableMask`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个二维数组来表示我们的网格，所以让我们创建一个二维节点数组，我们可以称它为`grid`。然后我们可以创建一个`Vector2`来定义这个网格在世界坐标中覆盖的区域，并称它为`gridWorldSize`。我们还需要一个`float`变量来定义每个单独的节点覆盖的空间量，在这个类中称为`nodeRadius`。然后我们需要创建一个`LayerMask`来定义不可行走区域，并将其命名为`unwalkableMask`。
- en: 'In order to visualize the grid that we just created in our game editor, we
    decided to use `OnDrawGizmos` method; using this is useful but not mandatory:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的游戏编辑器中可视化我们刚刚创建的网格，我们决定使用`OnDrawGizmos`方法；使用这个方法是很有用的，但不是强制性的：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s create a `Start` method, and we are going to add some basic calculations.
    The main thing that we need to figure out is how many nodes can we fit in to our
    grid. We start by creating a new `float` variable called `nodeDiameter` and new
    `int` variables called `gridSizeX` and `gridSizeY`. Then, inside of our `Start`
    method we are going to add the value of the `nodeDiameter` that is equal to `nodeRadius*2`.
    `gridSizeX` is equal to `gridWorldSize.x/nodeDiameter`,and this will tell us how
    many nodes can fit in the `gridWorldSize.x`. Then we will be rounding the number
    to fit into an integer number, so we will be using `Mathf.RoundToInt` to make
    this possible. After creating the calculus for the `x` axis, we can duplicate
    the same code and change it to make it work for the `y` axis. To finalize our
    `Start` method, we create a new function, we are going to call `CreateGrid()`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we add the value of the `grid` variable, `grid = new Node[gridSizeX, gridSizeY];`.
    Now we need to add collision detection that will establish the walkable and non-walkable
    areas of the map. To do this, we create a loop that can be seen in the code demonstrated
    previously. We simply added a new `Vector3` variable to get the bottom left corner
    of the map, which is called `worldBottomLeft`. Then we assigned the collision
    detection, which will search for any objects that are colliding with the walkable
    area by using `Physics.Check`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before testing it out, we need to update our `OnDrawGizmos` function, so that
    we can see the grid on top of the map. To make the grid visible, we assigned the
    colors red and white and the form of the cubes by using the `nodeDiameter` value
    to set the dimension of each cube. If the node is walkable, the color will be
    set to white; otherwise, it will be set to red. Now we can test it out:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cef43480-0339-4096-9e07-cbd490f9ba37.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'The results are wonderful; now we have a grid that auto-analyses the map and
    indicates the walkable and non-walkable areas. With this part completed, the rest
    will be easier to implement. Before moving on to the next part, we need to add
    a method that will tell our character which node it is standing in. In our code,
    we will be adding a function called `NodeFromWorldPoint` that will make this possible:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And we have finally completed the first part of our example. We have a code
    that can work in any scene we just need to define the scale of the map in which
    we want the code to search for the walkable and non-walkable areas, and the dimensions
    of each node in case we want to change the precision of the pathfinding remember
    that if we increase the number of nodes on the map, more CPU power will be required
    to calculate the pathfinding system).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Pathfinding implementation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to set the character to search for the final destination that
    we want. Let's start by creating a new class, which we will call **pathfinding**.
    This class will manage the search for the best path in order to reach the final
    destination. It will calculate in real time the shortest path that the character
    needs to follow and it will be updated every second, so if the final destination
    is moving, it will keep following and recalculating the best path.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将角色设置为搜索我们想要的最终目的地。让我们先创建一个新的类，我们将称之为**pathfinding**。这个类将管理搜索最佳路径以到达最终目的地。它将实时计算角色需要遵循的最短路径，并且每秒更新一次，所以如果最终目的地在移动，它将保持跟随并重新计算最佳路径。
- en: '![](img/7ebdfdaf-0ab4-4e0c-b6c8-4d411df3b50c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ebdfdaf-0ab4-4e0c-b6c8-4d411df3b50c.png)'
- en: We start by adding the AI character into our game editor that will eventually
    search for another character of the game. For test purposes, we will simply add
    some basic functions to our character that will let him move around the map, but
    we can also use a simple cube to test whether the pathfinding system is working.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将AI角色添加到我们的游戏编辑器中，它最终将搜索游戏中的另一个角色。为了测试目的，我们将简单地为我们的人物添加一些基本功能，使他能够在地图上移动，但我们也可以使用一个简单的立方体来测试路径查找系统是否工作。
- en: 'After importing our character into the game, we can start creating the class
    that will be assigned to it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的角色导入到游戏中后，我们可以开始创建一个将被分配给它的类：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We start by creating a function called `FindPath` that will store all the necessary
    values to calculate the distance between the start position and the target position.
    Then we add a `Grid` variable that will have the same value as the `grid` that
    we have previously created. Then we used the `Awake` function to access to the
    `grid` values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`FindPath`的函数，该函数将存储计算起始位置和目标位置之间距离所需的所有必要值。然后我们添加一个`Grid`变量，它的值将与我们之前创建的`grid`相同。然后我们使用`Awake`函数来访问`grid`值：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we need to create a list that will contain all of the nodes present in
    the game, as we have demonstrated before. One list contains all the `OPEN` nodes,
    and another one will contain all the `CLOSED` nodes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要创建一个列表，将包含游戏中所有存在的节点，正如我们之前所演示的那样。一个列表包含所有`OPEN`节点，另一个将包含所有`CLOSED`节点：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we have opened the `Node` class, and we added new variables called `gCost`
    and `hCost`. The idea is that this class calculates the shortest path value, and
    as we saw previously, in order to get the `fCost` that represents the shortest
    path, we need to sum the values of the `g` and `h` nodes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打开了`Node`类，并添加了名为`gCost`和`hCost`的新变量。这个类的想法是计算最短路径值，正如我们之前所看到的，为了得到代表最短路径的`fCost`，我们需要将`g`和`h`节点的值相加。
- en: '*f(n)=g(n)+h(n).*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(n)=g(n)+h(n)*。'
- en: 'Once the `Node` class is edited, we can go back to our pathfinding class and
    continue implementing the lines of code that will make our AI character search
    for the optimal path:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编辑了`Node`类，我们就可以回到我们的路径查找类，继续实现那些将使我们的AI角色搜索最佳路径的代码行：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Back to our pathfinding class; we need to define the current node that the
    character is positioned in. To make this happen, we added `Node currentNode =
    openSet[0]`; this will set 0 as the default node. Then we create the loop that
    will compare the `fCost` of the possible nodes to choose which one is the best
    option, `openSet[i].fCost < node.fCost || openSet[i].fCost == node.fCost`. This
    is the code that we have used to achieve the desirable results for this example,
    but it can still be optimized if necessary:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的路径查找类；我们需要定义角色所在的位置的当前节点。为了实现这一点，我们添加了`Node currentNode = openSet[0]`；这将0设置为默认节点。然后我们创建循环，比较可能节点的`fCost`以选择最佳选项，`openSet[i].fCost
    < node.fCost || openSet[i].fCost == node.fCost`。这是我们用来实现这个例子所需结果所使用的代码，但如果需要，它仍然可以进一步优化：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Continuing our loop, we have now defined when the current node is set to `OPEN`
    or `CLOSED` and established that if the current node value is equal to the target
    node value, it means that the character already has arrived at the final destination
    `if (currentNode == targetNode)`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的循环，我们现在已经定义了当前节点被设置为`OPEN`或`CLOSED`的情况，并确定如果当前节点值等于目标节点值，这意味着角色已经到达了最终目的地`if
    (currentNode == targetNode)`：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we need to loop through each of the `neighbor` nodes of the `current node`.
    To do this, we have decided to add this to our grid code, so we need to open the
    `grid` class that we created at the beginning of the example and add the `List`
    function demonstrated previously. Then we will be adding the necessary values
    to the `Node` class (`gridX` and `gridY`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要遍历 `current node` 的每个 `neighbor` 节点。为了做到这一点，我们决定将其添加到我们的网格代码中，因此我们需要打开在示例开头创建的
    `grid` 类，并添加之前演示的 `List` 函数。然后我们将添加必要的值到 `Node` 类（`gridX` 和 `gridY`）：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have added the final content for the `Node` class that contains the
    `gridX` and `gridY` values that will be used by the `grid` code. This is the final
    look at the `Node` class. Now, we can move on to the pathfinding class again:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了 `Node` 类的最终内容，该类包含 `gridX` 和 `gridY` 值，这些值将被 `grid` 代码使用。这是对 `Node`
    类的最终查看。现在，我们可以再次转向路径查找类：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we have added a `foreach` loop that will loop through the neighbors to
    check if they are walkable or non-walkable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个 `foreach` 循环，该循环将遍历邻居节点以检查它们是否可通行或不可通行。
- en: 'To better understand the next step that we are going to take, there will be
    some example diagrams of what we want to achieve to complete the pathfinding system:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们接下来要采取的步骤，我们将有一些示例图来展示我们想要实现的内容以完成路径查找系统：
- en: '![](img/7eb863af-bbac-4bfc-b32b-507673cc5503.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb863af-bbac-4bfc-b32b-507673cc5503.jpg)'
- en: 'We first need to count along the **X** axis to know how many nodes away we
    are from the final position on the **X** axis, and then we count along the **Y**
    axis to find out how many nodes away we are from the final position on the **Y**
    axis:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要沿着 **X** 轴计数，以了解我们距离 **X** 轴上的最终位置有多少个节点，然后我们沿着 **Y** 轴计数，以找出我们距离 **Y**
    轴上的最终位置有多少个节点：
- en: '![](img/81d50822-c277-45cf-8f96-07afe7230459.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81d50822-c277-45cf-8f96-07afe7230459.jpg)'
- en: 'In this example, we can see that in order to get to the **B** position we need
    to move upwards two points. Because we are always searching for the shortest path,
    at the same time we are going upwards, we move on the **X** axis:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到，为了到达 **B** 位置，我们需要向上移动两个点。因为我们总是在寻找最短路径，所以在向上移动的同时，我们在 **X** 轴上移动：
- en: '![](img/1f5e29a8-8561-430b-833d-45e81bfc6b5d.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f5e29a8-8561-430b-833d-45e81bfc6b5d.jpg)'
- en: To calculate how many either vertical or horizontal moves are necessary to reach
    the **B** position, we just subtract the lower number from the higher number.
    For example, before going on a straight line to the **B** position, it is necessary
    to calculate *5-2 = 3*, which gives us how many horizontal moves we need to reach
    the final destination.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算到达 **B** 位置所需的垂直或水平移动次数，我们只需将较大的数字减去较小的数字。例如，在直线上到达 **B** 位置之前，我们需要计算 *5-2
    = 3*，这告诉我们需要多少次水平移动才能到达最终目的地。
- en: 'Now, we can get back to the pathfinding code and add the equation that we have
    just learned:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到路径查找代码，并添加我们刚刚学到的公式：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we just added the lines of code that will tell us how many horizontal
    and vertical steps the AI needs to take in order to arrive at the target destination.
    Now, if we look back at the pseudo code that we created at the very beginning
    of this chapter to check what is left to create, we can see that we have followed
    the same structure and that we are almost finished. The pseudo code is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是添加了代码行，这些代码将告诉我们 AI 需要多少次水平和垂直步骤才能到达目标目的地。现在，如果我们回顾一下我们在本章开头创建的伪代码，以检查还需要创建什么，我们可以看到我们遵循了相同的结构，并且我们几乎完成了。伪代码如下：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, let's keep adding more important content into our code and keep moving towards
    the conclusion of the pathfinding class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续将更多重要内容添加到我们的代码中，并继续向路径查找类的结论迈进。
- en: 'We need to set the neighbor''s `f_cost` and as we already know, to calculate
    this value, we need to use the `g_Cost` and `h_Cost` of the neighbor node:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置邻居的 `f_cost`，正如我们已知的那样，为了计算这个值，我们需要使用邻居节点的 `g_Cost` 和 `h_Cost`：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the pathfinding class we have added the following code, which will calculate
    the neighbor nodes to check for their `f_cost`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径查找类中，我们添加了以下代码，该代码将计算邻居节点以检查它们的 `f_cost`：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before exiting from the loop, we will be calling a function called `RetracePath`,and
    we can give it `startNode` and `targetNode`. Then we have to create that new function
    with the same name and assign a list of the nodes that we have already explored.
    In order to visualize the pathfinding to see if it is working properly or not,
    we also have a path that we will be creating in the `grid` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出循环之前，我们将调用一个名为`RetracePath`的函数，并给它提供`startNode`和`targetNode`。然后我们必须创建一个具有相同名称的新函数，并分配一个已经探索的节点列表。为了可视化路径查找，看看它是否正常工作，我们还在`grid`类中创建了一个路径：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This section of the `grid` class was updated, now containing the `List`, `path`,
    and a new gizmo that will show on the editor view, the path between the AI position
    and the target position:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid`类的这一部分已被更新，现在包含`List`、`path`以及一个新的小工具，它将在编辑器视图中显示AI位置和目标位置之间的路径：'
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And finally, to conclude our example, we add a `void Update()` into our pathfinding
    class that will make the AI constantly search for the target position.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了总结我们的例子，我们在路径查找类中添加了一个`void Update()`方法，这将使AI不断搜索目标位置。
- en: 'Now we can move on to our game editor and assign the code pathfinding that
    we have created to the grid. Then we simply assign the AI character and the target
    position that we want:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到我们的游戏编辑器，并将我们创建的路径查找代码分配给网格。然后我们简单地分配AI角色和我们想要的目标位置：
- en: '![](img/69ac8284-7d67-4bcf-9f86-3198c61abdee.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69ac8284-7d67-4bcf-9f86-3198c61abdee.png)'
- en: 'If we test the pathfinding system, we can see that it is working perfectly.
    In the preceding screenshot, the top left point is the AI character''s position,
    and in the bottom right is the target destination. We can see that the character
    planned the shortest path and one that avoids colliding with the buildings:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试路径查找系统，我们可以看到它运行得非常完美。在上面的截图里，左上角是AI角色的位置，右下角是目标目的地。我们可以看到角色规划了最短路径，并且避开了与建筑的碰撞：
- en: '![](img/1872a4d1-4477-4263-b3ac-60ec6805bb43.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1872a4d1-4477-4263-b3ac-60ec6805bb43.png)'
- en: Then we have disabled the mesh from the buildings to have a better look at the
    walkable and unwalkable areas of the map. We can see that the character only chooses
    the walkable areas and avoids any obstacles in its way. It is complicated to demonstrate
    it using still images, but if we change the target location in real time, we can
    see the pathfinding adjusting the route that the character needs to take, and
    it always chooses the shortest path.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们禁用了建筑物的网格，以便更好地查看地图的可行走和不可行走区域。我们可以看到角色只选择可行走区域，并避开其路径上的任何障碍。用静态图像展示它很复杂，但如果我们在实时改变目标位置，我们可以看到路径查找正在调整角色需要采取的路线，并且它总是选择最短路径。
- en: '![](img/7e9a26eb-f9f9-409f-96fe-d41bd0f9b3ed.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e9a26eb-f9f9-409f-96fe-d41bd0f9b3ed.jpg)'
- en: The advanced pathfinding system that we have just created can be found in many
    popular games that everybody loves. Now that we have learned how to create a complex
    pathfinding system, we are able to re-create some parts of the most advanced AI
    characters of modern games such as GTA or Assassins Creed. Talking about Assassins
    Creed, it will be our next game, reference for the next chapter because its AI
    characters link perfectly between A* pathfinding and realistic crowd interactions,
    as we can see in the preceding screenshot.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的高级路径查找系统可以在许多大家喜爱的流行游戏中找到。现在我们已经学会了如何创建复杂的路径查找系统，我们能够重新创建现代游戏中如GTA或刺客信条中最先进AI角色的某些部分。谈到刺客信条，它将是我们的下一款游戏，作为下一章的参考，因为其AI角色在A*路径查找和现实人群交互之间完美连接，正如我们在上面的截图中所看到的。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we revisited how to create point-to-point movement, but instead
    of using a simple method, we have studied how huge and successful game studios
    manage to solve one of the most complicated features of a AI, pathfinding. Here,
    we have learned how to use theta algorithms to recreate an human feature that
    helps us search and move in the right direction in order to arrive at the desired
    destination.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了如何创建点对点移动，但不是使用简单的方法，而是研究了大型且成功的游戏工作室如何解决AI最复杂的功能之一，即路径查找。在这里，我们学习了如何使用theta算法来重现人类特征，这有助于我们在正确的方向上搜索和移动，以便到达期望的目的地。
- en: In the next chapter, we will be talking about realistic crowd interactions,
    a very important aspect when trying to make an AI character as realistic as possible.
    We will be studying different approaches used in different types of game, and
    also we will be looking at how humans and animals interact in their environments
    and how we can use that in our AI code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论现实中的群体互动，这是尝试使人工智能角色尽可能真实的一个重要方面。我们将研究不同类型游戏中使用的方法，同时我们还将探讨人类和动物在其环境中如何互动，以及我们如何将这一点应用到我们的AI代码中。
