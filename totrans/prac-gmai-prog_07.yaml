- en: Advanced Pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at the advanced pathfinding methods that
    can be used in a wide range of games. The main objective of this chapter is to
    learn the foundations of how to create an advanced AI element that can analyze
    the map and process all the necessary information in order to decide the best
    path that needs to be taken. Advanced pathfinding methods can be found in many
    popular game titles that require the AI character to choose the best path in real
    time, and we will analyze some of the most famous examples and how can we replicate
    the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Simple versus advanced pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discovered in the previous chapter, pathfinding is used by AI characters
    to discover the direction that they need to move and how to do it correctly. Depending
    on the game that we are working on, we could use a simple pathfinding system or
    a complex one. Both can be very useful. There are situations where a simple pathfinding
    system is enough to accomplish the task that we are looking for, but in other
    cases we need a different alternative to the methods that we have covered before
    in order to achieve the complexity and realism that is necessary for our AI character.
  prefs: []
  type: TYPE_NORMAL
- en: Before talking about any advanced system of creating a pathfinding method, let's
    discover why we need to use it and in what circumstances it is necessary to update
    our character and make it more intelligent and aware. Using our previous examples,
    we will be looking at the limitations that exist for a normal pathfinding method.
    Understanding the limitations of a simple pathfinding system will help us acknowledge
    what is missing and what challenges we will face when we are about to create a
    more complex system. So it is a good start to first learn how we can set up a
    simple pathfinding system and then we can move on to a more complex one. Because
    games have evolved at the same rate as the technology available to create them,
    our first example will be an older game, and then we'll see how the same game
    has evolved, in particular AI pathfinding.
  prefs: []
  type: TYPE_NORMAL
- en: Open world maps are now very common, and many games from different genres use
    this to create a rich experience, but it wasn't always like this. Let's take the
    first **Grand Theft Auto** (**GTA**) game as an example. Analyzing the pattern
    of the cars that are driving on the map, we can see that they don't have a complex
    system, and the drivers are stuck to the predefined route or lap that each of
    them is assigned to follow. Obviously, this AI pathfinding system was very advanced
    at that time and even if we play it today, we don't feel discouraged by the AI
    characters because it works wonderfully for that game.
  prefs: []
  type: TYPE_NORMAL
- en: The AI drivers follow their path and stop every time the player is in their
    way. This demonstrates that they have a collision detector in front of each car
    to tell them if there is something blocking the path. If there is something in
    front of the car, the driver stops immediately, and until the path is unblocked,
    it won't drive again. This is a sign that the drivers have some sort of pathfinding
    system that couldn't solve different situations where it was not possible for
    them to keep driving in the same direction. For that reason and to avoid any errors
    or glitches in the game, the programmers have chosen to make the drivers stop
    when that happens.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d96ded83-37cb-4284-8fa1-2309735da118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding case scenario, where the drivers stop when it's not possible for
    them to keep moving forward, became one of the biggest strengths in their future
    games. Many things have evolved in the GTA games, and the AI is definitely one
    of them. They have refined the AI drivers, making them aware of the situation
    and their surroundings. Let's analyze *GTA San Andreas,* which is also available
    to play on mobile phones. In this game, if we stop our car in front of the AI
    driver, the results are completely different. Depending on the personality of
    the AI driver, it will react differently; for example, some of them will simply
    honk the horn and wait a little bit, and if the player keeps blocking their way,
    the driver will outrun the player. Others might react more aggressively, getting
    out of the car to confront the player physically.
  prefs: []
  type: TYPE_NORMAL
- en: If the AI driver notices that the environment is getting dangerous by hearing
    shots, they speed up and choose the fastest path to get out of that situation.
    This type of behavior demonstrates that the AI characters have a more complex
    and refined pathfinding system in conjunction with a possibility map, where the
    surrounding situation will reflect which path they end up choosing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29e6ca7d-c2bb-45dc-aaad-a200b6e6cd79.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the drivers now have a presence that's much more noticeable than
    in the first game. In the previous chapter, we studied how to create a simple
    pathfinding system, very similar to what we analyzed in the first GTA game. Now,
    we'll look in depth at how to create an AI character that can get away from any
    unexpected situation.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of those things that still isn't perfect, and many developers are
    trying new ways of creating AI characters that can behave almost like a human
    person would if trapped in the same situation. Some companies are getting close
    to that--one big example is Rockstar Games with their GTA franchise, and for that
    reason we have chosen to start with their example.
  prefs: []
  type: TYPE_NORMAL
- en: A* search algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unpredictable situations usually lead to a large amount of hours coding the
    extensive possibilities that the characters have. For this reason, it was necessary
    to think on a new way to create a better pathfinding system, where the characters
    could analyze the surroundings for themselves in real time and choose the best
    path to take. One method that has become very popular for this effect is using
    **theta algorithms**, which allows the characters to constantly search for the
    best path without it being necessary to manually set which points they need to
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: The Theta search algorithm (A*) is a widely used search algorithm that can be
    used to find solutions for many problems and pathfinding is one of them. Using
    this algorithm to solve pathfinding problems is very common due to the uniform-cost
    search and heuristic search. The Theta search algorithm examines every corner
    of the map to help the character determine if it is possible to use that location
    or not, while trying to reach the desired destination.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The map or scene of the game needs to be prepared or pre-analyzed before the
    theta algorithm can work. The environment that includes all the assets of the
    map will be handled as a graph. This means that the map will be broken into different
    points and locations, which are called nodes. These nodes are used to record all
    the progress of the search. While memorizing the map location, each individual
    node has other attributes, such as fitness, goal, and heuristic, usually represented
    by the letters f, g, and h. The purpose of the fitness, goal, and heuristic attributes
    is to put in order how good a path is according to the current node.
  prefs: []
  type: TYPE_NORMAL
- en: Different values are assigned to the paths between the nodes. These values usually
    represent the distances between the nodes. The value between the nodes doesn't
    necessarily have to be distance. The value can also be time; this will help us
    find the fastest path instead of the shortest one, for example. The Theta algorithm
    uses two lists, an open list and a closed list. The open list contains the nodes
    that were totally explored. Marker arrays can also be used to find out whether
    a state is in the open list or the closed list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7325c113-ad29-4aec-95ac-4dc68ba988a5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that the character will constantly be searching for the best nodes
    to follow in order to achieve the fastest or shortest results. As we can see in
    the preceding screenshot, the map was pre-analyzed, the walkable area is represented
    by the small gray squares, while the big squares represent the area that is blocked
    by some object or environment asset. The AI character represented by the black
    and white circle needs to move node by node until it reaches the star object.
    If for some reason one of the nodes is blocked, the character will rapidly switch
    to the closest one and then continue on its way.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this pathfinding method's theory is very similar to what we have
    created before, where the character follows point by point until it arrives at
    the final destination. The main difference is that with the Theta algorithm, the
    points are generated automatically by the AI, making it the best choice when developing
    big or complex scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of using A*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Theta algorithm is not the perfect solution that can be used everywhere
    or in every game, and we should keep that thought in mind. Because the AI character
    is constantly searching for the best path to follow, a significant portion of
    the CPU is being used exclusively for that task. Because tablets and mobile devices
    are very popular gaming platforms nowadays, it is worth mentioning that developing
    a game for these platforms requires paying special attention to the CPU and GPU
    usage, and for that reason, A* pathfinding can be a disadvantage here.
  prefs: []
  type: TYPE_NORMAL
- en: But hardware limitation isn't the only disadvantage. When we let the AI assume
    all the work without any human control, bugs are highly likely. That is one reason
    why modern games that prefer using open world maps encounter a lot of bugs and
    weird AI reactions, because it is extremely difficult to narrow down all the possible
    outcomes in a massive gameplay area.
  prefs: []
  type: TYPE_NORMAL
- en: '" says bugs in the latest demo are natural for open world games"'
  prefs: []
  type: TYPE_NORMAL
- en: Final Fantasy XV director
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0b85096-b48d-4dea-9e47-44c982765b97.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The director of Final Fantasy XV commented about this issue, stating that bugs
    are expected in every open world game. This summarizes perfectly why using theta
    algorithms for AI pathfinding is a popular and efficient approach when developing
    open world games, but it is not perfect and bugs will definitely occur.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the theta algorithm and the pros and
    cons of it, let's move on to the practical section.
  prefs: []
  type: TYPE_NORMAL
- en: Going directly from A to B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start with a simple example, without any obstacles between one
    point and another. This will help us visualize how the algorithm finds the best
    path. Then we will be adding an obstacle and observing how the algorithm chooses
    the best path when contouring the obstacle at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aad6a824-7609-45fa-8528-7fb8d1fcd22a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this grid we have two points, **A** that is the starting point and **B**
    that is the end point. We want to find the shortest path between the two. To help
    us solve this problem, we will be using the A* algorithm and we'll see how it
    manages to find the shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93ce4d0d-9c3a-4b13-9bac-daf1e24f2006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, the algorithm calculates every step to find the shortest one. To calculate
    this, the algorithm uses two nodes, as we discovered before, the G node and the
    H node. G represents the distance from the starting point, so it calculates how
    far it is from the **A** position. H represents the distance from the end point,
    so it calculates how far it is from the **B** position. If we sum both nodes (*G
    + H = F*), we get the F node value, which represents the shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the shortest number is **42**, so we can move to that position
    and calculate again every available hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7dbd57e-5e87-4f6b-9fa2-353608b3c063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once again, the algorithm calculates the best options that are available from
    the position that we are in. We are getting close to B, and for that reason the
    values for the H nodes are getting smaller while the values for the G nodes are
    getting bigger, and that is perfectly fine. From all the possibilities that we
    currently have, the number **42** is once again the lowest number and the best
    option to take. So the natural decision is to move towards that position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d07cdf49-4103-415c-83e7-41ef34ddff18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And finally, we have arrived at the **B** point. Once the algorithm finds that
    the H node value is zero, that means that it has already arrived at the desired
    destination and there's no need to keep searching for a better path.
  prefs: []
  type: TYPE_NORMAL
- en: From point A to B with obstacles in the way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is exactly how the A* pathfinding works; it goes from point to point evaluating
    the best options and pursuing the shortest path until it reaches the final destination.
    The earlier example was simple, and now we are going to make it more interesting
    to see how it works if we add obstacles to the map.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62751395-95a1-49b1-831a-868731b8a83d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the same map, we have painted some squares in black, representing that
    those positions can''t be used. Now, it starts getting slightly more interesting,
    because if we try to guess what the best path to take would be, we might be wrong.
    Once again, let''s calculate what the best options are, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2adcc2c2-b7bc-482a-a9f4-24de3f92f740.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results that we get are exactly the same as the first test and this is normal,
    because none of the points that are surrounding the **A** position are positioned
    on the black squares. Once again, we can move towards the lowest number that is
    **42**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80c93264-b146-4336-a0e4-99b0b97c13b5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have made our first move and calculated the best options that are
    available from that point, we are in an interesting situation. At this moment,
    we have the three lowest numbers and we have to choose one. We need to find the
    shortest path that leads us to the **B** position and because the three lowest
    numbers are the same, we need to make the decision according to the H node only,
    which represents the distance between our current position and the B position.
    Two of the positions have the H value of **38** while just one of them has the
    value of **24**, making it the lowest H value of the three. So let's move on in
    that direction, which seems to be closer to the final destination.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a7b201a-6932-4130-b195-4c98124c81ef.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From now on we can notice that the F values are getting higher, which represents
    the shortest path value. This is due to the black squares that we have added to
    the map. Because of them, we need to go around, increasing the length of the path
    that we need to take. This is how the AI will perceive the walls; they know for
    a fact that the final destination is close, but in order to arrive there, they
    can't pass through the wall, so they need to go around until they find an open
    door or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the lowest values are in the other direction, which means that we need
    to go back in order to find a better path. This is a very important aspect of
    the algorithm, because if we have the character walking around searching for the
    best path at the same time that it is walking, we will have a more human-like
    result. It will look like that he is searching for the correct path to arrive
    at the desired destination, like a person would if they didn't know the right
    path. On the other hand, the character can be programmed to make all the calculations
    before it starts moving, and in that case we would see a character going directly
    to the right path until it reaches the final point. Both methods are valid and
    can be used for different purposes and different games.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing our pathfinding, we need to keep choosing the lowest value, so at
    this point we need to go back and choose between the two lowest values, **48**.
    Both have the same G and H values, so the only way to find out which is the best
    path to take is to randomly choose one of the points or pre-calculate them to
    see which of them will have the lowest value. So let's choose one randomly to
    see the values that come up.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11b3a167-57a4-4c63-a903-1996d152010c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After choosing one of the two shortest possibilities, we found that the values
    are getting higher, and for that reason we need to go back and calculate the other
    value as well to see if there is a lower value after that. Because we can already
    see the map and we already know where the **B** point is placed, we know for a
    fact that the lowest value is actually further away than the **68** value that
    appeared just now. But if we didn't know where the B point was, we still needed
    to check that **48** value, to see if the destination point was near that position
    or not. That is what the AI character will decide in the gameplay it will constantly
    check the lowest F value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/343ff24c-7d89-4093-a9f6-d08258520075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After choosing the new position, we can see that it didn't provide any better
    opportunities, and we need to keep searching for a better path, which in this
    case is going to be a point that we have already discovered, but whose outcomes
    we didn't calculate. Once again, we have the two lowest F values and we will be
    choosing the lowest H value, that is, **20**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87f40b8b-3f80-416d-9b77-8445089ec64b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After calculating the new possibilities, we notice that we need to choose **54**
    again to see if the final destination is closer to that point. This is exactly
    the process that will occur when we program the AI to find the shortest path that
    it will need to take in order to arrive at the final destination. The calculations
    need to be solved in real time, and as will start to notice, they can get very
    complex. This is why it consumes a significant portion of the CPU power, because
    it is the hardware component designated to this function (calculus).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will be selecting the number **54**, because it is the lowest number
    on the map.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68864176-58de-44d5-8aab-249035f9b385.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we keep moving down, the values will get higher, which means that we are
    getting farther away from where we need to be. If we were the AI and didn't know
    that the final destination is at the top, we would need to check the number **60**,
    because it is the most promising of them all at the moment. So, let's calculate
    the outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e973133-d4ea-46da-97f0-807b6cd896b3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can see that there are a lot of identical lowest numbers, which are
    **62**, so we need to explore them all and keep calculating until the character
    finds the right path. For the purposes of the example we will be moving to every
    lowest number that we can see on the map now.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f08211d8-9543-4434-b006-274a738a8f16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After exploring all the lowest possibilities, we can see that we are getting
    closer to the final destination. At this point, the lowest value available is
    **68**, and after that it will be easy to reach the final point.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd6307c8-185a-43a2-a0a6-43bd9afe0a10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we have arrived at the point **B** destination. This is the visual
    aspect of A* algorithm, where the darker gray area represents the positions that
    the computer has visited and the lighter gray area represents the outcome calculations
    of those areas that we visited.
  prefs: []
  type: TYPE_NORMAL
- en: The computer can calculate the best path in real time, or the developers can
    also choose to let the AI calculate the best options before exporting the game.
    So the AI will automatically know which path it needs to follow when the game
    starts, saving some CPU power.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain how this works in the programming language, we will be using pseudo
    code to demonstrate this example. This way we can understand from start to finish
    how we can create the search method in any programming language and how we can
    adapt it ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze each line of code that we used to create the example. We have
    divided the grid map into two different categories: `OPEN` and `CLOSED`. The `OPEN`
    ones are the squares that we have already explored, represented on the image by
    the dark gray blocks. While the `CLOSED` are the white blocks that we didn''t
    explore yet. This will allow the AI to distinguish between the explored and not
    explored blocks, going from point to point finding the best path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we assigned the first block that is considered `OPEN`; this will set the
    starting point and it will automatically start calculating the best options from
    that position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to create a loop, and inside our loop we have a temporary
    variable called `current`; this is equal to the node in the `OPEN` list that has
    the lowest F cost. Then it will be removed from the `OPEN` list and added to the
    `CLOSED` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if the current node is the target node, the code assumes that the final
    destination has been explored and we can just exit out of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we must go through each of the `neighbor` nodes of the current node.
    If it is not traversable, meaning that we cannot pass that position or if it was
    previously explored and is on the `CLOSED` list, the code can skip to the next
    neighbor. This part sets where it is possible to move and also tells the AI to
    not take into consideration positions that were previously explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If it is not the case, then we can move on and check a couple of things. If
    the new path to the `neighbor` is shorter than the old path or if the `neighbor`
    is not on the `OPEN` list, then we set the `f_cost` of the `neighbor` by calculating
    the `g_cost` and the `h_cost`. We see the new possible blocks have children from
    the current block, so we can trace the steps that are being taken. And finally,
    if the `neighbor` is not on the `OPEN` list, we can add it.
  prefs: []
  type: TYPE_NORMAL
- en: Looping this, the code will constantly be searching for the best options and
    moving towards the closest values until it arrives at the target node value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b87cd73d-436e-405a-9656-47babb924f1f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same principles that we have just learned can be found in pedestrians of
    the *GTA 5*. Many other games use this method, obviously, but we wanted to use
    this game as an example of the two pathfinding systems that can be found in most
    games. If we applied this system to AI police in order to search and find the
    player, we would have more or less the same results that can be seen in the actual
    gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: It takes more than just searching for the final destination, and this is just
    a small portion of the final code, but we would see an AI character avoiding walls
    and getting closer to the player position, step by step. On top of that, it would
    be necessary to add more content to the AI code, letting the character know what
    to do in multiple situations that can occur, such as having water in the middle
    of the path, stairs, moving cars, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Generating grid nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to implement what we have learned so far into a practical exercise.
    Let's start by creating or importing our scene into the game editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d89e5ee-c238-4908-a358-e69832b11670.png)'
  prefs: []
  type: TYPE_IMG
- en: For this example, we are going to use buildings as non-walkable objects, but
    it can be anything that we choose, then we need to separate the objects that we
    just imported from the ground. To do this, we are going to assign them to a separate
    layer, and we are going to call it **unwalkable**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can start creating our first class of the game, and we are going to
    start from the `node` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have seen that the nodes have two different states, either they are walkable
    or non-walkable, so we can start by creating a Boolean called `walkable`. Then
    we need to know in what point in the world the node represents, so we create a
    `Vector 3` for the `worldPosition`. Now, we need some way to assign these values
    when we create a node, so we create the `Node` variable that will contain all
    the important information regarding the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the essential part of this class, we can move on to the `grid`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need a two-dimensional array of nodes that represents our grid,
    so let's create a two-dimensional array of nodes, and we can call it `grid`. Then
    we can create a `Vector2` that will define the area in world coordinates that
    this grid covers and call it `gridWorldSize`. We also need a `float` variable
    to define how much space each individual node covers, which in this class is called
    `nodeRadius`. Then we need to create a `LayerMask` to define the area that is
    non-walkable and give it the name `unwalkableMask`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to visualize the grid that we just created in our game editor, we
    decided to use `OnDrawGizmos` method; using this is useful but not mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `Start` method, and we are going to add some basic calculations.
    The main thing that we need to figure out is how many nodes can we fit in to our
    grid. We start by creating a new `float` variable called `nodeDiameter` and new
    `int` variables called `gridSizeX` and `gridSizeY`. Then, inside of our `Start`
    method we are going to add the value of the `nodeDiameter` that is equal to `nodeRadius*2`.
    `gridSizeX` is equal to `gridWorldSize.x/nodeDiameter`,and this will tell us how
    many nodes can fit in the `gridWorldSize.x`. Then we will be rounding the number
    to fit into an integer number, so we will be using `Mathf.RoundToInt` to make
    this possible. After creating the calculus for the `x` axis, we can duplicate
    the same code and change it to make it work for the `y` axis. To finalize our
    `Start` method, we create a new function, we are going to call `CreateGrid()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we add the value of the `grid` variable, `grid = new Node[gridSizeX, gridSizeY];`.
    Now we need to add collision detection that will establish the walkable and non-walkable
    areas of the map. To do this, we create a loop that can be seen in the code demonstrated
    previously. We simply added a new `Vector3` variable to get the bottom left corner
    of the map, which is called `worldBottomLeft`. Then we assigned the collision
    detection, which will search for any objects that are colliding with the walkable
    area by using `Physics.Check`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Before testing it out, we need to update our `OnDrawGizmos` function, so that
    we can see the grid on top of the map. To make the grid visible, we assigned the
    colors red and white and the form of the cubes by using the `nodeDiameter` value
    to set the dimension of each cube. If the node is walkable, the color will be
    set to white; otherwise, it will be set to red. Now we can test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cef43480-0339-4096-9e07-cbd490f9ba37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The results are wonderful; now we have a grid that auto-analyses the map and
    indicates the walkable and non-walkable areas. With this part completed, the rest
    will be easier to implement. Before moving on to the next part, we need to add
    a method that will tell our character which node it is standing in. In our code,
    we will be adding a function called `NodeFromWorldPoint` that will make this possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: And we have finally completed the first part of our example. We have a code
    that can work in any scene we just need to define the scale of the map in which
    we want the code to search for the walkable and non-walkable areas, and the dimensions
    of each node in case we want to change the precision of the pathfinding remember
    that if we increase the number of nodes on the map, more CPU power will be required
    to calculate the pathfinding system).
  prefs: []
  type: TYPE_NORMAL
- en: Pathfinding implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to set the character to search for the final destination that
    we want. Let's start by creating a new class, which we will call **pathfinding**.
    This class will manage the search for the best path in order to reach the final
    destination. It will calculate in real time the shortest path that the character
    needs to follow and it will be updated every second, so if the final destination
    is moving, it will keep following and recalculating the best path.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ebdfdaf-0ab4-4e0c-b6c8-4d411df3b50c.png)'
  prefs: []
  type: TYPE_IMG
- en: We start by adding the AI character into our game editor that will eventually
    search for another character of the game. For test purposes, we will simply add
    some basic functions to our character that will let him move around the map, but
    we can also use a simple cube to test whether the pathfinding system is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing our character into the game, we can start creating the class
    that will be assigned to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating a function called `FindPath` that will store all the necessary
    values to calculate the distance between the start position and the target position.
    Then we add a `Grid` variable that will have the same value as the `grid` that
    we have previously created. Then we used the `Awake` function to access to the
    `grid` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to create a list that will contain all of the nodes present in
    the game, as we have demonstrated before. One list contains all the `OPEN` nodes,
    and another one will contain all the `CLOSED` nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we have opened the `Node` class, and we added new variables called `gCost`
    and `hCost`. The idea is that this class calculates the shortest path value, and
    as we saw previously, in order to get the `fCost` that represents the shortest
    path, we need to sum the values of the `g` and `h` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '*f(n)=g(n)+h(n).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Node` class is edited, we can go back to our pathfinding class and
    continue implementing the lines of code that will make our AI character search
    for the optimal path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to our pathfinding class; we need to define the current node that the
    character is positioned in. To make this happen, we added `Node currentNode =
    openSet[0]`; this will set 0 as the default node. Then we create the loop that
    will compare the `fCost` of the possible nodes to choose which one is the best
    option, `openSet[i].fCost < node.fCost || openSet[i].fCost == node.fCost`. This
    is the code that we have used to achieve the desirable results for this example,
    but it can still be optimized if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing our loop, we have now defined when the current node is set to `OPEN`
    or `CLOSED` and established that if the current node value is equal to the target
    node value, it means that the character already has arrived at the final destination
    `if (currentNode == targetNode)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to loop through each of the `neighbor` nodes of the `current node`.
    To do this, we have decided to add this to our grid code, so we need to open the
    `grid` class that we created at the beginning of the example and add the `List`
    function demonstrated previously. Then we will be adding the necessary values
    to the `Node` class (`gridX` and `gridY`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added the final content for the `Node` class that contains the
    `gridX` and `gridY` values that will be used by the `grid` code. This is the final
    look at the `Node` class. Now, we can move on to the pathfinding class again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added a `foreach` loop that will loop through the neighbors to
    check if they are walkable or non-walkable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the next step that we are going to take, there will be
    some example diagrams of what we want to achieve to complete the pathfinding system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eb863af-bbac-4bfc-b32b-507673cc5503.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We first need to count along the **X** axis to know how many nodes away we
    are from the final position on the **X** axis, and then we count along the **Y**
    axis to find out how many nodes away we are from the final position on the **Y**
    axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81d50822-c277-45cf-8f96-07afe7230459.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we can see that in order to get to the **B** position we need
    to move upwards two points. Because we are always searching for the shortest path,
    at the same time we are going upwards, we move on the **X** axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f5e29a8-8561-430b-833d-45e81bfc6b5d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To calculate how many either vertical or horizontal moves are necessary to reach
    the **B** position, we just subtract the lower number from the higher number.
    For example, before going on a straight line to the **B** position, it is necessary
    to calculate *5-2 = 3*, which gives us how many horizontal moves we need to reach
    the final destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can get back to the pathfinding code and add the equation that we have
    just learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just added the lines of code that will tell us how many horizontal
    and vertical steps the AI needs to take in order to arrive at the target destination.
    Now, if we look back at the pseudo code that we created at the very beginning
    of this chapter to check what is left to create, we can see that we have followed
    the same structure and that we are almost finished. The pseudo code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, let's keep adding more important content into our code and keep moving towards
    the conclusion of the pathfinding class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set the neighbor''s `f_cost` and as we already know, to calculate
    this value, we need to use the `g_Cost` and `h_Cost` of the neighbor node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the pathfinding class we have added the following code, which will calculate
    the neighbor nodes to check for their `f_cost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Before exiting from the loop, we will be calling a function called `RetracePath`,and
    we can give it `startNode` and `targetNode`. Then we have to create that new function
    with the same name and assign a list of the nodes that we have already explored.
    In order to visualize the pathfinding to see if it is working properly or not,
    we also have a path that we will be creating in the `grid` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This section of the `grid` class was updated, now containing the `List`, `path`,
    and a new gizmo that will show on the editor view, the path between the AI position
    and the target position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And finally, to conclude our example, we add a `void Update()` into our pathfinding
    class that will make the AI constantly search for the target position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can move on to our game editor and assign the code pathfinding that
    we have created to the grid. Then we simply assign the AI character and the target
    position that we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69ac8284-7d67-4bcf-9f86-3198c61abdee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we test the pathfinding system, we can see that it is working perfectly.
    In the preceding screenshot, the top left point is the AI character''s position,
    and in the bottom right is the target destination. We can see that the character
    planned the shortest path and one that avoids colliding with the buildings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1872a4d1-4477-4263-b3ac-60ec6805bb43.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we have disabled the mesh from the buildings to have a better look at the
    walkable and unwalkable areas of the map. We can see that the character only chooses
    the walkable areas and avoids any obstacles in its way. It is complicated to demonstrate
    it using still images, but if we change the target location in real time, we can
    see the pathfinding adjusting the route that the character needs to take, and
    it always chooses the shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e9a26eb-f9f9-409f-96fe-d41bd0f9b3ed.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The advanced pathfinding system that we have just created can be found in many
    popular games that everybody loves. Now that we have learned how to create a complex
    pathfinding system, we are able to re-create some parts of the most advanced AI
    characters of modern games such as GTA or Assassins Creed. Talking about Assassins
    Creed, it will be our next game, reference for the next chapter because its AI
    characters link perfectly between A* pathfinding and realistic crowd interactions,
    as we can see in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we revisited how to create point-to-point movement, but instead
    of using a simple method, we have studied how huge and successful game studios
    manage to solve one of the most complicated features of a AI, pathfinding. Here,
    we have learned how to use theta algorithms to recreate an human feature that
    helps us search and move in the right direction in order to arrive at the desired
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be talking about realistic crowd interactions,
    a very important aspect when trying to make an AI character as realistic as possible.
    We will be studying different approaches used in different types of game, and
    also we will be looking at how humans and animals interact in their environments
    and how we can use that in our AI code.
  prefs: []
  type: TYPE_NORMAL
