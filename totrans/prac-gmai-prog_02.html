<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Possibility and Probability Maps</h1>
                </header>
            
            <article>
                
<p>In this chapter, we'll be talking about possibility and probability maps, understanding how and where they are used. We'll also be learning the best practices for creating an AI that reacts to the player and that also chooses the best options, as we look to create a character that can make decisions as a human would.</p>
<p>As we saw previously, video games used to rely heavily on predetermining the behavior of what the AI could do in different scenarios that were either created by the game itself or by the player's actions. This method has been present since day one and is still being used today, making it an extremely valuable method for creating quality AI characters. Before explaining, in detail, what each of the maps do, and before demonstrating how to create them in order to develop good AI behavior, it's always good to have a general idea of what possibility and probability maps are and where or when they are applied.</p>
<p>As gamers, we tend to enjoy the product as a whole, experiencing every part of the game with enthusiasm and dedication, forgetting about the technical aspects of the game. For that reason, we sometimes forget that even simple things that happen while we play were already destined to occur that way, and that there is a lot of thought and planning behind that moment. Everything happens for a reason, as we often hear, and this can also be applied to video games. From the moment you clicked the start button to begin the game to the last awesome combo that you performed to defeat the final boss of the game, everything was planned to happen and it was necessary for a programmer to input all of those possibilities within the game. If you clicked the A button and your character jumped, that happened because it was determined to be that way. The same thing is valid for AI enemies or allies on the game; when they do something to defeat or help you, it was necessary for that behavior to be programmed, and to do that we use states.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Game states</h1>
                </header>
            
            <article>
                
<p>To understand how to create possibility or probability maps we need to first acknowledge the principle aspect necessary to create them, which is called game states, or simply states. We call game states to the actions that are predetermined throughout different occasions in the game, and those actions can be applied to both the player or to the enemy character. Some examples can be simple behavior, such as run, jump, or attack, and those states can be expanded a little more, for example when the character is in the air and cannot attack or if the character has low magical energy and cannot perform a magic attack. In these cases, the character goes from one state to another or can't perform one if it's doing another.</p>
<div class="CDPAlignCenter CDPAlign"><img height="107" width="331" class=" image-border" src="assets/f20164ce-777f-4a79-b420-8764519d357a.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Possibility maps</h1>
                </header>
            
            <article>
                
<p>Now let's take a deeper look at the possibility maps that we encountered in the examples in the first chapter, from the chess machine to the Metal Gear Solid video game. As we can see, it's a technique that is still being used today, and it is almost impossible to create a game AI without it.</p>
<p>As the name suggests, possibility maps allow the programmer to define the possibilities available to the player or the AI character within the game. Everything that is possible inside the game needs to be planned and coded, but what happens when you allow the character to do a lot of things can they do them all at the same time? If played during different stages of the game, can they react in the same way at all of the stages? To allow, and restrain, the possible actions, we also need to think about the possible scenarios that can occur in the game, and when you put all of that together it's called a possibility map.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to use possibility maps</h1>
                </header>
            
            <article>
                
<p>Let's take a look at a simple example of a common FPS game, and for that we'll be using the states demonstrated in the preceding image.</p>
<p>Imagine that we are the enemy character of the game and our goal is to shoot and kill the player using only the states walk, run, cover, jump, fire, and defend. We need to take into consideration that the player will do his best to kill us, and therefore a lot of possible scenarios may arrive. Let's start with the basics we are walking from one point to another while protecting our space and as the player goes near that space, our goal changes from protecting our space to the definitive goal, that is, killing the player. What should we do next? Fire? Run towards the player and fire from close range? Cover and wait until the player is nearby? What if the player saw us first and is preparing to fire at us? A lot of things could happen, and a lot of things can be done with just a few states. So, let's map every possible situation and plan how we should act or react in each individual situation. Examples that I would choose for my game are as follows:</p>
<ul>
<li>Walk slowly to a cover position, wait for the player, and shoot him</li>
<li>Run for cover and then fire from that position</li>
<li>Defend (moving away from the bullets) while running to a cover position</li>
<li>Fire against the player, running towards him, and keep firing</li>
</ul>
<p>Depending on the type of game that we want to create, we can use the same states to shape it into a different genre. We also need to take into consideration the personality of the character that we are programming. If it's a robot, it probably won't be afraid to keep firing against the player, even if the chances of getting destroyed are 99%. On the other hand, if it's an inexperienced soldier, it might feel reluctant to get shot and will run for cover instantly. The list goes on and on just by changing the personality of the character.</p>
<div class="CDPAlignCenter CDPAlign"><img height="267" width="277" class=" image-border" src="assets/9f529c32-3f20-45ac-acc6-e2a21ea8a524.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing a possibility map (FPS)</h1>
                </header>
            
            <article>
                
<p>At this point, we are able to understand what a possibility map is and how it can be used to create an AI character that behaves accordingly to different situations in the game. Now that we understand how to use a possibility map, let's create a practical example where we programmed our AI character to successfully defeat the player. For this example, I'll be using two models, one represents the AI enemy that we are programming and the other one represents the player.</p>
<p>We'll create a common example, where the AI is protecting the entrance of a building that the player needs to enter in order to deactivate a bomb and complete the level. Let's imagine that we already have the player fully programmed and that we now need to focus on our AI enemy, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="317" width="565" class=" image-border" src="assets/24955dfe-2bb8-4c0e-8882-d1bcea3aa25a.jpg"/></div>
<p>Before writing any line of code we need to think about the possible situations that can occur and how our AI will react to them. First, we'll be simplifying the situation by breaking down our stages into a simple 2D visualization that will be used as a reference to determinate distances and other relevant parameters.</p>
<div class="CDPAlignCenter CDPAlign"><img height="237" width="393" class=" image-border" src="assets/149af240-03a2-49ea-a485-6ad61c15d8af.jpg"/></div>
<p>After simplifying the situation, we are ready to start planning the possibilities. The player is allowed to move around the building. Note that there's only one entrance, and that entrance is protected by our enemy AI. The arrows represents the direction that the characters are facing, and this will be an important aspect to our planning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a possibility map (FPS)</h1>
                </header>
            
            <article>
                
<p>We'll learn how to create an awareness behavior for the AI character later, so for now we will just be using simple Boolean variables to determine if the player is near our position and what direction it is facing. Taking that into consideration, let's break our image into trigger zones to define when our enemy AI should react.</p>
<div class="CDPAlignCenter CDPAlign"><img height="208" width="346" class=" image-border" src="assets/01e2e023-d664-4bd9-bbc0-dc7ea838a5b4.jpg"/></div>
<p>The <span class="packt_screen">YES</span> zones represents the area that triggers our AI to change its behavior from the passive to offensive state. The <span class="packt_screen">NO</span> zones represent the area that doesn't have an impact on our AI behavior. I've divided the <span class="packt_screen">YES</span> zones into three because we want our AI character to react differently according to the player's position. If the player comes from the right side (<span class="packt_screen">YES R</span>), the enemy has a wall that can be used for cover; if it comes from the left side (<span class="packt_screen">YES L</span>), we can't use that wall anymore, and once the player is in the middle (<span class="packt_screen">YES M</span>), the AI can only move backwards inside of the building.</p>
<p>Let's prepare our script for the enemy AI. In this example, we will use the C# language, but you can adapt the script to any programming language that you prefer, as the principles remains the same. The variables that we'll be using for now are <kbd>Health</kbd>, <kbd>statePassive</kbd>, <kbd>stateAggressive</kbd>, and <kbd>stateDefensive</kbd>:</p>
<pre>public class Enemy : MonoBehaviour { <br/>private int Health = 100; <br/>private bool statePassive; <br/>private bool stateAggressive; <br/>private bool stateDefensive; <br/>// Use this for initialisation  <br/>void Start () {  <br/>}  <br/>// Update is called once per frame <br/>void Update () {  <br/>}  <br/>} </pre>
<p>Now that we know the basic information required for the AI, we need to think about when those states will be used and how the AI will choose between the three available options. For this, we'll use a possibility map. We already know the areas that trigger our character, and we have already chosen the three behavior states, so it's time to plan the transitions and reactions according to the player's position and behavior.</p>
<div class="CDPAlignCenter CDPAlign"><img height="170" width="404" class=" image-border" src="assets/698e2d58-eabe-4ef8-9a74-7cab089b3652.jpg"/></div>
<p>Our enemy AI can go from <strong>PASSIVE</strong> to <strong>DEFENSIVE</strong> or <strong>AGGRESSIVE</strong>, from <strong>AGGRESSIVE</strong> to <strong>DEFENSIVE</strong>, and from <strong>DEFENSIVE</strong> to <strong>AGGRESSIVE</strong>, but once our AI knows that the player is around, it will never go back to the passive behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the states</h1>
                </header>
            
            <article>
                
<p>Let's define what triggers each state and how the AI should choose the correct state in different scenarios. The PASSIVE state will be the default state, and the game will start in that position until the player comes across our character. The DEFENSIVE state will be used in two different situations if the player comes from the right side and if he has already confronted the player and has low HP. Finally, the AGGRESSIVE state will be activated if the player comes from the left side or has already arrived at the middle area:</p>
<pre>public class Enemy : MonoBehaviour {<br/>private int Health = 100;<br/>private bool statePassive; <br/>private bool stateAggressive; <br/>private bool stateDefensive; <br/>private bool triggerL; <br/>private bool triggerR; <br/>private bool triggerM;<br/>// Use this for initialisation <br/>void Start () { <br/> statePassive = true; <br/>}<br/>// Update is called once per frame <br/>void Update () {<br/> // The AI will remain passive until an interaction with the player occurs <br/> if(Health == 100 &amp;&amp; triggerL == false &amp;&amp; triggerR == false &amp;&amp; triggerM <br/> == false) <br/> { <br/>  statePassive = true; <br/>  stateAggressive = false; <br/>  stateDefensive = false; <br/> }<br/> // The AI will shift to the defensive mode if player comes from the<br/> right side or if the AI is below 20 HP <br/> if(Health&lt;= 100 &amp;&amp; triggerR == true || Health&lt;= 20) <br/> { <br/>  statePassive = false; <br/>  stateAggressive = false; <br/>  stateDefensive = true; <br/> }<br/> // The AI will shift to the aggressive mode if player comes from the<br/> left side or it's on the middle and AI is above 20HP <br/> if(Health&gt; 20 &amp;&amp; triggerL == true || Health&gt; 20 &amp;&amp; triggerM == true) <br/> { <br/>  statePassive = false; <br/>  stateAggressive = true; <br/>  stateDefensive = false; <br/>  } <br/> } <br/>}</pre>
<p>We added the trigger variables <kbd>triggerL</kbd>, <kbd>trigger,</kbd> and <kbd>triggerM</kbd> and also defined when the AI should change from one behavior state to another. At this point, our enemy already knows what to do in different situations that may occur during gameplay according to the player's position.</p>
<p>Now we just need to determine what will happen on each state, because that is what differentiates a <span>DEFENSIVE</span> state from an <span>AGGRESSIVE</span> one. For this specific enemy, where his main function is to protect the entrance of the building, we want him to stay put at all times and to never run after the player. This is because the AI doesn't know that it is just one person and can't take the risk of going after just one soldier if there's a possibility of being greeted by several. This will help to give a little realism to the actions of the enemy. We'll also use the defensive behavior state for the moment where the enemy feels that it is losing the battle and is about to die, or when it has the advantage of using the building to protect itself while the player doesn't. Finally, the aggressive state will be used when the AI sees a clear advantage to kill or if it doesn't have any other options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DEFENSIVE state</h1>
                </header>
            
            <article>
                
<p>So, let's start with the situation where the player comes from the right side and our enemy has already spotted him. We want our AI to take advantage of the wall that protects him, making it difficult for the player as well as demonstrating a human-like intention, rather than simply opening fire. The enemy will move towards the wall and stay there firing on the corner until the player arrives to that position.</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/3cbaedea-1d79-4feb-846e-a9dcccc70426.jpg"/></div>
<p>The enemy will change from the <span>PASSIVE</span> state into the <span>DEFENSIVE</span> state, instead of OFFENSIVE, only because doing that gives him a slightly better advantage over the player. Being defensive on the first encounter shows some personality to the AI, which is very important when making the behavior of the computer character believable. In future chapters we'll learn how to use the environment to help define our AI character in depth:</p>
<pre>Void Defensive () { <br/>if(playerPosition == "triggerR") <br/>{ <br/>// Check if player is currently  <br/>located on the triggerR position <br/>transform.LookAt(playerSoldier); <br/>// Face the direction of the player   <br/>if(cover == false) <br/> { <br/>  transform.position = Vector3.MoveTowards(transform.position,  <br/>  wallPosition.position, walk); <br/> } <br/>if(cover == true) <br/> { <br/>  coverFire();} <br/> } <br/>} </pre>
<p>We added the core for the <kbd>Defensive</kbd> state that we want to implement on our enemy AI when the player is coming from the right side. We also added new variables, such as <kbd>speed</kbd>, <kbd>cover</kbd>, <kbd>playerSoldier,</kbd> and <kbd>coverFire.</kbd> First, we need to check if the player is currently positioned in the <kbd>triggerR</kbd> zone; if the result is positive, the character should move towards the cover position. Once the enemy AI is at the cover position, he can start firing against the player (<kbd>coverFire</kbd>). Now let's input the following situation if the player is still alive, our enemy needs to move to another situation, otherwise it will be cornered, which isn't a good scenario for the character we are creating. Let's add that situation to our script.</p>
<p>We want our character to walk back and get inside the building, while always facing the player and firing at the same time. We could use another tactic, or decide to be more aggressive and confront the player directly, but for now let's stick to a simple strategy. We can add more complex behavior later:</p>
<pre>if (playerPosition == "triggerM") <br/>{  <br/> transform.LookAt(playerSoldier); // Face the direction of the player  <br/> transform.position = Vector3.MoveTowards(transform.position,  <br/> buildingPosition.position, walkBack);  <br/> backwardsFire(); } </pre>
<div class="CDPAlignCenter CDPAlign"><img height="323" width="574" class=" image-border" src="assets/03cc7346-5cc8-4368-af96-0a436bfab0ed.jpg"/></div>
<p>In this part of the code we added a situation where the player comes from the right side and is still alive going to the middle, so we needed to change the previous behavior to a new one. Our AI character goes from the cover position to a newer position that is inside the building, firing at the player the whole time. At this point, the enemy will keep getting back until one of the two characters die either the player or the AI character. We close the situation where the player comes from the right side. Now that we have completed this part, we need to complete the scenario and add the last situation, which is where the player goes around the building and comes from the left side. Our AI will need to adapt to these circumstances and behave differently, so let's work on that part and complete the example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AGGRESSIVE state</h1>
                </header>
            
            <article>
                
<p>Before we started programming, we defined how many states we would need for this enemy AI, and we chose three different states: <span>PASSIVE</span>, <span>DEFENSIVE</span>, and <span>AGGRESSIVE</span>. Now that we already have the two behavior states in place (passive and defensive), there is just one more needed to complete our enemy AI, that is, to protect the building.</p>
<p>We previously decided that the character would only directly confront the player if he couldn't use the wall as cover, and that moment is where the player comes from the left and the enemy is surprised with its presence.</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/7626b687-89fb-4680-8d7b-f657d9c0a1cc.jpg"/></div>
<p>Once again, we need to first check if the player triggered the left area, as that will activate our enemy AI from the PASSIVE state into the AGGRESSIVE state we intended. Then, we need to define what he should do in that case. Let's start writing it in our script:</p>
<pre>Void Aggressive () {   <br/>if(playerPosition == "triggerL" || playerPosition == "triggerM")  <br/>{  <br/> transform.LookAt(playerSoldier); // Face the direction of the player  <br/> frontFire();  <br/>}   <br/>else {   <br/> transform.position = Vector3.MoveTowards(transform.position,<br/> triggerLPosition.position, walk);  <br/>}   <br/>}  </pre>
<p>This time we added our two possible situations when attacking a player that comes from the left; the first is if the player comes from the left and continues towards the enemy, or remains in the same position. The second situation that could occur is if the player soon retreats as soon as he sees the enemy, and in that scenario we have chosen to make the enemy search for the player, going towards the <kbd>triggerL</kbd> position where initially the player appeared.</p>
<p>This is the completed script, written using the possibility map example that we've been working on in this chapter. Let's take a look at the full script:</p>
<pre>Private int Health = 100;  <br/>Private bool statePassive;  <br/>Private bool stateAggressive;  <br/>Private bool stateDefensive;   <br/>Private bool triggerL;  <br/>Private bool triggerR;  <br/>Private bool triggerM;   <br/>public Transform wallPosition;  <br/>public Transform buildingPosition;  <br/>public Transform triggerLPosition; <br/>private bool cover;  <br/>private float speed;  <br/>private float speedBack;  <br/>private float walk;  <br/>private float walkBack; <br/>public Transform playerSoldier;  <br/>staticstring playerPosition; </pre>
<p>In the previous block of code, we can see all of the variables that have been used in our script so far. The rest of the script is as follows:</p>
<pre>// Use this for initialization <br/>Void Start () {        <br/>statePassive = true;  <br/>}  <br/>// Update is called once per frame  <br/>Void Update () {   <br/>// The AI will remain passive until an interaction with the player occurs <br/>if(Health == 100 &amp;&amp; triggerL == false &amp;&amp; triggerR == false &amp;&amp; triggerM == false) <br/>{  <br/> statePassive = true;  <br/> stateAggressive = false;  <br/> stateDefensive = false;  <br/>}   <br/>// The AI will shift to the defensive mode if player comes from the right side or if the AI is below 20 HP  <br/>if(Health&lt;= 100 &amp;&amp; triggerR == true || Health&lt;= 20){  <br/> statePassive = false;  <br/> stateAggressive = false;  <br/> stateDefensive = true;  <br/>}   <br/>// The AI will shift to the aggressive mode if player comes from the left side or it's on the middle and AI is above 20HP  <br/>if(Health&gt; 20 &amp;&amp; triggerL == true || Health&gt; 20 &amp;&amp; triggerM == true){  <br/> statePassive = false;  <br/> stateAggressive = true;  <br/> stateDefensive = false;  <br/>}   <br/>walk = speed * Time.deltaTime;  <br/>     = speedBack * Time.deltaTime;  <br/>}   <br/>Void Defensive () {   <br/>     if (playerPosition == "triggerR")  <br/>     {  <br/>     // Check if player is currently located on the triggerR position  <br/>     transform.LookAt(playerSoldier); // Face the direction of the<br/>     player   <br/>     if(cover == false)  <br/>      {  <br/>        transform.position = Vector3.MoveTowards(transform.position,  <br/>        wallPosition.position, walk);         <br/>       }   <br/>     if(cover == true)  <br/>     {  <br/>      coverFire();  <br/>     }  <br/>     }   <br/>    if(playerPosition == "triggerM") <br/>     {  <br/>      transform.LookAt(playerSoldier); // Face the direction of the<br/>      player  <br/>      transform.position = Vector3.MoveTowards(transform.position,<br/>      buildingPosition.position, walkBack);  <br/>      backwardsFire();  <br/>     }  <br/>    }   <br/>Void Aggressive () {   <br/>if (playerPosition == "triggerL" || playerPosition == "triggerM")<br/> {  <br/>  transform.LookAt(playerSoldier); // Face the direction of the player  <br/>  frontFire();  <br/> }   <br/>else {   <br/>  transform.position = Vector3.MoveTowards(transform.position, <br/>  triggerLPosition.position, walk);  <br/> }   <br/>}    <br/>Void coverFire () {  <br/>// Here we can write the necessary code that makes the enemy firing while in cover position.}   <br/>Void backwardsFire () { <br/>// Here we can write the necessary code that makes the enemy firing while going back.}   <br/>voidfrontFire() { <br/>}   </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Possibility map conclusion</h1>
                </header>
            
            <article>
                
<p>We have finally completed our first possibility map example. The principles that were shared in this chapter can be used in a wide range of game genres. In fact, almost any game that you plan to create in the future can greatly benefit from a possibility map. As we saw, this technique is used to plan every situation that the player can create, and how the character AI should behave according to that. By planning this carefully we can avoid a lot of issues in gameplay, as well as a lack of diversity regarding the character AI behavior. Another interesting point that is worth mentioning is to try to create a different Possibility Map for different characters of the game, as not all humans react equally. A computer AI should follow that same rule.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Probability maps</h1>
                </header>
            
            <article>
                
<p>A probability map is a more complex and detailed version of a possibility map because it relies on probabilities in order to change the behavior of the character, rather than a simple on or off trigger. Its similarity with the possibility map is that it's also required for planning ahead the possible states for our character. This time, however, we add to it a percentage, using which the AI will calculate what behavior he will be using. Imagine the next example using the situation that we previously created for the possibility map our enemy AI could be more aggressive in the daytime than at night. For that, we create a statement that explains to our enemy that if it's night time, there is a lesser chance of seeing the player character, and for that reason it will choose a more defensive approach instead of an aggressive one. Or, simply, we could define that our enemy calculates the probability of killing the player simply based on the distance between the two characters. If the player gets closer to the enemy, the probability of the AI getting back and surviving are lesser than if he keeps firing against the player, so we can add that equation into the AI.</p>
<p>Let's take a look at our human behavior, the choices we make; usually, we make our decision by taking into consideration past events and what we've done before. When we feel hungry and we decide to go out for dinner, can our friend guess which restaurant we have chosen? Our friend may have calculated the probability of our choice and given their answer by taking into consideration the higher percentage chance. That's exactly what we need to do to our AI friend; we need to assign some probabilities to his choices, such as what's the probability of the AI character falling asleep while protecting the building during the day and during the night? What's the probability of the enemy running if he has low hp? If we apply probability to our AI character, it helps to create that unpredictable behavior that humans have and makes the game more engaging and natural.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to use probability maps</h1>
                </header>
            
            <article>
                
<p>In this example, we'll continue using the same scenario that we created before, where our AI guard is protecting a building that contains an atomic that the player needs to deactivate. The only entrance to the building is protected by our AI character.</p>
<p>Let's imagine that we are the guard and we have orders to stay there for 16 hours straight we would probably need to eat, drink, and move a little bit to be able to stay active and alert the whole time. We will therefore add that to our character, making it more unpredictable for the player. If the AI decides to eat or drink, he will be inside the building, and if he decides to walk a little bit he will be patrolling from the <kbd>triggerL</kbd> to <kbd>triggerR</kbd> position. Most of the time, he will be just standing on his guard position.</p>
<div class="CDPAlignCenter CDPAlign"><img height="82" width="220" class=" image-border" src="assets/152524bc-c191-41d3-878d-bcd6318ef28e.jpg"/></div>
<p>This is a probability map, and here we define the percentage of each state that our character exists in. It means that every time the player sees the enemy AI, the enemy can be doing one of those things. This will differ greatly when you take into consideration the time of day at which the player decided to appear. If the player arrives in the morning, it has an <strong>0.87</strong> chance of finding the enemy in a guard position in front of the building, a <strong>0.10</strong> chance of finding him eating or drinking inside the building, and finally a <strong>0.03</strong> chance of finding him walking outside from one point to another. If the player arrives in the afternoon, it has a <strong>0.48</strong> chance of finding the enemy in a guard position in front of the building, a <strong>0.32</strong> chance of finding him eating or drinking inside the building, and finally a <strong>0.2</strong> chance of finding him walking around from one point to another. At night, the player has a <strong>0.35</strong> chance of finding the enemy in the guard position, a <strong>0.40</strong> chance of finding him eating or drinking inside the building, and a <strong>0.25</strong> chance of finding the enemy walking around.</p>
<div class="CDPAlignCenter CDPAlign"><img height="247" width="438" class=" image-border" src="assets/c25d3452-5650-45ae-9c47-5ce7ca04030c.jpg"/></div>
<p>This will help to create that unpredictable aspect to our character by not making it as obvious that he will be in the same position every time you play the level. We can also update this probability every five minutes or so, in case the player stays still, waiting for our enemy to change position. This technique is used in a lot of games, but especially in stealth games, where observation is key. This is because the player has the opportunity to stay in a safe position and observe the enemy behavior, similar to heist movies, where actors wait for the guards to change shifts before getting inside the bank. Because of this popular behavior that we're used to seeing in movies, players like to feel that same sensation in games, and so probability maps have changed the way how we play.</p>
<p>An example of how probability can be used in a script is as follows. For this, I've used the <kbd>Passive</kbd> state and added the probability that we previously decided to use:</p>
<pre>Void Passive () {   <br/>rndNumber = Random.Range(0,100);  <br/>If(morningTime == true &amp;&amp;  13) <br/>{  <br/>// We have 87% of chance  <br/>goGuard(); <br/>}   <br/>if(morningTime == true &amp;&amp; rndNumber =&lt; 13 &amp;&amp; rndNumber&lt; 3) <br/>{ <br/>// We have 10% of chance  <br/>goDrink();  <br/>}   <br/>if(morningTime == true &amp;&amp; rndNumber&lt;= 3) <br/>{ <br/>// We have 3% of chance  <br/>goWalk();  <br/>}   <br/>if(afternoonTime == true &amp;&amp; rndNumber&gt; 52) <br/>{ <br/>// We have 48% of chance  <br/>goGuard();  <br/>}   <br/>if(afternoonTime == true &amp;&amp; rndNumber =&lt; 34 &amp;&amp; rndNumber&lt; 2) <br/>{  <br/>// We have 32% of chance<br/>goDrink();  <br/>}   <br/>if(afternoonTime == true &amp;&amp; rndNumber&lt;= 2) <br/>{  <br/>// We have 2% of chance  <br/>goWalk();  <br/>}   <br/>if(nightTime == true &amp;&amp; rndNumber&gt; 65) <br/>{  <br/>// We have 35% of chance  <br/>goGuard();  <br/>}   <br/>if(nightTime == true &amp;&amp; rndNumber =&lt; 65 &amp;&amp; rndNumber&lt; 25) <br/>{  <br/>// We have 40% of chance  <br/>goDrink();  <br/>}   <br/>if(nightTime == true &amp;&amp; rndNumber&lt;= 25) <br/>{  <br/>// We have 25% of chance        <br/>goWalk();  <br/>}  <br/>}  </pre>
<p>To calculate the percentage, we first need to create a random number from <kbd>0</kbd> to <kbd>100</kbd>, and then we create a statement that will use that number to check to which statement it belongs. On the first statement, for example, we have an <kbd>87%</kbd> chance of the AI staying in the guard position, so if the random number is higher than <kbd>13</kbd>, it fits within this category and the character is made to stay in the guard position. A number higher than <kbd>3</kbd> and equal or less than <kbd>13</kbd>, gives us a <kbd>10%</kbd> of chance, and a number equal or less than <kbd>3</kbd> gives us a <kbd>3%</kbd> chance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Where to go from here</h1>
                </header>
            
            <article>
                
<p>Now that we understand how to use a probability and possibility map, a pertinent question that we might question ourselves is, what can we do with this? Well we saw how important is to use a possibility map to define the behaviors of a character and how the probability helps to make those behaviors unpredictable, but we can do a lot more with what we learned depending on the type of game that we are creating or the type of AI that we want. Remember that flaws makes part of what we are as humans and we are surrounded by probabilities, even if it's just <em>0</em>,<em>000001%</em> the probability of happening the unexpected exists that's why no one is perfect, so it's a fun fact to remember when creating an AI character, giving them some probability of human stuff happening, or simply making good or bad decisions, that builds a personality to the computer character that you are creating.</p>
<p>Another special thing that we can do with probability maps, is giving the AI the opportunity to learn from himself, making him smarter every time the player decides to play the game. Both the player and the enemy AI will learn, making the challenge always updated according to the hours spent on the game. If the player has the tendency to use the same weapon or coming from the same direction, the computer should update that information and use it on future events. If the player confronted the computer <em>100</em> times and <em>60%</em> of those times he used a grenade, the AI should have that in mind and react according to that probability. That will push the player to think in other strategies, also not being so obvious exploring other ways of defeating the enemy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter has described possibility and probability maps and we have learned how to let the AI make decisions for itself according to the player actions. Possibility and probability maps is the foundation of an AI character and now we can explore this technique to create new and unique artificial intelligence for our games. In the next chapter, we'll learn how the AI should behave according to the different options that it has on that moment instead of using a possibility map. We want the character to analyze the situation and think about what to do, taking in consideration many factors, such as health, distance, weapon, bullets, and any other relevant factors.</p>


            </article>

            
        </section>
    </body></html>