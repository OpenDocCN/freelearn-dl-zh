["```py\n    def __init__(self, location, heading=0, speed=0, \n                 angular_vel=0, radius=8.0, range_finder_range=100.0):\n        self.heading = heading\n        self.speed = speed\n        self.angular_vel = angular_vel\n        self.radius = radius\n        self.range_finder_range = range_finder_range\n        self.location = location\n        # defining the range finder sensors\n        self.range_finder_angles = [-90.0, -45.0, 0.0, 45.0, 90.0, -180.0]\n        # defining the radar sensors\n        self.radar_angles = [(315.0, 405.0), (45.0, 135.0),\n                             (135.0, 225.0), (225.0, 315.0)]\n        # the list to hold range finders activations\n        self.range_finders = [None] * len(self.range_finder_angles)\n        # the list to hold pie-slice radar activations\n        self.radar = [None] * len(self.radar_angles)\n```", "```py\n    def __init__(self, agent, walls, exit_point, exit_range=5.0):\n        self.walls = walls\n        self.exit_point = exit_point\n        self.exit_range = exit_range\n        # The maze navigating agent\n        self.agent = agent\n        # The flag to indicate if exit was found\n        self.exit_found = False\n        # The initial distance of agent from exit\n        self.initial_distance = self.agent_distance_to_exit()\n```", "```py\n        for i, angle in enumerate(self.agent.range_finder_angles):\n            rad = geometry.deg_to_rad(angle)\n            projection_point = geometry.Point(\n                x = self.agent.location.x + math.cos(rad) * \\\n                    self.agent.range_finder_range,\n                y = self.agent.location.y + math.sin(rad) * \\\n                    self.agent.range_finder_range\n            )\n            projection_point.rotate(self.agent.heading, \n                                    self.agent.location)\n            projection_line = geometry.Line(a = self.agent.location, \n                                            b = projection_point)\n            min_range = self.agent.range_finder_range\n            for wall in self.walls:\n                found, intersection = wall.intersection(projection_line)\n                if found:\n                    found_range = intersection.distance(\n                                                   self.agent.location)\n                    if found_range < min_range:\n                        min_range = found_range\n            # Store the distance to the closest obstacle\n            self.agent.range_finders[i] = min_range\n```", "```py\n    def update_radars(self):\n        target = geometry.Point(self.exit_point.x, self.exit_point.y)\n        target.rotate(self.agent.heading, self.agent.location)\n        target.x -= self.agent.location.x\n        target.y -= self.agent.location.y\n        angle = target.angle()\n        for i, r_angles in enumerate(self.agent.radar_angles):\n            self.agent.radar[i] = 0.0 # reset specific radar \n            if (angle >= r_angles[0] and angle < r_angles[1]) or \n               (angle + 360 >= r_angles[0] and angle + 360 < r_angles[1]):\n                # fire the radar\n                self.agent.radar[i] = 1.0\n```", "```py\n    def update(self, control_signals):\n        if self.exit_found:\n            return True # Maze exit already found\n        self.apply_control_signals(control_signals)\n        vx = math.cos(geometry.deg_to_rad(self.agent.heading)) * \\\n                      self.agent.speed\n        vy = math.sin(geometry.deg_to_rad(self.agent.heading)) * \\\n                      self.agent.speed\n        self.agent.heading += self.agent.angular_vel\n        if self.agent.heading > 360:\n            self.agent.heading -= 360\n        elif self.agent.heading < 0:\n            self.agent.heading += 360\n        new_loc = geometry.Point(\n            x = self.agent.location.x + vx, \n            y = self.agent.location.y + vy\n        )\n        if not self.test_wall_collision(new_loc):\n            self.agent.location = new_loc\n        self.update_rangefinder_sensors()\n        self.update_radars()\n        distance = self.agent_distance_to_exit()\n        self.exit_found = (distance < self.exit_range)\n        return self.exit_found\n```", "```py\n       self.agent.angular_vel += (control_signals[0] - 0.5)\n       self.agent.speed += (control_signals[1] - 0.5)\n```", "```py\n        vx = math.cos(geometry.deg_to_rad(self.agent.heading)) * \\\n                      self.agent.speed\n        vy = math.sin(geometry.deg_to_rad(self.agent.heading)) * \\\n                      self.agent.speed\n        self.agent.heading += self.agent.angular_vel\n        if self.agent.heading > 360:\n            self.agent.heading -= 360\n        elif self.agent.heading < 0:\n            self.agent.heading += 360\n        new_loc = geometry.Point(\n            x = self.agent.location.x + vx, \n            y = self.agent.location.y + vy\n        )\n        if not self.test_wall_collision(new_loc):\n            self.agent.location = new_loc\n```", "```py\n        self.update_rangefinder_sensors()\n        self.update_radars()\n```", "```py\n        distance = self.agent_distance_to_exit()\n        self.exit_found = (distance < self.exit_range)\n        return self.exit_found\n```", "```py\n    def __init__(self, generation, agent_id):\n        self.generation = generation\n        self.agent_id = agent_id\n        self.x = -1\n        self.y = -1\n        self.fitness = -1\n        self.hit_exit = False\n        self.species_id = -1\n        self.species_age = -1\n```", "```py\ndef eval_fitness(genome_id, genome, config, time_steps=400):\n    maze_env = copy.deepcopy(trialSim.orig_maze_environment)\n    control_net = neat.nn.FeedForwardNetwork.create(genome, config)\n    fitness = maze.maze_simulation_evaluate(\n              env=maze_env, net=control_net, time_steps=time_steps)\n    record = agent.AgentRecord(\n        generation=trialSim.population.generation,\n        agent_id=genome_id)\n    record.fitness = fitness\n    record.x = maze_env.agent.location.x\n    record.y = maze_env.agent.location.y\n    record.hit_exit = maze_env.exit_found\n    record.species_id = trialSim.population.species.\\\n                                       get_species_id(genome_id)\n    record.species_age = record.generation - \\\n      trialSim.population.species.get_species(genome_id).created\n    trialSim.record_store.add_record(record)\n    return fitness\n```", "```py\n    # Calculate the fitness score based on distance from exit\n    fitness = env.agent_distance_to_exit()\n    if fitness <= self.exit_range:\n         fitness = 1.0\n    else:\n        # Normalize fitness score to range (0,1]\n        fitness = (env.initial_distance - fitness) / \\\n                   env.initial_distance\n        if fitness <= 0.01:\n            fitness = 0.01\n```", "```py\n[NEAT]\nfitness_criterion = max\nfitness_threshold = 1.0\npop_size = 250\nreset_on_extinction = False\n```", "```py\nnum_hidden = 1\nnum_inputs = 10\nnum_outputs = 2\n```", "```py\n[NEAT]\ncompatibility_disjoint_coefficient = 1.1\n[DefaultSpeciesSet]\ncompatibility_threshold = 3.0\n```", "```py\nnode_add_prob          = 0.1\nnode_delete_prob       = 0.1\n```", "```py\nfeed_forward            = False\n```", "```py\n11\n30 22\n0\n270 100\n5 5 295 5\n295 5 295 135\n295 135 5 135\nâ€¦\n```", "```py\n$ conda create --name maze_objective_neat python=3.5\n$ conda activate maze_objective_neat\n$ pip install neat-python==0.92 \n$ conda install matplotlib\n$ conda install graphviz\n$ conda install python-graphviz\n```", "```py\n    maze_env_config = os.path.join(local_dir, '%s_maze.txt' % \n                                   args.maze)\n    maze_env = maze.read_environment(maze_env_config)\n```", "```py\n    seed = 1559231616\n    random.seed(seed)\n    config = neat.Config(neat.DefaultGenome, \n                         neat.DefaultReproduction,\n                         neat.DefaultSpeciesSet, \n                         neat.DefaultStagnation,\n                         config_file)\n    p = neat.Population(config)\n```", "```py\n    global trialSim\n    trialSim = MazeSimulationTrial(maze_env=maze_env, \n                                   population=p)\n```", "```py\n    p.add_reporter(neat.StdOutReporter(True))\n    stats = neat.StatisticsReporter()\n    p.add_reporter(stats)\n    p.add_reporter(neat.Checkpointer(5, \n                 filename_prefix='%s/maze-neat-checkpoint-' % \n                 trial_out_dir))\n```", "```py\n    start_time = time.time()\n    best_genome = p.run(eval_genomes, n=n_generations)\n    elapsed_time = time.time() - start_time\n    solution_found = (best_genome.fitness >= \\\n                      config.fitness_threshold)\n    if solution_found:\n        print(\"SUCCESS: The stable maze solver controller was found!!!\")\n    else:\n        print(\"FAILURE: Failed to find the stable maze solver controller!!!\")\n```", "```py\ndef eval_genomes(genomes, config):\n    for genome_id, genome in genomes:\n        genome.fitness = eval_fitness(genome_id, genome, config)\n```", "```py\n$ python maze_experiment.py -m medium -g 150\n```", "```py\n****** Running generation 145 ****** \n\nMaze solved in 388 steps\nPopulation's average fitness: 0.24758 stdev: 0.25627\nBest fitness: 1.00000 - size: (3, 11) - species 7 - id 35400\n\nBest individual in generation 145 meets fitness threshold - complexity: (3, 11)\n```", "```py\nBest genome:\nKey: 35400\nFitness: 1.0\nNodes:\n 0 DefaultNodeGene(key=0, bias=5.534849614521037, response=1.0, activation=sigmoid, aggregation=sum)\n 1 DefaultNodeGene(key=1, bias=1.8031133229851957, response=1.0, activation=sigmoid, aggregation=sum)\n 158 DefaultNodeGene(key=158, bias=-1.3550878188609456, response=1.0, activation=sigmoid, aggregation=sum)\nConnections:\n DefaultConnectionGene(key=(-10, 158), weight=-1.6144052085440168, enabled=True)\n DefaultConnectionGene(key=(-8, 158), weight=-1.1842193888036392, enabled=True)\n DefaultConnectionGene(key=(-7, 0), weight=-0.3263706518456319, enabled=True)\n DefaultConnectionGene(key=(-7, 1), weight=1.3186165993348418, enabled=True)\n DefaultConnectionGene(key=(-6, 0), weight=2.0778575294986945, enabled=True)\n DefaultConnectionGene(key=(-6, 1), weight=-2.9478037554862824, enabled=True)\n DefaultConnectionGene(key=(-6, 158), weight=0.6930281879212032, enabled=True)\n DefaultConnectionGene(key=(-4, 1), weight=-1.9583885391583729, enabled=True)\n DefaultConnectionGene(key=(-3, 1), weight=5.5239054588484775, enabled=True)\n DefaultConnectionGene(key=(-1, 0), weight=0.04865917999517305, enabled=True)\n DefaultConnectionGene(key=(158, 0), weight=0.6973191076874032, enabled=True)\nSUCCESS: The stable maze solver controller was found!!!\nRecord store file: out/maze_objective/medium/data.pickle\n```", "```py\n$ python visualize.py -m medium -r out/maze_objective/medium/data.pickle --width 300 --height 150\n```", "```py\n$ python maze_experiment.py -m hard -g 500\n```"]