<html><head></head><body>
        

                            
                    <h1 class="header-title">How It All Comes Together</h1>
                
            
            
                
<p>We've almost arrived at the end of our journey. We've learned all the essential tools to implement fun AI in our Unity game. We stressed this throughout the course of the book, but it's important to drive the point home: the concepts and patterns we learned throughout the book are individual concepts, but they can, and often should, be used in harmony to achieve the desired behavior from our AI. Before we say our goodbyes, we'll look at a simple tank-defense game that implements some of the concepts that we've learned to achieve a cohesive "game," and I only say "game" because this is more of a blueprint for you to expand upon and play with. In this chapter, we will:</p>
<ul>
<li>Integrate some of the systems we've learned in a single project</li>
<li>Create an AI tower agent</li>
<li>Create our <kbd>NavMeshAgent</kbd> tank</li>
<li>Set up the environment</li>
<li>Test our sample scene</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the rules</h1>
                
            
            
                
<p>Our "game" is quite simple. While the actual game logic, such as health, damage, and win conditions, are left completely up to you, our example focuses on setting you up to implement your own tank-defense game.</p>
<p>When deciding on what kind of logic and behavior you'll need from your agent, it's important to have the rules of the game fleshed out beyond a simple idea. Of course, as you implement different features, those rules can change, but having a set of concepts nailed down early on will help you pick the best tools for the job.</p>
<p>It's a bit of a twist on the traditional tower-defense genre. You don't build towers to stop an oncoming enemy; you rather use your abilities to help your tank get through a gauntlet of towers. As your tank traverses the maze, towers along the path will attempt to destroy your tank by shooting explosive projectiles at it. To help your tank get to the other side, you can use two abilities:</p>
<ul>
<li>Boost: This ability doubles your tank's movement speed for a short period of time. This is great for getting away from a projectile in a bind.</li>
<li>Shield: This creates a shield around your tank for a short period of time to block oncoming projectiles.</li>
</ul>
<p>For our example, we'll implement the towers using a finite state machine, since they have a limited number of states and don't require the extra complexity of a behavior tree. The towers will also need to be able to be aware of their surroundings, or more specifically, whether the tank is nearby so that they can shoot at it, so we'll use a sphere trigger to model the towers' field of vision and sensing. The tank needs to be able to navigate the environment on its own, so we use a NavMesh and <kbd>NavMeshAgent</kbd> to achieve this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the towers</h1>
                
            
            
                
<p>In the sample project for this chapter, you'll find a <kbd>Tower</kbd> prefab in the <kbd>Prefabs</kbd> folder. The tower itself is quite simple; it's just a group of primitives arranged to look like a cannon, as you can see in the following screenshot:</p>
<div><img height="191" width="234" src="img/8c253632-3fee-4b44-b674-d37b4eea57e8.png"/></div>
<p>Our beautiful primitive shape tower</p>
<p>The barrel of the gun is affixed to the spherical part of the tower. The gun can rotate freely on its axis when tracking the player so that it can fire in the direction of its target, but it is immobile in every other way. Once the tank gets far enough away, the tower cannot chase it or reposition itself.</p>
<p>In the sample scene, there are several towers placed throughout the level. As they are prefabbed, it's very easy to duplicate towers, move them around, and reuse them between the levels. Their setup is not terribly complicated either. Their hierarchy looks similar to the following screenshot:</p>
<div><img height="56" width="287" src="img/d88c2f8d-30dd-4faa-a529-042495e9e0a2.png"/></div>
<p>The Tower hierarchy in the inspector</p>
<p>The breakdown of the hierarchy is as follows:</p>
<ul>
<li><kbd>Tower</kbd>: Technically, this is the base of the tower: the cylinder that holds the rest of it up. This serves no function but to hold the rest of the parts.</li>
<li><kbd>Gun</kbd>: The gun is where most of the magic happens. It is the sphere mounted on the tower with the barrel on it. This is the part of the tower that moves and tracks the player.</li>
<li><kbd>Barrel</kbd> and <kbd>Muzzle</kbd>: The muzzle is located at the tip of the barrel. This is used as the spawn point for the bullets that come out of the gun.</li>
</ul>
<p>We mentioned that the gun is where the business happens for the tower, so let's dig in a bit deeper. The inspector with the gun selected looks similar to the following screenshot:</p>
<div><img height="584" width="430" src="img/b5875c68-5e83-4409-9ddb-00d306ef04f7.png"/></div>
<p>The inspector for the gun</p>
<p>There is quite a bit going on in the inspector here. Let's look at each of the components that affect the logic:</p>
<ul>
<li>Sphere Collider: This is essentially the tower's range. When the tank enters this sphere, the tower can detect it and will lock on to it to begin shooting at it. This is our implementation of perception for the tower. Notice that the radius is set to <kbd>7</kbd>. The value can be changed to whatever you like, but <kbd>7</kbd> seems to be a fair value. Also, note that we set the Is Trigger checkbox to true. We don't want this sphere to actually cause collisions, just to fire trigger events.</li>
<li>Rigidbody: This component is required for the collider to actually work properly, whether objects are moving or not. This is because Unity does not send collision or trigger events to game objects that are not moving, unless they have a <kbd>Rigidbody</kbd> component.</li>
<li>Tower: This is the logic script for the tower. It works in tandem with the state machine and the state machine behavior, but we'll look at these components in moreÂ depth shortly.</li>
<li>Animator: This is our tower's state machine. It doesn't actually handle animation.</li>
</ul>
<p>Before we look at the code that drives the tower, let's take a brief look at the state machine. It's not terribly complicated, as you can see in the following screenshot:</p>
<div><img src="img/bb39c091-8d25-4171-aa58-dd855b10c11d.png"/></div>
<p>The state machine for the tower</p>
<p>There are two states that we care about: <kbd>Idle</kbd> (the default state) and <kbd>LockedOn</kbd>. The transition from <kbd>Idle</kbd> to <kbd>LockedOn</kbd> happens when the <kbd>TankInRange</kbd> bool is set to <kbd>true</kbd>, and the reverse transition happens when the bool is set to <kbd>false</kbd>.</p>
<p>The <kbd>LockedOn</kbd> state has a <kbd>StateMachineBehaviour</kbd> class attached to it, which we'll look at next:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class LockedOnState : StateMachineBehaviour { 
 
    GameObject player; 
    Tower tower; 
 
   // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state 
    override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
        player = GameObject.FindWithTag("Player"); 
        tower = animator.gameObject.GetComponent&lt;Tower&gt;(); 
        tower.LockedOn = true; 
    } 
 
     //OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks 
  override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
        animator.gameObject.transform.LookAt(player.transform); 
  } 
 
  // OnStateExit is called when a transition ends and the state machine finishes evaluating this state 
    override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
        animator.gameObject.transform.rotation = Quaternion.identity; 
        tower.LockedOn = false; 
    } 
} </pre>
<p>When we enter the state and <kbd>OnStateEnter</kbd> is called, we find a reference to our player. In the provided example, the player is tagged as <kbd>"Player"</kbd> so that we are able to get a reference to it using <kbd>GameObject.FindWithTag</kbd>. Next, we fetch a reference to the <kbd>Tower</kbd> component attached to our tower prefab and set its <kbd>LockedOn</kbd> bool to <kbd>true</kbd>.</p>
<p>As long as we're in the state, <kbd>OnStateUpdate</kbd> gets called on each frame. Inside this method, we get a reference to the <kbd>Gun GameObject</kbd> (which the <kbd>Tower</kbd> component is attached to) via the provided <kbd>Animator</kbd> reference. We use this reference to the gun to have it track the tank using <kbd>Transform.LookAt</kbd>.</p>
<p>Alternatively, as the <kbd>LockedOn</kbd> bool of the <kbd>Tower</kbd> is set to <kbd>true</kbd>, this logic could be handled in the <kbd>Tower.cs</kbd> script instead.</p>
<p>Lastly, as we exit the state, <kbd>OnStateExit</kbd> gets called. We use this method to do a little cleanup. We reset the rotation of our gun to indicate that it is no longer tracking the player, and we set the tower's <kbd>LockedOn</kbd> bool back to <kbd>false</kbd>.</p>
<p>As we can see, this <kbd>StateMachineBehaviour</kbd> interacts with the <kbd>Tower.cs</kbd> script, so let's look at <kbd>Tower.cs</kbd> next for a bit more context as to what's happening:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class Tower : MonoBehaviour { 
    [SerializeField] 
    private Animator animator; 
 
    [SerializeField] 
    private float fireSpeed = 3f; 
    private float fireCounter = 0f; 
    private bool canFire = true; 
 
    [SerializeField] 
    private Transform muzzle; 
    [SerializeField] 
    private GameObject projectile; 
 
    private bool isLockedOn = false; 
 
    public bool LockedOn { 
        get { return isLockedOn; } 
        set { isLockedOn = value; } 
    } </pre>
<p>First up, we declare our variables and properties.</p>
<p>We need a reference to our state machine; this is where the <kbd>Animator</kbd> variable comes in. The next three variables, <kbd>fireSpeed</kbd>, <kbd>fireCounter</kbd>, and <kbd>canFire</kbd>, all relate to our tower's shooting logic. We'll see how that works later.</p>
<p>As we mentioned earlier, the muzzle is the location the bullets will spawn from when shooting. The projectile is the prefab we're going to instantiate.</p>
<p>Lastly, <kbd>isLockedOn</kbd> is get and set via <kbd>LockedOn</kbd>. While this book, in general, strays away from enforcing any particular coding convention, it's generally a good idea to keep values private unless explicitly required to be public, so instead of making <kbd>isLockedOn</kbd> public, we provide a property for it to access it remotely (in this case, from the <kbd>LockedOnState</kbd> behavior):</p>
<pre>private void Update() { 
        if (LockedOn &amp;&amp; canFire) { 
            StartCoroutine(Fire()); 
        } 
    } 
 
    private void OnTriggerEnter(Collider other) { 
        if (other.tag == "Player") { 
            animator.SetBool("TankInRange", true); 
        } 
    } 
 
    private void OnTriggerExit(Collider other) { 
        if (other.tag == "Player") { 
            animator.SetBool("TankInRange", false); 
        } 
    } 
 
    private void FireProjectile() { 
        GameObject bullet = Instantiate(projectile, muzzle.position, muzzle.rotation) as GameObject; 
        bullet.GetComponent&lt;Rigidbody&gt;().AddForce(muzzle.forward * 300); 
    } 
 
    private IEnumerator Fire() { 
        canFire = false; 
        FireProjectile(); 
        while (fireCounter &lt; fireSpeed) { 
            fireCounter += Time.deltaTime; 
            yield return null; 
        } 
        canFire = true; 
        fireCounter = 0f; 
    } 
}</pre>
<p>Next up, we have all our methods, and the meat and potatoes of the tower logic. Inside the <kbd>Update</kbd> loop, we check for two thingsâare we locked on, and can we fire? If both are true, we fire off our <kbd>Fire()</kbd> coroutine. We'll look at why <kbd>Fire()</kbd> is a coroutine before coming back to the <kbd>OnTrigger</kbd> messages.</p>
<p>Coroutines can be a tricky concept to grasp if you're not already familiar with them. For more information on how to use them, check out Unity's documentation at <a href="http://docs.unity3d.com/Manual/Coroutines.html">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p>
<p>As we don't want our tower to be able to constantly shoot projectiles at the tank like a projectile-crazy death machine, we use the variables that we defined earlier to create a cushion between each shot. After we call <kbd>FireProjectile()</kbd> and set <kbd>canFire</kbd> to <kbd>false</kbd>, we start a counter from 0 up to <kbd>fireSpeed</kbd>, before we set <kbd>canFire</kbd> to <kbd>true</kbd> again. The <kbd>FireProjectile()</kbd> method handles the instantiation of the projectile and shoots it out toward the direction the gun is pointing to using <kbd>Rigidbody.AddForce</kbd>. The actual bullet logic is handled elsewhere, but we'll look at that later.</p>
<p>Lastly, we have our two <kbd>OnTrigger</kbd> eventsâone for when something enters the trigger attached to this component and another for when an object leaves said trigger. Remember the <kbd>TankInRange</kbd> bool that drives the transitions for our state machine? This variable gets set to <kbd>true</kbd> here when we enter the trigger and back to <kbd>false</kbd> as we exit. Essentially, when the tank enters the gun's sphere of "vision," it instantly locks on to the tank, and the lock is released when the tank leaves the sphere.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making the towers shoot</h1>
                
            
            
                
<p>If we look back at our <kbd>Tower</kbd> component in the inspector, you'll notice that a prefab named <kbd>bullet</kbd> is assigned to the <kbd>projectile</kbd> variable. This prefab can be found in the <kbd>Prefabs</kbd> folder of the sample project. The prefab looks similar to the following screenshot:</p>
<div><img height="598" width="400" src="img/75bd09a2-4848-4d9f-93a1-56721e3b0711.png"/></div>
<p>The bullet prefab</p>
<p>The <kbd>bullet</kbd> game object is nothing fancy; it's just a bright yellow orb. There is a sphere collider attached to it, and, once again, we must make sure that <kbd>IsTrigger</kbd> is set to <kbd>true</kbd> and it has a <kbd>Rigidbody</kbd> (with <kbd>gravity</kbd> turned <kbd>off</kbd>) attached to it. We also have a <kbd>Projectile</kbd> component attached to the <kbd>bullet</kbd> prefab. This handles the collision logic. Let's take a look at the code:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class Projectile : MonoBehaviour { 
 
    [SerializeField] 
    private GameObject explosionPrefab; 
 
  void Start () {  } 
 
    private void OnTriggerEnter(Collider other) { 
        if (other.tag == "Player" || other.tag == "Environment") { 
            if (explosionPrefab == null) { 
                return; 
            } 
            GameObject explosion = Instantiate(explosionPrefab, transform.position, Quaternion.identity) as GameObject; 
            Destroy(this.gameObject);             
        } 
    } 
}</pre>
<p>We have a fairly straightforward script here. In our level, we have all of the floor and walls tagged as <kbd>"Environment"</kbd>, so in our <kbd>OnTriggerEnter</kbd> method, we check that the trigger this projectile is colliding with is either the player or the environment. If it is, we instantiate an <kbd>explosion</kbd> prefab and destroy the projectile. Let's take a look at the <kbd>explosion</kbd> prefab, which looks similar to this:</p>
<div><img height="619" width="418" src="img/fdb692f3-6d7d-4492-a0b6-aab7c7d06041.png"/></div>
<p>Inspector with the explosion prefab selected</p>
<p>As we can see, there is a very similar game object here; we have a sphere collider with <kbd>IsTrigger</kbd> set to <kbd>true</kbd>. The main difference is an <kbd>animator</kbd> component. When this <kbd>explosion</kbd> is instantiated, it expands as an explosion would, then we use the state machine to destroy the instance when it transitions out of its explosion state. The <kbd>animation</kbd> controller looks similar to the following screenshot:</p>
<div><img height="428" width="986" src="img/fdd64ced-6e0f-4f64-a04b-1b0faf254e31.png"/></div>
<p>The animation controller driving the explosion prefab</p>
<p>You'll notice the <kbd>explode</kbd> state has a behavior attached to it. The code inside this behavior is fairly simple:</p>
<pre>// OnStateExit is called when a transition ends and the state machine finishes evaluating this state 
    override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
        Destroy(animator.gameObject, 0.1f); 
    } </pre>
<p>All we're doing here is destroying the instance of the object when we exit the state, which occurs when the animation ends.</p>
<p>If you want to flesh out the game with your own game logic, this may be a good place to trigger any secondary effects such as damage, environment particles, or anything you can think of!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the tank</h1>
                
            
            
                
<p>The example project also includes a prefab for the tank, which is simply called (you guessed it) <kbd>Tank</kbd>, inside the <kbd>Prefabs</kbd> folder.</p>
<p>The tank itself is a simple agent with one goal: reach the end of the maze. As mentioned earlier, the player has to help the tank out along the way by activating its abilities to keep it safe from oncoming fire from the towers.</p>
<p>By now, you should be fairly familiar with the components you'll encounter along the way, except for the <kbd>Tank.cs</kbd> component attached to the prefab. Let's take a look at the code to figure out what's going on behind the scenes:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class Tank : MonoBehaviour { 
    [SerializeField] 
    private Transform goal; 
    private NavMeshAgent agent; 
    [SerializeField] 
    private float speedBoostDuration = 3; 
    [SerializeField] 
    private ParticleSystem boostParticleSystem; 
    [SerializeField] 
    private float shieldDuration = 3f; 
    [SerializeField] 
    private GameObject shield; 
 
    private float regularSpeed = 3.5f; 
    private float boostedSpeed = 7.0f; 
    private bool canBoost = true; 
    private bool canShield = true; </pre>
<p>There are a number of values that we want to be able to tweak easily, so we declare the corresponding variables first. Everything from the duration of our abilities to the effects associated with them is set here first:</p>
<pre>    private bool hasShield = false; 
private void Start() { 
        agent = GetComponent&lt;NavMeshAgent&gt;(); 
        agent.SetDestination(goal.position); 
    } 
 
    private void Update() { 
        if (Input.GetKeyDown(KeyCode.B)) { 
            if (canBoost) { 
                StartCoroutine(Boost()); 
            } 
        } 
        if (Input.GetKeyDown(KeyCode.S)) { 
            if (canShield) { 
                StartCoroutine(Shield()); 
            } 
        } 
    } </pre>
<p>Our <kbd>Start</kbd> method simply does some setup for our tank; it grabs the <kbd>NavMeshAgent</kbd> component and sets its destination to be equal to our goal variable. We will discussÂ thatÂ in more detail soon.</p>
<p>We use the <kbd>Update</kbd> method to catch the input for our abilities. We've mapped <kbd>B</kbd> to <kbd>boost</kbd> and <kbd>S</kbd> to <kbd>shield</kbd>. As these are timed abilities, much like the towers' ability to shoot, we implement these via coroutines:</p>
<pre>private IEnumerator Shield() { 
        canShield = false; 
        shield.SetActive(true); 
        float shieldCounter = 0f; 
        while (shieldCounter &lt; shieldDuration) { 
            shieldCounter += Time.deltaTime; 
            yield return null; 
        } 
        canShield = true; 
        shield.SetActive(false); 
    } 
 
    private IEnumerator Boost() { 
        canBoost = false; 
        agent.speed = boostedSpeed; 
        boostParticleSystem.Play(); 
        float boostCounter = 0f; 
        while (boostCounter &lt; speedBoostDuration) { 
            boostCounter += Time.deltaTime; 
            yield return null; 
        } 
        canBoost = true; 
        boostParticleSystem.Pause(); 
        agent.speed = regularSpeed; 
    }</pre>
<p>The two abilities' logic is very similar. The <kbd>shield</kbd> enables and disables the <kbd>shield</kbd> game object, which we define in a variable in the inspector, and after an amount of time equal to <kbd>shieldDuration</kbd> has passed, we turn it off and allow the player to use the <kbd>shield</kbd> again.</p>
<p>The main difference in the <kbd>Boost</kbd> code is that rather than enabling and disabling a game object, the <kbd>boost</kbd> calls <kbd>Play</kbd> on a particle system we assign via the inspector and also sets the speed of our <kbd>NavMeshAgent</kbd> to double the original value, before resetting it at the end of the ability's duration.</p>
<p>Can you think of other abilities you'd give the tank? This is a very straightforward pattern that you can use to implement new abilities in your own variant of the project. You can also add additional logic to customize the shield and boost abilities here.</p>
<p>The sample scene already has an instance of the tank in it with all the variables properly set up. The inspector for the tank in the sample scene looks similar to the following screenshot:</p>
<div><img height="109" width="344" src="img/cc16eec0-8050-4694-8e02-9b985fe42d2e.png"/></div>
<p>Inspector with the tank instance selected</p>
<p>As you can see in the preceding screenshot, we've assigned the <kbd>Goal</kbd> variable to a transform with the same name, which is located in the scene at the end of the maze we've set up. We can also tweak the duration of our abilities here, which is set to 3 by default. You can also swap out the art for the abilities, be it the particle system used in the boost or the game object used for the shield.</p>
<p>The last bit of code to look at is the code driving the camera. We want the camera to follow the player, but only along its <kbd>z</kbd> value, horizontally down the track. The code to achieve this looks similar to this:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
public class HorizontalCam : MonoBehaviour { 
    [SerializeField] 
    private Transform target; 
 
    private Vector3 targetPositon; 
 
    private void Update() { 
        targetPositon = transform.position; 
        targetPositon.z = target.transform.position.z; 
        transform.position = Vector3.Lerp(transform.position, targetPositon, Time.deltaTime); 
    } 
} </pre>
<p>As you can see, we simply set the target position of the camera equal to its current position on all axes, but we then assign the <em>z</em> axis of the target position to be the same as our target's, which, if you look in the inspector, has been set to the transform of the tank. We then use linear interpolation (<kbd>Vector3.Lerp</kbd>) to smoothly translate the camera from its current position to its target position every frame.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bonus tank abilities</h1>
                
            
            
                
<p>The sample project also includes three bonus tank abilities for you to play with. Of course, you are highly encouraged to modify these abilities or implement your own custom rules, but for the sake of spicing up the example a bit, all you have to do is add the component for each ability you want to add to the tank prefab.</p>
<p>The bonus abilities are:</p>
<ul>
<li><strong>Hulk mode</strong>: Your tank grows in size for a set amount of time. Want a challenge? Implement a health and armor system similar to our <em>HomeRock</em> example from <a href="8db41b31-be4b-432f-a68e-ef13e1f7e03b.xhtml">Chapter 6</a>,Â <em>Behavior Trees,Â </em>and have the buff be represented visually by this ability!</li>
<li><strong>Shrink mode</strong>: It's the opposite of hulk mode, duh! Your tank shrinks for a set period of time. If you're feeling up to the task, try implementing a stealth system where turrets are unable to detect your tank while it's in shrink mode.Â </li>
<li><strong>Time warp, or as I like to call it, DMV mode</strong>: This ability sloooows down time to a crawl. If you want a real challenge, try implementing a selective weapon system, where the turrets could try to outsmart you by using a faster projectile to counter your time warp mode!</li>
</ul>
<p>Where you take the abilities system is up to you. It's always fun to see what different directions readers take their own versions of these samples. If you have a cool twist on this or any of the previous samples, share them with the author via Twitter (<kbd>@ray_barrera</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the environment</h1>
                
            
            
                
<p>As our tank uses a <kbd>NavMeshAgent</kbd> component to traverse the environment, we need to set up our scene using static game objects for the bake process to work properly, as we learned in <a href="503803fe-f343-4a0c-835f-463c98005182.xhtml">Chapter 4</a>, <em>Finding Your Way</em>. The maze is set up in a way so that towers are spread out fairly reasonably and the tank has plenty of space to maneuver around easily. The following screenshot shows the general layout of the maze:</p>
<div><img height="257" width="286" src="img/4bf0c3e1-c60e-458d-8baf-bfb1b5edb461.png"/></div>
<p>The gauntlet our tank must run through</p>
<p>As you can see, there are seven towers spread out through the maze and a few twists and turns for our tank to break line of sight. In order to avoid having our tank graze the walls, we adjust the settings in the navigation window to our liking. By default, the example scene has the agent radius set to 1.46 and the step height to 1.6. There are no hard rules for how we arrived at these numbers; it is just trial and error.</p>
<p>After baking the NavMesh, we'll end up with something similar to what's shown in the following screenshot:</p>
<div><br/>
<img height="260" width="411" class="aligncenter size-full wp-image-419 image-border" src="img/c4ee0237-7406-4026-ad63-c547bdd65cbb.png"/></div>
<p>The scene after we've baked our NavMesh</p>
<p>Feel free to rearrange the walls and towers to your liking. Just remember that any blocking objects you add to the scene must be marked as static, and you have to rebake the navigation for the scene after you've set everything up just the way you like it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the example</h1>
                
            
            
                
<p>The example scene is ready to play right out of the box, so if you didn't get the itch to modify any of the default settings, you can just hit the play button and watch your tank go. You'll notice we've added a canvas with a label explaining the controls to the player. There is nothing fancy going on here; it's just a simple "press this button to do that" kind of instruction:</p>
<div><img height="59" width="166" src="img/e899a045-605f-4b1e-bc92-f739d2dcc60c.png"/></div>
<p>Simple instructions to guide the player</p>
<p>The example project is a great example to expand upon and to have fun with. With the concepts learned throughout this book, you can expand on the types of towers, the tank's abilities, the rules, or even give the tank more complex, nuanced behavior. For now, we can see that the concepts of state machines, navigation, perception and sensing, and steering, all come together in a simple yet amusing example. The following screenshot shows the game in action:</p>
<div><img height="267" width="351" src="img/ac4727ce-e444-4ad3-993a-a278e212ef14.png"/></div>
<p>The tank-defense game in action</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>So, we've reached the end. In this chapter, we took a few of the concepts covered in the book and applied them to create a small tank-defense game. We built upon the concept of finite state machines, which we originally covered in <a href="9e338555-162c-4ed0-a519-035cfcea94ce.xhtml">Chapter 2</a>, <em>Finite State Machines and You</em>, and created an artificial intelligence to drive our enemy towers' behavior. We then enhanced the behavior by combining it with sensing and perception, and finally we implemented navigation via Unity's NavMesh feature to help our tank AI navigate through our maze-like level, through a gauntlet of autonomous AI towers with one thing on their simple AI minds: destroy!</p>
<p>As we conclude this book, take a moment and pat yourself on the back! We've covered a lot of ground, and covered a lot of topics. You've now learned about state machines, behavior trees, A*, fuzzy logic, and so much more. What's most exciting is to think of all the ways in which you can mix-and-match and apply these concepts. Hopefully, throughout this book you've been thinking of ways to enhance your existing or upcoming games with these concepts. You now have the tools to create smarter inhabitants for your digital worlds. Good luck!</p>


            

            
        
    </body></html>