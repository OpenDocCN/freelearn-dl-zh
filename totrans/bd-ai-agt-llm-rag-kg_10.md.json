["```py\npip install streamlit\n```", "```py\nstreamlit run my_app.py\n```", "```py\nstreamlit run https://raw.githubusercontent.com/streamlit/my_apps/master/my_app.py\n```", "```py\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\n# Title for the app\nst.title(\"Simple Streamlit App with Box Plot\")\n# Create a sample DataFrame\ndata = {\n    'Category': ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'],\n    'Values': [10, 20, 15, 25, 30, 20, 35, 40, 45]\n}\ndf = pd.DataFrame(data)\n# Display the DataFrame\nst.write(\"Here is the sample DataFrame:\")\nst.dataframe(df)\n# Create a box plot\nfig, ax = plt.subplots()\ndf.boxplot(column='Values', by='Category', ax=ax, grid=False)\nplt.title(\"Box Plot of Values by Category\")\nplt.suptitle(\"\")  # Remove the automatic subtitle\nplt.xlabel(\"Category\")\nplt.ylabel(\"Values\")\n# Display the plot in Streamlit\nst.pyplot(fig)\n```", "```py\ndf = pd.DataFrame(data)\nst.dataframe(df.style.highlight_max(axis=0))\n```", "```py\ncity_data = {\n    'City': ['Palermo', 'Syracuse', 'Catania', 'Agrigento'],\n    'latitude': [38.1157, 37.0757, 37.5079, 37.2982],\n    'longitude': [13.3615, 15.2867, 15.0830, 13.5763]\n}\ncity_data = pd.DataFrame(city_data)\nst.map(city_data)\n```", "```py\nst.write(city_data)\n```", "```py\nimport streamlit as st\nimport time\n# Use @st.cache_data to cache the result\n@st.cache_data\ndef load_data():\n    time.sleep(3)  # Simulate a slow operation (e.g., loading a large dataset)\n    return \"Data loaded!\"\n# Call the function\nst.write(load_data())\nin a similar way for st.cache_resource:\nimport streamlit as st\nimport time\n# Example: A resource-intensive function (e.g., loading a model)\n@st.cache_resource\ndef load_model():\n    time.sleep(5)  # Simulate a slow operation like loading a model\n    return \"Model loaded!\"  # This could be a model object in a real scenario\n# Call the function\nst.write(load_model())\n```", "```py\nimport streamlit as st\n# Define a list of grocery items (the initial list of items to buy)\ngrocery_items = ['Apple', 'Banana', 'Carrot', 'Milk', 'Eggs']\n# Streamlit app interface\nst.title('Grocery List App')\n# Text input to add a new item to the list\nnew_item = st.text_input(\"Add a new item to your grocery list:\")\n# Button to add the new item to the list\nif st.button('Add Item'):\n    if new_item:\n        grocery_items.append(new_item)\n        st.success(f\"'{new_item}' has been added to your list!\")\n    else:\n        st.warning(\"Please enter an item to add.\")\n# Display the current list of grocery items\nst.write(\"### Items to Buy:\")\nfor item in grocery_items:\n    st.write(f\"- {item}\")\n```", "```py\nimport streamlit as st\n# Initialize session state for grocery_items if it doesn't exist yet\nif 'grocery_items' not in st.session_state:\n    st.session_state.grocery_items = ['Apple', 'Banana', 'Carrot', 'Milk', 'Eggs']\n# Streamlit app interface\nst.title('Grocery List App')\n# Text input to add a new item to the list\nnew_item = st.text_input(\"Add a new item to your grocery list:\")\n# Button to add the new item to the list\nif st.button('Add Item'):\n    if new_item:\n        # Append the new item to the list stored in session state\n        st.session_state.grocery_items.append(new_item)\n        st.success(f\"'{new_item}' has been added to your list!\")\n    else:\n        st.warning(\"Please enter an item to add.\")\n# Display the current list of grocery items\nst.write(\"### Items to Buy:\")\nfor item in st.session_state.grocery_items:\n    st.write(f\"- {item}\")\n```", "```py\nimport streamlit as st\nconn = st.connection(\"my_database_sql\")\ndf = conn.query(\"select * from my_beautiful_table\")\nst.dataframe(df)\n```", "```py\nst.title(\"Your Title Here\")\nst.header(\"Your Header Here\")\nst.header(\"Your Header Here\", divider=True, help =\"bla bla\")\nst.subheader(\"Your Subheader Here\")\n```", "```py\nimport streamlit as st\n# Initialize session state for grocery_items if it doesn't exist yet\nif 'grocery_items' not in st.session_state:\n    st.session_state.grocery_items = ['Apple', 'Banana', 'Carrot', 'Milk', 'Eggs']\n# Streamlit app interface\nst.title('Grocery List App :banana: :apple: :egg:')  # Main title of the app\n# Display a header for the section where the user can add items\nst.header('Add new item')\n# Text input to add a new item to the list\nnew_item = st.text_input(\"Type an item to add to your grocery list:\")\n# Button to add the new item to the list\nif st.button('Add Item'):\n    if new_item:\n        # Append the new item to the list stored in session state\n        st.session_state.grocery_items.append(new_item)\n        st.success(f\"'{new_item}' has been added to your list!\")\n    else:\n        st.warning(\"Please enter an item to add.\")\n# Display a subheader for the current grocery list\nst.subheader('Current Grocery List')\n# Display the current list of grocery items\nfor item in st.session_state.grocery_items:\n    st.write(f\"- {item}\")\n```", "```py\n# Set the page configuration to include a logo\nst.set_page_config(page_title=\"Grocery List App\", page_icon=\"https://github.com/SalvatoreRa/tutorial/blob/main/images/vegetable_basket_logo.jpg?raw=true\")\n# Display the title image\nst.image(\"https://github.com/SalvatoreRa/tutorial/blob/main/images/vegetables.jpg?raw=true\", use_column_width=True)\nst.caption(\"Image from [here](https://unsplash.com/it/@randyfath)\")\n# Add logo to the sidebar\nst.sidebar.image(\"https://github.com/SalvatoreRa/tutorial/blob/main/images/vegetable_basket_logo.jpg?raw=true\", use_column_width=True)\n```", "```py\ndata = []\nfor i, item in enumerate(st.session_state.grocery_items):\n    with col1 if i % 2 == 0 else col2:\n        st.markdown(f\"**{item}**\")\n        quantity_at_home = st.slider(f\"Quantity at home\", 0, 12, st.session_state.quantity_at_home[item], key=f\"home_{item}\")\n        st.session_state.quantity_at_home[item] = quantity_at_home\n        quantity_to_take = st.slider(f\"Quantity to take\", 0, 12, st.session_state.quantity_to_take[item], key=f\"take_{item}\")\n        st.session_state.quantity_to_take[item] = quantity_to_take\n        taken = st.checkbox(f\"Taken\", st.session_state.taken[item], key=f\"taken_{item}\")\n        st.session_state.taken[item] = taken\n        data.append([item, quantity_at_home, quantity_to_take, \"Yes\" if taken else \"No\"])\n```", "```py\ndf = pd.DataFrame(data, columns=[\"Name\", \"Quantity at Home\", \"Quantity to Take\", \"Taken\"])\nst.table(df)\n```", "```py\n# Progress bar\ntaken_count = sum(1 for item in st.session_state.taken.values() if item)\ntotal_items = len(st.session_state.grocery_items)\nprogress = taken_count / total_items if total_items > 0 else 0\nst.subheader(\"Grocery Completion Progress\")\nst.progress(progress)\nst.write(f\"{taken_count} out of {total_items} items taken ({progress*100:.2f}%)\")\n```", "```py\n# Function to generate PDF\ndef generate_pdf():\n    pdf = FPDF()\n    pdf.set_auto_page_break(auto=True, margin=15)\n    pdf.add_page()\n    pdf.set_font(\"Arial\", size=12)\n    logo_path = \"logo.jpg\"  # Add logo to PDF\n    response = requests.get(logo_url)\n    with open(logo_path, \"wb\") as f:\n        f.write(response.content)\n    pdf.image(logo_path, 10, 10, 30)  # Position and size of the logo\n    pdf.cell(200, 10, \"Grocery List\", ln=True, align='C')\n    pdf.ln(20)  # Added extra spacing to prevent text overlapping the logo\n    for index, row in df.iterrows():\n        pdf.cell(0, 10, f\"{row['Name']} - At Home: {row['Quantity at Home']} - To Take: {row['Quantity to Take']} - Taken: {row['Taken']}\", ln=True)\n    pdf_output = os.path.join(os.getcwd(), \"grocery_list.pdf\")\n    pdf.output(pdf_output)\n    return pdf_output\n# Directly download the PDF when the button is clicked\nif st.sidebar.button(\"Download List as PDF\"):\n    pdf_file = generate_pdf()\n    with open(pdf_file, \"rb\") as f:\n        st.sidebar.download_button(\"Download Grocery List PDF\", f, file_name=\"grocery_list.pdf\", mime=\"application/pdf\", key=\"download_pdf\", on_click=None)\n```", "```py\nelif page == \"Notes\":\n    st.title(\"Notes\")\n    st.session_state.notes = st.text_area(\"Write your notes here:\", st.session_state.notes)\n    if st.button(\"Save Notes\"):\n        st.success(\"Notes saved successfully!\")\n```", "```py\nelif page == \"Find Supermarkets\":\n    st.title(\"Find Nearby Supermarkets (OSM)\")\n        # Get user's location\n    location_input = st.text_input(\"Enter your location (City, Address, or Coordinates):\")\n    if st.button(\"Find Supermarkets\") and location_input:\n        geolocator = Nominatim(user_agent=\"grocery_app\")\n        location = geolocator.geocode(location_input)\n        if location:\n            st.success(f\"Location found: {location.address}\")\n            # Create map\n            m = folium.Map(location=[location.latitude, location.longitude], zoom_start=14)\n            folium.Marker([location.latitude, location.longitude], tooltip=\"Your Location\", icon=folium.Icon(color=\"blue\")).add_to(m)\n            # Use Overpass API to find nearby supermarkets\n            overpass_url = \"http://overpass-api.de/api/interpreter\"\n            overpass_query = f\"\"\"\n            [out:json];\n            node[\"shop\"=\"supermarket\"](around:5000,{location.latitude},{location.longitude});\n            out;\n            \"\"\"\n            response = requests.get(overpass_url, params={'data': overpass_query})\n            data = response.json()\n            for element in data[\"elements\"]:\n                lat, lon = element[\"lat\"], element[\"lon\"]\n                name = element.get(\"tags\", {}).get(\"name\", \"Unnamed Supermarket\")\n                folium.Marker([lat, lon], tooltip=name, icon=folium.Icon(color=\"green\")).add_to(m)\n            folium_static(m)\n        else:\n            st.error(\"Location not found. Please try a different input.\")\n```", "```py\nimport streamlit as st\nimport numpy as np\nimport pandas as pd\nimport pydeck as pdk\nimport openai\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sentence_transformers import SentenceTransformer\n```", "```py\nclass ItineraryPlannerAgent:\n    def __init__(self, api_key):\n        self.api_key = api_key\n    def create_itinerary(self, destination, best_month, hotel, duration):\n        client = openai.OpenAI(api_key=self.api_key)\n        prompt = f\"\"\"\n        Create a {duration}-day travel itinerary for {destination} in the best month: {best_month}.\n        Recommended Hotel: {hotel['name']}.\n        \"\"\"\n        response = client.chat.completions.create(\n            model=\"gpt-4\",\n            messages=[\n                {\"role\": \"system\", \"content\": \"You are an expert travel planner.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            max_tokens=300\n        )\n        return response.choices[0].message.content\n```", "```py\nopenai_api_key = st.secrets[\"general\"][\"openai_api_key\"]\nweather_agent = WeatherAnalysisAgent()\nhotel_agent = HotelRecommenderAgent()\nitinerary_agent = ItineraryPlannerAgent(api_key=openai_api_key)\nweather_agent.train(historical_weather_data)\nhotel_agent.add_hotels(hotels_database)\nYour API should be in a file TOML, like this:\n[general]\nopenai_api_key = \"YOUR_API\"\n```", "```py\nst.title(\"AI Travel Planner ✈️\")\nst.write(\"Find the best time to travel and discover the perfect hotel!\")\ndestination = st.text_input(\"Enter your destination (e.g., Rome):\", \"Rome\")\npreferences = st.text_area(\"Describe your ideal hotel:\", \"Luxury hotel in city center with spa.\")\nduration = st.slider(\"Trip duration (days):\", 1, 14, 5)\n```", "```py\nif st.button(\"Generate Travel Plan ✨\"):\n    best_months = weather_agent.predict_best_time({'latitude': 41.9028, 'longitude': 12.4964})\n    best_month = best_months[0]['month']\n    recommended_hotels = hotel_agent.find_hotels(preferences)\n    itinerary = itinerary_agent.create_itinerary(destination, best_month, recommended_hotels[0], duration)\n    st.subheader(\"📆 Best Months to Visit\")\n    for m in best_months:\n        st.write(f\"Month {m['month']}: Score {m['score']:.2f}\")\n    st.subheader(\"🏨 Recommended Hotel\")\n    st.write(f\"**{recommended_hotels[0]['name']}** - {recommended_hotels[0]['description']}\")\n    st.subheader(\"📜 Generated Itinerary\")\n    st.write(itinerary)\n    # -------------------------------\n    # Interactive Map\n    # -------------------------------\n    st.subheader(\"🗺 Destination Map\")\n    map_data = pd.DataFrame(\n        {'lat': [41.9028], 'lon': [12.4964]},\n    )\n    st.map(map_data)\n```", "```py\n    try:\n         response = client.chat.completions.create(\n             model=\"gpt-4\",\n             messages=[...],\n             timeout=10           # optional timeout\n         )\n         return response.choices[0].message.content\n    except openai.RateLimitError:\n         st.error(\"Rate limit exceeded. Please try again later.\")\n    except openai.APIError as e:\n         st.error(f\"OpenAI API error: {str(e)}\")\n    except Exception as e:\n         st.error(f\"Unexpected error: {str(e)}\")\n    ```", "```py\n    import time\n     import random\n    def call_openai_with_retry(prompt, retries=3):\n         for i in range(retries):\n             try:\n                 return client.chat.completions.create(\n                     model=\"gpt-4\",\n                     messages=[ {\"role\": \"user\", \"content\": prompt}]\n                 )\n            except openai.APIError:\n                 wait = 2 ** i + random.random()\n                 time.sleep(wait)\n        st.error(\"Failed after multiple retries.\")    return None\n    ```", "```py\n    import logging\n     logging.basicConfig(level=logging.INFO)\n     logger = logging.getLogger(__name__)\n    try:\n         logger.info(\"Calling OpenAI API\")\n         response = client.chat.completions.create(...)\n    except Exception as e:\n         logger.exception(\"API call failed\")\n         st.error(\"Something went wrong.\")\n    ```", "```py\n    [general]\n     openai_api_key = \"application-api-key\"\n    ```", "```py\n    import openai\n     openai.api_key = st.secrets[\"general\"][\"openai_api_key\"]\n    ```", "```py\n    export OPENAI_API_KEY=\"your-api-key\"\n    ```", "```py\n    import os\n    openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n    ```", "```py\n    export OPENAI_API_KEY=\"your-api-key\"\n     streamlit run app.py\n    nano ~/.bashrc\n    ```", "```py\n# Minimal python image\n FROM python:3.11-slim\nWORKDIR /app\nCOPY requirements.txt .\n RUN pip install --no-cache-dir -r requirements.txt\nCOPY . .\n# Create and use a non-root user through the keyword USER\n RUN useradd -m appuser\n USER appuser\nCMD [\"streamlit\", \"run\", \"app.py\"]\n```", "```py\n# Runtime execution\n docker run -e OPENAI_API_KEY=\"your-api-key\" my-streamlit-app\n```", "```py\nimport asyncio\nasync def my_coroutine():\n    print(\"Hello, world!\")\n# Create an event loop and run the coroutine\nasyncio.run(my_coroutine())\n```", "```py\nasync def task1():\n    await asyncio.sleep(2)\n    print(\"Task 1 completed!\")\nasync def task2():\n    await asyncio.sleep(1)\n    print(\"Task 2 completed!\")\nasync def main():\n    await asyncio.gather(task1(), task2())  # Run both tasks concurrently\nasyncio.run(main())\n```", "```py\nimport asyncio\nasync def task1():\n    await asyncio.sleep(2)\n    print(\"Task 1 completed!\")\nasync def task2():\n    await asyncio.sleep(1)\n    print(\"Task 2 completed!\")\nasync def main():\n    t1 = asyncio.create_task(task1())\n    t2 = asyncio.create_task(task2())\n    # Both tasks start running in the background immediately\n    await t1\n    await t2\nasyncio.run(main())\n```", "```py\nimport requests\nimport time\ndef fetch_url(url):\n    response = requests.get(url)\n    return f\"Fetched {url}\"\ndef sync_fetch():\n    urls = ['https://httpbin.org/get'] * 5  # Simulating 5 requests to the same URL\n    results = [fetch_url(url) for url in urls]\n    for result in results:\n        print(result)\ndef main():\n    start_time = time.time()\n    sync_fetch()\n    end_time = time.time()\n    print(f\"Synchronous version took {end_time - start_time:.4f} seconds\")\n# Run the synchronous example\nmain()\n```", "```py\nimport asyncio\nimport aiohttp\nimport time\nasync def fetch_url(session, url):\n    async with session.get(url) as response:\n        await response.text()  # Simulate processing the response\n        return f\"Fetched {url}\"\nasync def async_fetch():\n    urls = ['https://httpbin.org/get'] * 5  # Simulating 5 requests to the same URL\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        for result in results:\n            print(result)\nasync def main():\n    start_time = time.time()\n    await async_fetch()\n    end_time = time.time()\n    print(f\"Asynchronous version took {end_time - start_time:.4f} seconds\")\n# Directly calling the asynchronous function in Jupyter\nawait main()\n```", "```py\nimport time\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\ndef train_and_evaluate_model(n_estimators, max_depth, min_samples_split, min_samples_leaf):\n    # Load dataset\n    data = load_iris()\n    X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.2, random_state=42)\n        # Initialize and train the model\n    model = RandomForestClassifier(\n        n_estimators=n_estimators,\n        max_depth=max_depth,\n        min_samples_split=min_samples_split,\n        min_samples_leaf=min_samples_leaf\n    )\n    model.fit(X_train, y_train)\n     # Evaluate the model\n    predictions = model.predict(X_test)\n    accuracy = accuracy_score(y_test, predictions)\n        return (n_estimators, max_depth, min_samples_split, min_samples_leaf, accuracy)\ndef tune_hyperparameters():\n    n_estimators_values = [10, 50, 100, 150, 200]  # Hyperparameter values to tune\n    max_depth_values = [5, 10, None]\n    min_samples_split_values = [2, 5]\n    min_samples_leaf_values = [1, 2, 4]\n    results = []\n    for n_estimators in n_estimators_values:\n        for max_depth in max_depth_values:\n            for min_samples_split in min_samples_split_values:\n                for min_samples_leaf in min_samples_leaf_values:\n                    results.append(train_and_evaluate_model(n_estimators, max_depth, min_samples_split, min_samples_leaf))\n        # Find the best hyperparameters and accuracy\n    best_params = max(results, key=lambda x: x[4])\n    print(f\"Best hyperparameters: {best_params[:4]} with accuracy: {best_params[4]:.4f}\")\n# Measure time for synchronous execution\nstart_time = time.time()\ntune_hyperparameters()\nend_time = time.time()\nprint(f\"Synchronous version took {end_time - start_time:.4f} seconds\")\n```", "```py\nimport asyncio\nimport time\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nasync def train_and_evaluate_model(n_estimators, max_depth, min_samples_split, min_samples_leaf):\n    # Load dataset\n    data = load_iris()\n    X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.2, random_state=42)\n    # Initialize and train the model\n    model = RandomForestClassifier(\n        n_estimators=n_estimators,\n        max_depth=max_depth,\n        min_samples_split=min_samples_split,\n        min_samples_leaf=min_samples_leaf\n    )\n    model.fit(X_train, y_train)\n    # Evaluate the model\n    predictions = model.predict(X_test)\n    accuracy = accuracy_score(y_test, predictions)\n    return (n_estimators, max_depth, min_samples_split, min_samples_leaf, accuracy)\nasync def tune_hyperparameters():\n    n_estimators_values = [10, 50, 100, 150, 200]  # Hyperparameter values to tune\n    max_depth_values = [5, 10, None]\n    min_samples_split_values = [2, 5]\n    min_samples_leaf_values = [1, 2, 4]\n    tasks = []\n    for n_estimators in n_estimators_values:\n        for max_depth in max_depth_values:\n            for min_samples_split in min_samples_split_values:\n                for min_samples_leaf in min_samples_leaf_values:\n                    tasks.append(train_and_evaluate_model(n_estimators, max_depth, min_samples_split, min_samples_leaf))\n        results = await asyncio.gather(*tasks)\n        # Find the best hyperparameters and accuracy\n    best_params = max(results, key=lambda x: x[4])\n    print(f\"Best hyperparameters: {best_params[:4]} with accuracy: {best_params[4]:.4f}\")\n# Measure time for asynchronous execution\nstart_time = time.time()\nawait tune_hyperparameters()\nend_time = time.time()\nprint(f\"Asynchronous version took {end_time - start_time:.4f} seconds\")\n```"]