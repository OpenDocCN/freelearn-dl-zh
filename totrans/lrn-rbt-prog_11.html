<html><head></head><body><div><div><h1 id="_idParaDest-180"><em class="italic"><a id="_idTextAnchor171"/>Chapter 9</em>: Programming RGB Strips in Python</h1>
			<p>LED lights can be used with a robot to debug and give it feedback so that the code running on the robot can show its state. Colored RGB LEDs let you mix the red, green, and blue components of light to make many colors, adding brightness and color to a robot. We have not paid much attention to making it look fun, so this time we will focus on that.</p>
			<p>Mixing different sequences of LEDs can be used to convey information in real time. You can use which are on/off, their brightness, or their color to represent information. This feedback is easier to read than a stream of text, which will help as sensors are added to the robot. This also means the code on the robot can show state without relying on the SSH terminal to do so.</p>
			<p>In this chapter, we will learn the following:</p>
			<ul>
				<li>What is an RGB strip?</li>
				<li>Comparing light strip technologies</li>
				<li>Attaching the light strip to the Raspberry Pi</li>
				<li>Making a robot display a code object</li>
				<li>Using the light strip for debugging the avoid behavior </li>
				<li>Making a rainbow display with LEDs</li>
			</ul>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor172"/>Technical requirements</h1>
			<p>To build this you will need the following:</p>
			<ul>
				<li>A computer with internet access and Wi-Fi</li>
				<li>The robot, a Raspberry Pi, and the code from the previous chapter</li>
				<li>The Pimoroni LED SHIM</li>
			</ul>
			<p>The code for this chapter is on GitHub at <a href="https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9">https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9</a><a id="_idTextAnchor173"/>.</p>
			<p>Check out the video at the following link to see the Code in Action: <a href="https://bit.ly/39vglXm">https://bit.ly/39vglXm</a>.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor174"/>What is an RGB strip?</h1>
			<p>Using <a id="_idIndexMarker411"/>lights to display data can be a simple yet flexible way to get data to the user without connecting a full display. For example, a single light could be turned on or off to indicate whether a robot is powered on or the state of a simple sensor. A multicolor light can change color to show more detail, to indicate a few different states that the robot is in. RGB in this chapter stands for Red-Green-Blue, so by controlling the intensity levels of these color channels in a light, multiple colors can be shown. We'll investigate how this happens later in the <em class="italic">RGB values</em> section.</p>
			<p>Adding multiple lights lets you show more data. These can be in a strip (a line of lights), as well as panels/matrixes, rings, and other interesting shapes.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor175"/>Comparing light strip technologies</h1>
			<p>There are many competing <a id="_idIndexMarker412"/>technologies for lights and light strips. For light types, incandescent lights, such as old light bulbs, tend to use a lot of power and take up too much space to be useful in robots. Fluorescent lights, such as kitchen strips or curly compact types, need complex power systems that also take up too much space. Electroluminescent wire, also known as EL wire, is often used to decorate objects by outlining them; it looks interesting but is tricky to control. <strong class="bold">Light Emitting Diode</strong> (<strong class="bold">LED</strong>) technology<a id="_idIndexMarker413"/> is low power and tends to be small and easy to control, which makes it best suited for robots such as ours. LEDs are also cheap.</p>
			<p>The most useful kind, in our case, which we will use in this chapter, are addressable RGB LEDs. Addressable means that each individual LED in the strip can be set to different colors and brightness, allowing a sequence of colors along the strip. To keep it simple, we will use a type with a built-in controller.</p>
			<p><em class="italic">Figure 9.1</em> shows some of the types of<a id="_idIndexMarker414"/> addressable RGB LED configurations I have experimented with:</p>
			<div><div><img src="img/B15660_09_01.jpg" alt="" width="1601" height="838"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Types of addressable RGB LEDs</p>
			<p>All of these LED controllers <a id="_idIndexMarker415"/>take a stream of data. Some types, such as the Neopixel, WS2812, SK9822, APA102C, DotStar, and 2801 types, take the red, green, and blue components that they need, and then pass the remaining data to the next LED. Designers arrange these LEDs into strips, rings, or square matrixes, chaining them to take advantage of how they pass the data along. The LED strips can come as rigid sticks or as flexible strips on a reel. For our robot, eight or more LEDs make for a great display.</p>
			<p>There are also some completely different technologies, such as the LED SHIM from Pimoroni and LED matrices in color using shift registers. The Pimoroni LED SHIM<a id="_idIndexMarker416"/> is one of the easiest to use (with a Raspberry Pi) of the LED strips. It houses a controller (the IS31FL3731), which is controlled over the I2C data bus. The Pimoroni LED SHIM has 24 LEDs, which is more than enough to cater to our needs. It doesn't need any extra power handling and is also widely available. </p>
			<p>Our robot uses the I2C data bus for the motor controller, which happily shares with other devices, such as the LED SHIM, by having a different address. I2C instructions are sent as an address for the device, followed by an I2C register to write and a value for it. </p>
			<p>Because of its simplicity and<a id="_idIndexMarker417"/> compatibility with our robot, I will continue this chapter with the Pimoroni LED SHIM. This can be bought from Mouser Electronics in most countries, along with Pimoroni, Adafruit, and SparkFun.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor176"/>RGB values</h2>
			<p>The colors red, green, and <a id="_idIndexMarker418"/>blue can mix to make almost any color combination. Systems express these as RGB values. RGB is the same principle used by most, if not all, color display screens you see. TVs, mobile phones, and computer screens use this. Multicolor LEDs use the same principle to produce many colors. Code usually specifies the amounts of each color to mix as three-number components, as shown in the following diagram:</p>
			<div><div><img src="img/B15660_09_02.jpg" alt="" width="480" height="361"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – The RGB color space [SharkD / CC BY-SA (https://creativecommons.org/licenses/by-sa/3.0)]</p>
			<p>The diagram in <em class="italic">Figure 9.2</em> shows an RGB color cube. It has arrows showing axes for increasing each of the red, green, and blue components. The exposed surfaces of the cube show different shades and intensities as the color combinations mix throughout the cube.</p>
			<p>The corner to the bottom-front-right is blue, the top-front-right is turquoise (mixing blue and green), the bottom-front-left is purple (mixing red and blue), the bottom-far-left is red (with no green or blue), and the top-far-left is yellow (high red and green, no blue). </p>
			<p>As each value is increased, we get different colors from them being mixed. The top-front-left corner would be the maximum of all three – white. The bottom-rear-right corner would be the minimum of all three – black. The cutout shows a color with intensities as fractions.</p>
			<p>In our code, we will use numbers ranging from 0 for absolutely turned off to 255 for full intensity, with values in between for many levels of intensity. The colors are mixed by adding, so adding all of them at full brightness makes white.</p>
			<p>Although this <a id="_idIndexMarker419"/>theoretically gives many colors, in practice, the differences between the intensity of 250 and 255 are not discernible on most RGB LEDs.</p>
			<p>You have seen some of the LED technologies and a little information about how to mix colors for them. We have also made a decision about which technology to use, the Pimoroni LED SHIM. Since we'll be attaching this to our robot, please buy one and come back for the next section.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor177"/>Attaching the light strip to the Raspberry  Pi</h1>
			<p>Before we <a id="_idIndexMarker420"/>write code to display color sequences on the<a id="_idIndexMarker421"/> LED SHIM, we need to attach it to the Raspberry Pi on our robot. After we have finished this section, the robot block diagram will look as in <em class="italic">Figure 9.3</em>:</p>
			<div><div><img src="img/B15660_09_03.jpg" alt="" width="1331" height="610"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The robot block diagram with the LED strip</p>
			<p>The block <a id="_idIndexMarker422"/>diagram now shows the LED strip connected to the <a id="_idIndexMarker423"/>Raspberry Pi, with an arrow indicating information flow from the Raspberry Pi to the strip. The strip is highlighted as a new addition to the system. Let's see how this works.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor178"/>Attaching the LED strip to the robot</h2>
			<p>The Pimoroni LED SHIM<a id="_idIndexMarker424"/> attaches quite readily to the Raspberry Pi. We put it <a id="_idIndexMarker425"/>on top of the motor controller, with its pass-through header, so that we can see the lights on top. Take a look at <em class="italic">Figure 9.4</em> to see how:</p>
			<div><div><img src="img/B15660_09_04.jpg" alt="" width="1478" height="453"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Fitting the LEDs</p>
			<p>Use <em class="italic">Figure 9.4</em> with the following steps to attach the strip:</p>
			<ol>
				<li>The strip is small. Line the strip up with the header pins coming from the top of the motor HAT. You will need to unplug the wires already plugged into the Raspberry Pi to add the SHIM.</li>
				<li>The wider part should be sticking out from the HAT. Gently push the SHIM onto the pins, only a little at first, working across the strip until all the pins are in the holes – it is slightly stiff but should grip on.</li>
				<li>Once all the pins<a id="_idIndexMarker426"/> are in, evenly push the SHIM down so that the pins<a id="_idIndexMarker427"/> mostly stick out.</li>
				<li>Now, you'll need to replace the wires. Refer to <em class="italic">Figure 8.15</em> in <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>, for the distance sensor wiring information.</li>
			</ol>
			<p>Now that you've attached the LED SHIM, this robot is ready to light up. Let's program it.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor179"/>Making a robot display the code object</h1>
			<p>Although <a id="_idIndexMarker428"/>we are building around the Pimoroni LED SHIM, we've already seen that there are other types of RGB LED systems. Since we might later swap the SHIM out for a different system, it would be a good idea to make an interface on top of the LEDs. Like the motor's interface, this decouples handling hardware and making behaviors.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor180"/>Making an LED interface</h2>
			<p>So, what interface do we want <a id="_idIndexMarker429"/>for the LEDs? First, we want them to be available on the robot as <code>robot.leds</code>. We want to clear the LEDs (turn them all off), set each individual LED to a different color, and set a bunch/range of LEDs to a list of colors. </p>
			<p>It's useful for the code to tell us how many LEDs we have, so if the number changes, the animations or displays still make some sense.</p>
			<p>For the colors, we use three values – <code>r</code>, <code>g</code>, and <code>b</code> – to represent the red, green, and blue components. Python has a type<a id="_idIndexMarker430"/> called a <code>color</code> as a parameter, this is a tuple of <code>(r, g, b)</code>.</p>
			<p>The LEDs in strips are addressable, so our code uses an LED number starting at <code>0</code>.</p>
			<p>So, as a structure, our code starts with <code>robot.leds</code>. <code>leds</code> will be a member of the existing <code>robot</code> class. It is an object with these members:</p>
			<ul>
				<li><code>set_one(led_number, color)</code>: This sets one LED at <code>led_number</code> to the specified color.</li>
				<li><code>set_range(led_range, color)</code>: This sets all the LEDs defined by a Python iterable <code>led_range</code> to <code>color</code>. A Python iterable can be a list of LED numbers [<code>0</code>, <code>3</code>], or it can be a range made using the <code>range</code> function. For example, <code>range(2,8)</code> creates the list <code>[2, 3, 4, 5, 6, 7]</code>.</li>
				<li><code>set_all(color)</code>: This sets all of the LEDs to the color.</li>
				<li><code>clear()</code>: This clears all of the LEDs to black, turning them all off.</li>
				<li><code>show()</code>: All of the other methods prepare a display, allowing you to set combinations of LEDs. Nothing is updated on the LED device until your code calls this. This method reflects how most LED strips expect to set all the LEDs from one stream of data. </li>
				<li><code>count</code>: This holds the number of LEDs in the strip.</li>
			</ul>
			<p>Keeping the preceding <a id="_idIndexMarker431"/>points in mind, let's write this code for the LED SHIM:</p>
			<ol>
				<li value="1">First, we need to install the LED SHIM library. So, on the Raspberry Pi, type the following:<pre><strong class="bold">pi@myrobot:~ $ pip3 install ledshim</strong></pre></li>
				<li>Our code must start by importing this and setting up the device. Put the following code in <code>leds_led_shim.py</code> (named after the device type):<pre><code>import ledshim</code> to set the device up.</p><p>We have set up a property for the number of LEDs in our LED class, called <code>count</code>. This property can be read like a variable but is read-only, and our code can't accidentally overwrite it.  </p></li>
				<li>Now, we create the methods to interact with the strip. Setting a single LED is fairly straightforward:<pre><code>(r, g, b)</code>, the LED SHIM library expects them to be separate parameters. Python has a trick for expanding a tuple into a set of parameters by using an asterisk with the variable name. This expansion is what <code>*color</code> means on the second line.</p><p>The LED SHIM code raises <code>KeyError</code> if the user attempts to set an LED out of range.</p></li>
				<li>Setting a bunch of LEDs is also a simple wrapper in our code:<pre><strong class="bold">    def set_range(self, led_range, color):</strong>
<strong class="bold">        ledshim.set_multiple_pixels(led_range, color)</strong></pre></li>
				<li>We also want a way to set all of the LEDs. This code is similar to setting a single LED:<pre><strong class="bold">    def set_all(self, color):</strong>
<strong class="bold">        ledshim.set_all(*color)</strong></pre></li>
				<li>Let's add a method for clearing the LEDs:<pre><strong class="bold">    def clear(self):</strong>
<strong class="bold">        ledshim.clear()</strong></pre></li>
				<li>Finally, we<a id="_idIndexMarker432"/> need the <code>show</code> code, to send the colors we've configured to the LEDs. The Pimoroni LED SHIM library has made this very simple:<pre><strong class="bold">    def show(self):</strong>
<strong class="bold">        ledshim.show()</strong></pre></li>
			</ol>
			<p>We have installed the LED SHIM library and created an interface for ourselves. We can use this interface to communicate with the LEDs, and it is designed to be swapped out for compatible code for a different type of LED device. Now, we'll make this LED interface available in our <code>Robot</code> object. </p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor181"/>Adding LEDs to the Robot object</h2>
			<p>Next, we update <a id="_idIndexMarker433"/>our <code>robot.py</code> file to deal with an LED system. For<a id="_idIndexMarker434"/> this, we do the following:</p>
			<ol>
				<li value="1">Start by adding the <code>leds_led_shim</code> file to the imports (the new code is in bold):<pre>from Raspi_MotorHAT import Raspi_MotorHAT
from gpiozero import DistanceSensor
import atexit
<strong class="bold">import leds_led_shim</strong></pre></li>
				<li>Next, we add an instance of the SHIM to the constructor (<code>init</code>) method for <code>Robot</code> (the new code is in bold): <pre>class Robot:
    def __init__(self, motorhat_addr=0x6f):
       # Setup the motorhat with the passed in address
       self._mh = Raspi_MotorHAT(addr=motorhat_addr)
       # get local variable for each motor
       self.left_motor = self._mh.getMotor(1)
       self.right_motor = self._mh.getMotor(2)
       # Setup The Distance Sensors
       self.left_distance_sensor = DistanceSensor(echo=17, trigger=27, queue_len=2)
        self.right_distance_sensor = DistanceSensor(echo=5, trigger=6, queue_len=2)
        <strong class="bold"># Setup the Leds</strong>
        <strong class="bold">self.leds = leds_led_shim.Leds()</strong></pre></li>
				<li>As we have to<a id="_idIndexMarker435"/> stop more than just the motors, we'll <a id="_idIndexMarker436"/>swap <code>stop_motors</code> for a new <code>stop_all</code> method in the <code>atexit</code> call to stop other devices (such as the LEDs) too: <pre>        <strong class="bold"># ensure everything gets stopped when the code exits</strong>
<strong class="bold">        atexit.register(self.stop_all)</strong></pre></li>
				<li>Create the <code>stop_all</code> method, which stops the motors and clears the LEDs: <pre><strong class="bold">    def stop_all(self):</strong>
<strong class="bold">        self.stop_motors()</strong>
<strong class="bold">        # Clear the display</strong>
<strong class="bold">        self.leds.clear()</strong>
<strong class="bold">        self.leds.show()</strong></pre><p class="callout-heading">Important note</p><p class="callout">The complete code can be found at <a href="https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9">https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9</a>.</p></li>
			</ol>
			<p>We have now added support for the LEDs to the <code>Robot</code> class, making the interface we designed earlier available, and ensuring that the LEDs are cleared when the robot code exits. Next, we will start testing and turning on LEDs.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor182"/>Testing one LED</h2>
			<p>We have installed<a id="_idIndexMarker437"/> some hardware, along with a library for it, and then added code to make this available in our robot. However, before we go further, we should make sure that everything works with a test. This is a good place to find any problems and troubleshoot them.  </p>
			<p>Let's try testing a single LED. One aspect of our robot running Python that we've not explored is that it can run the Python <strong class="bold">REPL</strong> – <strong class="bold">read, eval, print loop</strong>. What that means is you can start Python and immediately type code to run there. We'll use this to test our LEDs a little:</p>
			<ol>
				<li value="1">Copy the <code>leds_led_shim.py</code> and <code>robot.py</code> code onto the Raspberry Pi.</li>
				<li>SSH into the robot, and just type <code>python3</code>. The Raspberry Pi should respond like this:<pre><strong class="bold">pi@myrobot:~ $ python3</strong>
<strong class="bold">Python 3.7.3 (default, Apr  3 2019, 05:39:12) </strong>
<strong class="bold">[GCC 8.2.0] on linux</strong>
<strong class="bold">Type "help", "copyright", "credits" or "license" for more information.</strong>
<strong class="bold">&gt;&gt;&gt;</strong></pre></li>
				<li>Let's get our <code>robot</code> library ready to use. Type the parts shown in bold:<pre><strong class="bold">&gt;&gt;&gt; import robot</strong>
<strong class="bold">&gt;&gt;&gt; r = robot.Robot()</strong></pre></li>
				<li>Now, try turning on an LED, setting it to red:<pre><strong class="bold">&gt;&gt;&gt; r.leds.set_one(0, (255, 0, 0))</strong></pre></li>
				<li>Hmm – nothing happened. Remember, we need to call <code>leds.show</code> to display our setting on them:<pre><strong class="bold">&gt;&gt;&gt; r.leds.show()</strong></pre><p>You should <a id="_idIndexMarker438"/>now see a single red LED.</p></li>
				<li>Let's try and set another to purple by mixing red and blue LEDs:<pre><code>leds.show</code> to send the colors to the LED device.</p></li>
				<li>To stop this session, press <em class="italic">Ctrl</em> +<em class="italic">D</em> on an empty line. The <code>atexit</code> code automatically turns all the LEDs off.</li>
			</ol>
			<p>You should now have seen an LED working and lighting up in multiple colors. This demonstrates that the code so far is good. If not, please refer to the following section. If this is all working, skip on ahead to the <em class="italic">Testing all LEDs</em> section.</p>
			<h3 id="_idParaDest-191">Troubleshooting</h3>
			<p>If you encounter <a id="_idIndexMarker439"/>problems trying to light the LEDs, there are some troubleshooting steps you can take.</p>
			<p>If running the code shows errors, do the following:</p>
			<ul>
				<li>Check that you have enabled I2C (as shown in <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>, <em class="italic">Drive and Turn – Moving Motors with Python</em>). </li>
				<li>Use <code>sudo i2cdetect -y 1</code>, as seen in <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>, <em class="italic">Drive and Turn – Moving Motors with Python</em>. You should see the LEDs at the address <code>74</code>.</li>
				<li>Check that you have installed the <code>ledshim</code> Python package with <code>pip3</code>.</li>
				<li>Carefully check the code for mistakes and errors. If it's the code from GitHub, create an issue!</li>
			</ul>
			<p>If the LEDs do not light at all, do the following:</p>
			<ul>
				<li>Try running the example code that comes with the SHIM at <a href="https://github.com/pimoroni/led-shim/tree/master/examples">https://github.com/pimoroni/led-shim/tree/master/examples</a>.</li>
				<li>Ensure you have installed the LEDs the correct way around, as shown in <em class="italic">Figure 9.4</em>.</li>
				<li>Ensure you have evenly pushed the LED strip down onto the header pins.</li>
				<li>Did you <a id="_idIndexMarker440"/>remember to use <code>leds.show()</code>?</li>
			</ul>
			<p>By following these troubleshooting tips, you will have eliminated the most common issues with this system. You should now have a working LED and be able to proceed to the next section.</p>
			<p>Testing all LEDs</p>
			<p>Now, we can <a id="_idIndexMarker441"/>try the <code>set_all</code> method. We'll make something that simply flashes a couple of different colors on the LEDs. Create a file called <code>leds_test.py</code>:</p>
			<ol>
				<li value="1">First, we need imports. We need to import our <code>R</code><code>obot</code> library and <code>time</code> to animate this:<pre><strong class="bold">from robot import Robot</strong>
<strong class="bold">from time import sleep</strong></pre></li>
				<li>Now, let's set up our bot, along with a couple of named colors:<pre><strong class="bold">bot = Robot()</strong>
<strong class="bold">red = (255, 0, 0)</strong>
<strong class="bold">blue = (0, 0, 255)</strong></pre></li>
				<li>The next part is the main loop. It alternates between the two colors, with <code>sleep</code>:<pre><code>set_all</code> method to set all the LEDs to <code>red</code> and call the <code>show</code> method to send it <a id="_idIndexMarker442"/>to the device. The code uses <code>sleep</code> to wait for half a second, before switching to <code>blue</code>. </p><p class="callout-heading">Important note</p><p class="callout">The complete code is at <a href="https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter8/leds_test.py">https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter8/leds_test.py</a>.</p></li>
				<li>When you have uploaded these files to the Raspberry Pi, type the following to show the red/blue alternating LED display:<pre><strong class="bold">pi@myrobot:~ $ python3 leds_test.py</strong></pre></li>
				<li>Press <em class="italic">Ctrl</em> + <em class="italic">C</em> on the terminal to stop this running.</li>
			</ol>
			<p>We have now shown all the LEDs working. This has also shown them switching between different colors, using timing to produce a very simple animation. We can build on this, producing more interesting uses of color and animation, but first, we will divert to learn a bit more about mixing colors.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor183"/>Making a rainbow display with the LEDs</h1>
			<p>Now we <a id="_idIndexMarker443"/>get to use these for some fun. We will extend our<a id="_idIndexMarker444"/> avoiding behavior from the previous chapter to show rainbow bar graphs on a side corresponding to the distances read. We could also use this for sensors. Before we can link the movement to the animation, how is a rainbow created?</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor184"/>Colour systems</h2>
			<p>RGB is how <a id="_idIndexMarker445"/>the hardware expects colors. However, RGB is less convenient for expressing intermediate colors or creating gradients between them. Colors that appear close to the eye can be a little far apart when in RGB. Because of this, there are other color systems.  </p>
			<p>The other<a id="_idIndexMarker446"/> color system we use is <strong class="bold">Hue, Saturation, and Value</strong> (<strong class="bold">HSV</strong>). We use HSV in this chapter to make rainbow-type displays and when doing computer vision in a later chapter to assist our code in detecting objects.</p>
			<h3 id="_idParaDest-194">Hue</h3>
			<p>Imagine taking the colors of the spectrum and placing them on a circle, blending through red to orange, orange to yellow, yellow to green, green to blue, blue to purple, and back around to red. The <strong class="bold">hue</strong> expresses a <a id="_idIndexMarker447"/>point around this circle. It does not affect the brightness of the color or how vivid it is. <em class="italic">Figure 9.5</em> shows how we can represent these points on a color wheel:</p>
			<p class="figure-caption"><img src="img/B15660_09_05.png" alt="" width="367" height="347"/></p>
			<p class="figure-caption">Figure 9.5 – A color wheel of hues</p>
			<p>In <em class="italic">Figure 9.5</em>, the circle shows that around 0 degrees, a red hue is seen. The compass points around the circle correspond to different colors. Colors are blended as you move around from one hue to another. You may<a id="_idIndexMarker448"/> have seen something like this in a color wheel gadget on a painting or drawing computer program. A continuous wheel setup like this is what lets us make a rainbow.</p>
			<h3 id="_idParaDest-195">Saturation</h3>
			<p>If you take a color such as red, it can be a grayish/dull red or a vivid, intense red. <strong class="bold">Saturation</strong> is an expression of<a id="_idIndexMarker449"/> the vividness of the color. As you go toward zero, it only makes shades of gray. As we increase the saturation, color begins to emerge – first in pastel tones, through to poster colors, and then to a striking hazard sign or pure colors at the high end of the saturation scale.</p>
			<h3 id="_idParaDest-196">Value</h3>
			<p>The <strong class="bold">value</strong> of the color is <a id="_idIndexMarker450"/>its brightness. It ranges from black at 0, through to a very dark version of the color, to a very bright color. Note that this does not approach white (in other words, pink colors), but a very bright red. To make a white color, you need to reduce the saturation too. Other color systems (such as HSL) specify a <em class="italic">light</em> component that would make things white this way.</p>
			<h3 id="_idParaDest-197">Converting HSV to RGB</h3>
			<p>There are <a id="_idIndexMarker451"/>complicated formulas to convert between one color system to <a id="_idIndexMarker452"/>another. However, Python can make this conversion itself. </p>
			<p>We will use <code>colorsys.hsv_to_rgb</code> to make this conversion. It accepts the three HSV components as fractions between 0 and 1, inclusive. </p>
			<p>In the case of the hue component, 0 is the start of the circle, 0.5 represents 180 degrees, the half circle, and 1 is all the way around to 360, the full circle.</p>
			<p>The saturation component at 0 is gray, fully desaturated, and 1 is the most intense color.</p>
			<p>The value component at 0 is black, fully dark, and at 1 is the brightest – a fully lit color. </p>
			<p>To make a bright cyan color, we would go past the half circle to about 0.6 for hue, 1.0 for saturation, and 1.0 for value:</p>
			<pre>cyan = colorsys.hsv_to_rgb(0.6, 1.0, 1.0)</pre>
			<p>However, this is not enough. The output from the <code>colorsys</code> call is a tuple, a collection of three items for the R, G, and B components. </p>
			<p>The output components are in terms of 0 to 1.0, too. Most RGB systems expect values between 0 and 255. To use them, we need to convert these values back up by multiplying them:</p>
			<pre>cyan_rgb = [int(c * 255) for c in cyan]</pre>
			<p>In the preceding line, we loop over each component, <code>c</code>, and multiply it by 255. By putting a <code>for</code> loop in square brackets like that in Python, we can loop over elements, and put the result back into a list.</p>
			<p>Now that you know how to convert HSV values to RGB, let's use this information to make a rainbow.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor185"/>Making a rainbow on the LEDs</h2>
			<p>We can use our<a id="_idIndexMarker453"/> color system <a id="_idIndexMarker454"/>understanding to make a rainbow on the LEDs: </p>
			<div><div><img src="img/B15660_09_06.jpg" alt="" width="1280" height="686"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – LEDs showing a rainbow on the robot</p>
			<p><em class="italic">Figure 9.6</em> shows a<a id="_idIndexMarker455"/> rainbow being displayed on the LEDs attached to the<a id="_idIndexMarker456"/> robot.</p>
			<p>Let's make this! Make a new file called <code>led_rainbow.py</code>:</p>
			<pre>import colorsys
def show_rainbow(leds, led_range):
    led_range = list(led_range)
    hue_step = 1.0 / len(led_range)
    for index, led_address in enumerate(led_range):
        hue = hue_step * index
        rgb = colorsys.hsv_to_rgb(hue, 1.0, 0.6)
        rgb = [int(c*255) for c in rgb]
        leds.set_one(led_address, rgb)</pre>
			<p>Let's go over this file line by line:</p>
			<ul>
				<li>This code starts by importing <code>colorsys</code>.</li>
				<li>We define a function, <code>show_rainbow</code>, which takes two parameters, a link to our LEDs system (which would usually be given <code>robot.leds</code>) and an LED range to set.</li>
				<li>Because we want to know the length of our LED range, we need to make sure it is a list, so we cast this on the first line of our function.</li>
				<li>For a rainbow, the hue value should sweep a full circle. In Python, <code>colorsys</code> is the values from 0 to 1. We want to advance the hue a fraction of a step for each LED in the range. By dividing 1.0 by the number of LEDs in a range, we get this fraction.</li>
				<li>We then loop over the LEDs. <code>enumerate</code> gives us an index while <code>led_address</code> advances. This code makes no assumptions about the range so that it could use an arbitrary list of LEDs.</li>
				<li>We then<a id="_idIndexMarker457"/> multiply <code>hue_step</code> and <code>index</code> to give the <code>hue</code> value, the<a id="_idIndexMarker458"/> right fraction of 1.0 to use. The following line converts this into an RGB value with a fixed saturation and brightness value.</li>
				<li>Because <code>colorsys</code> outputs values between 0 and 1, the code needs to multiply this by 255 and make the resulting number into an integer: <code>rgb = [int(c*255) for c in rgb]</code>.</li>
				<li>The code uses the <code>leds.set_one</code> method with this RGB value and the LED address.</li>
			</ul>
			<p>Let's test this with a file called <code>test_rainbow.py</code>:</p>
			<pre>from time import sleep
from robot import Robot
from led_rainbow import show_rainbow
bot = Robot()
while True:
    print("on")
    show_rainbow(bot.leds, range(bot.leds.count))
    bot.leds.show()
    sleep(0.5)
    print("off")
    bot.leds.clear()
    bot.leds.show()
    sleep(0.5)</pre>
			<p>This is quite similar to our previous red/blue test. However, in the first section, we use the <code>show_rainbow</code> function, which the code has imported from <code>led_rainbow</code>. It passed in the robot's LEDs and makes a range covering all of them. </p>
			<p>The code waits for<a id="_idIndexMarker459"/> half a second and then clears the LEDs for half a second. These are in <a id="_idIndexMarker460"/>a loop to make an on/off rainbow effect. Start this with <code>python3 test_rainbow.py</code>, and use <em class="italic">Ctrl</em> + <em class="italic">C</em> to stop it after seeing it work. </p>
			<p>Now that you've seen some simple animation and multicolor LED usage, we can take this to the next level by making the LEDs respond to sensors.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor186"/>Using the light strip for debugging the avoid behavior</h1>
			<p>LEDs in rainbows <a id="_idIndexMarker461"/>are fun, and switching colors<a id="_idIndexMarker462"/> looks nice. However, LEDs can be used for practical purposes too. In <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>, we added sensors to our robot to avoid obstacles. You can follow along in a PuTTY window, and see what the sensors are detecting by reading the numbers. But we can do better; with the light strip, we can put information on the robot to tell us what it is detecting.</p>
			<p>In this section, we will tie the LED output together to values from a behavior, first by basic lighting, and then by making some rainbow colors, too.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor187"/>Adding basic LEDs to the avoid behavior</h2>
			<p>Before we <a id="_idIndexMarker463"/>get fancy and reintroduce the rainbow, let's<a id="_idIndexMarker464"/> start with the basic version. The intent here will be to make two <em class="italic">indicator</em> bars to the left and right side of the LED bar. For each bar, more LEDs will light when the corresponding distance sensor detects a closer obstacle. We'll make it so that the bars go into the middle, so when a single outer LED is lit, the obstacle is far away. When most or all of the LEDs on one side are lit, the obstacle is much closer.</p>
			<p>We need to add a<a id="_idIndexMarker465"/> few parts to our avoid behavior:</p>
			<ul>
				<li>Some <a id="_idIndexMarker466"/>variables to set up the LED display, and how our distances map to it</li>
				<li>A way to convert a distance in to how many LEDs to show</li>
				<li>A method to display the state of our sensors on the LEDs using the preceding items</li>
				<li>To call the <code>display_state</code> method from the behavior's main loop</li>
			</ul>
			<p>Let's see how to incorporate the preceding points. Open the <code>avoid_behavior.py</code> file that you made in <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>, and follow along:</p>
			<ol>
				<li value="1">Before we can use the LEDs in this behavior, we need to separate them into the bars. In the <code>__init__</code> method of <code>ObstacleAvoidingBehavior</code>, add the following:<pre><strong class="bold">        # Calculations for the LEDs</strong>
<strong class="bold">        self.led_half = int(self.robot.leds.leds_count/2)</strong></pre></li>
				<li>Next, we need a color for the LEDs when sensing. I chose red. I encourage you to try another:<pre><strong class="bold">        self.sense_colour = 255, 0, 0</strong></pre></li>
				<li>With the variables' setup out of the way, let's add a method for converting the distance into LEDs. I added this after the <code>__init__</code> method:<pre><strong class="bold">    def distance_to_led_bar(self, distance):</strong></pre></li>
				<li>The distances are in terms of meters, with 1.0 being 1 meter, so subtracting the distance from 1.0 inverts this. The <code>max</code> function will return the largest of the two values, here it is used to ensure we don't go below zero:<pre><strong class="bold">        # Invert so closer means more LED's. </strong>
<strong class="bold">        inverted = max(0, 1.0 - distance)</strong></pre></li>
				<li>Now, we multiply this number, some fraction between 0 and 1, by the <code>self.led_half</code> value to get the number of LEDs to use. We round it up and turn this into an integer with <code>int(round())</code>, as we can only have a whole number of LEDs turned on. Rounding means that after our multiplication, if we end up with a value such as 3.8, we round it up to 4.0, then convert it into an integer to<a id="_idIndexMarker467"/> light four LEDs. We add 1 to this so that <a id="_idIndexMarker468"/>there's always at least one LED, and then return it:<pre><strong class="bold">        led_bar = int(round(inverted * self.led_half))</strong>
<strong class="bold">        return led_bar</strong></pre></li>
				<li>The next method is a trickier one; it will create the two bars. Let's start by declaring the method and clearing the LEDs:<pre><strong class="bold">    def display_state(self, left_distance, right_distance):</strong>
<strong class="bold">        # Clear first</strong>
<strong class="bold">        self.robot.leds.clear()</strong></pre></li>
				<li>For the left bar, we convert the left sensor distance to the number of LEDs, then create a range covering 0 to this number. It uses the <code>set_range</code> method to set a bunch of LEDs to <code>sense_color</code>. Note that your LEDs might be the other way around, in which case swap <code>left_distance</code> and <code>right_distance</code> in this <code>display</code> method:<pre><strong class="bold">        # Left side</strong>
<strong class="bold">        led_bar = self.distance_to_led_bar(left_distance)</strong>
<strong class="bold">        self.robot.leds.set_range(range(led_bar), self.sense_colour)</strong></pre></li>
				<li>The right side is trickier; after converting to an LED count, we need to create a range for the LEDs. The variable <code>led_bar</code> holds the number of LEDs to light. To light the right of the bar, we need to subtract this from the count of the LEDs to find the first LED, and create a range starting there to the total length. We must subtract 1 from the length – otherwise it will count 1 LED too far:<pre><strong class="bold">        # Right side</strong>
<strong class="bold">        led_bar = self.distance_to_led_bar(right_distance)</strong>
<strong class="bold">        # Bit trickier - must go from below the leds count up to the leds count.</strong>
<strong class="bold">        start = (self.robot.leds.count – 1) - led_bar</strong>
<strong class="bold">        self.robot.leds.set_range(range(start, self.robot.leds.count - 1), self.sense_colour)</strong></pre></li>
				<li>Next, we want to show the display we've now made:<pre><strong class="bold">        # Now show this display</strong>
<strong class="bold">        self.robot.leds.show()</strong></pre></li>
				<li>We then <a id="_idIndexMarker469"/>display our readings on the LEDs by <a id="_idIndexMarker470"/>calling <code>display_state</code> inside the behavior's <code>run</code> method. Here are a couple of lines for context, with the extra line highlighted:<pre>            # Get the sensor readings in meters
            left_distance = self.robot.left_distance_sensor.distance
            right_distance = self.robot.right_distance_sensor.distance
            <strong class="bold"># Display this</strong>
<strong class="bold">            self.display_state(left_distance, right_distance)</strong>
            # Get speeds for motors from distances
            nearest_speed, furthest_speed, delay = self.get_speeds(min(left_distance, right_distance))</pre></li>
			</ol>
			<p>Save this, send it to the Raspberry Pi, and run it. When it's running, you should be able to see the LEDs light up in a bar based on the distance. This is both satisfying and gives a good feel for what the robot is detecting. Let's make this a little more interesting by adding rainbows.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor188"/>Adding rainbows</h2>
			<p>We can use our LED rainbow<a id="_idIndexMarker471"/> to make our distance-sensing demo even more fun: </p>
			<div><div><img src="img/B15660_09_07.jpg" alt="" width="1280" height="755"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Distance sensor rainbow bars</p>
			<p><em class="italic">Figure 9.7</em> shows a photo of the <a id="_idIndexMarker472"/>rainbow bars for each distance sensor. This is a great visual demonstration of the LEDs animating.</p>
			<p>Since we added a library for showing rainbows, we can reuse it here. Let's see how to do it:</p>
			<ol>
				<li value="1">Open up the <code>avoid_behaviour.py</code> code from the previous section.  </li>
				<li>At the top, import <code>led_rainbow</code> so that we can use it:<pre>from robot import Robot
from time import sleep
<strong class="bold">from led_rainbow import show_rainbow</strong></pre></li>
				<li>Our existing code displayed a bar for the left. Instead of a bar, display a rainbow here. We need to ensure we have at least one item:<pre>     # Left side
     led_bar = self.distance_to_led_bar(left_distance)
<strong class="bold">     show_rainbow(self.robot.leds, range(led_bar))</strong></pre></li>
				<li>Once again, the right side will be a little bit trickier; as we want the rainbow to go the other way, we need to make the range count backward for the rainbow too. The Python <code>range</code> function, along with the <code>start</code> and <code>end</code> parameters, takes a step parameter. By making a step of -1, we can count down in the range:<pre>        start = (self.robot.leds.count – 1) - led_bar
        right_range = range(self.robot.leds.count - 1, start, -1)
        <strong class="bold">show_rainbow(self.robot.leds, right_range)</strong></pre></li>
				<li>Upload this<a id="_idIndexMarker473"/> and run it, and the bar graph will be in rainbow colors instead of a solid color.</li>
			</ol>
			<p>You have gone from a single LED to a number of LEDs. With some work on color systems, we were able to generate a rainbow and use it to show the status of a behavior.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor189"/>Summary</h1>
			<p>In this chapter, you learned how to interact with and use RGB LEDs, as well as how to choose and buy RGB LED strips that work with the Raspberry Pi. You learned how to make code for the LEDs on the robot, using them with robot behaviors. You also saw how the HSV color system works, which can be used to generate rainbows.</p>
			<p>You can take the techniques used here to add LED-based status displays to robots and write code to link them with behaviors.</p>
			<p>In the next chapter, we will look at servo motors and build a pan and tilt mechanism for moving sensors.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor190"/>Exercises</h1>
			<ol>
				<li value="1">Try mixing a different RGB color, or looking one up, and using <code>set_one</code>, <code>set_all</code>, or <code>set_range</code> to light LEDs in that color.</li>
				<li>Use the show left rainbow and show right rainbow functions to make the robot turn on rainbows corresponding to the side it's turning to in the <code>behaviour_path</code> code.</li>
				<li>By making a timer loop and advancing an index or changing a range, it would be possible to animate the rainbows or make them <em class="italic">scan</em> across the LED bar. Try this out.</li>
				<li>Could the other parts of the HSV color be used to make pulsing LED strips that change brightness?</li>
			</ol>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor191"/>Further reading</h1>
			<p>Please refer to the following for more information:</p>
			<ul>
				<li><em class="italic">Make Electronics: Learning by Discovery</em>, <em class="italic">Charles Platt</em>, <em class="italic">Make Community, LLC</em>: I've only started to cover some basic electronics with the switch and breadboard. To get a real feel for electronics, <em class="italic">Make Electronics</em> is a superb introduction.</li>
				<li>For more advanced electronics, try <em class="italic">Practical Electronics for Inventors, Fourth Edition</em>, <em class="italic">Paul Scherz</em>, <em class="italic">Simon Monk</em>, <em class="italic">McGraw-Hill Education TAB</em>: This gives practical building blocks for electronics that can be used to interface a robot controller with almost anything or build new sensors.</li>
				<li>The <code>colorsys</code> library, like most Python core libraries, has a great reference: <a href="https://docs.python.org/3/library/colorsys.html">https://docs.python.org/3/library/colorsys.html</a>.</li>
				<li>Pimoroni have some other demos with the LED SHIM at <a href="https://github.com/pimoroni/led-shim/tree/master/examples">https://github.com/pimoroni/led-shim/tree/master/examples</a>. These could be fun to adapt to our LED layer.</li>
			</ul>
		</div>
	</div></body></html>