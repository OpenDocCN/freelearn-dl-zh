- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Deploying Your Application on the Google Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Google Cloud 上部署您的应用程序
- en: You have come a long way in designing and developing your GenAI application.
    Now, it is time to take that next crucial step—deployment. While a true production-grade
    deployment involves various complexities such as CI/CD pipelines, scalability
    considerations, observability, cost optimization, and security hardening, this
    chapter is designed to give you a foundational, hands-on introduction to cloud
    deployment using Google Cloud Run. **Cloud Run** by Google Cloud provides a powerful
    yet developer-friendly way to deploy containerized applications without managing
    infrastructure, making it ideal for rapid prototyping and small-scale production
    use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您在设计和发展您的 GenAI 应用程序方面已经取得了长足的进步。现在，是时候迈出下一个关键步骤——部署。虽然真正的生产级部署涉及各种复杂性，如 CI/CD
    管道、可扩展性考虑、可观察性、成本优化和安全加固，但本章旨在为您提供一个基于 Google Cloud Run 的云部署基础、动手实践介绍。**Cloud
    Run** 由 Google Cloud 提供，它提供了一种强大且对开发者友好的方式来部署容器化应用程序，无需管理基础设施，非常适合快速原型设计和小规模生产用例。
- en: The deployment steps and services may vary slightly across other cloud platforms,
    such as AWS or Microsoft Azure, but we will focus on Google Cloud for brevity.
    However, once you are comfortable with the core concepts here, you are encouraged
    to experiment with similar workflows on other providers to broaden your cloud
    deployment expertise.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 部署步骤和服务可能在不同云平台（如 AWS 或 Microsoft Azure）上略有不同，但我们将专注于 Google Cloud 以简化说明。然而，一旦您熟悉了这里的核心概念，我们鼓励您在其他提供商上尝试类似的流程，以拓宽您的云部署专业知识。
- en: We will walk through the process of deploying the Haystack chatbot you built
    in [*Chapter 5*](Chapter_03.xhtml#_idTextAnchor021) as a serverless application
    on Google Cloud. The process of deploying the intelligent recommendation system
    using Spring AI is mentioned later in the chapter with the links to the resources
    to follow the steps. By the end of this chapter, you will have a working chatbot
    live on the cloud and the confidence to build on this foundation for more advanced
    deployments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍如何将您在[*第五章*](Chapter_03.xhtml#_idTextAnchor021)中构建的 Haystack 聊天机器人作为无服务器应用程序部署到
    Google Cloud。关于使用 Spring AI 部署智能推荐系统的步骤将在本章后面提及，并附有资源链接以便您跟随步骤进行。到本章结束时，您将拥有一个在云上运行的聊天机器人，并对此基础上的更高级部署充满信心。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Preparing your search chatbot using Haystack for deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Haystack 准备您的搜索聊天机器人以进行部署
- en: Containerizing the application with Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化应用程序
- en: Setting up a Google Cloud project and services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Google Cloud 项目和服务
- en: Deploying to Google Cloud Run
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到 Google Cloud Run
- en: Testing and verifying the deployment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和验证部署
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To deploy your Haystack chatbot using Google Cloud Run, you need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Google Cloud Run 部署您的 Haystack 聊天机器人，您需要以下条件：
- en: An active Google Cloud account with billing enabled. If you are new to Google
    Cloud, you can start by creating an account at [ https://console.cloud.google.com/](https://console.cloud.google.com/)
    and take advantage of the free tier and credits offered for new users.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个已启用计费的活跃 Google Cloud 账户。如果您是 Google Cloud 的新用户，可以从[https://console.cloud.google.com/](https://console.cloud.google.com/)创建一个账户，并利用为新用户提供免费层和信用额度。
- en: 'Access to a Neo4j database:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Neo4j 数据库：
- en: 'If you are using a local Neo4j instance, you must expose it publicly using
    `ngrok` or a similar tool, so that the deployed chatbot can connect to it. Here
    is an example to expose Neo4j’s `bolt` port:'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是本地 Neo4j 实例，您必须使用 `ngrok` 或类似工具将其公开，以便部署的聊天机器人可以连接到它。以下是一个公开 Neo4j 的
    `bolt` 端口的示例：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Update your `.env` with the `ngrok` public URL:'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ngrok` 公共 URL 更新您的 `.env` 文件：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are using AuraDB Free, the preceding step can be ignored.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用 AuraDB Free，可以忽略前面的步骤。
- en: Preparing your Haystack chatbot for deployment
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备您的 Haystack 聊天机器人以进行部署
- en: We will be deploying our application on Google Cloud. The approach we will be
    talking about is similar from a deployment perspective on all the popular cloud
    environments. We will be looking at building a `docker compose` and running it
    in the cloud. Google Cloud was chosen because it is convenient rather than having
    any technical advantage as such. Once we deploy and run the application on Google
    Cloud, the official documentation links for other clouds to deploy the same `docker
    compose` will be provided. Just repeating those steps in the book will not make
    much of a difference.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Google Cloud上部署我们的应用程序。我们将讨论的部署方法在所有流行的云环境中从部署角度来看是相似的。我们将查看构建`docker compose`并在云中运行它。选择Google
    Cloud是因为它方便，而不是因为它有任何技术优势。一旦我们在Google Cloud上部署并运行了应用程序，将提供其他云部署相同`docker compose`的官方文档链接。仅仅重复书中的那些步骤并不会带来太大的不同。
- en: Before jumping into containerization and deployment, it is important to ensure
    that your Haystack chatbot code is organized in a way that is compatible with
    serverless deployment. In this section, you will structure your code base appropriately
    and prepare the essential configuration files needed for deploying to Google Cloud
    Run.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行容器化和部署之前，确保您的Haystack聊天机器人代码以与无服务器部署兼容的方式组织非常重要。在本节中，您将适当地结构化代码库，并准备部署到Google
    Cloud Run所需的必要配置文件。
- en: We will be reusing the working search chatbot from [*Chapter 5*](Chapter_03.xhtml#_idTextAnchor021)
    by creating a copy of the main script (`search_chatbot.py`), renaming it `app.py`
    (as this is the default entry point many cloud services expect when serving a
    Python web application), and placing it in a simplified folder ready for containerization.
    Since the chatbot logic is already functional, we will skip local testing and
    move directly to packaging and deploying it to the cloud.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建主脚本（`search_chatbot.py`）的副本，将其重命名为`app.py`（因为这是许多云服务在提供Python网络应用程序时期望的默认入口点），并将其放置在一个简化文件夹中以准备容器化，来重用工作搜索聊天机器人。由于聊天机器人逻辑已经功能正常，我们将跳过本地测试，直接进行打包并将其部署到云端。
- en: '**Note**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: These steps to help you containerize and deploy your Haystack chatbot to Google
    Cloud Run are also presented in the `README.md` file in the book’s GitHub repo
    at [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch12](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch12).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您将Haystack聊天机器人容器化和部署到Google Cloud Run，这些步骤也在本书GitHub仓库的`README.md`文件中展示，网址为[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch12](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch12)。
- en: 'Next, prepare a `requirements.txt` file that lists all the necessary Python
    dependencies your chatbot needs to run. This file allows the container to install
    the required packages during the build process. The content of this file will
    look something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，准备一个`requirements.txt`文件，列出聊天机器人运行所需的全部Python依赖项。此文件允许容器在构建过程中安装所需的包。此文件的内容看起来可能如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To manage sensitive credentials and environment-specific configurations securely,
    it is recommended to use a `.env` file. In the `ch12` directory of the GitHub
    repo, you will find a file named `example.env` that serves as a template. This
    file includes placeholders for key variables such as your OpenAI API key and Neo4j
    database credentials. To use it, simply create a copy of this file, rename it
    `.env`, and populate it with your actual values. The application leverages the
    `python-dotenv` library to load these variables at runtime, keeping secrets out
    of your code base while still making them accessible to your application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全地管理敏感凭证和环境特定的配置，建议使用`.env`文件。在GitHub仓库的`ch12`目录中，您将找到一个名为`example.env`的文件，它作为一个模板。此文件包括用于您的OpenAI
    API密钥和Neo4j数据库凭证等关键变量的占位符。要使用它，只需创建此文件的副本，将其重命名为`.env`，并用您的实际值填充。应用程序利用`python-dotenv`库在运行时加载这些变量，从而将秘密从代码库中排除，同时仍然使它们对应用程序可访问：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, you have set up the core components needed for deployment—your
    application script, dependencies, and environment variables. To ensure everything
    is organized correctly for containerization and deployment, your project directory
    should now follow this structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经设置了部署所需的核心组件——您的应用程序脚本、依赖项和环境变量。为了确保一切组织正确，以便进行容器化和部署，您的项目目录现在应遵循以下结构：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `example.env` file acts as a reference for users to create their own .`env`
    file with valid credentials and configuration values. With all the core components
    now in place—including your application script, dependencies, and environment
    setup—you are ready to containerize your application for deployment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.env` 文件作为用户创建自己的 `.env` 文件的参考，其中包含有效的凭证和配置值。现在，所有核心组件都已就位——包括你的应用程序脚本、依赖项和环境设置——你现在可以为部署容器化你的应用程序。'
- en: Let us move on to the next step, which is to containerize your application with
    Docker.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行下一步，即使用 Docker 容器化你的应用程序。
- en: Containerizing the application with Docker
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化应用程序
- en: Before deploying your Haystack chatbot to Google Cloud Run, the application
    must be packaged into a Docker container. **Containerization** allows you to bundle
    your code, dependencies, and environment into a single, portable unit that runs
    consistently across different systems—including the cloud.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在将你的 Haystack 聊天机器人部署到 Google Cloud Run 之前，应用程序必须被打包到 Docker 容器中。**容器化**允许你将你的代码、依赖项和环境捆绑成一个单一、可移植的单位，该单位可以在不同的系统上（包括云端）一致地运行。
- en: In this section, you will create a Dockerfile, which defines the steps required
    to build a Docker image of your chatbot. This image will then be deployed to Cloud
    Run as a serverless web service.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个 Dockerfile，它定义了构建你的聊天机器人 Docker 镜像所需的步骤。然后，这个镜像将被部署到 Cloud Run 作为无服务器网络服务。
- en: 'Here is the Dockerfile used to containerize your Haystack chatbot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于容器化你的 Haystack 聊天机器人的 Dockerfile：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let us break down what each line does:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解每一行的作用：
- en: '`FROM python:3.11`: This sets the base image to Python 3.11, which includes
    everything needed to run Python applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM python:3.11`: 这将基础镜像设置为 Python 3.11，它包括运行 Python 应用程序所需的一切。'
- en: '`EXPOSE 8080`: Cloud Run expects the application to listen on port `8080`.
    This line documents the port that the container will expose at runtime.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 8080`: Cloud Run 预期应用程序在端口 `8080` 上监听。此行记录了容器在运行时将公开的端口。'
- en: '`WORKDIR /app`: This sets the working directory inside the container to `/app`.
    All subsequent commands will run from this directory.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /app`: 这将容器内的工作目录设置为 `/app`。所有后续命令都将从这个目录运行。'
- en: '`COPY . ./`: This copies the entire contents of your local project directory
    into the container’s `/app` directory.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY . ./`: 这将你的本地项目目录的全部内容复制到容器的 `/app` 目录中。'
- en: '`RUN pip install -r requirements.txt`: This installs all Python dependencies
    listed in your `requirements.txt` file.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN pip install -r requirements.txt`: 这安装了你在 `requirements.txt` 文件中列出的所有 Python
    依赖项。'
- en: '`CMD ["python", "app.py"]`: This specifies the command to run when the container
    starts—in this case, it runs your chatbot application using `app.py`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["python", "app.py"]`: 这指定了容器启动时要运行的命令——在这种情况下，它使用 `app.py` 运行你的聊天机器人应用程序。'
- en: Once your Dockerfile is in place, you now have a fully containerized version
    of your Haystack chatbot, ready to be deployed to the cloud. The next step is
    to configure your Google Cloud environment so that you can push your container
    and run it using Cloud Run.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的 Dockerfile 就位，你现在就拥有了一个完全容器化的 Haystack 聊天机器人版本，准备好部署到云端。下一步是配置你的 Google
    Cloud 环境，以便你可以推送你的容器并使用 Cloud Run 运行它。
- en: Let us move on to setting up your Google Cloud project and services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置你的 Google Cloud 项目和服务。
- en: Setting up a Google Cloud project and services
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Google Cloud 项目和服务
- en: Google Cloud provides a robust, developer-friendly platform for deploying modern
    applications, including GenAI-powered solutions. With tools such as Cloud Run,
    Artifact Registry, and Cloud Build, Google Cloud enables you to go from code to
    scalable, serverless deployment with minimal operational overhead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 为部署现代应用程序（包括由 GenAI 驱动的解决方案）提供了一个强大且面向开发者的平台。借助 Cloud Run、Artifact
    Registry 和 Cloud Build 等工具，Google Cloud 使你能够从代码到可扩展的无服务器部署，同时最小化运营开销。
- en: Although your Haystack chatbot uses OpenAI for language processing, Google Cloud
    plays a critical role in hosting the application, managing container builds, and
    securely storing your Docker images. In this section, you will configure your
    Google Cloud project, enable only the necessary services (such as Cloud Run, Cloud
    Build, and Artifact Registry), and prepare your environment for deployment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的 Haystack 聊天机器人使用 OpenAI 进行语言处理，但 Google Cloud 在托管应用程序、管理容器构建和安全性存储 Docker
    镜像方面发挥着关键作用。在本节中，你将配置你的 Google Cloud 项目，仅启用必要的服务（如 Cloud Run、Cloud Build 和 Artifact
    Registry），并为部署准备你的环境。
- en: By the end of this section, your project will be cloud-ready, with all the services
    and permissions in place to deploy your chatbot using Google Cloud’s serverless
    infrastructure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你的项目将准备好云部署，所有服务和权限都已就绪，以便使用 Google Cloud 的无服务器基础设施部署你的聊天机器人。
- en: Let us get started by setting up your project and enabling the required APIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置你的项目并启用所需的 API。
- en: Creating a project
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个项目
- en: In the Google Cloud console ([https://console.cloud.google.com/](https://console.cloud.google.com/)),
    on the project selector page, select or create a Google Cloud project ([https://cloud.google.com/resource-manager/docs/creating-managing-projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 控制台([https://console.cloud.google.com/](https://console.cloud.google.com/))的项目选择器页面，选择或创建一个
    Google Cloud 项目([https://cloud.google.com/resource-manager/docs/creating-managing-projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects))。
- en: Make sure that billing is enabled for your Cloud project. Learn how to check
    whether billing is enabled on a project at [https://cloud.google.com/billing/docs/how-to/verify-billing-enabled](https://cloud.google.com/billing/docs/how-to/verify-billing-enabled).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的 Cloud 项目已启用计费。了解如何在项目中检查计费是否已启用，请参阅[https://cloud.google.com/billing/docs/how-to/verify-billing-enabled](https://cloud.google.com/billing/docs/how-to/verify-billing-enabled)。
- en: Launching Google Cloud Shell
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Google Cloud Shell
- en: 'To simplify the setup and avoid installing any tools locally, we will use Google
    Cloud Shell, which comes pre-installed with Docker, the `gcloud` CLI, and Git.
    Here is how to get started:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化设置并避免在本地安装任何工具，我们将使用预装了 Docker、`gcloud` CLI 和 Git 的 Google Cloud Shell。以下是开始的方法：
- en: Go to the Google Cloud console ([https://console.cloud.google.com/](https://console.cloud.google.com/)).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Google Cloud 控制台([https://console.cloud.google.com/](https://console.cloud.google.com/))。
- en: Click the Cloud Shell icon in the top-right corner of the navigation bar (the
    terminal icon).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击导航栏右上角的 Cloud Shell 图标（终端图标）。
- en: A terminal window will open at the bottom of your screen. This is a fully functional
    shell with access to your Google Cloud project and services.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕底部将打开一个终端窗口。这是一个功能齐全的 shell，可以访问你的 Google Cloud 项目和服务。
- en: '**Note**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Cloud Shell provisions a temporary VM with 5 GB of persistent storage—more than
    enough for this walkthrough.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Shell 提供了一个具有 5 GB 持久存储的临时 VM——对于这个教程来说已经足够了。
- en: Setting your active project
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的活动项目
- en: 'Make sure you are working on the right Google Cloud project. You can either
    create a new one or use an existing one. Set it using the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你正在操作正确的 Google Cloud 项目。你可以创建一个新的项目或者使用现有的一个。使用以下步骤设置：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can verify the active project with the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令验证活动项目：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Enabling the required services
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用所需的服务
- en: 'Now, enable the Google Cloud services required for deploying your container:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启用部署你的容器所需的 Google Cloud 服务：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On successful execution of the command, you should see a message similar to
    the one shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行成功后，你应该会看到类似于以下的消息：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The alternative to the preceding `gcloud` command is through the console by
    searching for each product. If any API is missed, you can enable it during the
    implementation. Refer to the documentation for `gcloud` commands and usage: [https://cloud.google.com/sdk/gcloud/reference/config/list](https://cloud.google.com/sdk/gcloud/reference/config/list).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `gcloud` 命令的替代方法是通过对控制台中的每个产品进行搜索。如果遗漏了任何 API，你可以在实施过程中启用它。请参阅 `gcloud` 命令和用法文档：[https://cloud.google.com/sdk/gcloud/reference/config/list](https://cloud.google.com/sdk/gcloud/reference/config/list)。
- en: Adding your project files to Cloud Shell
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将你的项目文件添加到 Cloud Shell
- en: Before continuing with the deployment steps, make sure your Haystack chatbot
    files are available in your Google Cloud Shell environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续部署步骤之前，请确保你的 Haystack 聊天机器人文件已存在于你的 Google Cloud Shell 环境中。
- en: 'You have two options to do this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个选择来完成这个操作：
- en: '**Upload your existing files**: If you have been developing the project locally
    (e.g., as part of earlier chapters), you can upload your working directory to
    Cloud Shell using the **Upload** option in the Cloud Shell editor. Just click
    the **Open Editor** button (pencil icon), then use **File | Upload Files** or
    drag and drop your folder directly into the editor.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**上传现有文件**：如果你已经在本地开发项目（例如，作为早期章节的一部分），你可以使用 Cloud Shell 编辑器的 **上传** 选项将工作目录上传到
    Cloud Shell。只需点击 **打开编辑器** 按钮（铅笔图标），然后使用 **文件 | 上传文件** 或直接将文件夹拖放到编辑器中。'
- en: '**Clone from GitHub (recommended for clean setup)**: Alternatively, you can
    clone the *Chapter 12* code directly from the official book repository using the
    following command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从 GitHub 克隆（推荐用于干净设置）**：或者，你可以使用以下命令直接从官方书籍仓库克隆 *第 12 章* 的代码：'
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once you are inside the `ch12` folder, you will find all the necessary files—`app.py`,
    `requirements.txt`, `Dockerfile`, and `example.env`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入 `ch12` 文件夹，你将找到所有必要的文件——`app.py`、`requirements.txt`、`Dockerfile` 和 `example.env`。
- en: If you decide to clone the repo, make sure to follow the step mentioned earlier
    to generate the `.env` file. Now that your project files are in place and ready
    inside Cloud Shell, it is time to move on to the final stage—deploying your Haystack
    chatbot to Google Cloud Run.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定克隆仓库，请确保遵循前面提到的步骤来生成 `.env` 文件。现在你的项目文件已经放置在 Cloud Shell 内并准备就绪，是时候进入最终阶段——将你的
    Haystack 聊天机器人部署到 Google Cloud Run。
- en: Deploying to Google Cloud Run
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Google Cloud Run
- en: 'In this section, you will walk through the full deployment workflow—from setting
    environment variables and configuring Artifact Registry to building your container
    and deploying it live using Cloud Run. Let us break it down step by step:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解完整的部署工作流程——从设置环境变量和配置 Artifact Registry 到构建你的容器并使用 Cloud Run 部署它。让我们一步一步来分解：
- en: 'Set up environment variables. Begin by exporting the key environment variables
    for your Google Cloud project and deployment region. Replace the placeholders
    with your actual values:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置环境变量。首先，导出你的 Google Cloud 项目和部署区域的关键环境变量。用你的实际值替换占位符：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create an Artifact Registry instance and build the container. Configure your
    Artifact Registry repository and build your container image using Cloud Build:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Artifact Registry 实例并构建容器。配置你的 Artifact Registry 仓库并使用 Cloud Build 构建你的容器镜像：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the Docker repository:'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Docker 仓库：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Authenticate Docker with Artifact Registry:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Artifact Registry 验证 Docker：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, build and push your container image:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，构建并推送你的容器镜像：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command uses your Dockerfile to package the app and pushes the resulting
    container image to Artifact Registry.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用你的 Dockerfile 打包应用程序，并将生成的容器镜像推送到 Artifact Registry。
- en: Deploy to Cloud Run. Before deploying, make sure your `.env` file contains all
    the required environment variables, such as `OPENAI_API_KEY`, `NEO4J_URI`, and
    any project-specific configuration.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到 Cloud Run。在部署之前，请确保你的 `.env` 文件包含所有必需的环境变量，例如 `OPENAI_API_KEY`、`NEO4J_URI`
    以及任何特定于项目的配置。
- en: 'To pass these variables during deployment, convert your `.env` file into a
    format compatible with the `--set-env-vars` flag:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在部署期间传递这些变量，将你的 `.env` 文件转换为与 `--set-env-vars` 标志兼容的格式：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, deploy your application to Cloud Run:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，将你的应用程序部署到 Cloud Run：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once complete, Google Cloud Run will return a URL where your chatbot is live
    and accessible via the web.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，Google Cloud Run 将返回一个 URL，你的聊天机器人可以通过网页实时访问。
- en: Congratulations—your Haystack chatbot is now successfully deployed and running
    as a serverless application on Google Cloud!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——你的 Haystack 聊天机器人现在已成功部署，并在 Google Cloud 上作为一个无服务器应用程序运行！
- en: 'Let us move on to the final step: testing and verifying the deployment to ensure
    everything works as expected.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到最后一步：测试和验证部署，以确保一切按预期工作。
- en: Testing and verifying the deployment on Google Cloud
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Google Cloud 上测试和验证部署
- en: 'Once your deployment is complete, Google Cloud Run will return a public service
    URL, typically in the following format:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的部署完成，Google Cloud Run 将返回一个公共服务 URL，通常格式如下：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Open this URL in your browser. You should see your Gradio-powered chatbot interface
    live on the web—identical in functionality to your local version. You can now
    interact with the chatbot, submit queries, and receive movie recommendations just
    as before, but this time, it is running fully in the cloud.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开此 URL。你应该能看到你的 Gradio 驱动的聊天机器人界面在网页上实时运行——其功能与本地版本完全相同。你现在可以与聊天机器人互动，提交查询，并像以前一样接收电影推荐，但这次它是完全在云端运行的。
- en: 'If something does not work as expected, keep the following checklist ready
    for troubleshooting:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些事情没有按预期工作，请准备好以下清单进行故障排除：
- en: '**Dependency check**: Make sure your Dockerfile correctly installs all dependencies
    using `pip install -r requirements.txt`. Missing dependencies can result in build
    or runtime errors on Cloud Run.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖性检查**：确保你的 Dockerfile 使用 `pip install -r requirements.txt` 正确安装所有依赖项。缺少依赖项可能导致
    Cloud Run 上的构建或运行时错误。'
- en: '**Cloud Shell versus local environment**: If you are not using Google Cloud
    Shell, ensure your local environment is authenticated with Google Cloud using
    a service account that has appropriate permissions for Cloud Run, Artifact Registry,
    and (if applicable) Vertex AI.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Shell 与本地环境**：如果您没有使用 Google Cloud Shell，请确保您的本地环境通过具有适当权限的 Google
    Cloud 服务账户进行认证，以便于 Cloud Run、Artifact Registry 以及（如果适用）Vertex AI。'
- en: '**Monitor logs and metrics**: You can monitor your service’s logs, request
    history, and performance metrics directly from the Google Cloud console under
    **Cloud Run**. This is especially useful for debugging and performance tuning.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控日志和指标**：您可以直接从 Google Cloud 控制台下的 **Cloud Run** 中监控您服务的日志、请求历史和性能指标。这对于调试和性能调整特别有用。'
- en: '**Cloud Run service management**: Navigate to **Cloud Run** in the Cloud console,
    where you will see a list of deployed services. Your chatbot (e.g., `movies-chatbot`)
    should appear here. Clicking on the service name will give you access to the following:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Run 服务管理**：在云控制台中导航到 **Cloud Run**，您将看到已部署服务的列表。您的聊天机器人（例如，`movies-chatbot`）应该会出现在这里。点击服务名称将为您提供以下访问权限：'
- en: The public service URL
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共服务 URL
- en: Deployment history
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署历史
- en: Container configuration
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器配置
- en: Environment variables
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Logs and error reports
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和错误报告
- en: This visibility makes it easy to track and manage your application post-deployment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可见性使得跟踪和管理您的应用程序在部署后变得容易。
- en: With your chatbot now live, deployed on a scalable serverless platform, and
    publicly accessible, you have successfully completed the deployment journey. Your
    GenAI-powered movie recommendation chatbot is now ready to be used, shared, and
    further enhanced.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的聊天机器人已经上线，部署在可扩展的无服务器平台上，并且公开可访问，您已经成功完成了部署之旅。您的基于 GenAI 的电影推荐聊天机器人现在可以使用了，可以分享，并且可以进一步改进。
- en: Deploying the chatbot to other clouds
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将聊天机器人部署到其他云平台
- en: 'As mentioned in the initial section, once you have `docker compose` prepared,
    you can follow the instructions provided to deploy the same application to other
    clouds:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如初始部分所述，一旦您准备好了 `docker compose`，您就可以遵循提供的说明将相同的应用程序部署到其他云平台：
- en: '**Azure deployment**: Please follow the instructions provided at this link:  [https://techcommunity.microsoft.com/blog/appsonazureblog/how-to-deploy-a-local-docker-container-to-azure-container-apps/3583888](https://techcommunity.microsoft.com/blog/appsonazureblog/how-to-deploy-a-local-docker-container-to-azure-container-apps/3583888).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 部署**：请参考以下链接中的说明：  [https://techcommunity.microsoft.com/blog/appsonazureblog/how-to-deploy-a-local-docker-container-to-azure-container-apps/3583888](https://techcommunity.microsoft.com/blog/appsonazureblog/how-to-deploy-a-local-docker-container-to-azure-container-apps/3583888).'
- en: '**AWS deployment**: Docker provides a clear guide on deploying `docker compose`
    files to AWS. Please follow this link for more details: [https://www.docker.com/blog/docker-compose-from-local-to-amazon-ecs/](https://www.docker.com/blog/docker-compose-from-local-to-amazon-ecs/).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS 部署**：Docker 提供了将 `docker compose` 文件部署到 AWS 的清晰指南。请点击以下链接获取更多详细信息：[https://www.docker.com/blog/docker-compose-from-local-to-amazon-ecs/](https://www.docker.com/blog/docker-compose-from-local-to-amazon-ecs/).'
- en: When you follow the instructions in these links, you can see the similarity
    with the deployment approach when we chose to containerize the applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您遵循这些链接中的说明时，您会发现这与我们选择将应用程序容器化的部署方法有相似之处。
- en: 'There is a lot of information available in each cloud’s official documentation
    to deploy Spring Boot applications to the cloud. For example, if you are looking
    to run the application we created in *Chapters 9* and *10*, you can follow the
    steps in the documentation provided by various cloud vendors:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个云平台的官方文档中都有大量信息，可以帮助您将 Spring Boot 应用程序部署到云平台。例如，如果您想运行我们在第 *9* 章和 *10* 章中创建的应用程序，您可以遵循各个云服务提供商提供的文档中的步骤：
- en: '**Google Cloud**: This article ([https://cloud.google.com/run/docs/quickstarts/build-and-deploy/deploy-java-service](https://cloud.google.com/run/docs/quickstarts/build-and-deploy/deploy-java-service))
    lists detailed steps to deploy on Google Cloud Run'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud**：本文档 ([https://cloud.google.com/run/docs/quickstarts/build-and-deploy/deploy-java-service](https://cloud.google.com/run/docs/quickstarts/build-and-deploy/deploy-java-service))
    列出了在 Google Cloud Run 上部署的详细步骤'
- en: '**Azure**: This article ([https://learn.microsoft.com/en-us/azure/spring-apps/basic-standard/how-to-maven-deploy-apps](https://learn.microsoft.com/en-us/azure/spring-apps/basic-standard/how-to-maven-deploy-apps))
    shows how to deploy the Spring Boot application on Azure'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure**：这篇文章([https://learn.microsoft.com/en-us/azure/spring-apps/basic-standard/how-to-maven-deploy-apps](https://learn.microsoft.com/en-us/azure/spring-apps/basic-standard/how-to-maven-deploy-apps))展示了如何在Azure上部署Spring
    Boot应用程序'
- en: '**AWS**: For Azure here are some articles for your reference.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS**：对于Azure，这里有一些参考资料文章。'
- en: This article ([https://community.aws/content/2qk6oFuOPiA4G0N83ocU0REbtdN/step-by-step-guide-to-deploying-a-spring-boot-application-on-aws-ec2-with-best-practices](https://community.aws/content/2qk6oFuOPiA4G0N83ocU0REbtdN/step-by-step-guide-to-deploying-a-spring-boot-application-on-aws-ec2-with-best-practices))
    shows us how to deploy the Spring Boot application on AWS EC2
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这篇文章([https://community.aws/content/2qk6oFuOPiA4G0N83ocU0REbtdN/step-by-step-guide-to-deploying-a-spring-boot-application-on-aws-ec2-with-best-practices](https://community.aws/content/2qk6oFuOPiA4G0N83ocU0REbtdN/step-by-step-guide-to-deploying-a-spring-boot-application-on-aws-ec2-with-best-practices))展示了如何在AWS
    EC2上部署Spring Boot应用程序
- en: This article ([https://www.geeksforgeeks.org/deploy-a-spring-boot-application-with-aws/](https://www.geeksforgeeks.org/deploy-a-spring-boot-application-with-aws/))
    shows how to deploy the Spring Boot application using AWS Elastic Beanstalk
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这篇文章([https://www.geeksforgeeks.org/deploy-a-spring-boot-application-with-aws/](https://www.geeksforgeeks.org/deploy-a-spring-boot-application-with-aws/))展示了如何使用AWS
    Elastic Beanstalk部署Spring Boot应用程序
- en: These articles are good enough to guide you through deploying our GenAI application
    as, at its heart, it is a simple application that does not need scaling as such
    since it only performs the augmentation—that, too, as a batch process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文章足以指导你部署我们的GenAI应用程序，因为它的核心是一个简单的应用程序，不需要这样的扩展，因为它只执行增强——而且，那也是一个批量过程。
- en: The production deployment of these applications is a more complex procedure
    that requires you to focus on various supporting elements, such as database, monitoring,
    and so on. Discussing the whole deployment is out of the scope of this book, but
    we will highlight the deployment architecture and key considerations to deploy
    your applications in production in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序的生产部署是一个更复杂的流程，需要你关注各种支持元素，如数据库、监控等。讨论整个部署超出了本书的范围，但我们将突出部署架构和关键考虑因素，以便在下一节中部署你的应用程序。
- en: 'Preparing for deployment in production: key considerations'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备在生产环境中部署：关键考虑因素
- en: In this section, we will look at a typical architecture deployment for intelligent
    applications. There are a lot of other aspects we need to keep in mind when we
    are moving to production. For simplicity, we will refer to the augmentation application
    we built in *Chapters 9* and *10*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看智能应用程序的典型架构部署。当我们迁移到生产环境时，还有很多其他方面我们需要考虑。为了简单起见，我们将参考我们在*第9章*和*第10章*中构建的增强应用程序。
- en: 'Let us look at all the tasks we did from loading data to reviewing the results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从加载数据到审查结果的所有任务：
- en: We loaded the data into a graph.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将数据加载到图中。
- en: The graph was enhanced with seasonal relationships. We augmented the graph using
    the augmentation application—articles as well as customer behavior aspects.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该图通过季节性关系进行了增强。我们使用增强应用程序——包括文章以及客户行为方面——来增强该图。
- en: We also utilized KNN similarity and community detection algorithms to enhance
    the graph and reviewed how this approach gives us better results.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还利用了KNN相似性和社区检测算法来增强图，并回顾了这种方法如何给我们带来更好的结果。
- en: In a production deployment, all of these aspects may need to be automated and
    deployed as individual applications. Let us take a brief look at all of these
    aspects that we need to take care of.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产部署中，所有这些方面可能都需要自动化并作为独立的应用程序部署。让我们简要地看看所有这些我们需要注意的方面。
- en: When we are deploying intelligent applications to production, we need to make
    sure we take care of data ingestion, data consumption, the LLM or ML pipeline
    to augment the graph, and the graph database deployment architecture for scale.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将智能应用程序部署到生产环境时，我们需要确保我们关注数据摄取、数据消费、用于增强图的LLM或ML管道，以及用于扩展的图数据库部署架构。
- en: Let’s first take a look at the deployment architecture in *Figure 12.1*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看*图12.1*中的部署架构。
- en: '![Figure 12.1 — Deployment architecture of Neo4j intelligent applications](img/B31107_12_01-01.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 — Neo4j智能应用的部署架构](img/B31107_12_01-01.png)'
- en: Figure 12.1 — Deployment architecture of Neo4j intelligent applications
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 — Neo4j智能应用的部署架构
- en: We can see there are two different Neo4j databases shown here. In Neo4j for
    regular interaction, we will have `Primary`, which can perform both `READ` and
    `WRITE` capabilities. For analytical, **Graph Data Science** (**GDS**), and other
    uses, we will use `Secondary`, which provides only the `READ` capability. We can
    have more than one `Primary` database to provide high availability and more than
    one `Secondary` database to provide horizontal scalability. We can see from the
    diagram that all the regular interactions, including data ingestion and data consumption,
    are handled by `Primary` and the analytical workload that augments the graph is
    handled by `Secondary`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里显示了两个不同的Neo4j数据库。在Neo4j的常规交互中，我们将拥有`Primary`，它可以执行`READ`和`WRITE`功能。对于分析、**图数据科学**（**GDS**）和其他用途，我们将使用`Secondary`，它只提供`READ`功能。我们可以拥有多个`Primary`数据库以提供高可用性，以及多个`Secondary`数据库以提供横向扩展性。我们可以从图中看到，所有常规交互，包括数据摄取和数据消费，都由`Primary`处理，而增强图的负载分析工作由`Secondary`处理。
- en: This type of deployment architecture also makes it easy to maintain and monitor
    the system. The Neo4j database comes with **Neo4j Ops Manager** ([https://neo4j.com/docs/ops-manager/current/](https://neo4j.com/docs/ops-manager/current/))
    for deploying and monitoring Neo4j servers. It provides dashboards to monitor
    the current health of the system as well as to set up alerts to be notified in
    case of errors.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署架构也使得维护和监控系统变得容易。Neo4j数据库附带**Neo4j Ops Manager** ([https://neo4j.com/docs/ops-manager/current/](https://neo4j.com/docs/ops-manager/current/))，用于部署和监控Neo4j服务器。它提供仪表板来监控系统的当前健康状况，并在出现错误时设置警报以通知用户。
- en: For the other applications, we need to have similar monitoring, especially for
    data ingestion and augmentation applications. When they fail in the middle, we
    should be able to restart from where we have failed. The augmentation application
    is built to handle the data that way.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他应用程序，我们需要有类似的监控，特别是对于数据摄取和增强应用程序。当它们在中间失败时，我们应该能够从失败的地方重新启动。增强应用程序就是为此目的而构建的。
- en: 'When we are building the ingestion pipeline, we need to keep in mind these
    aspects:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建数据摄取管道时，我们需要牢记这些方面：
- en: What is our initial data size?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的初始数据量是多少？
- en: What are our day-to-day changes (incremental data changes) and their size?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们日常的更改（增量数据更改）及其大小是什么？
- en: How does incremental data come? Is it coming in near-real time, as a batch at
    regular intervals, a big batch at the end of the day, or interactive changes made
    by end users via the UI?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量数据是如何来的？它是以接近实时的方式，定期作为一个批次到来，还是在一天结束时作为一个大批次到来，还是由最终用户通过用户界面进行的交互式更改？
- en: We will look at best practices for these scenarios.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨这些场景的最佳实践。
- en: Initial data load
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始数据加载
- en: If we are migrating from another data source or database, we might have to move
    the data into Neo4j for the first time. Depending on this data size, we must decide
    whether we can take a transactional approach to load the data or leverage the
    offline data import approach called `neo4j-admin` import.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从其他数据源或数据库迁移，我们可能需要第一次将数据移动到Neo4j。根据数据量，我们必须决定我们是否可以采取事务方法来加载数据，或者利用名为`neo4j-admin`的离线数据导入方法。
- en: In [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor059), we used a transactional
    approach to load the data. If the amount of data we are loading is under a few
    million records, say 100 million, we can load this data in a reasonable amount
    of time. When we load the data transactionally, the Neo4j database needs to update
    the indexes and keep transaction logs apart, committing the data to the database.
    This adds a good amount of overhead to the process. But this approach gives us
    more flexibility and reusable code to use with incremental data loading. If we
    are loading data into a cluster, we can use this approach to make sure the data
    is available across the cluster, as the Neo4j database server makes sure the changes
    are replicated across the cluster. We have used the **LOAD CSV** option to load
    the data. You can read more about this at [https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/](https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](Chapter_09.xhtml#_idTextAnchor059)中，我们使用了事务方法来加载数据。如果我们加载的数据量不超过几百万条记录，比如说一亿条，我们可以在合理的时间内加载这些数据。当我们以事务方式加载数据时，Neo4j数据库需要更新索引并保持事务日志分开，将数据提交到数据库。这给过程增加了相当多的开销。但这种方法给我们提供了更多的灵活性和可重用的代码，可以用于增量数据加载。如果我们正在将数据加载到集群中，我们可以使用这种方法来确保数据在集群中可用，因为Neo4j数据库服务器确保更改在集群中复制。我们使用了**LOAD
    CSV**选项来加载数据。您可以在[https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/](https://neo4j.com/docs/cypher-manual/current/clauses/load-csv/)了解更多信息。
- en: This approach is fine for proofs of concept and ad hoc data load purposes, but
    for production systems, the data ingestion should be performed using a client
    by connecting to the database using the Neo4j protocol. While the **LOAD CSV**
    option is simple and attractive, it uses up the database heap to load the data
    and perform the data ingestion, which might not be desirable. A basic Python client
    application that can ingest data into a graph can be found at [https://github.com/neo4j-field/pyingest](https://github.com/neo4j-field/pyingest).
    Note that this is a sample client, and you need to build one that suits your production
    needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于概念验证和临时数据加载目的来说很好，但对于生产系统，数据摄取应该通过连接到数据库的客户端使用Neo4j协议来执行。虽然**LOAD CSV**选项简单且吸引人，但它使用数据库堆来加载数据和执行数据摄取，这可能不是所希望的。您可以在[https://github.com/neo4j-field/pyingest](https://github.com/neo4j-field/pyingest)找到一个基本的Python客户端应用程序，它可以向图中摄取数据。请注意，这是一个示例客户端，您需要构建一个适合您生产需求的客户端。
- en: If the data sizes are bigger, then using the **Neo4j Admin Import** process
    would be best. For this purpose, we need to prepare CSV files for nodes and relationships
    in a specific format and use the `neo4j-admin` tool to prepare the database. You
    can read more about the CSV file formats and examples at [https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin/neo4j-admin-import/](https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin/neo4j-admin-import/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据量更大，那么使用**Neo4j Admin Import**过程会更好。为此，我们需要以特定格式准备节点和关系的CSV文件，并使用`neo4j-admin`工具准备数据库。您可以在[https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin/neo4j-admin-import/](https://neo4j.com/docs/operations-manual/current/tools/neo4j-admin/neo4j-admin-import/)了解更多关于CSV文件格式和示例的信息。
- en: Incremental data load
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量数据加载
- en: The approaches for incremental data loading depend on the framework we will
    use to load the data. If there is a lot of streaming data, then leveraging a framework
    such as Apache Kafka might be a good idea. Also, it is easy to build applications
    to interact with databases to ingest the data using language frameworks such as
    Java, JavaScript, .NET, or Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 增量数据加载的方法取决于我们将用于加载数据的框架。如果有很多流数据，那么利用像Apache Kafka这样的框架可能是个好主意。此外，使用Java、JavaScript、.NET或Python等语言框架构建与数据库交互以摄取数据的应用程序也很容易。
- en: You can read about building client applications for Neo4j at [https://neo4j.com/docs/create-applications/](https://neo4j.com/docs/create-applications/).
    One thing we need to keep in mind is to leverage the managed transactional functions
    so that the driver can retry the transactions as needed in a cluster when the
    cluster topology changes due to network failures or server failures. You can read
    more about this at [https://neo4j.com/docs/java-manual/current/transactions/](https://neo4j.com/docs/java-manual/current/transactions/).
    This link points to Java usage, but the same feature is available for all supported
    language frameworks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://neo4j.com/docs/create-applications/](https://neo4j.com/docs/create-applications/)了解如何为
    Neo4j 构建客户端应用程序。我们需要注意的一点是利用管理事务函数，以便在集群因网络故障或服务器故障导致集群拓扑变化时，驱动程序可以在集群中根据需要重试事务。您可以在[https://neo4j.com/docs/java-manual/current/transactions/](https://neo4j.com/docs/java-manual/current/transactions/)了解更多关于此的信息。此链接指向
    Java 使用，但相同的功能适用于所有受支持的语言框架。
- en: Graph augmentation
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图增强
- en: While we have built the article augmentation and customer augmentation as a
    Spring Boot application, there are other aspects that we have not investigated
    automating. After we generated embeddings for a specified season for the customer,
    we ran the ML aspects as individual commands such as KNN similarity and community
    detection. We might have to automate these aspects, too. Whenever new data is
    ingested into the graph, we might have to trigger the augmentation application
    to generate the embeddings to adapt to the new data we have loaded, and then trigger
    the GDS algorithms after that is completed. Note that the ML pipeline we looked
    at is simple chaining of KNN similarity and community detection; they can be much
    more complex based on the needs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将文章增强和客户增强作为 Spring Boot 应用程序构建，但我们还没有调查自动化其他方面。在为特定季节的客户生成嵌入后，我们运行了如 KNN
    相似性和社区检测等独立的 ML 方面。我们可能也需要自动化这些方面。每当新数据被摄入到图中时，我们可能需要触发增强应用程序以生成嵌入以适应我们加载的新数据，然后在该完成后触发
    GDS 算法。请注意，我们查看的 ML 管道是 KNN 相似性和社区检测的简单链式连接；根据需要，它们可以更加复杂。
- en: If you want to read more about ML pipelines with Neo4j, you can visit [https://neo4j.com/docs/graph-data-science/current/machine-learning/machine-learning/](https://neo4j.com/docs/graph-data-science/current/machine-learning/machine-learning/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 Neo4j 的 ML 管道，您可以访问[https://neo4j.com/docs/graph-data-science/current/machine-learning/machine-learning/](https://neo4j.com/docs/graph-data-science/current/machine-learning/machine-learning/)。
- en: We explored how to look at recommendations as Cypher queries as part of analysis
    and validation. Once we are satisfied with queries, we might have to build an
    application to provide recommendations as needed on demand.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何将推荐作为分析验证的一部分作为 Cypher 查询来查看。一旦我们对查询感到满意，我们可能需要构建一个应用程序，以便根据需要提供推荐。
- en: We have built our application on the Spring Framework, which provides various
    capabilities and options to build a production-grade application that makes it
    easier to deploy and monitor applications. You can read more about how we can
    package the Spring applications for production deployment at [https://docs.spring.io/spring-boot/reference/packaging/index.html](https://docs.spring.io/spring-boot/reference/packaging/index.html).
    You can read more about the production-level features that help us monitor the
    application at [https://docs.spring.io/spring-boot/reference/actuator/index.html](https://docs.spring.io/spring-boot/reference/actuator/index.html).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序是基于 Spring 框架构建的，它提供了各种功能和选项来构建一个生产级的应用程序，这使得部署和监控应用程序变得更加容易。您可以在[https://docs.spring.io/spring-boot/reference/packaging/index.html](https://docs.spring.io/spring-boot/reference/packaging/index.html)了解更多关于我们如何为生产部署打包
    Spring 应用程序的信息。您可以在[https://docs.spring.io/spring-boot/reference/actuator/index.html](https://docs.spring.io/spring-boot/reference/actuator/index.html)了解更多关于生产级特性，这些特性帮助我们监控应用程序。
- en: These are the key principles and considerations for deployment; for production
    deployment, multiple aspects need to be considered, including a proper deployment
    architecture along with application development. Several processes need to be
    deployed for monitoring and performance evaluation to make sure the application
    scales with usage as data and traffic grows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是部署的关键原则和考虑因素；对于生产部署，需要考虑多个方面，包括适当的部署架构以及应用程序开发。需要部署多个流程以进行监控和性能评估，以确保应用程序随着数据和流量的增长而扩展。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this concluding chapter, you learned how to take your Haystack-powered GenAI
    chatbot from local development to a fully deployed, cloud-hosted application using
    Google Cloud Run. We walked through preparing your project structure, containerizing
    your application with Docker, configuring essential Google Cloud services, and
    deploying your chatbot in a scalable and serverless environment. You also learned
    how to verify the deployment, monitor performance, and troubleshoot common issues—equipping
    you with practical skills that extend far beyond just this project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的结尾，您学习了如何将Haystack驱动的GenAI聊天机器人从本地开发过渡到完全部署的、云托管的Google Cloud Run应用程序。我们一步步介绍了准备项目结构、使用Docker容器化应用程序、配置必要的Google
    Cloud服务，以及在可扩展和无服务器环境中部署聊天机器人。您还学习了如何验证部署、监控性能和解决常见问题——这些实用技能远超这个项目本身。
- en: More importantly, this chapter brought everything full circle. From understanding
    knowledge graphs and vector search to integrating GenAI workflows using Haystack
    and Neo4j and, finally, deploying your application to the cloud—you now have a
    complete end-to-end blueprint for building intelligent, scalable, and production-ready
    GenAI applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这一章节将所有内容串联起来。从理解知识图谱和向量搜索，到使用Haystack和Neo4j整合GenAI工作流程，最后将您的应用程序部署到云端——您现在拥有了构建智能、可扩展和现成生产环境的GenAI应用程序的完整端到端蓝图。
- en: We’ve now wrapped up our journey of building Neo4j-powered apps with LLMs. Up
    next, we’ll take a quick look at the key takeaways of this journey.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了使用LLMs构建Neo4j应用程序的旅程。接下来，我们将快速回顾这一旅程的关键收获。
