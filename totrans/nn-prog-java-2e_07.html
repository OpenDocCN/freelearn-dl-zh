<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 7. Clustering Customer Profiles"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch07" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 7. Clustering Customer Profiles</h1></div></div></div><p class="calibre11">One of the amazing capabilities of neural networks applying unsupervised learning is their ability to find hidden patterns which even experts may not have any clue about. In this chapter, we're going to explore this fascinating feature through a practical application to find customer and product clusters provided in transactions database. We'll go through a review on unsupervised learning and the clustering task. To demonstrate this application, the reader will be provided with a practical example on customer profiling and it's implementation in Java. The topics of this chapter are:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Clustering tasks</li><li class="listitem">Cluster analysis</li><li class="listitem">Cluster evaluation</li><li class="listitem">Applied unsupervised learning</li><li class="listitem">Radial basis functions neural network</li><li class="listitem">Kohonen network for clustering</li><li class="listitem">Handling with types of data</li><li class="listitem">Customer profiling</li><li class="listitem">Preprocessing</li><li class="listitem">Implementation in Java</li><li class="listitem">Credit analysis and profiles of customers</li></ul></div><div class="calibre2" title="Clustering tasks"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch07lvl1sec47" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Clustering tasks</h1></div></div></div><p class="calibre11">Clustering is <a id="id437" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>part of a broader set of tasks in data analysis, whose objective is to group elements that look alike, more similar to each other, into clusters or groups. Clustering tasks are fully based on unsupervised learning since there is no need to include any target output data in order to find clusters; instead, the solution designer may choose a number of clusters that they want to group the records into and check the response of the algorithm to it.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="tip28" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">Clustering tasks may seem to overlap with classification tasks with the crucial difference that in clustering there is no need to have a predefined set of classes before the clustering algorithm is run.</p></div></div><p class="calibre11">One may wish to <a id="id438" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>apply clustering when there is little or no information at all about how the data can be gathered into groups. Provided with dataset, we wish our neural network to identify both the groups and their members. While this may seem easy and straightforward to perform visually in a two-dimensional dataset, as shown in the following figure, with a higher number of dimensions, this task becomes not so trivial to perform and needs an algorithmic solution:</p><div class="mediaobject"><img src="Images/B05964_07_01.jpg" alt="Clustering tasks" class="calibre192"/></div><p class="calibre11">In clustering, the number of clusters is not determined by the data, but by the data analyst who is looking to cluster the data. Here the <span class="strong1"><em class="calibre16">boundaries</em></span> are a little bit different than those of classification tasks because they depend primarily on the number of clusters.</p><div class="calibre2" title="Cluster analysis"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec89" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Cluster analysis</h2></div></div></div><p class="calibre11">One difficulty<a id="id439" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> in the clustering tasks, and also in unsupervised learning tasks, is the accurate interpretation of the results. While in supervised learning there is a defined target, from which we can derive an error measure or confusion matrix, in unsupervised learning the evaluation of quality is totally different, and also totally dependent on the data itself. The validation criteria involves indexes that assert how well the data distributed across the clusters is, as well as external opinions from experts on the data that are also a measure of quality.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip29" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">To illustrate an example, let's suppose a task of clustering of plants given their characteristics (sizes, leave colors, period of fruiting, and so on), and a neural network mistakenly groups cactus with pine trees in the same cluster. A botanist would certainly not endorse the classification based on their specific knowledge on the field that this grouping does not make any sense.</p></div></div><p class="calibre11">Two major<a id="id440" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> issues happen in clustering. One is the fact that one neural network's output is never activated, meaning that one cluster does not have any data point associated with it. Another one is the case of nonlinear or sparse clusters, which could be erroneously grouped into several clusters while actually there might be only one.</p><div class="mediaobject"><img src="Images/B05964_07_02.jpg" alt="Cluster analysis" class="calibre193"/></div></div><div class="calibre2" title="Cluster evaluation and validation"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec90" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Cluster evaluation and validation</h2></div></div></div><p class="calibre11">Unfortunately, if the neural network clusters badly, one needs either to redefine the number <a id="id441" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of clusters or perform additional data preprocessing. To<a id="id442" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> evaluate how well the clustered data is, the <a id="id443" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Davies-Bouldin<a id="id444" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> and Dunn indexes may be applied.</p><p class="calibre11">The Davies-Boudin index takes into account the cluster's centroids in order to find inter and intra-distances between clusters and cluster members:</p><div class="mediaobject"><img src="Images/B05964_07_02_01.jpg" alt="Cluster evaluation and validation" class="calibre194"/></div><p class="calibre11">Where <span class="strong1"><em class="calibre16">n</em></span> is the number of clusters, ci is the centroid of cluster i, σi is the average distance of all elements in cluster <span class="strong1"><em class="calibre16">i</em></span>, and d(ci,cj) is the distance between clusters <span class="strong1"><em class="calibre16">i</em></span> and <span class="strong1"><em class="calibre16">j</em></span>. The smaller the value of DB index, the better the neural network will be considered to the cluster.</p><p class="calibre11">However, for <a id="id445" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>dense and sparse clusters, the DB index will not <a id="id446" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>give much useful information. This limitation can be overcome with the Dunn index:</p><div class="mediaobject"><img src="Images/B05964_07_02_02.jpg" alt="Cluster evaluation and validation" class="calibre195"/></div><p class="calibre11">Where <span class="strong1"><em class="calibre16">d(i,j)</em></span> is the inter cluster distance between <span class="strong1"><em class="calibre16">i</em></span> and <span class="strong1"><em class="calibre16">j</em></span>, and <span class="strong1"><em class="calibre16">d'(k)</em></span> is the intra cluster distance of cluster <span class="strong1"><em class="calibre16">k</em></span>. Here the higher the Dunn index is, the better the clustering will be because although the clusters may be sparse, they still need to be grouped together, and high intra-cluster distances will denote a bad grouping of data.</p></div><div class="calibre2" title="Implementation"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec91" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Implementation</h2></div></div></div><p class="calibre11">In<a id="id447" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the <code class="literal">CompetitiveLearning</code> class, we are going to implement these indexes:</p><div class="calibre2"><pre class="programlisting">public double DBIndex(){
  int numberOfClusters = this.neuralNet.getNumberOfOutputs();
  double sum=0.0;
  for(int i=0;i&lt;numberOfClusters;i++){
    double[] index = new double[numberOfClusters];
    for(int j=0;j&lt;numberOfClusters;j++){
      if(i!=j){
        //calculate the average distance for cluster i
        Double Sigmai=averageDistance(i,trainingDataSet);
        Double Sigmaj=averageDistance(j,trainingDataSet);
        Double[] Centeri=neuralNet.getOutputLayer().getNeuron(i).getWeights();
        Double[] Centerj=neuralNet.getOutputLayer().getNeuron(j).getWeights();
        Double distance = getDistance(Centeri,Centerj);
        index[j]=((Sigmai+Sigmaj)/distance);
      }
    }
    sum+=ArrayOperations.max(index);
  }
  return sum/numberOfClusters;
}

public double Dunn(){
  int numberOfClusters = this.neuralNet.getNumberOfOutputs();
  ArrayList&lt;double&gt; interclusterDistance;
  for(int i=0;i&lt;numberOfClusters;i++){
    for(int j=i+1;j&lt;numberOfClusters;j++){
      interClusterDistance.add(minInterClusterDistance (i,j,trainingDataSet);
    }
  }
  ArrayList&lt;double&gt; intraclusterDistance;
  for(int k=0;k&lt;numberOfClusters;k++){
    intraclusterDistance.add(maxIntraClusterDistance(k, trainingDataSet);
  }
  return ArrayOperations.Min(interclusterDistance)/ ArrayOperations.Max(intraclusterDistance);
}</pre></div></div><div class="calibre2" title="External validation"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec92" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>External validation</h2></div></div></div><p class="calibre11">In some <a id="id448" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>cases, there is already an expected result for clustering, as in the example of plants clustering. This is called external validation. One may <a id="id449" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>apply a neural network with unsupervised learning to cluster data that is already assigned a value. The major difference against the classification lies in the fact that the target outputs are not considered, so the algorithm itself is expected to draw a borderline based only on the data.</p></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Applied unsupervised learning"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch07lvl1sec48" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Applied unsupervised learning</h1></div></div></div><p class="calibre11">In neural <a id="id450" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>networks, there are a number of <a id="id451" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>architectures implementing unsupervised learning; however, the scope of this book will cover only the Kohonen neural network, developed in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch04.xhtml" title="Chapter 4. Self-Organizing Maps">Chapter 4</a>, <span class="strong1"><em class="calibre16">Self-Organizing Maps</em></span>.</p><div class="calibre2" title="Kohonen neural network"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec93" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Kohonen neural network</h2></div></div></div><p class="calibre11">Kohonen Networks, which<a id="id452" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> have been covered <a id="id453" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch04.xhtml" title="Chapter 4. Self-Organizing Maps">Chapter 4</a>, <span class="strong1"><em class="calibre16">Self-Organizing Maps </em></span>are now used in a modified fashion. Kohonen can produce a shape in one or two dimensions at the output, but here we are interested in clustering, which can be reduced in only one dimension.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip30" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">Actually the Kohonen neural network implemented in this framework considers the dimensions zero, one, and two, where zero means no connections between the output neurons and one means they form a line, and two means a grid. For this chapter's example, we will need a Kohonen network with no connected output neurons, therefore, the dimension will be zero.</p></div></div><p class="calibre11">In addition, clusters may be related or not to each other, so the vicinity of neurons can be ignored<a id="id454" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> for now in this chapter, which <a id="id455" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>means only one neuron will be activated and their neighbors will remain unchanged. And so, the neural network will adjust its weights to match data to an array of clusters:</p><div class="mediaobject"><img src="Images/B05964_07_03.jpg" alt="Kohonen neural network" class="calibre196"/></div><p class="calibre11">The training algorithm will be the competitive learning, whereby the neuron with the greatest output has its weights adjusted. By the end of training, all the clusters of a neural network are expected to be defined. Note that there are no links between output neurons, meaning that only one input is active at the output.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Profiling"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch07lvl1sec49" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Profiling</h1></div></div></div><p class="calibre11">One of the<a id="id456" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> interesting tasks in unsupervised learning is the profiling or clustering of information, in this chapter, customers and products. Given one dataset, one wants to find groups of records that share similar characteristics. Examples are customers that buy the same products or products that are usually bought together. This task results in a number of benefits for business owners because they are provided the information on which groups of customers and products they have, whereby they are enabled <a id="id457" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>to address them more accurately.</p><div class="calibre2" title="Pre-processing"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec94" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Pre-processing</h2></div></div></div><p class="calibre11">As seen in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch06.xhtml" title="Chapter 6. Classifying Disease Diagnosis">Chapter 6</a>, <span class="strong1"><em class="calibre16">Classifying Disease Diagnosis</em></span> transactional databases can contain both<a id="id458" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> numerical and categorical data. Whenever we face a categorical unscaled variable, we need to split it into the number of values the variable may take, using the <code class="literal">CategoricalDataSet</code> class. For example, let's suppose we have the following transaction list of customer purchases:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Transaction ID</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Customer ID</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Products</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Discount</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Total</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">1399</p>
</td><td class="calibre29">
<p class="calibre26">56</p>
</td><td class="calibre29">
<p class="calibre26">Milk, Bread, Butter</p>
</td><td class="calibre29">
<p class="calibre26">0.00</p>
</td><td class="calibre29">
<p class="calibre26">4.30</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">1400</p>
</td><td class="calibre29">
<p class="calibre26">991</p>
</td><td class="calibre29">
<p class="calibre26">Cheese, Milk</p>
</td><td class="calibre29">
<p class="calibre26">2.30</p>
</td><td class="calibre29">
<p class="calibre26">5.60</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">1401</p>
</td><td class="calibre29">
<p class="calibre26">406</p>
</td><td class="calibre29">
<p class="calibre26">Bread, Sausage</p>
</td><td class="calibre29">
<p class="calibre26">0.00</p>
</td><td class="calibre29">
<p class="calibre26">8.80</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">1402</p>
</td><td class="calibre29">
<p class="calibre26">239</p>
</td><td class="calibre29">
<p class="calibre26">Chipotle Sauce, Spice</p>
</td><td class="calibre29">
<p class="calibre26">0.00</p>
</td><td class="calibre29">
<p class="calibre26">6.70</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">1403</p>
</td><td class="calibre29">
<p class="calibre26">33</p>
</td><td class="calibre29">
<p class="calibre26">Turkey</p>
</td><td class="calibre29">
<p class="calibre26">0.00</p>
</td><td class="calibre29">
<p class="calibre26">4.50</p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">1404</p>
</td><td class="calibre29">
<p class="calibre26">406</p>
</td><td class="calibre29">
<p class="calibre26">Turkey, Butter, Spice</p>
</td><td class="calibre29">
<p class="calibre26">1.00</p>
</td><td class="calibre29">
<p class="calibre26">9.00</p>
</td></tr></tbody></table></div><p class="calibre11">It can easily be seen that the products are unscaled categorical data and for each transaction there is an undefined number of products purchased, the customer may purchase one or several. In order to transform that dataset into a numerical dataset, preprocessing is needed. For each product there will be a variable added to the dataset, resulting in the following:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Cust. Id</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Milk</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Bread</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Butter</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Cheese</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Sausage</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Chipotle Sauce</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Spice</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Turkey</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">56</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">991</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">406</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">239</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td></tr><tr class="calibre28"><td class="calibre29">
<p class="calibre26">33</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td></tr></tbody></table></div><p class="calibre11">In order to save space, we ignored the numerical variables and considered the presence of the product purchased by a client as <span class="strong1"><em class="calibre16">1</em></span> and the absence as <span class="strong1"><em class="calibre16">0</em></span>. Alternative preprocessing may consider the number of occurrences of a value, therefore becoming no longer binary, but discrete.</p></div><div class="calibre2" title="Implementation in Java"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec95" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Implementation in Java</h2></div></div></div><p class="calibre11">In this <a id="id459" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>chapter, we are going to explore the usage of Kohonen neural <a id="id460" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>network applied to customer clustering based on customer information collected from Proben1 (Card dataset).</p></div><div class="calibre2" title="Card – credit analysis for customer profiling"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec96" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Card – credit analysis for customer profiling</h2></div></div></div><p class="calibre11">The card <a id="id461" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>dataset is composed of 16 <a id="id462" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>variables in total. 15 are inputs and one is output. For security reasons, all variable names have been changed to meaningless symbols. This dataset brings a good mix of variable types (continuous, categorical with small numbers of values, and categorical with a larger number of values). The following table shows a summary of data:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Variable</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Type</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Values</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V1</p>
</td><td class="calibre29">
<p class="calibre26">OUTPUT</p>
</td><td class="calibre29">
<p class="calibre26">0; 1</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V2</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #1</p>
</td><td class="calibre29">
<p class="calibre26">b, a</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V3</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #2</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V4</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #3</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V5</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #4</p>
</td><td class="calibre29">
<p class="calibre26">u, y, l, t.</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V6</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #5</p>
</td><td class="calibre29">
<p class="calibre26">g, p, gg</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V7</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #6</p>
</td><td class="calibre29">
<p class="calibre26">c, d, cc, i, j, k, m, r, q, w, x, e, aa, ff</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V8</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #7</p>
</td><td class="calibre29">
<p class="calibre26">v, h, bb, j, n, z, dd, ff, o</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V9</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #8</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V10</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #9</p>
</td><td class="calibre29">
<p class="calibre26">t, f</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V11</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #10</p>
</td><td class="calibre29">
<p class="calibre26">t, f</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V12</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #11</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V13</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #12</p>
</td><td class="calibre29">
<p class="calibre26">t, f</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V14</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #13</p>
</td><td class="calibre29">
<p class="calibre26">g, p, s</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V15</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #14</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">V16</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #15</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td></tr></tbody></table></div><p class="calibre11">For simplicity we didn't use the inputs <span class="strong1"><em class="calibre16">v5-v8</em></span> and <span class="strong1"><em class="calibre16">v14</em></span>, in order to not inflate the number of inputs very much. We applied the following transformation:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Variable</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Type</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Values</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Conversion</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V1</p>
</td><td class="calibre29">
<p class="calibre26">OUTPUT</p>
</td><td class="calibre29">
<p class="calibre26">0; 1</p>
</td><td class="calibre29">
<p class="calibre26">-</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V2</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #1</p>
</td><td class="calibre29">
<p class="calibre26">b, a</p>
</td><td class="calibre29">
<p class="calibre26">b = 1, a = 0</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V3</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #2</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td><td class="calibre29">
<p class="calibre26">-</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V4</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #3</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td><td class="calibre29">
<p class="calibre26">-</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V9</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #8</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td><td class="calibre29">
<p class="calibre26">-</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V10</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #9</p>
</td><td class="calibre29">
<p class="calibre26">t, f</p>
</td><td class="calibre29">
<p class="calibre26">t = 1, f = 0</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V11</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #10</p>
</td><td class="calibre29">
<p class="calibre26">t, f</p>
</td><td class="calibre29">
<p class="calibre26">t = 1, f = 0</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V12</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #11</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td><td class="calibre29">
<p class="calibre26">-</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">V13</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #12</p>
</td><td class="calibre29">
<p class="calibre26">t, f</p>
</td><td class="calibre29">
<p class="calibre26">t = 1, f = 0</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">V15</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #14</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td><td class="calibre29">
<p class="calibre26">-</p>
</td></tr><tr class="calibre28"><td class="calibre29">
<p class="calibre26">V16</p>
</td><td class="calibre29">
<p class="calibre26">INPUT #15</p>
</td><td class="calibre29">
<p class="calibre26">continuous</p>
</td><td class="calibre29">
<p class="calibre26">-</p>
</td></tr></tbody></table></div><p class="calibre11">The<a id="id463" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> neural net topology<a id="id464" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> proposed is shown in the following figure:</p><div class="mediaobject"><img src="Images/B05964_07_04.jpg" alt="Card – credit analysis for customer profiling" class="calibre197"/></div><p class="calibre11">The number of examples stored is 690, but 37 of them have missing values. These 37 records were discarded. Therefore, 653 examples were used to train and test the neural network. The dataset division was made as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><span class="strong1"><strong class="calibre12">Training</strong></span>: 583 records</li><li class="listitem"><span class="strong1"><strong class="calibre12">Test</strong></span>: 70 records</li></ul></div><p class="calibre11">The Kohonen training algorithm used to cluster similar behavior depends on some parameters, such as:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Normalization type</li><li class="listitem">Learning rate</li></ul></div><p class="calibre11">It is<a id="id465" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> important to consider that<a id="id466" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the Kohonen training algorithm is unsupervised. So, this algorithm is used when the output is not known. In the card example there are output values in the dataset and they will be used here only to attest clustering. But in traditional clustering cases, the output values are not available.</p><p class="calibre11">In this specific case, because output is known, as classification, the clustering quality may be attested by:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Sensibility (true positive rate)</li><li class="listitem">Specificity (true negative rate)</li><li class="listitem">Total accuracy</li></ul></div><p class="calibre11">In Java projects, the calculations of these values are done through a class named <code class="literal">NeuralOutputData</code>, previously developed in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch06.xhtml" title="Chapter 6. Classifying Disease Diagnosis">Chapter 6</a>, <span class="strong1"><em class="calibre16">Classifying Disease Diagnosis</em></span>.</p><p class="calibre11">It is good practice to do many experiments to try to find the best neural net to cluster customers' profiles. Ten different experiments will be generated and each will be analyzed with the quality rates mentioned previously. The following table summarizes the strategy that will be followed:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Experiment</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Learning rate</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Normalization type</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#1</p>
</td><td rowspan="2" class="calibre29">
<p class="calibre26">0.1</p>
</td><td class="calibre29">
<p class="calibre26">MIN_MAX</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#2</p>
</td><td class="calibre29">
<p class="calibre26">Z_SCORE</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#3</p>
</td><td rowspan="2" class="calibre29">
<p class="calibre26">0.3</p>
</td><td class="calibre29">
<p class="calibre26">MIN_MAX</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#4</p>
</td><td class="calibre29">
<p class="calibre26">Z_SCORE</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#5</p>
</td><td rowspan="2" class="calibre29">
<p class="calibre26">0.5</p>
</td><td class="calibre29">
<p class="calibre26">MIN_MAX</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#6</p>
</td><td class="calibre29">
<p class="calibre26">Z_SCORE</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#7</p>
</td><td rowspan="2" class="calibre29">
<p class="calibre26">0.7</p>
</td><td class="calibre29">
<p class="calibre26">MIN_MAX</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#8</p>
</td><td class="calibre29">
<p class="calibre26">Z_SCORE</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#9</p>
</td><td rowspan="2" class="calibre29">
<p class="calibre26">0.9</p>
</td><td class="calibre29">
<p class="calibre26">MIN_MAX</p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">#10</p>
</td><td class="calibre29">
<p class="calibre26">Z_SCORE</p>
</td></tr></tbody></table></div><p class="calibre11">The <code class="literal">ClusterExamples</code> class was created to run each experiment. In addition to processing data in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch04.xhtml" title="Chapter 4. Self-Organizing Maps">Chapter 4</a>, <span class="strong1"><em class="calibre16">Self-Organizing Maps </em></span>it was also explained<a id="id467" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> how to create a<a id="id468" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> Kohonen net and how to train it via the Euclidian distance algorithm.</p><p class="calibre11">The following piece of code shows a bit of its implementation:</p><div class="calibre2"><pre class="programlisting">// enter neural net parameter via keyboard (omitted)

// load dataset from external file (omitted)

// data normalization (omitted)

// create ANN and define parameters to TRAIN:
CompetitiveLearning cl = new CompetitiveLearning(kn1, neuralDataSetToTrain, LearningAlgorithm.LearningMode.ONLINE);
  cl.show2DData=false;
  cl.printTraining=false;
  cl.setLearningRate( typedLearningRate );
  cl.setMaxEpochs( typedEpochs );
  cl.setReferenceEpoch( 200 );
  cl.setTestingDataSet(neuralDataSetToTest);

// train ANN
try {
System.out.println("Training neural net... Please, wait...");
  cl.train();
  System.out.println("Winner neurons (clustering result [TRAIN]):");
  System.out.println( Arrays.toString( cl.getIndexWinnerNeuronTrain() ) );
  
} catch (NeuralException ne) {
  ne.printStackTrace();
}</pre></div><p class="calibre11">After running <a id="id469" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>each experiment <a id="id470" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>using the <code class="literal">ClusteringExamples</code> class and saving the confusion matrix and total accuracy rates, it is possible to observe that experiments #4, #6, #8, and #10 have the same confusion matrix and accuracy. These experiments used z-score to normalize data:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Experiment</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Confusion matrix</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Total accuracy</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#1</p>
</td><td class="calibre29">
<p class="calibre26">[[14.0, 21.0]</p>
<p class="calibre26">[18.0, 17.0]]</p>
</td><td class="calibre29">
<p class="calibre26">44.28%</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#2</p>
</td><td class="calibre29">
<p class="calibre26">[[11.0, 24.0]</p>
<p class="calibre26">[34.0, 1.0]]</p>
</td><td class="calibre29">
<p class="calibre26">17.14%</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#3</p>
</td><td class="calibre29">
<p class="calibre26">[[21.0, 14.0]</p>
<p class="calibre26">[17.0, 18.0]]</p>
</td><td class="calibre29">
<p class="calibre26">55.71%</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#4</p>
</td><td class="calibre29">
<p class="calibre26">[[24.0, 11.0]</p>
<p class="calibre26">[1.0, 34.0]]</p>
</td><td class="calibre29">
<p class="calibre26">82.85%</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#5</p>
</td><td class="calibre29">
<p class="calibre26">[[21.0, 14.0]</p>
<p class="calibre26">[17.0, 18.0]]</p>
</td><td class="calibre29">
<p class="calibre26">55.71%</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#6</p>
</td><td class="calibre29">
<p class="calibre26">[[24.0, 11.0]</p>
<p class="calibre26">[1.0, 34.0]]</p>
</td><td class="calibre29">
<p class="calibre26">82.85%</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#7</p>
</td><td class="calibre29">
<p class="calibre26">[[8.0, 27.0]</p>
<p class="calibre26">[7.0, 28.0]]</p>
</td><td class="calibre29">
<p class="calibre26">51.42%</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#8</p>
</td><td class="calibre29">
<p class="calibre26">[[24.0, 11.0]</p>
<p class="calibre26">[1.0, 34.0]]</p>
</td><td class="calibre29">
<p class="calibre26">82.85%</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#9</p>
</td><td class="calibre29">
<p class="calibre26">[[27.0, 8.0]</p>
<p class="calibre26">[28.0, 7.0]]</p>
</td><td class="calibre29">
<p class="calibre26">48.57%</p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">#10</p>
</td><td class="calibre29">
<p class="calibre26">[[24.0, 11.0]</p>
<p class="calibre26">[1.0, 34.0]]</p>
</td><td class="calibre29">
<p class="calibre26">82.85%</p>
</td></tr></tbody></table></div><p class="calibre11">So, neural <a id="id471" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>nets built by <a id="id472" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>experiments #4, #6, #8, or #10 may be used to reach accuracy more than 80% to cluster customers financially.</p></div><div class="calibre2" title="Product profiling"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec97" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Product profiling</h2></div></div></div><p class="calibre11">Using a <a id="id473" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>transactional database provided with the code, we've compiled about 650 purchase transactions into a big matrix transactions <span class="strong1"><em class="calibre16">x</em></span> products, where in each cell there is the quantity of the corresponding product that has been bought on the corresponding transaction:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">#Trns.</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.1</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.2</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.3</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.4</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.5</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.6</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.7</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">…</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Prd.N</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">56</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">3</p>
</td><td class="calibre29">
<p class="calibre26">2</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">2</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">40</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">7</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">19</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">n</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">0</p>
</td><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29">
<p class="calibre26">1</p>
</td></tr></tbody></table></div><p class="calibre11">Let's consider that this matrix is a representation in an N-dimensional hyperspace taking each product as a dimension and the transactions as points. For simplicity, let's consider an example on three dimensions. A given transaction with the quantities bought for each product will be placed in a point corresponding to the quantities at each dimension.</p><div class="mediaobject"><img src="Images/B05964_07_05.jpg" alt="Product profiling" class="calibre198"/></div><p class="calibre11">The idea is to <a id="id474" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>cluster these transactions in order to find which products are usually bought together. So, we are going to use a Kohonen neural network in order to find the positions of the products that the clusters centers will be located at.</p><p class="calibre11">Our database consists of a clothing store and a sample of 27 registered products:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">1 Long Dress A</p>
</td><td class="calibre29">
<p class="calibre26">19 Overall with zipper</p>
</td><td class="calibre29">
<p class="calibre26">43 Bermuda M</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">3 Long Dress B</p>
</td><td class="calibre29">
<p class="calibre26">22 Shoulder overall</p>
</td><td class="calibre29">
<p class="calibre26">48 Stripped skirt</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">7 Short Dress A</p>
</td><td class="calibre29">
<p class="calibre26">23 Long stamped skirt</p>
</td><td class="calibre29">
<p class="calibre26">67 Camisole shoulder strap</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">8 Stamped Dress</p>
</td><td class="calibre29">
<p class="calibre26">24 Stamped short dress</p>
</td><td class="calibre29">
<p class="calibre26">68 Jeans M</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">9 Women Camisole</p>
</td><td class="calibre29">
<p class="calibre26">28 Pants M</p>
</td><td class="calibre29">
<p class="calibre26">69 XL Short dress</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">13 Pants S</p>
</td><td class="calibre29">
<p class="calibre26">31 Sleeveless short dress</p>
</td><td class="calibre29">
<p class="calibre26">74 Stripped camisole S</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">16 Overall for children</p>
</td><td class="calibre29">
<p class="calibre26">32 Short dress shoulder</p>
</td><td class="calibre29">
<p class="calibre26">75 Stripped camisole M</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">17 Shorts</p>
</td><td class="calibre29">
<p class="calibre26">34 Short <a id="id475" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>dress B</p>
</td><td class="calibre29">
<p class="calibre26">76 Stripped camisole L</p>
</td></tr><tr class="calibre28"><td class="calibre29">
<p class="calibre26">18 Stamped overall</p>
</td><td class="calibre29">
<p class="calibre26">42 Two blouse overall</p>
</td><td class="calibre29">
<p class="calibre26">106 Straight skirt</p>
</td></tr></tbody></table></div></div><div class="calibre2" title="How many clusters?"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch07lvl2sec98" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>How many clusters?</h2></div></div></div><p class="calibre11">Sometimes it may be difficult to choose how many clusters to find in a clustering algorithm. Some <a id="id476" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>approaches to determine an optimal choice<a id="id477" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> include information criteria such as <span class="strong1"><strong class="calibre12">Akaike Information Criteria</strong></span> (<span class="strong1"><strong class="calibre12">AIC</strong></span>), <span class="strong1"><strong class="calibre12">Bayesian Information Criteria</strong></span> (<span class="strong1"><strong class="calibre12">BIC</strong></span>), and the <a id="id478" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Mahalanobis distance from the center to the data. We suggest to the reader to check the references if interested in further details on these criteria.</p><p class="calibre11">To make tests to<a id="id479" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> product example, we also should use the <code class="literal">ClusteringExamples</code> class. For simplicity, we run tests with three and five clusters. For each experiment, the number of epochs was <span class="strong1"><em class="calibre16">1000</em></span>, the learning rate was <span class="strong1"><em class="calibre16">0.5</em></span>, and the normalization type was <code class="literal">MIN_MAX (-1; 1)</code>. Some results are shown in the following table:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Number of clusters</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Clusters of the first 15 elements</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Sum of products bought</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">3</p>
</td><td class="calibre29">
<p class="calibre26">0, 1, 2, 2, 2, </p>
<p class="calibre26">2, 2, 2, 2, 2, </p>
<p class="calibre26">2, 2, 0, 0, 2,</p>
</td><td class="calibre29">
<p class="calibre26">973, 585,  11,   5, 2, </p>
<p class="calibre26">  4,  11,   6,   3, 2, </p>
<p class="calibre26">  2,   2, 669, 672, 7,</p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">5</p>
</td><td class="calibre29">
<p class="calibre26">0, 1, 4, 4, 4, </p>
<p class="calibre26">4, 4, 4, 4, 4, </p>
<p class="calibre26">4, 4, 0, 0, 4,</p>
</td><td class="calibre29">
<p class="calibre26">973, 585,  11,   5, 2, </p>
<p class="calibre26">  4,  11,   6,   3, 2, </p>
<p class="calibre26">  2,   2, 669, 672, 7,</p>
</td></tr></tbody></table></div><p class="calibre11">Observing the preceding table, we note when the sum of products acquired is more than 600, then it's clustered together. Otherwise, when the sum is in the range of 500 to 599, another cluster is formed. Lastly, if the sum is low, a large cluster is created, because the dataset is compound by many cases that customers doesn't by more than 20 items.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip31" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">As recommend in the previous chapter, we suggest you explore the <code class="literal">ClusteringExamples</code> class and create a GUI to easily select the neural net parameters. You should try to reuse code through the inheritance concept.</p><p class="calibre17">Another tip is to further explore the product profiling example: varying the neural network training parameters, the number of clusters, and/or develop others ways of analyzing the clustering result.</p></div></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch07lvl1sec50" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Summary</h1></div></div></div><p class="calibre11">In this chapter, we've an application of customer profiling using the Kohonen neural network. Unlike the classification task, the clustering task does not consider the previous knowledge on the desired output; instead it is desirable for the clusters to be found by the neural network. However, we've seen that validation techniques may include external validation, which is a comparison with what could be understood as <span class="strong1"><em class="calibre16">target output</em></span>. Customer profiling is important because it gives a business owner more accurate and clean information about their customers, without the <span class="strong1"><em class="calibre16">human interference</em></span> in pointing which customers are in some groups or in others, as occurs in supervised learning. That's the advantage of unsupervised learning, enabling the data to draw results solely by themselves.</p></div></div>



  </body></html>