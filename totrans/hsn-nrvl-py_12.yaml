- en: Co-Evolution and the SAFE Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduce the concept of co-evolution and explain how it
    can be used to co-evolve the solver and the objective function that optimizes
    the evolution of the solver. We then discuss the **Solution and Fitness Evolution**
    (**SAFE**) method and provide a brief overview of different co-evolution strategies.
    You will learn how to use co-evolution with neuroevolution-based methods. You
    will also get practical experience with the implementation of a modified maze-solving
    experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Co-evolution basics and common co-evolution strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SAFE method basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified maze-solving experiment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion about the results of the experiment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following technical requirements should be met to execute the experiments
    described in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8/10, macOS 10.13 or newer, or modern Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anaconda Distribution version 2019.03 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter9](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter9)
  prefs: []
  type: TYPE_NORMAL
- en: Common co-evolution strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The natural evolution of biological systems cannot be considered separately
    from the concept of co-evolution. Co-evolution is one of the central evolutionary
    drives that leads to the current state of the biosphere, with the diversity of
    organisms that we can perceive around us.
  prefs: []
  type: TYPE_NORMAL
- en: We can define co-evolution as a mutually beneficial strategy of the simultaneous
    evolution of multiple genealogies of different organisms. The evolution of one
    species cannot be possible without other species. During evolution, the co-evolving
    species mutually interact, and these inter-species relations shape their evolutionary
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main types of co-evolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutualism** is when two or more species coexist and mutually benefit each
    other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Competitive co-evolution**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predation** is when one organism kills another and consumes its resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parasitism** is when one organism exploits the resources of another but does
    not kill it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commensalism** is when the members of one species benefit from another species
    without causing harm or benefits to the other species.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type of co-evolution strategy has been explored by researchers, and they
    have pros and cons for use as guiding principles of the neuroevolution process.
    However, a group of researchers recently explored the commensalism strategy as
    a guiding principle for neuroevolution and achieved promising results. They created
    the SAFE algorithm, which we will discuss in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the SAFE algorithm, please refer to the original publication
    at [https://doi.org/10.1007/978-3-030-16670-0_10](https://doi.org/10.1007/978-3-030-16670-0_10).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the common types of co-evolution, let's discuss the
    SAFE method in detail.
  prefs: []
  type: TYPE_NORMAL
- en: SAFE method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, the SAFE method is about the co-evolution of the solution
    and the fitness function, which guides the solution search optimization. The SAFE
    method is built around the *commensalistic* co-evolution strategy of two populations:'
  prefs: []
  type: TYPE_NORMAL
- en: The population of potential solutions, which evolve to solve the problem at
    hand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The population of objective function candidates, which evolve to guide the evolution
    of the solution population
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we have already discussed several search optimization strategies
    that can be used to guide the evolution of potential solution candidates. These
    strategies are objective-based fitness optimization and Novelty Search optimization.
    The former optimization strategy is perfect in situations when we have a plain
    fitness function landscape and can concentrate our optimization search on the
    ultimate goal. In this case, we can use the objective-based metric, which evaluates,
    in each epoch of evolution, how close our current solution is to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The Novelty Search optimization strategy is different. In this strategy, we
    are not interested in the proximity to the ultimate goal, but instead, we are
    concerned mostly about the path that the candidate solutions take. The central
    idea behind the Novelty Search method is to gradually explore the stepping stones,
    which finally lead to the destination. This optimization strategy is ideal for
    situations in which we have an intricate fitness function landscape with many
    deceptive dead ends and local optima.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the main idea behind the SAFE method is to benefit from both search optimization
    methods mentioned here. Hereafter, we will discuss the modified maze experiment,
    which uses both search optimization methods mentioned here to guide the neuroevolution
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Modified maze experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed in this book how to apply either the objective-based
    search optimization or Novelty Search optimization methods to the problem of solving
    a maze. In this chapter, we introduce a modified maze-solving experiment in which
    we try to combine both search optimization methods using the SAFE algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduce the co-evolution of two populations: a population of maze-solving
    agents and a population of objective function candidates. Following the SAFE method,
    we use a commensalistic co-evolution strategy in our experiment. Let''s first
    discuss the maze-solving agent.'
  prefs: []
  type: TYPE_NORMAL
- en: The maze-solving agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maze-solving agent is equipped with a set of sensors, allowing it to perceive
    the maze environment and to know the direction to the maze exit at each step.
    The configuration of the sensors is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fa62210-89a3-4c3e-83eb-2ea33a48e645.png)'
  prefs: []
  type: TYPE_IMG
- en: The maze-solving agent's sensor configuration
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the dark arrows define the range-finder sensors allowing
    the agent to perceive obstacles and find the distance to the obstacle in the given
    direction. The four sectors drawn around the robot's body are pie-slice radars,
    which detect the direction to the maze exit in each time step. The light arrow
    inside the robot's body determines the direction in which the robot is facing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the robot has two actuators: one to change its angular velocity (rotation)
    and another to change its linear velocity.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the same robot configuration that we used in [Chapter 5](22365f85-3003-4b67-8e1e-cc89fa5e259b.xhtml),
    *Autonomous Maze Navigation*. Thus, you should refer to that chapter for more
    details. Now that we have covered the maze-solving agent, let's look at the maze
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The maze environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maze is defined as an area enclosed by walls from the outside. Inside the
    maze, multiple internal walls create multiple dead ends with local fitness optima,
    which makes objective-oriented optimization search not very effective. Furthermore,
    due to the local fitness optima, objective-based search agents can get stuck inside
    a particular dead end, halting the evolution process completely. The dead ends
    are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d638be6b-cb23-4f8c-85b4-2cceb6bb9397.png)'
  prefs: []
  type: TYPE_IMG
- en: The local optima areas within the maze
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the solving agent's starting position is marked by
    a filled circle in the bottom-left corner, and the maze exit is marked by the
    filled circle in the top-left corner. The deceptive local fitness optima values
    are shown as filled sectors the agent's start position.
  prefs: []
  type: TYPE_NORMAL
- en: The maze environment is defined through the configuration file, and we have
    implemented the simulator to simulate the solving agent's traversal through the
    maze. We discussed the maze simulator environment implementation in [Chapter 5](22365f85-3003-4b67-8e1e-cc89fa5e259b.xhtml),
    *Autonomous Maze Navigation*, and you can refer to it for the particulars.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discuss the modifications that were introduced into the
    original experiment to implement the SAFE optimization strategy. The most critical
    difference is how the fitness function is defined, and we discuss that in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the complete implementation details of the maze simulator
    environment in the source code at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/maze_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/maze_environment.py).
  prefs: []
  type: TYPE_NORMAL
- en: Fitness function definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SAFE method is about the co-evolution of solution candidates and the objective
    function candidates, that is, we have two co-evolving populations of species.
    Thus, we need to define two fitness functions: one for the solution candidates
    (maze solvers) and another for objective function candidates. In this section,
    we discuss both variants.'
  prefs: []
  type: TYPE_NORMAL
- en: Fitness function for maze solvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every generation of the evolution, each solution individual (maze solver)
    is evaluated against all objective function candidates. We use the maximum fitness
    score obtained during the evaluation of a maze solver against each objective function
    candidate as a fitness score of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: The fitness function of the maze solver is an aggregate of two metrics—the distance
    from the maze exit (the objective-based score) and the novelty of the solver's
    final position (the novelty score). These scores are arithmetically combined using
    a pair of coefficients obtained as an output from the particular individual in
    the objective function candidate's population.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following formula gives the combination of these scores as a fitness score:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99dd6cf2-6a2e-4556-8ed8-5425e150abf8.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/3503325b-6d31-41e2-b0f0-6a834628f697.png) is the fitness values obtained
    by the evaluation of the solution candidate, ![](img/123669da-9593-4d08-8241-5ff4cfac875e.png),
    against the objective function, ![](img/e453f8b3-5790-49f1-a05f-0c51d6a62f68.png).
    The pair of the coefficients used, ![](img/53c7b36c-1a65-4a9f-8595-ca7a756e87a3.png),
    is the output of the particular objective function candidate. This pair determines
    how the distance to the maze exit (![](img/624adf98-48ae-4495-99e3-5530a8419e25.png))
    and the behavioral novelty (![](img/d029abbb-a6c9-40ab-9c34-a925f61ccac2.png))
    of the solution influence the ultimate fitness score of the maze solver at the
    end of the trajectory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance to the maze exit (![](img/da936b97-ef1d-4664-b1c0-5b345b1d4584.png))
    is determined as the Euclidean distance between the maze solver''s final coordinates
    and the maze exit coordinates. This is shown in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f31a6a7-a7d2-4f25-8104-1dde6650c8d4.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/3e37f415-f49c-4e25-b2b7-bc6da6ba6cb5.png) and ![](img/3867c95c-8ab2-45a4-a478-67c68f75eef7.png)
    are the final coordinates of the maze solver, and ![](img/2f68814d-b56a-4612-beda-2b10ad0268fd.png)
    and ![](img/969ad1ef-bfbf-4e2d-a978-e474b87b9d20.png) are the coordinates of the
    maze exit.'
  prefs: []
  type: TYPE_NORMAL
- en: The novelty score, ![](img/04896aaa-ddc1-4b2a-a092-523c6d720d2f.png), of each
    maze solver is determined by its final position in the maze (point ![](img/e73f9cc2-2135-4af1-a181-cf88e46c68e6.png)).
    It is calculated as the average distance from this point to the k-nearest neighbor
    points, which are the final positions of the other maze solvers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following formula gives the novelty score value at point *x* of the behavioral
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a0e787f-c22c-48ee-9cf9-c45937899fcc.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/ee826d80-17a8-43ca-b909-3da2823ca5e6.png) is the i-th nearest neighbor
    of ![](img/ba9a13e6-7f4d-4fa9-90a9-b46b55b0734b.png), and ![](img/669712d0-2d48-42c2-9474-6e2c62206052.png)
    is the distance between ![](img/1bae89af-0a10-4b72-ad2d-576c0ae140a1.png) and
    ![](img/a9776135-ca81-445d-b2fd-a900c50f2d65.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance between two points is the novelty metric measuring how different
    the current solution (![](img/7178d7f4-99f7-4bb3-bbc1-5b18e3af1c14.png)) is from
    another (![](img/21fafe7a-1559-41b7-b414-fcfa2f9bdb4a.png)) produced by different
    maze solvers. The novelty metric is calculated as the Euclidean distance between
    two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/217974f3-7c7b-4cbc-8fa3-8f326324d2af.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/5d45a339-7baa-4ae5-9d60-ab120d7b2472.png) and ![](img/4b5ba532-39df-4eba-b232-393c6597ed1b.png)
    are the values at position ![](img/19ab567e-e72f-438e-b07c-799a073fbe44.png) of
    the coordinate vectors holding coordinates of the ![](img/8f5c16cc-d11d-4bc6-b4f4-c89d32720229.png)
    and ![](img/32cb7134-f8c8-4fd1-8305-87feb5b67701.png) points correspondingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss how to define the fitness function for the optimization of
    the objective function candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Fitness function for the objective function candidates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SAFE method is based on a commensalistic co-evolutionary approach, which
    means that one of the co-evolving populations neither benefits nor is harmed during
    the evolution. In our experiment, the commensalistic population is the population
    of the objective function candidates. For this population, we need to define a
    fitness function that is independent of the performance of the maze-solver population.
  prefs: []
  type: TYPE_NORMAL
- en: A suitable candidate for such a function is a fitness function that uses the
    novelty score as the fitness score to be optimized. The formula to calculate the
    novelty score of each objective function candidate is the same as given for the
    maze solvers. The only difference is that in the case of the objective function
    candidates, we calculate the novelty score using vectors with the output values
    of each individual. After that, we use the novelty score value as the fitness
    score of the individual.
  prefs: []
  type: TYPE_NORMAL
- en: This method of novelty score estimation is a part of the modified **Novelty
    Search** (**NS**) method, which we discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Modified Novelty Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We presented the NS method in [Chapter 6](62301923-b398-43da-b773-c8b1fe383f1d.xhtml),
    *Novelty Search Optimization Method*. In the current experiment, we use a slightly
    modified version of the NS method, which we discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: The modifications to the NS method that we will present in this experiment relate
    to a new way of maintaining the archive of novelty points. The novelty point holds the
    maze solver's location in the maze at the end of the trajectory, which is combined
    with the novelty score.
  prefs: []
  type: TYPE_NORMAL
- en: In the more traditional version of the NS method, the size of the novelty archive
    is dynamic, allowing the addition of a specific novel point if its novelty score
    exceeds a certain threshold (the novelty threshold). Also, the novelty threshold
    can be adjusted during runtime, taking into account how fast the new novelty points
    are discovered during the evolution. These adjustments allow us to control the
    maximum size of the archive (to some extent). However, we need to start with an
    initial novelty threshold value, and this choice is not an obvious one.
  prefs: []
  type: TYPE_NORMAL
- en: The modified NS method introduces the fixed-size novelty archive to address
    the issue of choosing the correct novelty threshold value. The new novelty points
    are added to the archive until it becomes full. After that, a novelty point is
    added to the archive only if its novelty score exceeds the current minimum score
    of the archive by replacing the current point with a minimal score. Thus, we can
    maintain the fixed size of the novelty archive and store in it only the most valuable
    novelty points discovered during the evolution.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of the modified novelty archive implementation can be found
    at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/novelty_archive.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/novelty_archive.py).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss the most interesting parts of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The _add_novelty_item function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function allows the addition of new novelty points to the archive while
    maintaining its size. It has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code first checks whether the size of the novelty archive has not been exceeded
    yet and directly appends a new novelty point to it in this case. Otherwise, a
    new novelty point replaces the last item in the archive, which is the item with
    the smallest novelty score. We can be sure that the last item in the archive has
    the smallest novelty score because after adding a new item to the archive, we
    sort it in descending order of novelty score value.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluate_novelty_score function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function provides a mechanism to evaluate the novelty score of the novelty
    item against all items already collected in the novelty archive and all the novelty
    items discovered in the current population. We calculate the novelty score as
    the average distance to the *k=15* nearest neighbors by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to collect the distances from the provided novelty item to all items
    in the novelty archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we add the distances from the provided novelty item to all items
    in the current population:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can estimate the average k-nearest neighbors value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We sort the list with the distances in ascending order to guarantee that the
    closest items are first in the list. After that, we calculate the sum of the first
    *k=15* items in the list and divide it by the count of summed values. Thus, we
    obtain the value of the average distance to the *k-nearest neighbors*.
  prefs: []
  type: TYPE_NORMAL
- en: The modified NS optimization method is at the core of the fitness score evaluation
    for both the population of maze solvers and the population of objective function
    candidates. We use it extensively in the implementation of the experiment runner,
    which we discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Modified maze experiment implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the experiment runner is based on the MultiNEAT Python
    library, which we have used in several experiments in this book. The evolution
    of each co-evolving population is controlled by the basic NEAT algorithm, which
    was discussed in [Chapter 3](7acd0cf5-c389-4e55-93d7-9438fcaa1390.xhtml), *Using
    NEAT for XOR Solver Optimization*, [Chapter 4](34913ccd-6aac-412a-8f54-70d1900cef41.xhtml),
    *Pole-Balancing Experiments*, and [Chapter 5](22365f85-3003-4b67-8e1e-cc89fa5e259b.xhtml),
    *Autonomous Maze Navigation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in this section, we demonstrate how to use the NEAT algorithm to maintain
    the co-evolution of two independent populations of species: the maze solvers and
    the objective function candidates.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss the essential parts of the modified maze experiment runner.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, please refer to the source code at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/maze_experiment_safe.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/maze_experiment_safe.py).
  prefs: []
  type: TYPE_NORMAL
- en: Creation of co-evolving populations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this experiment, we need to create two co-evolving populations of species
    with different initial genotype configurations to meet the phenotypic requirements
    of the produced species.
  prefs: []
  type: TYPE_NORMAL
- en: The phenotype of the maze solver has 11 input nodes to receive signals from
    the sensors and two output nodes to produce control signals. At the same time,
    the phenotype of the objective function candidate has one input node receiving
    the fixed value (`0.5`), which is converted into two output values that are used
    as the fitness function coefficients of the maze solver.
  prefs: []
  type: TYPE_NORMAL
- en: We start with a discussion of how to create the population of the objective
    function candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Creation of the population of the objective function candidates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The genotype encoding the phenotype of the objective function candidates must
    produce phenotype configurations that have at least one input node and two output
    nodes, as discussed previously. We implement the population creation in the `create_objective_fun`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we create the NEAT genotype with one input node, two output nodes,
    and one hidden node. The hidden node is pre-seeded into the initial genome to
    boost the evolution with the pre-defined non-linearity. The activation function
    type of the hidden layer is selected to be hyperbolic tangent to support negative
    output values. This feature is essential for our task. A negative value of one
    of the coefficients produced by the objective function candidate can indicate
    that a particular component of the maze solver fitness function has a negative
    influence, and this sends a signal that the evolution needs to try other paths.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we create the `ObjectiveFun` object to maintain an evolving population
    of the objective function candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss how the population of maze solvers is created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the population of maze solvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maze-solver agent needs to get inputs from 11 sensors and generate two
    control signals, which affect the angular and linear velocity of the robot. Thus,
    the genome encoding the phenotype of the maze solver must yield phenotype configurations
    that include 11 input nodes and two output nodes. You can see how the creation
    of the initial population of genomes for the maze-solver agent is implemented
    by taking a look at the `create_robot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we obtain the appropriate NEAT hyperparameters from the `create_robot_params`
    function. After that, we use them to create an initial NEAT genotype with the
    corresponding number of input and output nodes. Finally, we create a `Robot` object,
    which encapsulates all the data related to the maze-solver population, along with
    the maze simulator environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we have created the two co-evolving populations, we need to implement
    the fitness score evaluation for individuals in both populations. We discuss the
    implementation details of the fitness score evaluation in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The fitness evaluation of the co-evolving populations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having defined the two co-evolving populations, we need to create functions
    to evaluate the fitness scores of the individuals in each population. As we have
    already mentioned, the fitness scores of the individuals in the maze-solver population
    depend on the outputs produced by the population of objective function candidates.
    At the same time, the fitness score of each objective function candidate is wholly
    determined by the novelty score of that individual.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have two different approaches to the evaluation of fitness scores,
    and we need to implement two different functions. Hereafter, we discuss both implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Fitness evaluation of objective function candidates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fitness score of each individual in the population of the objective function
    candidates is determined by its novelty score, which is calculated as we discussed
    previously. The implementation of the fitness score evaluation is divided between
    two functions: `evaluate_obj_functions` and `evaluate_individ_obj_function`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss the implementations of both functions.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluate_obj_functions function implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function accepts the `ObjectiveFun` object, which holds the population
    of the objective function candidates, and uses it to estimate the fitness score
    of each individual in the population by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we iterate over all genomes in the population and collect the novelty
    points for each genome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the code, the novelty points obtained from the `evaluate_individ_obj_function`
    function are appended to the list of novelty points in the population. Also, we
    append novelty point data to the list of coefficient pairs. The list of coefficient
    pairs later will be used to estimate the fitness scores of the individual maze
    solvers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we iterate over the list of population genomes and evaluate the novelty
    score of each genome using the novelty points collected in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The novelty score estimated using the novelty points are already collected in
    the novelty archive and the list of the novelty points created for the current
    population. After that, we set the estimated novelty score as the fitness score
    of the corresponding genome. Furthermore, we find the maximum value of the fitness
    score and return it, along with the list of coefficient pairs.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluate_individ_obj_function function implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function accepts the individual NEAT genome of the objective function
    candidate and returns the novelty point evaluation results. We implement it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We start with the creation of a `NoveltyItem` object to hold the novelty point
    data for a given genome. After that, we build a phenotype ANN and activate it
    with an input of `0.5`. Finally, we use the outputs from the ANN to create the
    novelty point.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we discuss the fitness score evaluation of the individuals
    in the maze-solver population.
  prefs: []
  type: TYPE_NORMAL
- en: Fitness evaluation of the maze-solver agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We estimate the fitness score of each individual in the maze-solver population
    as a compound consisting of two components: the novelty score and the distance
    to the maze exit at the end of the trajectory. The influence of each component
    is controlled by a coefficient pair produced by the individuals from the population
    of the objective function candidates.'
  prefs: []
  type: TYPE_NORMAL
- en: The fitness score evaluation is divided into three functions, which we are going
    to discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluate_solutions function implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `evaluate_solutions` function receives the `Robot` object as an input parameter,
    which maintains the population of the maze-solver agent and the maze environment
    simulator. Also, it receives a list of the coefficient pairs generated during
    the evaluation of the population of objective function candidates.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the input parameters of the function to evaluate each genome in the
    population and to estimate its fitness function. Here, we discuss the essential
    implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we evaluate each individual in the population against the maze simulator
    and find the distance to the maze exit at the end of the trajectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we iterate over all genomes in the population and estimate the novelty
    score of each individual. Also, we use the corresponding distance to the maze
    exit collected before and combine it with the calculated novelty score to evaluate
    genome fitness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the first half of the code, we use the `robot.archive.evaluate_novelty_score`
    function to estimate the novelty score of each individual in the population. The
    second half invokes the `evaluate_solution_fitness` function to estimate the fitness
    score of each individual using the novelty score and the distance to the maze
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we collect evaluation statistics about the performance of the best
    maze-solver genome in the population:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the end, all statistics collected during population evaluation are returned
    by the function.
  prefs: []
  type: TYPE_NORMAL
- en: Hereafter, we discuss how the individual maze-solver genome is evaluated against
    the maze environment simulator.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluate_individual_solution function implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the function that evaluates the performance of a particular maze solver
    against the maze environment simulator. It is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the phenotype ANN of the maze solver and use it as a controller
    to guide the robot through the maze:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we create a `NoveltyItem` object to hold the novelty point, which
    is defined by the robot's final position in the maze. After that, we create the
    phenotype ANN and run the maze simulator, using it as the control ANN for a given
    number of time steps (400). After a simulation completes, we receive the distance
    between the final position of the maze solver and the maze exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we save the simulation statistics into the `AgentRecord` object that
    we analyze at the end of the experiment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the function returns a tuple with the following values: a flag
    indicating whether we have found a solution, the distance to the maze exit at
    the end of the robot''s trajectory, and the `NoveltyItem` object encapsulating
    information about the novelty point discovered.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we discuss the implementation of the maze-solver fitness
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluate_solution_fitness function implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function is an implementation of the maze-solver fitness function that
    we discussed earlier. This function receives the distance to the maze exit, the
    novelty score, and the list of coefficient pairs generated by the current generation
    of the objective function candidates. Next, it uses the received input parameters
    to calculate the fitness score as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to normalize the distance and the novelty score values using
    the natural logarithm. This normalization will guarantee that the distance and
    novelty score values are always on the same scale. It is essential to have these
    values on the same scale because the coefficient pair is always in the range `[0,1]`.
    Thus, if the values of distance and novelty score have different scales, a pair
    of coefficients will not be unable to influence the significance of each value
    when calculating the fitness score.
  prefs: []
  type: TYPE_NORMAL
- en: The code iterates over the list of coefficients pairs and, for each pair of
    coefficients, it calculates the fitness score by combining the distance and the
    novelty score values.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate fitness score of the maze solver is the maximum among all found
    fitness scores. This value and the corresponding pair of coefficients are then
    returned by the function.
  prefs: []
  type: TYPE_NORMAL
- en: The modified maze experiment runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, when we have implemented all the necessary routines to create co-evolving
    populations and to evaluate the fitness of individuals within these populations,
    we are ready to start implementing the experiment runner loop.
  prefs: []
  type: TYPE_NORMAL
- en: The complete details can be found in the `run_experiment` function in the `maze_experiment_safe.py`
    file at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/maze_experiment_safe.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/maze_experiment_safe.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we discuss the essential details of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the creation of the corresponding populations of the co-evolving
    species:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start the evolution loop and evaluate both populations as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After evaluating the populations, we save the results as statistics of the
    current generation of the evolution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the evolution loop, we signal to both populations to advance
    to the next epoch if the solution has not been found in the current generation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After the evolution loop completes its iteration over a specified number of
    generations, we visualize the collected maze records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The maze records mentioned here hold the statistics of the evaluation of each
    maze-solver genome in the maze simulator collected during the evolution as `AgentRecord`
    objects. In the visualization, we render the final position of each evaluated
    maze solver with the maze.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simulate maze solving with the control ANN, which was created using
    the best solver genome found during the evolution. The trajectory of the maze
    solver during the simulation can be visualized as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At first, the code creates a phenotype ANN from the best solver genome. Next,
    it runs the maze simulator using the created phenotype ANN as the maze solver
    controller. We then render the collected trajectory points of the maze solver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render the plot with the average fitness scores per generation
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All the visualizations mentioned here are also saved into the local filesystem
    as SVG files and can be used later for result analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we discuss how to run the modified maze experiment and
    the results of the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Modified maze experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost ready to start the experiment with co-evolution using the modified
    maze experiment. However, before that, we need to discuss the hyperparameter selection
    for each co-evolving population.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameters for the maze-solver population
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this experiment, we choose to use the MultiNEAT Python library, which uses
    the `Parameters` Python class to maintain a list of all supported hyperparameters.
    The initialization of the hyperparameters for the population of maze solvers is
    defined in the `create_robot_params` function. Next, we discuss the essential
    hyperparameters and the reasons behind choosing particular values for them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to have a medium-sized population providing sufficient population
    diversity from the very beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are interested in producing a compact genome topology during the evolution
    and limiting the number of species within the population. Thus, we have defined
    tiny probabilities for adding new nodes and connections during the evolution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The novelty score rewards finding unique positions in the maze. One way to
    achieve this is to intensify the numerical dynamics within the phenotype. Thus,
    we have increased the range of connection weights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To support the evolutionary process, we choose to introduce elitism by defining
    the ratio of the genomes to be transferred to the next generation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The elitism value determines that about one-tenth of the individuals will be
    carried to the next generation.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameters for the objective function candidates population
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create the hyperparameters for the evolution of the population of objective
    function candidates in the `create_objective_fun_params` function. Here, we discuss
    the most critical hyperparameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to start with a small population to reduce computational costs.
    Also, the genotypes of the objective function candidate are not expected to be
    very complicated. Thus, a small population should be sufficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the maze solvers, we are interested in producing compact genomes. Thus,
    the probabilities of adding new nodes and connections are kept very small:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are not expecting a complicated topology of genomes in the population of
    the objective function candidates. Thus, most of the hyperparameters are set to
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: Working environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this experiment, we use the MultiNEAT Python library. Thus, we need to create
    an appropriate Python environment, which includes this library and other dependencies.
    You can set up the Python environment with the help of Anaconda with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These commands create the `maze_co` virtual environment with Python 3.5 and
    install all necessary dependencies into it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the modified maze experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to run the experiment in the newly created virtual environment.
    You can start the experiment by cloning the corresponding Git repository and running
    the script with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to activate the appropriate virtual environment with the `conda
    activate maze_co` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command starts one trial of the experiment for `150` generations
    of evolution using the medium-complexity maze configuration. After about `100`
    generations of evolution, a successful solution is discovered by the neuroevolution
    process, and you should be able to see the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From the output presented here, you can see that a successful maze solver was
    found at generation `105` and was able to solve the maze in 338 steps from the
    allotted 400\. Also, it is interesting to note that the coefficient pair produced
    by the best objective function candidate gives slightly more importance to the
    novelty score component of the maze-solver fitness function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to take a look at the plot of the best fitness scores per
    generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/812c2596-9516-4ca5-a854-6f90a391fa61.png)'
  prefs: []
  type: TYPE_IMG
- en: The fitness scores per generation
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding plot, you can see that the best fitness score has a maximum
    in the early generations of evolution. This is due to the high novelty score values,
    which are easier to obtain at the beginning of the evolution because there are
    many maze areas that have not been explored. Another essential point to note is
    that the average distance to the maze exit remains almost at the same level for
    most of the generations of evolution. Thus, we can assume that the correct solution
    was found not by gradual improvements, but rather by a quality leap of the champion
    genome. This conclusion is also supported by the next plot, where we render the
    collected maze records per species:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3c0e7fd-8a02-43b7-a9f3-df8e4e59c386.png)'
  prefs: []
  type: TYPE_IMG
- en: The maze records with final maze solvers positions
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding plot has two parts: the top for species with an objective fitness
    score (based on the distance from the maze exit) greater than **0.8**, and the
    bottom for other species. You can see that only one species produced a maze-solver
    genome that was able to reach the vicinity of the maze exit. Also, you can see
    that the genomes belonging to that species demonstrate very explorative behavior
    by exploring more maze areas than all other species combined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we discuss the path of the successful maze solver through the maze,
    which is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70fc92ee-1779-4fef-b8a6-4ea935d83d97.png)'
  prefs: []
  type: TYPE_IMG
- en: The path of the successful maze solver through the maze
  prefs: []
  type: TYPE_NORMAL
- en: The path of the successful maze solver is near-optimal for the given maze configuration.
  prefs: []
  type: TYPE_NORMAL
- en: This experiment also demonstrates the importance of the initial conditions in
    finding a successful solution. The initial conditions are defined by the random
    seed value that we choose before running the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have included the hard-to-solve maze configuration into the experiment source
    code at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/hard_maze.txt](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter9/hard_maze.txt).
    You can try to solve the hard maze configuration by using the following command:
    `python maze_experiment_safe.py -g 120 -t 5 -m hard --width 200 --height 200`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have found a successful solution using `1571021768` as a random seed value.
    Try to find another random seed value producing a successful solution. How many
    generations did it take to find it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the co-evolution of two populations of species.
    You learned how commensalistic co-evolution can be implemented to produce a population
    of successful maze solvers. We introduced you to an exciting approach of implementing
    a fitness function of the maze solver that combines the objective-based score
    and the novelty score using coefficients produced by the population of the objective
    function candidates. Also, you have learned about the modified Novelty Search
    method and how it differs from the original method, which we discussed in [Chapter
    6](62301923-b398-43da-b773-c8b1fe383f1d.xhtml), *Novelty Search Optimization Method*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the knowledge gained in this chapter, you will be able to apply a commensalistic
    co-evolution approach to your work or research tasks that have no clear fitness
    function definition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the deep neuroevolution method and
    how to use it to evolve agents that are able to play classic Atari games.
  prefs: []
  type: TYPE_NORMAL
