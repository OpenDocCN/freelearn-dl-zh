- en: How It All Comes Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切如何汇聚在一起
- en: 'We''ve almost arrived at the end of our journey. We''ve learned all the essential
    tools to implement fun AI in our Unity game. We stressed this throughout the course
    of the book, but it''s important to drive the point home: the concepts and patterns
    we learned throughout the book are individual concepts, but they can, and often
    should, be used in harmony to achieve the desired behavior from our AI. Before
    we say our goodbyes, we''ll look at a simple tank-defense game that implements
    some of the concepts that we''ve learned to achieve a cohesive "game," and I only
    say "game" because this is more of a blueprint for you to expand upon and play
    with. In this chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎到达了旅程的终点。我们已经学会了在Unity游戏中实现有趣AI的所有基本工具。我们在整本书的过程中都强调了这一点，但重要的是要强调：我们在整本书中学到的概念和模式是单独的概念，但它们可以，并且通常应该和谐地使用，以实现我们AI期望的行为。在我们告别之前，我们将查看一个简单的坦克防御游戏，该游戏实现了一些我们学到的概念，以实现一个统一的“游戏”，我之所以说“游戏”，是因为这更像是一个供你扩展和玩耍的蓝图。在本章中，我们将：
- en: Integrate some of the systems we've learned in a single project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们学过的某些系统整合到一个单一的项目中
- en: Create an AI tower agent
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个AI塔楼代理
- en: Create our `NavMeshAgent` tank
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的`NavMeshAgent`坦克
- en: Set up the environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Test our sample scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的示例场景
- en: Setting up the rules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置规则
- en: Our "game" is quite simple. While the actual game logic, such as health, damage,
    and win conditions, are left completely up to you, our example focuses on setting
    you up to implement your own tank-defense game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“游戏”相当简单。虽然实际的游戏逻辑，如健康、伤害和胜利条件，完全由你决定，但我们的示例专注于为你搭建一个平台，以便你实现自己的坦克防御游戏。
- en: When deciding on what kind of logic and behavior you'll need from your agent,
    it's important to have the rules of the game fleshed out beyond a simple idea.
    Of course, as you implement different features, those rules can change, but having
    a set of concepts nailed down early on will help you pick the best tools for the
    job.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定你的代理需要什么样的逻辑和行为时，重要的是游戏规则要具体化，而不仅仅是简单的一个想法。当然，随着你实现不同的功能，这些规则可能会改变，但尽早确定一套概念将有助于你选择最适合的工具。
- en: 'It''s a bit of a twist on the traditional tower-defense genre. You don''t build
    towers to stop an oncoming enemy; you rather use your abilities to help your tank
    get through a gauntlet of towers. As your tank traverses the maze, towers along
    the path will attempt to destroy your tank by shooting explosive projectiles at
    it. To help your tank get to the other side, you can use two abilities:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对传统塔防游戏类型的一种小小颠覆。你不是建造塔来阻止即将到来的敌人；相反，你使用你的能力来帮助你的坦克穿过塔楼的迷宫。随着你的坦克穿越迷宫，路径上的塔将试图通过向它射击爆炸性投射物来摧毁你的坦克。为了帮助你的坦克到达另一边，你可以使用两种能力：
- en: 'Boost: This ability doubles your tank''s movement speed for a short period
    of time. This is great for getting away from a projectile in a bind.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速：这个能力会在短时间内加倍你的坦克移动速度。这对于摆脱困境中的投射物非常有用。
- en: 'Shield: This creates a shield around your tank for a short period of time to
    block oncoming projectiles.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盾牌：这会在你的坦克周围创建一个短暂的护盾，以阻挡即将到来的投射物。
- en: For our example, we'll implement the towers using a finite state machine, since
    they have a limited number of states and don't require the extra complexity of
    a behavior tree. The towers will also need to be able to be aware of their surroundings,
    or more specifically, whether the tank is nearby so that they can shoot at it,
    so we'll use a sphere trigger to model the towers' field of vision and sensing.
    The tank needs to be able to navigate the environment on its own, so we use a
    NavMesh and `NavMeshAgent` to achieve this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用有限状态机来实现塔楼，因为它们有有限的状态，不需要行为树额外的复杂性。塔楼还需要能够感知其周围环境，或者更具体地说，坦克是否在附近，以便它们可以射击它，因此我们将使用球体触发器来模拟塔楼的视野和感知。坦克需要能够独立于环境导航，因此我们使用NavMesh和`NavMeshAgent`来实现这一点。
- en: Creating the towers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建塔楼
- en: 'In the sample project for this chapter, you''ll find a `Tower` prefab in the
    `Prefabs` folder. The tower itself is quite simple; it''s just a group of primitives
    arranged to look like a cannon, as you can see in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例项目中，你会在`Prefabs`文件夹中找到一个`Tower`预制体。这个塔本身相当简单；它只是一组排列成看起来像大炮的原型，正如你在下面的截图中所见：
- en: '![](img/8c253632-3fee-4b44-b674-d37b4eea57e8.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c253632-3fee-4b44-b674-d37b4eea57e8.png)'
- en: Our beautiful primitive shape tower
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们美丽的原始形状塔
- en: The barrel of the gun is affixed to the spherical part of the tower. The gun
    can rotate freely on its axis when tracking the player so that it can fire in
    the direction of its target, but it is immobile in every other way. Once the tank
    gets far enough away, the tower cannot chase it or reposition itself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 枪管固定在塔的球形部分上。当跟踪玩家时，枪可以在其轴上自由旋转，以便向目标方向射击，但在其他方面它是不可移动的。一旦坦克足够远，塔就无法追逐它或重新定位自己。
- en: 'In the sample scene, there are several towers placed throughout the level.
    As they are prefabbed, it''s very easy to duplicate towers, move them around,
    and reuse them between the levels. Their setup is not terribly complicated either.
    Their hierarchy looks similar to the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例场景中，整个关卡中放置了几个塔。由于它们是预制件，因此复制塔、移动它们并在关卡之间重复使用它们非常容易。它们的设置也不太复杂。它们的层次结构看起来类似于以下截图：
- en: '![](img/d88c2f8d-30dd-4faa-a529-042495e9e0a2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d88c2f8d-30dd-4faa-a529-042495e9e0a2.png)'
- en: The Tower hierarchy in the inspector
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器中的塔层次结构
- en: 'The breakdown of the hierarchy is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构的分解如下：
- en: '`Tower`: Technically, this is the base of the tower: the cylinder that holds
    the rest of it up. This serves no function but to hold the rest of the parts.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tower`：从技术上讲，这是塔的基础：支撑其余部分的圆柱体。它没有任何功能，只是用来支撑其余部分。'
- en: '`Gun`: The gun is where most of the magic happens. It is the sphere mounted
    on the tower with the barrel on it. This is the part of the tower that moves and
    tracks the player.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gun`：枪是大多数魔法发生的地方。它是塔上安装有枪管的球形部件。这是塔中移动并跟踪玩家的部分。'
- en: '`Barrel` and `Muzzle`: The muzzle is located at the tip of the barrel. This
    is used as the spawn point for the bullets that come out of the gun.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Barrel`和`Muzzle`：枪口位于枪管的尖端。这是枪中子弹的发射点。'
- en: 'We mentioned that the gun is where the business happens for the tower, so let''s
    dig in a bit deeper. The inspector with the gun selected looks similar to the
    following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到枪是塔的业务发生地，所以让我们深入了解一下。选择枪的检查器看起来类似于以下截图：
- en: '![](img/b5875c68-5e83-4409-9ddb-00d306ef04f7.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5875c68-5e83-4409-9ddb-00d306ef04f7.png)'
- en: The inspector for the gun
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 枪的检查器
- en: 'There is quite a bit going on in the inspector here. Let''s look at each of
    the components that affect the logic:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，检查器中有很多内容。让我们看看影响逻辑的每个组件：
- en: 'Sphere Collider: This is essentially the tower''s range. When the tank enters
    this sphere, the tower can detect it and will lock on to it to begin shooting
    at it. This is our implementation of perception for the tower. Notice that the
    radius is set to `7`. The value can be changed to whatever you like, but `7` seems
    to be a fair value. Also, note that we set the Is Trigger checkbox to true. We
    don''t want this sphere to actually cause collisions, just to fire trigger events.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球形碰撞体：这实际上是塔的范围。当坦克进入这个球形区域时，塔可以检测到它，并将锁定目标开始射击。这是我们为塔实现的感知功能。请注意，半径被设置为`7`。这个值可以根据你的喜好进行更改，但`7`似乎是一个合理的值。此外，请注意，我们将“是否触发”复选框设置为“是”。我们不希望这个球形实际上引起碰撞，只是触发事件。
- en: 'Rigidbody: This component is required for the collider to actually work properly,
    whether objects are moving or not. This is because Unity does not send collision
    or trigger events to game objects that are not moving, unless they have a `Rigidbody`
    component.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody：这个组件对于碰撞体正常工作是必需的，无论对象是否在移动。这是因为Unity不会向没有`Rigidbody`组件的游戏对象发送碰撞或触发事件，除非它们在移动。
- en: 'Tower: This is the logic script for the tower. It works in tandem with the
    state machine and the state machine behavior, but we''ll look at these components
    in more depth shortly.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tower：这是塔的逻辑脚本。它与状态机和行为协同工作，但我们将稍后深入了解这些组件。
- en: 'Animator: This is our tower''s state machine. It doesn''t actually handle animation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Animator：这是我们的塔状态机。它实际上并不处理动画。
- en: 'Before we look at the code that drives the tower, let''s take a brief look
    at the state machine. It''s not terribly complicated, as you can see in the following
    screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看驱动塔的代码之前，让我们简要地看看状态机。正如你在以下截图中所见，它并不复杂：
- en: '![](img/bb39c091-8d25-4171-aa58-dd855b10c11d.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb39c091-8d25-4171-aa58-dd855b10c11d.png)'
- en: The state machine for the tower
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 塔的状态机
- en: 'There are two states that we care about: `Idle` (the default state) and `LockedOn`.
    The transition from `Idle` to `LockedOn` happens when the `TankInRange` bool is
    set to `true`, and the reverse transition happens when the bool is set to `false`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注两种状态：`Idle`（默认状态）和 `LockedOn`。当 `TankInRange` 布尔值设置为 `true` 时，从 `Idle` 到
    `LockedOn` 的转换发生，而当布尔值设置为 `false` 时，反向转换发生。
- en: 'The `LockedOn` state has a `StateMachineBehaviour` class attached to it, which
    we''ll look at next:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`LockedOn` 状态附有一个 `StateMachineBehaviour` 类，我们将在下一部分进行探讨：'
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we enter the state and `OnStateEnter` is called, we find a reference to
    our player. In the provided example, the player is tagged as `"Player"` so that
    we are able to get a reference to it using `GameObject.FindWithTag`. Next, we
    fetch a reference to the `Tower` component attached to our tower prefab and set
    its `LockedOn` bool to `true`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入状态并调用 `OnStateEnter` 时，我们找到对玩家的引用。在提供的示例中，玩家被标记为 `"Player"`，这样我们就能使用 `GameObject.FindWithTag`
    获取对其的引用。接下来，我们获取附加到我们的塔预制件上的 `Tower` 组件的引用，并将其 `LockedOn` 布尔值设置为 `true`。
- en: As long as we're in the state, `OnStateUpdate` gets called on each frame. Inside
    this method, we get a reference to the `Gun GameObject` (which the `Tower` component
    is attached to) via the provided `Animator` reference. We use this reference to
    the gun to have it track the tank using `Transform.LookAt`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们处于该状态，`OnStateUpdate` 就会在每一帧被调用。在这个方法内部，我们通过提供的 `Animator` 引用获取对 `Gun GameObject`（`Tower`
    组件附加到的对象）的引用。我们使用这个枪的引用，通过 `Transform.LookAt` 来跟踪坦克。
- en: Alternatively, as the `LockedOn` bool of the `Tower` is set to `true`, this
    logic could be handled in the `Tower.cs` script instead.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于 `Tower` 的 `LockedOn` 布尔值被设置为 `true`，这个逻辑可以在 `Tower.cs` 脚本中处理。
- en: Lastly, as we exit the state, `OnStateExit` gets called. We use this method
    to do a little cleanup. We reset the rotation of our gun to indicate that it is
    no longer tracking the player, and we set the tower's `LockedOn` bool back to
    `false`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们退出状态时，会调用 `OnStateExit`。我们使用此方法进行一些清理工作。我们将枪的旋转重置，以表明它不再跟踪玩家，并将塔的 `LockedOn`
    布尔值重新设置为 `false`。
- en: 'As we can see, this `StateMachineBehaviour` interacts with the `Tower.cs` script,
    so let''s look at `Tower.cs` next for a bit more context as to what''s happening:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个 `StateMachineBehaviour` 与 `Tower.cs` 脚本交互，所以让我们接下来看看 `Tower.cs`，以获得更多关于正在发生什么的上下文：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First up, we declare our variables and properties.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的变量和属性。
- en: We need a reference to our state machine; this is where the `Animator` variable
    comes in. The next three variables, `fireSpeed`, `fireCounter`, and `canFire`,
    all relate to our tower's shooting logic. We'll see how that works later.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对状态机的引用；这就是 `Animator` 变量的作用。接下来的三个变量 `fireSpeed`、`fireCounter` 和 `canFire`
    都与我们的塔的射击逻辑相关。我们稍后会看到它是如何工作的。
- en: As we mentioned earlier, the muzzle is the location the bullets will spawn from
    when shooting. The projectile is the prefab we're going to instantiate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，枪口是射击时子弹将从中发射的位置。投射物是我们将要实例化的预制件。
- en: 'Lastly, `isLockedOn` is get and set via `LockedOn`. While this book, in general,
    strays away from enforcing any particular coding convention, it''s generally a
    good idea to keep values private unless explicitly required to be public, so instead
    of making `isLockedOn` public, we provide a property for it to access it remotely
    (in this case, from the `LockedOnState` behavior):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`isLockedOn` 通过 `LockedOn` 进行获取和设置。虽然这本书总体上避免强制执行任何特定的编码约定，但通常一个好的做法是除非明确需要公开，否则保持值私有，因此，我们不是将
    `isLockedOn` 设置为公开，而是提供一个属性来远程访问它（在这种情况下，从 `LockedOnState` 行为访问）：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next up, we have all our methods, and the meat and potatoes of the tower logic.
    Inside the `Update` loop, we check for two things—are we locked on, and can we
    fire? If both are true, we fire off our `Fire()` coroutine. We'll look at why
    `Fire()` is a coroutine before coming back to the `OnTrigger` messages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有所有我们的方法，以及塔逻辑的核心。在 `Update` 循环内部，我们检查两件事——我们是否锁定，以及我们是否可以开火。如果两者都为真，我们就调用
    `Fire()` 协程。在我们回到 `OnTrigger` 消息之前，我们将看看为什么 `Fire()` 是一个协程。
- en: Coroutines can be a tricky concept to grasp if you're not already familiar with
    them. For more information on how to use them, check out Unity's documentation
    at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前不熟悉协程，协程可能是一个难以理解的概念。有关如何使用协程的更多信息，请查看 Unity 的文档：[http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html)。
- en: As we don't want our tower to be able to constantly shoot projectiles at the
    tank like a projectile-crazy death machine, we use the variables that we defined
    earlier to create a cushion between each shot. After we call `FireProjectile()`
    and set `canFire` to `false`, we start a counter from 0 up to `fireSpeed`, before
    we set `canFire` to `true` again. The `FireProjectile()` method handles the instantiation
    of the projectile and shoots it out toward the direction the gun is pointing to
    using `Rigidbody.AddForce`. The actual bullet logic is handled elsewhere, but
    we'll look at that later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望我们的塔楼像疯狂发射弹丸的死亡机器一样不断向坦克射击，我们使用我们之前定义的变量来在每次射击之间创建一个缓冲区。在调用`FireProjectile()`并将`canFire`设置为`false`之后，我们从一个计数器从0开始到`fireSpeed`，然后再将`canFire`再次设置为`true`。`FireProjectile()`方法处理弹丸的实例化和向枪口指向的方向射击，使用`Rigidbody.AddForce`。实际的子弹逻辑在其他地方处理，但稍后我们会看看。
- en: Lastly, we have our two `OnTrigger` events—one for when something enters the
    trigger attached to this component and another for when an object leaves said
    trigger. Remember the `TankInRange` bool that drives the transitions for our state
    machine? This variable gets set to `true` here when we enter the trigger and back
    to `false` as we exit. Essentially, when the tank enters the gun's sphere of "vision,"
    it instantly locks on to the tank, and the lock is released when the tank leaves
    the sphere.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有两个`OnTrigger`事件——一个是在有东西进入此组件附加的触发器时，另一个是在对象离开该触发器时。还记得驱动我们状态机转换的`TankInRange`布尔变量吗？当我们进入触发器时，这个变量被设置为`true`，当我们退出时，它回到`false`。本质上，当坦克进入枪的“视野”球体时，它会立即锁定坦克，当坦克离开球体时，锁定会释放。
- en: Making the towers shoot
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让塔楼射击
- en: 'If we look back at our `Tower` component in the inspector, you''ll notice that
    a prefab named `bullet` is assigned to the `projectile` variable. This prefab
    can be found in the `Prefabs` folder of the sample project. The prefab looks similar
    to the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下检查器中的`Tower`组件，你会注意到一个名为`bullet`的预制件被分配给`projectile`变量。这个预制件可以在示例项目的`Prefabs`文件夹中找到。预制件看起来类似于以下截图：
- en: '![](img/75bd09a2-4848-4d9f-93a1-56721e3b0711.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75bd09a2-4848-4d9f-93a1-56721e3b0711.png)'
- en: The bullet prefab
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹预制件
- en: 'The `bullet` game object is nothing fancy; it''s just a bright yellow orb.
    There is a sphere collider attached to it, and, once again, we must make sure
    that `IsTrigger` is set to `true` and it has a `Rigidbody` (with `gravity` turned
    `off`) attached to it. We also have a `Projectile` component attached to the `bullet`
    prefab. This handles the collision logic. Let''s take a look at the code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`bullet`游戏对象没有什么特别的地方；它只是一个明亮的黄色球体。它附有一个球体碰撞器，并且，同样，我们必须确保`IsTrigger`设置为`true`，并且它附有一个`Rigidbody`（`gravity`被关闭）附上。我们还有一个附加到`bullet`预制件上的`Projectile`组件。这处理碰撞逻辑。让我们看看代码：'
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have a fairly straightforward script here. In our level, we have all of
    the floor and walls tagged as `"Environment"`, so in our `OnTriggerEnter` method,
    we check that the trigger this projectile is colliding with is either the player
    or the environment. If it is, we instantiate an `explosion` prefab and destroy
    the projectile. Let''s take a look at the `explosion` prefab, which looks similar
    to this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一个相当直接的脚本。在我们的关卡中，我们将所有地板和墙壁标记为`"Environment"`，所以在我们的`OnTriggerEnter`方法中，我们检查这个弹丸正在与之碰撞的触发器是玩家或环境。如果是，我们实例化一个`explosion`预制件并销毁弹丸。让我们看看`explosion`预制件，它看起来类似于以下截图：
- en: '![](img/fdb692f3-6d7d-4492-a0b6-aab7c7d06041.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdb692f3-6d7d-4492-a0b6-aab7c7d06041.png)'
- en: Inspector with the explosion prefab selected
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 选择带有爆炸预制件的检查员
- en: 'As we can see, there is a very similar game object here; we have a sphere collider
    with `IsTrigger` set to `true`. The main difference is an `animator` component.
    When this `explosion` is instantiated, it expands as an explosion would, then
    we use the state machine to destroy the instance when it transitions out of its
    explosion state. The `animation` controller looks similar to the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里有一个非常相似的游戏对象；我们有一个设置为`true`的`IsTrigger`的球体碰撞器。主要区别是有一个`animator`组件。当这个`explosion`被实例化时，它会像爆炸一样膨胀，然后我们使用状态机在它从爆炸状态过渡出来时销毁实例。`animation`控制器看起来与以下截图类似：
- en: '![](img/fdd64ced-6e0f-4f64-a04b-1b0faf254e31.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdd64ced-6e0f-4f64-a04b-1b0faf254e31.png)'
- en: The animation controller driving the explosion prefab
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动爆炸预制件的动画控制器
- en: 'You''ll notice the `explode` state has a behavior attached to it. The code
    inside this behavior is fairly simple:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`explode`状态附加了一个行为。这个行为内的代码相当简单：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All we're doing here is destroying the instance of the object when we exit the
    state, which occurs when the animation ends.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是在我们退出状态时销毁对象的实例，这发生在动画结束时。
- en: If you want to flesh out the game with your own game logic, this may be a good
    place to trigger any secondary effects such as damage, environment particles,
    or anything you can think of!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要用你自己的游戏逻辑来丰富游戏，这可能是一个触发任何次要效果的好地方，比如伤害、环境粒子，或者你能想到的任何东西！
- en: Setting up the tank
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置坦克
- en: The example project also includes a prefab for the tank, which is simply called
    (you guessed it) `Tank`, inside the `Prefabs` folder.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目还包括一个坦克预制件，它简单地称为（你猜对了）`Tank`，位于`Prefabs`文件夹中。
- en: 'The tank itself is a simple agent with one goal: reach the end of the maze.
    As mentioned earlier, the player has to help the tank out along the way by activating
    its abilities to keep it safe from oncoming fire from the towers.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 坦克本身是一个简单的代理，它的目标只有一个：到达迷宫的尽头。如前所述，玩家必须通过激活坦克的能力来帮助坦克，使其免受来自塔楼的来犯之火的伤害。
- en: 'By now, you should be fairly familiar with the components you''ll encounter
    along the way, except for the `Tank.cs` component attached to the prefab. Let''s
    take a look at the code to figure out what''s going on behind the scenes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经相当熟悉你将遇到的所有组件，除了附加到预制件的`Tank.cs`组件。让我们看看代码，找出幕后发生了什么：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a number of values that we want to be able to tweak easily, so we
    declare the corresponding variables first. Everything from the duration of our
    abilities to the effects associated with them is set here first:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够轻松调整一些值，因此我们首先声明相应的变量。从我们技能的持续时间到与之相关的效果，所有这些都在这里首先设置：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our `Start` method simply does some setup for our tank; it grabs the `NavMeshAgent`
    component and sets its destination to be equal to our goal variable. We will discuss that in
    more detail soon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Start`方法只是为我们坦克做一些设置；它获取`NavMeshAgent`组件并将其目的地设置为等于我们的目标变量。我们很快会详细讨论这一点。
- en: 'We use the `Update` method to catch the input for our abilities. We''ve mapped
    `B` to `boost` and `S` to `shield`. As these are timed abilities, much like the
    towers'' ability to shoot, we implement these via coroutines:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Update`方法来捕捉我们技能的输入。我们将`B`映射到`加速`，将`S`映射到`盾牌`。由于这些是计时技能，就像塔楼的射击能力一样，我们通过协程来实现这些：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The two abilities' logic is very similar. The `shield` enables and disables
    the `shield` game object, which we define in a variable in the inspector, and
    after an amount of time equal to `shieldDuration` has passed, we turn it off and
    allow the player to use the `shield` again.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 两个技能的逻辑非常相似。`盾牌`通过在检查器中定义的变量来启用和禁用`盾牌`游戏对象，当经过等于`盾牌持续时间`的时间后，我们将其关闭，并允许玩家再次使用`盾牌`。
- en: The main difference in the `Boost` code is that rather than enabling and disabling
    a game object, the `boost` calls `Play` on a particle system we assign via the
    inspector and also sets the speed of our `NavMeshAgent` to double the original
    value, before resetting it at the end of the ability's duration.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`加速`代码中的主要区别在于，它不是通过启用和禁用游戏对象，而是通过检查器分配的粒子系统上的`Play`调用，并将我们的`NavMeshAgent`的速度设置为原始值的两倍，然后在技能持续时间的末尾将其重置。'
- en: Can you think of other abilities you'd give the tank? This is a very straightforward
    pattern that you can use to implement new abilities in your own variant of the
    project. You can also add additional logic to customize the shield and boost abilities
    here.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到给坦克赋予的其他能力吗？这是一个非常直接的模式，你可以用它来实现你自己在项目中的新能力。你还可以在这里添加额外的逻辑来自定义盾牌和加速能力。
- en: 'The sample scene already has an instance of the tank in it with all the variables
    properly set up. The inspector for the tank in the sample scene looks similar
    to the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 样本场景中已经有一个坦克实例，所有变量都已正确设置。样本场景中坦克的检查器看起来类似于以下截图：
- en: '![](img/cc16eec0-8050-4694-8e02-9b985fe42d2e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc16eec0-8050-4694-8e02-9b985fe42d2e.png)'
- en: Inspector with the tank instance selected
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 选择坦克实例的检查器
- en: As you can see in the preceding screenshot, we've assigned the `Goal` variable
    to a transform with the same name, which is located in the scene at the end of
    the maze we've set up. We can also tweak the duration of our abilities here, which
    is set to 3 by default. You can also swap out the art for the abilities, be it
    the particle system used in the boost or the game object used for the shield.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的屏幕截图中所见，我们将`Goal`变量分配给了具有相同名称的变换，它位于我们设置的迷宫末尾的场景中。我们还可以调整我们能力的时间长度，默认设置为3。你也可以更换能力的艺术效果，无论是用于加速的粒子系统还是用于护盾的游戏对象。
- en: 'The last bit of code to look at is the code driving the camera. We want the
    camera to follow the player, but only along its `z` value, horizontally down the
    track. The code to achieve this looks similar to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要查看的代码是驱动摄像机的代码。我们希望摄像机跟随玩家，但只沿着其`z`值，水平沿着轨道。实现这一点的代码看起来类似于这样：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we simply set the target position of the camera equal to its
    current position on all axes, but we then assign the *z* axis of the target position
    to be the same as our target's, which, if you look in the inspector, has been
    set to the transform of the tank. We then use linear interpolation (`Vector3.Lerp`)
    to smoothly translate the camera from its current position to its target position
    every frame.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们只是将摄像机的目标位置设置为它在所有轴上的当前位置，但我们然后将目标位置的`z`轴设置为与我们的目标相同，如果你查看检查器，会发现它已经被设置为坦克的变换。然后我们使用线性插值（`Vector3.Lerp`）在每一帧将摄像机从当前位置平滑地移动到目标位置。
- en: Bonus tank abilities
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励坦克能力
- en: The sample project also includes three bonus tank abilities for you to play
    with. Of course, you are highly encouraged to modify these abilities or implement
    your own custom rules, but for the sake of spicing up the example a bit, all you
    have to do is add the component for each ability you want to add to the tank prefab.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 样本项目还包括三个额外的坦克能力供你玩耍。当然，我们非常鼓励你修改这些能力或实现你自己的自定义规则，但为了使示例更加丰富，你只需要为想要添加到坦克预制件中的每个能力添加组件。
- en: 'The bonus abilities are:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励能力包括：
- en: '**Hulk mode**: Your tank grows in size for a set amount of time. Want a challenge?
    Implement a health and armor system similar to our *HomeRock* example from [Chapter
    6](8db41b31-be4b-432f-a68e-ef13e1f7e03b.xhtml), *Behavior Trees, *and have the
    buff be represented visually by this ability!'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浩克模式**：你的坦克在设定的时间内变大。想要挑战？实现一个类似于我们[第6章](8db41b31-be4b-432f-a68e-ef13e1f7e03b.xhtml)，*Behavior
    Trees*中的*HomeRock*示例的健康和护甲系统，并且让这个增益效果通过这个能力在视觉上表示出来！'
- en: '**Shrink mode**: It''s the opposite of hulk mode, duh! Your tank shrinks for
    a set period of time. If you''re feeling up to the task, try implementing a stealth
    system where turrets are unable to detect your tank while it''s in shrink mode.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩小模式**：这是与浩克模式相反的，对吧！你的坦克在设定的时间内缩小。如果你觉得这个任务很有挑战性，尝试实现一个潜行系统，其中炮塔在缩小模式下无法检测到你的坦克。'
- en: '**Time warp, or as I like to call it, DMV mode**: This ability sloooows down
    time to a crawl. If you want a real challenge, try implementing a selective weapon
    system, where the turrets could try to outsmart you by using a faster projectile
    to counter your time warp mode!'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间扭曲，或者像我喜欢叫的，DMV模式**：这种能力将时间缓慢到几乎停止。如果你想挑战自己，尝试实现一个选择性的武器系统，其中炮塔可以使用更快的弹丸来对抗你的时间扭曲模式！'
- en: Where you take the abilities system is up to you. It's always fun to see what
    different directions readers take their own versions of these samples. If you
    have a cool twist on this or any of the previous samples, share them with the
    author via Twitter (`@ray_barrera`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择如何使用能力系统。看到读者如何以不同的方向使用这些样本的版本总是很有趣。如果你对这或之前的任何样本有独特的想法，请通过Twitter（`@ray_barrera`）与作者分享。
- en: Setting up the environment
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'As our tank uses a `NavMeshAgent` component to traverse the environment, we
    need to set up our scene using static game objects for the bake process to work
    properly, as we learned in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*. The maze is set up in a way so that towers are spread out
    fairly reasonably and the tank has plenty of space to maneuver around easily.
    The following screenshot shows the general layout of the maze:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的坦克使用`NavMeshAgent`组件来穿越环境，我们需要使用静态游戏对象设置我们的场景，以便烘焙过程能够正常工作，正如我们在[第4章](503803fe-f343-4a0c-835f-463c98005182.xhtml)，*Finding
    Your Way*中所学。迷宫被设置为塔楼分布得相当合理，坦克有足够的空间轻松地移动。以下屏幕截图显示了迷宫的一般布局：
- en: '![](img/4bf0c3e1-c60e-458d-8baf-bfb1b5edb461.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![调整设置](img/4bf0c3e1-c60e-458d-8baf-bfb1b5edb461.png)'
- en: The gauntlet our tank must run through
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 坦克必须通过的障碍
- en: As you can see, there are seven towers spread out through the maze and a few
    twists and turns for our tank to break line of sight. In order to avoid having
    our tank graze the walls, we adjust the settings in the navigation window to our
    liking. By default, the example scene has the agent radius set to 1.46 and the
    step height to 1.6\. There are no hard rules for how we arrived at these numbers;
    it is just trial and error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，迷宫中分布着七个塔，坦克需要绕过一些弯道才能打破视线。为了避免我们的坦克擦到墙上，我们调整了导航窗口中的设置以符合我们的喜好。默认情况下，示例场景将代理半径设置为1.46，步高设置为1.6。我们到达这些数字没有硬性规则；这只是试错的结果。
- en: 'After baking the NavMesh, we''ll end up with something similar to what''s shown
    in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在烘焙NavMesh之后，我们将得到以下截图所示的内容：
- en: '![](img/c4ee0237-7406-4026-ad63-c547bdd65cbb.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![测试示例](img/c4ee0237-7406-4026-ad63-c547bdd65cbb.png)'
- en: The scene after we've baked our NavMesh
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 烘焙我们的NavMesh之后的场景
- en: Feel free to rearrange the walls and towers to your liking. Just remember that
    any blocking objects you add to the scene must be marked as static, and you have
    to rebake the navigation for the scene after you've set everything up just the
    way you like it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随意调整墙壁和塔的位置以符合您的喜好。只需记住，您添加到场景中的任何阻挡物体都必须标记为静态，并且您必须设置好一切后重新烘焙场景的导航。
- en: Testing the example
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试示例
- en: 'The example scene is ready to play right out of the box, so if you didn''t
    get the itch to modify any of the default settings, you can just hit the play
    button and watch your tank go. You''ll notice we''ve added a canvas with a label
    explaining the controls to the player. There is nothing fancy going on here; it''s
    just a simple "press this button to do that" kind of instruction:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例场景可以直接播放，所以如果您没有修改默认设置的冲动，只需按播放按钮，就可以观看您的坦克移动。您会注意到我们为玩家添加了一个带有标签的画布，解释了控制方法。这里没有复杂的功能；它只是简单的“按这个按钮做那个”类型的说明：
- en: '![](img/e899a045-605f-4b1e-bc92-f739d2dcc60c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![玩家引导说明](img/e899a045-605f-4b1e-bc92-f739d2dcc60c.png)'
- en: Simple instructions to guide the player
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的说明来引导玩家
- en: 'The example project is a great example to expand upon and to have fun with.
    With the concepts learned throughout this book, you can expand on the types of
    towers, the tank''s abilities, the rules, or even give the tank more complex,
    nuanced behavior. For now, we can see that the concepts of state machines, navigation,
    perception and sensing, and steering, all come together in a simple yet amusing
    example. The following screenshot shows the game in action:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目是一个很好的例子，可以在此基础上扩展并享受乐趣。通过本书学到的概念，您可以扩展塔的类型、坦克的能力、规则，甚至给坦克更复杂、细腻的行为。目前，我们可以看到状态机、导航、感知和感知以及转向的概念在一个简单而有趣示例中结合在一起。以下截图显示了游戏的实际运行情况：
- en: '![](img/ac4727ce-e444-4ad3-993a-a278e212ef14.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![测试示例](img/ac4727ce-e444-4ad3-993a-a278e212ef14.png)'
- en: The tank-defense game in action
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 坦克防御游戏的实际运行情况
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'So, we''ve reached the end. In this chapter, we took a few of the concepts
    covered in the book and applied them to create a small tank-defense game. We built
    upon the concept of finite state machines, which we originally covered in [Chapter
    2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml), *Finite State Machines and You*,
    and created an artificial intelligence to drive our enemy towers'' behavior. We
    then enhanced the behavior by combining it with sensing and perception, and finally
    we implemented navigation via Unity''s NavMesh feature to help our tank AI navigate
    through our maze-like level, through a gauntlet of autonomous AI towers with one
    thing on their simple AI minds: destroy!'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经到达了终点。在本章中，我们选取了书中的一些概念，并应用它们来创建一个小型坦克防御游戏。我们基于有限状态机的概念，这个概念我们在[第二章](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)“有限状态机与您”中最初介绍过，创建了一个人工智能来驱动我们的敌人塔的行为。然后我们通过结合感知和感知来增强行为，最后通过Unity的NavMesh功能实现了导航，帮助我们的坦克AI在我们的迷宫式关卡中导航，穿过一排自主AI塔，这些塔的简单AI思维只有一个目标：摧毁！
- en: As we conclude this book, take a moment and pat yourself on the back! We've
    covered a lot of ground, and covered a lot of topics. You've now learned about
    state machines, behavior trees, A*, fuzzy logic, and so much more. What's most
    exciting is to think of all the ways in which you can mix-and-match and apply
    these concepts. Hopefully, throughout this book you've been thinking of ways to
    enhance your existing or upcoming games with these concepts. You now have the
    tools to create smarter inhabitants for your digital worlds. Good luck!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束这本书的时候，花点时间给自己鼓掌吧！我们已经覆盖了大量的内容，讨论了许多主题。你现在已经了解了状态机、行为树、A*算法、模糊逻辑等等。最令人兴奋的是思考所有你可以混合搭配并应用这些概念的方式。希望在这本书的阅读过程中，你已经想到了如何利用这些概念来增强你现有的或即将到来的游戏。你现在拥有了为你的数字世界创造更智能居民的工具。祝你好运！
