- en: '*Chapter 10*: Using Python to Control Servo Motors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servo motors can make precise and repeatable motions. Motion such as this is
    vital for moving sensors, controlling robot legs or arms, and moving them to a
    known position. Its uses are so engineers can predict robot behavior, so a robot
    can repeat things in automation, or so code can move limbs to accurately respond
    to what their sensors are instructing them. Raspberry Pi or add-on boards can
    control them. In this chapter, we will use these motors to build a pan and tilt
    mechanism—a head to position a sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are servo motors?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning a servo motor with the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a pan and tilt mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating pan and tilt code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot with the Raspberry Pi built in the previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screwdrivers—small Phillips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small pliers or a set of miniature spanners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nylon bolts and standoffs kit—2.5 mm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A two-axis mini pan-tilt micro servo kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two micro SG90/9g or MG90s servo motors, with their hardware and servo horns.
    The pan-tilt kit may already include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cutting pliers or side cutters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety goggles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2LKh92g](https://bit.ly/2LKh92g).'
  prefs: []
  type: TYPE_NORMAL
- en: What are servo motors?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Servo motors**, or **servomechanism motors**, are used to position robotic
    appendages such as arms, grippers, legs, and sensor mounts. They create other
    movements where the position is the main factor, unlike the wheel motors (DC motors),
    where speed is the controlling factor. Servo motors are used where (to some level
    of accuracy) turning to a specific place might be required. You can use code to
    control these precise positioning movements or a sequence of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A small selection of servo motors
  prefs: []
  type: TYPE_NORMAL
- en: 'Servos come in many sizes, from the very small at around 20-30 mm (shown in
    *Figure 10.1*) to those large enough to move heavy machinery. *Figure 10.2* shows
    some of the miniature hobby servos I use for my robots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – A small selection of servo motors in robots
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've seen where you might use servo motors, we can dive deeper and
    find out how a servo motor works.
  prefs: []
  type: TYPE_NORMAL
- en: Looking inside a servo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the compact form of a servo motor hides a controller, a DC motor, a
    gearbox (usually with a stop), and a sensor. These motors have a built-in feedback
    system. A servo motor takes input from a controller, which specifies a position
    for the motor to go to. The servo''s controller gets the motor''s current direction
    from the internal sensor. The controller compares the current motor position with
    the position that has been requested and generates an error—a difference. Based
    on this difference, the servo drives its motor to try and reduce that error to
    zero. When the motor moves, the sensor changes, and that error value changes,
    generating feedback and making the control loop shown in *Figure 10.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The servo motor control loop
  prefs: []
  type: TYPE_NORMAL
- en: Some types of servo motors, such as those used in ArmBot (*Figure 10.2*), have
    an additional output allowing you to read the state of the position sensor in
    your code too.
  prefs: []
  type: TYPE_NORMAL
- en: Sending input positions to a servo motor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Signals are sent to servo motors using **Pulse Width Modulation** (**PWM**).
    PWM is the same system seen in [*Chapter 2*](B15660_02_Final_ASB_ePub.xhtml#_idTextAnchor033),
    *Exploring Robot Building Blocks – Code and Electronics*, and is used on our robot
    to drive the wheel motors. PWM is a square wave, which has two states, *on* or
    *off* only. It is the timing of the signal, shown in *Figure 10.4*, which is interesting.
    You can consider the wave as a stream of pulses, where the length in time of each
    pulse encodes the position information for the servo controller. These pulses
    repeatedly cycle, with a period or frequency. People usually express frequency
    as cycles-per-second or hertz. A shorter pulse is a lower value, and a longer
    pulse is a higher value. The controller keeps the period/frequency the same, and
    it is the duty cycle (on-time to off-time ratio) that changes. With servo motors,
    the pulse length is the information encoding feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – PWM for servo motors
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10.4*, each graph has time on the *x*-axis. The *y*-axis for each
    of the stacked graphs has **L** for a logic-low and **H** for a logic-high. The
    top graph shows short pulses. The charts at the bottom show increased pulse time;
    however, they vary in an important aspect. In the middle graph, the off-time has
    not changed, but the period has changed.
  prefs: []
  type: TYPE_NORMAL
- en: In the bottom graph of *Figure 10.4*, the period is the same as the first graph,
    but it has a longer pulse time, with shorter off-time. Servo motors measure pulse
    length and not frequency, so the third graph's variation is the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: In our robot, we already have a chip in the motor controller that performs the
    fixed period PWM style. The chip is designed to control LEDs, but happily controls
    other PWM devices. We can control when the off-time and the on-times should start
    in a fixed period, which means it behaves like the bottom graph for longer pulse
    widths.
  prefs: []
  type: TYPE_NORMAL
- en: Pulse width control leads us nicely into the next section, where we make our
    robot generate PWM to position a servo. Let's prepare a servo motor, plug it in,
    and make it move.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning a servo motor with the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To position a servo, we need to set up a **servo horn** to see it move, and
    then plug it into the motor controller board. A servo horn is a small collar with
    one or more arms, usually used to connect the servo spindle/axle to a mechanism
    they move. *Figure 10.5* shows how to attach a horn to a servo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Fitting a servo horn
  prefs: []
  type: TYPE_NORMAL
- en: 'The images in *Figure 10.5* show how to fit a servo horn. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Servo motors usually come with small bags of hardware, containing a few different
    horn types and screws to attach them to the servo and the parts you want them
    to move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the very short small screws for this, as the longer screws can break the
    servo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Screw a one-armed servo horn into the servo. The long collar of the horn fits
    over the servo's output spindle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The servo should now look like this. Don't over-tighten the collar screw, as
    you may need to loosen it and set the middle again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next image, we plug the servo into the control board to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Plugging a servo into the control board
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow *Figure 10.6* to see how to connect the servo to the Full Function Motor
    HAT board on the robot. Make sure you power down the robot fully before connecting
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The outline arrow here indicates the servo connector. Servo connectors have
    three pins shown with the solid arrows: brown for **ground** (**G**), red for
    **voltage** (**V**), and yellow/orange/white for **signal** (**S**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This panel shows that the Motor HAT has a 4 x 3 block of connectors marked **PWM/Servo**,
    indicated by the arrows. The four servo channel columns are numbered (**0**, **1**,
    **14**, and **15**). Each channel has three pins, marked with a pin label (GVS).
    **GVS** refers to **ground**, **voltage**, and **signal**. Align the yellow wire
    from the servo connector with row S and the brown wire with row G, with the red
    wire in the middle. Plug this servo into channel 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The connection is similar to controllers such as the PiConZero, but may require
    some soldering work on other motor boards. Now that you have wired this motor
    in, we need to write some code to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for turning a servo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some board libraries can convert directly from degree to servo movement pulses.
    With this library, we need to write the code for that math. Some of the calculations
    result in constants that won't change once we know which servo controller and
    servo we are using. We can store the results as constants and reuse them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could store the result of such calculations in a variable, but letting
    the computer do it has a few advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The computer is excellent and quick at calculating these constants. It may make
    rounding errors but is likely to make fewer errors than a human would copying
    from a calculator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's clear what numbers came from where and how to calculate them. Putting in
    a *magic number* that came from a calculator makes it harder to see where it came
    from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you change a tuning factor, the calculations stay fresh.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you find an error, it's easy to change it here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When setting out calculations in code, use descriptive variable names and comments—being
    descriptive helps you understand your code and check whether the math makes sense.
    You read code many times after writing it, so this principle applies to any variable
    or function name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s make some test code to move a servo to a position typed by the user
    in degrees. Put this code in `servo_type_position.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Raspi_MotorHAT` library we are using for the robot has a `PWM` module,
    which we import and create an object to manage. We use `atexit` again to ensure
    that the controller stops signaling the motor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must specify the address when setting up the PWM device — it''s the same
    I2C device we are using for the motors and has the same address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The servo works in cycles at 50 Hz; however, we can use 100 Hz so our motors
    can drive too. If the frequency is low, the DC motors will stall very easily.
    This frequency will be a time base for our PWM frequency, which we keep to also
    use in calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s call the middle position 0 degrees. For most servos, turning to -90
    degrees requires a pulse of 1 ms; going to the center requires 1.5 ms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turning it to 90 degrees requires a pulse of 2 ms; this is 0.5 ms from the
    mid-point, which gives us a primary calibration point for 90 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The length of a pulse in our chip also depends on the frequency. This chip
    specifies a pulse''s size as the number of steps per cycle, using 4,096 steps
    (12 bits) to represent this. A higher frequency would require more steps in the
    pulse to maintain the pulse length in milliseconds. We can make a ratio for this;
    steps per millisecond:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have steps per millisecond and know how many milliseconds a pulse
    should be for 90 degrees, we can get a ratio of steps per degree. We can also
    use this to redefine our middle point in steps, too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use these constants in a `convert_degrees_to_pwm` function to get the
    steps needed for any angle in degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we move anything, we should make sure the system stops. We stop by setting
    PWM to `4096`. This number may sound odd, but instead of giving a long pulse,
    it turns on an additional bit in the control board, which turns the servo pin
    entirely off. Turning off the pin releases/relaxes the servo motor. Otherwise,
    the motor would try to seek/hold the last position we gave it until it''s powered
    down. We can use `atexit` to do this, just as we did with stopping motors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now ask for user input in a loop. The `input` function in Python asks
    the user to type something and stores it in a variable. We convert it into an
    integer to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then convert the position to an end step using our preceding calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then use `pwm.setPWM` to set our pulse in steps. It takes the servo
    channel number, a start step, which we''ll hold at 0, and an end step, which we''ve
    calculated previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now turn the robot on and send this code to it. When you run this code,
    it will ask you to type a number. Start with number 0\. When you press *Enter*,
    you will hear the servo move.
  prefs: []
  type: TYPE_NORMAL
- en: You can now try other values, but do not give it values outside of -90 to 90
    degrees as you may damage the servo. We add code later to protect against this
    damage. If this system works, you should see the servo move between each different
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you find problems getting this to run, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the servo motors are plugged into the correct ports and are the
    right way around. The **S** pin should go into a yellow cable on most servos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of jittering or failing to get to the right position can mean you have
    less than fresh batteries—please ensure they are fresh.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running DC motor behaviors from other chapters, if the servo droops, this
    may also be down to lower battery power. Make sure you are using metal hydride
    rechargeables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we move on, how does this Motor HAT control both servo motors and DC
    motors? Let's take a closer look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling DC motors and servo motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HAT that I''ve suggested for this book (and readers may choose others)
    is based on a PCA9685 chip, which is popular for making robots such as this. It
    is a multi-channel PWM controller. Take a look at the diagram for an overview
    of how it is connected in this robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Block diagram of the motor board
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.7* shows a block diagram of the Full Function Motor HAT. This is
    not a wiring diagram, it is still a functional block diagram, but it shows components
    and connections on the board. On the far left is the Raspberry Pi, with a line
    connecting the PCA9685 chip. This line is the I2C communication going into the
    hat, shown by the labeled gray box.'
  prefs: []
  type: TYPE_NORMAL
- en: The PWM generator has many connections out. Eight of these outputs go to control
    TB6612 motor drivers. These have power outputs suitable for DC motors (or stepper
    motors). They are still in the gray box as they are part of the hat. We connected
    those power outputs to our right motor (m1), left motor (m2), and have a space
    m3/m4 connection for other motors.
  prefs: []
  type: TYPE_NORMAL
- en: The servo channels expose four of these PWM outputs directly. We'll connect
    the pan servo to one output and tilt to another.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, I mentioned driving the PWM chip at 100 Hz instead of
    50\. This is because if we combine servo motors and DC motors, the time base for
    the chip applies to all the PWM outputs, even if the duty cycle (on-time to off-time
    ratio) changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have tested the basics, we can calibrate the servo, finding where
    the 0 position is and making sure 90 degrees is moving by the right amount.
  prefs: []
  type: TYPE_NORMAL
- en: Calibrating your servos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The servo horn allows you to see the servo motor''s movement. Zero should be
    close to the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: First, use a screwdriver with the horn to line zero up with the middle. Loosen
    it, lift it, move it around to the middle, and then push it down again. Do not
    tighten this much as we will be removing this again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the servo motor's motion is impeded, including an attempt to move it past
    its limits, it pulls higher currents to try and reach the position. Stalling a
    servo like that can cause a lot of heat and damage to the stalled motor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now try entering 90 and -90\. You may find the two sides are not reaching 90
    because servos can vary slightly. Increase the `deflect_90_in_ms` value to adjust
    the motor range. Do so in small 0.1 increments, as going too far here may lead
    to servo damage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you've calibrated your servo, it is a good idea to ask each servo to go
    to position 0 before starting the next step. You can do this by plugging the second
    servo into channel 1 on the servo's connector, and then swapping the first parameter
    of every call to the `pwm.setPWM` method from 0 to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now tested some basic servo code, and then tried both servos and two
    channels. We can now use the servo motors to build a pan and tilt mechanism to
    point sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pan and tilt mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to build and add a pan and tilt servo mechanism to our robot.
    This mechanism is like a head for our robot to mount sensors on it. A **pan and
    tilt mechanism**, shown in *Figure 10.8*, moves a sensor (or anything else) through
    two axes under servo motor control.
  prefs: []
  type: TYPE_NORMAL
- en: '*Pan* means to turn left or right. *Tilt* means to tilt up or down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – A pan and tilt mechanism from a typical kit
  prefs: []
  type: TYPE_NORMAL
- en: Kits like the one in *Figure 10.8* are available from Mouser, along with Adafruit
    outlets. You may need to purchase the servo motors separately. There are other
    types of pan-tilt. Ensure it is the type that uses two servos and refer to the
    manufacturer's documentation where it is different. We build the kit, mount it
    onto our robot, and plug it into the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our robot block diagram with the servos looks like *Figure 10.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Block diagram of the robot with servo motors added
  prefs: []
  type: TYPE_NORMAL
- en: The block diagram in *Figure 10.9* extends the block diagram from the previous
    chapter by adding the pan and tilt servos. These connect to the Motor HAT.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've seen how it fits in the robot block diagram, it's time to build
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Building the kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need your pan and tilt kit, a screwdriver, and a cutter. *Figure 10.10*
    shows the parts of the mechanism laid out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – The parts of the pan-tilt mechanism
  prefs: []
  type: TYPE_NORMAL
- en: Take note of the terms I use for the different plastic parts in *Figure 10.10*;
    I use those for the assembly. Next to these are the screws that would have come
    with the kit too. There are usually self-tapping M2 screws in a servo motor's
    hardware bag – please ensure you have them.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The plastic here may ping off, so don't do this without safety goggles. Be aware
    of other people in the room and tiny sharp plastic bits landing. Please wear safety
    goggles for this step!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your parts ready, we''ll begin by assembling the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Preparing the pan base
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assemble the base, as shown in *Figure 10.11*, with the help of the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure out and cut a cross-shaped servo horn to fit the base. There are ridges
    it must fit into in the base. Shorten the servo horn's long arms to just over
    three holes and make them slightly thinner with the cutters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Line up the servo horn in the base, so the arms are in the recessed area, and
    the servo horn collar is facing away from the base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find four of the long M2 self-tapping screws.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Screw the servo horn into the base. Note that, with some servo horns, only the
    horizontal or the vertical screws may line up; two is sufficient, but four are
    more secure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our base is now ready. Next, we''ll assemble the left arm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Assembling the left arm and tilt plate
  prefs: []
  type: TYPE_NORMAL
- en: 'To assemble the left arm, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Line up the stud with the hole on the tilt plate, as shown in *Figure 10.12*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the stud into this hole; you will need to hold this in place for the next
    step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take one of the servo motors and the two screws with collars. The servo rests
    on the two brackets on the tilt plate, and when screwed in, holds the left arm
    in place. Ensure that the servo's spindle aligns with the stud and hole before
    screwing it in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great! Now let''s move on to the right arm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Assembling the right arm
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to assemble the arm:'
  prefs: []
  type: TYPE_NORMAL
- en: To assemble the right arm, you need another servo horn—this time, the kind with
    just a collar and a single straight arm. As shown in *Figure 10.13*, the servo
    horn needs trimming to fit the intended recess on the right arm. Use one of the
    M2 self-tapping screws to bolt this onto the right arm of the mechanism. The servo
    horn you have attached is at the front of the mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flip this assembly over and slot another servo (this is the pan servo) into
    the slots as indicated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should have the spindle facing the bottom of the photo, as shown in the third
    panel. This servo motor faces downward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next step is to combine the left and right arm that we just created. Follow
    along:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Combining the left arm and right arm
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to follow these steps to combine the arms:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.14* shows how to bring the left and right arm of the mechanism together.
    When combining the arms, the right arm servo horn''s collar should clip around
    the tilt servo you screwed onto the tilt plate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pan servo, in the left-arm assembly, fits into a matching cut-out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use one of the short screws to attach the collar of the right arm to the tilt
    servo, keeping the tilt plate upright.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use two of the small thin screws to screw the two arms together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re almost there. The last part is to combine the base that we initially
    created to the rest of the mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Combining the base with the mechanism
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue with the procedure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.15* shows how to attach the mechanism to its base. Push the collar
    from the servo horn screwed into the base onto the pan servo spindle. Line it
    up so that the long axis of the base is in line with the bottom of the mechanism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use one of the very short screws to bolt the collar onto the servo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final panel shows the fully assembled pan and tilt mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've seen how a pan and tilt mechanism goes together around the servos. Assembling
    constructions like this is valuable for seeing how these mechanisms work and getting
    a feel for what the servo motors will do when they move. Now that the pan and
    tilt mechanism has been assembled, we need to attach it to the robot before we
    can move the head around.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the pan and tilt mechanism to the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mechanism needs to become part of the robot. We need both to attach it physically
    and wire it in place so that the motor controller can send signals to it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.16* shows how to attach the pan and tilt mechanism to the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Attaching the pan and tilt mechanism to the robot
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these instructions, along with the steps shown in *Figure 10.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: For this, you need two long bolts and two nuts to attach the pan and tilt mechanism
    to the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the bolts into the short end of the pan and tilt base so that they are
    pointing down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The chassis I recommended has a slot across the front, which came in handy for
    the line sensor. This slot is perfect for mounting this pan and tilt mechanism,
    with the screws through the slot. On another chassis, you may need to measure
    and drill holes for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread on the nuts and tighten from beneath the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire in the servos. The tilt (up and down servo) should plug into servo channel
    0, and the pan (left and right) should plug into servo channel 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! Your robot is ready, and the hardware setup is complete. You
    are now ready to write code and try out the new head for your robot. So, let's
    dive straight in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pan and tilt code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We build our pan and tilt code in layers. We create a `Servos` class and put
    the previous calculations into it. We set up our robot class to have an instance
    of the `Servos` class, and ways to access the servo to pan and the servo to tilt.
  prefs: []
  type: TYPE_NORMAL
- en: Making the servo object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this class, we encapsulate (internally manage the details of) converting
    an angle into a servo movement, and the quirks, such as channel numbers, of our
    servo board. We make a `Servos` class in a `servos.py` file for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `servos.py` file starts with an import and then goes straight into the
    constructor (the `__init__` function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add a comment, so when we use the `Servos` class, we can see
    what we meant. The text in here will show up as help for our class in some code
    editors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The triple-quoted string at the top of the constructor is a convention known
    as a **docstring** in Python. Any string declared at the top of a function, method,
    class, or file becomes a special kind of comment, which many editors use to show
    you more help for the library. It's useful in any kind of library layer. The convention
    of using a docstring will complement all of the explanatory comments that we'll
    carry in from the test code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next section of the `__init__` method should look familiar. It sets up
    all the calculations created in *steps 3* to *7* of the *Writing code for turning
    a servo* section within the `servos` object. We are storing the PWM object in
    `self._pwm`. We only keep some of the variables for later by storing them in `self`,
    and the rest are intermediate calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the last part of the `__init__` method, we create `self._channels`; this
    variable lets us use channel numbers 0, 1, 2, and 3, and maps them to the quirky
    numbers on the board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want a safety function to turn all of the servo motors off. Sending
    no pulse at all does that and releases the servos, protecting power and saving
    the motors from damage. This function uses the trick seen in *step 9* of the *Writing
    code for turning a servo recipe*, setting a start time of `0` and `4096` for the
    off flag to generate no pulse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is the conversion function, which we saw in *step 8* of the *Writing code
    for turning a servo section*, but localized to the class. We will only use this
    conversion internally. The Python convention for this is to prefix it with an
    underscore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, we need a method to move the servo to an angle. It will take a channel
    number and an angle. I''ve used another docstring in this method to explain what
    it does and what the limits are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next couple of lines validate the input. It limits the angle to protect
    the servo from an out-of-range value, raising a Python exception if it''s outside.
    An exception pushes a problem like this up to calling systems until one of them
    handles it, killing the code if nobody does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last two lines of this method set the position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find the full code at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/servos.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/servos.py).
  prefs: []
  type: TYPE_NORMAL
- en: This class is now ready to incorporate into our robot. Let's do this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the servo to the robot class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start using the preceding `Servos` class in behaviors, we will incorporate
    it into our `robot.py` file and assign specific purposes to specific servo motors.
    This way, a behavior could use a different robot with differently configured pan
    and tilt mechanisms by swapping out the robot class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to patch this into the `Robot` class in `robot.py`. First, let''s
    import it after the `leds` import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `servos` object then needs to be set up in the constructor for `Robot`,
    passing along the address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we should make sure it stops when the robot stops by adding it to the
    `stop_all` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing to do in `robot` is to map setting pan and tilt values to the
    actual servo motors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `Robot` object now has methods to interact with the pan and tilt servos
    on the robot chassis. This gives us specific controls for servos on the robot
    and presents a layer to use in behaviors. In the next section, we will make a
    behavior that uses these to make circles.
  prefs: []
  type: TYPE_NORMAL
- en: Circling the pan and tilt head
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we make the pan and tilt head move in small circles of around
    30 degrees. This behavior demonstrates the mechanism and the parts of the code
    to talk to it. The code creates a repeating animated kind of behavior that uses
    a time base—a current time. We use the time base to draw the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file; I suggest the name `circle_pan_tilt_behavior.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start with a number of imports; the `Robot` object, the `math` library,
    and some timing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As our behavior has local data, we will put it into a class of its own. The
    constructor (`the__init__` method) takes the `Robot` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This behavior is essentially an animation, so it has a time and count of *frames*
    or positions for each circle. We use a `frames_per_circle` variable to adjust
    how many steps it goes through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The math functions work in radians. A full circle of radians is *2 times pi*.
    We divide that by `frames_per_circle` to make a multiplier we call `radians_per_frame`.
    We can multiply this back out with the current frame to give us a radian angle
    for the circle later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Being a circle, it should also have a radius, representing how far our servos
    deflect from the middle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next method in the behavior is `run`. This puts the behavior in a `while
    True` loop, so it runs until the user stops it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When our behavior runs, we then take `current_time` and turn it into a frame
    number using the modulo (remainder) operation on `frames_per_circle`. The modulo
    constrains the number between zero and the number of frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then take this `frame_number` variable and turn it back into radians, a
    position around the circle, by multiplying it back with `radians_per_frame`. This
    multiplication gives us a value we call `frame_in_radians`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The formula for drawing a circle is to make one of the axes the cosine of the
    angle, times the radius, and the other the sine of the angle, times the radius.
    So, we calculate this and feed each axis to a servo motor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We perform a small `sleep()` to give the motors time to reach their position,
    and then add one to the current time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That entire `run` method together (*steps 7-11*) is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we just want to start up and run our behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, we've built a `Servos` class, and incorporated it to control the pan and
    tilt mechanism in our `Robot` code. You've seen code to move servo motors in an
    animation-like way. We can combine this with the physical pan-tilt in the next
    section to see this run.
  prefs: []
  type: TYPE_NORMAL
- en: Running it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to send `servos.py`, `robot.py`, and `circle_pan_tilt_behavior.py`
    to the Raspberry Pi over SFTP. On the Raspberry Pi, type `python3 circle_pan_tilt_behaviour.py`
    to see it. The head should now be making circles.
  prefs: []
  type: TYPE_NORMAL
- en: This is demonstration code for the device, but will later be able to use the
    same device to track faces by mounting a camera on it. The use of frames here
    to create an animation is important for making smooth predetermined movements
    with a robot, controlling small movements over time.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this does not run, please try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you were able to test the servos as shown in the *Writing code for turning
    a servo* section. There is no need to disassemble the pan and tilt mechanism for
    this, but please make sure you have made a servo move with the code there and
    followed that troubleshooting section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you see errors while running this, please ensure you are running with `python3`.
    Please ensure that you have checked for typos in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code fails to import anything, ensure that you have copied over all the
    preceding files and that you have installed/set up the libraries in previous chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the motors move to an extreme position, you may have missed the step to calibrate
    them. You will need to unbolt and pop each out of the servo horn, send it to position
    0, using the test code from the *Writing code for turning a servo* section, and
    then push them back in at a neutral position, screwing them back in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a servo refuses to move at all, check that it has been plugged in the right
    way, ensuring that G corresponds to the black servo wire, V corresponds to the
    red wire, and S to the yellow signal wire from the servo. The robot code has assumed
    that the servo motors are plugged into channels 0 and 1 of the motor control board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that there are no breaks in the wires or their insulation. I have seen
    a batch of servo motors of this type with wire problems and had to return them.
    You should not be able to see any bare patches of wire.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the connectors are pushed in firmly. If they are loose here, then
    a signal may not be getting to the servo motors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s worth saying again: low batteries will make a servo jitter or fail to
    reach a set point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now have troubleshot the common problems seen with running this circle
    servo motor behavior and see the head making small and slow circles. We will be
    able to use this system in a later chapter to look at faces.
  prefs: []
  type: TYPE_NORMAL
- en: Building a scanning sonar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the distance sensor we attached in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, with the pan and tilt mechanism allows
    us to set up an interesting experiment. If we attach the distance sensor to the
    head, and then slowly sweep in a direction (for example, the pan direction), we
    can create a sensor sweep of an area. We can then use some Python code to plot
    this, making a small map of things in front of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: A sensor similar to this combination is found in advanced robots (like those
    from Boston Dynamics) and autonomous cars. LIDAR and RADAR sensors use laser light
    or radio frequencies with a fast spinning drum to perform the same kind of sweeps
    far faster than our example. LIDAR sensors are starting to appear on the hobbyist
    market, but are still a little costly.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize this, we are going to use a special kind of chart – a polar plot.
    This plots around a circle, with the *x*-axis being where we are around a circle
    (in radians – multiples of pi). The *y*-axis forms how far a plotted point is
    from the center of a circle – so a larger value will be further out. This lends
    itself very well to this example because we are sweeping the servo through angles
    and receiving distance data. We will have to account for the servo working in
    degrees and translate to radians for the graph output.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this step, we''ll extend a sensor''s wires and reposition the sensor onto
    the pan-and-tilt head. Start with the robot powered down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Pop out the sensor and prepare two wires
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to reposition the sensor together with *Figure 10.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to pop one of the distance sensors out of the mount on the robot's
    front. I used the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the pan/tilt head there, identify the small slots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make two lengths of single-core wire or sandwich ties. A length of about 18
    cm for each should suffice:![](img/B15660_10_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.18 – Steps 4 to 6; putting wires in the slots
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For each side, first push the wire through the indicated slot shown in *Figure
    10.18*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bend it around a little, pushing the two ends nearly together so that it doesn't
    just drop out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the other side the same way, so both sides are ready:![](img/B15660_10_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.19 – Wrapping wire underneath the sensor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Put the sensor in place and bend the left wire coming from the top of the head
    around the sensor's front.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now bend it under the big round element (the ultrasonic transducer) indicated
    by the white arrow in *Figure 10.19*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bend the wire sticking out underneath over the sensor:![](img/B15660_10_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.20 – Twist the wire and repeat for the right
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wrap this wire around the top of the left transducer and bring the two wire
    ends together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Twist the top and bottom ends together, as shown in *Figure 10.20*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 8* to *11* for the wires on the right:![](img/B15660_10_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.21 – The sensor temporarily secured to the pan-and-tilt head
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The sensor should now be temporarily secured to the pan-and-tilt head, as shown
    in *Figure 10.21*. You are now ready to wire it back in:![](img/B15660_10_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.22 – Extend the wires and plug the wires in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may need to extend the jumper wires, as shown in *Figure 10.22*. You are
    likely to have more male-female jumper cables left, so use four of those to extend
    the sensor. Be careful to ensure that you make the same connections through these
    to the sensor. It helps to use the same colors if you can.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now make the wire connections to the sensor. Refer back to [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, for reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I suggest running the `test_distance_sensor.py` code from [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, and checking that the sensor is working
    before you continue.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have mounted the sensor on the head, it will move when we instruct
    the servo motors to move. Let's make sure that we have the right tools on the
    Raspberry Pi for the code first.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code will use the Python tool `matplotlib` to output the data. It makes
    a **polar** plot, a graph originating radially from a point, which will look like
    a sonar scan you may have seen in movies. To do this, you will need to install
    Matplotlib (and its dependencies) onto your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH (putty) into the Raspberry Pi and type the following to get the packages
    that Matplotlib requires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing you need is Matplotlib itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Matplotlib may take a short time to install and install many helper packages
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: With the library installed, you are ready to write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make our plot and get the data, the code will move the sensor to the full
    extent on one side, and then move back in steps (for example, 5 degrees), measuring
    at each. This example will show using a sensor and servo motor together and introduce
    other ways to view sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `sonar_scan.py` and follow these steps for its content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with some imports; the `time` import, with which we can give motor
    and sensors time to work, `math` to convert from degrees to radians, `matplotlib`
    to make the display, and `robot` to interface with the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then have some setup parameters. We put these out here to encourage you
    to experiment with different turn speeds and extents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s initialize the `Robot` object and ensure the tilt is looking horizontally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to prepare a place to store our scan data. We will use a dictionary
    mapping from a heading in degrees to the value sensed there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The scan loop starts from the lower bound and increments by the scan step up
    to the upper bound; this gives us our range of facings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each facing in the loop, we need to point the sensor, and wait for the
    servo to move and for the sensor to get readings. We negate the facing here because
    the servo motor turns the opposite way to the polar plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then store the sensor distance as centimeters in the scan data for each
    facing, using the facing as its key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following loop converts the facings into radians. The servo works in degrees,
    but a quirk of Matplotlib is that the polar axis must be in radians:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we make our polar plot, telling Matplotlib the axis and the data, and that
    we want a green line with `g-`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last line writes this plot out to a `png` image file, so we can use `scp`
    to download it from the Raspberry Pi and view the plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Put this code on the Raspberry Pi, place the robot somewhere with a few obstacles
    less than a meter away, and run the code with `python3 sonar_scan.py`. You should
    see the servo motor make a sweep of the bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this runs, the `scan.png` output should look something like *Figure 10.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – A sonar scan plot of my lab
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.23* shows the sonar scan output on a polar plot. It shows the measurements
    in degrees, with a green line tracing the contours of items detected in front
    of the sensor. In this image, my lower bound was -90, my upper bound 90, and my
    step at 2 degrees for slightly finer resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a finer resolution (less than 2 degrees) will make it slower. The sleep
    value could be tuned, but lower values risk the servo not settling or the sensor
    not producing further readings.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you encounter problems while running this tool, please try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, ensure the distance sensor works by following the troubleshooting and
    testing steps in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*. Verify the wiring and use the test
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the servo motors are working, as shown in the preceding *Creating
    the pan and tilt code* section. Follow the troubleshooting procedures there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are errors running the code, ensure that you have installed all the
    libraries needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that there are no typos in the code you have entered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, the file output will be on the Raspberry Pi, so you will have to copy
    it back to view it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can be helpful to print values before they go into the `plt.polar` method.
    Add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now have been able to make a sonar scan and get a plot like the one
    above. I suggest you experiment with the values to create different plot resolutions
    and put different object combinations in front of the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's summarize what we've seen in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about servo motors, how to control them with
    your motor controller, and how they work. You've built a pan and tilt mechanism
    with them and added code to the `Robot` object to work with that mechanism. Finally,
    you've demonstrated all of the parts with the circling behavior.
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to use the code you've seen to control other servo motor systems,
    such as robot arms. The animation style techniques can be useful for smooth movement
    and circular motions. I used a system a little like this when controlling the
    18 motors in SpiderBot's legs.
  prefs: []
  type: TYPE_NORMAL
- en: You've seen how to use a servo with a sensor on a head to make some kind of
    map of the world and related it to the LIDAR systems used on bigger and more expensive
    robots.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at another way to map and observe the world
    with encoders. These sensors will detect wheels turning on our robot to determine
    how our robot is moving.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider how you might build other servo-based extensions. A robot arm needs
    at least four servos, but a simple gripper/grabber can use the two additional
    channels our robot has left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look around at kits for a gripper, a design with a pincer, and perhaps an up/down
    control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you write the code for this gripper? What would you add to the `Robot`
    object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What demo behavior would you make for this gripper?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A gripper might move too violently when just given a different position to be
    in. How would you make a slower smooth movement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: This servo motor control hat is based on the PCA9685 device. The PCA9685 product
    data sheet ([https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf](https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf))
    contains full information about operating this chip. I highly recommend referencing
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I also recommend looking at the SG90 servo motor data sheet ([http://www.ee.ic.ac.uk/pcheung/teaching/DE1_EE/stores/sg90_datasheet.pdf](http://www.ee.ic.ac.uk/pcheung/teaching/DE1_EE/stores/sg90_datasheet.pdf))
    for information about their operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AdaFruit guide to the pan and tilt mechanism ([https://learn.adafruit.com/mini-pan-tilt-kit-assembly](https://learn.adafruit.com/mini-pan-tilt-kit-assembly))
    has a set of assembly instructions. They are in a slightly different order from
    mine but may give a different perspective if this is proving to be tricky.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
