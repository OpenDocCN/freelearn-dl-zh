- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Auto-Code Generation Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a prompt?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-line prompts for auto-code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-line prompts for auto-code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain-of-thought prompts for auto-code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chat with code assistant for auto-code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common building methods of auto-code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the growth in **large language model** (**LLM**) applications, one of the
    interesting use cases, auto-code generation based on user comments, has become
    popular. The last few years have given rise to multiple code assistants for developers,
    such as GitHub Copilot, Codex, Pythia, and Amazon Q Developer, among many others.
    These code assistants can be used to get code recommendations and, in many cases,
    generate error-free code from scratch, just by passing a few plain text comments
    that describe what the user requires from the code.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these code assistants are now backed by LLMs. LLMs are pretrained on
    large publicly available datasets, including public code bases. This training
    on large corpora of data helps code assistants generate more accurate, relevant
    code recommendations. To improve the developer’s code-writing experience, these
    code assistants can not only easily integrate with different **integrated development
    environments** (**IDE**) and code editors but are also readily available with
    different services offered by most of the cloud providers, with minimal configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, auto-code generation is a process in which the developer has the ability
    to interact with different code assistants from any supported code editor, using
    simple plain text comments, to get code recommendations in real time for different
    supported coding languages.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go deeper into auto-code generation with the help of code assistants
    later in this chapter, let’s look at the key concept of prompts related to generative
    AI.
  prefs: []
  type: TYPE_NORMAL
- en: What is a prompt?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As specified earlier, LLMs are pretrained on publicly available large datasets,
    which makes them very powerful and versatile. These LLMs typically have billions
    of parameters that can be used to solve multiple tasks out of the box, without
    the need for additional training.
  prefs: []
  type: TYPE_NORMAL
- en: Users just need to ask the right question with relevant context to get the best
    output from an LLM. The plain text comments/questions that act as an instruction
    to an LLM are called **prompts** and the technique of asking the right questions
    with corresponding context is called **prompt engineering**. While interacting
    with LLMs, providing prompts with precise information and, if required, supplementing
    with additional relevant context, is very important in order to get the most accurate
    results. The same is true while interacting with code assistants as most of the
    code assistants are integrated with an LLM. As a user, while interacting with
    a code assistant, you should provide prompts with simple, specific, and relevant
    context, which helps to generate quality code with high accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the integration of a code assistant with an LLM.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Overview of code assistant integration with an LLM](img/B21378_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Overview of code assistant integration with an LLM
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to interact with code assistants to get the desired
    outcomes. In the following sections, we will explore a few of those techniques.
    To illustrate these techniques, we will leverage the Python programming language
    inside JetBrains’ PyCharm IDE that has been set up to work with Amazon Q Developer
    (refer [*Chapter 2*](B21378_02.xhtml#_idTextAnchor022) for the setup).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Q Developer uses LLMs in the background to generate the code. LLMs, by
    nature, are non-deterministic, so you may not get exactly the same code blocks
    as shown in the code snapshots. However, logically, the generated code should
    meet the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Single-line prompts for auto-code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A single-line prompt for auto-code generation refers to the technique in which
    the user, using a code assistant, specifies requirements in a single line of plain
    text, with the expectation of getting relevant lines of code generated in an automated
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points about single-line prompts for auto-code generation:'
  prefs: []
  type: TYPE_NORMAL
- en: In the single-line prompt technique, instead of specifying complex technical
    details, the user needs to effectively summarize the requirements at a high level
    in plain text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code assistants integrated with LLMs are trained to understand these single-line
    prompts in order to translate them into executable and mostly error-free code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the single-line prompt with instructions, context, and specific requirements,
    code assistants will generate code that can range from a single line to multiple
    lines to more complex functions and classes to meet the intended functional requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single-line prompt for auto-code generation is useful when the code requirement
    is relatively simple and can easily be described in a sentence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single-line prompt for auto-code generation can significantly reduce time,
    compared to manually writing the same code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since a single-line prompt for auto-code generation does not need much prompt-engineering
    experience, it is most commonly used by users who have little to no coding experience.
    In plain text, they can provide *what* the code should do instead of *how* to
    make it happen using actual code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, as simple requirements are used in a single-line prompt, the
    generated code may not require extensive reviews.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary – single-line prompts for auto-code generation
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a single-line prompt for auto-code generation is a technique where
    the user describes relatively simple code requirements using natural language
    in plain text format; the code assistant then uses LLMs to auto-generate single
    or multiple lines of code. It makes coding much simpler and accessible to more
    people, especially users who have relatively little or no coding experience or
    may be new to a specific coding language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a single-line prompt for auto-code generation
    in a PyCharm IDE with Amazon Q Developer enabled as the code assistant, followed
    by the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.2 – Auto-code generation with a single-line prompt in PyCharm IDE
    with Amazon Q Developer](img/B21378_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Auto-code generation with a single-line prompt in PyCharm IDE with
    Amazon Q Developer
  prefs: []
  type: TYPE_NORMAL
- en: Observe that Amazon Q Developer generated a single line of code as our requirement
    was simple and could be easily achieved within a single-line prompt. We will look
    at more complex examples in our next chapters. In this chapter, we are just explaining
    the different techniques of auto-code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You may find typos in a few prompts and screenshots in *Part 2* of the book.
    We have purposely not corrected them to highlight that Amazon Q Developer understands
    the underlying meaning of what's being asked, even with incorrect grammar in the
    prompts.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-line prompts for auto-code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-line prompts for auto-code generation refer to the technique where a user
    can define requirements using natural language text in a single prompt, which
    can span multiple sentences. Based on the information provided in each of the
    sentences, the code assistant then tries to understand the correlation among them
    in order to grasp the requirements and generate the desired code.
  prefs: []
  type: TYPE_NORMAL
- en: The code assistant will mainly rely on key phrases from each of the sentences;
    it will then use each of those key phrases to form a relationship among all the
    sentences. This guides code assistants to use LLMs to form a sequence of code
    lines to meet the requirement. In most cases, code assistants will generate multiple
    lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points about multi-line prompts for auto-code generation:'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-line prompts for auto-code generation are useful when the code requirement
    is relatively complex, has multiple steps, and cannot be easily described in one
    simple sentence, as it may require more context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code assistants use each sentence from the multi-line prompt to extract key
    phrases, then use an LLM to understand the relationship across sentences and key
    phrases. This generates the interpretation of the code fragments and corresponding
    correlations to define end-to-end code requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the complexity of the requirements, better quality and more targeted
    code is usually achieved by providing context in multiple simple, concise sentences.
    These sentences can provide details such as functionality requirements, architectural
    constraints, and platform specifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code generated by multi-line prompts is more customized, elaborative, and relatively
    complex versus single-line prompts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generated code may require code review and thorough testing, and, depending
    on the complexity of the requirements, some code refinement may be needed before
    being promoted to the next project life cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-line prompts for auto-code generation require a good grasp of prompt engineering.
    It’s important to include key details without being overly verbose or ambiguous
    and to understand the generated code. As a result, this technique is typically
    used by users with coding experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accuracy of the code is highly dependent on the maturity/training of the
    code assistants and LLM used to generate the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary – multi-line prompts for auto-code generation
  prefs: []
  type: TYPE_NORMAL
- en: In summary, multi-line prompts for auto-code generation is a technique where
    users describe relatively complex code goals in plain natural language text with
    multiple sentences. Then, the code assistant can use the key phrases from those
    sentences to form relationships around them, which helps understand the user requirements
    and turn them into multiple lines of code. It requires some degree of experience
    in prompt engineering, code reviews, and in some cases, rewriting the generated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of a multi-line prompt for auto-code generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use an auto-generated code block for the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The code needs to be generated with a specific language version – in this case,
    Python 3.6.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code needs to read the `/``user/data/input/sample.csv` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code needs to load data in a pandas DataFrame with a specific name, `csv_data.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code needs to display a sample of 50 rows with a column header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We write the prompt as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.3 – Auto-code generation with a multi\uFEFF-line prompt in the PyCharm\
    \ IDE with Amazon Q Developer](img/B21378_03_003.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Auto-code generation with a multi-line prompt in the PyCharm IDE
    with Amazon Q Developer
  prefs: []
  type: TYPE_NORMAL
- en: Observe that Amazon Q Developer generated multiple lines of code with two functions
    – `read_csv_file()` to read the CSV file and `display_sample_records()` to display
    50 records. Then, it created `__main__` to call both functions to generate an
    end-to-end script.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the preceding code does meet the requirements but, based on user/corporate
    preferences, may need some modification and/or tuning. In the next section, we
    will learn about another technique suitable for experienced developers. This technique
    is particularly beneficial when developers are familiar with the code flow and
    require assistance in generating the code.
  prefs: []
  type: TYPE_NORMAL
- en: Chain-of-thought prompts for auto-code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chain-of-thought prompts for auto-code generation refer to a technique where
    the user employs a combination of single-line or multi-line prompts to provide
    step-by-step instructions. Code assistants then use an LLM to automatically generate
    code for each step individually. Users can use multiple natural language prompts
    that can link together to solve complex requirements. These prompts can be chained
    together to guide the model to produce relevant targeted code. It’s an effective
    technique to divide complex coding tasks into smaller code fragments by providing
    simple prompts to the code assistant one at a time. The code assistant can use
    each prompt to generate more tailored code fragments. Ultimately, all the code
    fragments can be used as building blocks to solve the complex requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points about chain-of-thought prompts for auto-code generation:'
  prefs: []
  type: TYPE_NORMAL
- en: Chain-of-thought prompts are a technique in which users divide complex requirements
    into smaller, more manageable single-line or multi-line prompts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain-of-thought prompts can also be useful for code customization. Users can
    effectively use this technique to obtain customized code by providing specific
    information in a prompt, such as generating code with relevant variable names,
    specific function names, step-by-step logic flow, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code assistants leverage advances in LLMs to generate the code fragments to
    meet each individual prompt, which acts as a part of the final end-to-end code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain-of-thought prompts can be used to generate code for a wide range of tasks,
    such as creating a new project, implementing a specific feature, customizing the
    code to meet custom standards, improving flexibility, accuracy of the code, and
    code organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generated code may require code review and integration testing to verify whether
    all the individual code fragments combined meet the end-to-end requirements. Depending
    on the outcome of test cases, users may need to readjust the prompts or rewrite
    some of the code blocks before being promoted to the next project life cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique can be used by more experienced users as they are mainly responsible
    for tracking the code generation flow to meet the final goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accuracy of the overall code is highly dependent on the prompts provided
    by users, due to which users need to have some background in prompt engineering
    to generate accurate end-to-end code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary – chain-of-thought prompts for auto-code generation
  prefs: []
  type: TYPE_NORMAL
- en: In summary, chain-of-thought prompts for auto-code generation are a technique
    in which users describe complex code requirements in smaller, easier, and more
    manageable single-line or multi-line prompts of plain, natural language text.
    The code assistant uses each of these prompts to generate specific code based
    on the information provided in a prompt. In the end, the output from all these
    individual prompts combined generates the final code. This technique is effective
    in creating highly tailored code. User needs to carry out integration tests to
    verify that the code meets the end-to-end functionality; based on the test case
    results, users may need to adjust the prompts and/or rewrite some of the code
    fragments of the final code.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of chain-of-thought prompts for auto-code generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use an auto-generated code block with multiple prompts for the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Python coding language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code must check whether the `/user/data/input/sample.csv` file is present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function named `read_csv_file()` to read the CSV files. Also, try to
    use a specific `read_csv` from pandas to read records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `read_csv_file()` function to read the `/``user/data/input/sample.csv`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display a sample of 50 records with corresponding column details from the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s break down the preceding requirements into three separate prompts.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, for simplicity, in this example, we will use single-line prompts
    for auto-code generation but based on the complexity of your requirements, you
    can have a combination of single-line and multi-line prompts to achieve chain-of-thought
    prompts. The code assistant generates multiple lines of code based on the prompts,
    accompanied by corresponding inline comments. This simplifies the understanding
    of the code for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first prompt followed by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.4 – Prompt 1: auto-code generation with a chain-of-thought prompt
    in the PyCharm IDE with Amazon Q Developer](img/B21378_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4 – Prompt 1: auto-code generation with a chain-of-thought prompt
    in the PyCharm IDE with Amazon Q Developer'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that Amazon Q Developer created multiple lines of code that included
    a function called `check_file_exists()` with one parameter to get `file_path`,
    which checks whether the file exists or not and returns `True`/`False`. It also
    added the next `file_path` variable with an assigned value as the `/``user/data/input/sample.csv`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second prompt followed by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.5 – Prompt 2: auto-code generation with a chain-of-thought prompt
    in the PyCharm IDE with Amazon Q Developer](img/B21378_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5 – Prompt 2: auto-code generation with a chain-of-thought prompt
    in the PyCharm IDE with Amazon Q Developer'
  prefs: []
  type: TYPE_NORMAL
- en: Here, also observe that Amazon Q Developer created multiple lines of code. As
    instructed, it created a function called `read_csv_file_file_exists()` with one
    parameter to get `file_path` and used the `read_csv` method to read the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the third prompt followed by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.6 – Prompt 3: auto-code generation with a chain-of-thought prompt
    in the PyCharm IDE with Amazon Q Developer](img/B21378_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6 – Prompt 3: auto-code generation with a chain-of-thought prompt
    in the PyCharm IDE with Amazon Q Developer'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, here, observe how Amazon Q Developer created multiple lines of code
    with a `display_sample_records()` function to display the 50 sample records.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next technique for auto-code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Chat with code assistant for auto-code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the code assistants allow users to use a chat-style interaction technique
    to get code recommendations and auto-generate error-free code. Some of the code
    assistant examples include but are not limited to Amazon Q Developer, ChatGPT,
    and Copilot. Just like asking questions to your teammates to get recommendations,
    users can interact with code assistants to ask questions and get recommendations/suggestions
    related to your questions. In addition, many of the code assistants will also
    provide the details in a step-by-step walk-through for the information associated
    with the answer, and will also provide some reference links to get more context.
    Users can review the details and can choose to integrate the code into the main
    program and/or update existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points about chatting with a code assistant for auto-code
    generation:'
  prefs: []
  type: TYPE_NORMAL
- en: Chatting with a code assistant helps users to engage in a question-and-answer
    style interaction in real time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chatting with a code assistant allows users to receive suggestions and recommendations
    by directly asking questions and stating their requirements in natural language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique can be used by users of any experience level to obtain information
    and suggestions, but it requires some experience to understand and review the
    recommended code. It can be utilized to obtain responses for a variety of complex
    code issues, learn new technology, generate detailed designs, retrieve overall
    architecture details, discover coding best practices and code documentation, perform
    debugging tasks, and future support for the generated code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During coding, similar to other prompting techniques, it allows users to describe
    complex requirements in smaller, more manageable step-by-step questions to generate
    code. Additionally, the code assistant tracks the questions and corresponding
    answers to improve responses for future questions by recommending the most relevant
    options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, users are responsible for reviewing and testing to verify that
    the recommended code truly meets the overall needs and integrates within the overall
    code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help users understand the code, the code assistant also provides a detailed
    flow associated with the answer and reference links to obtain additional context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the advanced code assistants, such as Amazon Q Developer, also gather
    context from current files open in the IDE. They automatically retrieve information
    related to the coding language used and the location of the file to provide more
    relevant answers. This assists the code assistant in handling questions related
    to updating existing code, software support, software development, best practices,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accuracy of the overall code is highly dependent on the user’s ability to
    ask relevant and accurate questions with specific details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary – chatting with a code assistant for auto-code generation
  prefs: []
  type: TYPE_NORMAL
- en: In summary, users at any level of experience can utilize chatting with the code
    assistant for auto-code generation. This technique involves interacting with the
    code assistant in a question-and-answer style in real time to receive suggestions
    and/or recommendations for a wide variety of use cases, including complex code,
    detailed designs, overall architecture, coding best practices, code documentation,
    future support, code updates, and understanding the code, among others. In most
    cases, users are responsible for reviewing and integrating the suggested code
    into the main code base during the coding phase. To assist users, code assistants
    can provide details related to the flow associated with the answer and reference
    links to obtain more context.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a generic example of chatting with a code assistant for auto-code
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirement is to get generic help from Amazon Q Developer to understand
    the approaches to debug issues with a Python function and, more specifically,
    for `read_csv_file()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Chatting with a code assistant technique for auto-code generation
    using Amazon Q Developer](img/B21378_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Chatting with a code assistant technique for auto-code generation
    using Amazon Q Developer
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the response with step-by-step details related to our question:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Chatting with a code assistant for auto-code generation – Amazon
    Q Developer response](img/B21378_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Chatting with a code assistant for auto-code generation – Amazon
    Q Developer response
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the response, observe that Amazon Q Developer also provided
    the sources used to provide the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Chatting with a code assistant for auto-code generation – Amazon
    Q Developer sources](img/B21378_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Chatting with a code assistant for auto-code generation – Amazon
    Q Developer sources
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easy for the user, if you just hover over the sources, Amazon Q
    Developer will show exact details from the source in the same window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Chatting with a code assistant for auto-code generation – Amazon
    Q Developer source details](img/B21378_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Chatting with a code assistant for auto-code generation – Amazon
    Q Developer source details
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get into the topic of different building methods of auto-code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Common building methods of auto-code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in the previous sections, different levels of experienced users
    can make use of code assistants to generate the desired code to meet functional
    requirements. In this section, we will walk through some common building methods
    useful for auto-code generation, depending on the complexity of the requirements.
    We will use Amazon Q Developer integration with JetBrains’ PyCharm IDE to illustrate
    how a code assistant can help users automate the generation of code fragments
    and/or get recommendations from the system.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s begin with each of the code-building methods used in the auto-code
    generation technique.
  prefs: []
  type: TYPE_NORMAL
- en: Single-line code completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code assistants that leverage LLMs can keep track of all the prompts provided
    as input by a user. At runtime, code assistants use all the input information
    to suggest relevant code. Here is a simple demonstration of how Amazon Q Developer
    helps users with single-line code completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'When users start typing code in an Amazon Q Developer-enabled environment,
    it can understand the context of the current and previous inputs. It will start
    suggesting the next code block to complete the existing line or recommend the
    next line that may follow after the current one. The following screenshot highlights
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Single-line code completion in the PyCharm IDE using Amazon
    Q Developer](img/B21378_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Single-line code completion in the PyCharm IDE using Amazon Q
    Developer
  prefs: []
  type: TYPE_NORMAL
- en: Observe that when the user starts typing the DataFrame name, `csv_data`, Amazon
    Q Developer suggests using the `read_csv_file()` function, which is defined in
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: Full function generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the basic building blocks of programming is functions. Typically, a function
    is a reusable multi-line block of code, defined anywhere in the program, to perform
    a specific task. Functions do not run unless called. A function can accept parameters
    or arguments that can be passed when being called in your script. Optionally,
    a function can return data to the calling statement. Code assistants can help
    users write an entire function body. Users just need to provide the information
    about the functionality they need from a function, and optionally, the programming
    language, using any of the previous auto-code generation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an example of how users can auto-generate a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple demonstration of how Amazon Q Developer helps users
    with the generation of a full function:'
  prefs: []
  type: TYPE_NORMAL
- en: The user needs to write a simple Python function named `read_csv()` that takes
    `file_path` as a parameter and returns a sample of 50 records
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `read_csv()` function to read a CSV file from the `/``user/data/input/sample.csv`
    path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the chain-of-thought prompt technique to generate the preceding
    code. Here is the first prompt followed by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.12 – Function generation in the PyCharm IDE using Amazon Q Developer
    – generating the function](img/B21378_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Function generation in the PyCharm IDE using Amazon Q Developer
    – generating the function
  prefs: []
  type: TYPE_NORMAL
- en: Observe, as instructed in the single-line prompt, that Amazon Q Developer has
    created a Python function named `read_csv()` that takes `file_path` as a parameter
    and returns a sample of 50 records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at how you can get the function statement logic auto-generated,
    followed by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.13 – Full function generation in PyCharm IDE using Amazon Q Developer
    – calling the function](img/B21378_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Full function generation in PyCharm IDE using Amazon Q Developer
    – calling the function
  prefs: []
  type: TYPE_NORMAL
- en: Observe, as instructed in Amazon Q Developer, that the call logic is generated
    for the `read_csv()` function to read data from the `/``user/data/input/sample.csv`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Block completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the logical flow of a program, users need to run certain code blocks
    based on conditions and/or need to run certain lines in loops. The most common
    code blocks to achieve these functionalities are `if` conditions, `for` loops,
    `while` conditions, and `try` blocks. Code assistants are trained to complete
    and suggest possible code to write these conditional and loop statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how Amazon Q Developer can help users suggest possible `if`
    conditions in the previously created function in the *Full function generation*
    example (reference *Figure 3**.13*). As Amazon Q Developer understands the context
    of the code, it’s able to understand the functionality associated with the `read_csv()`
    function. So, start typing `if` inside the `read_csv()` function to show our intent
    to write a conditional block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Block completion in the IDE using Amazon Q Developer](img/B21378_03_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Block completion in the IDE using Amazon Q Developer
  prefs: []
  type: TYPE_NORMAL
- en: Observe that, once the user starts typing `if`, Amazon Q Developer understands
    that `file_path` is a mandatory parameter for the `read_csv()` function and expects
    to have a `.csv` file; based on this understanding, it suggests adding an error
    handling condition to check whether the passed parameter has a `.``csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Line-by-line recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, user requirements can be complex and users may not be able to define
    all of them using a combination of multiple prompts. In a few cases, code assistants
    may not be able to generate the script as expected by the user in a single code
    generation. In addition, if the user decides to update the existing code, then
    Amazon Q Developer provides line-by-line recommendations. Amazon Q Developer tries
    to understand the context of the script and predict relevant next lines that might
    be logically useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the previous script from the *Block completion* section (reference
    *Figure 3**.14*) to check whether Amazon Q Developer can recommend the next line
    of code. To illustrate the functionality, let’s delete the last line, `print(data)`.
    Then, go to the last line of the script and press *Enter*; now, Amazon Q Developer
    will try to predict the next logical functionality for the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Line-by-line recommendations in the IDE using Amazon Q Developer](img/B21378_03_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Line-by-line recommendations in the IDE using Amazon Q Developer
  prefs: []
  type: TYPE_NORMAL
- en: Observe that, in this script, Amazon Q Developer is suggesting the print DataFrame
    statement, `print(data)`, which makes logical sense as we read the data from the
    `sample.csv` file in a DataFrame named `data`.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-reference existing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the common best coding practices is to use existing functions from different
    files in the same repository of code. Many developers like to create reusable
    functions and save them in a common file that can be referenced in other scripts.
    Code assistants understand existing scripts and functions present across the repository.
    This allows them to help users recommend new code referencing functions from existing
    files. Users can write simple single-line prompts to suggest Code assistants to
    generate the code referencing existing functions from a particular program file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Amazon Q Developer has functionalities available that can cross-reference
    the existing code during new code generation. Let’s assume the user already has
    the function saved in the `prompt-Fullfunctiongeneration.py` file (reference *Figure
    3**.14*) and wants to use the existing function, `read_csv`, in a new script.
    Here is the prompt followed by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.16 – Cross-referencing the existing code in the IDE using Amazon
    Q Developer](img/B21378_03_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Cross-referencing the existing code in the IDE using Amazon Q
    Developer
  prefs: []
  type: TYPE_NORMAL
- en: Observe that Amazon Q Developer imported all the functions from `prompt_fullfunctiongeneration`
    and then used the `read_csv()` function and generated code to read the `test.csv`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Generating sample data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the development process, developers commonly need sample data that may
    or may not be readily available. Code assistants can help users generate sample
    data in different ways. We will explore a couple of methods by which Amazon Q
    Developer can help users generate the sample data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that a user already has some sample data and wants to create additional
    records to bump up the volume of data. Just like many other code assistants, Amazon
    Q Developer understands the structure and format of the existing sample data to
    generate the next sample record. In the following sample example, the user has
    one record in JSON format with `sr_nbr`, `name`, `age`, and `city` as attributes.
    Once the user hits *Enter* at the end of the first record, Amazon Q Developer
    will start generating sample records. The following screenshot highlights this
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Generating sample data in PyCharm IDE using Amazon Q Developer](img/B21378_03_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Generating sample data in PyCharm IDE using Amazon Q Developer
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that Amazon Q Developer is suggesting the next sample record based
    on the structure from an existing record, `{"sr_nbr": 2, "name": "Jane", "age":
    25, "``city": "Chicago"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider another example and assume that the user does not have a sample
    dataset but is aware of the attributes needed in the sample data. The user needs
    to create a fixed number of sample records. In this case, the user can use prompts
    to generate the sample data. In the following sample example, the user has entered
    a prompt to generate 50 records in JSON format with `sr_nbr`, `name`, `age`, and
    `city` as the desired attributes. With this prompt, Amazon Q Developer suggested
    a random data generation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the prompt followed by the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.18 – Generating sample data in the PyCharm IDE using Amazon Q Developer
    – function logic](img/B21378_03_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Generating sample data in the PyCharm IDE using Amazon Q Developer
    – function logic
  prefs: []
  type: TYPE_NORMAL
- en: Observe that based on the requirement specified in the prompt, Amazon Q Developer
    generated the `generate_user_data()` function with a range of `50` to generate
    sample data with the `sr_nbr`, `name`, `age`, and `city` attributes in a JSON
    file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, if you press *Enter* at the end of the function, you will observe
    that Amazon Q Developer will use a line-by-line recommendation to suggest end-to-end
    code and also save data in a `user_data.json` file. The following screenshot highlights
    this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Generating sample data in the IDE using Amazon Q Developer
    – script](img/B21378_03_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Generating sample data in the IDE using Amazon Q Developer – script
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing the scripts is an imperative part of coding. Testing code needs to be
    done at different phases, such as unit testing during or toward the end of coding,
    integration testing across multiple scripts, and so on. Let’s explore the options
    available with code assistants to support unit test creation. As discussed earlier,
    code assistants can understand the context of scripts. This helps developers reference
    existing program files during unit test creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume a user wants to create unit tests for the previously generated
    code to generate sample data (reference *Figure 3**.18*). The user can use a simple
    single-line prompt to create the unit tests. Amazon Q Developer can analyze the
    code present in the function file and generate the basic unit test cases. The
    following prompt and output showcases this capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.20 – Writing unit tests in the PyCharm IDE using Amazon Q Developer](img/B21378_03_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Writing unit tests in the PyCharm IDE using Amazon Q Developer
  prefs: []
  type: TYPE_NORMAL
- en: Observe that Amazon Q Developer used the input prompt to reference the `generate_user_data()`
    function from the `sample_data_generation.py` file and, based on the functionality,
    generated a basic unit test case. In addition, it also created a full end-to-end
    script that can be used to run the unit test case.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining and documenting code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the life cycle of the project, many developers work on the same script
    to add code or update existing code. A lack of documentation can make it really
    difficult for everyone to understand the end-to-end logic in the script. To help
    developers understand existing code, many of the code assistants have different
    mechanisms to generate explanations of the code in natural language, and plain
    text format. Users can use the outcome of these options to create documentation
    or embed details in the comments section of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Q Developer can help users generate the documentation with respect to
    the existing script. Once the script is open in an IDE, just type the `Explain`
    command in Q’s chat session. Amazon Q Developer will analyze the whole script
    and will return the natural language text, explaining the functionality of the
    script. For example, let’s use the previously created script, `prompt-Fullfunctiongeneration.py`
    (reference *Figure 3**.14*), and ask Amazon Q Developer to explain the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Documenting code in the PyCharm IDE using the Amazon Q Developer
    interface](img/B21378_03_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Documenting code in the PyCharm IDE using the Amazon Q Developer
    interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that the user does not need to specify the script name, as Amazon Q
    Developer can automatically use the script open in the editor when you type the
    `Explain` command. The following screenshot highlights the code explanation provided
    by Amazon Q Developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Documenting code in the IDE using Amazon Q Developer – documentation](img/B21378_03_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – Documenting code in the IDE using Amazon Q Developer – documentation
  prefs: []
  type: TYPE_NORMAL
- en: Observe that Amazon Q Developer generated documentation in natural language.
    It was able to provide the exact functionality of the `read_csv()` function; then,
    it explained that the script used the function to read the `/user/data/input/sample.csv`
    file. In this way, any code can easily be documented without having to manually
    understand the code and type the whole explanation, thus saving time and improving
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Updating existing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous examples, developers often inherit previously developed
    code. Users need to update the code based on newly available libraries and known
    issues and to improve coding standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, updating existing code falls into one of these three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring**: Users need to update existing code to simplify it, making
    it easy to understand, and/or add additional exceptions to handle errors and so
    on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixing**: Users need to update existing code to fix bugs, which may be known
    or unknown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizing**: Users need to update existing code to improve execution efficiency
    and performance tune'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help developers complete the tasks just mentioned, many code assistants offer
    options. Users can use the outcomes of these options to update existing code and
    improve coding standards.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how Amazon Q Developer can help users update existing code. Similar
    to the `Explain` command discussed in the previous section, Amazon Q Developer
    has the `Refactor`, `Fix`, and `Optimize` commands. Once the script is open in
    an IDE, simply type any of these commands to get recommendations from Amazon Q
    Developer. Based on the code quality, Amazon Q Developer can provide multiple
    different recommendations and a direct option to insert the fragment into the
    existing script.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following screenshot, let’s use the previously created script,
    `prompt-Fullfunctiongeneration.py` (reference *Figure 3**.15*), and ask Amazon
    Q Developer to refactor the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Updating existing code in the PyCharm IDE using the Amazon
    Q Developer interface: Refactor](img/B21378_03_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23 – Updating existing code in the PyCharm IDE using the Amazon Q
    Developer interface: Refactor'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that Amazon Q Developer can automatically use the script open in the
    editor when you type the `Refactor` instruction and suggest multiple recommendations
    to consider while refactoring. Let’s look at a couple of them in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, Amazon Q Developer suggests adding hints to the
    `file_path` function parameter and returning parameters as a list to improve overall
    readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Updating existing code in the PyCharm IDE using the Amazon
    Q Developer interface: Refactor 2](img/B21378_03_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24 – Updating existing code in the PyCharm IDE using the Amazon Q
    Developer interface: Refactor 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following screenshot, Amazon Q Developer suggests including
    additional exception handling for the `file_path` parameter to check whether the
    file is of the CSV type and whether the file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Updating existing code in the PyCharm IDE using the Amazon
    Q Developer interface: Refactor 3](img/B21378_03_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25 – Updating existing code in the PyCharm IDE using the Amazon Q
    Developer interface: Refactor 3'
  prefs: []
  type: TYPE_NORMAL
- en: We will explore other options and dive deep into the examples in [*Chapter 12*](B21378_12.xhtml#_idTextAnchor181).
  prefs: []
  type: TYPE_NORMAL
- en: Feature development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code assistants can help developers develop features simply by describing them
    in natural language and specifying key phrases. As a user, you only need to provide
    keywords/phrases related to the functionality of the feature, and code assistants
    can generate the end-to-end code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how Amazon Q Developer can help users develop features. Amazon
    Q Developer leverages the context of the current project to generate a comprehensive
    implementation plan and specifies the necessary code changes. To initiate feature
    development, the user just needs to open a file within their project and type
    `/dev` in the `/dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s ask Amazon Q Developer to implement a binary search feature.
    This is highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Feature development in the PyCharm IDE using the Amazon Q Developer
    interface](img/B21378_03_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – Feature development in the PyCharm IDE using the Amazon Q Developer
    interface
  prefs: []
  type: TYPE_NORMAL
- en: Observe that, based on the command, Amazon Q Developer generated code for the
    binary search feature, provided details of the code flow/algorithm, and referenced
    sources to generate the features.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive deep into detailed examples in [*Chapter 12*](B21378_12.xhtml#_idTextAnchor181).
  prefs: []
  type: TYPE_NORMAL
- en: Code transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When upgrading versions, depending on the programming language used, users may
    have to make various adjustments in their code to ensure compatibility with the
    latest version. Code assistants offer assistance to developers in upgrading their
    code, helping them transition from older versions to the most recent ones.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Amazon Q Developer has the capability to upgrade the code language
    version. Users can just open the existing old version code and use the `/transform`
    command to upgrade the code version directly within their files.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive deep into further details with examples in [*Chapter 12*](B21378_12.xhtml#_idTextAnchor181).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the integration of code assistants with LLMs to
    assist users with auto-code generation. Then, we explored three commonly used
    auto-code generation prompting techniques: single-line prompts, multi-line prompts,
    and chain-of-thought prompts. We introduced each of these prompting techniques
    for auto-code generation, along with potential use cases, limitations, and required
    coding experience. Sample code examples were used in JetBrains’ PyCharm IDE with
    Amazon Q Developer enabled. Additionally, we introduced the *chat with code assistant*
    technique in the auto-code generation process, where users interact with the code
    assistant in a simple question-and-answer style session. Amazon Q Developer was
    utilized to obtain general recommendations for coding/debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed some of the common building methods of code generation, such
    as single-line code completion, full function generation, block completion, line-by-line
    recommendations, generating sample data, writing unit tests, explaining and documenting
    code, updating existing code, feature development, and code transformation. Furthermore,
    we explored these functionalities with Amazon Q Developer in JetBrains’ PyCharm
    IDE to support the most common code-building methods.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll start *Part 2* of the book. In this part, *Chapters 4* to *9* will
    walk you through how Amazon Q Developer can boost developer productivity by auto-generating
    code for many supported programming languages. Based on your expertise or preference,
    feel free to navigate directly to the chapters that interest you the most.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve deeper into how to utilize these techniques
    and building methods within the IDE environment for the Python and Java languages.
    Additionally, we will create a sample Python application with the assistance of
    Amazon Q Developer.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Amazon Q Developer single-line code completion: [https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/single-line-completion.html](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/single-line-completion.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon Q Developer full function generation: [https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/full-function-generation.html](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/full-function-generation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon Q Developer block completion: [https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/code-block.html](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/code-block.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon Q Developer line-by-line recommendations: [https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/line-by-line-1.html](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/line-by-line-1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon Q Developer chat with Amazon Q Developer in IDEs: [https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/q-in-IDE-chat.html](https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/q-in-IDE-chat.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explain and update code with Amazon Q Developer: [https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/explain-update-code.html](https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/explain-update-code.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Feature development with Amazon Q Developer: [https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/feature-dev.html](https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/feature-dev.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code transformation with Amazon Q Developer: [https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/code-transformation.html](https://docs.aws.amazon.com/amazonq/latest/aws-builder-use-ug/code-transformation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prompt engineering guide – generating code: [https://www.promptingguide.ai/applications/coding](https://www.promptingguide.ai/applications/coding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
