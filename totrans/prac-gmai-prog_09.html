<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">AI Planning and Collision Avoidance</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover topics that will help bring a higher complexity level to our AI characters. The idea of this chapter is to give the power of planning and deciding to the characters. We have already explored some of the technical knowledge required to achieve this in the previous chapters, and now we will explore in detail the process of creating an AI character that can plan ahead their decisions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Search</h1>
                </header>
            
            <article>
                
<p>We will start by talking about searching in video games. Search can be the first decision that our characters make because in most of the times, we want the characters to search for something, either searching for the player or for something else that will lead the character to their victory.</p>
<p>Having our characters be able to successfully find something is very useful and can be highly important as well. This is a feature that can be found in a large number of video games, and for that reason, it is likely that we will need to use it as well.</p>
<p>As we saw in previous examples, most of the times we have a player who walks around the map and when they come across an enemy, that enemy changes from an idle to offensive position. Now, we want the enemy to be proactive and constantly searching for the player instead of waiting for him. In our heads, we can start thinking about the process that is required for the enemy to start searching for the player. That process that we have in our heads needs to be planned, and that plan needs to be in the AI character's head. Basically, we want the AI thoughts to be the same as our thoughts because that will look realistic, and that is exactly what we want.</p>
<p>Other times, we might want the search to be secondary, where the main priority of the character is something else. This is very common for real-time strategy games, where the AI characters start exploring the map, and at a certain point, they find an enemy base. The searching wasn't their priority, but even then it is a part of the game-exploring the map and getting the opponent's location. After discovering the player's location, the AI character can decide whether exploring more of it becomes a priority or not and what would be their next step.</p>
<p>Also, we can create realistic animals for hunting games, for example, where the main objective of the animal is to eat and drink, so they have to constantly search for food or water, and if they are not hungry or thirsty anymore, they can search for a warm place to stay. However, meanwhile if the animal finds a predator, their priority will change immediately, and the animal will start searching for a safe place to stay.</p>
<p>There are many decisions that can depend on a search system, and it is a feature that mimics what real life humans or animals do. We will cover the most common types of searches on video games, and the objective is to turn the AI character able to search and successfully find anything.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Offensive search</h1>
                </header>
            
            <article>
                
<p>The first type of search that we will create is an offensive search. By offensive search, we mean that this is set to be the primary objective of the AI character. The idea is that the character of the game for some reason needs to find the player, similar to the hide and seek game, where one of the players has to hide and the other one needs to find them.</p>
<p>We have a map where the character can walk freely, only taking in consideration the collision avoidance that they have to make (trees, hills, and rocks):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/306146e9-f5f3-4320-ac3d-48cb4f9c7443.png"/></div>
<p>So, the first step is to create a system where the character can walk around the map. For this example, we have chosen to create a waypoint system where the character can move from point to point and explore the entire map.</p>
<p>After importing the map and characters that we'll use on the game, we need to configure the waypoints that will be used by the character to know where they need to go. We can do this manually adding the coordinates into our code, but to simplify the process, we'll create objects on the scene that will serve as waypoints and delete the 3D mesh, because it won't be necessary.</p>
<p>Now, we group all the waypoints that we have created and name the group as <strong>waypoints</strong>. Once we have the waypoints in place and grouped together, we can start creating the code that will tell our character how many waypoints they need to follow. This code is very useful because that way we can create different maps, using as many waypoints as we need without necessarily updating the character code:</p>
<pre>public static Transform[] points;<br/><br/>     void Awake () <br/>     {<br/>         points = new Transform[transform.childCount];<br/>         for (int i = 0; i &lt; points.Length; i++)<br/>         {<br/>             points[i] = transform.GetChild(i); <br/>         }<br/>     } </pre>
<p>This code will be assigned to the group that we have created and will count the number of waypoints that has inside of it and ordering them.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/469b1cb9-124a-4772-bb52-fed8e5142648.png"/></div>
<p>The blue spheres that we can see in preceding image represent the 3D meshes that we have used as waypoints. For this example, the character will follow eight points until they finish the path. Now, let's move on to the AI character code and see how we can make the AI character move from point to point using the points that we have created.</p>
<p>We will start by creating the basic functions of the character-the health and speed-then we will create a new variable that will give them the next position and another variable that will be used to know which waypoint they need to follow:</p>
<pre> public float speed;<br/> public int health;<br/><br/> private Transform target;<br/> private int wavepointIndex = 0; </pre>
<p>Now, we have the basic variables that are needed to make an enemy character move from point to point until they find the player. Let's see how to use these in order to make it playable now:</p>
<pre> private float speed;<br/> public int health;<br/><br/> private Transform target;<br/> private int wavepointIndex = 0;<br/><br/><br/> void Start ()<br/> {<br/>      target = waypoints.points[0];  speed = 10f;<br/> }<br/><br/> void Update ()<br/> {<br/>      Vector3 dir = target.position - transform.position;<br/>      transform.Translate(dir.normalized * speed * Time.deltaTime, Space.World);<br/><br/>      if(Vector3.Distance(transform.position, target.position) &lt;= 0.4f)<br/>      {<br/>          GetNextWaypoint();<br/>      }<br/> }<br/><br/> void GetNextWaypoint()<br/> {<br/>      if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>      {<br/>          Destroy(gameObject);<br/>          return;<br/>      }<br/><br/>      wavepointIndex++;<br/>      target = waypoints.points[wavepointIndex];<br/> } </pre>
<p>In the <kbd>Start</kbd> function, we assigned the first <kbd>waypoint</kbd> that the characters need to follow that is, the <kbd>waypoint</kbd> number zero, the first on the transform list that we have created previously on the <kbd>waypoint</kbd> code. Also, we have determined the velocity of the character, and for this example, we have chosen <kbd>10f</kbd>.</p>
<p>Then, in the <kbd>Update</kbd> function, the character will calculate the distance between the next position and the current position, using the <kbd>Vector3 dir</kbd>. The character will constantly be moving on, so we have created a line of code that serves as movement for the character <kbd>transform.Translate</kbd> in this case. Knowing the distance and the speed information, the character will know how far it is from the next position, and once they reach the desirable distance from that point, they can move on to the next point. To make this happen, we will create an <kbd>if</kbd> statement that will tell the character when they reach <kbd>0.4f</kbd> (for this example) near from the point that he is moving into, that means that he already have arrived to that destination and he can start moving on to the next point <kbd>GetNextWaypoint()</kbd>.</p>
<p>In the <kbd>GetNextWaypoint()</kbd> function, the character will start to confirm whether they already have arrived at the final destination; if they have, then the object can be destroyed, if not, they can follow the next waypoint. The <kbd>wavepointIndex++</kbd> will add one number to the index every time the character arrives at the waypoint position, moving from <em><kbd>0&gt;1&gt;2&gt;3&gt;4&gt;5</kbd></em> and so on.</p>
<p>Now, we assign the code to our character and place the character at the start position and test the game to check whether it is working properly:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/cf2103af-d861-4fd2-9edd-5474511e6c98.png"/></div>
<p>Now, the character moves from one point to another, and this is the first and necessary step when developing a search system-the character needs to move around the map. Now, we just need to make it turn to the direction that they are facing and then we can start worrying about the search feature:</p>
<pre> public float speed;<br/> public int health;<br/> public float speedTurn;<br/><br/> private Transform target;<br/> private int wavepointIndex = 0;<br/><br/><br/> void Start ()<br/> {<br/>      target = waypoints.points[0];<br/>      speed = 10f;<br/>      speedTurn = 0.2f;<br/> }<br/><br/> void Update ()<br/> {<br/>      Vector3 dir = target.position - transform.position;<br/>      transform.Translate(dir.normalized * speed * Time.deltaTime, Space.World);<br/><br/>      if(Vector3.Distance(transform.position, target.position) &lt;= 0.4f)<br/>      {<br/>          GetNextWaypoint();<br/>      }<br/><br/>      Vector3 newDir = Vector3.RotateTowards(transform.forward, dir, speedTurn,<br/>      0.0F);<br/><br/>      transform.rotation = Quaternion.LookRotation(newDir);<br/> }<br/><br/> void GetNextWaypoint()<br/> {<br/>      if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>      {<br/>          Destroy(gameObject);<br/>          return;<br/>      }<br/><br/>      wavepointIndex++;<br/>      target = waypoints.points[wavepointIndex];<br/> } </pre>
<p>Now, we have the character facing the direction that they are moving on, and we are ready to add the searching system.</p>
<p>So, we have a character that is walking from point to point on the map, and at this moment even if they find the player, they won't stop walking and nothing will happen. So, that's what we are going to do now.</p>
<div class="CDPAlignCenter CDPAlign"><img height="274" width="477" class=" image-border" src="assets/d2245505-9131-4cbd-95ed-876efcb03f86.png"/></div>
<p>The approach that we have chosen to achieve the desired results is to add a trigger zone in form of a circle around the character, as we can see in the preceding screenshot. The character will be walking around the map, and when that trigger zone detects the player, the character has found the primary objective. Let's add that into our character code:</p>
<pre>     public float speed;<br/>     public int health;<br/>     public float speedTurn;<br/>     private Transform target;<br/>     private int wavepointIndex = 0;<br/>     private bool Found;<br/><br/>     void Start ()<br/>     {<br/>         target = waypoints.points[0];<br/>         speed = 10f;<br/>         speedTurn = 0.2f;<br/>     }<br/><br/>     void Update ()<br/>     {<br/>         Vector3 dir = target.position - transform.position;<br/>         transform.Translate(dir.normalized * speed * Time.deltaTime,<br/>         Space.World);<br/><br/>         if(Vector3.Distance(transform.position, target.position) &lt;= 0.4f)<br/>         {<br/>             GetNextWaypoint();<br/>         }<br/><br/>         Vector3 newDir = Vector3.RotateTowards(transform.forward, dir,<br/>         speedTurn, 0.0F);<br/><br/>         transform.rotation = Quaternion.LookRotation(newDir);<br/>     }<br/><br/>     void GetNextWaypoint()<br/>     {<br/>         if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>         {<br/>             Destroy(gameObject);<br/>             return;<br/>         }<br/><br/>         wavepointIndex++;<br/>         target = waypoints.points[wavepointIndex];<br/>     }<br/><br/>     void OnTriggerEnter(Collider other)<br/>     {<br/>         if(other.gameObject.tag =="Player")<br/>         {<br/>             Found = true;<br/>         }<br/>     } </pre>
<p>So, now we added a <kbd>void OnTriggerEnter</kbd> that verifies that the trigger zone gets in touch with something else. To check whether the object that has entered on the trigger zone is the player, we have an if statement that checks whether the object of the game has the tag <kbd>Player</kbd>. If that is true, the Boolean variable <kbd>Found</kbd> is changed to true. This Boolean variable will be very useful in a moment.</p>
<p>Let's test the game and check whether the character passes through the player and whether at that moment the variable <kbd>Found</kbd> has changed from false to true:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="229" width="399" class=" image-border" src="assets/6a312676-a9c8-4683-a170-a4706dd9731d.png"/></div>
<p>The search system that we just implemented works great; the character will walk around the map searching for the player and they can find the player without any issue. The next step is to tell the character to stop searching when they already have found the player.</p>
<pre>     public float speed;<br/>     public int health;<br/>     public float speedTurn;<br/>     private Transform target;<br/>     private int wavepointIndex = 0;<br/>     public bool Found;<br/><br/>     void Start ()<br/>     {<br/>         target = waypoints.points[0];<br/>         speed = 40f;<br/>         speedTurn = 0.2f;<br/>     }<br/><br/>     void Update ()<br/>     {<br/>         if (Found == false)<br/>         {<br/>             Vector3 dir = target.position - transform.position;<br/>             transform.Translate(dir.normalized * speed *<br/>             Time.deltaTime,<br/>             Space.World);<br/><br/>             if (Vector3.Distance(transform.position, target.position)<br/>             &lt;= 0.4f)<br/>             {<br/>                 GetNextWaypoint();<br/>             }<br/><br/>             Vector3 newDir = Vector3.RotateTowards(transform.forward,<br/>             dir,<br/>             speedTurn, 0.0F);<br/><br/>             transform.rotation = Quaternion.LookRotation(newDir);<br/>         }<br/>     }<br/><br/>     void GetNextWaypoint()<br/>     {<br/>         if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>         {<br/>             Destroy(gameObject);<br/>             return;<br/>         }<br/><br/>         wavepointIndex++;<br/>         target = waypoints.points[wavepointIndex];<br/>     }<br/><br/>     void OnTriggerEnter(Collider other)<br/>     {<br/>         if(other.gameObject.tag == "Player")<br/>         {<br/>             Found = true;<br/>         }<br/>     } </pre>
<p>With these last modifications, we have an AI character that goes around the map until they find the player and when they finally find them, they stop moving around and ready to plan what to do next.</p>
<p>What we have done here is use the <kbd>Found</kbd> Boolean to determine whether the player should be searching for the player or not.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/7eaa77f5-1b7b-4b16-94bc-e4bf6f3c9a1b.png"/></div>
<p>The preceding image represents the state of our character at the moment, and we are ready to implement more features on it to make them plan and take the best decisions.</p>
<p>This searching system can be applied to a lot of different game genres, and we can set it fairly quickly, which makes it a perfect way to start planning the AI character. Now, let's move on and work on the anticipation feature of the player character.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Predicting opponent actions</h1>
                </header>
            
            <article>
                
<p>Now, let's make the character anticipate what is going to happen even before getting in confrontation against the player. This is the part where the character AI starts to plan the best options available to accomplish the objective.</p>
<p>Let's take a look at how we can implement an anticipation system into the character AI. We will continue to use the example mentioned in the preceding section, where we have a soldier searching for another one in the map. At the moment, we have a character that moves around the map and stops when they find the player.</p>
<p>If our character AI has found the player, most likely situation is for the player to find the character AI as well so that both characters are aware of each other. What are the chances of the player attacking the character AI? What are the chances of the player not having enough bullets to fire against the character? All of that is very subjective and very unpredictable. However, we want our character to have that in mind and anticipate the possible moves of the player.</p>
<p>So, let's start with a simple question: is the player facing the character?. Having the character to check this will help them to make a judgment about the possible outcomes. To achieve this result, we will be adding a trigger <kbd>Collider</kbd> in the back and another in front of each character of the game, including the player as we can see in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="286" width="498" class=" image-border" src="assets/668401cd-28f5-4f28-84e6-dbcac9508d54.png"/></div>
<p>The idea of having two extra Colliders on each character is to help the other characters identify whether they are looking at the back or front side of the character. So, let's add this to every character of the game and name the trigger <kbd>Collider</kbd> with the names <kbd>back</kbd> and <kbd>front</kbd>.</p>
<p>Now, let's make the character distinguish between the back and the front trigger. It can be done in two different ways-the first way is by adding a stretched trigger collider in front of the character representing the observation range:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a69075c2-ce9e-45af-ab50-d2e7095acb3d.png"/></div>
<p>Alternatively, we can create a <span class="packt_screen">RAYCAST</span> starting from the character's position and ending at the distance that we think is likely to be the vision range of our character as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/0b586143-db50-40e4-895f-0afaa96a64d4.jpg"/></div>
<p>Both methods have their advantages and disadvantages, and once again, we don't necessarily need to constantly use the most complicated methods to achieve great results. So, the advice here is to use the method that we are more comfortable with, and a good choice for this example would be the trigger <kbd>Collider</kbd> to represent the vision range of the character.</p>
<p>Let's add the trigger <kbd>Collider</kbd> in front of the character, and then we can start working on the code to make it detect the front or back side of the characters. The first thing we need to change in our code is to make the character face the player's direction when they see him. The character wouldn't be able to anticipate anything if they are not looking at the player, so let's fix that first:</p>
<pre>void Update ()<br/>     {<br/>         if (Found == false)<br/>         {<br/>             Vector3 dir = target.position - transform.position;<br/>             transform.Translate(dir.normalized * speed *<br/>             Time.deltaTime,<br/>             Space.World);<br/><br/>             if (Vector3.Distance(transform.position, target.position)<br/>             &lt;= 0.4f)<br/>             {<br/>                 GetNextWaypoint();<br/>             }<br/><br/>             Vector3 newDir = Vector3.RotateTowards(transform.forward,<br/>             dir,<br/>             speedTurn, 0.0F);<br/><br/>             transform.rotation = Quaternion.LookRotation(newDir);<br/>         }<br/><br/>         if (Found == true)<br/>         {<br/>             transform.LookAt(target);<br/>         }<br/>     }<br/><br/>     void GetNextWaypoint()<br/>     {<br/>         if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>         {<br/>             Destroy(gameObject);<br/>             return;<br/>         }<br/><br/>         wavepointIndex++;<br/>         target = waypoints.points[wavepointIndex];<br/>     }<br/><br/>     void OnTriggerEnter(Collider other)<br/>     {<br/>         if(other.gameObject.tag == "Player")<br/>         {<br/>             Found = true; 
             target = other.gameObject.transform;  
<br/>         }<br/>     } </pre>
<p>Now, we have our AI character constantly facing the player when they see them. To make this work, we added our first line of code inside the <kbd>if (Found == true)</kbd>. Here, we used the <kbd>transform.LookAt</kbd> that makes the AI face the player character. When the player is spotted by our AI character, it automatically becomes the target:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/29050f88-0b13-4fd7-882b-3b5b25e493a6.png"/></div>
<p>Now that, we have our AI character facing the player, we can check whether they are looking at the back or front side of the player.</p>
<p>It might look illogical for us to think that the character doesn't know the difference, but when developing an AI character, everything needs to be written on the code, especially details such as this one that can have a huge impact on anticipating, planning, and finally making a decision.</p>
<p>So, now we have to use the trigger <kbd>Collider</kbd> that we added previously to check whether our AI character is facing the front or back side of the player that is in front of them. Let's start by adding the following two new variables:</p>
<pre> public bool facingFront;<br/> public bool facingBack; </pre>
<p>The variables that we added are the Boolean <kbd>facingFront</kbd> and <kbd>facingBack</kbd>. The trigger will set one of these values to true, and that way, the character AI will know which side they are looking at. So, let's configure the trigger:</p>
<pre>void Update ()<br/>     {<br/>         if (Found == false)<br/>         {<br/>             Vector3 dir = target.position - transform.position;<br/>             transform.Translate(dir.normalized * speed * <br/>             Time.deltaTime,<br/>             Space.World);<br/><br/>             if (Vector3.Distance(transform.position, target.position)<br/>             &lt;= 0.4f)<br/>             {<br/>                 GetNextWaypoint();<br/>             }<br/><br/>             Vector3 newDir = Vector3.RotateTowards(transform.forward,<br/>             dir,<br/>             speedTurn, 0.0F);<br/><br/>             transform.rotation = Quaternion.LookRotation(newDir);<br/>         }<br/><br/>         if (Found == true)<br/>         {<br/>             transform.LookAt(target);<br/>         }<br/>     }<br/><br/>     void GetNextWaypoint()<br/>     {<br/>         if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>         {<br/>             Destroy(gameObject);<br/>             return;<br/>         }<br/><br/>         wavepointIndex++;<br/>         target = waypoints.points[wavepointIndex];<br/>     }<br/><br/>     void OnTriggerEnter(Collider other)<br/>     {<br/>         if(other.gameObject.tag == "Player")<br/>         {<br/>             Found = true;<br/>             target = other.gameObject.transform;<br/>         }<br/><br/>         if(other.gameObject.name == "frontSide")<br/>         {<br/>             facingFront = true;<br/>             facingBack = false;<br/>         }<br/><br/>         if(other.gameObject.name == "backSide")<br/>         {<br/>             facingFront = false;<br/>             facingBack = true;<br/>         }<br/>     } </pre>
<p>So, what we did was having the trigger checking whether was colliding against the back or front side of the other character. To achieve this result, we have the trigger questioning whether the collision that it has detected was the <kbd>frontSide</kbd> object or <kbd>backSide</kbd> object. Only one of them can be true at a time.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="265" width="461" class=" image-border" src="assets/a2795f93-935e-45ec-83ea-d71e7998a5f0.png"/></div>
<p>Now that, we have our character distinguishing the player's back side and front side, we want him to be able to analyze the dangers of both situations. So, the first thing we will do is to have a very distinct difference of the situation when the character finds the player facing their back and when they are facing their front. When facing the front side, the player is ready to shoot at our AI character, so it is an even more dangerous situation. We will be creating a danger meter and can start importing this situation into the equation:</p>
<pre> public float speed;<br/> public int health;<br/> public float speedTurn;<br/> private Transform target;<br/> private int wavepointIndex = 0;<br/> public bool Found;<br/><br/> public bool facingFront;<br/> public bool facingBack;<br/><br/> public int dangerMeter;</pre>
<p>In the variables section, we add a new integer called <kbd>dangerMeter</kbd>. Now, we will add the values that will help determine whether the situation that our AI character is facing has a higher or lower risk to be attacked:</p>
<pre>void OnTriggerEnter(Collider other)<br/>     {<br/>         if(other.gameObject.tag == "Player")<br/>         {<br/>             Found = true;<br/>             target = other.gameObject.transform;<br/>         }<br/><br/>         if(other.gameObject.name == "frontSide")<br/>         {<br/>             facingFront = true;<br/>             facingBack = false;<br/>             dangerMeter += 50;<br/>         }<br/><br/>         if(other.gameObject.name == "backSide")<br/>         {<br/>             facingFront = false;<br/>             facingBack = true;<br/>             dangerMeter += 5;<br/>         }<br/>     } </pre>
<p>So, depending on the situation, we can add a small value that will represent a small risk or a big value that will represent a big risk. If the danger value is high, the AI character needs to anticipate a life-threatening situation, and for that reason, dramatic decisions probably will be made. On the other hand, if our character is facing a lower-risk situation, they can start planning something more precise and effective.</p>
<p>Plenty of factors can be added to the <kbd>dangerMeter</kbd>, such as the location where our character is positioned in relation to the player. To make this, we need to divide the map into different zones and assign a level of risk that each zones has. For example, if the character is in the middle of the forest, it can be considered a moderated risk zone, whereas if they are in the open, it can be considered a higher risk zone. How many bullets our character has, the remaining lifelines, and endless more can be added into our <kbd>dangerMeter</kbd> equation. Having this implemented into our character will help him anticipate the situations that can happen to him.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collision avoidance</h1>
                </header>
            
            <article>
                
<p>Predicting collisions is a very useful thing to have been implemented into our AI characters and can be used on crowd systems too in order to make the crowd move more organically when one character is walking on the direction as another character as we saw in the previous chapter. Now, let's take a look at a simple way to implement this feature:</p>
<div class="CDPAlignCenter CDPAlign"><img height="427" width="743" class=" image-border" src="assets/d2efc8d9-77fd-4d1c-8238-e4ede7c38e8b.png"/></div>
<p>To predict a collision, we need at least two objects or characters. In the preceding image, we have two spheres representing two characters and the dashed lines represent their movement. If the blue sphere moves toward the red sphere, at a certain point, they will collide with each other. The main objective here is to predict when that will happen and adjust the trajectory of the sphere so that it can avoid the collision.</p>
<div class="CDPAlignCenter CDPAlign"><img height="222" width="443" class=" image-border" src="assets/d3082dba-73b6-4b14-9d4b-d9fe7f117c41.png"/></div>
<p>In the preceding image, we can see the representation of what we need to do if we want our character to avoid colliding with the obstacle. We need to have the velocity vector that will indicate the direction of the character. This same vector will also be used to produce a new one called <kbd>ahead</kbd>, which is a copy of the velocity vector, but with a longer length. This means that the <kbd>ahead</kbd> vector represents the line of sight of our character, and as soon they see the obstacle, they will adjust their direction to avoid colliding with it. This is how we calculate the <kbd>ahead</kbd> vector:</p>
<pre>ahead = transform.position + Vector3.Normalize(velocity) * MAX_SEE_AHEAD;</pre>
<p>The <kbd>ahead</kbd> is a <kbd>Vector3</kbd> variable, <kbd>velocity</kbd> is a <kbd>Vector3</kbd> variable, and <kbd>MAX_SEE_AHEAD</kbd> is a float variable that will tell how far ahead we can see. If we increase the <kbd>MAX_SEE_AHEAD</kbd> value, the earlier the character will start adjusting his direction, as demonstrated on the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="231" width="461" class=" image-border" src="assets/26f69b1c-f70d-49fc-b4c6-896a4e653ef2.png"/></div>
<p>To check for the collision, one solution that can be used is the line-sphere intersection, where the line is the <kbd>ahead</kbd> vector and the sphere is the obstacle. This method works, but we'll be using a simplification of that, which is easier to understand and has identical results. So, the <kbd>ahead</kbd> vector will be used to produce another vector, and this vector will be half of its length:</p>
<div class="CDPAlignCenter CDPAlign"><img height="226" width="451" class=" image-border" src="assets/90fbb91f-0555-4af3-878f-33ca281cf93a.png"/></div>
<p>In the preceding image, we can see that <kbd>ahead</kbd> and <kbd>ahead2</kbd> goes toward the same direction, the only difference is the length between them:</p>
<pre>ahead = transform.position + Vector3.Normalize(velocity) * MAX_SEE_AHEAD;<br/>ahead2 = transform.position + Vector3.Normalize(velocity) * (MAX_SEE_AHEAD * 0.5);</pre>
<p>We need to check for a collision to know whether one of those two vectors is inside the <strong>OBSTACLE ZONE</strong>. To calculate that, we can compare the distance between the vectors and the obstacle center. If the distance is less or equal to the <strong>OBSTACLE ZONE</strong>, then that means that our vectors are inside of the <strong>OBSTACLE ZONE</strong> and a collision was found.</p>
<div class="CDPAlignCenter CDPAlign"><img height="258" width="515" class=" image-border" src="assets/851321f2-681a-4ca0-b638-c7f0115573c7.png"/></div>
<p><span class="MsoIntenseEmphasis">The <kbd>ahead2</kbd> vector does not appear on the preceding diagram just to simplify it.</span></p>
<p>If either of the two <kbd>ahead</kbd> vectors get inside of the <strong>OBSTACLE ZONE</strong>, it means that the obstacle is blocking the path, and to solve our problem, we will calculate the distance between the two points:</p>
<pre> public Vector3 velocity; 
 public Vector3 ahead;<br/> public float MAX_SEE_AHEAD;<br/> public Transform a;<br/> public Transform b;<br/><br/> void Start (){<br/><br/>     ahead = transform.position + Vector3.Normalize(velocity) * MAX_SEE_AHEAD;<br/>     }<br/><br/> void Update ()<br/> {<br/><br/>     float distA = Vector3.Distance(a.position, transform.position);<br/>     float distB = Vector3.Distance(b.position, transform.position);<br/><br/>     if(distA &gt; distB)<br/>     {<br/>         avoidB();<br/>     }<br/><br/>     if(distB &gt; distA)<br/>     {<br/>         avoidA();<br/>     }<br/>     }<br/><br/>     void avoidB()<br/>     {<br/><br/>     }<br/><br/>     void avoidA()<br/>     {<br/><br/>     } 
} </pre>
<p>In case of having more than one obstacle blocking the path, we'll need to check which one is closer to our character, then we can start avoiding the closer obstacle first and then move on to the second obstacle:</p>
<div class="CDPAlignCenter CDPAlign"><img height="244" width="487" class=" image-border" src="assets/2a02969c-b5b4-4e09-85b0-6b7c9ad2979d.png"/></div>
<p>The closest obstacle, the most threatening, will be selected for calculation. Now, let's take a look at how we can calculate and perform the avoidance:</p>
<pre> public Vector3 velocity;<br/> public Vector3 ahead;<br/> public float MAX_SEE_AHEAD;<br/> public float MAX_AVOID;<br/> public Transform a;<br/> public Transform b;<br/> public Vector3 avoidance;<br/><br/> void Start () {<br/><br/>     ahead = transform.position + Vector3.Normalize(velocity) * MAX_SEE_AHEAD;<br/> }<br/><br/> void Update ()<br/> {<br/><br/>     float distA = Vector3.Distance(a.position, transform.position);<br/>     float distB = Vector3.Distance(b.position, transform.position);<br/><br/>     if(distA &gt; distB)<br/>     {<br/>         avoidB();<br/>     }<br/><br/>     if(distB &gt; distA)<br/>     {<br/>         avoidA();<br/>     }<br/> }<br/><br/> void avoidB()<br/> {<br/>     avoidance = ahead - b.position;<br/>     avoidance = Vector3.Normalize(avoidance) * MAX_AVOID;<br/> }<br/><br/> void avoidA()<br/> {<br/>     avoidance = ahead - a.position;<br/>     avoidance = Vector3.Normalize(avoidance) * MAX_AVOID;<br/> } 
}  </pre>
<p>After <kbd>avoidance</kbd> is calculated, it is normalized and scaled by <kbd>MAX_AVOID</kbd>, which is a number that is used to define the <kbd>avoidance</kbd> length. The higher the <kbd>MAX_AVOID</kbd> value is, the stronger is the avoidance, pushing our character away from the obstacle.</p>
<div class="CDPAlignCenter CDPAlign"><img height="191" width="382" class=" image-border" src="assets/c57139c2-9a74-4731-948c-5d87c45d6909.png"/></div>
<div class="packt_tip">The position of any entity can be set as vectors, so they can be used in calculations with other vectors and forces.</div>
<p>Now, we have the foundation to make our character predict and steer away from the obstacle position, avoiding collision with it. Using this in conjunction with a pathfinding, we can let our characters move freely in the game and enjoy the results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have explored how to make our AI character create and follow a plan to execute a determinate objective in this chapter. The idea is to think ahead what is going to happen and to prepare for that situation. To complete this, we have also explored how to make our AI character predict a collision with an object or another character. This will be fundamental not only to make our character move freely on the map, but also it serves as a new equation to have in mind when planning what to do. In our next chapter, we will be talking about awareness, how to develop one of the most iconic features of stealth games, and make our AI characters self-aware of what is happening around them with realistic field of view.</p>


            </article>

            
        </section>
    </body></html>