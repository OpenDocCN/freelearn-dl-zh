<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-130">
    <a id="_idTextAnchor132">
    </a>
    
     7
    
   </h1>
   <h1 id="_idParaDest-131">
    <a id="_idTextAnchor133">
    </a>
    
     Introducing Behavior Trees
    
   </h1>
   <p>
    
     In the
    
    <a id="_idIndexMarker260">
    </a>
    <a id="_idIndexMarker261">
    </a>
    
     universe of game development,
    
    <strong class="bold">
     
      behavior trees
     
    </strong>
    
     are hierarchical structures that govern the decision-making processes of AI characters, determining their actions and reactions during gameplay.
    
    
     As a game programmer, delving into the intricacies of behavior trees is crucial, as it will empower you with the ability to craft dynamic, intelligent, and engaging virtual entities that enhance the player’s
    
    
     
      game experience.
     
    
   </p>
   <p>
    
     This chapter aims to provide a gentle introduction to behavior trees and Blackboards, as well as their application within the
    
    
     
      Unreal Engine.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics
     
    
   </p>
   <ul>
    <li>
     
      Explaining
     
     
      
       behavior trees
      
     
    </li>
    <li>
     
      Understanding behavior trees in
     
     
      
       Unreal Engine
      
     
    </li>
    <li>
     
      Understanding
     
     
      
       the Blackboard
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-132">
    <a id="_idTextAnchor134">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     There are no technical requirements to follow
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-133">
    <a id="_idTextAnchor135">
    </a>
    
     Explaining behavior trees
    
   </h1>
   <p>
    
     In its broader sense, a behavior tree is a
    
    <a id="_idIndexMarker262">
    </a>
    
     mathematical model used in many fields of computer science, including video games.
    
    
     It outlines the transition between a finite set of tasks in a modular manner.
    
    
     The power of behavior trees lies in their ability to create intricate tasks from simple components, without going into the details of how each component is implemented.
    
    
     While behavior trees share some similarities with hierarchical state machines – where states are organized in a hierarchy, allowing for better reuse of behaviors – the primary distinction lies in the fact that tasks, not states, serve as the fundamental elements of behavior.
    
    
     The main advantage is their intuitive nature, making them less prone to errors; this is why they are highly favored within the game
    
    
     
      development industry.
     
    
   </p>
   <p>
    
     Today’s video games are increasingly intricate, leading to a proportional complexity in AI characters.
    
    
     Hence, the maintenance of these characters – or agents – is crucial.
    
    
     Unlike systems such as finite state machines, which become difficult to maintain as the number of states increases, behavior trees offer a practical and scalable solution for decision-making processes.
    
    
     When an agent executes a behavior tree, it conducts a
    
    <strong class="bold">
     
      depth-first search
     
    </strong>
    
     to
    
    <a id="_idIndexMarker263">
    </a>
    
     locate and execute the lowest-level
    
    
     
      leaf node.
     
    
   </p>
   <p>
    
     The key advantages of
    
    <a id="_idIndexMarker264">
    </a>
    <a id="_idIndexMarker265">
    </a>
    
     behavior trees over other systems lie in their scalability, expressiveness, and extensibility.
    
    
     Unlike other systems, behavior trees do not involve explicit transitions between states; instead, each node in the tree specifies how to run its children.
    
    
     This stateless nature eliminates the need to track previously executed nodes to determine the next set of behaviors.
    
    
     The expressiveness of behavior trees stems from the use of various levels of abstraction, implicit transitions, and complex control structures for
    
    
     
      composite nodes.
     
    
   </p>
   <p>
    
     Furthermore, in behavior trees, transitions occur through calls and return values exchanged between tree nodes, facilitating a two-way control
    
    
     
      transfer mechanism.
     
    
   </p>
   <h2 id="_idParaDest-134">
    <a id="_idTextAnchor136">
    </a>
    
     Behavior tree structure
    
   </h2>
   <p>
    
     A behavior tree is visually depicted as a tree
    
    <a id="_idIndexMarker266">
    </a>
    <a id="_idIndexMarker267">
    </a>
    
     structure with nodes categorized as
    
    <strong class="bold">
     
      root
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      control flow
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      execution
     
    </strong>
    
     – or
    
    <strong class="bold">
     
      tasks
     
    </strong>
    
     .
    
    
     In this representation, each node may have a parent node and one or more children.
    
    
     In particular, the following is
    
    
     
      worth noting:
     
    
   </p>
   <ul>
    <li>
     
      The root node has no parents and only
     
     
      
       one child
      
     
    </li>
    <li>
     
      Control flow nodes have one parent and at least
     
     
      
       one child
      
     
    </li>
    <li>
     
      Execution nodes have one parent and
     
     
      
       no children
      
     
    </li>
   </ul>
   <p>
    
     A behavior tree is executed starting from the root, which sends execution triggers to its
    
    
     
      child nodes.
     
    
   </p>
   <p>
    
     Whenever a control flow node is reached, it will control the execution and flow of decision-making within the tree, determining which tasks or sub-trees should be executed based on certain conditions
    
    
     
      or rules.
     
    
   </p>
   <p>
    
     Every time an execution node is triggered, it will execute a specific task, reporting back to its parent with a status of
    
    <em class="italic">
     
      running
     
    </em>
    
     if the task is ongoing,
    
    <em class="italic">
     
      success
     
    </em>
    
     if the objective is accomplished, or
    
    <em class="italic">
     
      failure
     
    </em>
    
     if the task
    
    
     
      is unsuccessful.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 7
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     shows an
    
    <a id="_idIndexMarker268">
    </a>
    <a id="_idIndexMarker269">
    </a>
    
     example of a behavior tree execution, starting from the root, going to a control flow node, and finally executing
    
    
     
      a task:
     
    
   </p>
   <div><div><img alt="Figure 7.1 – Behavior tree example" src="img/Figure_7.1_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.1 – Behavior tree example
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Behavior tree nodes are executed from top to bottom and left to right; this is also the way they are
    
    
     
      usually numbered.
     
    
   </p>
   <p>
    
     It goes without saying that there isn’t just one way to implement behavior trees.
    
    
     That’s why in the next section, I’ll dive into all the nitty-gritty details about the Unreal
    
    
     
      Engine system.
     
    
   </p>
   <h2 id="_idParaDest-135">
    <a id="_idTextAnchor137">
    </a>
    
     What is a behavior tree in Unreal Engine?
    
   </h2>
   <p>
    
     In Unreal Engine, behavior trees are
    
    <a id="_idIndexMarker270">
    </a>
    <a id="_idIndexMarker271">
    </a>
    
     assets that are edited in a similar way to Blueprints – that is, visually – by adding and linking a set of nodes with specific functionalities to form a
    
    <strong class="bold">
     
      behavior tree graph
     
    </strong>
    
     .
    
    
     During the
    
    <a id="_idIndexMarker272">
    </a>
    
     execution of logic in a behavior tree, a separate asset known as a Blackboard – further details on this will be provided later in this chapter – is used to retain information that the behavior tree requires to make
    
    
     
      well-informed decisions.
     
    
   </p>
   <p>
    
     A behavior tree is handled by a
    
    <strong class="source-inline">
     
      BehaviorTreeComponent
     
    </strong>
    
     instance that is held by the
    
    <strong class="source-inline">
     
      AIController
     
    </strong>
    
     instance.
    
    
     It should be noted that the component is not automatically attached to the controller; you will need to add it through C++ or Blueprints.
    
    
     If no component is present, it will automatically be created
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     When comparing Unreal Engine behavior trees with other behavior tree systems, one key distinction to keep in mind is their event-driven nature, which prevents constant code execution.
    
    
     Instead of continuously checking for relevant changes, an Unreal Engine behavior tree listens for events that can prompt tree modifications.
    
    
     Using an event-driven architecture provides performance enhancements and debugging capabilities benefits – this is something I will show in the
    
    
     
      upcoming chapters.
     
    
   </p>
   <h2 id="_idParaDest-136">
    <a id="_idTextAnchor138">
    </a>
    
     Behavior tree node instancing
    
   </h2>
   <p>
    
     It needs to be noted that
    
    <a id="_idIndexMarker273">
    </a>
    
     behavior trees exist as
    
    <strong class="bold">
     
      shared objects
     
    </strong>
    
     in your project; this means that all agents using a behavior tree will share the same instance, and all shared objects will be unable to store agent-specific data.
    
    
     The main advantages of using shared nodes are CPU speed improvement and reduced
    
    
     
      memory usage.
     
    
   </p>
   <p>
    
     Agent-specific data can be leveraged in many ways – one being the Blackboard that we will see later in this chapter – to give you more flexibility on how to use your
    
    
     
      behavior tree.
     
    
   </p>
   <p>
    
     Another such method is instancing single nodes; this will grant each AI agent using a behavior tree a unique instance of the node at the cost of higher performance and memory usage.
    
    
     An example of a node using such a
    
    <a id="_idIndexMarker274">
    </a>
    
     method is the
    
    
     <strong class="bold">
      
       PlayAnimation
      
     </strong>
    
    
     
      task.
     
    
   </p>
   <h2 id="_idParaDest-137">
    <a id="_idTextAnchor139">
    </a>
    
     Order of execution
    
   </h2>
   <p>
    
     As previously mentioned,
    
    <a id="_idIndexMarker275">
    </a>
    
     behavior tree nodes are executed from top to bottom and left to right and Unreal Engine is no exception.
    
    
     Nodes are numbered following this convention to easily track the execution order.
    
    
     <em class="italic">
      
       Figure 7
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     shows a behavior tree
    
    <a id="_idIndexMarker276">
    </a>
    <a id="_idIndexMarker277">
    </a>
    
     from the
    
    <strong class="bold">
     
      Lyra Starter Game
     
    </strong>
    
     project, showing the nodes with their corresponding
    
    
     
      sequence numbers:
     
    
   </p>
   <div><div><img alt="Figure 7.2 – Behavior tree sequence" src="img/Figure_7.2_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.2 – Behavior tree sequence
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In Unreal Engine, a root node is never numbered because it is not considered part of
    
    
     
      the sequence.
     
    
   </p>
   <p>
    
     In this section, you have received a gentle introduction to behavior trees and how they are executed.
    
    
     The next section will delve deeper into the Unreal Engine system to help you better understand how to incorporate behavior trees effectively into
    
    
     
      your games.
     
    
   </p>
   <h1 id="_idParaDest-138">
    <a id="_idTextAnchor140">
    </a>
    
     Understanding behavior trees in Unreal Engine
    
   </h1>
   <p>
    
     Understanding behavior trees and what they are made of is essential for designing effective AI systems in Unreal Engine; in this section, I will be presenting you with the key concepts associated with behavior trees to help you start developing your own
    
    
     
      AI characters.
     
    
   </p>
   <p>
    
     In Unreal Engine, there are five types of elements in
    
    
     
      behavior trees:
     
    
   </p>
   <ul>
    <li>
     
      
       Root node
      
     
    </li>
    <li>
     
      
       Task nodes
      
     
    </li>
    <li>
     
      
       Composite nodes
      
     
    </li>
    <li>
     
      
       Decorators
      
     
    </li>
    <li>
     
      
       Services
      
     
    </li>
   </ul>
   <p>
    
     To provide you with a comprehensive understanding of each type, I will present them individually, ensuring a clear depiction of their
    
    
     
      respective functions.
     
    
   </p>
   <h2 id="_idParaDest-139">
    <a id="_idTextAnchor141">
    </a>
    
     The root node
    
   </h2>
   <p>
    
     The root node
    
    <a id="_idIndexMarker278">
    </a>
    <a id="_idIndexMarker279">
    </a>
    
     functions as the initial point for a
    
    <a id="_idIndexMarker280">
    </a>
    <a id="_idIndexMarker281">
    </a>
    
     behavior tree; it holds a distinct position within the tree and is governed by a set of
    
    
     
      special rules:
     
    
   </p>
   <ul>
    <li>
     
      There can be only one such node in the
     
     
      
       tree structure
      
     
    </li>
    <li>
     
      It can have only one connection, and if this connection is removed, then the entire tree
     
     
      
       is disabled
      
     
    </li>
    <li>
     
      It does not support the attachment of decorator or
     
     
      
       service nodes
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 7.3 – Root node" src="img/Figure_7.3_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.3 – Root node
    
   </p>
   <h2 id="_idParaDest-140">
    <a id="_idTextAnchor142">
    </a>
    
     Task nodes
    
   </h2>
   <p>
    
     Task nodes are
    
    <a id="_idIndexMarker282">
    </a>
    <a id="_idIndexMarker283">
    </a>
    
     responsible for performing actions
    
    <a id="_idIndexMarker284">
    </a>
    <a id="_idIndexMarker285">
    </a>
    
     such as moving an AI or adjusting Blackboard values.
    
    
     A task will not stop its execution until a failure or success result
    
    
     
      is reported.
     
    
   </p>
   <p>
    
     A task node can also have one or more decorators or services attached, allowing for more complex behaviors and interactions within the
    
    
     
      game environment.
     
    
   </p>
   <p class="callout-heading">
    
     Task nodes
    
   </p>
   <p class="callout">
    
     Tasks are identified by a
    
    
     
      purple color.
     
    
   </p>
   <div><div><img alt="Figure 7.4 – Task examples" src="img/Figure_7.4_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.4 – Task examples
    
   </p>
   <p>
    
     Unreal Engine includes a set of pre-built tasks that are readily available for use.
    
    
     These tasks address the most generic scenarios that developers are likely to require.
    
    
     However, tasks can be extended to allow you to create your own
    
    
     
      custom nodes.
     
    
   </p>
   <p>
    
     Here is a partial list of some of the tasks that will be available to you as
    
    
     
      standard features:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Finish With Result
      
     </strong>
     
      : Once executed, this node will instantly finish with a defined result –
     
     <strong class="source-inline">
      
       Succeeded
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Failed
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Aborted
      
     </strong>
     
      , or
     
     
      <strong class="source-inline">
       
        In Progress
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       Move To
      
     </strong>
     
      : Once executed, it will move the AI agent to a target location by using the
     
     
      
       Navigation System
      
     
    </li>
    <li>
     <strong class="bold">
      
       Move Directly Toward
      
     </strong>
     
      : Once executed, it will move the AI agent to a target location without using the
     
     
      
       Navigation System
      
     
    </li>
    <li>
     <strong class="bold">
      
       Wait
      
     </strong>
     
      : Once executed, it will cause the behavior tree to wait on this node until a specified time
     
     
      
       has passed
      
     
    </li>
    <li>
     <strong class="bold">
      
       Play Animation
      
     </strong>
     
      : Once executed, this node will play a specified
     
     
      
       animation asset
      
     
    </li>
    <li>
     <strong class="bold">
      
       Play Sound
      
     </strong>
     
      : Once executed, this node will play a
     
     
      
       specified sound
      
     
    </li>
   </ul>
   <p>
    
     As you can see, tasks represent individual actions or operations that an AI agent can perform; you can use them to create simple actions or combine several to create more
    
    
     
      complex behaviors.
     
    
   </p>
   <h2 id="_idParaDest-141">
    <a id="_idTextAnchor143">
    </a>
    
     Composite nodes
    
   </h2>
   <p>
    
     Composite nodes
    
    <a id="_idIndexMarker286">
    </a>
    <a id="_idIndexMarker287">
    </a>
    
     define the root of a
    
    <a id="_idIndexMarker288">
    </a>
    <a id="_idIndexMarker289">
    </a>
    
     branch and set the rules for its execution; additionally, they are the only nodes that can be applied to the root node of a
    
    
     
      behavior tree.
     
    
   </p>
   <p>
    
     A composite node can also have decorators and services applied, enabling more complex logic in it.
    
    
     Once a service is applied, it will be active while the children of the composite
    
    
     
      are executed.
     
    
   </p>
   <p class="callout-heading">
    
     Composite nodes
    
   </p>
   <p class="callout">
    
     Composites are identified by a
    
    
     
      grey color.
     
    
   </p>
   <p>
    
     There are three composite
    
    
     
      nodes available:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Selectors
       
      </strong>
     
    </li>
    <li>
     
      <strong class="bold">
       
        Simple parallels
       
      </strong>
     
    </li>
    <li>
     
      <strong class="bold">
       
        Sequences
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     Let’s examine them one
    
    
     
      by one.
     
    
   </p>
   <h3>
    
     Selectors
    
   </h3>
   <p>
    
     Selector nodes execute
    
    <a id="_idIndexMarker290">
    </a>
    <a id="_idIndexMarker291">
    </a>
    
     their children sequentially
    
    <a id="_idIndexMarker292">
    </a>
    <a id="_idIndexMarker293">
    </a>
    
     from left to right, and they will halt execution as soon as one of them succeeds.
    
    
     When a child of a selector node succeeds, the selector itself is considered successful.
    
    
     On the other hand, if all the selector’s children fail, the selector node itself is marked
    
    
     
      as failed.
     
    
   </p>
   <div><div><img alt="Figure 7.5 – Selector node" src="img/Figure_7.5_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.5 – Selector node
    
   </p>
   <h3>
    
     Simple parallels
    
   </h3>
   <p>
    
     Simple parallel nodes
    
    <a id="_idIndexMarker294">
    </a>
    <a id="_idIndexMarker295">
    </a>
    
     enable the execution of a single
    
    <a id="_idIndexMarker296">
    </a>
    <a id="_idIndexMarker297">
    </a>
    
     main task node concurrently with a complete tree.
    
    
     After the main task is completed, you may decide – through the
    
    <strong class="bold">
     
      Finish Mode
     
    </strong>
    
     attribute – whether the node should immediately finish, halting the secondary tree, or whether it should wait for the secondary tree to finish
    
    
     
      before completing.
     
    
   </p>
   <p class="IMG---Figure">
    
     <img alt="Figure 7.6 – Simple Parallel node" src="img/Figure_7.6_B31016.jpg"/>
    
   </p>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.6 – Simple Parallel node
    
   </p>
   <h3>
    
     Sequences
    
   </h3>
   <p>
    
     Sequence nodes run their
    
    <a id="_idIndexMarker298">
    </a>
    <a id="_idIndexMarker299">
    </a>
    
     children sequentially from
    
    <a id="_idIndexMarker300">
    </a>
    <a id="_idIndexMarker301">
    </a>
    
     left to right.
    
    
     They halt execution when a child fails.
    
    
     If a child fails, the sequence also fails.
    
    
     Unlike selectors, the success of the sequence is achieved only when all its
    
    
     
      children succeed.
     
    
   </p>
   <div><div><img alt="Figure 7.7 – Sequence node" src="img/Figure_7.7_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.7 – Sequence node
    
   </p>
   <h2 id="_idParaDest-142">
    <a id="_idTextAnchor144">
    </a>
    
     Decorators
    
   </h2>
   <p>
    
     Decorators – sometimes also
    
    <a id="_idIndexMarker302">
    </a>
    <a id="_idIndexMarker303">
    </a>
    
     referred to as conditionals – are used to determine whether a branch in the tree, or even a
    
    <a id="_idIndexMarker304">
    </a>
    <a id="_idIndexMarker305">
    </a>
    
     single node, can be executed.
    
    
     They must be attached to either a composite or a
    
    
     
      task node.
     
    
   </p>
   <p>
    
     Decorators play a crucial role in determining the execution path of branches within the behavior tree; they essentially act as decision-makers, evaluating whether a specific branch or individual node should proceed with execution.
    
    
     They serve as a condition, assessing the viability of continuing down a particular branch, signaling a precautionary failure if the task – or a sub-tree – is destined to fail.
    
    
     This preemptive action helps prevent the decorator from attempting to carry out a task – or sub-tree – that is bound to fail due to various reasons such as insufficient information or
    
    
     
      outdated objectives.
     
    
   </p>
   <p class="callout-heading">
    
     Decorators
    
   </p>
   <p class="callout">
    
     Decorators are identified by a
    
    
     
      blue color.
     
    
   </p>
   <div><div><img alt="Figure 7.8 – Decorator applied to a Selector" src="img/Figure_7.8_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.8 – Decorator applied to a Selector
    
   </p>
   <p>
    
     Unreal Engine includes a set of pre-built
    
    <a id="_idIndexMarker306">
    </a>
    <a id="_idIndexMarker307">
    </a>
    
     decorators that are readily available for use, but they can be extended to allow you to create your own
    
    
     
      custom ones.
     
    
   </p>
   <p>
    
     Here is a partial list of some of the tasks that will be available to you as
    
    
     
      standard features:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Blackboard
      
     </strong>
     
      : Will check whether a value has been set – or not set – on a given
     
     
      
       Blackboard key
      
     
    </li>
    <li>
     <strong class="bold">
      
       Composite
      
     </strong>
     
      : Will let you create some more advanced logic than built-in nodes by using
     
     <strong class="bold">
      
       AND
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       OR
      
     </strong>
     
      , and
     
     
      <strong class="bold">
       
        NOT
       
      </strong>
     
     
      
       nodes
      
     
    </li>
    <li>
     <strong class="bold">
      
       Cooldown
      
     </strong>
     
      : Will lock the execution of a node or a branch until a predefined time
     
     
      
       has passed
      
     
    </li>
    <li>
     <strong class="bold">
      
       Does Path Exists
      
     </strong>
     
      : Will check whether a path is found between
     
     
      
       two points
      
     
    </li>
    <li>
     <strong class="bold">
      
       Loop
      
     </strong>
     
      : Will loop a node or a branch indefinitely – or a number of times,
     
     
      
       if set
      
     
    </li>
   </ul>
   <p>
    
     Most decorators include an
    
    <strong class="bold">
     
      Inverse Condition
     
    </strong>
    
     property, that will let you, well...
    
    
     invert the condition, giving you more flexibility.
    
    
     As an example, you may use the same decorator in a behavior tree to execute different tasks under
    
    
     
      opposite conditions.
     
    
   </p>
   <p>
    
     For instance, you may use
    
    <strong class="bold">
     
      Does Path Exist
     
    </strong>
    
     to move an AI agent to a target point and use
    
    <strong class="bold">
     
      Inverse Condition
     
    </strong>
    
     on another instance of
    
    <strong class="bold">
     
      Does Path Exist
     
    </strong>
    
     to look for an alternative
    
    
     
      target point.
     
    
   </p>
   <p>
    
     In conclusion, decorators serve as decision points that determine whether a certain action or branch within the behavior tree should be executed
    
    
     
      or not.
     
    
   </p>
   <h2 id="_idParaDest-143">
    <a id="_idTextAnchor145">
    </a>
    
     Services
    
   </h2>
   <p>
    
     Services can be
    
    <a id="_idIndexMarker308">
    </a>
    <a id="_idIndexMarker309">
    </a>
    
     attached to composite or task
    
    <a id="_idIndexMarker310">
    </a>
    <a id="_idIndexMarker311">
    </a>
    
     nodes and run at specific intervals – defined in the
    
    <strong class="bold">
     
      Interval
     
    </strong>
    
     attribute – while their branch is active.
    
    
     They are commonly employed for conducting checks and updating
    
    
     
      the Blackboard.
     
    
   </p>
   <p>
    
     Once triggered by a task or a composite, a service will keep executing regardless of the number of parent-child levels being executed below the
    
    
     
      owing node.
     
    
   </p>
   <p class="callout-heading">
    
     Services
    
   </p>
   <p class="callout">
    
     Services are identified by a
    
    
     
      green color.
     
    
   </p>
   <div><div><img alt="Figure 7.9 – Service applied to a Selector" src="img/Figure_7.9_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.9 – Service applied to a Selector
    
   </p>
   <p>
    
     Services are very specific to the behavior tree you are developing; this means that, most probably, you will have to create your own custom ones.
    
    
     However, Unreal Engine provides two pre-built services that are readily available
    
    
     
      for use:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Default Focus
      
     </strong>
     
      : This enables quick access to an actor from the AI controller instead of using a
     
     
      
       Blackboard key.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Run EQS
      
     </strong>
     
      : This can be used to regularly execute an EQS – more on this in
     
     <a href="B31016_11.xhtml#_idTextAnchor218">
      
       <em class="italic">
        
         Chapter 11
        
       </em>
      
     </a>
     
      ,
     
     <em class="italic">
      
       Understanding the Environment Query System
      
     </em>
     
      – at assigned intervals.
     
     
      It can also update a specified
     
     
      
       Blackboard key.
      
     
    </li>
   </ul>
   <p>
    
     Having covered the various types of nodes that make up a behavior tree, it’s now time to get into the next section in order to delve into
    
    
     
      Blackboard assets.
     
    
   </p>
   <h1 id="_idParaDest-144">
    <a id="_idTextAnchor146">
    </a>
    
     Understanding the Blackboard
    
   </h1>
   <p>
    
     In Unreal Engine, the Blackboard is a
    
    <a id="_idIndexMarker312">
    </a>
    <a id="_idIndexMarker313">
    </a>
    
     crucial component of behavior trees; it acts as a memory space – some sort of brain – where AI agents can read and write data during their decision-making process.
    
    
     This means that developers will be able to query and update information stored
    
    
     
      within it.
     
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker314">
    </a>
    <a id="_idIndexMarker315">
    </a>
    
     Blackboard is created as a
    
    <strong class="bold">
     
      Blackboard Data
     
    </strong>
    
     asset, which will be assigned to a behavior tree, and it contains a set of variables – named keys – that store specific information of predefined types.
    
    
     These keys can be accessed and manipulated during runtime to influence the decision-making of
    
    
     
      AI characters.
     
    
   </p>
   <div><div><img alt="Figure 7.10 – Blackboard example" src="img/Figure_7.10_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.10 – Blackboard example
    
   </p>
   <p>
    
     A key can be set to
    
    <strong class="bold">
     
      Instance Synced
     
    </strong>
    
     ; in this case, the key itself will be synchronized across all instances of the Blackboard.
    
    
     This synchronization ensures that any changes made to the value of the key will be reflected consistently across all instances of the AI agents sharing the same behavior tree
    
    
     
      and Blackboard.
     
    
   </p>
   <div><div><img alt="Figure 7.11 – The Instance Synced property" src="img/Figure_7.11_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.11 – The Instance Synced property
    
   </p>
   <p>
    
     A
    
    <a id="_idIndexMarker316">
    </a>
    <a id="_idIndexMarker317">
    </a>
    
     Blackboard can store up to 255 keys and it supports the following
    
    
     
      data types:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        FVector
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        FRotator
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        Bool
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        Int32
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        Float
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        UClass
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        UObject
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        FName
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        UEnum
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        FString
       
      </strong>
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     A Blackboard cannot
    
    
     
      store arrays.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      BlackboardComponent
     
    </strong>
    
     instance will allow you to query data from a Blackboard and store data in the Blackboard itself.
    
    
     The creation system follows a similar pattern to the
    
    <strong class="source-inline">
     
      BehaviorTreeComponent
     
    </strong>
    
     , as explained previously in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Despite its apparent simplicity, understanding how a Blackboard works is crucial for ensuring the effective functioning of your
    
    
     
      AI agents.
     
    
   </p>
   <h1 id="_idParaDest-145">
    <a id="_idTextAnchor147">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we were introduced to the behavior tree system.
    
    
     Beginning with a brief theoretical overview, we saw how behavior trees function in Unreal Engine and learned about the key components that constitute the entire system.
    
    
     Finally, we discussed the Blackboard asset, a crucial element for the effective operation of
    
    
     
      behavior trees.
     
    
   </p>
   <p>
    
     Get ready for the upcoming chapter, where we will guide you back into action and make you craft a behavior tree for our very own dummy character.
    
    
     Specifically, you will be creating your own custom services and tasks in order to give our soon-to-be AI agent a proper AI brain.
    
    
     Brace yourself, because things are about to get intriguingly wild and – sometimes –
    
    
     
      delightfully chaotic!
     
    
   </p>
  </div>
 </body></html>