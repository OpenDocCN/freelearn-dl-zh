- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extracting Linguistic Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a deep dive into the full power of spaCy. You will discover
    the linguistic features, including spaCy’s most used features such as the **part-of-speech**
    ( **POS** ) **tagger** , the **dependency parser** , the **named entity recognizer**
    , and **merging/splitting** features.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll learn about the POS tag concept, how the spaCy POS tagger functions,
    and how to place POS tags into your **natural-language understanding** ( **NLU**
    ) applications. Next, you’ll learn a structured way to represent the sentence
    syntax through the dependency parser. You’ll learn about the dependency labels
    of spaCy and how to interpret the spaCy dependency labeler results with revealing
    examples. Then, you’ll learn a very important NLU concept that lies at the heart
    of many **natural language processing** ( **NLP** ) applications— **named entity
    recognition** ( **NER** ). We’ll go over examples of how to extract information
    from the text using NER. Finally, you’ll learn how to merge and split the entities
    you extracted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is POS tagging?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to dependency parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing NER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging and splitting tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code of this chapter can be found at [https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition](https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition)
    .
  prefs: []
  type: TYPE_NORMAL
- en: What is POS tagging?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A part of speech is a syntactic category in which every word falls into a category
    according to its function in a sentence. For example, English has nine main categories:
    verb, noun, pronoun, determiner, adjective, adverb, preposition, conjunction,
    and interjection. We can describe the functions of each category as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verb** : Expresses an action or a state of being'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noun** : Identifies a person, a place, or a thing, or names a particular
    of one of these (a proper noun)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pronoun** : Can replace a noun or noun phrase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determiner** : Is placed in front of a noun to express a quantity or clarify
    what the noun refers to—briefly, a noun introducer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adjective** : Modifies a noun or a pronoun'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adverb** : Modifies a verb, an adjective, or another adverb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preposition** : Connects a noun/pronoun to other parts of the sentence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conjunction** : Glues words, clauses, and sentences together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interjection** : Expresses emotion in a sudden and exclamatory way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This core set of categories, without any language-specific morphological or
    syntactic features, are called **universal tags** . spaCy captures universal tags
    via the **pos_** **feature** .
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we are providing examples in the English language, so we’ll
    only focus on English. Different languages offer different tagsets. You can see
    the label schemes used by each model by selecting the model language at [https://spacy.io/models](https://spacy.io/models)
    and clicking on the **Label** **Scheme** button.
  prefs: []
  type: TYPE_NORMAL
- en: Each supported language of spaCy admits its own fine-grained tagset and tagging
    scheme. This language specific tagging scheme usually covers morphological features,
    tenses and aspects of verbs, number of nouns (singular/plural), person and number
    information of pronouns (first-, second-, or third-person, singular or plural),
    pronoun type (personal, demonstrative, or interrogative), adjective type (comparative
    or superlative), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: spaCy supports fine-grained POS tags to answer language-specific needs. The
    **tag_feature** corresponds to the fine-grained tags. Don’t worry if you haven’t
    worked with POS tags before, as you’ll become familiar by practicing with the
    help of our examples. You can also always call **spacy.explain()** on the tags.
    We usually call **spacy.explain()** in two ways, either directly on the tag name
    string or with **token.tag_** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that in practice with some coding. By this point, you should already
    have the spaCy library and the English model installed, but if not, you can just
    run **python –m pip install spacy** and then **python –m spacy download en_core_web_sm**
    . All set; let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s import spaCy and explain what the **NNS** tag means:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s load the English model and process a sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can print the text and the POS tag of each token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also print the explanation using **token.tag_** as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to know more about POS, you can read more about it at *Eight Parts
    of* *Speech* : [http://www.butte.edu/departments/cas/tipsheets/grammar/parts_of_speech.html](http://www.butte.edu/departments/cas/tipsheets/grammar/parts_of_speech.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: POS tagging offers a very basic syntactic understanding of the sentence. POS
    tags are used in NLU when we want to find the verbs and the nouns in a sentence
    or better disambiguate some words for their meanings (more on this subject soon).
  prefs: []
  type: TYPE_NORMAL
- en: Each word is tagged by a POS tag depending on its context—the other surrounding
    words and their POS tags. POS taggers are sequential statistical models, which
    means that *a tag of a word depends on the word-neighbor tokens, their tags, and
    the word itself* . POS tagging has always been done in different forms. **Sequence-to-sequence
    learning** ( **Seq2seq** ) started with **Hidden Markov Models** ( **HMMs** )
    and evolved to neural network models, usually using **Long Short-Term Memory**
    ( **LSTM** ) cells.
  prefs: []
  type: TYPE_NORMAL
- en: Many NLU applications still need to know the word type for better accuracy.
    Syntactic information can be used in a traditional task called **Word-Sense Disambiguation**
    ( **WSD** ). Let’s see how to tackle it with the help of the spaCy tagger in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Word-Sense Disambiguation (WSD)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WSD is a classical NLU problem of deciding in which sense a particular word
    is used in a sentence. A word can have many senses—for instance, consider the
    word bass. Here are some senses we can think of:'
  prefs: []
  type: TYPE_NORMAL
- en: Bass—sea bass, fish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bass—lowest masculine voice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bass—male singer with the lowest voice range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Determining the sense of the word can be crucial in search engines, machine
    translation, and question-answering systems. For the preceding example, bass,
    a POS tagger is unfortunately not much help as the tagger labels all senses with
    a noun tag. We need more than a POS tagger. How about the word *beat* ? Let’s
    have a look at this here:'
  prefs: []
  type: TYPE_NORMAL
- en: Beat—to strike violently ( **verb** ( **V** ))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beat—to defeat someone else in a game or a competition ( **verb** ( **V** ))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beat—rhythm in music or poetry ( **noun** ( **N** ))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beat—bird wing movement ( **noun** ( **N** ))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beat—completely exhausted ( **adjective** ( **ADJ** ))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, POS tagging can help a lot indeed. The *ADJ tag* determines the word sense
    definitely; if the word beat is tagged as ADJ, it identifies the sense *completely
    exhausted* . This is not true for the V and N tags; if the word beat is labeled
    with a V tag, its sense can be to *strike violently* or to *defeat someone else*
    . WSD is an open problem, and many statistical models are proposed. However, if
    you need a quick prototype, you can tackle this problem in some cases (such as
    in the preceding example) with the help of the spaCy tagger.
  prefs: []
  type: TYPE_NORMAL
- en: Verb tense and aspect in NLU applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we used the example of the travel agency application
    where we got the base forms (which are freed from verb tense and aspect) of the
    verbs by using **lemmatization** . In this subsection, we’ll focus on how to use
    the verb tense and aspect information that we lost during the lemmatization process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Verb tense** and **aspect** are maybe the most interesting information that
    verbs provide us, telling us when the action happened in time and if the action
    of the verb is finished or ongoing. Tense and aspect together indicate a verb’s
    reference to the current time. English has three basic tenses: past, present,
    and future. A verb tense can express different aspects and forms, such as the
    simple, progressive/continuous, perfect, perfect continuous, and future tenses.
    For instance, in the sentence *I’m eating* , the action *eat* happens in the present
    and is ongoing. Hence, we describe this verb as *present progressive/continuous*
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, how do we use this information in our travel agency NLU? Consider
    the following customer sentences that can be directed to our NLU application:'
  prefs: []
  type: TYPE_NORMAL
- en: I flew to Rome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m flying to Rome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will fly to Rome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In all the sentences, the action is to *fly* : however, only some sentences
    state the intent to make a ticket booking. Let’s imagine these sentences with
    a surrounding context, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: I flew to Rome three days ago. I still didn’t get the bill, please send it ASAP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m flying to Rome next week. Can you check flight availability?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will fly to Rome next week. Can you check the flights?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At a quick glance, the past form of the verb fly doesn’t indicate a booking
    intent. Rather, it directs to either a customer complaint or customer service
    issues. The *infinitive* and *present progressive* forms, on the other hand, point
    to booking intent. We can use the POS tags to filter these intents by filtering
    the sentences that have the **VBG** tag (a verb in present progressive form) or
    the **VB** tag (a verb in base/infinitive form). Let’s do that in the following
    code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have covered one semantic and one morphological task—WSD and tense/aspect
    of verbs. We’ll now continue with another syntactic concept—dependency parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to dependency parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With spaCy’s dependency parser, we can *represent the syntactic structure of
    sentences* . In the previous section, we focused on POS tags, which categorize
    words syntactically. While POS tags offer insights into the tags of neighboring
    words, they don’t reveal the relationships between words that are not directly
    adjacent in a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, dependency parsing involves analyzing sentence structures
    via dependencies between the tokens. The dependency parser tags syntactic relations
    between tokens of the sentence and connects tokens that are syntactically related.
    A dependency or a dependency relation is a directed link between two tokens.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the dependency parsing as a tree, as illustrated in *Figure
    3* *.1* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The result of running dependency parsing on a sentence](img/B22441_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The result of running dependency parsing on a sentence
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn more about these dependency relations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many statistical methods in NLP revolve around vector representations of words
    and treat a sentence as a sequence of words. As you can see in *Figure 3* *.1*
    , a sentence is more than a sequence of tokens—it has a structure. Every word
    in a sentence has a well-defined role, such as verb, subject, object, and so on;
    hence, sentences have a structure. This structure is used extensively in chatbots,
    question-answering, and machine translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful application that first comes to mind is determining the sentence
    object and subject. Again, let’s go back to our travel agency application. Imagine
    a customer is complaining about the service. Compare the two sentences *I forwarded
    you the email* and *You forwarded me the email* ; if we eliminate the stop words
    *I* , *you* , *me* , and *the* , this is what remains:'
  prefs: []
  type: TYPE_NORMAL
- en: I forwarded you the email -> forwarded email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You forwarded me the email -> forwarded email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though the remaining parts of the sentences are identical, the two sentences
    have very different meanings and require different answers. In the first sentence,
    the sentence subject is *I* (then, the answer most probably will start with *you*
    ), and the second sentence’s subject is *you* (which will end up in an *I* answer).
  prefs: []
  type: TYPE_NORMAL
- en: The dependency parser helps us to go deeper into the sentence syntax and semantics,
    going beyond the analysis of the words by themselves. Let’s explore more, starting
    from the dependency relations.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'spaCy assigns each token a dependency label, just as with other linguistic
    features such as a lemma or a POS tag. spaCy shows dependency relations with directed
    arcs. *Figure 3* *.2* shows an example of a dependency relation between a noun
    and the adjective that qualifies the noun:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Dependency relation between a noun and its adjective](img/B22441_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Dependency relation between a noun and its adjective
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency label describes the type of syntactic relation between two tokens
    as follows: one of the tokens is the **syntactic parent** (called the **head**
    ) and the other is its **dependent** (called the **child** ). In the preceding
    example, **flower** is the head and **blue** is its dependent/child.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency label is assigned to the child. Token objects have **dep** (int
    value) and **dep_** (unicode, human-readable string) properties that hold the
    dependency label, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we iterated over the tokens and printed their text and dependency
    labels. Let’s understand these dependency labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**blue** had the **amod** label assigned. **amod** is the dependency label
    for an adjective-noun relation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flower** is the **ROOT** . **ROOT** is a special label in the dependency
    tree; it is assigned to the main verb of a sentence. If we’re processing a phrase
    (not a full sentence), the **ROOT** label is assigned to the root of the phrase,
    which is the head noun of the phrase. In the **blue flower** phrase, the head
    noun, **flower** , is the root of the phrase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each sentence or phrase has exactly one root, and it’s the root of the parse
    tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree nodes can have more than one child, but each node can only have one parent
    (due to tree restrictions, and trees containing no cycles). In other words, every
    token has exactly one head, but a parent can have several children. This is the
    reason why the dependency label is assigned to the dependent node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see a list of the most common and useful dependency labels, then we’ll
    see how exactly they link tokens to each other. Here’s the list first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**amod** : Adjectival modifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**aux** : Auxiliary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**compound** : Compound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dative** : Dative object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**det** : Determiner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dobj** : Direct object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nsubj** : Nominal subject'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nsubjpass** : Nominal subject, passive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nummod** : Numeric modifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**poss** : Possessive modifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**root** : The root'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see examples of how these labels are used and what relation they express:'
  prefs: []
  type: TYPE_NORMAL
- en: '**amod** is an adjectival modifier. As understood from the name, this relation
    modifies the noun (or pronoun). In *Figure 3* *.3,* we see white modify sheep:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – amod relation](img/B22441_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – amod relation
  prefs: []
  type: TYPE_NORMAL
- en: '**aux** is what you might guess: it’s the dependency relation between an auxiliary
    verb and its main verb. The dependent is an auxiliary verb, and the head is the
    main verb. In *Figure 3* *.4* , we see that **has** is the auxiliary verb of the
    main **gone** verb:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – aux relation](img/B22441_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – aux relation
  prefs: []
  type: TYPE_NORMAL
- en: '**compound** is used for the noun compounds; the second noun is modified by
    the first noun. In *Figure 3* *.5* , **phone book** is a noun compound and the
    **phone** noun modifies the **book** noun:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – compound relation](img/B22441_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – compound relation
  prefs: []
  type: TYPE_NORMAL
- en: 'The **det** relation links a determiner (the dependent) to the noun it qualifies
    (its head). In *Figure 3* *.6* , **the** is the determiner of the noun **girl**
    in this sentence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – det relation](img/B22441_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – det relation
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look into two object relations, **dative** and **dobj** . The **dobj**
    relation is between the verb and its direct object. A sentence can have more than
    one object (such as in the following example); a direct object is the object that
    the verb acts upon, and the others are called **indirect objects** .
  prefs: []
  type: TYPE_NORMAL
- en: 'A direct object is generally marked with the **accusative case** . A **dative**
    relation points to a **dative object** , which receives an indirect action from
    the verb. In the sentence shown in *Figure 3* *.7* , the indirect object is **me**
    and the direct object is **book** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The direct and indirect objects of the sentence](img/B22441_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The direct and indirect objects of the sentence
  prefs: []
  type: TYPE_NORMAL
- en: '**nsubj** and **nsubjposs** are two relations that are related to the nominal
    sentence subject. The subject of the sentence is the one that committed the action.
    A passive subject is still the subject, but we mark it with **nsubjposs** . In
    *Figure 3* *.8* , **Mary** is the nominal subject of the sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – nsubj relation](img/B22441_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – nsubj relation
  prefs: []
  type: TYPE_NORMAL
- en: '**you** is the passive nominal subject of the sentence in *Figure 3* *.9* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – nsubjpass relation](img/B22441_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – nsubjpass relation
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered sentence subject and object relations. Now, we’ll discover
    two modifier relations; one is the **nummod (numeric modifier)** and the other
    is the **poss (possessive modifier)** . A numeric modifier modifies the meaning
    of the head noun by a number or quantity. In the sentence in *Figure 3* *.10*
    , **nummod** is easy to spot; it’s between **3** and **books** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – nummod relation](img/B22441_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – nummod relation
  prefs: []
  type: TYPE_NORMAL
- en: 'A possessive modifier happens either between a *possessive pronoun* and a noun
    or a *possessive’s* and a noun. In the sentence shown in *Figure 3* *.11* , **my**
    is a possessive marker on the noun **book** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – poss relation between my and book](img/B22441_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – poss relation between my and book
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, **is** is the **root** label, which is not a real relation
    but is a marker for the sentence verb. A root word has no real parent in the syntactic
    tree; the root is the main verb of the sentence. In the preceding sentence, the
    main verb is the **is** auxiliary verb. Notice that the root node has no incoming
    arc—that is, no parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most useful labels for our NLU purposes. Now let’s practice how
    we can make use of dependency labels. **token.dep_** includes the dependency label
    of the dependent token. The **token.head** property points to the head/parent
    token. Only the root token does not have a parent; spaCy points to the token itself
    in this case. Let’s bisect the example sentence from *Figure 3* *.11* , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterated over the tokens and printed the fine-grained POS tag and the dependency
    label. **is** is the main verb of the sentence and is labeled by the **ROOT**
    label. **This** is the subject of the sentence. We can go one level deeper and
    print the token heads this time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the verb **is** is the head of all the tokens except the **my**
    one, which has **book** as the head. Let’s examine the dependency tree of a longer
    and more complicated sentence, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in *Figure 3* *.12* , we locate the main verb and the **trying**
    root (it has no incoming arcs). The left side of the word **trying** looks manageable,
    but the right side has a chain of arcs. Let’s start with the left side. The **we**
    pronoun is labeled with **nsubj** . Hence, this is the nominal subject of the
    sentence. The other left arc, labeled **aux** , points to the **trying** dependent
    ( **are** ), which is the auxiliary verb of the main verb, **trying** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – A complicated parsing example](img/B22441_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – A complicated parsing example
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see what is happening on the right side. **trying** is attached to
    the second verb, **understand** , via an **xcomp** relation. The **xcomp** (or
    open complement) relation of a verb is a clause without its own subject. Here,
    the **to understand the difference** clause has no subject, so it’s an open complement.
    We follow the **dobj** arc from the second verb, **understand** , and land on
    the noun, **difference** , which is the direct object of the **to understand the**
    **difference** clause.
  prefs: []
  type: TYPE_NORMAL
- en: The *displaCy* online demo ( [https://demos.explosion.ai/displacy](https://demos.explosion.ai/displacy)
    ) is a great tool for you to try your own example sentences and see the parsing
    results. This section has a solid foundation for general linguistics and information
    extraction for the pattern-matching exercises we will see in [*Chapter 4*](B22441_04.xhtml#_idTextAnchor056)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this chapter, let’s learn about a very famous NLP task: NER.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing NER
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a **named entity** ? A named entity is a real-world object that we can
    refer to by a proper name or quantity of interest. It can be a person, a place
    (city, country, landmark, or famous building), an organization, a company, a product,
    dates, times, percentages, monetary amounts, a drug, or a disease name. Some examples
    are Alicia Keys, Paris, France, Brandenburg Gate, WHO, Google, Porsche Cayenne,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A named entity always points to a specific object, and that object is distinguishable
    via the corresponding named entity. For instance, if we tag the **Paris is the
    capital of France** sentence, we parse **Paris** and **France** as named entities,
    but not the word **capital** . The reason is that **capital** does not point to
    a specific object; it’s a general name for many objects.
  prefs: []
  type: TYPE_NORMAL
- en: NER categorization is a bit different from POS categorization. Here, the number
    of categories is as high as we want. The most common categories are person, location,
    and organization and are supported by almost every usable NER tagger.
  prefs: []
  type: TYPE_NORMAL
- en: 'spaCy supports a wide range of entity types. Which ones you use depends on
    your corpus. If you process financial text, you most probably use **MONEY** and
    **PERCENTAGE** more often than **WORK_OF_ART** . Here is a list of the entity
    types supported by spaCy (sourced from [https://towardsdatascience.com/explorations-in-named-entity-recognition-and-was-eleanor-roosevelt-right-671271117218](https://towardsdatascience.com/explorations-in-named-entity-recognition-and-was-eleanor-roosevelt-right-671271117218)
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '**PERSON** : People, including fictional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NORP** : Nationalities or religious or political groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FAC** : Buildings, airports, highways, bridges, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORG** : Companies, agencies, institutions, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPE** : Countries, cities, states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LOC** : Non-GPE locations, mountain ranges, bodies of water'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PRODUCT** : Objects, vehicles, foods, and so on ( not services)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EVENT** : Named hurricanes, battles, wars, sports events, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WORK_OF_ART** : Titles of books, songs, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LAW** : Named documents made into laws'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LANGUAGE** : Any named language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DATE** : Absolute or relative dates or periods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TIME** : Times smaller than a day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PERCENT** : Percentage, including %'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MONEY** : Monetary values, including unit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QUANTITY** : Measurements, as of weight or distance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORDINAL** : first, second, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CARDINAL** : Numerals that do not fall under another type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as with the POS tagger statistical models, NER models are also sequential
    models. The very first modern NER tagger model is a **Conditional Random Field**
    ( **CRF** ). CRFs are sequence classifiers used for structured prediction problems
    such as labeling and parsing. The current state-of-the-art NER tagging is achieved
    with the **transformers** architecture (more on that in [*Chapter 6*](B22441_06.xhtml#_idTextAnchor087)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Named entities in a doc are available via the **doc.ents** property. **doc.ents**
    is a list of **Span** objects, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: spaCy also tags each token with the entity type. The type of the named entity
    is available via **token.ent_type** (int) and **token.ent_type_** (unicode). If
    the token is not a named entity, then **token.ent_type_** is just an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as for POS tags and dependency labels, we can call **spacy.explain()**
    on the tag string or on **token.ent_type_** , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After tagging tokens with different syntactical features, we sometimes want
    to merge or split entities into fewer or more tokens. In the next section, we
    will see how this merging and splitting is done.
  prefs: []
  type: TYPE_NORMAL
- en: Merging and splitting tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, we want to unite or split multiword named entities. For example,
    this is needed when the tokenizer does not perform so well on some unusual tokens,
    and you need to split them by hand. In this subsection, we’ll cover a very practical
    remedy for our multiword expressions, multiword named entities, and typos: **doc.retokenize**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '**doc.retokenize** is used in a context manager and it’s the correct tool for
    merging and splitting the spans of **doc** objects. The **retokenizer.merge()**
    method should receive the spans to merge and the attributes to set on these merged
    tokens. Let’s see an example of retokenization by merging a multiword named entity,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a **doc** from the sentence and print the entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s see how spaCy separated the tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to merge tokens on positions **3** and **4** and de span slices are
    set as **(value_included, value_not_included)** , so we will slice **doc[3:5]**
    and set the **LEMMA** of this new token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s print the tokens again to see whether the merge worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Merging the tokens worked well, but how about splitting a multiword token into
    several tokens? In this setting, either there’s a typo in the text you want to
    fix, or the custom tokenization is not satisfactory for your specific sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Splitting a span is a bit more complicated than merging a span because of the
    following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We are changing the dependency tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to assign new POS tags, dependency labels, and necessary token attributes
    to the new tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basically, we need to think about how to assign linguistic features to the
    new tokens we created. Let’s see how to deal with the new tokens with an example
    of how to fix a typo, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3* *.13* shows what the dependency tree looks like before the splitting
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Sample sentence’s dependency tree before retokenization](img/B22441_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Sample sentence’s dependency tree before retokenization
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will split the **doc[3]** , **NewHampshire** , into two tokens: **New**
    and **Hampshire** . We will give fine-grained POS tags and dependency labels to
    the new tokens via the **attrs** dictionary to the **retokenize.split()** method.
    We will also rearrange the dependency tree by passing the new tokens’ parents
    via the **heads** parameter. While arranging the heads, there are two things to
    consider, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, when you provide a relative position, such as **(doc[3], 1)** , this
    means that the head of **doc[3]** will be the token that is *one position ahead*
    —in this case, that’s **doc[4]** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, if you give an absolute position, it means the position in the original
    **Doc** object. In the following code snippet, the second item in the **heads**
    list indicates that the head of the **Hampshire** token is the second token in
    the original Doc, which is the **in** token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s do this in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3* *.14* shows what the dependency tree looks like after the splitting
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Dependency tree after the splitting operation](img/B22441_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Dependency tree after the splitting operation
  prefs: []
  type: TYPE_NORMAL
- en: You can apply merging and splitting operations onto any span, not only the named
    entity spans. The most important part here is to correctly arrange the new dependency
    tree and the linguistic attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter gave you details of spaCy’s linguistic features and how to use
    them. You learned about POS tagging and applications and learned about an important
    yet not-so-well-known and well-used feature of spaCy—dependency labels. Then,
    we discovered a famous NLU tool and concept: NER. We saw how to do named entity
    extraction, again via examples. We finalized this chapter with a handy tool for
    merging and splitting spans.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s next? In the next chapter, we will discover how to use these linguistic
    features to extract information using the **Matcher** , **PhraseMatcher** , and
    **SpanRuler** classes.
  prefs: []
  type: TYPE_NORMAL
