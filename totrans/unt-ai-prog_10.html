<html><head></head><body>
		<div><h1 id="_idParaDest-114"><em class="italic"><a id="_idTextAnchor447"/>Chapter <a id="_idTextAnchor448"/>8</em>: Navigation Mesh</h1>
			<p>As we saw in <a href="B17984_07_Epub.xhtml#_idTextAnchor398"><em class="italic">Chapter 7</em></a>, <em class="italic">A* Pathfinding</em>, the most critical decision in pathfinding is how to represent the scene's geometry. The AI agents need to know where the obstacles are, and it is our job as AI designers to provide the best representation we can to the pathfinding algorithm. Previously, we created a custom representation by dividing the map into a 2D grid, and then we implemented a custom pathfinding algorithm by implementing A* using that representation. But wouldn't it be awesome if Unity could do all that for us?</p>
			<p>Fortunately, Unity can do this using <strong class="bold">Navigation Meshes</strong> (<strong class="bold">NavMeshes</strong>). While in the previous 2D representation, we divided the world into perfect squares, with NavMeshes, we will divide the world using arbitrary convex polygons. This representation has two exciting advantages: first, every polygon can be different, and therefore we can use a small number of big polygons for vast open areas and many smaller polygons for very crowded spaces; second, we do not need to lock the Agent on a grid anymore, and so the pathfinding produces more natural paths.</p>
			<p>This chapter will explain how we can use Unity's built-in NavMesh generator to make pathfinding for AI agents much easier and more performant. Some years ago, NavMeshes were an exclusive Unity Pro feature. Fortunately, this is not true anymore; NavMeshes are available in the free version of Unity for everyone!</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up the map</li>
				<li>Building the scene with slopes</li>
				<li>Creating navigation areas</li>
				<li>An overview of Off Mesh Links</li>
			</ul>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor449"/><a id="_idTextAnchor450"/>Technical requirements</h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <code>Chapter 8</code> folder in the book repository: <a id="_idTextAnchor451"/><a id="_idTextAnchor452"/><a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter08">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter08</a>.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor453"/>Setting up the map</h1>
			<p>To get <a id="_idIndexMarker390"/>started, let's build a simple scene, as shown in the following screenshot. This is the first scene in the example project and is called <code>NavMesh01-Simple.scene</code>. You can use a plane as the ground object and several cube entities as the wall objects:</p>
			<div><div><img src="img/B17984_08_1.jpg" alt="Figure 8.1 – An image of the NavMesh01-Simple scene, a plane with obstacles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – An image of the NavMesh01-Simple scene, a plane with obstacles</p>
			<p>In the following subsections, we will set up the walls as obstacles, bake the NavMesh, and configure the tanks.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor454"/><a id="_idTextAnchor455"/>Navigation static</h2>
			<p>Once we <a id="_idIndexMarker391"/>add the floor and the obstacles, it is essential to mark them<a id="_idIndexMarker392"/> with the <strong class="bold">Navigation Static</strong> tag so that the NavMesh generator knows that they need to be taken into account during the baking process. To do this, select all of the objects, click on the <strong class="bold">Static</strong> button, and choose <strong class="bold">Navigation Static</strong>, as shown in the following screenshot:</p>
			<div><div><img src="img/B17984_08_2.jpg" alt="Figure 8.2 – The Navigation Static property&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The Navigation Static property<a id="_idTextAnchor456"/><a id="_idTextAnchor457"/><a id="_idTextAnchor458"/></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor459"/>Baking the NavMesh</h2>
			<p>Now that we<a id="_idIndexMarker393"/> have <a id="_idIndexMarker394"/>completed the scene, let's bake the NavMesh. To do that, follow these steps:</p>
			<ol>
				<li>Navigate to <strong class="bold">Window</strong> | <strong class="bold">AI</strong> | <strong class="bold">Navigation</strong>, and you should be able to see this window:</li>
			</ol>
			<div><div><img src="img/B17984_08_3.jpg" alt="Figure 8.3 – Navigation window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Navigation window</p>
			<p class="callout-heading">Info</p>
			<p class="callout">All the <a id="_idIndexMarker395"/>properties <a id="_idIndexMarker396"/>in the <strong class="bold">Navigation</strong> window are pretty self-explanatory: <strong class="bold">Agent Radius</strong> and <strong class="bold">Agent Height</strong> represent the size of the virtual agent used by Unity to bake the NavMesh, <strong class="bold">Max Slope</strong> is the value in degrees of the sharpest incline the character can walk up, and so on. If we have multiple AI agents, we should bake the NavMesh using the radius and height of the <em class="italic">smallest</em> AI character. For more information, you can check out the following Unity reference documentation: <a href="https://docs.unity3d.com/Manual/Navigation.html">https://docs.unity3d.com/Manual/Navigation.html</a>.</p>
			<ol>
				<li value="2">Select the plane and, in the <strong class="bold">Object</strong> tab, set its area to <strong class="bold">Walkable</strong>.</li>
			</ol>
			<div><div><img src="img/B17984_08_4.jpg" alt="Figure 8.4 – The Object section of the Navigation panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – The Object section of the Navigation panel</p>
			<ol>
				<li value="3">Leave<a id="_idIndexMarker397"/> everything<a id="_idIndexMarker398"/> else with the default values and click on <strong class="bold">Bake</strong>.</li>
				<li>You should see a progress bar baking the NavMesh for your scene, and after a while, you should see the NavMesh in your scene, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B17984_08_5.jpg" alt="Figure 8.5 – The baking of a NavMesh&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The baking of a NavM<a id="_idTextAnchor460"/><a id="_idTextAnchor461"/><a id="_idTextAnchor462"/>esh</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor463"/>NavMesh agent</h2>
			<p>At this point, we<a id="_idIndexMarker399"/> have <a id="_idIndexMarker400"/>completed the super-simple scene setup. Now, let's add some AI agents to see if it works:</p>
			<ol>
				<li value="1">As a character, we use our trustworthy tank model. However, do not worry if you're working in a different scene and have a different model. Everything works the same way independently of the model.</li>
			</ol>
			<div><div><img src="img/B17984_08_6.jpg" alt="Figure 8.6 – Tank entity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Tank entity</p>
			<ol>
				<li value="2">Add the <strong class="bold">Nav Mesh Agent</strong> component to our tank entity. This component makes<a id="_idIndexMarker401"/> pathfinding <a id="_idIndexMarker402"/>easy. We do not need to implement pathfinding algorithms such as A* anymore. Instead, we only need to set the destination property of the component at runtime, and the component will compute the path using Unity's internal pathfinding algorithm.</li>
				<li>Navigate to <strong class="bold">Component</strong> | <strong class="bold">Navigation</strong> | <strong class="bold">Nav Mesh Agent</strong> to add this component:</li>
			</ol>
			<div><div><img src="img/B17984_08_7.jpg" alt="Figure 8.7 – Nav Mesh Agent properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Nav Mesh Agent properties</p>
			<p class="callout-heading">Info</p>
			<p class="callout">You can find the official Unity reference for the <strong class="bold">Nav Mesh Agent</strong> at <a href="https://docs.unity3d.com/Manual/class-NavMeshAgent.html">https://docs.unity3d.com/Manual/class-NavMeshAgent.html</a>.</p>
			<p>One property to <a id="_idIndexMarker403"/>note is the <strong class="bold">Area Mask</strong> property. It specifies the <a id="_idIndexMarker404"/>NavMesh layers that this NavMesh agent can walk on. We will talk about navigation layers in the<a id="_idTextAnchor464"/> <em class="italic">Baking navigation areas</em> s<a id="_idTextAnchor465"/>ection.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor466"/>Updating an agent's destinations</h2>
			<p>Now <a id="_idIndexMarker405"/>that we have set up our AI agent, we need a way to tell it <a id="_idIndexMarker406"/>where to go and update the destination of the tank to the mouse click position.</p>
			<p>So, let's add a sphere entity, which we use as a marker object, and then attach the <code>Target.cs</code> script to an empty game object. Then, drag and drop this sphere entity onto this script's <code>targetMarker</code> transform property in the Inspector.</p>
			<h3>The Target.cs class</h3>
			<p>This<a id="_idIndexMarker407"/> script <a id="_idIndexMarker408"/>contains a simple class that does three things:</p>
			<ul>
				<li>Gets the mouse click position using a ray</li>
				<li>Updates the marker position</li>
				<li>Updates the <code>destination</code> property of all the NavMesh agents</li>
			</ul>
			<p>The following lines show the <code>Target</code> class's code:</p>
			<pre>using UnityEngine;
using System.Collections;
public class Target : MonoBehaviour { 
    private UnityEngine.AI.NavMeshAgent[] navAgents;
    public Transform targetMarker;
    public float verticalOffset = 10.0f;
    void Start() {
        navAgents = FindObjectsOfType(
           typeof(UnityEngine.AI.NavMeshAgent)) as 
           UnityEngine.AI.NavMeshAgent[];
    }
    void UpdateTargets(Vector3 targetPosition) { 
        foreach (UnityEngine.AI.NavMeshAgent agent in 
                 navAgents) {
            agent.destination = targetPosition;
        }
    }
    void Update() {
        // Get the point of the hit position when the mouse 
        // is being clicked 
        if(Input.GetMouseButtonDown(0)) {
            Ray ray = Camera.main.ScreenPointToRay(
              Input.mousePosition);
            if (Physics.Raycast(ray.origin, ray.direction, 
                out var hitInfo)) {
                Vector3 targetPosition = hitInfo.point;
                UpdateTargets(targetPosition);
                targetMarker.position = targetPosition + 
                  new Vector3(0, verticalOffset, 0);
            }
        }
    }
}</pre>
			<p>At the start <a id="_idIndexMarker409"/>of the game, we look for all the <code>NavMeshAgent</code> array (note that if you want to spawn new agents at runtime, you need to update the <code>navAgents</code> list). Then, whenever there's a mouse click event, we do a simple raycast to determine the first object colliding with the ray. If the beam hits an object, we update the position of our marker and update each NavMesh agent's destination by setting the <code>destination</code> property with the new position. We will be using this script throughout this chapter to tell the destination position for our AI agents.</p>
			<p>Now, test the scene, and click on a point that you want your tanks to go to. The tanks should move<a id="_idIndexMarker411"/> as close <a id="_idIndexMarker412"/>as possible to that point while avoiding every static ob<a id="_idTextAnchor467"/>stacle (in this ca<a id="_idTextAnchor468"/>se, the walls).</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor469"/>Setting up a scene with slopes</h1>
			<p>Let's build <a id="_idIndexMarker413"/>a scene with some slopes, like this:</p>
			<div><div><img src="img/B17984_08_8.jpg" alt="Figure 8.8 – Scene with slopes-NavMesh02-Slope.scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Scene with slopes-NavMesh02-Slope.scene</p>
			<p>One important thing to note is that the slopes and the wall should be in contact. If we want to use NavMeshes, objects need to be perfectly connected. Otherwise, there'll be gaps in the NavMesh, and the Agents will not be able to find the path anymore. There's a feature<a id="_idIndexMarker414"/> called <strong class="bold">Off Mesh Link</strong> generation to solve similar problems, but we will look at Off Mesh Links in the <em class="italic">Using Off Mesh Links</em> section later in this chapter. For now, let's concentrate on building the slope:</p>
			<ol>
				<li value="1">Make sure<a id="_idIndexMarker415"/> to connect the slope properly:</li>
			</ol>
			<div><div><img src="img/B17984_08_9.jpg" alt="Figure 8.9 – A well-connected slope&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – A well-connected slope</p>
			<ol>
				<li value="2">We can adjust the <strong class="bold">Max Slope</strong> property in the Navigation window's <strong class="bold">Bake</strong> tab according to the level of slope in our scenes that we want to allow the Agents to travel. We'll use 45 degrees here. If your slopes are steeper than this, you can use a higher <strong class="bold">Max Slope</strong> value.</li>
				<li>Bake the scene, and you should have generated a NavMesh, like this:</li>
			</ol>
			<div><div><img src="img/B17984_08_10.jpg" alt="Figure 8.10 – The generated NavMesh&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – The generated NavMesh</p>
			<ol>
				<li value="4">We will place some tanks with the <strong class="bold">Nav Mesh Agent</strong> component.</li>
				<li>Create a new cube object and use it as the target reference position.</li>
				<li>We will be using our previous <code>Target.cs</code> script to update the destination property of the AI agent.</li>
				<li>Test run the scene, and you should see the AI agent crossing the <a id="_idTextAnchor470"/>slopes to reach the target.</li>
			</ol>
			<p>Congratulation, you<a id="_idIndexMarker416"/> have implemented your first basic NavMesh-powered AI. Now, you can implement agents able to navigate over simple plains. What if we want more complex scenarios? That's the topic of t<a id="_idTextAnchor471"/>he next section.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor472"/>Baking navigation areas with different costs</h1>
			<p>In games with <a id="_idIndexMarker417"/>complex environments, we usually have areas that are harder to traverse than others. For example, crossing a lake with a bridge is less challenging than crossing it without a bridge. To simulate this, we want to make crossing the lake more costly than using a bridge. This section will look at navigation areas that define different layers with different navigation cost values.</p>
			<p>For this, we build a scene, as shown in <em class="italic">Figure 8.11</em>. Three planes represent two ground planes separated by a water plane and connected by a bridge-like structure. As you can see, crossing over the water plane is the most direct way to traverse the lake; however, passing through the water costs more than using the bridge and, therefore, the pathfinding algorithm will prefer the bridge to the water:</p>
			<div><div><img src="img/B17984_08_11.jpg" alt="Figure 8.11 – Scene with layers – NavMesh03-Layers.scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Scene with layers – NavMesh03-Layers.scene</p>
			<p>Let's follow a step-by-step procedure so that we can create a navigation area:</p>
			<ol>
				<li value="1">Go to the <strong class="bold">Navigation</strong> window and select the <strong class="bold">Areas</strong> section:</li>
			</ol>
			<div><div><img src="img/B17984_08_12.jpg" alt="Figure 8.12 – The Areas section in the Navigation window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – The Areas section in the Navigation window</p>
			<p>Unity comes <a id="_idIndexMarker418"/>with three default layers: <strong class="bold">Default</strong>, <strong class="bold">Not Walkable</strong>, and <strong class="bold">Jump</strong>, each with potentially different cost values.</p>
			<ol>
				<li value="2">Let's add a new layer called <code>Water</code> and give it a cost of <code>5</code>.</li>
				<li>Select the water plane.</li>
				<li>Go to the <strong class="bold">Navigation</strong> window and, in the <strong class="bold">Object</strong> tab, set <strong class="bold">Navigation Area</strong> to <strong class="bold">Water</strong>:</li>
			</ol>
			<div><div><img src="img/B17984_08_13.jpg" alt="Figure 8.13 – Water layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – Water layer</p>
			<ol>
				<li value="5">Bake the NavMesh for the scene and run it to test it.</li>
			</ol>
			<p>You should see that the AI agents now choose the slope rather than going through the plane marked as the water layer because it's more expensive to traverse the water. Try experimenting with placing the target object at different points on the water plane. You should see that the AI agents sometimes swim back to the shore and sometimes take th<a id="_idTextAnchor473"/>e bridge rather <a id="_idIndexMarker419"/>than trying to swim across the water.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">You can find the official Unity documentation for <strong class="bold">NavMesh Areas</strong> at <a href="https://docs.unity3d.com/Manual/nav-AreasAndCosts.html">https://docs.unity3d.com/Manual/nav-AreasAndCosts.html</a>.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor475"/>Using Off Mesh Links to connect gaps between areas</h1>
			<p>Sometimes, there<a id="_idIndexMarker420"/> may be some gaps in the scene that can make the NavMeshes disconnected. For instance, the Agents do not find a path in our previous examples if we do not tightly connect the slopes to the walls, so we need to make it possible to jump over such gaps. In another example, we may want to set up points where our agents can jump off the wall onto the plane below. Unity has a feature called <strong class="bold">Off Mesh Links</strong> to connect such gaps. Off Mesh Links can be set up manually or can be automatically generated by Unity's NavMesh generator.</p>
			<p>Here's the scene that we're going to build in this example. As you can see in <em class="italic">Figure 8.14</em>, there's a small gap between the two planes. </p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B17984_08_14.jpg" alt="Figure 8.14 – The scene with Oﬀ Mesh Links – NavMesh04-OﬀMeshLinks.scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – The scene with Oﬀ Mesh Links – NavMesh04-O<a id="_idTextAnchor476"/><a id="_idTextAnchor477"/>ﬀMeshLinks.scene</p>
			<p>In this section, we <a id="_idIndexMarker421"/>will learn how to connect these two planes using <strong class="bold">Off Mesh Links</strong>.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor478"/>Generated Off Mesh Links</h2>
			<p>Firstly, we use<a id="_idIndexMarker422"/> autogenerated Off Mesh Links to connect the two planes. To do that, we need to follow these steps:</p>
			<ol>
				<li value="1">Mark these two planes as <strong class="bold">Off Mesh Link Generation</strong> and <strong class="bold">Static</strong> in the property Inspector, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B17984_08_15.jpg" alt="Figure 8.15 – Oﬀ Mesh Link Generation and Static&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – Oﬀ Mesh Link Generation and Static</p>
			<ol>
				<li value="2">Go to the <strong class="bold">Navigation</strong> window and look at the properties on the <strong class="bold">Bake</strong> tab. You can set the <a id="_idIndexMarker423"/>distance threshold to autogenerate Off Mesh Links:</li>
			</ol>
			<div><div><img src="img/B17984_08_16.jpg" alt="Figure 8.16 – Generated Oﬀ Mesh Links properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16 – Generated Oﬀ Mesh Links properties</p>
			<ol>
				<li value="3">Click on <strong class="bold">Bake</strong>, and you should have Off Mesh Links connecting the two planes, like this:</li>
			</ol>
			<div><div><img src="img/B17984_08_17.jpg" alt="Figure 8.17 – Generated Oﬀ Mesh Links&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.17 – Generated Oﬀ Mesh Links</p>
			<ol>
				<li value="4">Now, our AI agents <a id="_idIndexMarker424"/>can find the path between the planes. But first, ensure that the tanks have <strong class="bold">Jump</strong> enabled in the <strong class="bold">Area Mask</strong> property of the <strong class="bold">Nav Mesh Agent</strong> component, as shown in <em class="italic">Figure 8.18</em>:</li>
			</ol>
			<div><div><img src="img/B17984_08_18.jpg" alt="Figure 8.18 – The Area Mask configuration for the Tanks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.18 – The Area Mask configuration for the Tanks</p>
			<p>If everything is correct, agents will essentially jump to the other plane once they reach the edge of the<a id="_idIndexMarker425"/> plane and find an <strong class="bold">Off Mesh Link</strong> component. But, of course, if jumping agents are not what we want (after all, who has ever seen a jumping tank?), we should instead put a bridge for the<a id="_idTextAnchor479"/><a id="_idTextAnchor480"/><a id="_idTextAnchor481"/> Agents to cross.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor482"/>Manual Off Mesh Links</h2>
			<p>If we don't want<a id="_idIndexMarker426"/> to generate Off Mesh Links along the edge and, instead, we want the Agents to reach a certain point before teleporting to the other side, then we need to set up the Off Mesh Links manually, as we can see in <em class="italic">Figure 8.19</em>:</p>
			<div><div><img src="img/B17984_08_19.jpg" alt="Figure 8.19 – Manual Oﬀ Mesh Links setup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19 – Manual Oﬀ Mesh Links setup</p>
			<p>Execute the following steps to set up the Off Mesh Links manually:</p>
			<ol>
				<li value="1">We initialize a scene with a significant gap between the two planes. Then, we place two pairs of sphere entities on each side of the plane.</li>
				<li>Choose a<a id="_idIndexMarker427"/> sphere and add an <strong class="bold">Off Mesh Link</strong> component by navigating to <strong class="bold">Component</strong> | <strong class="bold">Navigation</strong> | <strong class="bold">Off Mesh Link</strong>. We only need to add this component to one sphere.</li>
				<li>Next, drag and drop the first sphere to the <strong class="bold">Start</strong> property and the other sphere to the <strong class="bold">End</strong> property:</li>
			</ol>
			<div><div><img src="img/B17984_08_20.jpg" alt="Figure 8.20 – Oﬀ Mesh Link component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20 – Oﬀ Mesh Link component</p>
			<ol>
				<li value="4">Go to the <strong class="bold">Navigation</strong> window and<a id="_idTextAnchor483"/> bake the scene.</li>
			</ol>
			<div><div><img src="img/B17984_08_21.jpg" alt="Figure 8.21 – Manually generated Oﬀ Mesh Links&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21 – Manually generated Oﬀ Mesh Links</p>
			<ol>
				<li value="5">The<a id="_idIndexMarker428"/> manual <strong class="bold">Off Mesh Links</strong> now connect the two planes, and AI agents can use them to traverse terrain, even in the presence of gaps.<p class="callout-heading">Info</p><p class="callout">You can find <a id="_idIndexMarker429"/>Unity's official reference for Off Mesh Links at <a href="https://docs.unity3d.com/Manual/nav-CreateOffMeshLink.html">https://docs.unity3d.com/Manual/nav-CreateOffMeshLink.html</a>.</p></li>
			</ol>
			<p>This last demo concludes our exploration of Unity's NavMeshes. You should now know all the basics of this vital tool for AI chara<a id="_idTextAnchor484"/>cter development. </p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor485"/>Summary</h1>
			<p>In this chapter, we learned how to generate and use NavMeshes to implement pathfinding for our games. First, we studied how to set up different navigation layers with varying costs for pathfinding. Then, using the destination property, we used the <strong class="bold">Nav Mesh Agent</strong> component to find the path and move toward the target. Next, we set up Off Mesh Links to connect the gaps between the NavMeshes using the autogeneration feature and a manual setup with the <strong class="bold">Off Mesh Link</strong> component.</p>
			<p>With all this information, we can now easily create simple games with a reasonably complicated AI. For example, you can try to set the destination property of AI tanks to the player's tank's position and make them follow it. Then, using simple FSMs, they can start attacking the player once they reach a certain distance. FSMs have taken us far, but they have their limits. In the next chapter, we will learn about Behavior Trees and how we can use them to make AI decisions in even the most complex games.</p>
		</div>
	</body></html>