<html><head></head><body>
        

                            
                    <h1 class="header-title">Navigation</h1>
                
            
            
                
<p><em>The problem behind pathfinding is as old as the Labyrinth at Knossos: how do I get from point A to point B using the shortest route and avoiding all obstacles in-between?</em></p>
<p>Many algorithms have been developed to solve pathfinding problems, including those related to the A* algorithm, which was first introduced in computer science during the 1960s (section 2).</p>
<p>Pathfinding routines are typical components of many video games, with Non-Player Characters (NPCs) having the task of finding optimal paths on the game maps, which can constantly change. For example, passageways, gates, or doors can change their statuses during gameplay.</p>
<p>There are quite a lot of problems when it comes to pathfinding, and unluckily for us, there isn't a one-solution-fits-all approach. This is because each problem will have its own solution, depending on the type of problem it is. Not only this, it will also depend on the type of game that you are developing. For example, is the final destination for the AI a static building (stationary), or do they need to jump on top of a floating raft (dynamic)? You also need to take the terrain into consideration – is it flat or rocky, and so on? To add an additional layer of complexity, we also need to consider whether there are obstacles present, as well as whether these objects are static (fire hydrant) or if they can be moved (e.g. boxes). Then, we need to think about the actual path itself. For example, it might be easier to travel along the road, but running across rooftops will get you where you need to be quicker. Following the same train of thought, the AI might not even have a final destination, in the sense that they don't have to be somewhere specific. For example, they might just wander around as someone who is part of a village. However, I have only highlighted a few issues and considerations that are related to pathfinding. As you experience different situations that use pathfinding, you are likely to encounter other issues. Remember to be patient and to consider all the variables that I have mentioned here and others that are specific to your situation.</p>
<p>Fortunately for us, Unreal has incorporated a navigation system that can be used for the most common of situations. As a result, we don't need to re-implement everything from scratch. The main goal of this chapter is to ensure that you understand how to use it, and ensure that you have some idea of how you can expand on it. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>
<p>What to expect from a <strong><em>Navigation System</em></strong></p>
</li>
<li>
<p>The <strong><em>Unreal Navigation System</em></strong>, and how it works</p>
</li>
<li>
<p>How to <strong><em>Generate the Navigation Mesh</em></strong> for a level, and its available settings</p>
</li>
<li>
<p>How to <strong><em>Modify the Navigation Mesh</em></strong>, by using the following:</p>
<ul>
<li><strong><em>Navigation Areas</em></strong>, to change the weight associated with a part of the Navigation Mesh</li>
<li><strong><em>Navigation Links</em></strong>, to connect two parts of the Navigation Mesh that would otherwise be separated</li>
<li><strong><em>Navigation Filters</em></strong>, to perform a slight change to the Navigation Mesh while executing a specific query on the <em>Navigation System</em></li>
</ul>
</li>
</ul>
<p>Let's dive in!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What to expect from a Navigation System</h1>
                
            
            
                
<p>First of all, before we explore the <strong><em>Unreal Navigation System</em></strong>, it is useful to define what we would expect from a generic <em>Navigation System</em>. The following is required from the <em>Navigation System</em>:</p>
<ul>
<li style="font-weight: 400">It needs to determine if a path (that can be traversed by the agent performing the query) exists between two generic points on the map</li>
<li style="font-weight: 400">If such a path exists, return the one that is the most convenient for the agent (usually the shortest)</li>
</ul>
<p>However, while searching for the best path, there are many aspects to take into consideration. A good navigation system should not only consider these, but also perform the query in a relatively short period of time. Some of these aspects are as follows:</p>
<ul>
<li style="font-weight: 400">Is the AI agent who's performing the query able to pass through a specific portion of the map? For instance, there might be a lake, and the AI character may or may not know how to swim. Similarly, can the agent crouch and move into a ventilation tunnel?</li>
<li style="font-weight: 400">The AI agent might want to avoid (or prefer) certain paths, which aren't necessarily the shortest ones. For instance, if a building is on fire, the agent should try to avoid this, or risk of getting burned. As another example, let's say there are two paths: one is covered from enemy fire, but it's long, while the other one is short but exposed to enemy fire; which one should the AI choose? Although this might be part of the decision-making process, some heuristics can be implemented at the level of pathfinding, and a navigation system should support them.</li>
<li style="font-weight: 400">A map might be dynamic, which means that obstacles, objects, roads, cliffs, and so on, change during gameplay. Is the navigation system able to handle these changes in real time while they happen, and correct the generated paths?</li>
</ul>
<p>Now, it's time to see how Unreal implements all of these features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unreal Navigation System</h1>
                
            
            
                
<p>The Unreal navigation system is based on a <strong><em>Navigation Mesh</em></strong> (<strong><em>Nav Mesh</em></strong> for short). It entails dividing the navigable space into areas – in this case, polygons – which are subdivided into triangles for efficiency. Then, to reach a certain place, each triangle is considered a node of a graph, and if two triangles are adjacent, then their respective nodes are connected. On this graph, you can execute a pathfinding algorithm, such as A* with a Euclidean distance heuristic, or even something more complicated (e.g. variants of A* or systems that take into consideration different costs). This will produce a path among these triangles where the AI character can walk.</p>
<p>In reality, this process is a little bit more complicated, because considering all the triangles as nodes of a giant graph will produce a good result, but it is inefficient, especially since we have access to the information that's stored in the polygons and how these are connected. Moreover, you might need extra information about specific triangles, which might have different costs, different abilities required to traverse them, etc… However, unless you need to change the underlying structure of the <em>Navigation System</em>, you don't need to work/operate at this level of detail. Being able to understand that all of the triangles form a graph in some way, in which pathfinding algorithms can run, is more than sufficient to master the tool itself. </p>
<p>To be able to use the <em>Navigation System</em>, let's understand the main process of setting up the navigation system. At this stage, we will no longer worry about how the system is structured underneath, but rather how we can use all of its features. The system will do the rest. In the same way, we need to provide information about the map to the navigation system (e.g. specify special areas). Usually, it's the AI programmer in your team who takes care of this, but if your team is small, a level designer might take care of this task. Although there is not a specific process, but, rather an iterative procedure, let's explore the different steps – or tools, if you prefer – that you can use to define the <em>Nav Mesh</em> in Unreal. We will examine them in detail throughout this chapter:</p>
<ul>
<li style="font-weight: 400"><strong>Generation of the Navigation Mesh</strong>: This is the first step. Before you'll be able to use the following tools, it is important to start generating a <em>Nav Mesh</em>. This step includes defining how to generate the polygons, the triangles, the precision of the <em>Nav Mesh</em>, and even which kind of agents will traverse this specific <em>Nav Mesh</em>.</li>
<li style="font-weight: 400"><strong>Navigation Mesh Modifiers</strong>: Not all the parts of the <em>Nav Mesh</em> are created equal, and this is a tool to specify which parts of the <em>Nav Mesh</em> should behave differently. In fact, as we have seen before, there might be a zone with poisoned gas, and the agent would like to avoid this part, unless they really have to traverse it. The Nav Mesh Modifier allows you to specify that the area containing the gas is special. However, the type of behavior within the area (e.g. this path should not be traversed, or should only be traversed by agents with swimming abilities) is specified within a Nav Area.</li>
<li style="font-weight: 400"><strong>Navigation Areas</strong>: This allows you to specify how a specific type of area should behave, whether it should be avoided, etc. These are key when performing <em>Nav Filtering</em> to determine which areas the agent can traverse.</li>
</ul>
<ul>
<li style="font-weight: 400"><strong>Navigation Links</strong>: These can connect two different parts of the <em>Nav Mesh</em>. Suppose you have a platform ledge. By default, the AI agent will find another way. If you have in mind the Third Person map template, the agent that needs to get down from platform will go around the area to use the stairs, rather than just falling/jumping off the platform. A <strong><em>Nav Link</em></strong> allows you to connect the part of the <em>Nav Mesh</em> that's on top of the platform with the part below it. As a result, the agent will be able to fall off the platform. However, note that <strong><em>Nav Links</em></strong> can connect two generic portions of the <em>Nav Mesh</em>, thus allowing pathfinding to find its way through jumps, teleports, etc.</li>
<li><strong>Nav Filtering</strong>: We don't necessarily want to find a path in the same way on every occasion. <strong><em>Nav Filtering</em></strong> allows us to define specific rules on how to perform the pathfind for that specific instance (for that specific time that the pathfind is invoked to seek a path).</li>
</ul>
<p>Let's break these points down and talk about them in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating the Navigation Mesh</h1>
                
            
            
                
<p>Generating a simple <em>Navigation Mesh</em> is pretty straightforward in Unreal. Let's look at how we can do it. From the <strong><em>Mode</em></strong> panel, in the <strong><em>Volume</em></strong> tab, you will be able to find the <strong>Nav Mesh Bounds Volume</strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c95dcf12-7fb9-4646-910e-f8caffee10e6.png" style="width:17.75em;height:24.50em;"/></p>
<p>Drag it into the world. You will notice that the volume is quite small in respect to the map. Everything inside that volume will be taken into consideration to generate a <em>Nav Mesh</em>. Of course, a <em>Nav Mesh</em> has many parameters, but for now let's keep thing simple.</p>
<p>If you press the <em>P</em> button on your keyboard, you will be able to see the <em>Nav Mesh</em> in the <em>Viewport</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7bda5f63-d4ba-4669-880e-571872b8f2f7.png" style="width:63.92em;height:37.92em;"/></p>
<p>As you can see, it is limited to the area that's contained in the volume of <strong><em>Nav Mesh Bounds Volume</em></strong>. Let's scale the <strong><em>Nav Mesh Bounds Volume</em></strong> to fit all the level we have. This is what your level should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9a05c6e9-be72-4247-8f7f-3a7faba6bc5b.png" style="width:63.92em;height:38.00em;"/></p>
<p>Did you notice how, while you were scaling your volume, the <em>Nav Mesh</em> was updating automatically? This is because, in Unreal, the <em>Nav Mesh</em> is generated every time something that impacts the <em>Nav Mesh</em> moves.</p>
<p>While updating, the part of the <em>Nav Mesh</em> that's affected (that is, updated) should turn red, as shown in the following screenshot:<br/>
<br/>
<img src="img/4fb77e20-0694-4e05-be87-ef51c87721e3.png" style="width:92.08em;height:54.67em;"/></p>
<p>This is how easy is to generate a <em>Nav Mesh</em>. However, to be able to master the tool, we need to learn more about how to refine the <em>Nav Mesh</em> and how it is used by the AI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting parameters for the Nav Mesh</h1>
                
            
            
                
<p>If you click on the <strong><em>Nav Mesh Bounds Volume</em></strong>, you will notice that there are no options for the generation of the <em>Nav Mesh</em>. In fact, some parameters are at the project level, while others are at the map level.</p>
<p>Let's navigate to the <strong><em>World Outliner</em></strong>, where you will find that a <strong><em>RecastNavMesh-Default</em></strong> actor has been placed in the scene, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6a7aa75c-89fb-4011-ab5d-b79e3d098f91.png" style="width:28.00em;height:23.92em;"/></p>
<p>In fact, when you drag a <strong><em>Nav Mesh Bounds Volume</em></strong>, if the map doesn't have a <strong><em>RecastNavMesh-Default</em></strong>, one will be created. If we click on it, we will be able to change all of its properties in the <strong><em>Details Panel</em></strong>.</p>
<p>As you can see, there are a lot of default values. These can be changed in the <em>Project Settings</em> (under the <em>Navigation Mesh</em> tab). Let's break down every section, and try to grasp the main concepts around them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Display settings</h1>
                
            
            
                
<p>As the name suggests, these are settings that are related on how we can visualize the <em>Nav Mesh</em> that we have generated in detail. In particular, we will be able to see the generated Polygons, the triangles, and how the polygons are connected. We will go through these in more detail in <a href="a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml">Chapter 12</a><em>, Debugging Methods for AI - Navigation, EQS, and Profiling</em>, when we will talk about debugging tools:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d306b851-9c15-49ac-91b8-d7d845857233.png" style="width:21.50em;height:33.83em;"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Generation settings</h1>
                
            
            
                
<p>These settings concern the generation of the <em>Nav Mesh</em>. Usually, the default values are more than perfect to start with, and so you should only touch these values if you know what you are doing. The following screenshot shows these settings:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7b4fde45-cb3b-465a-a1f0-6f15cbc1b1d1.png" style="width:38.25em;height:49.83em;"/></p>
<p>The best way to learn about these settings is by playing with their parameters, first in an example map, then in your own maps. After that, you need to check the results of doing this (especially with the visual debugging tools that are presented in <a href="a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml">Chapter 12</a>, <em>Debugging Methods for AI - Navigation, EQS, and Profiling</em>). To get you started, let's look at the main ones:</p>
<ul>
<li style="font-weight: 400"><strong>Tile Size UU</strong>: This parameter defines how fine the polygons that are generated are. Lower values mean a more precise navigation mesh, with more polygons, but also a slower generation time (and potentially more memory usage). You can see the effect of this parameter by turning on the <strong>Draw Triangle Edges</strong> in the display settings that are shown in the preceding screenshot.</li>
<li style="font-weight: 400"><strong>Cell Height</strong>: This determines how high the generated cells are from the floor (which might result in connecting areas at a different height, so be careful).</li>
<li style="font-weight: 400"><em>Agent settings</em> (<strong>Radius</strong>, <strong>Height</strong>, <strong>Max Height</strong>, <strong>Max Slope</strong>, <strong>Max Step Height</strong>): These settings are specific to your agents and should be specified appropriately. In particular, these are the minimum values an agent should have to traverse this <em>Nav Mesh</em>. As a result, the <em>Nav Mesh</em> will not be able to navigate with agents with smaller values than this, because the <em>Nav Mesh</em> is generated only for agents with these requirements. These settings are useful to generate an appropriate <em>Nav Mesh</em> for your agents, without wasting resources on a <em>Nav Mesh</em> with areas that your agents will never be able to navigate.</li>
<li style="font-weight: 400"><strong>Min Region Area</strong>: This gets rid of certain artifacts of the <em>Nav Mesh Generation</em> that are too insignificant to navigate.</li>
</ul>
<p>Many of the remaining settings are about optimization, and they can be overwhelming, especially for newcomers in AI Programming. Therefore, I decided to not include these details in this book. However, once you are confident about using the Navigation System, you can check the tool-tips of these settings and experiment with them so that you can learn about what they do.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project Settings</h1>
                
            
            
                
<p>It is worthwhile mentioning, even if we don't go through them in details, that same <em>Navigation</em> settings can be changed from the <strong><em>Project Settings</em></strong>; there is a specific tab for that, as shown in the following picture:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4ad635c0-048f-4e67-bec9-00bb4eabfd58.png"/></p>
<p>Interesting to notice is the last tab about <em>Agents</em>. Here it is possible to create an <em>Array</em> of <strong><em>Supported Agents</em></strong>, so that different agents can have different ways to navigate the <em>Nav Mesh</em>. For instance, a mouse might have a very different <em>Navigation Mesh</em> than a Giant Troll. In fact the mouse can also go in small holes, whereas the Troll can't. Here you will be able to specify all the different kinds of agents you have:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a66abba0-becf-4f70-9023-e4b8a90d4c55.png"/></p>
<p>You cannot assign directly which kind of <em>agents</em> your character will follow, but, based on the <em>Character Movement Component</em> (or <em>Movement Components</em> in general), a kind of agent is assigned to the <em>Character/AI Agent</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Settings on the Character Movement Component</h1>
                
            
            
                
<p>As we have seen from the previous section, the agents, which are its abilities, its shape, etc... influence a lot how it navigates the <em>Nav Mesh</em>. You will be able to find all of these settings on the <em>Character Movement Component</em>.</p>
<p>However, this component is outside the scope of this book, and we will not see it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the Navigation Mesh</h1>
                
            
            
                
<p>So far, we have seen how is it possible to generate a Navigation Mesh. However, we would like to modify this so that it suits our needs better. As we mentioned previously, there might be different areas that can be costly to traverse, or there might be a connection between two points of the <em>Nav Mesh</em> that seem to be separated (e.g. by a ledge).</p>
<p>As a result, this section explores the different tools that Unreal has to modify the <em>Nav Mesh</em> so that it can be adapted to the level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Nav Modifier Volume</h1>
                
            
            
                
<p>Alright – it's time to look at how we can start modifying the <em>Nav Mesh</em>. For instance, there might be a part of the <em>Nav Mesh</em> that we don't want to be crossable, or another section that we want to have different properties. We can do this by using a <strong><em>Nav Modifier Volume</em></strong>.</p>
<p>You can find this setting by going to the <em>Mode</em> panel, under the <em>Volumes</em> tab, and then by going to the <em>Nav Mesh Bounds Volume</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1db935b4-77c7-4a20-a9d5-3f5df34c14d9.png" style="width:20.92em;height:29.67em;"/></p>
<p>Once this volume has been placed in the map, the default value is to remove the part of the <strong><em>Nav Mesh</em></strong> within the volume, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5dbdb0f1-7a72-4f6b-ad6c-ab68a8627daa.png"/></p>
<p>This is useful when you have areas that you don't want your AI to go in, or fix up artifacts of your navigation mesh. Although the <strong><em>Nav Modifier Volume</em></strong> specifies a part of the map, the behavior is specified in the <strong><em>Nav Mesh Areas</em></strong>. This means that, if we look at the settings of the <strong><em>Nav Mesh Modifier Volume</em></strong>, we can find only one related to the <em>Navigation</em>, named <strong><em>Area Class</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cf02f114-879b-4d7f-92ee-9cc5185b4e2a.png" style="width:26.67em;height:4.67em;"/></p>
<p>As a result, this volume can only specify a portion of the map in which a specific <strong><em>Area Class</em></strong> is applied. By default, the <strong><em>Area Class</em></strong> is <strong><em>NavArea_Null</em></strong>, which "<em>removes</em>" the <em>Nav Mesh</em> in that portion of the map that's overlapping this volume. We'll explore how <strong><em>Nav Mesh Areas</em></strong> work in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Nav Mesh Areas</h1>
                
            
            
                
<p>In the previous section, we talked about how not all parts of the navigable area of the map are created equal. If there is a zone that it is considered dangerous, the AI should avoid it. Unreal's built-in navigation system is able to handle these different areas by using costs. This means that the AI will evaluate the path to take by summing all the costs along the path, and it will select the one with the minimal cost.</p>
<p>Also, it is worth specifying that there are two types of costs. For each area, there is an initial cost for entering (or leaving) the area and a cost for traversing the area. Let's look at a couple of examples to clarify the difference between the two.</p>
<p>Imagine that there is a forest, but at each entrance of the forest, the AI needs to pay a toll to the indigenous living in the forest. However, once inside, the AI can move freely, as if they were outside the forest. In this case, entering the forest has a cost, but once inside, there is no cost to pay. As a result, when the AI needs to evaluate whether to traverse the forest or not, it depends on whether there is another way to go and how long it would take them to do so.</p>
<p>Now, imagine that there is an area with poison gas instead. In this second scenario, the cost for entering the area might be zero, but the cost for traversing it is high. In fact, the longer the AI stays in the area, the more health it loses. Whether it is worth entering or not only depends on whether there is an alternative way and how long that alternative way will take to traverse (like in the previous case), but also how long, once entered, the AI needs to traverse the area.</p>
<p>In Unreal, costs are specified inside the class. If you click on a <strong><em>Nav Modifier Volume</em></strong>, you will notice that you need to specify an <strong><em>Area Class</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e2ce11a2-a705-48ff-a8da-fce7169816dd.png" style="width:27.67em;height:5.00em;"/></p>
<p>As you may have guessed, the default value is <strong><em>NavArea_Null</em></strong>, which has an infinite cost for entering, resulting in the AI never going into that area. The Navigation system is smart enough to not even bother generating that area, and treats it as a non-navigable area.</p>
<p>However, you can change the <strong><em>Area Class</em></strong>. By default, you will be able to access the following <em>Area Classes</em>:</p>
<ul>
<li><strong><em>NavArea_Default</em></strong>: This is the default area that is generated. It is useful to have it as a modifier in case you want to have more than one of these modifiers in the same spot.</li>
<li><strong>NavArea_LowHeight</strong>: This indicates that the area is not suitable for every agent, since the height is reduced (for example, in the case of a ventilation tunnel, not all the agents can fit/crouch).</li>
<li><strong>NavArea_Null</strong>: This makes the area non-navigable for all the agents.</li>
<li class="CDPAlignLeft CDPAlign"><strong>NavArea_Obstacle</strong>: This assigns a higher cost to the area, so the agent will want to avoid it:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/7e2b287f-260f-4a69-972f-f53b0a1be631.png" style="width:33.75em;height:18.08em;"/></p>
<p>You will notice that if you create a new Blueprint, or even when you open the source code in Visual Studio, there will be <strong>NavArea_Meta</strong> and a child of it, <strong>NavArea_MetaSwitchingActor</strong>. However, if you look at their code, they mainly have some deprecated code. Therefore, we won't be using them in this book.</p>
<p>However, you can extend the list of the different areas (and potentially add more functionalities) by extending the <strong><em>NavArea Class</em></strong>. Let's see how we can do this, both in Blueprint and C++. Of course, as we did in the previous chapter, we are going to create a new folder named <em>Chapter3/Navigation</em>, in which we will place all our code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a NavArea class in Blueprint</h1>
                
            
            
                
<p>Creating a new <strong><em>NavArea</em></strong> class in blueprint is quite straightforward; you just need to create a new Blueprint that inherits from the <strong><em>NavArea</em></strong> class, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a3907d95-e2b5-4284-8d11-238ff812a44c.png" style="width:34.58em;height:42.75em;"/></p>
<p>By convention, the name of the class should start with "<em>NavArea_</em>". We will rename it to <strong><em>NavArea_BPJungle</em></strong> here (I added BP to signify that we have created this with Blueprint, since we are repeating the same task both in Blueprint and in C++). This is what it should look like in the <em>Content Browser</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9b2e7914-a6c9-464b-8dc8-3e0f4921f9cc.png" style="width:25.08em;height:17.75em;"/></p>
<p>Then, if you open the blueprint, you will be able to assign the custom costs to the area. You can also specify a specific color for your area so that it is easy to recognize when you build your <em>Nav Mesh</em>. This is what the <em>Details</em> panel looks like by default:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/20aef577-b969-498d-b42d-6a5c75c5b16a.png" style="width:33.92em;height:12.92em;"/></p>
<p>Now, we can customize as per our needs. For example, we might want to have a cost to enter the <em>Jungle</em>, and a slightly higher cost to traverse it. We are going to use a bright green for the color, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e241764-a571-49aa-90d8-873e5d59d480.png"/></p>
<p>Once compiled and saved, we can assign this newly created area to the <strong><em>Nav Modifier Volume</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fe05e7eb-2bbd-4282-a6c3-ee63a9ffca6a.png" style="width:23.58em;height:3.75em;"/></p>
<p>This is what our finished class looks like in our level (if the <em>Navigation Mesh</em> is visible):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e9eeedb0-3cd3-4091-aa80-8b852d08869a.png" style="width:73.92em;height:44.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a NavArea class in C++</h1>
                
            
            
                
<p>It's easy to create a <em><strong>NavArea</strong></em> class in C++ as well. First of all, you need to create a new C++ class that inherits from the <strong><em>NavArea</em></strong> class, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/08e5efd9-ba54-4a2d-b17f-ed75f2d2b4ba.png" style="width:60.67em;height:36.67em;"/></p>
<p>By convention, the name should start with "<em>NavArea_</em>". Therefore, you can rename it <strong><em>NavArea_Desert</em></strong> (just to vary which kind of terrain the AI can face, since we created a <em>Jungle</em> previously) and place it in "<strong><em>Chapter3/Navigation</em></strong>":</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/60f44b62-465c-4eb7-a887-6aff0a644ad7.png" style="width:62.17em;height:37.58em;"/></p>
<p>Once you have created the class, you just need to assign the parameters in the constructor. For your convenience, here is the class definition in which we declare a simple constructor:</p>
<pre>#include "CoreMinimal.h"<br/>#include "NavAreas/NavArea.h"<br/>#include "NavArea_Desert.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class UNREALAIBOOK_API UNavArea_Desert : public UNavArea<br/>{<br/>  GENERATED_BODY()<br/><br/>  UNavArea_Desert();<br/>  <br/>};</pre>
<p>Then, in the implementation of the constructor, we can assign the different parameters. For instance, we can have a high cost for entering and a higher cost for traversing (with respect to the <em>Default</em> or the <em>Jungle</em>). Furthermore, we can set the color to <em>Yellow</em> so that we remember that it is a desert area:</p>
<pre>#include "NavArea_Desert.h"<br/><br/>UNavArea_Desert::UNavArea_Desert()<br/>{<br/>  DefaultCost = 1.5f;<br/>  FixedAreaEnteringCost = 3.f;<br/>  DrawColor = FColor::Yellow;<br/>}</pre>
<p>You can always play with these values to see which one works best for you. For instance, you can create an area with a very high entering cost, but a low traversal cost. As a result, you will have an area that, should be avoided if it's only going to be traversed for a little while, but if the agent traverses it for a long period of time, it might be more convenient than the shorter route.</p>
<p>Once you have created the class, you can set it as part of the <strong><em>Nav Modifier Volume</em></strong>, as shown in the following screenshot: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/73745221-a2e8-420a-8710-ef9639376624.png" style="width:32.08em;height:5.33em;"/></p>
<p>As a result, you will be able to see your custom area in the <em>Nav Mesh</em> (in this case, with a <em>Yellow Color</em>)<em>:</em></p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8ff546d2-ffcc-419a-8a9a-47b27a3bab00.png" style="width:71.83em;height:42.00em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Nav Link Proxy</h1>
                
            
            
                
<p>By default, if there is a ledge, the AI will not fall through it, even if it would be the shortest path they could take to get to their destination. In fact, the <em>Nav Mesh</em> on top of the ledge is not (directly) connected with the <em>Nav Mesh</em> at the bottom. However, the <em>Unreal Navigation System</em> provides a way to connect two arbitrary triangles in the <em>Nav Mesh</em> through what is called a <strong><em>Nav Link Proxy</em></strong>.</p>
<p>Although the regions are connected, and the pathfinder will find the correct road, the AI cannot go against the rules of the game, both in terms of physics or game mechanics. This means that if the AI is unable to jump or traverse a magic wall, the character will get stuck since the pathfinder returned a path, but the character cannot execute it.</p>
<p>Let's explore this tool in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Nav Link Proxy</h1>
                
            
            
                
<p>To connect two regions with a link, we need to go to the <strong><em>Mode</em></strong> panel in the <strong><em>All Classes</em></strong> tab and select <strong><em>Nav Link Proxy</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7efd30e8-18cf-4e84-aa25-cfb16f3c32fe.png" style="width:22.92em;height:35.33em;"/></p>
<p>Alternatively, you can search for it in the <em>Modes</em> panel to find it more quickly:<br/>
<br/>
<img src="img/8b88cd2f-5954-461f-989d-b6236f2a911f.png" style="width:24.42em;height:9.08em;"/></p>
<p>Once the link has been placed in the level, you will see an "<em>arrow/link</em>", and you will be able to modify the start and end points of the link. They are called <strong><em>Left</em></strong> and <strong><em>Right</em></strong>, and the easiest way to set their location is by dragging (and placing) them in the <em>Viewport</em>. As a result, you will be able to connect two different parts of the <em>Nav Mesh</em>. As we can see in the following screenshot, if the <em>Nav Mesh</em> is visible (enabled with the <em>P</em> key), you will see an arrow connecting the <strong><em>Right</em></strong> and <strong><em>Left</em></strong> nodes. This arrow is pointing in both directions. This will result in the link being bidirectional:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c72f4dfa-8b3d-481e-b4e0-f2d54ea58e6c.png" style="width:69.58em;height:44.08em;"/></p>
<p>You might notice that there are two arrows, one with a darker shade of green. Also, this second <em>arro</em><em>w/arc/link</em> might not be exactly where you placed your <em>Right</em> end, but rather attached to the <em>Nav Mesh</em>. You can see this second arrow more clearly in the following screenshot:<br/>
<br/>
<img src="img/546c4c46-99a4-413c-a745-fa7b6f80b15e.png"/><br/>
<br/>
This is actually how the <em>Nav Mesh</em> is connected, due to the <em>Projection Settings</em> of the <em>Link</em>. We will explore this setting in the next section.</p>
<p>If you want to make the link go only in one direction, we can change this setting in the <em>Details Panel</em>. However, to explore these settings, we first need to understand that there are two different types of <em>Links</em>: <strong><em>Simple</em></strong> and <strong><em>Smart</em></strong>.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple Links and Smart Links</h1>
                
            
            
                
<p>When we create a <strong><em>Nav Link Proxy</em></strong>, it comes with an array of <strong><em>Simple Links</em></strong>. This means that with a single <strong><em>Nav Link Proxy</em></strong>, we can connect different parts of the <em>Nav Mesh</em> together. However, the <strong><em>Nav Link Proxy</em></strong> comes with a single <strong><em>Smart Link</em></strong> as well, which is disabled by default.</p>
<p class="mce-root">Let's learn about the similarities and difference between a <strong><em>Simple Link</em></strong> and a <strong><em>Smart Link</em></strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Both Simple and Smart Links</h1>
                
            
            
                
<p class="mce-root"><strong><em>Both Simple and Smart Links</em></strong> behave in a similar fashion, in the sense that they connect two parts of the <em>Nav Mesh</em> together. Moreover, Both type of links can have <strong><em>Direction</em></strong> (<em>Left to Right</em>, <em>Right to Left</em>, or <em>Both Ways</em>) and a <strong><em>Nav Area</em></strong> (which kind of navigation area the link is in; for instance, you might want to have a custom cost when using this link).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple Links</h1>
                
            
            
                
<p class="mce-root"><strong><em>Simple Links</em></strong> exists in the <strong><em>Point Links Array</em></strong> within the <em>Nav Proxy Link</em>, which means that multiple simple links in a single <em>Nav Proxy Link</em> are possible. To create another <em>Simple Link</em>, you can add an additional element to the array of <em>Simple Nodes</em> from the <em>Details</em> panel, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/39a6c509-1e98-4a47-9dc3-7716d8590c37.png" style="width:26.50em;height:9.58em;"/></p>
<p class="mce-root">Once we have more <em>Simple Links</em>, we can set the <strong><em>Start</em></strong> and <strong><em>End</em></strong> positions, like we did for the first one (by selecting them and moving them within the <em>Viewport</em> as any other actor). The following screenshot shows where I placed two <em>Simple Links</em> on the same <em>Nav Proxy Link</em> next to each other:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0c6c5746-93b0-4c2f-b473-42e3ce0696ee.png" style="width:76.67em;height:48.58em;"/></p>
<p>Every time we create a <em>Nav Link Proxy</em>, it comes with one <em>Simple Link</em> within the array.</p>
<p>For every <strong><em>Simple Link</em></strong> we have in the <em>Point Links Array</em>, we can access its settings by expanding the item. The following screenshot shows the Settings for the first <em>Simple Link</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6294e13f-1c31-4d72-90e9-e0303d1c8030.png" style="width:34.92em;height:27.67em;"/></p>
<p>Let's understand these various settings:</p>
<ul>
<li><strong><em>Left</em></strong> and <strong><em>Right</em></strong>: The position of the <strong><em>Left</em></strong> and <strong><em>Right</em></strong> ends of the Link, respectively.</li>
<li><strong><em>Left Project Height</em></strong> and <strong><em>Right Project Height</em></strong>: If this number is greater than zero, then the link will be projected down to the navigation geometry (using a trace with the maximum length specified by this number) for the <em>Left</em> and <em>Right</em> end of the <em>Link</em>, respectively. You can see this projected link in the following screenshot:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/31afd7a3-fd7e-480c-b726-e0e967eb9d8f.png" style="width:82.33em;height:52.17em;"/></p>
<ul>
<li><strong><em>Direction</em></strong>: This specifies in which direction the link works. Also, the arrow in the <em>Viewport</em> will update accordingly. The possible options for this are as follows:
<ul>
<li><strong><em>Both Ways</em></strong>: The link is bidirectional (remember that the AI needs to be equipped to traverse the Link in both directions; e.g. if we're going over a ledge, the agent needs to be able to fall from it (one direction of the link) and jump (the other direction of the link).</li>
<li><strong><em>Left to Right</em></strong>: The link is only crossable from the Left end to the Right one (the agent still needs to have the ability to go in that link direction).</li>
<li><strong><em>Right to Left</em></strong>: The link is only crossable from the Right end to the Left one (the agent still needs have the ability to go in that link direction).</li>
</ul>
</li>
<li><strong><em>Snap Radius</em></strong> and <strong><em>Height Radius</em></strong>: You may have noticed a cylinder that attaches the end of each link. These two settings control the Radius and the Height of that cylinder. Check <em>Snap to Cheapest Area</em> for more information about the use of this cylinder. The following screenshot shows that the first link has a bigger cylinder (both a bigger radius and higher):</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/695389b2-d0c7-4738-b69b-acf7be8d5361.png" style="width:80.50em;height:48.75em;"/></p>
<ul>
<li><strong><em>Description</em></strong>: This is just a string in which you can insert a description for your convenience; it has no impact on the <em>Navigation</em> or on the <em>Link</em>.</li>
<li><strong><em>Snap to Cheapest Area</em></strong>: If enabled, it will try to connect the link ends to the cheapest area among the available triangles within the cylinder that's specified by the <em>Snap Radius</em> and the <em>Height Radius</em>. For instance, if the cylinder intersects both the <em>Default Nav Area</em> and the <em>BPJungle</em> Nav Area (that we created earlier), the link will be connected directly to the <em>Default Nav Area</em>, rather than the jungle.</li>
<li><strong><em>Area Class</em></strong>: The <em>Link</em> might have a cost to traverse, or be of a specific <em>Nav Area</em>. This parameter allows you to define which kind of <em>Nav Area</em> the <em>Link</em> is when traversed.</li>
</ul>
<p>This concludes all the possibilities for the <strong><em>Simple Links</em></strong>. However, this is a very powerful tool that lets you shape the <em>Nav Mesh</em> and achieve amazing AI behavior. Now, let's dive into <em>Smart Links</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Smart Links</h1>
                
            
            
                
<p class="mce-root">Smart Links can be enabled and disabled at <em>runtime</em> using the "<strong><em>Smart Link Is Relevant</em></strong>" boolean variable. You can also notify surrounding actors of this change. By default, it is not relevant (it isn't used in the sense that the link is not available), and there is only a single <strong><em>Smart Link</em></strong> per <em>Nav Proxy Link</em>.</p>
<div><strong>Please note, and don't get confused</strong>: The <em>Smart link</em> can be in two states: Enabled and Disabled. However, if the link is actually "present/exists" (for the Navigation Mesh), that is another property (<em>Smart Link Is Relevant</em>), which in other words means that the link is "<em>active</em>" for the Navigation System (but it can still be in the Enabled or Disabled state).</div>
<p class="mce-root">Unfortunately (at least for the current version of the Engine), these are not visible in the Editor, which means that the <strong><em>Start</em></strong> and <strong><em>End</em></strong> positions need to be set manually.</p>
<p>However, let's go through the settings of a <em>Smart Link</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/958f72d7-f063-49ac-ac10-8c36b41901cc.png" style="width:27.25em;height:14.83em;"/></p>
<ul>
<li><strong><em>Enabled Area Class</em></strong>: This is the <em>Nav Area</em> that the Link assumes when it is enabled. The default is <em>NavArea_Default</em>.</li>
<li><strong><em>Disabled Area Class</em></strong>: This is the <em>Nav Area</em> that the Link assumes when it is disabled. This means that, when the Link is disabled, it can still be traversed if a crossable area is assigned (e.g. when the link is disabled, we might want to have a very high cost to cross, but we still want it to be possible to traverse it. Of course, the default is <em>NavArea_Default</em>, which means that it is not crossable.</li>
</ul>
<ul>
<li><strong><em>Link Relative Start</em></strong>: This represents the Start point of the link, relative to the position of its <em>Nav Link Proxy</em>.</li>
<li><strong><em>Link Relative End</em></strong>: This represents the End point of the link, relative to the position of its <em>Nav Link Proxy</em>.</li>
<li><strong><em>Link Direction</em></strong>: This specifies in which direction the link works. The possible options are as follows:
<ul>
<li><strong><em>Both Ways</em></strong>: The link is bidirectional (remember that the AI needs to be equipped to traverse the Link in both directions; e.g. over a ledge, the agent needs to be able to fall from it (one direction of the link) and jump (the other direction of the link).</li>
<li><strong><em>Left to Right</em></strong>: The link is only crossable from the Left end to the Right one (the agent still needs to have the ability to go in that link direction).</li>
<li><strong><em>Right to Left</em></strong>: The link is only crossable from the Right end to the Left one (the agent still needs to have the ability to go in that link direction).</li>
</ul>
</li>
</ul>
<p>Although the options of this parameter label the end points of the link as <em>Left</em> and <em>Right</em>, they refer to the <em>Start</em> and <em>End</em> point of the link. Alternatively (this may be better since the link can be bidirectional), <em>Link Relative Start</em> and <em>Link Relative End</em> refer to <em>Left</em> and <em>Right</em>.</p>
<ul>
<li><strong><em>Link Enabled</em></strong>: This is a boolean variable that determines whether the <em>Smart Link</em> is enabled. This value can be changed at runtime, and the link can "<em>notify</em>" surrounding agents/actors that are interested in such information (see later for more info). The default value is true.</li>
<li><strong><em>Smart Link Is Relevant</em></strong>: This is a boolean variable that determines whether the <em>Smart Link</em> is actually "<em>active</em>", that is, if it is relevant or whether we should ignore it. The default value is false.</li>
</ul>
<p>These are the main settings regarding a Smart Link.</p>
<p>It's worth mentioning that <em>Smart Links</em> can actually do more than just connect Nav Meshes. They have a series of functions to handle agents that are traversing the Link. For instance, by opening the <kbd>NavLinkProxy.h</kbd> file, we can find the following functions:</p>
<pre>  /** called when agent reaches smart link during path following, use ResumePathFollowing() to give control back */<br/>  UFUNCTION(BlueprintImplementableEvent)<br/>  void ReceiveSmartLinkReached(AActor* Agent, const FVector&amp; Destination);<br/><br/>  /** resume normal path following */<br/>  UFUNCTION(BlueprintCallable, Category="AI|Navigation")<br/>  void ResumePathFollowing(AActor* Agent);<br/><br/>  /** check if smart link is enabled */<br/>  UFUNCTION(BlueprintCallable, Category="AI|Navigation")<br/>  bool IsSmartLinkEnabled() const;<br/><br/>  /** change state of smart link */<br/>  UFUNCTION(BlueprintCallable, Category="AI|Navigation")<br/>  void SetSmartLinkEnabled(bool bEnabled);<br/><br/>  /** check if any agent is moving through smart link right now */<br/>  UFUNCTION(BlueprintCallable, Category="AI|Navigation")<br/>  bool HasMovingAgents() const;</pre>
<p>Unfortunately, these functions are outside the scope of this book, but I invite you to read the code to learn more about them.</p>
<p>Previously, we mentioned that the <em>Smart Link</em> can broadcast information regarding its status change at runtime to nearby agent/actors. You can change how the <em>Smart Link</em> broadcasts this information with the <em><strong>Broadcast</strong></em> settings, which are just below the <em>Smart Link</em> ones:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/36555d1b-3e0c-4ec7-a7f8-c4e01c536479.png" style="width:20.25em;height:11.83em;"/></p>
<p>These settings are quite intuitive, but let's go through them quickly:</p>
<ul>
<li><strong><em>Notify when Enabled</em></strong>: If true, the Link will notify agents/actors when it gets <em>Enabled</em>.</li>
<li><strong><em>Notify when Disabled</em></strong>: If true, the Link will notify agents/actors when it gets <em>Disabled</em>.</li>
<li><strong><em>Broadcast Radius</em></strong>: This specifies how far the broadcast should go. Every agent that is outside this radius will not get notified about the change of the Link.</li>
<li><strong><em>Broadcast Interval</em></strong>: This specifies after how long the Link should repeat the broadcast. If the value is zero, the broadcast is repeated only once.</li>
<li><strong><em>Broadcast Channel</em></strong>: This is the trace channel for broadcasting the change.</li>
</ul>
<p>This concludes our discussion on <strong><em>Smart Links</em></strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other settings of the Nav Link Proxy</h1>
                
            
            
                
<p>Finally, it's just worth mentioning that the <strong><em>Nav Link Proxy</em></strong> can create an <em>Obstacle Box</em> when the <em>Nav Mesh</em> is generated. You can find these settings in the <em>Details Panel</em> of the <strong><em>Nav Link Proxy</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ec16dca6-906f-46f9-9647-3ef6462bfb5d.png" style="width:26.42em;height:9.33em;"/></p>
<p>These settings allow you to decide whether the <em>Obstacle Box</em> is active/used, its <em>dimension/extent</em> and its offset, as well as the type of <em>Nav Area</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the Nav Link Proxy</h1>
                
            
            
                
<p>If you are wondering whether it is possible to extend <em>Links</em> or include them within more complex actors, the answer is "<em>Of course, Yes! But you can only extend them in C++</em>".</p>
<p>Since this book cannot cover everything, we don't have the time to deal with this in detail. However, some of the reasons why you may want to extend the <strong><em>Nav Link Proxy</em></strong> are to have a better control over the characters that enter your Link. For instance, you might want to have a <em>Jump Pad</em> that pushes the character through the Link. This isn't very complicated to do, and if you search for this online, you will find plenty of tutorials on how to do this using <em>Navigation Links</em>.</p>
<p>Just keep in mind that to be a good AI programmer in Unreal, you will eventually need to master this part of <em>Nav Links</em> as well, but for now, we are covering enough.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigation Avoidance</h1>
                
            
            
                
<p>Navigation Avoidance is a very broad topic, and Unreal has some subsystems that do this for us. Therefore, we will deal with this topic in <a href="c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml" target="_blank">Chapter 6</a><em>, Crowds</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigation Filtering</h1>
                
            
            
                
<p>We don't want to find a certain path in the same way every time. Imagine that our AI agent uses a power up and it is able to move through the jungle twice as fast. In this case, the Navigation System is not aware of this change, nor is it a permanent change to the shape or weights of the <em>Nav Mesh</em>.</p>
<p><strong><em>Nav Filtering</em></strong> allows us to define specific rules on how to perform the pathfind for that specific period of time. You may have noticed that every time we perform a navigation task, either in Blueprint or C++, there is an optional parameter for inserting a <strong><em>Nav Filter</em></strong>. Here are some examples of Blueprint nodes (the same goes for C++ functions) that have this optional filter parameter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/76884c87-a640-4eef-8342-95d9c87ce979.png" style="width:55.83em;height:39.58em;"/></p>
<p>Even the <strong><em>Move To</em></strong> nodes of <strong><em>Behavior Trees</em></strong> have the <strong><em>Navigation Filter</em></strong> option:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a3c66db1-5dfc-4681-9faf-d233bf226f27.png" style="width:29.58em;height:25.75em;"/></p>
<p>Of course, once you have inserted a filter, the pathfinding will behave accordingly. This means that using <strong><em>Nav Filters</em></strong> is pretty straightforward. However, how can we create <strong><em>Nav Filters</em></strong>? Let's find out, both in Blueprint and C++.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Navigation Filter in Blueprint</h1>
                
            
            
                
<p>Previously in this chapter, we created a Jungle area in Blueprint. Thus, this seems like a good example that we can use to create a <strong><em>Nav Filter</em></strong> that allows the AI Agent to travel through the Jungle faster – even faster than it takes to traverse the <em>Default Area</em> of the <em>Nav Mesh</em>. Let's imagine that the AI Agent has some power or ability that allows it to move faster in Jungle type areas in the level.</p>
<p>To create a <strong><em>Nav Filter</em></strong> in Blueprint, we need to start creating a new Blueprint that inherits from <strong><em>NavigationQueryFilter</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6ab2ad92-2ebe-4288-ac0a-c44987dcabc0.png" style="width:32.17em;height:42.25em;"/></p>
<p>By convention, the name of the class should start with "<em>NavFilter_</em>". We will rename it to <strong><em>NavFilter_BPFastJungle</em></strong> (I added BP so that I can remember that I created this with Blueprint, since we are repeating the same task in Blueprint and in C++). This is what it should look like in the <em>Content Browser</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0e66b0b6-c13f-426c-ae20-89eec9929602.png" style="width:28.42em;height:21.50em;"/></p>
<p>Once we open the Blueprint, we will find its options in the <em>Details</em> panel:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/72deec62-e9a3-4d06-8959-56d80ddcd367.png" style="width:27.67em;height:11.58em;"/></p>
<p>As you can see, there is an <strong><em>Array of Areas</em></strong> and two sets for <em>Including and Excluding (Nav) Flags</em>. Unfortunately, we didn't cover <em>Nav Flags</em> since they are out of the scope of this book, and they can only be assigned in C++ at the time of writing. However, the <strong><em>Array of Areas</em></strong> is quite interesting. Let's add a new Area and use our <strong><em>NavArea_BPJungle</em></strong> for the <strong><em>Area Class</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2de8dfeb-c213-4a39-80bb-41cd53eaad36.png" style="width:30.92em;height:18.58em;"/></p>
<p>Now, we can override the <strong><em>Travel Cost</em></strong> and the <strong><em>Entering Cost</em></strong> for the Jungle Area, which will be used instead of the costs we specified in the Area Class if this filter is used. Remember to tick the checkbox next to the option's name to enable editing. For example, we could have a <strong><em>Travel Cost</em></strong> of <strong><em>0.6</em></strong> (since we can move through the Jungle quickly without any issues) and an <strong><em>Entering Cost</em></strong> of <strong><em>zero</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4a5f47e4-1cb1-4140-a704-550b50bf9a2e.png" style="width:31.33em;height:18.92em;"/></p>
<p>Now, we are all good to good. The filter is ready for if you prefer traveling in the Jungle!</p>
<div><strong>Changing the Travel Cost for a</strong> <strong>Nav Area DOESN'T make the AI agent go faster or slower in that area</strong>, it just makes pathfinding prefer that path over another. The implementation that the agent becomes faster in that area is left out from the <em>Navigation System</em>, and so you will need to implement that when the AI character is in the jungle.</div>
<p>If you also followed the C++ part for the <em>Nav Areas</em>, then you should also have the Desert area in your project. As an optional step, we can add a second area to the filter. Imagine that by using the power-up or ability to move faster in the Jungle, our character has become very sensitive to the sun and very prone to sunburns, which decreases their health significantly. As a result, we can set a higher cost for the <em>Desert Area</em> if this filter is used. Just add another Area, and set the <strong><em>Area Class</em></strong> to <strong><em>NavArea_Desert</em></strong>. Then, override the costs; for instance, a <strong><em>Travel Cost</em></strong> of <strong><em>2.5</em></strong> and an <strong><em>Entering Cost</em></strong> of <strong><em>10</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/403f1ba4-5fc5-4d2c-bcef-50d932d1905f.png" style="width:33.17em;height:28.33em;"/></p>
<p>Once you have finished editing the settings, save the Blueprint. From now on, you will be able to use this filter within the <em>Navigation System</em>. This concludes how to create a <strong><em>Nav Filter</em></strong> in Blueprint.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Navigation Filter in C++</h1>
                
            
            
                
<p>In a similar way to Blueprint, we can create a C++ <strong><em>Nav Filter</em></strong>. This time, we can create a filter that slightly lowers the cost for the Desert Area. You can use this filter on certain animals that live in the desert and will be less prone to its effects. </p>
<p>To start, we need to create a new C++ class that inherits from <strong><em>NavigationQueryFilter</em></strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5fabbbab-98ea-4c47-9577-88f07d3c7fb3.png" style="width:70.75em;height:42.75em;"/></p>
<p>By convention, the name of the class should start with "<em>NavFilter_</em>". Hence, we will rename it to <strong><em>NavFilter_Desert Animal</em></strong> and place it in "<strong><em>Chapter3/Navigation</em></strong>":</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/17195ad5-bddc-4e6c-917d-39058ad8f501.png" style="width:75.58em;height:45.67em;"/></p>
<p>To set its properties, we need to create a default constructor. Write the following in the header (<kbd>.h</kbd>) file:</p>
<pre>#include "CoreMinimal.h"<br/>#include "NavFilters/NavigationQueryFilter.h"<br/>#include "NavFilter_DesertAnimal.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class UNREALAIBOOK_API UNavFilter_DesertAnimal : public UNavigationQueryFilter<br/>{<br/>  GENERATED_BODY()<br/><br/><strong>  UNavFilter_DesertAnimal();</strong><br/>};</pre>
<p>For the implementation (<kbd>.cpp</kbd> file), we need to do a bit more work. First of all, we need to have access to the <em>Nav Area</em> that we need, which, in this case, is the Desert. Let's add the following <kbd>#include</kbd> statement:</p>
<pre>#include "NavArea_Desert.h"</pre>
<p>Then, in the constructor, we need to create a <strong><em>FNavigationFilterArea</em></strong>, which is a class that contains all the options for filtering a specific class. In our example, we can store this new <em>Filter Area</em> inside a variable named <kbd>Desert</kbd>:</p>
<pre>UNavFilter_DesertAnimal::UNavFilter_DesertAnimal() {<br/><br/><strong>  //Create the Navigation Filter Area</strong><br/><strong>  FNavigationFilterArea Desert = FNavigationFilterArea();</strong><br/><br/><em>  // [REST OF THE CODE]</em><br/>}</pre>
<p>Next, we need to fill the <kbd>Desert</kbd> variable with the options that we want to override for that class, including which <strong><em>Nav Area</em></strong> we are modifying:</p>
<pre>UNavFilter_DesertAnimal::UNavFilter_DesertAnimal() {<br/><br/><em>  // [PREVIOUS CODE]</em><br/><br/><strong> //Set its parameters</strong><br/><strong>  Desert.AreaClass = UNavArea_Desert::StaticClass();</strong><br/><br/><strong>  Desert.bOverrideEnteringCost = true;</strong><br/><strong>  Desert.EnteringCostOverride = 0.f;</strong><br/><br/><strong>  Desert.bOverrideTravelCost = true;</strong><br/><strong>  Desert.TravelCostOverride = 0.8f;</strong><br/><br/><em>  // [REST OF THE CODE]</em><br/>}</pre>
<p>Finally, we need to add this <em>Filter Area</em> in the <strong><em>Areas</em></strong> array:</p>
<pre>UNavFilter_DesertAnimal::UNavFilter_DesertAnimal() {<br/><br/><em>  // [PREVIOUS CODE]</em><br/><br/><strong>  //Add it to the the Array of Areas for the Filter.</strong><br/><strong>  Areas.Add(Desert);</strong><br/>}</pre>
<p>For your convenience, here is the full <kbd>.cpp</kbd> file:</p>
<pre>#include "NavFilter_DesertAnimal.h"<br/>#include "NavArea_Desert.h"<br/><br/>UNavFilter_DesertAnimal::UNavFilter_DesertAnimal() {<br/><br/>  //Create the Navigation Filter Area<br/>  FNavigationFilterArea Desert = FNavigationFilterArea();<br/><br/>  //Set its parameters<br/>  Desert.AreaClass = UNavArea_Desert::StaticClass();<br/><br/>  Desert.bOverrideEnteringCost = true;<br/>  Desert.EnteringCostOverride = 0.f;<br/><br/>  Desert.bOverrideTravelCost = true;<br/>  Desert.TravelCostOverride = 0.8f;<br/><br/>  //Add it to the the Array of Areas for the Filter.<br/>  Areas.Add(Desert);<br/>}</pre>
<p>Compile this code and you will be able to use this filter next time you need to use the <em>Navigation System</em>. This concludes our discussion on <em>Navigation Filters</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overriding the Navigation System</h1>
                
            
            
                
<p>From the <em>Mode Panel</em>, you are able to drag into the level a special actor called <strong><em>Nav System Config Override</em></strong>. </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e076b9b0-72f7-4027-803a-1d200c5c974d.png" style="width:25.33em;height:11.00em;"/></p>
<p>This actor allows you to override the built-in <em>Navigation System</em> by using another one. Of course, you will have to develop it first, and this would need a lot of effort.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/14df0108-48ef-4609-8f2c-0008f216d03d.png" style="width:39.00em;height:31.25em;"/></p>
<p>Reasons why you should substitute the default Navigation System (or maybe used along with another one) is mainly due to overcome limitations. What about air-units; how can they do a 3D Pathfinding? How about spiders who have a surface pathfinding?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at how we can set up the <em>Navigation System </em>so that our AI character can move around the map. In particular, we have learned how we can shape the <em>Nav Mesh</em> with <em>Modifier Volumes</em>, <em>Nav Link Proxies</em>, and <em>NavMesh Areas</em>.</p>
<p>As a result, our AI agents can smoothly navigate through the map, efficiently finding a path between two points that is optimized based on their capabilities (e.g. using <em>Navigation Filters</em>) by respecting the varies types of "<em>terrains</em>" of the map (e.g. using <em>Navigation Areas</em>). Moreover, they can fall over ledges or jump between platforms (e.g. by using <em>Nav Link Proxies</em> and a bit of coding for jumping).</p>
<p>In the next chapter, we are going to learn about a more advanced AI feature in the Unreal Framework, that is, the <em>Environment Querying System</em>, which allows the agent to "<em>query</em>" the environment so that they can find locations (or actors) with specific requisites.</p>


            

            
        
    </body></html>