["```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class LockedOnState : StateMachineBehaviour { \n\n    GameObject player; \n    Tower tower; \n\n   // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state \n    override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n        player = GameObject.FindWithTag(\"Player\"); \n        tower = animator.gameObject.GetComponent<Tower>(); \n        tower.LockedOn = true; \n    } \n\n     //OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks \n  override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n        animator.gameObject.transform.LookAt(player.transform); \n  } \n\n  // OnStateExit is called when a transition ends and the state machine finishes evaluating this state \n    override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n        animator.gameObject.transform.rotation = Quaternion.identity; \n        tower.LockedOn = false; \n    } \n} \n```", "```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class Tower : MonoBehaviour { \n    [SerializeField] \n    private Animator animator; \n\n    [SerializeField] \n    private float fireSpeed = 3f; \n    private float fireCounter = 0f; \n    private bool canFire = true; \n\n    [SerializeField] \n    private Transform muzzle; \n    [SerializeField] \n    private GameObject projectile; \n\n    private bool isLockedOn = false; \n\n    public bool LockedOn { \n        get { return isLockedOn; } \n        set { isLockedOn = value; } \n    } \n```", "```py\nprivate void Update() { \n        if (LockedOn && canFire) { \n            StartCoroutine(Fire()); \n        } \n    } \n\n    private void OnTriggerEnter(Collider other) { \n        if (other.tag == \"Player\") { \n            animator.SetBool(\"TankInRange\", true); \n        } \n    } \n\n    private void OnTriggerExit(Collider other) { \n        if (other.tag == \"Player\") { \n            animator.SetBool(\"TankInRange\", false); \n        } \n    } \n\n    private void FireProjectile() { \n        GameObject bullet = Instantiate(projectile, muzzle.position, muzzle.rotation) as GameObject; \n        bullet.GetComponent<Rigidbody>().AddForce(muzzle.forward * 300); \n    } \n\n    private IEnumerator Fire() { \n        canFire = false; \n        FireProjectile(); \n        while (fireCounter < fireSpeed) { \n            fireCounter += Time.deltaTime; \n            yield return null; \n        } \n        canFire = true; \n        fireCounter = 0f; \n    } \n}\n```", "```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class Projectile : MonoBehaviour { \n\n    [SerializeField] \n    private GameObject explosionPrefab; \n\n  void Start () {  } \n\n    private void OnTriggerEnter(Collider other) { \n        if (other.tag == \"Player\" || other.tag == \"Environment\") { \n            if (explosionPrefab == null) { \n                return; \n            } \n            GameObject explosion = Instantiate(explosionPrefab, transform.position, Quaternion.identity) as GameObject; \n            Destroy(this.gameObject);             \n        } \n    } \n}\n```", "```py\n// OnStateExit is called when a transition ends and the state machine finishes evaluating this state \n    override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { \n        Destroy(animator.gameObject, 0.1f); \n    } \n```", "```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class Tank : MonoBehaviour { \n    [SerializeField] \n    private Transform goal; \n    private NavMeshAgent agent; \n    [SerializeField] \n    private float speedBoostDuration = 3; \n    [SerializeField] \n    private ParticleSystem boostParticleSystem; \n    [SerializeField] \n    private float shieldDuration = 3f; \n    [SerializeField] \n    private GameObject shield; \n\n    private float regularSpeed = 3.5f; \n    private float boostedSpeed = 7.0f; \n    private bool canBoost = true; \n    private bool canShield = true; \n```", "```py\n    private bool hasShield = false; \nprivate void Start() { \n        agent = GetComponent<NavMeshAgent>(); \n        agent.SetDestination(goal.position); \n    } \n\n    private void Update() { \n        if (Input.GetKeyDown(KeyCode.B)) { \n            if (canBoost) { \n                StartCoroutine(Boost()); \n            } \n        } \n        if (Input.GetKeyDown(KeyCode.S)) { \n            if (canShield) { \n                StartCoroutine(Shield()); \n            } \n        } \n    } \n```", "```py\nprivate IEnumerator Shield() { \n        canShield = false; \n        shield.SetActive(true); \n        float shieldCounter = 0f; \n        while (shieldCounter < shieldDuration) { \n            shieldCounter += Time.deltaTime; \n            yield return null; \n        } \n        canShield = true; \n        shield.SetActive(false); \n    } \n\n    private IEnumerator Boost() { \n        canBoost = false; \n        agent.speed = boostedSpeed; \n        boostParticleSystem.Play(); \n        float boostCounter = 0f; \n        while (boostCounter < speedBoostDuration) { \n            boostCounter += Time.deltaTime; \n            yield return null; \n        } \n        canBoost = true; \n        boostParticleSystem.Pause(); \n        agent.speed = regularSpeed; \n    }\n```", "```py\nusing UnityEngine; \nusing System.Collections; \n\npublic class HorizontalCam : MonoBehaviour { \n    [SerializeField] \n    private Transform target; \n\n    private Vector3 targetPositon; \n\n    private void Update() { \n        targetPositon = transform.position; \n        targetPositon.z = target.transform.position.z; \n        transform.position = Vector3.Lerp(transform.position, targetPositon, Time.deltaTime); \n    } \n} \n```"]