- en: '*Chapter 3*: Diving into Core Nodes and Data in n8n'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever been to a construction site just as they are starting to build
    a home, it can sometimes be challenging to envision what the final home will be
    like, and the future owners are probably very excited to get into the home and
    make it their own. If they had their way, they would probably skip this part of
    the home build and focus on all the details such as paint color, room layout,
    and furniture placement.
  prefs: []
  type: TYPE_NORMAL
- en: But if all home builders were to do this, none of their homes would last very
    long. They would not have a proper foundation upon which to sit, and the frame
    of the home would quickly fail.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing can be said for learning to design computer programs. If a new
    developer does not learn the foundational parts and concepts of a programming
    system, then the application build goes very slowly and tends to be of poor quality.
    But unlike with a traditional computer programmer, it is not necessary to understand
    complex syntax or coding structure to become proficient at developing with a no-code
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to properly understand the core nodes and how data is structured
    in n8n. Without these foundational concepts, you will not get very far with n8n.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the data structure in n8n
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function node—Custom JavaScript in workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Request node—Talk to any **application programming interface** (**API**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webhook node — Handling real-time events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays and **JavaScript Object Notation** (**JSON**) objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will have learned how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use n8n's data structure to manipulate and transform data inside workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JavaScript inside your low-code workflows to unlock custom functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `HTTP Request` node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle real-time events using the `Webhook` node and trigger workflows based
    on this data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with arrays and JSON objects inside n8n, understand when to use what kind
    of data format, and transform data inside the workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have installed n8n
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: n8n should be running, and the Editor **user interface** (**UI**) is open
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have access to the GitHub repository, which can be found here: [https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the data structure in n8n
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I love traveling to different countries and experiencing life from a different
    perspective. Different cultures and customs fascinate me.
  prefs: []
  type: TYPE_NORMAL
- en: But unfortunately, I often find myself running into trouble because I am only
    fluent in a single language. Without having a language in common, it is easy to
    misunderstand what someone else is trying to communicate to me.
  prefs: []
  type: TYPE_NORMAL
- en: n8n also has its version of a language that it uses to communicate between nodes.
    This "language" is known as JSON and is a simple text format that is easy for
    both computers and humans to read. Using JSON, n8n can transfer both text and
    non-text (known as **binary**) information.
  prefs: []
  type: TYPE_NORMAL
- en: The developers at n8n designed each node in the workflow to receive and output
    data in this specific JSON format. This standard data structure allows n8n to
    chain these nodes together in infinite workflow combinations to produce a wide
    variety of different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to have a strong understanding of JSON in general and, specifically,
    how n8n uses JSON. This section talks about how JSON represents information and
    two different ways of grouping it—objects and arrays. We also delve into how n8n
    uses JSON to communicate inside a workflow and store the two main types of data
    inside a workflow—JSON and binary data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you will find a sample of JSON-formatted information.
    This example describes a 2021 red car with automatic transmission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: JSON syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few syntax items to cover, making it easier to understand these
    JSON files. These items can be broken down into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Values**—Data or information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key-value pairs**—Name of the information and the information itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects**—Groups of key-value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrays**—Groups of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be learning more about these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A value is a piece of data represented in JSON. A value can be:'
  prefs: []
  type: TYPE_NORMAL
- en: A string (a series of alphanumeric symbols)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number (standard numeric value)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JSON object (see the *Objects* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array (see the *Arrays* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean (`true` or `false` value)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-value pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first piece of JSON information to understand is key-value pairs. These
    are made of a field name in double quotes and a value separated by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `"fruit": "apple"` is a key-value pair, with `"fruit"` being the
    key and `"apple"` being the value.'
  prefs: []
  type: TYPE_NORMAL
- en: You can reference a key in n8n to retrieve the value that is paired with it.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An object is a group of key-pair values enclosed within curly brackets and
    separated by a comma. For example, `{"name": "Jill", "age": 27, "certified": true}`
    is an object with three keys (`name`, `age`, and `certified`), and each key has
    a value (`Jill`, `27`, and `true`).'
  prefs: []
  type: TYPE_NORMAL
- en: Their key can reference values in the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take this a step further, let''s imagine we have the following JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `user1.name` would be `Jill` and `user2.name` would be `James`.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An array is a group of values enclosed within square brackets and separated
    by a comma. For example, `[ "zero", "one", "two" ]` is an array with three values.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are similar to objects, except they do not have keys, so their index
    references the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'An index is the position of a value in the array. The index value starts with
    zero (0) and increases by one for each portion in the array. In our example, these
    are the indexes of the array and their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`—`"zero"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1—"one"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2—"two"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: n8n JSON structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON that is passed between nodes in n8n is a particular structure. It is
    made up of an array of at least one object.
  prefs: []
  type: TYPE_NORMAL
- en: That object has either one or two sub-objects inside it. The two object keys
    are `json` and `binary`.
  prefs: []
  type: TYPE_NORMAL
- en: The json object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `json` object is a required object. Inside it is all of the JSON data that
    you will see as the result of a node execution.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the `json` object are flexible and can be a mixture of other
    objects, arrays, and key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a set note that sets the key `colour` to a `red` value,
    the node output will appear like this in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But when this information is stored in the n8n JSON format, it is passed between
    nodes, looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This way, the nodes understand that the information is meant to be for them
    and identify the information as test information. There is also an optional binary
    section to go along with the json section, and that will be covered a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the format in which data is passed between
    nodes. It represents the framework for the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – n8n data structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – n8n data structure
  prefs: []
  type: TYPE_NORMAL
- en: The entire set of data that is passed between nodes is built into a JSON array.
    Inside that array, there are two JSON objects—one called `JSON` and another called
    `Binary`. The `JSON` object contains key-value pairs representing text data. Meanwhile,
    the `Binary` object contains binary information (think of this as a file). Along
    with the actual data of the `Binary` object, there is some metadata such as `mimeType`
    (this is the type of file the data contains), `fileExtension`, and `fileName`.
  prefs: []
  type: TYPE_NORMAL
- en: The binary object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second object in the n8n JSON data structure is the `binary` object. The
    `binary` object is an optional component since not every JSON dataset contains
    a binary element. But when it is provided, this object contains information that
    generally represents a file in a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you are to include this object in your n8n JSON data, it has a particular
    structure. Inside the `binary` object is a key named whatever you wish (for our
    example, we will call it `binaryKeyName`). The value associated with this key
    is another object. This object is made up of up to four key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` (required)—Base64-encoded binary data or unique data ID reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mimeType` (optional)—The type of data stored in the `data` value based on
    standard mime types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileExtension` (optional)—The extension that the file representing the information
    in the `data` value has'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileName` (optional)—The name of the file describing the data in the `data`
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path` (optional) - The location of the file on the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `binary` object is set in the n8n JSON data, you will see an extra
    `binary` object, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Binary data in n8n Editor UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Binary data in n8n Editor UI
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to take a look at the `Function` node. It
    allows you to create custom code in JavaScript in case there is no node to perform
    the exact action you need. This is where understanding the n8n data structure
    becomes extremely important for manipulating information using JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Function node – Custom JavaScript in workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the perfect n8n node for the action you want to complete simply
    doesn''t exist. This makes sense because there are an infinite number of different
    actions that could take place. This is why n8n created the `Function` node: so
    that we would have a way of creating our own custom actions, and we are going
    to learn how to do that next.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Function` node is the most versatile node in the n8n toolbox. It can execute
    JavaScript to manipulate data output from other nodes and then output it in the
    standard n8n data structure. You can see a screenshot representation of it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Function node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Function node
  prefs: []
  type: TYPE_NORMAL
- en: But the flexibility of the `Function` node does require you to be able to use
    some JavaScript. Unlike many other nodes with several options and parameters to
    pick and choose from, the `Function` node only has a single parameter—the JavaScript
    code field. It is in this field that you will do all of your work.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code field contains, surprisingly, JavaScript. You will use this
    programming language to do all data manipulations within the `Function` node.
    While you don't need to be a JavaScript expert, there is some value in getting
    to know this language better. For what we will be talking about in this book,
    a basic understanding of JavaScript will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you open up the JavaScript code field in a new `Function` node,
    you will notice that there are already several lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This gives you an excellent example of how the `Function` node works. This script
    assigns the value of `1` to the `myNewField` key in every item in the JSON object
    of the n8n data structure. It then writes to the web browser console that the
    action is done. Finally, it outputs the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute this `Function` node, you will get the following output as a
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, just how did this work? It worked because of the `items` array, which we
    are going to be covering in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The items array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to this code is the `items` array. This stores all of the information
    in the n8n data structure passed to the `Function` node from the previous node.
    The value in the square brackets represents the index of the JSON object in the
    `items` array with which you wish to work.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic `items` array only has a single object represented by the zero
    (0) index number, but it is possible to have several more objects in the `items`
    array, and you can access each of these objects using the array index number associated
    with that object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we are going to talk a bit about referencing different
    parts of the `items` array using dot notation, along with how to output the information
    once we have transformed it. Plus, we will also cover how to access data in different
    nodes other than the one that immediately preceded the node you are in.
  prefs: []
  type: TYPE_NORMAL
- en: Dot notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have chosen the proper object within the `items` array by indicating
    its index number, you need to determine if you will work with the JSON or the
    binary object. You can do this by using what is referred to as `.`). In *line
    1* of our code, the dot between `items[0]` and `json` tells n8n to reference the
    `json` object in the `items` array with the `0` index.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you will be working in the `json` object, but there are situations
    where you would use the `binary` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the dot notation used to reference different parts of
    the `items` array, refer to the following table with the dot notation name on
    the left and the piece of the JSON it is referencing on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_3.05_B17493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Outputting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with functions in other programming languages, the `Function` node needs
    to indicate which information gets passed to the rest of the program. This is
    accomplished by the second line of code, which returns the newly updated `items`
    array to the next node.
  prefs: []
  type: TYPE_NORMAL
- en: While it is a best practice to modify the value of the `items` array and pass
    it on to the next node, this is technically not required, and you can return any
    array that follows the proper n8n data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Data from other nodes (the $items method)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to reference the output of a node that is not directly
    connected to the `Function` node that you are working with but has been executed
    before your node. In this instance, referencing the `items` array will not give
    you the correct information.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue, you can use the `$items` method. This method allows you
    to access all of the data in a node as long as that node is before the present
    node you are working in and has already been executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this in action. Let''s build the following workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Basic workflow with three Function nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Basic workflow with three Function nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a default `Function` node, the output of the `myFunction` node
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Reset` node then deletes everything that it receives and sets the output
    to empty, as indicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the JavaScript in the `Function` node to output the information from
    the previous node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you will see, we end up with the same results as we have from the `Reset`
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the `$items` method to pull the data from the `myFunction`
    node, essentially skipping the `Reset` node. Change the JavaScript in the `Function`
    node to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you run the workflow now, you will see that the output of the `Function`
    node matches the output of the `myFunction` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `items` array, you can specify which item in the `$items` method
    to reference by setting the index in square brackets. Along with using the array
    index, you can also use dot notation to reference deeper into the array and objects.
    For example, this is a perfectly acceptable way of accessing specific information
    from a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the `Function` node uses JavaScript, you have all of the power of JavaScript
    at your disposal for manipulating data. A deep dive into JavaScript and its capabilities
    is outside of the scope of this book, but there are some useful commands that
    we have put together to give you a head start.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For these examples, we will assume that we have a variable called `fullName`,
    and the value assigned to it is `Jim Nasium`. Have a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_3.01_B17493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mathematics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript also has potent mathematical abilities. Here are some practical
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_3.02_B17493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you should now realize, the `Function` node is extremely powerful. We have
    learned how to reference data both inside the node and from other nodes, manipulate
    both strings and numbers, and output the data so that it can be used by other
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the power of the `Function` node
    and some ideas of what can be done with the data, let's look at getting some data
    from remote systems via their API using the `HTTP Request` node.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Request node – Talk to any API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer systems are fantastic for storing and processing massive amounts of
    data, but computer users and developers very quickly discovered that there was
    no actual standard for allowing these computers to share information.
  prefs: []
  type: TYPE_NORMAL
- en: Someone had the bright idea to use the new web standard to create a way for
    these systems to communicate. They would use standard request methods to retrieve,
    add, delete, or update information on remote computers. Along with these functions,
    they would even provide the ability to secure these connections using various
    methods to ensure only authorized individuals could get to the data.
  prefs: []
  type: TYPE_NORMAL
- en: This system setup is collectively referred to as a web API, which is one of
    the most popular ways of working with remote data today. There are thousands of
    different APIs available, providing access to an extensive range of data and information.
  prefs: []
  type: TYPE_NORMAL
- en: Since one of the primary functions of n8n is to connect different systems to
    share data, it only makes sense to talk to these web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to learn how APIs work, how they are formatted,
    ways that data can be passed through APIs, and primary methods supported by APIs,
    along with the response codes that they return. Finally, we will perform some
    basic API calls, as well as look at how to secure these calls.
  prefs: []
  type: TYPE_NORMAL
- en: Web API 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we look at the `HTTP Request` node, let's first do a quick overview of
    how APIs work to better understand how they allow systems to interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs run on the same technology as most of the websites on the internet,
    but instead of dishing up your favorite web pages or cat videos, web servers configured
    to run APIs allow remote systems to make a request and then reply to the request
    with data based on the input received earlier. The data that is sent between the
    systems is often formatted in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the most basic API in action, let''s take a look at the Random User
    API. Open up your web browser, and in the address bar, enter [https://randomuser.me/api/](https://randomuser.me/api/).
    When you press the *Enter* key, you will see a bunch of text similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While this may look like a lot of gibberish, you will see a few characters that
    look familiar from our `Function` node chapter if you look closely. What we've
    come across is compressed or unformatted JSON!
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an API URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access an API, one of the essential items you will need is a **Uniform Resource
    Locator** (**URL**). It is vital to understand the different parts of a URL because
    you or your system will often be required to build the URL yourself so that you
    can work with your desired information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a fictional API URL, dissect the different parts of the URL,
    and determine their purpose. For this exercise, we are going to use the following
    URL: [https://api.example.com/v3/computers?type=laptop&ram=32&hdd=1024](https://api.example.com/v3/computers?type=laptop&ram=32&hdd=1024)'
  prefs: []
  type: TYPE_NORMAL
- en: The parts of the API URL are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example, this is the https:// portion of the URL. This will generally
    be either http:// or https://. This is important because if the protocol is http://,
    the data is not encrypted between the API server and the client. Anyone can see
    what information is passing between these two computers, including passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Always make sure that the protocol is https://.
  prefs: []
  type: TYPE_NORMAL
- en: Base URL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The base URL in our example is [api.example.com](http://api.example.com). It
    is sometimes referred to as the **hostname**, **domain name**, or **Domain Name
    System (DNS) name**. These all refer to the same thing. The base URL is generally
    the server that is hosting the API.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our example, the endpoint is /v3/computers. It is sometimes referred to
    as the API path. The endpoint is either static (that is, it stays the same) or
    dynamic (that is, it changes based on the information that is being requested).
    While there is no absolute standard for how endpoints are used, there are some
    common practices.
  prefs: []
  type: TYPE_NORMAL
- en: From our example, the /v3 portion tells us that this is version 3 of the API,
    and the /computers portion tells us that we can expect one or more records to
    be returned by this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example has three query parameters—`type=laptop`, `ram=32`, and `hdd=1024`.
    Two delimiters identify the query parameters. The `?` delimiter separates the
    query parameters from the rest of the URL, and the `&` delimiter separates each
    query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Much as with JSON key-value pairs, the key is the portion before the equals
    sign (`=`), and the value is the portion after the equals sign (`=`).
  prefs: []
  type: TYPE_NORMAL
- en: Other parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While using specific endpoints and query parameters are the most common ways
    of controlling the type of information that is passed between the API client and
    server, other parameters can further modify the information flow.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Headers are typically used to provide metadata about the API request. They often
    give information on the type of data being transmitted, security tokens, or server
    information.
  prefs: []
  type: TYPE_NORMAL
- en: These are generally transmitted in a key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: Body parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The body of a request typically carries information or data required to complete
    the request or is supplied by the server based on the request made by the client.
  prefs: []
  type: TYPE_NORMAL
- en: This information is generally sent in a key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different ways of interacting with APIs, each producing a different
    result on the server hosting the API and the client requesting the action. These
    are referred to as **methods** and can be thought of as action verbs that allow
    the system to know how to deal with the request. The next sections provide a brief
    overview of each method and its general use.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GET` is the most common method. It is used every time you use a web browser
    to retrieve information from a web server.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` is typically used for retrieving data from an API.'
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `POST` method is the other most commonly used method. Web browsers will
    often use this method to submit information from a web form.
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` is generally used for submitting information to an API that is then
    stored by the API as a new record.'
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `DELETE` method is usually used to delete a resource or record on the API's
    remote server.
  prefs: []
  type: TYPE_NORMAL
- en: HEAD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `HEAD` method works very much like the `GET` method, except that the API
    only returns header information and no other data.
  prefs: []
  type: TYPE_NORMAL
- en: PATCH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Patching a resource allows you to change only part of the information in the
    record, leaving everything else the same as it was before.
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PUT` is similar to the `POST` method in that it creates a new record on the
    API server if no record exists. But if the information being put to the API has
    a matching record, this record will be overwritten and replaced by the new information.'
  prefs: []
  type: TYPE_NORMAL
- en: Response codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a request is made to an API server and the data and metadata is returned
    to the client, there is also a response code. While diving deep into what each
    response code means and how you can use them for detailed troubleshooting is beyond
    the scope of this book, it is essential to know each classification of response
    code and what they represent.
  prefs: []
  type: TYPE_NORMAL
- en: 1xx (informational)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request was received by the server and is still being processed. Please
    wait for it to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 2xx (success)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything worked as expected, more or less.
  prefs: []
  type: TYPE_NORMAL
- en: 3xx (redirection)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The API is no longer at the location you requested. Check the error message
    to get a better idea of the new API location.
  prefs: []
  type: TYPE_NORMAL
- en: 4xx (client error)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Something is wrong with how you formed the API request. Check the error message
    and then update the request.
  prefs: []
  type: TYPE_NORMAL
- en: 5xx (server error)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's a problem with the server, and generally, there is little that you can
    do to resolve the issue. If you have the contact information for the person/team
    managing the API server, you could report the error to them and see if they can
    assist.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what APIs are about, let's start using n8n's `HTTP Request`
    node to connect to a few APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Basic API call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple API call. Let's get information from GitHub about
    the n8n project.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `HTTP Request` node to the canvas in the n8n Editor UI and open the
    node. Please leave all of the parameters at their defaults, except for the `URL`
    value. Set the `URL` value to https://api.github.com/users/n8n-io/.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s it! We are now ready to retrieve the data from the server via the
    API! Click on **Execute Node** to perform the API request. You should get a response
    that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can now connect other nodes to the output of the `HTTP Request` node and
    process the information however you wish, or send it to another system.
  prefs: []
  type: TYPE_NORMAL
- en: Using basic authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s try something a bit more complicated. We''re going to look up `HTTP
    Request` node to query the API:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [https://upcdatabase.org/signup](https://upcdatabase.org/signup) and
    create an account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have your account created, go to [https://upcdatabase.org/apikeys](https://upcdatabase.org/apikeys)
    and copy the token on that page. If there is no token on the page, create a new
    token and then copy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the n8n Editor UI, add a new `HTTP Request` node to the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Authentication** parameter, select **Basic Auth**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click **Create New** to open up a new credential window for the **Basic
    Auth** parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in a value for `UPC`), enter your email address in the **User** field,
    and paste your token into the **Password** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `HTTP Request` node. Notice that the **Basic Auth** parameter now
    has the name of the credentials that you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the URL parameter field, enter [https://api.upcdatabase.org/product/765756931182](https://api.upcdatabase.org/product/765756931182).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `HTTP Request` node should be ready to go. Hit **Execute Node** and check
    out your results. They should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Try changing the number at the end of the URL and replace it with other UPCs
    you have around your home, and see what information you can find out about the
    products.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the basics of APIs including the parts that make
    up an API, how information is transmitted using APIs, the different **HyperText
    Transfer Protocol** (**HTTP**) methods, and their corresponding response codes.
    We then made both basic and secured API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we better understand APIs, let's move away from retrieving information
    that we request from other servers and take a look at receiving information that
    is pushed to n8n.
  prefs: []
  type: TYPE_NORMAL
- en: Webhook node – Handling real-time events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of Webhooks as the cousin of APIs. In fact, you can create an
    API server using the `Webhook` node!
  prefs: []
  type: TYPE_NORMAL
- en: A Webhook listens for `GET`, `HEAD`, or `POST` requests and then starts a workflow
    when it detects one. The `Webhook` node can do this because it is a trigger node.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to create a Webhook using n8n. As
    part of this build, we will learn how to send information to the Webhook and how
    to respond back with the requested information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic test Webhook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a basic Webhook, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Webhook` node to the n8n Editor UI canvas and open the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave all of the parameter values at their defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Webhook URLs** section by clicking on the **Webhook URLs** text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Test URL** toggle under the **Display URL for** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the URL to copy it to your clipboard (for example, [https://tephlon.app.n8n.cloud/webhook-test/373227bb-5fda-49e9-b491-54ef33db3eed](https://tephlon.app.n8n.cloud/webhook-test/373227bb-5fda-49e9-b491-54ef33db3eed)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Webhook` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the workflow. This is important because the Webhook URL can't register
    until the workflow is saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! You've just created your first basic Webhook!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test it to see if it is working! Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the n8n Editor UI, open up the `Webhook` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Execute Node** button to start the Webhook listening.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up a new web browser, paste the Webhook URL you copied earlier into the
    address bar, and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything is working correctly, you should see two things happen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the web browser window, you should get the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the n8n Editor UI, you should receive a bunch of information in the `Webhook`
    node output window, similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is all of the information that has been sent to n8n from the web browser.
    While there is some interesting data here, there isn't anything helpful at this
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Sending information to n8n
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have a basic Webhook running, let''s see what happens when we send
    some information to it as a query in the URL. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the n8n Editor UI, open up the `Webhook` node and press the **Execute Node**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the web browser window that you used previously, paste the Webhook URL into
    the address bar, but before you press *Enter*, add `?fname=Jim&lname=Nasium` to
    the end of the URL. Then, press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Everything looks the same in the web browser, but let''s look closely at the
    `query` section in the `Webhook` node output window, which you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These values match the values entered at the end of the URL that was entered
    into the web browser. You can now use this information received from the client
    in the rest of your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know we can receive information from the client, let''s send a
    confirmation message to the sender! Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Webhook` node, change `Response Mode` to `Last Node`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `Webhook` node, add a `html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a `Webhook` node and enable the option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Webhook` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Set` node to the n8n Editor UI and connect it to the output of the `Webhook`
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Set` node and add a `string` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the value `html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the gears next to **Value** and click on the **Add Expression** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `<H1>Thanks for visiting, {{$json["query"]["fname"]}} {{$json["query"]["lname"]}}!</H1>`
    in the **Expression** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Set` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see what this does for us. In the n8n Editor UI, click on the `?fname=Jim&lname=Nasium`.
  prefs: []
  type: TYPE_NORMAL
- en: If everything has been set up correctly, you should get a message in large letters
    stating "`Thanks for visiting, Jim Nasium!`".
  prefs: []
  type: TYPE_NORMAL
- en: How does that work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the web browser sends the information to the Webhook, the Webhook grabs
    the `fname=Jim&lname=Nasium` portion of the URL and sends it on to the `Set` node.
    The `Set` node then uses the values for `fname` and `lname` to dynamically generate
    **HyperText Markup Language** (**HTML**), which the Webhook uses to send back
    to the web browser. The web browser then displays the HTML accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We've essentially turned n8n into a web server that can generate real-time dynamic
    web pages!
  prefs: []
  type: TYPE_NORMAL
- en: We have one last section that we want to cover before we close out this chapter.
    Let's talk about manipulating data stored in arrays and JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays and JSON objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: n8n uses a lot of arrays and JSON objects, and it is important that you are
    comfortable working with them. In this section, we will learn how to manipulate
    arrays and objects by splitting, combining, and writing to these items.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of data flying around an n8n workflow, and it can be constructive
    to learn a few tips and tricks about manipulating this data stored in arrays and
    JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these examples, we are going to use an array with three JSON objects with
    the same keys, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at this information using the **Table** tab at the top of the n8n
    node generating this information, it will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_3.03_B17493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can generate this table in a `Function` node by adding a `Function` node
    to the n8n Editor UI and then pasting the following into the JavaScript code field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, the output of the `Function` node should match the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's learn how to split data from the `Function` node using the `IF`
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the cats from the dogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we are going to do is split this array into two arrays using
    the `IF` node. We are going to send all of the dogs to the `true` output and all
    of the cats to the `false` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach an `IF` node to the output of the node generating the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `IF` node and add a `string` condition to the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Value 1` field, click on the gears icon and select **Add Expression**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `{{$json["species"]}}` into the **Expression** field and close the Expression
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Value 2` field, type `dog` for the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `IF` node and execute the workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `IF` node and take a look at the results for the `true` and `false`
    outputs. You should see that there are two entries in the `false` output and one
    in the `true` output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combining two arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have split the array apart, let''s see if we can bring them back
    together again. We''re going to do this using the `Merge` node. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Merge` node to the n8n Editor UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `true` output from the `IF` node to `Input 1` of the `Merge` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `false` output from the `IF` node to `Input 2` of the `Merge` node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Merge` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `Mode` parameter, select **Append**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Merge` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your final workflow should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Splitting and merging an array workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Splitting and merging an array workflow
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to test it out! Execute the workflow. When it finishes running,
    open up the `Merge` node. The output windows should show that the array is once
    again back together.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the same value to all JSON objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's imagine we want to add another key to all records in the array coming
    out from the `Merge` node. Let's also assume that each copy of the key will be
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can accomplish this by using the `Set` node. Here are the steps you need
    to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Set` node to the n8n Editor UI and attach it to the output of the `Merge`
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Set` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Boolean value and name it `adopted`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the value of `adopted` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Set` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To check if it worked, execute the workflow and open up the `IF` node. The
    table in the output window should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_3.04_B17493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the `IF`, `Merge`, and `Set` nodes allows us to perform some instrumental
    data manipulation tasks quickly and easily without resorting to custom coding
    using the `Function` node.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered some critical concepts, and in it, we learned how to build
    some powerful tools within n8n.
  prefs: []
  type: TYPE_NORMAL
- en: We first covered how n8n structures data with JSON using the primary components
    of key-value pairs, objects, and arrays. We followed this by showing how n8n stores
    JSON and binary data internally. Then we talked about using the `Function` node
    and understanding the `items` array, dot notation, and the `$items` method. Once
    functions were figured out, we learned about APIs and how to send and receive
    data using basic and authenticated calls. Next, we reviewed Webhooks and used
    them in n8n to send information and generate HTML files. Finally, we went over
    how n8n works with JSON objects and arrays, including manipulating data that is
    stored in these items.
  prefs: []
  type: TYPE_NORMAL
- en: With this new information under your belt, you are well on your way to building
    practical tools using n8n.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will put this new knowledge to use and build three
    applications in n8n!
  prefs: []
  type: TYPE_NORMAL
