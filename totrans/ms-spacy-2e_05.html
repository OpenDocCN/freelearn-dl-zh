<html><head></head><body>
  <div id="_idContainer068">
   <h1 class="chapter-number" id="_idParaDest-75">
    <a id="_idTextAnchor074">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor075">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Extracting Semantic Representations with spaCy Pipelines
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In this chapter, we will apply what we learned in
    </span>
    <a href="B22441_04.xhtml#_idTextAnchor056">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.4.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <em class="italic">
     <span class="koboSpan" id="kobo.5.1">
      ,
     </span>
    </em>
    <span class="koboSpan" id="kobo.6.1">
     to the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      Airline Travel Information System
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      ATIS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     ), a well-known airplane ticket reservation system dataset.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     The data consists of utterances – sentences of users asking for information.
    </span>
    <span class="koboSpan" id="kobo.10.3">
     First, we will extract the named entities, creating our own extraction patterns with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.11.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.12.1">
     .
    </span>
    <span class="koboSpan" id="kobo.12.2">
     Then we will determine the intent of the user utterance with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.13.1">
      DepedencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.14.1">
     patterns.
    </span>
    <span class="koboSpan" id="kobo.14.2">
     We will also use the code to extract the intent and create our own custom spaCy component and use it to process large datasets faster with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.15.1">
       Language.pipe()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      method.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.17.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.18.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Extracting named entities
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.21.1">
        SpanRuler
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      Extracting dependency relations
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.24.1">
        DependencyMatcher
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.25.1">
      Creating a pipeline component using
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       extension attributes
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.27.1">
      Running the pipeline with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.28.1">
       large datasets
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-77">
    <a id="_idTextAnchor076">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.30.1">
     In this chapter, we’ll process a dataset.
    </span>
    <span class="koboSpan" id="kobo.30.2">
     The dataset and the chapter code can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.31.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.32.1">
       https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     We will use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.35.1">
      pandas
     </span>
    </strong>
    <span class="koboSpan" id="kobo.36.1">
     library to manipulate our dataset.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     We'll also used the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.37.1">
      wget
     </span>
    </strong>
    <span class="koboSpan" id="kobo.38.1">
     command-line tool.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.39.1">
      pandas
     </span>
    </strong>
    <span class="koboSpan" id="kobo.40.1">
     can be installed via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.41.1">
      pip
     </span>
    </strong>
    <span class="koboSpan" id="kobo.42.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.43.1">
      wget
     </span>
    </strong>
    <span class="koboSpan" id="kobo.44.1">
     is preinstalled in many
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.45.1">
      Linux distributions.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor077">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     Extracting named entities with SpanRuler
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     In many
    </span>
    <a id="_idIndexMarker229">
    </a>
    <span class="koboSpan" id="kobo.48.1">
     NLP applications, including semantic parsing, we start looking for meaning in a text by examining the entity types and placing an
    </span>
    <a id="_idIndexMarker230">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     entity extraction component into our NLP pipelines.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     Named entities play a key role in understanding the meaning of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      user text.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     We’ll also start a semantic parsing pipeline by extracting the named entities from our corpus.
    </span>
    <span class="koboSpan" id="kobo.51.2">
     To understand what sort of entities we want to extract, first, we’ll get to know the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      ATIS dataset.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-79">
    <a id="_idTextAnchor078">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     Getting to know the ATIS dataset
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     Throughout
    </span>
    <a id="_idIndexMarker231">
    </a>
    <span class="koboSpan" id="kobo.55.1">
     this chapter, we’ll work with the ATIS corpus.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     ATIS is a well-known dataset; it’s one of the standard benchmark datasets for intent classification.
    </span>
    <span class="koboSpan" id="kobo.55.3">
     The dataset consists of utterances from customers who want to book a flight and/or get information about flights, including flight costs, destinations,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      and timetables.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.57.1">
     No matter what the NLP task is, you should always go over your corpus with the naked eye.
    </span>
    <span class="koboSpan" id="kobo.57.2">
     We want to get to know our corpus to integrate our observations of the corpus into our code.
    </span>
    <span class="koboSpan" id="kobo.57.3">
     While viewing our text data, we usually keep an eye on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.58.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.59.1">
      What kinds of utterances are there?
     </span>
     <span class="koboSpan" id="kobo.59.2">
      Is it a short text corpus or does the corpus consist of long documents or
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.60.1">
       medium-length paragraphs?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.61.1">
      What sort of entities does the corpus include?
     </span>
     <span class="koboSpan" id="kobo.61.2">
      Examples include people’s names, city names, country names, organization names, and so on.
     </span>
     <span class="koboSpan" id="kobo.61.3">
      Which ones do we want
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.62.1">
       to extract?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.63.1">
      How is punctuation used?
     </span>
     <span class="koboSpan" id="kobo.63.2">
      Is the text correctly punctuated, or is no punctuation used
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.64.1">
       at all?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.65.1">
      Did users follow the grammatical rules?
     </span>
     <span class="koboSpan" id="kobo.65.2">
      How are the grammatical rules followed?
     </span>
     <span class="koboSpan" id="kobo.65.3">
      Is the capitalization correct?
     </span>
     <span class="koboSpan" id="kobo.65.4">
      Are there
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.66.1">
       misspelled words?
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     Before starting any processing, we’ll examine our corpus.
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.68.1">
      Here’s how:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.69.1">
      Let’s go ahead and download
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.70.1">
       the dataset:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.71.1">mkdir data</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.72.1">wget -P data https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition/blob/main/chapter_05/data/atis_intents.csv</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.73.1">
       The dataset is a two-column
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.74.1">
        CSV file.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.75.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.76.1">
     If you are running the code on a Jupyter notebook, you can add a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.77.1">
      !
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     before the commands to run
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.79.1">
      them there.
     </span>
    </span>
   </p>
   <ol>
    <li value="2">
     <span class="koboSpan" id="kobo.80.1">
      Next, we’ll
     </span>
     <a id="_idIndexMarker232">
     </a>
     <span class="koboSpan" id="kobo.81.1">
      get some insights into the dataset statistics with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.82.1">
       pandas
      </span>
     </strong>
     <span class="koboSpan" id="kobo.83.1">
      .
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.84.1">
       pandas
      </span>
     </strong>
     <span class="koboSpan" id="kobo.85.1">
      is a popular data manipulation library that is frequently used by data scientists.
     </span>
     <span class="koboSpan" id="kobo.85.2">
      You can read more
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.86.1">
       at
      </span>
     </span>
     <a href="https://pandas.pydata.org/docs/getting_started/intro_tutorials/">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.87.1">
        https://pandas.pydata.org/docs/getting_started/intro_tutorials/
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.88.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.89.1">
import pandas as pd
df = pd.read_csv("data/atis_intents.csv", header=None, 
                 names=["utterance", "text"])
df.shape</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.90.1">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.91.1">
        shape
       </span>
      </strong>
      <span class="koboSpan" id="kobo.92.1">
       attribute returns a tuple representing the dimensionality of
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.93.1">
        DataFrame
       </span>
      </strong>
      <span class="koboSpan" id="kobo.94.1">
       .
      </span>
      <span class="koboSpan" id="kobo.94.2">
       We can see that the dataset has two columns and
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.95.1">
        4,978 rows.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.96.1">
      Let’s create a bar plot to see the number of utterances in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.97.1">
       the dataset:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.98.1">
df["utterance"].value_counts().plot.barh()</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.99.1">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.100.1">
        value_counts()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.101.1">
       method returns a series containing counts of unique values.
      </span>
      <span class="koboSpan" id="kobo.101.2">
       The pandas library uses Matplotlib under the hood to plot this in a bar chart; this is
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.102.1">
        the result:
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer061">
     <span class="koboSpan" id="kobo.103.1">
      <img alt="Figure 5.1 – Bar chart with utterance frequencies" src="image/B22441_05_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.104.1">
     Figure 5.1 – Bar chart with utterance frequencies
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     Most user requests
    </span>
    <a id="_idIndexMarker233">
    </a>
    <span class="koboSpan" id="kobo.106.1">
     are for information about flights, followed by requests about airfares.
    </span>
    <span class="koboSpan" id="kobo.106.2">
     However, before extracting the utterances, we will learn how to extract named entities.
    </span>
    <span class="koboSpan" id="kobo.106.3">
     Let’s do this in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      next section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor079">
    </a>
    <span class="koboSpan" id="kobo.108.1">
     Defining LOCATION entities
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     In this
    </span>
    <a id="_idIndexMarker234">
    </a>
    <span class="koboSpan" id="kobo.110.1">
     section, our goal is to extract
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      LOCATION
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     entities.
    </span>
    <span class="koboSpan" id="kobo.112.2">
     The pipeline of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      en_core_web_sm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     model already has an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.115.1">
      NER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     component.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     Let’s see
    </span>
    <a id="_idIndexMarker235">
    </a>
    <span class="koboSpan" id="kobo.117.1">
     what entities the default NER model extracts from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      "i want to fly from boston at 838 am and arrive in denver at 1110 in the
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.119.1">
       morning"
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      utterance:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.121.1">
      First, we import
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.122.1">
       the libraries:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.123.1">
import spacy
from spacy import displacy</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.124.1">
      Then we load the spaCy model and process
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.125.1">
       a sentence:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.126.1">
nlp = spacy.load("en_core_web_sm")
text = "i want to fly from boston at 838 am and arrive in denver at 1110 in the morning"
doc = nlp(text)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.127.1">
      Finally, we display the entities
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.128.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.129.1">
        displacy
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.130.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.131.1">
displacy.render(doc, style='ent')</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.132.1">
       We can see the result in
      </span>
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.133.1">
         Figure 5
        </span>
       </em>
      </span>
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.134.1">
         .2
        </span>
       </em>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.135.1">
        :
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer062">
     <span class="koboSpan" id="kobo.136.1">
      <img alt="Figure 5.2 – Entities extracted by the NER component" src="image/B22441_05_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.137.1">
     Figure 5.2 – Entities extracted by the NER component
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.138.1">
     The
    </span>
    <a id="_idIndexMarker236">
    </a>
    <span class="koboSpan" id="kobo.139.1">
     NER model
    </span>
    <a id="_idIndexMarker237">
    </a>
    <span class="koboSpan" id="kobo.140.1">
     finds the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.141.1">
      Global Political Entity
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.143.1">
      GPE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     ) for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      boston
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.147.1">
      denver
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     , but knowing the cities is not sufficient.
    </span>
    <span class="koboSpan" id="kobo.148.2">
     We want to know
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.149.1">
      from
     </span>
    </strong>
    <span class="koboSpan" id="kobo.150.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.151.1">
      where
     </span>
    </strong>
    <span class="koboSpan" id="kobo.152.1">
     they want to fly.
    </span>
    <span class="koboSpan" id="kobo.152.2">
     This means that in this case, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.153.1">
      adpositions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.154.1">
     (a cover term for prepositions and postpositions) are important.
    </span>
    <span class="koboSpan" id="kobo.154.2">
     spaCy uses the
    </span>
    <a id="_idIndexMarker238">
    </a>
    <span class="koboSpan" id="kobo.155.1">
     Universal
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.156.1">
      Parts-of-Speech
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.158.1">
      POS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     ) tags, so the adposition tag is named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      "ADP"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     .
    </span>
    <span class="koboSpan" id="kobo.161.2">
     You can see all the descriptions for the POS tags, dependency label, or entity type of spaCy in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.162.1">
      glossary (
     </span>
    </span>
    <a href="https://github.com/explosion/spaCy/blob/master/spacy/glossary.py">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.163.1">
       https://github.com/explosion/spaCy/blob/master/spacy/glossary.py
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.165.1">
     Getting back to the utterance example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      from boston
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      in denver
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     are the entities we want to extract.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     Since we know exactly what POS tags and GPE entities we need to create the new entities, a good way of implementing this extraction is to rely on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.170.1">
      Tagger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.171.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      EntityRecognizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     components of the NLP pipeline.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     We’ll do this by creating rules to extract the tokens based on the tags.
    </span>
    <span class="koboSpan" id="kobo.173.3">
     spaCy makes this easy to do with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.174.1">
       SpanRuler
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      component.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor080">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     Adding the SpanRuler component to our processing pipeline
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.177.1">
     Customizing
    </span>
    <a id="_idIndexMarker239">
    </a>
    <span class="koboSpan" id="kobo.178.1">
     NLP pipelines is very straightforward with spaCy.
    </span>
    <span class="koboSpan" id="kobo.178.2">
     Each pipeline is created with a combination of spaCy components.
    </span>
    <span class="koboSpan" id="kobo.178.3">
     It might not be very clear at first, but when we load an out-of-the-box spaCy model, it already comes with several
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.179.1">
      different components:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.180.1">
nlp.pipe_names</span></pre>
   <p>
    <span class="koboSpan" id="kobo.181.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.182.1">
      nlp.pipe_names
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     attribute
    </span>
    <a id="_idIndexMarker240">
    </a>
    <span class="koboSpan" id="kobo.184.1">
     returns the component names, in order.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.185.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.186.1">
      .3
     </span>
    </em>
    <span class="koboSpan" id="kobo.187.1">
     shows all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      of them.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer063">
     <span class="koboSpan" id="kobo.189.1">
      <img alt="Figure 5.3 – The default components of the en_core_web_sm model" src="image/B22441_05_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.190.1">
     Figure 5.3 – The default components of the en_core_web_sm model
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     We can see that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      en_core_web_sm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     model comes with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      ['tok2vec', 'tagger', 'parser', 'attribute_ruler', 'lemmatizer', 'ner']
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     components by default.
    </span>
    <span class="koboSpan" id="kobo.195.2">
     Each component returns a processed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.196.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.197.1">
     object, which is then passed on to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      next component.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.199.1">
     You can add components to the processing pipeline using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      Language.add_pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     method (here nlp is the object of the Language class, which we will be using to call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      add_pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.203.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      .add_pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     method expects a string with the name of the component.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     Under the hood, this method takes care of creating the component, adds it to the pipeline, and then returns the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.206.1">
      component object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.207.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     component is an out-of-the-box component for rule-based span and named entity recognition.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     The component lets you add spans to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      Doc.spans
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     and/or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.212.1">
      Doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.213.1">
     .
    </span>
    <span class="koboSpan" id="kobo.213.2">
     Let’s try it for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      first time:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.215.1">
      First, we call the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.216.1">
        add_pipe()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.217.1">
       method:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.218.1">spanruler_component = nlp.add_pipe("span_ruler")</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.219.1">
      Then we add the patterns using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.220.1">
       add_patterns()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.221.1">
      method.
     </span>
     <span class="koboSpan" id="kobo.221.2">
      They should be defined using a list of dictionaries containing the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.222.1">
       "label"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.223.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.224.1">
       "
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.225.1">
        pattern"
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.226.1">
       keys:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.227.1">
patterns_location_spanruler = [
    {"label": "LOCATION", 
     "pattern": [{"POS": "ADP"}, {"ENT_TYPE": "GPE"}]}]
spanruler_component.add_patterns(patterns_location_spanruler)</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.228.1">
       spaCy uses
      </span>
      <em class="italic">
       <span class="koboSpan" id="kobo.229.1">
        Thinc
       </span>
      </em>
      <span class="koboSpan" id="kobo.230.1">
       (
      </span>
      <a href="https://thinc.ai/docs/api-config#registry">
       <span class="koboSpan" id="kobo.231.1">
        https://thinc.ai/docs/api-config#registry
       </span>
      </a>
      <span class="koboSpan" id="kobo.232.1">
       ) registry, a system that maps string keys to functions.
      </span>
      <span class="koboSpan" id="kobo.232.2">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.233.1">
        "span_ruler"
       </span>
      </strong>
      <span class="koboSpan" id="kobo.234.1">
       string name is the string to reference the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.235.1">
        SpanRuler
       </span>
      </strong>
      <span class="koboSpan" id="kobo.236.1">
       component.
      </span>
      <span class="koboSpan" id="kobo.236.2">
       We then define a pattern named
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.237.1">
        LOCATION
       </span>
      </strong>
      <span class="koboSpan" id="kobo.238.1">
       and add it to the component using the
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.239.1">
         add_patterns()
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.240.1">
        method.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.241.1">
      Unlike in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.242.1">
       doc.ents
      </span>
     </strong>
     <span class="koboSpan" id="kobo.243.1">
      , overlapping
     </span>
     <a id="_idIndexMarker241">
     </a>
     <span class="koboSpan" id="kobo.244.1">
      matches are allowed in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.245.1">
       doc.spans
      </span>
     </strong>
     <span class="koboSpan" id="kobo.246.1">
      .
     </span>
     <span class="koboSpan" id="kobo.246.2">
      By default,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.247.1">
       SpanRuler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.248.1">
      adds the matches as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.249.1">
       spans
      </span>
     </strong>
     <span class="koboSpan" id="kobo.250.1">
      to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.251.1">
       doc.spans["ruler"]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.252.1">
      group of spans.
     </span>
     <span class="koboSpan" id="kobo.252.2">
      Let’s process the text again and check whether
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       SpanRuler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      did its job.
     </span>
     <span class="koboSpan" id="kobo.254.2">
      Since the component adds the Span to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.255.1">
       "ruler"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.256.1">
      key, we need to specify this to render the spans
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.257.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.258.1">
        displacy
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.259.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.260.1">
doc = nlp(text)
options = {"spans_key": "ruler"}
displacy.render(doc, style='span', options=options)</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.261.1">
       Let’s see the results in
      </span>
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.262.1">
         Figure 5
        </span>
       </em>
      </span>
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.263.1">
         .4
        </span>
       </em>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.264.1">
        .
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer064">
     <span class="koboSpan" id="kobo.265.1">
      <img alt="Figure 5.4 – Spans extracted with SpanRuler" src="image/B22441_05_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.266.1">
     Figure 5.4 – Spans extracted with SpanRuler
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.267.1">
     We can see that the component identified the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.268.1">
      "from boston"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.269.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      "in denver"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.271.1">
     Span.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.272.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.273.1">
     has some settings that you can change.
    </span>
    <span class="koboSpan" id="kobo.273.2">
     This can be done via the config argument on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.274.1">
      nlp.pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.275.1">
     method or using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.276.1">
      config.cfg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.277.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.277.2">
     Let’s add the spans to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      Doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     instead
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.281.1">
       doc.spans["ruler"]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      :
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.283.1">
      First, we remove the component of the pipeline because we only have one component with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.284.1">
       same name:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.285.1">nlp.remove_pipe("span_ruler")</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.286.1">
      Then
     </span>
     <a id="_idIndexMarker242">
     </a>
     <span class="koboSpan" id="kobo.287.1">
      we set the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.288.1">
       "annotate_ents"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.289.1">
      parameter of the component to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.290.1">
       True
      </span>
     </strong>
     <span class="koboSpan" id="kobo.291.1">
      .
     </span>
     <span class="koboSpan" id="kobo.291.2">
      The entities added by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.292.1">
       EntityRecognizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.293.1">
      are needed in our pattern, so we also need to set the overwrite parameter to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.294.1">
       False
      </span>
     </strong>
     <span class="koboSpan" id="kobo.295.1">
      so we don’t
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.296.1">
       overwrite them:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.297.1">
config = {"annotate_ents": True, "overwrite": False}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.298.1">
      Now we create the component again with this config, add the previously created patterns and process the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.299.1">
       text again.
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.300.1">
spanruler_component_v2 = nlp.add_pipe(
    "span_ruler", config=config)
spanruler_component_v2.add_patterns(patterns_location_spanruler)
doc = nlp(text)
displacy.render(doc, style='ent')</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.301.1">
       By doing all that, the matches become entities,
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.302.1">
        not spans.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.303.1">
       Let’s see the new entities in
      </span>
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.304.1">
         Figure 5
        </span>
       </em>
      </span>
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.305.1">
         .5
        </span>
       </em>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.306.1">
        :
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer065">
     <span class="koboSpan" id="kobo.307.1">
      <img alt="Figure 5.5 – Entities extracted using SpanRuler" src="image/B22441_05_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.308.1">
     Figure 5.5 – Entities extracted using SpanRuler
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.309.1">
     You can see that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      {'GPE', 'boston'}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.312.1">
      {'GPE', 'denver'}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.313.1">
     entities don’t exist anymore; they’re now
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.314.1">
      {'from boston', 'LOCATION'}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.315.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.316.1">
      {'in denver', 'LOCATION'}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.317.1">
     , respectively.
    </span>
    <span class="koboSpan" id="kobo.317.2">
     Overlapping entities are not allowed in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      Doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     , so they are filtered using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      util.filter_spans
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     function by default.
    </span>
    <span class="koboSpan" id="kobo.321.2">
     This function keeps the first longest span over
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      shorter spans.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.323.1">
     You can
    </span>
    <a id="_idIndexMarker243">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     override most of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     settings.
    </span>
    <span class="koboSpan" id="kobo.326.2">
     Some of the available settings are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.328.1">
       spans_filter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.329.1">
      : A method to filter spans before they are assigned
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.330.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.331.1">
        doc.spans
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.332.1">
       ents_filter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.333.1">
      : A method to filter spans before they are assigned
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.334.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.335.1">
        doc.ents
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.336.1">
       validate
      </span>
     </strong>
     <span class="koboSpan" id="kobo.337.1">
      : A method to set whether patterns should be validated or passed to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.338.1">
       Matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.339.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.340.1">
       PhraseMatcher
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.341.1">
       as validate
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     In this section, we’ve learned how to create and extract entities using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.343.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.344.1">
     .
    </span>
    <span class="koboSpan" id="kobo.344.2">
     Having the pattern to extract
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.345.1">
      LOCATION
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     entities, we can now move on and extract the intention of utterances.
    </span>
    <span class="koboSpan" id="kobo.346.2">
     Let’s do this in the next section
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.348.1">
       DependencyMatcher
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-82">
    <a id="_idTextAnchor081">
    </a>
    <span class="koboSpan" id="kobo.350.1">
     Extracting dependency relations with DependencyMatcher
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     To
    </span>
    <a id="_idIndexMarker244">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     extract the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.353.1">
      intent
     </span>
    </em>
    <span class="koboSpan" id="kobo.354.1">
     of the
    </span>
    <a id="_idIndexMarker245">
    </a>
    <span class="koboSpan" id="kobo.355.1">
     utterances, we need to match tokens based on their syntax relationship with each other.
    </span>
    <span class="koboSpan" id="kobo.355.2">
     The goal is to find out what sort of intent the user carries – to book a flight, purchase a meal on their already booked flight, cancel their flight, and so on.
    </span>
    <span class="koboSpan" id="kobo.355.3">
     Every intent includes a verb (to book) and an object that the web acts on (flight, hotel, meal, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.356.1">
      so on).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.357.1">
     In this section, we’ll extract transitive verbs and their direct objects from utterances.
    </span>
    <span class="koboSpan" id="kobo.357.2">
     We’ll begin our intent recognition section by extracting the transitive verb and the direct object of the verb.
    </span>
    <span class="koboSpan" id="kobo.357.3">
     Before we move on to extracting transitive verbs and their direct objects, let’s first quickly go over the concepts of transitive verbs and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.358.1">
      direct/indirect objects.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor082">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     Linguistic primer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.360.1">
     Let’s explore some
    </span>
    <a id="_idIndexMarker246">
    </a>
    <span class="koboSpan" id="kobo.361.1">
     linguistic concepts related to sentence structure, including verbs and verb-object relations.
    </span>
    <span class="koboSpan" id="kobo.361.2">
     A verb is a very important component of the sentence as it indicates the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.362.1">
      action
     </span>
    </em>
    <span class="koboSpan" id="kobo.363.1">
     in the sentence.
    </span>
    <span class="koboSpan" id="kobo.363.2">
     The object of the sentence is the
    </span>
    <strong class="bold">
    </strong>
    <em class="italic">
     <span class="koboSpan" id="kobo.364.1">
      thing or person
     </span>
    </em>
    <span class="koboSpan" id="kobo.365.1">
     that is affected by the action of the verb.
    </span>
    <span class="koboSpan" id="kobo.365.2">
     Hence, there’s a natural connection between the sentence verb and objects.
    </span>
    <span class="koboSpan" id="kobo.365.3">
     The concept of transitivity captures verb-object relations.
    </span>
    <span class="koboSpan" id="kobo.365.4">
     A transitive verb is a verb that needs an object to act upon.
    </span>
    <span class="koboSpan" id="kobo.365.5">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.366.1">
      some examples:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.367.1">
I bought flowers.
</span><span class="koboSpan" id="kobo.367.2">He loved his cat.
</span><span class="koboSpan" id="kobo.367.3">He borrowed my book.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.368.1">
     In these example sentences,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.369.1">
      bought
     </span>
    </strong>
    <span class="koboSpan" id="kobo.370.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      loved
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.373.1">
      borrowed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.374.1">
     are transitive verbs.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     In the first sentence,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.375.1">
      bought
     </span>
    </strong>
    <span class="koboSpan" id="kobo.376.1">
     is the transitive verb and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.377.1">
      flowers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.378.1">
     is its object, the thing that has been bought by the sentence subject.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.379.1">
      I Loved
     </span>
    </strong>
    <span class="koboSpan" id="kobo.380.1">
     –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.381.1">
      his cat
     </span>
    </strong>
    <span class="koboSpan" id="kobo.382.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.383.1">
      borrowed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.384.1">
     –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.385.1">
      my book
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     are transitive verb-object examples.
    </span>
    <span class="koboSpan" id="kobo.386.2">
     We’ll focus on the first sentence again – what happens if we erase the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.387.1">
      flowers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.388.1">
     object?
    </span>
    <span class="koboSpan" id="kobo.388.2">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.389.1">
      that here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.390.1">
I bought</span></pre>
   <p>
    <span class="koboSpan" id="kobo.391.1">
     You bought
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.392.1">
      what
     </span>
    </em>
    <span class="koboSpan" id="kobo.393.1">
     ?
    </span>
    <span class="koboSpan" id="kobo.393.2">
     Without an object, this sentence doesn’t carry any meaning at all.
    </span>
    <span class="koboSpan" id="kobo.393.3">
     In the preceding sentences, each of the objects completes the meaning of the verb.
    </span>
    <span class="koboSpan" id="kobo.393.4">
     This is a way of understanding whether a verb is transitive or not – erase the object and check whether the sentence remains
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      semantically intact.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     Some verbs are transitive and some verbs are intransitive.
    </span>
    <span class="koboSpan" id="kobo.395.2">
     An intransitive verb is the opposite of a transitive verb; it doesn’t need an object to act upon.
    </span>
    <span class="koboSpan" id="kobo.395.3">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.396.1">
      some examples:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.397.1">
Yesterday I slept for 8 hours.
</span><span class="koboSpan" id="kobo.397.2">The cat ran towards me.
</span><span class="koboSpan" id="kobo.397.3">When I went out, the sun was shining.
</span><span class="koboSpan" id="kobo.397.4">Her cat died 3 days ago.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     In all the preceding sentences, the verbs make sense without an object.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     If we erase all the words other than the subject and object, these sentences are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      still meaningful:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.400.1">
I slept.
</span><span class="koboSpan" id="kobo.400.2">The cat ran.
</span><span class="koboSpan" id="kobo.400.3">The sun was shining.
</span><span class="koboSpan" id="kobo.400.4">Her cat died.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     Pairing an
    </span>
    <a id="_idIndexMarker247">
    </a>
    <span class="koboSpan" id="kobo.402.1">
     intransitive verb with an object doesn’t make sense.
    </span>
    <span class="koboSpan" id="kobo.402.2">
     You can’t run someone or something, you can’t shine something or someone, and you certainly cannot die something
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      or someone.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.404.1">
     Sentence object
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.405.1">
     As we
    </span>
    <a id="_idIndexMarker248">
    </a>
    <span class="koboSpan" id="kobo.406.1">
     remarked before, the object is the thing or person that is affected by the verb’s action.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     The action stated by the verb is committed by the sentence subject and the sentence object is affected.
    </span>
    <span class="koboSpan" id="kobo.406.3">
     A sentence can be direct or indirect.
    </span>
    <span class="koboSpan" id="kobo.406.4">
     A direct object answers the questions
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.407.1">
      who
     </span>
    </em>
    <span class="koboSpan" id="kobo.408.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.409.1">
      what
     </span>
    </em>
    <span class="koboSpan" id="kobo.410.1">
     .
    </span>
    <span class="koboSpan" id="kobo.410.2">
     You can find the direct object by asking
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.411.1">
      The subject {verb} what/who?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     .
    </span>
    <span class="koboSpan" id="kobo.412.2">
     Here are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      some examples:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.414.1">
I bought flowers.       I bought what?      - flowers
He loved his cat.       He loved who?       - his cat
He borrowed my book.    He borrowed what?   - my book</span></pre>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     An
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.416.1">
      indirect object
     </span>
    </em>
    <span class="koboSpan" id="kobo.417.1">
     answers the questions
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.418.1">
      for what
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.420.1">
      for whom
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     , and/or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.422.1">
      to whom
     </span>
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     .
    </span>
    <span class="koboSpan" id="kobo.423.2">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.424.1">
      some examples:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.425.1">
He gave me his book.    He gave his book to whom?   - me
He gave his book to me. </span><span class="koboSpan" id="kobo.425.2">He gave his book to whom?   - me</span></pre>
   <p>
    <span class="koboSpan" id="kobo.426.1">
     Indirect objects are often preceded by the prepositions
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.427.1">
      to
     </span>
    </strong>
    <span class="koboSpan" id="kobo.428.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.429.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.430.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.431.1">
      from
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     As you can see from these examples, an indirect object is also an object and is affected by the verb’s action, but its role in the sentence is a bit different.
    </span>
    <span class="koboSpan" id="kobo.432.3">
     An indirect object is sometimes viewed as the recipient of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      direct object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.434.1">
     This is all you need to know about transitive/intransitive verbs and direct/indirect objects to digest this chapter’s material.
    </span>
    <span class="koboSpan" id="kobo.434.2">
     If you want to learn more about sentence syntax, you can read the great book
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.435.1">
      Linguistic Fundamentals for Natural Language Processing
     </span>
    </em>
    <span class="koboSpan" id="kobo.436.1">
     by Emily Bender (
    </span>
    <a href="https://dl.acm.org/doi/book/10.5555/2534456">
     <span class="koboSpan" id="kobo.437.1">
      https://dl.acm.org/doi/book/10.5555/2534456
     </span>
    </a>
    <span class="koboSpan" id="kobo.438.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.438.2">
     We have covered the basics of sentence syntax, but this is still a great resource to learn about syntax
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.439.1">
      in depth.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor083">
    </a>
    <span class="koboSpan" id="kobo.440.1">
     Matching patterns with the DependencyMatcher component
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.441.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.442.1">
      DependencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.443.1">
     component
    </span>
    <a id="_idIndexMarker249">
    </a>
    <span class="koboSpan" id="kobo.444.1">
     lets us
    </span>
    <a id="_idIndexMarker250">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     match patterns to extract information, but instead of defining a list of adjacent tokens as with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.446.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.447.1">
     patterns, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.448.1">
      DependencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.449.1">
     patterns match tokens
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.450.1">
      specifying the relations between them
     </span>
    </em>
    <span class="koboSpan" id="kobo.451.1">
     .
    </span>
    <span class="koboSpan" id="kobo.451.2">
     The component works with the dependencies extracted by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.452.1">
      DependencyParser
     </span>
    </strong>
    <span class="koboSpan" id="kobo.453.1">
     component.
    </span>
    <span class="koboSpan" id="kobo.453.2">
     Let’s see the kind of information this component extracts in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.454.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.455.1">
text = "show me flights from denver to philadelphia on tuesday"
doc = nlp(text)
displacy.render(doc, style='dep')</span></pre>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     Let´s see the results in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.457.1">
       Figure 5
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.458.1">
       .6
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.459.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer066">
     <span class="koboSpan" id="kobo.460.1">
      <img alt="Figure 5.6 – The dependency arcs of the sentence (the rest of the sentence is omitted)" src="image/B22441_05_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.461.1">
     Figure 5.6 – The dependency arcs of the sentence (the rest of the sentence is omitted)
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.462.1">
     The extracted dependency labels are the ones below the arcs.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.463.1">
      Show
     </span>
    </em>
    <span class="koboSpan" id="kobo.464.1">
     is a transitive verb, and in this sentence, its direct object is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.465.1">
      flight
     </span>
    </em>
    <span class="koboSpan" id="kobo.466.1">
     .
    </span>
    <span class="koboSpan" id="kobo.466.2">
     This dependency is extracted by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      DependencyParser
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     component and is labeled as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      dobj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.471.1">
      direct object).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.472.1">
     Our goal is
    </span>
    <a id="_idIndexMarker251">
    </a>
    <span class="koboSpan" id="kobo.473.1">
     to extract the intent, so we’ll define
    </span>
    <a id="_idIndexMarker252">
    </a>
    <span class="koboSpan" id="kobo.474.1">
     the pattern always looking for a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      verb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     and its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.477.1">
      dobj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.478.1">
     dependencies.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.479.1">
      DependencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.480.1">
     uses Semgrex operators to define the patterns.
    </span>
    <span class="koboSpan" id="kobo.480.2">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.481.1">
      Semgrex syntax
     </span>
    </strong>
    <span class="koboSpan" id="kobo.482.1">
     might be confusing at first, so let’s take it step
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      by step.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.484.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.485.1">
      DependencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.486.1">
     patterns consist of a list of dictionaries.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     The first dictionary defines an anchor token using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.487.1">
      RIGHT_ID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.488.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.489.1">
      RIGHT_ATTRS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.490.1">
     .
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.491.1">
      RIGHT_ID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.492.1">
     is a unique name for the right-hand node in the relation and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.493.1">
      RIGHT_ATTRS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.494.1">
     are the token attributes to match.
    </span>
    <span class="koboSpan" id="kobo.494.2">
     The pattern format is the same pattern used with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.495.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.496.1">
     .
    </span>
    <span class="koboSpan" id="kobo.496.2">
     In our pattern, the anchor token will be the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.497.1">
      dobj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.498.1">
     token, so the first dictionary is defined
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.499.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.500.1">
pattern = [
    {
        "RIGHT_ID": "direct_object_token",
        "RIGHT_ATTRS": {"DEP": "dobj"}
    }
]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     As spaCy’s documentation says (
    </span>
    <a href="https://spacy.io/usage/rule-based-matching/#dependencymatcher">
     <span class="koboSpan" id="kobo.502.1">
      https://spacy.io/usage/rule-based-matching/#dependencymatcher
     </span>
    </a>
    <span class="koboSpan" id="kobo.503.1">
     ), after the first dictionary, the following dictionaries of the pattern should have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      following keys:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.505.1">
       LEFT_ID
      </span>
     </strong>
     <span class="koboSpan" id="kobo.506.1">
      : The name of the left-hand node in the relation, which has been defined in an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.507.1">
       earlier node
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.508.1">
       REL_OP
      </span>
     </strong>
     <span class="koboSpan" id="kobo.509.1">
      : An operator that describes how the two nodes
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.510.1">
       are related
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.511.1">
       RIGHT_ID
      </span>
     </strong>
     <span class="koboSpan" id="kobo.512.1">
      : A unique name for the right-hand node in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.513.1">
       the relation
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.514.1">
       RIGHT_ATTRS
      </span>
     </strong>
     <span class="koboSpan" id="kobo.515.1">
      : The token attributes to match for the right-hand node in the same format as patterns provided to the regular token-based as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.516.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.517.1">
        SpanRuler
       </span>
      </strong>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.518.1">
     Given these keys,
    </span>
    <a id="_idIndexMarker253">
    </a>
    <span class="koboSpan" id="kobo.519.1">
     we construct the pattern by indicating the left-hand node of the relation, defining a name for the new right-hand node, and indicating the operator to describe the relation between the two nodes.
    </span>
    <span class="koboSpan" id="kobo.519.2">
     Getting back to our example, after defining
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.520.1">
      direct_object_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     as the anchor we will set
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.522.1">
      RIGHT_ID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     of the next dictionary to be the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.524.1">
      VERB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.525.1">
     token and define the operator as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.526.1">
      direct_object_token &lt; verb_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.527.1">
     because the direct object is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.528.1">
      the immediate dependent
     </span>
    </em>
    <span class="koboSpan" id="kobo.529.1">
     of the verb.
    </span>
    <span class="koboSpan" id="kobo.529.2">
     Here are some other operators that are supported by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      DependencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     (you can check the full list of operators
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.532.1">
      here
     </span>
    </span>
    <a href="https://spacy.io/usage/rule-based-matching/#dependencymatcher-operators">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.533.1">
       https://spacy.io/usage/rule-based-matching/#dependencymatcher-operators
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.534.1">
      ):
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.535.1">
       A &lt; B
      </span>
     </strong>
     <span class="koboSpan" id="kobo.536.1">
      : A is the immediate dependent
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.537.1">
       of B
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.538.1">
       A &gt; B
      </span>
     </strong>
     <span class="koboSpan" id="kobo.539.1">
      : A is the immediate head
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.540.1">
       of B
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.541.1">
       A &lt;&lt; B
      </span>
     </strong>
     <span class="koboSpan" id="kobo.542.1">
      : A is the dependent in a chain to B following dep →
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.543.1">
       head paths
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.544.1">
       A &gt;&gt; B
      </span>
     </strong>
     <span class="koboSpan" id="kobo.545.1">
      : A is the head in a chain to B following head →
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.546.1">
       dep paths
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.547.1">
     Don’t worry
    </span>
    <a id="_idIndexMarker254">
    </a>
    <span class="koboSpan" id="kobo.548.1">
     if these operations gave you a little headache; it also happened to me.
    </span>
    <span class="koboSpan" id="kobo.548.2">
     Those are just a few of them, you can check the full list of operators at
    </span>
    <a href="https://spacy.io/usage/rule-based-matching#dependencymatcher-operators">
     <span class="koboSpan" id="kobo.549.1">
      https://spacy.io/usage/rule-based-matching#dependencymatcher-operators
     </span>
    </a>
    <span class="koboSpan" id="kobo.550.1">
     .
    </span>
    <span class="koboSpan" id="kobo.550.2">
     All right, let’s get back to our example and define the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      full pattern:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.552.1">
pattern = [
    {
        "RIGHT_ID": "direct_object_token",
        "RIGHT_ATTRS": {"DEP": "dobj"}
    },
    {
        "LEFT_ID": "direct_object_token",
        "REL_OP": "&lt;",
        "RIGHT_ID": "verb_token",
        "RIGHT_ATTRS": {"POS": "VERB"}
    }
]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.553.1">
     Now, we are
    </span>
    <a id="_idIndexMarker255">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     good to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      create
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.556.1">
       DependencyMatcher
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.557.1">
      :
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.558.1">
      First, we
     </span>
     <a id="_idIndexMarker256">
     </a>
     <span class="koboSpan" id="kobo.559.1">
      need to pass the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.560.1">
       vocabulary
      </span>
     </strong>
     <span class="koboSpan" id="kobo.561.1">
      object (the vocabulary is shared with the documents the matcher
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.562.1">
       operates on):
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.563.1">
from spacy.matcher import DependencyMatcher
matcher = DependencyMatcher(nlp.vocab)</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.564.1">
       Next, we need to define a callback function that will take the following arguments:
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.565.1">
        matcher
       </span>
      </strong>
      <span class="koboSpan" id="kobo.566.1">
       ,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.567.1">
        doc
       </span>
      </strong>
      <span class="koboSpan" id="kobo.568.1">
       ,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.569.1">
        i
       </span>
      </strong>
      <span class="koboSpan" id="kobo.570.1">
       , and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.571.1">
        matches
       </span>
      </strong>
      <span class="koboSpan" id="kobo.572.1">
       .
      </span>
      <span class="koboSpan" id="kobo.572.2">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.573.1">
        matcher
       </span>
      </strong>
      <span class="koboSpan" id="kobo.574.1">
       argument refers to the matcher instance,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.575.1">
        doc
       </span>
      </strong>
      <span class="koboSpan" id="kobo.576.1">
       is the document being analyzed,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.577.1">
        i
       </span>
      </strong>
      <span class="koboSpan" id="kobo.578.1">
       is the index of the current match, and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.579.1">
        matches
       </span>
      </strong>
      <span class="koboSpan" id="kobo.580.1">
       is a list detailing the matches found.
      </span>
      <span class="koboSpan" id="kobo.580.2">
       We will create a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.581.1">
        callback
       </span>
      </strong>
      <span class="koboSpan" id="kobo.582.1">
       function to show the intent in a single word, such as
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.583.1">
        bookFlight
       </span>
      </strong>
      <span class="koboSpan" id="kobo.584.1">
       ,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.585.1">
        cancelFlight
       </span>
      </strong>
      <span class="koboSpan" id="kobo.586.1">
       ,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.587.1">
        bookMeal
       </span>
      </strong>
      <span class="koboSpan" id="kobo.588.1">
       , and so on.
      </span>
      <span class="koboSpan" id="kobo.588.2">
       The function will take the tokens of the match and print
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.589.1">
        their lemma:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.590.1">def show_intent(matcher, doc, i, matches):
    match_id, token_ids = matches[i]
    verb_token = doc[token_ids[1]]
    dobj_token = doc[token_ids[0]]
    intent = verb_token.lemma_ + dobj_token.lemma_.capitalize()
print("Intent:", intent)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.591.1">
      To add a rule to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.592.1">
       matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.593.1">
      , we specify an ID key, one or more patterns, and the optional callback function to act on the matches.
     </span>
     <span class="koboSpan" id="kobo.593.2">
      Finally, we process the text again and call the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.594.1">
       matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.595.1">
      object, passing this
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.596.1">
       doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.597.1">
      as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.598.1">
       the parameter:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.599.1">
matcher.add("INTENT", [pattern], on_match=show_intent)
doc = nlp("show me flights from denver to philadelphia on tuesday")
matches = matcher(doc)</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.600.1">
       Great!
      </span>
      <span class="koboSpan" id="kobo.600.2">
       The
      </span>
      <a id="_idIndexMarker257">
      </a>
      <span class="koboSpan" id="kobo.601.1">
       code prints
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.602.1">
        Intent: showFlightIntent
       </span>
      </strong>
      <span class="koboSpan" id="kobo.603.1">
       , so the recognition was successful.
      </span>
      <span class="koboSpan" id="kobo.603.2">
       Here, we recognized a single intent, but some utterances may carry multiple intents.
      </span>
      <span class="koboSpan" id="kobo.603.3">
       For example, consider the following utterance from
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.604.1">
        the corpus:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.605.1">show all flights and fares from denver to san francisco</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.606.1">
       Here, the
      </span>
      <a id="_idIndexMarker258">
      </a>
      <span class="koboSpan" id="kobo.607.1">
       user wants to list all the flights and, at the same time, see the fare info.
      </span>
      <span class="koboSpan" id="kobo.607.2">
       One way of processing is considering these intents as a single and complex intent.
      </span>
      <span class="koboSpan" id="kobo.607.3">
       A common way of processing this sort of utterance is to label the utterance with
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.608.1">
        multiple intents.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.609.1">
     Let’s see the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.610.1">
      DEP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     dependencies extracted
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.612.1">
      by
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.613.1">
       DependencyParser
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.614.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer067">
     <span class="koboSpan" id="kobo.615.1">
      <img alt="Figure 5.7 – The dependency arcs of the new sentence (the rest of the sentence is omitted)" src="image/B22441_05_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.616.1">
     Figure 5.7 – The dependency arcs of the new sentence (the rest of the sentence is omitted)
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.617.1">
     In
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.618.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.619.1">
      .7
     </span>
    </em>
    <span class="koboSpan" id="kobo.620.1">
     , we see that the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.621.1">
      dobj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.622.1">
     arc connects
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.623.1">
      show
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.625.1">
      flights
     </span>
    </strong>
    <span class="koboSpan" id="kobo.626.1">
     .
    </span>
    <span class="koboSpan" id="kobo.626.2">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.627.1">
      conj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.628.1">
     (conjunction) arc connects
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.629.1">
      flights
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.631.1">
      fares
     </span>
    </strong>
    <span class="koboSpan" id="kobo.632.1">
     to indicate the conjunction relation.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     This relation is built by a conjunction such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.633.1">
      and
     </span>
    </strong>
    <span class="koboSpan" id="kobo.634.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.635.1">
      or
     </span>
    </strong>
    <span class="koboSpan" id="kobo.636.1">
     and indicates that a noun is joined to another noun by this
    </span>
    <a id="_idIndexMarker259">
    </a>
    <span class="koboSpan" id="kobo.637.1">
     conjunction.
    </span>
    <span class="koboSpan" id="kobo.637.2">
     Now let’s write the code to recognize these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.638.1">
      two intents:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.639.1">
      Converting the arc relationship to a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.640.1">
       REL_OP
      </span>
     </strong>
     <span class="koboSpan" id="kobo.641.1">
      operator,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.642.1">
       direct_object_token
      </span>
     </strong>
     <span class="koboSpan" id="kobo.643.1">
      will be the head of the relationship this time, so we will use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.644.1">
       &gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.645.1">
      operator since
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.646.1">
       direct_object_token
      </span>
     </strong>
     <span class="koboSpan" id="kobo.647.1">
      is
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.648.1">
       the immediate head
      </span>
     </em>
     <span class="koboSpan" id="kobo.649.1">
      of the
     </span>
     <a id="_idIndexMarker260">
     </a>
     <span class="koboSpan" id="kobo.650.1">
      new
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.651.1">
       conjunction_token
      </span>
     </strong>
     <span class="koboSpan" id="kobo.652.1">
      .
     </span>
     <span class="koboSpan" id="kobo.652.2">
      This is the new pattern to match
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.653.1">
       two intents:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.654.1">
pattern_two = [
    {
        "RIGHT_ID": "direct_object_token",
        "RIGHT_ATTRS": {"DEP": "dobj"}
    },
    {
        "LEFT_ID": "direct_object_token",
        "REL_OP": "&lt;",
        "RIGHT_ID": "verb_token",
        "RIGHT_ATTRS": {"POS": "VERB"}
    },
    {
        "LEFT_ID": "direct_object_token",
        "REL_OP": "&gt;",
        "RIGHT_ID": "conjunction_token",
        "RIGHT_ATTRS": {"DEP": "conj"}
    }
]</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.655.1">
      We also
     </span>
     <a id="_idIndexMarker261">
     </a>
     <span class="koboSpan" id="kobo.656.1">
      need to update the callback function so it can print the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.657.1">
       two intents:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.658.1">
def show_two_intents(matcher, doc, i, matches):
    match_id, token_ids = matches[i]
    verb_token = doc[token_ids[1]]
    dobj_token = doc[token_ids[0]]
    conj_token = doc[token_ids[2]]
    intent = verb_token.lemma_ + \
        dobj_token.lemma_.capitalize() + ";" + \
        verb_token.lemma_ + conj_token.lemma_.capitalize()
    print("Two intents:", intent)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.659.1">
      Now we just need to add this new rule to the matcher.
     </span>
     <span class="koboSpan" id="kobo.659.2">
      Since the pattern ID already exists, the patterns will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.660.1">
       be extended:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.661.1">
matcher.add("TWO_INTENTS", [pattern_two], 
            on_match=show_two_intents)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.662.1">
      With all of that set, we can now find the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.663.1">
       matches again:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.664.1">
doc = nlp("show all flights and fares from denver to san francisco")
matches = matcher(doc)</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.665.1">
     Now the matcher
    </span>
    <a id="_idIndexMarker262">
    </a>
    <span class="koboSpan" id="kobo.666.1">
     finds the tokens for the two patterns, the first one and this new one, which matches two intents.
    </span>
    <span class="koboSpan" id="kobo.666.2">
     Until now, we have just been
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.667.1">
      printing the intent
     </span>
    </em>
    <span class="koboSpan" id="kobo.668.1">
     , but in a real setting, it’s a good idea to store this information on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.669.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.670.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.670.2">
     To do that, we’ll create our own spaCy component.
    </span>
    <span class="koboSpan" id="kobo.670.3">
     Let’s learn how to do it in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.671.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-85">
    <a id="_idTextAnchor084">
    </a>
    <span class="koboSpan" id="kobo.672.1">
     Creating a pipeline component using extension attributes
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.673.1">
     To create
    </span>
    <a id="_idIndexMarker263">
    </a>
    <span class="koboSpan" id="kobo.674.1">
     our component, we will use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.675.1">
      @Language.factory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.676.1">
     decorator.
    </span>
    <span class="koboSpan" id="kobo.676.2">
     A component factory is a callable that takes settings and returns a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.677.1">
      pipeline component function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.678.1">
     .
    </span>
    <span class="koboSpan" id="kobo.678.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.679.1">
      @Language.factory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.680.1">
     decorator
    </span>
    <a id="_idIndexMarker264">
    </a>
    <span class="koboSpan" id="kobo.681.1">
     also adds the name of the custom component to the registry, making
    </span>
    <a id="_idIndexMarker265">
    </a>
    <span class="koboSpan" id="kobo.682.1">
     it possible to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.683.1">
      .add_pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.684.1">
     method to add the component to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.685.1">
      the pipeline.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     spaCy allows you to set any custom attributes and methods on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.687.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.688.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.689.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.690.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.691.1">
      Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.692.1">
     objects, which become available as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.693.1">
      Doc._.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.694.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.695.1">
      Span._.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.696.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.697.1">
      Token._.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.698.1">
     .
    </span>
    <span class="koboSpan" id="kobo.698.2">
     In our case, we will add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.699.1">
      Doc._.intent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.700.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.701.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.702.1">
     , taking advantage of spaCy’s data structures to store
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.703.1">
      our data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.704.1">
     We will implement the component logic inside a Python class.
    </span>
    <span class="koboSpan" id="kobo.704.2">
     spaCy expects the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.705.1">
      __init__()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.706.1">
     method to take the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.707.1">
      nlp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.708.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.709.1">
      name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.710.1">
     arguments (spaCy fills then automatically), and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.711.1">
      __call__()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.712.1">
     method should receive and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.713.1">
      return
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.714.1">
       Doc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.715.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.716.1">
     Let’s create the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.717.1">
       IntentComponent
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.718.1">
      class:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.719.1">
      First, we create the class.
     </span>
     <span class="koboSpan" id="kobo.719.2">
      Inside the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.720.1">
       __init__()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.721.1">
      method, we create the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.722.1">
       DependencyMatcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.723.1">
      instance, add the patterns to the matcher, and set the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.724.1">
       intent
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.725.1">
       extension attribute:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.726.1">
class IntentComponent:
    def __init__(self, nlp: Language):
        self.matcher = DependencyMatcher(nlp.vocab)
        pattern = [
            {
                "RIGHT_ID": "direct_object_token",
                "RIGHT_ATTRS": {"DEP": "dobj"}
            },
            {
                "LEFT_ID": "direct_object_token",
                "REL_OP": "&lt;",
                "RIGHT_ID": "verb_token",
                "RIGHT_ATTRS": {"POS": "VERB"}
            }
        ]
        pattern_two = [
            {
                "RIGHT_ID": "direct_object_token",
                "RIGHT_ATTRS": {"DEP": "dobj"}
            },
            {
                "LEFT_ID": "direct_object_token",
                "REL_OP": "&lt;",
                "RIGHT_ID": "verb_token",
                "RIGHT_ATTRS": {"POS": "VERB"}
            },
            {
                "LEFT_ID": "direct_object_token",
                "REL_OP": "&gt;",
                "RIGHT_ID": "conjunction_token",
                "RIGHT_ATTRS": {"DEP": "conj"}
            }
        ]
        self.matcher.add("INTENT", [pattern])
        self.matcher.add("TWO_INTENTS", [pattern_two])
        if not Doc.has_extension("intent"):
            Doc.set_extension("intent", default=None)</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.727.1">
       Now, inside
      </span>
      <a id="_idIndexMarker266">
      </a>
      <span class="koboSpan" id="kobo.728.1">
       the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.729.1">
        __call__()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.730.1">
       method, we find the matches and check whether it’s a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.731.1">
        "TWO_INTENTS"
       </span>
      </strong>
      <span class="koboSpan" id="kobo.732.1">
       match.
      </span>
      <span class="koboSpan" id="kobo.732.2">
       If so, we extract the tokens for this pattern
      </span>
      <a id="_idIndexMarker267">
      </a>
      <span class="koboSpan" id="kobo.733.1">
       and set the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.734.1">
        doc._.intent
       </span>
      </strong>
      <span class="koboSpan" id="kobo.735.1">
       attribute; if not, in the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.736.1">
        else
       </span>
      </strong>
      <span class="koboSpan" id="kobo.737.1">
       block, we extract the tokens for the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.738.1">
        "
       </span>
      </strong>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.739.1">
         INTENT"
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.740.1">
        match:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.741.1">    def __call__(self, doc: Doc) -&gt; Doc:
        matches = self.matcher(doc)
        for match_id, token_ids in matches:
            string_id = nlp.vocab.strings[match_id]
            if string_id == "TWO_INTENTS":
                verb_token = doc[token_ids[1]]
                dobj_token = doc[token_ids[0]]
                conj_token = doc[token_ids[2]]
                intent = verb_token.lemma_ + \
                    dobj_token.lemma_.capitalize() + \
                    ";" + verb_token.lemma_ + \
                    conj_token.lemma_.capitalize()
                doc._.intent = intent
                break
        else:
            for match_id, token_ids in matches:
                string_id = nlp.vocab.strings[match_id]
                if string_id == "INTENT":
                    verb_token = doc[token_ids[1]]
                    dobj_token = doc[token_ids[0]]
                    intent = verb_token.lemma_ + \
                        dobj_token.lemma_.capitalize()
                    doc._.intent = intent
        return doc</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.742.1">
       With
      </span>
      <a id="_idIndexMarker268">
      </a>
      <span class="koboSpan" id="kobo.743.1">
       this code, we register the custom extension in
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.744.1">
        Doc
       </span>
      </strong>
      <span class="koboSpan" id="kobo.745.1">
       by setting
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.746.1">
        doc._.intent = intent
       </span>
      </strong>
      <span class="koboSpan" id="kobo.747.1">
       on the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.748.1">
        __call__()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.749.1">
       method, where we find the matches and save
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.750.1">
        the intent.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.751.1">
      Now that
     </span>
     <a id="_idIndexMarker269">
     </a>
     <span class="koboSpan" id="kobo.752.1">
      we have the class for the custom component, the next step is to register it using
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.753.1">
       the decorator:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.754.1">
@Language.factory("intent_component")
def create_intent_component(nlp: Language, name: str):
    return IntentComponent(nlp)</span></pre>
    </li>
   </ol>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.755.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.756.1">
     If you’re using a Jupyter Notebook and need to re-create the component, you’ll need to restart the kernel.
    </span>
    <span class="koboSpan" id="kobo.756.2">
     If not, spaCy will give us an error since the component name was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.757.1">
      already registered.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.758.1">
     That’s it, that’s your first custom component!
    </span>
    <span class="koboSpan" id="kobo.758.2">
     Congratulations!
    </span>
    <span class="koboSpan" id="kobo.758.3">
     Now, to extract the intent, we just need to add the component to the pipeline.
    </span>
    <span class="koboSpan" id="kobo.758.4">
     If we want to see the intent, we can access it with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.759.1">
      doc._.intent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.760.1">
     .
    </span>
    <span class="koboSpan" id="kobo.760.2">
     Here’s how you can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.761.1">
      do it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.762.1">
nlp.add_pipe("intent_component")
text = "show all flights and fares from denver to san francisco"
doc = nlp(text)
doc._.intent</span></pre>
   <p>
    <span class="koboSpan" id="kobo.763.1">
     Cool, right?
    </span>
    <span class="koboSpan" id="kobo.763.2">
     If you don’t remember, the
    </span>
    <a id="_idIndexMarker270">
    </a>
    <span class="koboSpan" id="kobo.764.1">
     dataset has 4,978 utterances.
    </span>
    <span class="koboSpan" id="kobo.764.2">
     That’s not a very large number, but
    </span>
    <a id="_idIndexMarker271">
    </a>
    <span class="koboSpan" id="kobo.765.1">
     what if it was bigger?
    </span>
    <span class="koboSpan" id="kobo.765.2">
     Could spaCy help us make it faster?
    </span>
    <span class="koboSpan" id="kobo.765.3">
     Yes!
    </span>
    <span class="koboSpan" id="kobo.765.4">
     In the next section, we will learn how to run our pipelines using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.766.1">
       Language.pipe()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.767.1">
      method.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-86">
    <a id="_idTextAnchor085">
    </a>
    <span class="koboSpan" id="kobo.768.1">
     Running the pipeline with large datasets
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.769.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.770.1">
      Language.pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.771.1">
     method
    </span>
    <a id="_idIndexMarker272">
    </a>
    <span class="koboSpan" id="kobo.772.1">
     processes texts as a stream and yields
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.773.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.774.1">
     objects in order.
    </span>
    <span class="koboSpan" id="kobo.774.2">
     It buffers the texts in batches instead of one-by-one, since this is usually more efficient.
    </span>
    <span class="koboSpan" id="kobo.774.3">
     If we want to get a specific doc, we need to call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.775.1">
      list()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.776.1">
     first because the method returns a Python generator that yields
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.777.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.778.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.778.2">
     This is how you can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.779.1">
      do it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.780.1">
utterance_texts = df.text.to_list()
processed_docs = list(nlp.pipe(utterance_texts))
print(processed_docs[0], processed_docs[0]._.intent)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.781.1">
     In the preceding code, we are getting a list of text utterances from the DataFrame we loaded at the beginning of the chapter and processing it in batches using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.782.1">
      .pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.783.1">
     .
    </span>
    <span class="koboSpan" id="kobo.783.2">
     Let’s compare the time difference by using and not using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.784.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.785.1">
       pipe()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.786.1">
      method:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.787.1">
import timestart_time = time.time()
utterance_texts = df.text.to_list()
processed_docs_vanilla = [nlp(text) for text in utterance_texts]
end_time = time.time()
execution_time = end_time - start_time
print("Execution time:", execution_time, "seconds")
&gt;&gt;&gt; Execution time: 27.12 seconds</span></pre>
   <p>
    <span class="koboSpan" id="kobo.788.1">
     This gives us a period of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.789.1">
      27.12
     </span>
    </strong>
    <span class="koboSpan" id="kobo.790.1">
     seconds.
    </span>
    <span class="koboSpan" id="kobo.790.2">
     Now, let’s use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.791.1">
      following method:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.792.1">
import timestart_time = time.time()
utterance_texts = df.text.to_list()
processed_docs_pipe = list(nlp.pipe(utterance_texts))
end_time = time.time()
execution_time = end_time - start_time
print("Execution time:", execution_time, "seconds")
&gt;&gt;&gt; Execution time: 5.90 seconds</span></pre>
   <p>
    <span class="koboSpan" id="kobo.793.1">
     Using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.794.1">
      nlp.pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.795.1">
     , we get the same results in 5.90 seconds.
    </span>
    <span class="koboSpan" id="kobo.795.2">
     That’s a huge difference.
    </span>
    <span class="koboSpan" id="kobo.795.3">
     We
    </span>
    <a id="_idIndexMarker273">
    </a>
    <span class="koboSpan" id="kobo.796.1">
     can also specify
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.797.1">
      batch_size
     </span>
    </strong>
    <span class="koboSpan" id="kobo.798.1">
     and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.799.1">
      n_process
     </span>
    </strong>
    <span class="koboSpan" id="kobo.800.1">
     to set the number of processors to use.
    </span>
    <span class="koboSpan" id="kobo.800.2">
     There is also an option to disable components if you need to run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      .pipe()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     just to get the result of the text processed by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.803.1">
      specific components.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.804.1">
     Awesome, we’ve finished our first pipeline with our own custom component!
    </span>
    <span class="koboSpan" id="kobo.804.2">
     Congratulations!
    </span>
    <span class="koboSpan" id="kobo.804.3">
     Here is the full code of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.805.1">
      the pipeline:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.806.1">
import spacy
from spacy.language import Language
from spacy.tokens import Doc
from spacy.matcher import DependencyMatcher
@Language.factory("intent_component")
def create_intent_component(nlp: Language, name: str):
@Language.factory("intent_component")
def create_intent_component(nlp: Language, name: str):
    return IntentComponent(nlp)
class IntentComponent:
    def __init__(self, nlp: Language):
                self.matcher = DependencyMatcher(nlp.vocab)
        pattern = [
            {
                "RIGHT_ID": "direct_object_token",
                "RIGHT_ATTRS": {"DEP": "dobj"}
            },
            {
                "LEFT_ID": "direct_object_token",
                "REL_OP": "&lt;",
                "RIGHT_ID": "verb_token",
                "RIGHT_ATTRS": {"POS": "VERB"}
            }
        ]
        pattern_two = [
            {
                "RIGHT_ID": "direct_object_token",
                "RIGHT_ATTRS": {"DEP": "dobj"}
            },
            {
                "LEFT_ID": "direct_object_token",
                "REL_OP": "&lt;",
                "RIGHT_ID": "verb_token",
                "RIGHT_ATTRS": {"POS": "VERB"}
            },
            {
                "LEFT_ID": "direct_object_token",
                "REL_OP": "&gt;",
                "RIGHT_ID": "conjunction_token",
                "RIGHT_ATTRS": {"DEP": "conj"}
            }
        ]
        self.matcher.add("INTENT", [pattern])
        self.matcher.add("TWO_INTENTS", [pattern_two])
        if not Doc.has_extension("intent"):
            Doc.set_extension("intent", default=None)
    def __call__(self, doc: Doc) -&gt; Doc:
        matches = self.matcher(doc)
        for match_id, token_ids in matches:
            string_id = nlp.vocab.strings[match_id]
            if string_id == "TWO_INTENTS":
                verb_token = doc[token_ids[1]]
                dobj_token = doc[token_ids[0]]
                conj_token = doc[token_ids[2]]
                intent = verb_token.lemma_ + \
                    dobj_token.lemma_. </span><span class="koboSpan" id="kobo.806.2">capitalize() + ";" + \
                    verb_token.lemma_ + \
                    conj_token.lemma_. </span><span class="koboSpan" id="kobo.806.3">capitalize()
                doc._.intent = intent
                break
        else:
            for match_id, token_ids in matches:
                string_id = nlp.vocab.strings[match_id]
                if string_id == "INTENT":
                    verb_token = doc[token_ids[1]]
                    dobj_token = doc[token_ids[0]]
                    intent = verb_token.lemma_ + \
                        dobj_token.lemma_. </span><span class="koboSpan" id="kobo.806.4">capitalize()
                    doc._.intent = intent
       return doc
nlp = spacy.load("en_core_web_sm")
nlp.add_pipe("intent_component")
text = "show all flights and fares from denver to san francisco"
doc = nlp(text)
doc._.intent</span></pre>
   <p>
    <span class="koboSpan" id="kobo.807.1">
     spaCy makes the
    </span>
    <a id="_idIndexMarker274">
    </a>
    <span class="koboSpan" id="kobo.808.1">
     pipeline code tidy and organized, two qualities that are essential if we want to maintain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.809.1">
      our codebase.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-87">
    <a id="_idTextAnchor086">
    </a>
    <span class="koboSpan" id="kobo.810.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.811.1">
     In this chapter, you learned how to generate a complete semantic parse of utterances.
    </span>
    <span class="koboSpan" id="kobo.811.2">
     First, you added a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.812.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.813.1">
     component to extract an NER entity that is significant to the use case context.
    </span>
    <span class="koboSpan" id="kobo.813.2">
     Then, you learned how to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.814.1">
      DependencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.815.1">
     to perform intent recognition by analyzing sentence structure.
    </span>
    <span class="koboSpan" id="kobo.815.2">
     Next, you also learned how to create your own custom spaCy component to extract the intent of the utterances.
    </span>
    <span class="koboSpan" id="kobo.815.3">
     Finally, you saw how to process large datasets faster with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.816.1">
       Language.pipe()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.817.1">
      method.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.818.1">
     Both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.819.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.820.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.821.1">
      DependencyMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.822.1">
     rely on the patterns we create.
    </span>
    <span class="koboSpan" id="kobo.822.2">
     The process of creating these patterns is a back-and-forth process.
    </span>
    <span class="koboSpan" id="kobo.822.3">
     We analyze the results, then test out new patterns, then analyze the results again, and so on.
    </span>
    <span class="koboSpan" id="kobo.822.4">
     The goal of this chapter was to teach you how to use these tools so you can perform this process in your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.823.1">
      own projects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.824.1">
     In the next chapters, we will shift more toward machine learning methods.
    </span>
    <a href="B22441_06.xhtml#_idTextAnchor087">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.825.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.826.1">
     will cover how to use spaCy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.827.1">
      with Transformers.
     </span>
    </span>
   </p>
  </div>
 </body></html>