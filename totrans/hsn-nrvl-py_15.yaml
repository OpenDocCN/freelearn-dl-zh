- en: Best Practices, Tips, and Tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践、技巧与窍门
- en: In this chapter, we provide some advice on best practices, tips, and tricks
    for writing and analyzing neuroevolution algorithms. By the end of this chapter,
    you will know how to start working with the problem at hand, how to tune the hyperparameters
    of the neuroevolution algorithm, how to use advanced visualization tools, and
    what metrics can be used to the analyze the algorithm's performance. Also, you
    will learn about the best coding practices for Python, which will help you in
    the implementation of your projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供了一些关于编写和分析神经进化算法的最佳实践、技巧和窍门的建议。到本章结束时，你将了解如何开始处理手头的问题，如何调整神经进化算法的超参数，如何使用高级可视化工具，以及可以使用哪些指标来分析算法的性能。此外，你还将了解
    Python 的最佳编码实践，这有助于你在项目实施中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Starting with problem analysis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从问题分析开始
- en: Selecting the optimal search optimization method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择最佳搜索优化方法
- en: Using advanced visualization tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级可视化工具
- en: Tuning hyperparameters and knowing what should be tuned
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整超参数并了解应调整的内容
- en: Understanding which performance metrics to collect
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解需要收集哪些性能指标
- en: Python coding tips and tricks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 编码技巧与窍门
- en: Starting with problem analysis
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从问题分析开始
- en: 'Starting with a proper analysis of the problem space is a recipe for success. Neuroevolution
    is lenient with programmer errors. Such mistakes are a part of the environment,
    and the evolution process can adapt to them. However, there is a particular category
    of mistakes that can hinder the evolution process from finding a successful solution:
    the numerical stability of the evolution process. Most types of activation function
    are designed to operate in a range of inputs between zero and one. As a result,
    too large or negative values do not have much influence on the evolution process.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从对问题空间的适当分析开始是成功的关键。神经进化对程序员错误宽容。这些错误是环境的一部分，进化过程可以适应它们。然而，有一种特定的错误类别可能会阻碍进化过程找到成功解决方案：进化过程的数值稳定性。大多数类型的激活函数都设计在零到一之间的输入范围内运行。因此，过大或负的值对进化过程的影响不大。
- en: Thus, you may need to preprocess the input data to avoid these numeric issues. Do
    not skip the analysis of the input data samples and data preprocessing steps.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能需要预处理输入数据以避免这些数值问题。不要跳过对输入数据样本和分析步骤的分析。
- en: Next, we discuss how to preprocess the input data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何预处理输入数据。
- en: Preprocessing data
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理数据
- en: Always examine the range of possible data inputs and check for outliers. If
    you find that the scale of one input parameter differs from another by an order
    of magnitude, you need to preprocess the input data samples. Otherwise, the input
    data features with higher magnitude will have such a significant impact on the
    training process that they will ultimately outweigh the contribution of the other
    input data features. However, the small signals produced by the data inputs with
    small magnitude are often crucial to finding a successful solution. Delicate input
    signals can characterize subtle but valuable traits in the underlying process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查可能的数据输入范围并查找异常值。如果你发现某个输入参数的规模与其他参数相差一个数量级，你需要预处理输入数据样本。否则，具有更高幅度的输入数据特征将对训练过程产生如此显著的影响，以至于它们最终会超过其他输入数据特征的贡献。然而，由小幅度数据输入产生的微小信号通常对于找到成功解决方案至关重要。微妙的输入信号可以表征底层过程中的微妙但宝贵的特性。
- en: Data standardization
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据标准化
- en: 'Most machine learning algorithms greatly benefit from input data that is normally
    distributed; that is, it has a mean and unit variance of zero. The common approach
    to scaling input data to have a zero mean and unit variance is given by the following
    formula:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数机器学习算法都从正态分布的输入数据中受益；也就是说，它具有零均值和单位方差。将输入数据缩放到具有零均值和单位方差的一般方法如下公式所示：
- en: '![](img/13bb8ddc-72e8-472e-b76e-4b115090c91b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13bb8ddc-72e8-472e-b76e-4b115090c91b.png)'
- en: Note that ![](img/85488aed-53c1-400e-8237-9a4847110a9b.png) is a scaled input
    score, ![](img/c6a79923-909c-43e0-8b69-29a757133063.png) is the input data sample, ![](img/dd2b4597-5c3a-40bf-b0de-42547a1f9881.png)
    is the mean of training samples, and ![](img/6551f51e-dd0f-451c-8716-d3a86ff7ae33.png)
    is the standard deviation of the training samples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，![](img/85488aed-53c1-400e-8237-9a4847110a9b.png) 是缩放后的输入分数，![](img/c6a79923-909c-43e0-8b69-29a757133063.png)
    是输入数据样本，![](img/dd2b4597-5c3a-40bf-b0de-42547a1f9881.png) 是训练样本的平均值，而 ![](img/6551f51e-dd0f-451c-8716-d3a86ff7ae33.png)
    是训练样本的标准差。
- en: 'You can use the Scikit-learn Python library to apply standard scaling to your
    input data samples. The following source code is an example of this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Scikit-learn Python 库对你的输入数据样本应用标准缩放。以下源代码是这一点的示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code, we first create the input data samples. After that, `StandardScaler` is
    used to center and scale the input samples. The results of the data transformation are
    shown in the last lines of the code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们首先创建输入数据样本。之后，使用 `StandardScaler` 对输入样本进行居中和缩放。数据转换的结果显示在代码的最后几行。
- en: Another method of data preprocessing is scaling features to fit into a specific
    range, which we discuss next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据预处理的另一种方法是缩放特征以适应特定范围，我们将在下一节中讨论。
- en: Scaling inputs to a range
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输入缩放到特定范围
- en: 'Scaling inputs to fit into a specific range is another method of data preprocessing.
    This method is an alternative to standardization. Range scaling produces data
    samples that lie within a given range between the minimum and maximum values.
    Often, this method is used to scale input data in a range between zero and one.
    You can use `MinMaxScaler` of the Scikit-learn Python library to scale data in
    a range, as shown in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入缩放到适应特定范围是数据预处理的另一种方法。这种方法是标准化的替代方案。范围缩放产生位于最小值和最大值之间给定范围内的数据样本。通常，这种方法用于将输入数据缩放到零和一之间的范围。你可以使用
    Scikit-learn Python 库中的 `MinMaxScaler` 来缩放数据，如下例所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code starts with the creation of a sample dataset and transforms it using
    the `MinMaxScaler` class. In the final output, you can see the results of the
    range-scaling transformation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从创建一个样本数据集开始，并使用 `MinMaxScaler` 类对其进行转换。在最终输出中，你可以看到范围缩放转换的结果。
- en: Sometimes, you need to have data samples with the same units. This type of preprocessing
    is called **normalization**. We discuss it in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要具有相同单位的数据样本。这种预处理类型被称为**归一化**。我们将在下一节中讨论它。
- en: Data normalization
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据归一化
- en: Often, your input data features have different units of measurement. For example,
    in the pole-balancing experiment, the cart position was measured in meters, the
    linear speed was in meters per second, and the angular speed was in radians per
    second. It is beneficial to normalize input data to simplify the comparison between
    input data features.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的输入数据特征有不同的度量单位。例如，在平衡杆实验中，小车位置以米为单位测量，线性速度以每秒米为单位，角速度以每秒弧度为单位。将输入数据归一化以简化输入数据特征之间的比较是有益的。
- en: The process of normalization effectively eliminates the units of measurement
    from the input data samples. After that, all the samples will be in the range
    between zero and one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 归一化过程有效地从输入数据样本中消除了度量单位。之后，所有样本都将位于零和一之间。
- en: 'There are different types of normalization in statistics. We already mentioned
    two methods: data standardization and data range scaling. Additionally, Scikit-learn
    provides a specialized transformer to perform data normalization, which scales
    individual samples to what is known as a unit norm. The following code demonstrates
    how to use it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学中有不同类型的归一化。我们已提到两种方法：数据标准化和数据范围缩放。此外，Scikit-learn 提供了一个专门的转换器来执行数据归一化，它将单个样本缩放到所谓的单位范数。以下代码演示了如何使用它：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code creates the test data sample and applies normalization to it using
    the `l2` norm and outputs the results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建测试数据样本，并使用`l2`范数对其进行归一化，然后输出结果。
- en: The Scikit-learn library provides the implementation of many other data preprocessing
    methods. It would be useful for you to get familiar with them. You can find an
    excellent tutorial at [https://scikit-learn.org/stable/modules/preprocessing.html](https://scikit-learn.org/stable/modules/preprocessing.html).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn 库提供了许多其他数据预处理方法的实现。熟悉它们对你会有所帮助。你可以在 [https://scikit-learn.org/stable/modules/preprocessing.html](https://scikit-learn.org/stable/modules/preprocessing.html)
    找到一篇优秀的教程。
- en: Understanding the problem domain
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解问题域
- en: In this book, some of the experiments we have discussed have been related to
    real processes in the physical world. To find successful solutions for such processes,
    you need to understand the underlying physical laws and principles. For example,
    the problem of balancing the cart-pole apparatus requires us to define a full
    set of equations of motion to write an accurate simulator of the task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们讨论的一些实验与物理世界的真实过程有关。为了找到此类过程的成功解决方案，您需要理解其背后的物理定律和原理。例如，平衡小车-杆装置的问题要求我们定义一组完整的运动方程，以编写准确的任务模拟器。
- en: Also for most tasks in the field of robotics, you need to write a simulator
    that uses the correct physical model and equations of the underlying apparatus.
    You need to fully comprehend the physics of the process to implement the simulator
    correctly. And even if you use a ready-made simulator, understanding the physical
    principles implemented in it is incredibly beneficial for you because understanding
    the dynamics of the real-world process allows you to tune the hyperparameters
    of the training algorithm appropriately.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于机器人领域的许多任务，您还需要编写一个使用底层装置的正确物理模型和方程的模拟器。您需要完全理解该过程的物理，以正确实现模拟器。即使您使用现成的模拟器，理解其中实现的物理原理对您来说也是极其有益的，因为理解现实世界过程的动力学允许您适当地调整训练算法的超参数。
- en: Writing good simulators
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写良好的模拟器
- en: When working on a specific problem, it is crucial to write an appropriate simulator
    that correctly implements the specifics of the simulated process. If you use such
    a simulator, you will be able to run long episodes of training, which is impossible
    when using direct inputs from physical devices.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理特定问题时，编写一个正确实现模拟过程具体细节的适当模拟器至关重要。如果您使用这样的模拟器，您将能够运行长时间的训练阶段，而使用来自物理设备的直接输入则不可能实现这一点。
- en: A good simulator should allow you to control the duration of the single time
    step of the simulated process. During neuroevolution, you need to evaluate each
    individual in the population against the given simulator. Thus, it makes sense
    during training to make the duration of a single time step as small as possible
    to increase the execution speed. On the other hand, when a solution has been found
    and you need to test it by hand, it would be beneficial if you could run the simulator
    at normal execution speed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模拟器应该允许您控制模拟过程的单步时间长度。在神经进化过程中，您需要将种群中的每个个体与给定的模拟器进行比较。因此，在训练过程中，使单步时间尽可能短以提高执行速度是有意义的。另一方面，当找到解决方案并需要手动测试时，如果能够以正常执行速度运行模拟器，将是有益的。
- en: Also, you can use the existing mature simulators for your projects, which can
    save you a lot of time. Familiarize yourself with well-established open source
    simulator packages. They often provide advanced physics simulation as well as
    a collection of premade building blocks for your virtual robots and environments.
    You can start your search at [https://github.com/cyberbotics/webots](https://github.com/cyberbotics/webots).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用现有的成熟模拟器来完成您的项目，这可以为您节省大量时间。熟悉那些经过良好建立的开源模拟器包。它们通常提供高级物理模拟以及为您的虚拟机器人和环境提供的预制的构建块集合。您可以从[https://github.com/cyberbotics/webots](https://github.com/cyberbotics/webots)开始搜索。
- en: Next, we discuss how to select the right search optimization method for your
    experiment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何为您的实验选择正确的搜索优化方法。
- en: Selecting the optimal search optimization method
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择最佳搜索优化方法
- en: 'In this book, we have presented you with two basic search optimization methods:
    goal-oriented search and Novelty Search. The former method is more straightforward
    to implement and easier to understand. However, Novelty Search is handy in cases
    where the fitness function has a deceptive landscape with many local optima traps.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们向您介绍了两种基本的搜索优化方法：目标导向搜索和新颖性搜索。前者方法更易于实现和理解。然而，新颖性搜索在适应度函数具有许多局部最优陷阱的欺骗性景观的情况下非常有用。
- en: In the next section, we briefly discuss both methods to remind you of the details
    and to help you choose which one to use in a given situation. We start with goal-oriented
    search.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要讨论这两种方法，以提醒您细节并帮助您在特定情况下选择使用哪一种。我们首先从目标导向搜索开始。
- en: Goal-oriented search optimization
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标导向搜索优化
- en: Goal-oriented search optimization is based on measuring the proximity of the
    solution to the ultimate goal. To calculate the average distance to the goal,
    it often uses a metric such as the mean squared error. Next, we discuss the particulars
    of the mean squared error metric.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目标导向搜索优化基于测量解决方案与最终目标之间的接近程度。为了计算到目标的平均距离，它通常使用均方误差等度量。接下来，我们将讨论均方误差度量的具体细节。
- en: Mean squared error
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均方误差
- en: 'The mean squared error is the average squared difference between the obtained
    results and the actual values. It''s given by the following formula:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 均方误差是获得的结果与实际值之间平均平方差的平均值。它由以下公式给出：
- en: '![](img/ccef67ed-0e0f-4b78-94a1-3681954b0c54.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccef67ed-0e0f-4b78-94a1-3681954b0c54.png)'
- en: Here ![](img/e19aaa43-32a0-4e11-9d20-2f402a953a2d.png) is the estimated value,
    and ![](img/ef7783ea-55f1-4fa6-93e5-436e18ae5a1d.png) is the actual value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里![图片](img/e19aaa43-32a0-4e11-9d20-2f402a953a2d.png)是估计值，而![图片](img/ef7783ea-55f1-4fa6-93e5-436e18ae5a1d.png)是实际值。
- en: We used a variation of the mean squared error to define an objective function
    for the XOR experiment. Next, we discuss goal-oriented metrics for problems related
    to positioning in Euclidean space.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用均方误差的变体来定义XOR实验的目标函数。接下来，我们将讨论与欧几里得空间中的定位相关问题的目标导向度量。
- en: Euclidean distance
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欧几里得距离
- en: Euclidean distance is an appropriate metric for tasks related to navigation
    through the Euclidean problem space. In the Euclidean problem space, we define
    the problem goal as a point with particular coordinates.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离是适用于与欧几里得问题空间中的导航相关的任务的适当度量。在欧几里得问题空间中，我们将问题目标定义为具有特定坐标的点。
- en: 'Using the Euclidean distance, it is easy to calculate the distance between
    the position of the navigational agent and the target point it is trying to reach.
    The following formula calculates the Euclidean distance between two vectors:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用欧几里得距离，可以轻松计算导航代理位置与其试图到达的目标点之间的距离。以下公式计算两个向量之间的欧几里得距离：
- en: '![](img/bc216503-a6b1-4b91-aa4e-807473a46650.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc216503-a6b1-4b91-aa4e-807473a46650.png)'
- en: Here ![](img/14d9fbed-2477-4e01-9c09-e7b526688945.png) is the Euclidean distance
    between the vector with agent position ![](img/198589e9-f5ec-4f59-ad3f-2d06418c83b2.png) and
    the vector with the ultimate goal of the agent, ![](img/2136a3bc-3fe7-4887-9cf1-d7347fff6c6a.png).
    We used this metric to define the objective function of an agent navigating through
    the maze in [Chapter 5](22365f85-3003-4b67-8e1e-cc89fa5e259b.xhtml), *Autonomous
    Maze Navigation*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里![图片](img/14d9fbed-2477-4e01-9c09-e7b526688945.png)是具有代理位置![图片](img/198589e9-f5ec-4f59-ad3f-2d06418c83b2.png)的向量与具有代理最终目标的向量![图片](img/2136a3bc-3fe7-4887-9cf1-d7347fff6c6a.png)之间的欧几里得距离。我们使用这个度量来定义[第5章](22365f85-3003-4b67-8e1e-cc89fa5e259b.xhtml)“自主迷宫导航”中代理在迷宫中导航的目标函数。
- en: However, the problem of autonomous maze navigation is caused by the deceptive
    fitness function landscape, which makes goal-oriented search optimization inefficient.
    Next, we discuss the Novelty Search optimization method, which is able to address
    this inefficiency.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自主迷宫导航的问题是由欺骗性的适应度函数景观引起的，这使得目标导向搜索优化效率低下。接下来，我们将讨论新颖搜索优化方法，它能够解决这种低效问题。
- en: Novelty Search optimization
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新颖搜索优化
- en: As we have mentioned, navigation through the maze is a deceptive problem that
    requires a different approach to define the fitness function. In [Chapter 5](22365f85-3003-4b67-8e1e-cc89fa5e259b.xhtml),
    *Autonomous Maze Navigation*, we presented you with a particular maze configuration
    that produces areas with strong local optima of goal-oriented fitness scores.
    As a result, the training process can be trapped inside these areas and will fail
    to produce a successful solution. The Novelty Search optimization method was devised
    to address issues with deceptive fitness function landscapes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，通过迷宫导航是一个具有欺骗性的问题，需要不同的方法来定义适应度函数。在[第5章](22365f85-3003-4b67-8e1e-cc89fa5e259b.xhtml)“自主迷宫导航”中，我们向您展示了一种特定的迷宫配置，该配置产生具有目标导向适应度分数强局部最优的区域。因此，训练过程可能会被困在这些区域中，并无法产生成功的解决方案。新颖搜索优化方法被设计用来解决欺骗性适应度函数景观的问题。
- en: 'Novelty Search rewards the novelty of a solution rather than its proximity
    to the ultimate goal. Furthermore, the novelty metric, which is used to calculate
    the fitness score of each solution, completely ignores the proximity of the solution
    to the ultimate goal. There are two popular approaches to calculate the novelty
    score:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 新颖性搜索奖励的是解决方案的新颖性，而不是其与最终目标的接近程度。此外，用于计算每个解决方案适应度分数的新颖性指标，完全忽略了解决方案与最终目标的接近程度。有两种流行的计算新颖性分数的方法：
- en: The novelty score is calculated from differences in the architectures of the
    solutions.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新颖性分数是从解决方案架构的差异中计算出来的。
- en: The novelty is calculated using the unique variations in the behavior of the
    solutions in the common behavioral space.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新颖性是通过在共同行为空间中解决方案行为的独特变化来计算的。
- en: The former calculates a difference between the encoding of the current solution
    and all the previous solutions. The latter compares the result produced by the
    current solution in the behavioral space to results produced by other solutions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前者计算当前解决方案编码与所有先前解决方案编码之间的差异。后者将当前解决方案在行为空间中产生的结果与其他解决方案产生的结果进行比较。
- en: We used novelty scores based on the uniqueness of the exposed behavior to define
    the fitness function of the maze solvers. The trajectory of the maze solver through
    the maze entirely determines the behavioral space of the agent and can be used
    to calculate the novelty score. In this case, the novelty score is the Euclidean
    distance between the trajectory vectors of the current solution and all other
    solutions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基于暴露行为独特性的新颖性分数来定义迷宫求解器的适应度函数。迷宫求解器在迷宫中的轨迹完全决定了代理的行为空间，并可用于计算新颖性分数。在这种情况下，新颖性分数是当前解决方案轨迹向量和所有其他解决方案轨迹向量之间的欧几里得距离。
- en: Now that we have discussed the importance of choosing an appropriate search
    optimization method, we can move on to the discussion of another important aspect
    of a successful experiment. You need to have a good visualization of the results
    of the experiment to get insights into its performance. Next, we discuss the visualization
    of results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了选择适当的搜索优化方法的重要性，我们可以继续讨论实验成功的另一个重要方面。你需要对实验结果有一个良好的可视化，以便对其性能有深入了解。接下来，我们将讨论结果的可视化。
- en: Advanced visualization
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级可视化
- en: Almost always, proper visualization of inputs and results is crucial to the
    success of your experiment. With proper visualization, you will get intuitive
    insights about what has gone wrong and what needs to be fixed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，正确地可视化输入和结果对于实验的成功至关重要。有了正确的可视化，你将获得关于出了什么问题以及需要修复什么的直观见解。
- en: Always try to visualize the simulator execution environment. Such visualization
    can save you hours of debugging when you get an unexpected result. Usually, with
    adequate visualization, you can see that something has gone wrong at a glance,
    such as a maze solver that got stuck up in a corner.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总是尝试可视化模拟器执行环境。这种可视化可以在你得到意外结果时节省你数小时的调试时间。通常，有了足够的可视化，你可以一眼看出哪里出了问题，例如一个在角落里卡住的迷宫求解器。
- en: With neuroevolution algorithms, you also need to visualize the performance of
    the genetic algorithm execution per generation. You need to visualize speciation
    from generation to generation to see whether the evolutionary process has stagnated.
    Stagnated evolution fails to create enough species to maintain healthy diversity
    among solvers. On the other hand, too many species hinder evolution by reducing
    the chances of reproduction between different organisms.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用神经进化算法时，你还需要可视化每一代的遗传算法执行性能。你需要从一代到一代地可视化物种形成，以查看进化过程是否已经停滞。停滞的进化无法创造出足够的物种来维持求解器之间的健康多样性。另一方面，过多的物种通过减少不同生物之间繁殖的机会来阻碍进化。
- en: Another important visualization allows us to see the topology of the produced
    phenotype **artificial neural network **(**ANN**). It is useful to visually inspect
    the topologies of the produced solution to check whether it satisfies our expectations.
    For example, when we discussed the modular retina problem in [Chapter 8](9f3dce4d-2cc7-4307-a704-bfcfe4ad56b4.xhtml),
    *ES-HyperNEAT and the Retina Problem*, it was beneficial to see that modular structures
    evolved in the topology of the successful solutions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的可视化使我们能够看到产生的表型**人工神经网络**（**ANN**）的拓扑结构。检查产生的解决方案的拓扑结构是否满足我们的期望是有用的。例如，当我们讨论第
    8 章[模块化视网膜问题](9f3dce4d-2cc7-4307-a704-bfcfe4ad56b4.xhtml)时，*ES-HyperNEAT 和视网膜问题*，看到模块化结构在成功解决方案的拓扑结构中进化是有益的。
- en: You need to familiarize yourself with the standard Python scientific plotting
    libraries to create adequate visualizations for the results of your experiments.
    It is essential to develop good practical skills with such visualization libraries
    as Matplotlib ([https://matplotlib.org](https://matplotlib.org/)) and Seaborn
    ([https://seaborn.pydata.org](https://seaborn.pydata.org/)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要熟悉标准的 Python 科学绘图库，以便为您的实验结果创建足够的可视化。掌握像 Matplotlib ([https://matplotlib.org](https://matplotlib.org/))
    和 Seaborn ([https://seaborn.pydata.org](https://seaborn.pydata.org/)) 这样的可视化库的实用技能是至关重要的。
- en: Next, we discuss the importance of hyperparameter tuning for the performance
    of the neuroevolution process.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论超参数调整对神经进化过程性能的重要性。
- en: Tuning hyperparameters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整超参数
- en: 'With proper tuning of the hyperparameters, you can make tremendous improvements
    in the training speed and efficiency of the neuroevolution process. Here are some
    practical tips:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当调整超参数，您可以极大地提高神经进化过程的训练速度和效率。以下是一些实用技巧：
- en: Do short runs with different seed values of the random number generator and
    note how the algorithm performance changes. After that, choose the seed value
    that gives the best performance and use it for the long runs.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的随机数生成器种子值进行短时间运行，并注意算法性能的变化。之后，选择给出最佳性能的种子值，并用于长时间运行。
- en: You can increase the number of species in the population by decreasing the compatibility
    threshold and by slightly increasing the value of the disjoint/excess weight coefficient.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过降低兼容性阈值和略微增加不交/过剩权重系数的值来增加种群中的物种数量。
- en: If the process of neuroevolution has stumbled while trying to find a solution,
    try to decrease the value of the NEAT survival threshold. This coefficient maintains
    the ratio of the best organisms within a population that got the chance to reproduce.
    By doing this, you increase the quality of the individuals allowed to reproduce
    based on their fitness score.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果神经进化过程在尝试找到解决方案时遇到了困难，尝试降低 NEAT 生存阈值的值。这个系数维持了种群中最佳生物体繁殖的机会比例。通过这样做，您可以根据其适应度分数提高允许繁殖的个体的质量。
- en: By increasing the maximum stagnation age, you can guarantee that species survive
    long enough to have a chance to introduce beneficial mutations in the later stages
    of evolution. Sometimes, such an operation can help to revitalize the neuroevolution
    process that stalls. However, you should always try with the small stagnation
    age values (15-20) to initiate a quick rotation of the species, and only increase
    this parameter significantly if all other tweaks fail.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加最大停滞年龄，您可以确保物种有足够的时间在进化的后期阶段引入有益的突变。有时，这样的操作可以帮助恢复停滞的神经进化过程。然而，您应该始终尝试使用小的停滞年龄值（15-20）来启动物种的快速轮换，并且只有在所有其他调整都失败的情况下才显著增加此参数。
- en: After hyperparameter adjustments, do a short run for a few tens of generations
    to see the performance change dynamics. Pay special attention to the number of
    species—there should be at least more than one species in the population. Too
    many species is also a bad sign. Usually, 5 to 20 species is a good range.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调整超参数后，进行几十代的短时间运行，以观察性能变化动态。特别关注物种数量——种群中至少应该有多个物种。物种过多也是一个不良信号。通常，5 到 20
    个物种是一个良好的范围。
- en: Use the visualization of the experiment results to get quick insights into the
    performance of the experiment. Never pass up the chance to visualize the ANN topology
    of the discovered solutions. These visualizations can give you priceless insights
    on how to tune up the neuroevolutionary process.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实验结果的可视化来快速了解实验的性能。永远不要错过可视化发现解决方案的ANN拓扑结构的机会。这些可视化可以给你提供无价的见解，告诉你如何调整神经进化过程。
- en: Don't waste your time on long evolutionary runs. If the experiment fails to
    find a successful solution in 1,000 generations, there's a good chance that something
    is wrong with your code or the library you are using. For most simple problems,
    a successful solution can be found even in 100 generations.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要浪费时间去进行长时间的进化运行。如果实验在1,000代内未能找到成功解决方案，那么很可能你的代码或你使用的库存在问题。对于大多数简单问题，成功解决方案甚至可以在100代内找到。
- en: The population size is a critical parameter of the evolutionary process. With
    large populations, you get great diversity from the very beginning of the process,
    which boosts the process. However, large populations are hard to compute. Thus,
    there is always a trade-off between population size and computational cost. As
    a rule of thumb, if you struggle to find other suitable hyperparameters, try to
    increase the population size and see if it helps. But be ready to wait extra time
    for the neuroevolution process to complete.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种群大小是进化过程中的一个关键参数。在过程一开始，较大的种群就能带来很大的多样性，从而推动过程的发展。然而，大种群难以计算。因此，种群大小和计算成本之间总是存在权衡。作为一个经验法则，如果你在寻找其他合适的超参数时遇到困难，尝试增加种群大小，看看是否有所帮助。但要做好准备，等待额外的神经进化过程完成时间。
- en: Always print the debug information, allowing you to restart the experiment from
    any stage of evaluation. It is always painful when you find a solution after two
    days of computation, but due to some programming mistakes your program crashes
    when trying to output the congratulations message. You need to output at least
    the random seed value at the beginning of each trial. This can guarantee that
    you can accurately recreate all the generations of the evolution in case of failure.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是打印调试信息，这样你可以从评估的任何阶段重新启动实验。当你计算两天后发现解决方案，但由于一些编程错误，你的程序在尝试输出祝贺信息时崩溃，这总是令人痛苦。你需要在每个试验的开始至少输出随机种子值。这可以保证在失败的情况下，你可以准确地重新创建所有进化的代数。
- en: Do not underestimate the importance of hyperparameter tuning. Even taking into
    account that the neuroevolution process can handle many programming mistakes,
    choosing the right hyperparameters can significantly improve the efficiency of
    the process. As a result, you will be able to find a successful solution in hundreds
    of generations instead of thousands or more.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不要低估超参数调整的重要性。即使考虑到神经进化过程可以处理许多编程错误，选择正确的超参数也可以显著提高过程的效率。结果，你将能够在数百代而不是数千代或更多代内找到成功解决方案。
- en: To compare the performance of the different solutions, you need to use appropriate
    performance metrics, which we discuss next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较不同解决方案的性能，你需要使用适当的性能指标，我们将在下面讨论。
- en: Performance metrics
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能指标
- en: After a successful solution is found, it is crucial to compare it with other
    solutions to estimate how good it is. There are many important statistical metrics
    that compare different models.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到成功解决方案之后，将其与其他解决方案进行比较以估计其好坏至关重要。有许多重要的统计指标可以比较不同的模型。
- en: Become familiar with concepts such as precision score, recall score, F1 score,
    ROC AUC, and accuracy. Understanding these metrics will help you to compare the
    results produced by different models in various classification tasks. Next, we
    give a brief overview of these metrics.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉精度分数、召回分数、F1分数、ROC AUC和准确率等概念。理解这些指标将帮助你比较不同模型在各种分类任务中产生的结果。接下来，我们将简要概述这些指标。
- en: Precision score
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精度分数
- en: 'The precision score attempts to answer the question of how many among the positive
    identifications are actually correct. The precision score can be calculated as
    follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 精度分数试图回答有多少个阳性识别实际上是正确的。精度分数可以按以下方式计算：
- en: '![](img/39c39b2d-035b-43e9-8372-a535fd670b69.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39c39b2d-035b-43e9-8372-a535fd670b69.png)'
- en: TP is the true positives, and FP is the false positives.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: TP是真正阳性，FP是假阳性。
- en: Recall score
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆分数
- en: 'The recall score answers the question of how many actual positives were identified
    correctly. The recall score can be given with the following formula:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 召回度分数回答了有多少实际正样本被正确识别的问题。召回度分数可以用以下公式给出：
- en: '![](img/be020c54-1660-43ad-973f-46acac16effc.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be020c54-1660-43ad-973f-46acac16effc.png)'
- en: TP is the true positives, and FN is the false negatives.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: TP是真正例，FN是假负例。
- en: F1 score
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F1分数
- en: 'The F1 score is a weighted average between the precision and recall scores.
    The best value of the F1 score is one, and the worst is zero. The F1 score allows
    measuring classification accuracy specific to a particular class. It can be defined
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: F1分数是精确度和召回度分数的加权平均值。F1分数的最佳值是1，最差值是0。F1分数允许测量特定类别的分类准确度。它可以定义为以下：
- en: '![](img/49c867e3-4a74-4078-93bd-428b49e683b1.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49c867e3-4a74-4078-93bd-428b49e683b1.png)'
- en: Here ![](img/42109623-2159-48c7-8c3f-a93054e4a0f5.png) is the precision score,
    and ![](img/967b6214-cb80-4ddd-bade-8097bc89c112.png) is the recall score relative
    to a specific positive class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里![图片](img/42109623-2159-48c7-8c3f-a93054e4a0f5.png)是精确度分数，而![图片](img/967b6214-cb80-4ddd-bade-8097bc89c112.png)是与特定正类相关的召回度分数。
- en: In the next section, we will look at the**Receiver Operating Characteristic**
    (**ROC**) curve and **Area Under the Curve** (**AUC**).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨**接收者操作特征**（**ROC**）曲线和**曲线下面积**（**AUC**）。
- en: ROC AUC
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROC AUC
- en: We create the ROC by plotting true positive rates against false positive rates
    at different thresholds. It shows the performance of the classification model
    at different thresholds.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在不同阈值下绘制真正例率与假正例率来创建ROC曲线。它显示了分类模型在不同阈值下的性能。
- en: 'The **true positive rate** (**TPR**) is a synonym of recall, which we discussed
    earlier. It can be given by this formula:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**真正例率**（**TPR**）是召回的同义词，我们之前讨论过。它可以由以下公式给出：'
- en: '![](img/bb8832b2-2521-4823-b658-e1b62c928f99.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb8832b2-2521-4823-b658-e1b62c928f99.png)'
- en: 'The false positive rate is calculated as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假正例率的计算方法如下：
- en: '![](img/9a3b7842-92a1-42a1-a859-3314c28e4fd7.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a3b7842-92a1-42a1-a859-3314c28e4fd7.png)'
- en: TN is the true negatives.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: TN代表真正例。
- en: 'The AUC allows us to estimate the discrimination power of the classification
    model, that is, the ability of the model to correctly rank the random positive
    points more highly than the random negative points. Here is an example of an ROC
    curve:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: AUC允许我们估计分类模型的判别能力，即模型正确对随机正样本点进行排序高于随机负样本点的能力。以下是一个ROC曲线的示例：
- en: '![](img/ee44a12d-d1a8-43a0-ba60-0e96da607c86.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee44a12d-d1a8-43a0-ba60-0e96da607c86.png)'
- en: The ROC curve example
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ROC曲线示例
- en: In the graph, you can see the ROC curve example. The larger the AUC is, the
    more accurate the classifier model. The dashed line shows the worst classifier
    accuracy. In general, the closer the ROC curve is to the upper-left corner, the
    better the performance of the classification model.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，你可以看到ROC曲线的示例。AUC越大，分类器模型越准确。虚线表示最差的分类器准确度。一般来说，ROC曲线越接近左上角，分类模型的性能越好。
- en: Accuracy
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准确度
- en: 'Accuracy is a metric measuring how many correct predictions our model was able
    to produce. The accuracy is given by the following formula:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 准确度是一个衡量我们的模型能够产生多少正确预测的指标。准确度由以下公式给出：
- en: '![](img/299fba72-dbb7-4085-b6f4-120015f8d9d2.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/299fba72-dbb7-4085-b6f4-120015f8d9d2.png)'
- en: FP is the false positives, and FN is the false negatives.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: FP代表假正例，FN代表假负例。
- en: More details about described metrics can be found at [https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html](https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于描述的指标详情可以在[https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html](https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html)找到。
- en: Next, we discuss Python coding tips.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论Python编码技巧。
- en: Python coding tips and tricks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python编码技巧和窍门
- en: Having decided to work with Python, it is vital to learn the best coding practices
    of the language. Here, we provide you with some tips and give you directions to
    continue with self-learning.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用Python后，学习该语言的最佳编码实践至关重要。在这里，我们为您提供一些建议，并指导您继续自学。
- en: Coding tips and tricks
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码技巧和窍门
- en: 'The following coding tips and tricks will help you master Python:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下编码技巧和窍门将帮助您掌握Python：
- en: You should learn how to use the popular machine learning libraries, such as
    NumPy ([https://numpy.org](https://numpy.org/)), pandas ([https://pandas.pydata.org](https://pandas.pydata.org/)),
    and Scikit-learn ([https://scikit-learn.org/stable/](https://scikit-learn.org/stable/)).
    Mastering these libraries will give you tremendous power in data manipulation
    and analysis. This will help you to avoid many mistakes, and enable easy debugging
    of the results collected from the experiments.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该学习如何使用流行的机器学习库，例如 NumPy ([https://numpy.org](https://numpy.org/))、pandas
    ([https://pandas.pydata.org](https://pandas.pydata.org/)) 和 Scikit-learn ([https://scikit-learn.org/stable/](https://scikit-learn.org/stable/))。掌握这些库将在数据处理和分析方面给您带来巨大的力量。这将帮助您避免许多错误，并使从实验中收集的结果易于调试。
- en: Learn about the object-oriented coding paradigm. This will allow you to write
    a clean and maintainable source code that is easy to understand. You can start
    at [https://www.datacamp.com/community/tutorials/python-oop-tutorial](https://www.datacamp.com/community/tutorials/python-oop-tutorial).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解面向对象的编程范式。这将使您能够编写清晰且易于维护的源代码，易于理解。您可以从 [https://www.datacamp.com/community/tutorials/python-oop-tutorial](https://www.datacamp.com/community/tutorials/python-oop-tutorial)
    开始。
- en: Do not write everything into one huge function. Break your code into smaller
    reusable blocks implemented as functions or classes that can be reused in multiple
    projects and easily debugged.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将所有内容都写在一个巨大的函数中。将您的代码分解成更小的可重用块，实现为函数或类，这些函数或类可以在多个项目中重用，并且易于调试。
- en: Print the relevant debug output to understand what is going on in your implementation.
    Having enough debugging outputs allows you to understand what is going wrong with
    the execution.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印相关的调试输出以了解您的实现中正在发生什么。足够的调试输出允许您了解执行过程中出现的问题。
- en: Write comments related to the functions, classes, and intricate places in your
    source code. Good comments can significantly help in code understandability. Writing
    the comments before starting the implementation also helps you to clarify your
    thoughts.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的源代码中编写与函数、类和复杂位置相关的注释。好的注释可以显著帮助代码的可理解性。在开始实现之前编写注释也有助于您澄清思路。
- en: When writing comments to the function, describe all the input and output parameters
    and their default values, if any exist.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给函数编写注释时，描述所有输入和输出参数及其默认值（如果有的话）。
- en: If you decide to continue with Python, spend some time learning about the Python
    standard libraries. Python is a mature programming language with many utility
    functions embedded into its standard libraries. It also has many functions allowing
    advanced data manipulations, which can be used in machine learning tasks. More
    details about standard Python libraries can be found at [https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你决定继续使用 Python，花些时间学习 Python 的标准库。Python 是一种成熟的编程语言，其中包含了许多嵌入到其标准库中的实用函数。它还提供了许多高级数据处理功能，这些功能可用于机器学习任务。更多关于标准
    Python 库的详细信息可以在 [https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html)
    找到。
- en: Follow the standard Python source code conventions when giving names to variables
    and classes. Adhering to the standard naming conventions makes your code more
    readable and easy to understand for anyone experienced with Python. You can find
    more details at [https://docs.python-guide.org/writing/style/](https://docs.python-guide.org/writing/style/) and [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给变量和类命名时，遵循标准的 Python 源代码约定。遵循标准命名约定可以使您的代码对熟悉 Python 的人来说更易于阅读和理解。更多详细信息可以在
    [https://docs.python-guide.org/writing/style/](https://docs.python-guide.org/writing/style/)
    和 [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
    找到。
- en: Make yourself familiar with modern version control systems, such as Git. A **Version
    Control System** (**VCS**) is a potent tool at your disposal that may save you
    hours and even days of attempts to recover your lost work caused by a hard drive
    crash. You can learn about Git at [https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf](https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf) and [https://www.atlassian.com/git/tutorials](https://www.atlassian.com/git/tutorials).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使自己熟悉现代版本控制系统，如 Git。**版本控制系统**（**VCS**）是您可用的强大工具，可能会为您节省数小时甚至数天的时间，以恢复因硬盘故障而丢失的工作。您可以在
    [https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf](https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf)
    和 [https://www.atlassian.com/git/tutorials](https://www.atlassian.com/git/tutorials)
    了解 Git。
- en: Learn about online code repositories such as GitHub ([https://github.com](https://github.com))
    and Bitbucket ([https://bitbucket.org](https://bitbucket.org/)), where you can
    share your source code and study the source code of other data scientists.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在线代码仓库，例如GitHub ([https://github.com](https://github.com)) 和 Bitbucket ([https://bitbucket.org](https://bitbucket.org/))，在这些平台上你可以分享你的源代码并研究其他数据科学家的源代码。
- en: Another important aspect of writing good implementations is setting up the working
    environment correctly and using adequate programming tools.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好实现的重要方面之一是正确设置工作环境并使用适当的编程工具。
- en: Working environment and programming tools
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作环境和编程工具
- en: It is always a good idea to use one of the mature Python package managers, such
    as the Anaconda Distribution, to set up your working environment properly. As
    an additional benefit, you will get a lot of free scientific and machine learning
    packages that are ready to be installed with a single command. Furthermore, the
    Anaconda Distribution handles the management of all indirect dependencies and
    helps you keep all your packages up to date. You can find the Anaconda Distribution
    at [https://www.anaconda.com/distribution/](https://www.anaconda.com/distribution/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用成熟的Python包管理器之一，如Anaconda Distribution，来正确设置你的工作环境是个好主意。作为额外的好处，你将获得大量免费的科学和机器学习包，这些包可以一键安装。此外，Anaconda
    Distribution处理所有间接依赖项的管理，并帮助你保持所有包的最新状态。你可以在[https://www.anaconda.com/distribution/](https://www.anaconda.com/distribution/)找到Anaconda
    Distribution。
- en: 'Always create a new virtual Python environment for each of your experiments.
    After that, if something goes wrong with dependencies, you will be able to clean
    everything with one command and start from scratch. The new Python environment
    can be created with the Anaconda Distribution as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个实验中始终为你的实验创建一个新的虚拟Python环境。之后，如果依赖项出现问题，你将能够通过一条命令清理一切并从头开始。可以使用以下方式使用Anaconda
    Distribution创建新的Python环境：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When creating a new environment, always specify the exact Python version you
    are planning to use in it. Providing the exact version will help you to avoid
    many surprises caused by incompatibility. The Python version can be defined for
    the new environment as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新环境时，始终指定你计划在其中使用的确切Python版本。提供确切版本将帮助你避免由不兼容性引起的大量意外。可以按以下方式为新环境定义Python版本：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you need to use a new dependency in your project, first check that the appropriate
    installation package exists in Anaconda Cloud. By using libraries from Anaconda
    Cloud, you can avoid the problems of indirect dependency installation. Furthermore,
    some frameworks, such as TensorFlow, require the installation of additional system
    drivers and headers. This task can be very cumbersome and require additional expertise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在项目中使用新的依赖项，首先检查Anaconda Cloud中是否存在适当的安装包。通过使用Anaconda Cloud中的库，你可以避免间接依赖安装的问题。此外，一些框架，如TensorFlow，需要安装额外的系统驱动程序和头文件。这项任务可能非常繁琐，并需要额外的专业知识。
- en: Use a good code editor that supports code completion, documentation browsing,
    and maintaining virtual Python environments. A good editor to start with is Visual
    Studio Code—a free editor provided by Microsoft. You can find it at [https://code.visualstudio.com](https://code.visualstudio.com/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用支持代码补全、文档浏览和维护虚拟Python环境的良好代码编辑器。一个好的起点是Visual Studio Code——由微软提供的免费编辑器。你可以在[https://code.visualstudio.com](https://code.visualstudio.com/)找到它。
- en: Make yourself familiar with modern Linux systems, such as Ubuntu. Most machine
    learning libraries are much easier to use with Linux. This is especially true
    for libraries that use GPU acceleration. More details about Ubuntu and its installation
    can be found at [https://ubuntu.com](https://ubuntu.com/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使自己熟悉现代Linux系统，如Ubuntu。大多数机器学习库在Linux上使用起来都更容易。这对于使用GPU加速的库尤其如此。有关Ubuntu及其安装的更多详细信息，请参阅[https://ubuntu.com](https://ubuntu.com/)。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided you with practical tips that we hope will make
    your life easier. You learned about the standard methods of data preprocessing
    and about conventional statistical metrics that can be used to evaluate the performance
    of the models you created. Finally, you learned how to improve your coding skills
    and where to look for additional information about Python and machine learning
    topics.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为你提供了实用的技巧，希望这些技巧能让你生活更轻松。你了解了数据预处理的标准化方法，以及可以用来评估你创建的模型性能的传统统计指标。最后，你学习了如何提高你的编码技能以及在哪里寻找有关Python和机器学习主题的更多信息。
- en: In the next chapter, we will look at a few concluding remarks based on what
    we have learned in the book and where we can use the concepts we have learned
    in the future.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾一些基于我们在书中所学到的内容以及我们将来可以在哪里应用我们所学概念的总结性评论。
