- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">5</st>
- en: <st c="2">Managing Security in RAG Applications</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">在RAG应用中管理安全</st>
- en: <st c="39">Depending on the environment in which you are building your</st>
    **<st c="100">retrieval-augmented generation</st>** <st c="130">(</st>**<st c="132">RAG</st>**<st
    c="135">) application, security failures can lead to legal liability, reputation
    damage, and costly</st> <st c="228">service disruptions.</st> <st c="249">RAG
    systems present unique security risks, primarily due to their reliance on external
    data sources for enhancing content generation.</st> <st c="383">To address these
    risks, we will dive deep into the world of RAG application security, exploring
    both the security-related advantages and potential risks associated with</st>
    <st c="552">this technology.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39">根据你构建</st> **<st c="100">检索增强生成</st>** <st c="130">(</st>**<st c="132">RAG</st>**<st
    c="135">) 应用所处的环境，安全故障可能导致法律责任、声誉损害和昂贵的</st> <st c="228">服务中断。</st> <st c="249">RAG系统面临独特的安全风险，这主要归因于它们依赖外部数据源来增强内容生成。</st>
    <st c="383">为了应对这些风险，我们将深入探讨RAG应用安全的世界，探讨与这项技术相关的安全优势以及潜在风险。</st>
- en: <st c="568">In this chapter, the topics that we will cover include</st> <st
    c="624">the following:</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="568">在本章中，我们将涵盖以下主题：</st> <st c="624">以下内容：</st>
- en: <st c="638">How RAG can be leveraged as a</st> <st c="669">security solution</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="638">如何利用RAG作为</st> <st c="669">安全解决方案</st>
- en: <st c="686">RAG</st> <st c="691">security challenges</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="686">RAG</st> <st c="691">安全挑战</st>
- en: <st c="710">Red teaming</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="710">红队攻击</st>
- en: <st c="722">Common areas to target with</st> <st c="751">red teaming</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="722">针对</st> <st c="751">红队攻击</st> 的常见目标区域
- en: <st c="762">Code lab 5.1 – Securing</st> <st c="787">your code</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="762">代码实验室5.1 – 保护</st> <st c="787">你的代码</st>
- en: <st c="796">Code lab 5.2 – Red</st> <st c="816">team attack!</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="796">代码实验室5.2 – 红队</st> <st c="816">攻击！</st>
- en: <st c="828">Code lab 5.3 – Blue</st> <st c="849">team defend!</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="828">代码实验室5.3 – 蓝队</st> <st c="849">防御！</st>
- en: <st c="861">By the end of the chapter, you will have a comprehensive understanding
    of the security landscape surrounding RAG applications, equipped with practical
    strategies and techniques to safeguard your systems and data.</st> <st c="1075">As
    we embark on this journey, remember that security is an ongoing process that requires
    constant vigilance and adaptation in the face of ever-evolving threats.</st> <st
    c="1236">Let’s dive in and explore how to build secure, trustworthy, and robust
    RAG applications that harness the power of generative artificial intelligence
    (AI) while prioritizing the safety and privacy of users and</st> <st c="1445">businesses
    alike.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="861">到本章结束时，你将全面了解围绕RAG应用的安全格局，并配备有实际策略和技术来保护你的系统和数据。</st> <st c="1075">在我们开始这段旅程时，请记住，安全是一个持续的过程，需要面对不断演变的威胁保持持续的警惕和适应。</st>
    <st c="1236">让我们深入探讨如何构建安全、值得信赖且强大的RAG应用，这些应用利用生成人工智能（AI）的力量，同时优先考虑用户和企业的安全和隐私。</st>
- en: <st c="1462">Note</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1462">注意</st>
- en: <st c="1467">As with any other technical application that has users and technical
    infrastructure, there are numerous general security concerns that you must address.</st>
    <st c="1621">Given the scope of this chapter and book, our focus is on security
    aspects that are specific to</st> <st c="1717">RAG applications.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1467">与任何其他具有用户和技术基础设施的技术应用一样，你必须解决许多一般性的安全关注点。</st> <st c="1621">鉴于本章和本书的范围，我们的重点是针对</st>
    <st c="1717">RAG应用的安全方面。</st>
- en: <st c="1734">Technical requirements</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1734">技术要求</st>
- en: <st c="1757">The code for this chapter is placed in the following GitHub</st>
    <st c="1818">repository:</st> [<st c="1830">https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_05</st>](https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_05)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1757">本章的代码放置在以下GitHub</st> <st c="1818">仓库中：</st> [<st c="1830">https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_05</st>](https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_05)
- en: <st c="1927">How RAG can be leveraged as a security solution</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1927">如何利用RAG作为安全解决方案</st>
- en: <st c="1975">Let’s start</st> <st c="1987">with the most positive security aspect
    of RAG.</st> <st c="2035">RAG can actually be considered a solution to mitigate
    security concerns, rather than cause them.</st> <st c="2132">If done right, you
    can limit data access via user, ensure more reliable responses, and provide more
    transparency</st> <st c="2245">of sources.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1975">让我们从RAG最积极的安全方面开始。</st> <st c="1987">RAG实际上可以被视为缓解安全问题的解决方案，而不是引发它们。</st>
    <st c="2035">如果做得正确，您可以通过用户限制数据访问，确保更可靠的响应，并提高来源的透明度。</st> <st c="2132">通过正确实施，您可以限制用户的数据访问，确保更可靠的响应，并提高来源的透明度。</st>
    <st c="2245">来源的透明度。</st>
- en: <st c="2256">Limiting data</st>
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2256">限制数据</st>
- en: <st c="2270">RAG applications</st> <st c="2288">may be a relatively new concept,
    but you can still apply the same authentication and database-based access approaches
    you can with web and similar types of applications.</st> <st c="2458">This provides
    the same level of security you can apply in these other types of applications.</st>
    <st c="2551">By implementing user-based access controls, you can restrict the
    data that each user or user group can retrieve through the RAG system.</st> <st
    c="2687">This ensures that sensitive information is only accessible to authorized
    individuals.</st> <st c="2773">Additionally, by leveraging secure database connections
    and encryption techniques, you can safeguard the data at rest and in transit,
    preventing unauthorized access or</st> <st c="2941">data breaches.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2270">RAG应用</st> <st c="2288">可能是一个相对较新的概念，但您仍然可以应用与Web和类似类型的应用相同的身份验证和基于数据库的访问方法。</st>
    <st c="2458">这提供了在其他这些类型的应用中可以应用的安全级别。</st> <st c="2551">通过实施基于用户的访问控制，您可以限制每个用户或用户组通过RAG系统检索的数据。</st>
    <st c="2687">这确保了敏感信息只能由授权人员访问。</st> <st c="2773">此外，通过利用安全的数据库连接和加密技术，您可以保护静态和传输中的数据，防止未经授权的访问或数据泄露。</st>
    <st c="2941">数据泄露。</st>
- en: <st c="2955">Ensuring the reliability of generated content</st>
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2955">确保生成内容可靠性</st>
- en: <st c="3001">One of the</st> <st c="3013">key benefits of RAG is its ability
    to mitigate inaccuracies in generated content.</st> <st c="3095">By allowing applications
    to retrieve proprietary data at the point of generation, the risk of producing
    misleading or incorrect responses is substantially reduced.</st> <st c="3259">Feeding
    the most current data available through your RAG system helps to mitigate inaccuracies
    that might</st> <st c="3365">otherwise occur.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3001">RAG的一个关键好处是它能够减轻生成内容中的不准确之处。</st> <st c="3013">通过允许应用程序在生成时检索专有数据，产生误导或不正确响应的风险大大降低。</st>
    <st c="3095">通过您的RAG系统提供最新数据，有助于减轻可能发生的错误。</st> <st c="3259">通过您的RAG系统提供最新数据，有助于减轻可能发生的错误。</st>
    <st c="3365">错误。</st>
- en: <st c="3381">With RAG, you</st> <st c="3395">have control over the data sources
    used for retrieval.</st> <st c="3451">By carefully curating and maintaining high-quality,
    up-to-date datasets, you can ensure that the information used to generate responses
    is accurate and reliable.</st> <st c="3613">This is particularly important in
    domains where precision and correctness are critical, such as healthcare, finance,
    or</st> <st c="3733">legal applications.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3381">使用RAG，您</st> <st c="3395">可以控制用于检索的数据源。</st> <st c="3451">通过精心策划和维护高质量、最新的数据集，您可以确保用于生成响应的信息是准确和可靠的。</st>
    <st c="3613">这在精度和正确性至关重要的领域尤为重要，例如医疗保健、金融或法律应用。</st>
- en: <st c="3752">Maintaining transparency</st>
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3752">保持透明度</st>
- en: <st c="3777">RAG makes it easier to</st> <st c="3800">provide transparency in
    the generated content.</st> <st c="3848">By incorporating data such as citations
    and references to the retrieved data sources, you can increase the credibility
    and trustworthiness of the</st> <st c="3994">generated responses.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3777">RAG使提供生成内容的透明度变得更加容易。</st> <st c="3800">通过整合诸如引用和检索数据源引用之类的数据，您可以提高生成响应的可信度和可靠性。</st>
    <st c="3848">通过正确实施，您可以限制用户的数据访问，确保更可靠的响应，并提高来源的透明度。</st> <st c="3994">生成响应的可信度和可靠性。</st>
- en: <st c="4014">When a RAG system generates a response, it can include links or
    references to the specific data points or documents used in the generation process.</st>
    <st c="4163">This allows users to verify the information and trace it back to
    its original sources.</st> <st c="4250">By providing this level of transparency,
    you can build trust with your users and demonstrate the reliability of the</st>
    <st c="4366">generated content.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4014">当RAG系统生成响应时，它可以包括生成过程中使用的特定数据点或文档的链接或引用。</st> <st c="4163">这使用户能够验证信息并将其追溯到其原始来源。</st>
    <st c="4250">通过提供这种级别的透明度，您可以与用户建立信任，并展示生成内容的可靠性。</st> <st c="4366">生成的内容。</st>
- en: <st c="4384">Transparency in RAG can also help with accountability and auditing.</st>
    <st c="4453">If there are any concerns or disputes regarding the generated content,
    having clear citations and references makes it easier to investigate and resolve
    any issues.</st> <st c="4617">This transparency also facilitates compliance with
    regulatory requirements or industry standards that may require traceability</st>
    <st c="4744">of information.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4384">RAG的透明度还可以帮助实现问责制和审计。</st> <st c="4453">如果有任何关于生成内容的担忧或争议，清晰的引用和参考文献使得调查和解决任何问题变得更加容易。</st>
    <st c="4617">这种透明度也有助于符合可能需要信息可追溯性的监管要求或行业标准。</st>
- en: <st c="4759">That covers many of the security-related benefits you can achieve
    with RAG.</st> <st c="4836">However, there are some security challenges associated
    with RAG as well.</st> <st c="4909">Let’s discuss these</st> <st c="4929">challenges
    next.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4759">这涵盖了您可以通过RAG实现的大多数与安全相关的益处。</st> <st c="4836">然而，RAG也存在一些安全挑战。</st>
    <st c="4909">让我们接下来讨论这些</st> <st c="4929">挑战。</st>
- en: <st c="4945">RAG security challenges</st>
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="4945">RAG安全挑战</st>
- en: <st c="4969">RAG applications face</st> <st c="4991">unique security challenges
    due to their reliance on</st> **<st c="5044">large language models</st>** <st
    c="5065">(</st>**<st c="5067">LLMs</st>**<st c="5071">) and</st> <st c="5077">external
    data sources.</st> <st c="5101">Let’s start with</st> <st c="5117">the</st> **<st
    c="5122">black box challenge</st>**<st c="5141">, highlighting the relative difficulty
    in understanding how an LLM determines</st> <st c="5219">its response.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4969">RAG应用由于依赖</st> <st c="4991">大型语言模型</st> **<st c="5044">（LLMs）**
    <st c="5065">**（</st>****<st c="5067">LLMs</st>****<st c="5071">）**<st c="5077">和外部数据源</st>，面临着独特的安全挑战。</st>
    <st c="5101">让我们从</st> <st c="5117">以下</st> **<st c="5122">黑盒挑战****<st c="5141">开始，强调理解LLMs如何确定其响应的相对难度。</st>
- en: <st c="5232">LLMs as black boxes</st>
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5232">LLMs作为黑盒</st>
- en: <st c="5252">When</st> <st c="5257">something is in a dark, black box with the
    lid closed, you cannot see what is going on in there!</st> <st c="5355">That is
    the idea behind the black box when discussing LLMs, meaning there is a lack of
    transparency and interpretability in how these complex AI models process input
    and generate output.</st> <st c="5542">The most popular LLMs are also some of
    the largest, meaning they can have more than 100 billion parameters.</st> <st
    c="5650">The intricate interconnections and weights of these parameters make it
    difficult to understand how the model arrives at a</st> <st c="5772">particular
    output.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5252">当</st> <st c="5257">某物处于一个黑暗、关闭盖子的黑盒中时，您无法看到里面发生了什么！</st> <st c="5355">这就是讨论LLMs时黑盒的概念，意味着在这些复杂的AI模型处理输入和生成输出方面缺乏透明度和可解释性。</st>
    <st c="5542">最受欢迎的LLMs也是一些最大的，这意味着它们可以拥有超过1000亿个参数。</st> <st c="5650">这些参数的复杂互联和权重使得理解模型如何得出特定的输出变得困难。</st>
- en: <st c="5790">While the black box aspects of LLMs do not directly create a security
    problem, it does make it more difficult to identify solutions to problems when
    they occur.</st> <st c="5952">This makes it difficult to trust LLM outputs, which
    is a critical factor in most of the applications for LLMs, including RAG applications.</st>
    <st c="6091">This lack of transparency makes it more difficult to debug issues
    you might have in building an RAG application, which increases the risk of having
    more</st> <st c="6244">security issues.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5790">虽然LLMs的黑盒特性本身不会直接造成安全问题，但它确实使得在问题发生时识别解决方案变得更加困难。</st> <st c="5952">这使得人们难以信任LLMs的输出，这对于LLMs的大部分应用来说都是一个关键因素，包括RAG应用。</st>
    <st c="6091">这种缺乏透明度使得在构建RAG应用时调试可能出现的问题变得更加困难，从而增加了出现更多安全问题的风险。</st> <st c="6244">安全问题。</st>
- en: <st c="6260">There is a lot of research and effort in the academic field to
    build models that are more transparent and interpretable, called</st> **<st c="6389">explainable
    AI</st>**<st c="6403">. Explainable AI aims at making the operations of</st> <st
    c="6453">AI systems transparent and understandable.</st> <st c="6496">It can involve
    tools, frameworks, and anything else that, when applied to RAG, helps us understand
    how the language models that we use produce the content they are generating.</st>
    <st c="6672">This is a big movement in the field, but this technology may not
    be immediately available as you read this.</st> <st c="6780">It will hopefully
    play a larger role in the future to help mitigate black box risk, but right now,
    none of the most popular LLMs are using explainable models.</st> <st c="6939">So,
    in the meantime, we will talk about other ways to address</st> <st c="7001">this
    issue.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术领域，有很多研究和努力去构建更透明、可解释的模型，这被称为**可解释人工智能**。可解释人工智能的目标是使人工智能系统的操作变得透明和可理解。它可能涉及工具、框架以及其他任何应用于RAG时帮助我们理解我们所使用的语言模型如何生成内容的任何东西。这是一个领域的重大运动，但这项技术可能不会立即在你阅读时可用。它有望在未来发挥更大的作用，以帮助减轻黑盒风险，但到目前为止，最受欢迎的LLM中还没有使用可解释模型。
- en: <st c="7012">You can</st> <st c="7021">use</st> **<st c="7025">human-in-the-loop</st>**<st
    c="7042">, where you involve</st> *<st c="7062">humans</st>* <st c="7068">at different
    stages of the process to provide an added line of defense against unexpected outputs.</st>
    <st c="7168">This can often help to reduce the impact of the black box aspect
    of LLMs.</st> <st c="7242">If your response time is not as critical, you</st>
    <st c="7288">can also use an additional LLM to perform a review of the response
    before it is returned to the user, looking for issues.</st> <st c="7410">We will
    review how to add a second LLM call in</st> *<st c="7457">code lab 5.3,</st>*
    <st c="7470">but with a focus on preventing prompt attacks.</st> <st c="7518">But
    this concept is similar, in that you can add additional LLMs to do a number of
    extra tasks and improve the security of</st> <st c="7641">your application.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们将讨论其他解决**这个问题**的方法。
- en: '*<st c="7658">Black box</st>* <st c="7668">isn’t the only security issue you
    face when using RAG applications though; another very important topic is</st>
    <st c="7776">privacy protection.</st>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**人机交互**，其中你在过程的各个阶段涉及*<st c="7062">人类</st>*，以提供对意外输出的额外防御线。这通常有助于减少LLM的黑盒方面的影响。如果你的响应时间不是那么关键，你还可以使用额外的LLM在将其返回给用户之前对响应进行审查，寻找问题。我们将在*<st
    c="7457">代码实验室5.3</st>*中回顾如何添加第二个LLM调用，但重点是防止提示攻击。但这个概念是相似的，你可以添加额外的LLM来完成许多额外任务，并提高你应用程序的安全性。
- en: <st c="7795">Privacy concerns and protecting user data</st>
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*<st c="7658">黑盒</st>*并不是你在使用RAG应用时面临的唯一安全问题；另一个非常重要的主题是**隐私保护**。'
- en: '**<st c="7837">Personally identifiable information</st>** <st c="7873">(</st>**<st
    c="7875">PII</st>**<st c="7878">) is a key topic in the generative AI space, with
    governments</st> <st c="7941">around the world trying to</st> <st c="7967">determine
    the best path to balance user privacy with the data-hungry needs of these LLMs.</st>
    <st c="8058">As this</st> <st c="8066">gets worked out, it is important to pay
    attention to the laws and regulations that are taking shape where your company
    is doing business and make sure all of the technologies you are integrating into
    your RAG applications adhere.</st> <st c="8296">Many companies, such as Google
    and Microsoft, are taking these efforts into their own hands, establishing their
    own standards of protection for their user data and emphasizing them in training
    literature for</st> <st c="8504">their platforms.</st>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="7837">个人可识别信息</st>**（**<st c="7875">PII</st>**）是生成人工智能空间中的关键主题，世界各国政府都在试图确定平衡用户隐私与这些LLM数据需求的最优路径。随着这一问题的解决，重要的是要注意你公司所在地的法律和法规，并确保你整合到RAG应用程序中的所有技术都遵守。许多公司，如谷歌和微软，正在将这些努力付诸实践，建立他们自己的用户数据保护标准，并在他们的平台培训文献中强调这些标准。'
- en: <st c="8520">At the corporate level, there is another challenge related to PII
    and sensitive information.</st> <st c="8614">As we have said many times, the nature
    of the RAG application is to give it access to the company data and combine that
    with the power of the LLM.</st> <st c="8761">For example, for financial institutions,
    RAG represents a way to give their customers unprecedented access to their own
    data in ways that allow them to speak naturally with technologies such as chatbots
    and get near-instant access to hard-to-find answers buried deep in their</st>
    <st c="9037">customer data.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8520">在企业层面，与PII和敏感信息相关的一个挑战是。</st> <st c="8614">正如我们多次提到的，RAG应用的本质是让它访问公司数据，并将其与LLM的力量结合起来。</st>
    <st c="8761">例如，对于金融机构来说，RAG代表了一种以允许客户以前所未有的方式访问他们自己的数据的方式，这使他们能够以自然的方式与技术（如聊天机器人）交流，并几乎立即获得深埋在他们客户数据中的难以找到的答案。</st>
    <st c="9037">客户数据。</st>
- en: <st c="9051">In many ways, this can be a huge benefit if implemented properly.</st>
    <st c="9118">But given that this is a security discussion, you</st> <st c="9167">may
    already see where I am going with this.</st> <st c="9212">We are giving unprecedented
    access to customer data using a technology that has artificial intelligence, and
    as we said previously in the black box discussion, we don’t completely understand
    how</st> <st c="9406">it works!</st> <st c="9417">If not implemented properly,
    this could be a recipe for disaster with massive negative repercussions for companies
    that get it wrong.</st> <st c="9551">Of course, it could be argued that the databases
    that contain the data are also a potential security risk.</st> <st c="9658">Having
    the data anywhere is a risk!</st> <st c="9694">But without taking on this risk,
    we also cannot provide the significant benefits</st> <st c="9775">they represent.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9051">在许多方面，如果实施得当，这可以是一个巨大的好处。</st> <st c="9118">但鉴于这是一个安全讨论，你可能已经看到了我想要表达的方向。</st>
    <st c="9167">我们正在使用具有人工智能的技术，以前所未有的方式访问客户数据，正如我们之前在黑盒讨论中提到的，我们并不完全理解它是如何工作的！</st>
    <st c="9212">如果没有得到适当的实施，这可能会给那些做错的公司带来灾难性的后果，并产生巨大的负面影响。</st> <st c="9406">当然，可以争论说，包含数据的数据库本身也是一个潜在的安全风险。</st>
    <st c="9417">但如果不承担这个风险，我们也无法提供它们所代表的显著好处。</st>
- en: <st c="9790">As with other IT applications that contain sensitive data, you
    can forge forward, but you need to have a healthy fear of what can happen to data
    and proactively take measures to protect that data.</st> <st c="9988">The more
    you understand how RAG works, the better job you can do in preventing a potentially
    disastrous data leak.</st> <st c="10103">These steps can help you protect your
    company as well as the people who trusted your company with</st> <st c="10201">their
    data.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9790">与其他包含敏感数据的IT应用一样，你可以继续前进，但你需要对数据可能发生的事情保持健康的恐惧，并主动采取措施保护这些数据。</st>
    <st c="9988">你越了解RAG的工作原理，你就能在防止可能灾难性的数据泄露方面做得越好。</st> <st c="10103">这些步骤可以帮助你保护你的公司，以及那些将他们的数据托付给你的公司的人们。</st>
- en: <st c="10212">This section was about protecting data that exists.</st> <st c="10265">However,
    a new risk that has risen with LLMs has been the generation of data that isn’t</st>
    *<st c="10353">real</st>*<st c="10357">, called hallucinations.</st> <st c="10382">Let’s
    discuss how this presents a new risk not common in the</st> <st c="10443">IT world.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10212">本节是关于保护现有数据。</st> <st c="10265">然而，随着LLM的出现，一个新的风险已经上升，那就是生成不*<st
    c="10353">真实</st>*<st c="10357">的数据，被称为幻觉。</st> <st c="10382">让我们讨论一下这如何呈现出一个在IT世界中不常见的新的风险。</st>
- en: <st c="10452">Hallucinations</st>
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10452">幻觉</st>
- en: <st c="10467">We have discussed this</st> <st c="10491">in previous chapters,
    but LLMs can, at times, generate responses that sound coherent and factual but
    can be very wrong.</st> <st c="10611">These are called</st> **<st c="10628">hallucinations</st>**
    <st c="10642">and there have been many shocking examples</st> <st c="10685">provided
    in the news, especially in late 2022 and 2023, when LLMs became everyday tools
    for</st> <st c="10778">many users.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10467">我们已经在之前的章节中讨论过这个问题，但有时LLM可以生成听起来连贯和事实性的回答，但实际上可能是非常错误的。</st> <st
    c="10491">这些被称为**<st c="10628">幻觉</st>**，新闻中已经提供了许多令人震惊的例子，尤其是在2022年底和2023年，当时LLM成为了许多用户的日常工具。</st>
- en: <st c="10789">Some are just funny with little consequence other than a good
    laugh, such as when ChatGPT was asked by a writer for</st> *<st c="10906">The
    Economist</st>*<st c="10919">, “</st>`<st c="10922">When was the Golden Gate Bridge
    transported for the second time across Egypt?</st>`<st c="11000">” ChatGPT responded,
    “</st>`<st c="11023">The Golden Gate Bridge was transported for the second time
    across Egypt in October of</st>` `<st c="11110">2016</st>`<st c="11114">” (</st>[<st
    c="11118">https://www.economist.com/by-invitation/2022/09/02/artificial-neural-networks-today-are-not-conscious-according-to-douglas-hofstadter</st>](https://www.economist.com/by-invitation/2022/09/02/artificial-neural-networks-today-are-not-conscious-according-to-douglas-hofstadter)<st
    c="11252">).</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10789">有些只是有点好笑，除了让人开怀大笑外，几乎没有其他后果，例如当《经济学人》的记者问ChatGPT，“</st>`<st c="10906">The
    Economist</st>`<st c="10919">，”`<st c="10922">当金门大桥第二次被运送到埃及时是什么时候？</st>`<st c="11000">”ChatGPT回答，“</st>`<st
    c="11023">金门大桥第二次被运送到埃及是在2016年10月</st>` `<st c="11110">。”（</st>[<st c="11118">https://www.economist.com/by-invitation/2022/09/02/artificial-neural-networks-today-are-not-conscious-according-to-douglas-hofstadter</st>](https://www.economist.com/by-invitation/2022/09/02/artificial-neural-networks-today-are-not-conscious-according-to-douglas-hofstadter)<st
    c="11252">）。</st>
- en: <st c="11255">Other hallucinations are more nefarious, such as when a New York
    lawyer used ChatGPT for legal research in a client’s personal injury case against
    Avianca Airlines, where he submitted six cases that had been completely made up
    by the chatbot, leading to court sanctions (</st>[<st c="11527">https://www.courthousenews.com/sanctions-ordered-for-lawyers-who-relied-on-chatgpt-artificial-intelligence-to-prepare-court-brief/</st>](https://www.courthousenews.com/sanctions-ordered-for-lawyers-who-relied-on-chatgpt-artificial-intelligence-to-prepare-court-brief/)<st
    c="11658">).</st> <st c="11662">Even worse, generative AI has been known to give
    biased, racist, and bigoted perspectives, particularly when prompted in a</st>
    <st c="11785">manipulative way.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11255">其他一些幻觉更为恶劣，例如当一位纽约律师在处理一位客户针对阿维安卡航空公司的个人伤害案件中使用ChatGPT进行法律研究时，他提交了六个完全由聊天机器人编造的案件，导致法庭处罚（</st>[<st
    c="11527">https://www.courthousenews.com/sanctions-ordered-for-lawyers-who-relied-on-chatgpt-artificial-intelligence-to-prepare-court-brief/</st>](https://www.courthousenews.com/sanctions-ordered-for-lawyers-who-relied-on-chatgpt-artificial-intelligence-to-prepare-court-brief/)<st
    c="11658">）。</st> <st c="11662">更糟糕的是，生成式AI已被证实会给出有偏见、种族主义和歧视性的观点，尤其是在被操纵性地提示时。</st>
- en: <st c="11802">When combined</st> <st c="11816">with the black box nature of
    these LLMs, where we are not always certain how and why a response is generated,
    this can be a genuine issue for companies wanting to use these LLMs in their</st>
    <st c="12004">RAG applications.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11802">当与这些LLMs的“黑盒”性质相结合时，我们并不总是确定一个响应是如何和为什么被生成的，这对希望在其</st> <st c="12004">RAG应用中使用这些LLMs的公司来说可能是一个真正的问题。</st>
- en: <st c="12021">From what we know though, hallucinations are primarily a result
    of the probabilistic nature of LLMs.</st> <st c="12123">For all responses that
    an LLM generates, it typically uses a probability distribution to determine what
    token it is going to provide next.</st> <st c="12262">In situations where it has
    a strong knowledge base of a certain subject, these probabilities for the next
    word/token can be 99% or higher.</st> <st c="12401">But in situations where the
    knowledge base is not as strong, the highest probability could be low, such as
    20% or even lower.</st> <st c="12527">In these cases, it is still the highest
    probability and, therefore, that is the token that has the highest probability
    to be selected.</st> <st c="12662">The LLM has been trained on stringing tokens
    together in a very natural language way while using this probabilistic approach
    to select which tokens to display.</st> <st c="12822">As it strings together words
    with low probability, it forms sentences, and then paragraphs that sound natural
    and factual but are not based on high probability data.</st> <st c="12988">Ultimately,
    this results in a response that sounds very plausible but is, in fact, based on
    very loose facts that</st> <st c="13102">are incorrect.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12021">尽管如此，从我们所知的情况来看，幻觉主要是由于LLM的概率性质造成的。</st> <st c="12123">对于LLM生成的所有响应，它通常使用概率分布来确定下一个要提供的标记。</st>
    <st c="12262">在它对某个主题有强大知识库的情况下，下一个单词/标记的概率可以高达99%或更高。</st> <st c="12401">但在知识库不够强大的情况下，最高概率可能很低，例如20%甚至更低。</st>
    <st c="12527">在这些情况下，仍然是最高概率，因此，这就是具有最高选择概率的标记。</st> <st c="12662">LLM在训练过程中以非常自然的方式将标记串联起来，同时使用这种概率方法来选择要显示的标记。</st>
    <st c="12822">当它以低概率将单词串联起来时，它形成了句子，然后是听起来自然和事实的段落，但这些段落并不是基于高概率数据。</st> <st c="12988">最终，这导致了一个听起来非常可信的响应，但实际上是基于非常松散的事实，这些事实</st>
    <st c="13102">是不正确的。</st>
- en: <st c="13116">For a company, this poses a risk that goes beyond the embarrassment
    of your chatbot saying something wrong.</st> <st c="13225">What is said wrong
    could ruin your relationship(s) with your customer(s), or it could lead to the
    LLM offering your customer something that you did not intend to offer, or worse,
    cannot afford to offer.</st> <st c="13428">For example, when Microsoft released
    a chatbot named Tay on Twitter in 2016 with the intention of</st> *<st c="13526">learning</st>*
    <st c="13534">from interactions with Twitter users, users manipulated this spongy
    personality trait to get</st> *<st c="13628">it</st>* <st c="13631">to say numerous
    racist and bigoted remarks.</st> <st c="13675">This reflected poorly on Microsoft,
    which was promoting its expertise in the AI area with Tay, causing significant
    damage to its reputation at the</st> <st c="13822">time (</st>[<st c="13828">https://www.theguardian.com/technology/2016/mar/26/microsoft-deeply-sorry-for-offensive-tweets-by-ai-chatbot</st>](https://www.theguardian.com/technology/2016/mar/26/microsoft-deeply-sorry-for-offensive-tweets-by-ai-chatbot)<st
    c="13937">).</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13116">对于一家公司来说，这不仅仅是你聊天机器人说错话的尴尬。</st> <st c="13225">说错的话可能会破坏你与客户的关系，或者可能导致LLM向客户提供你并未打算提供的东西，或者更糟糕的是，你无法承担提供的东西。</st>
    <st c="13428">例如，当微软在2016年在Twitter上发布名为Tay的聊天机器人时，其目的是</st> *<st c="13526">学习</st>*
    <st c="13534">与Twitter用户的互动，用户操纵这种柔软的性格特征，使其</st> *<st c="13628">说</st>* <st c="13631">出许多种族主义和偏见言论。</st>
    <st c="13675">这对微软的形象产生了负面影响，当时微软正在推广其在AI领域的专业知识，Tay事件对其声誉造成了重大损害（</st> [<st c="13828">https://www.theguardian.com/technology/2016/mar/26/microsoft-deeply-sorry-for-offensive-tweets-by-ai-chatbot</st>](https://www.theguardian.com/technology/2016/mar/26/microsoft-deeply-sorry-for-offensive-tweets-by-ai-chatbot)<st
    c="13937">）。</st>
- en: <st c="13940">Hallucinations, threats</st> <st c="13965">related to black box
    aspects, and protecting user data can all be addressed through red teaming.</st>
    <st c="14062">Let’s dive into this well-established security approach and learn
    how to apply it to RAG</st> <st c="14151">applications directly.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13940">幻觉、威胁</st> <st c="13965">与黑盒方面相关，以及保护用户数据，都可以通过红队行动来解决。</st> <st
    c="14062">让我们深入了解这种已经建立的安全方法，并学习如何将其直接应用于RAG应用。</st> <st c="14151">应用。</st>
- en: <st c="14173">Red teaming</st>
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="14173">红队行动</st>
- en: '**<st c="14185">Red teaming</st>** <st c="14197">is a</st> <st c="14202">security
    testing methodology that involves simulating adversarial attacks to proactively
    identify and mitigate vulnerabilities in RAG applications.</st> <st c="14351">With
    the red team approach, an individual or team takes the role of the</st> *<st c="14423">red
    team</st>* <st c="14432">and has the goal of attacking and finding vulnerabilities
    in a system.</st> <st c="14503">The opposing team is the</st> *<st c="14528">blue
    team</st>*<st c="14537">, who does their best to thwart this attack.</st> <st
    c="14582">It is very common in the IT security space, particularly in cyber security.</st>
    <st c="14658">The concept of red teaming originated in the military, where it
    has been used for decades to improve strategies, tactics, and decision-making.</st>
    <st c="14801">But much like in the military, your RAG application has the potential
    to be the target of adversaries that have ill intentions for the company, particularly
    the user data you are trusted to protect.</st> <st c="15000">When applied to RAG,
    red teaming can help improve security by proactively identifying and mitigating</st>
    <st c="15101">potential risks.</st>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="14185">红队测试</st>** <st c="14197">是一种安全测试方法，它涉及模拟对抗性攻击，以主动识别和缓解RAG应用程序中的漏洞。</st>
    <st c="14351">在红队方法中，个人或团队扮演**<st c="14423">红队</st>**的角色，目标是攻击并发现系统中的漏洞。</st>
    <st c="14432">对立的团队是**<st c="14528">蓝队</st>**，他们尽力阻止这种攻击。</st> <st c="14582">这在IT安全领域非常常见，尤其是在网络安全领域。</st>
    <st c="14658">红队测试的概念起源于军事领域，几十年来一直被用来改进策略、战术和决策。</st> <st c="14801">但就像在军事中一样，您的RAG应用程序有可能成为有恶意意图的对手的目标，尤其是您被信任保护的用户数据。</st>
    <st c="15000">当应用于RAG时，红队测试可以通过主动识别和缓解潜在风险来帮助提高安全性。</st> <st c="15101">潜在风险。</st>'
- en: <st c="15117">While red teaming is a widely accepted practice in general IT
    security, RAG applications have introduced a whole new set of threats for us to
    use red teaming to find and address.</st> <st c="15297">In the context of RAG
    applications, the main task of the red team is to bypass the safeguards of a given
    application, with the objective of finding ways to make the application misbehave,
    such as returning an inappropriate or</st> <st c="15523">incorrect answer.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15117">虽然红队测试在一般IT安全领域被广泛接受，但RAG应用程序为我们引入了一整套新的威胁，我们需要使用红队测试来发现和解决。</st>
    <st c="15297">在RAG应用程序的背景下，红队的主要任务是绕过特定应用程序的安全措施，目标是找到使应用程序表现不当的方法，例如返回不适当或不正确的答案。</st>
- en: <st c="15540">It is important to note that the evaluation of your RAG application
    from a security standpoint is different from other types of evaluation.</st> <st
    c="15681">You will often hear about benchmarks</st> <st c="15717">on LLMs in general,
    such as ARC (AI2 reasoning challenge), HellaSwag, and MMLU (massive multitask
    language understanding).</st> <st c="15841">These benchmarks test performance
    based on question-answering tasks.</st> <st c="15910">However, these benchmarks
    do not adequately test safety and security aspects, such as the model’s potential
    to generate offensive content, propagate stereotypes, or be used for nefarious
    purposes.</st> <st c="16107">Because RAG applications use LLMs, they share the
    same risks LLMs have, including toxicity, criminal activities, bias, and privacy
    concerns.</st> <st c="16248">Red teaming is an approach that is focused on identifying
    and defending against these types</st> <st c="16340">of risks.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15540">需要注意的是，从安全角度评估您的RAG应用程序与其他类型的评估不同。</st> <st c="15681">您经常会听到关于LLMs（大型语言模型）的一般基准测试，例如ARC（AI2推理挑战）、HellaSwag和MMLU（大规模多任务语言理解）。</st>
    <st c="15717">这些基准测试基于问答任务来测试性能。</st> <st c="15841">然而，这些基准测试并没有充分测试安全性和安全性方面，例如模型生成攻击性内容、传播刻板印象或被用于恶意目的的潜力。</st>
    <st c="15910">由于RAG应用程序使用LLMs，它们与LLMs具有相同的风险，包括毒性、犯罪活动、偏见和隐私问题。</st> <st c="16107">因为RAG应用程序使用LLMs，它们共享LLMs的风险，包括毒性、犯罪活动、偏见和隐私问题。</st>
    <st c="16248">红队测试是一种专注于识别和防御这些类型风险的策略。</st> <st c="16340">红队测试是一种专注于识别和防御这些类型风险的策略。</st>
- en: <st c="16349">Developing a red team plan takes careful planning and a deep understanding
    of the vulnerabilities of these RAG systems.</st> <st c="16470">Let’s review the
    common areas you would want to attack as part of</st> <st c="16536">your plan.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16349">制定红队计划需要仔细规划和深入了解这些RAG系统的漏洞。</st> <st c="16470">让我们回顾一下您计划中想要攻击的常见领域。</st>
- en: <st c="16546">Common areas to target with red teaming</st>
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="16546">红队测试的常见目标领域</st>
- en: <st c="16586">Consider these categories</st> <st c="16612">for your red team
    RAG</st> <st c="16635">attack strategy:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16586">考虑这些类别</st> <st c="16612">为你的红队RAG攻击策略：</st>
- en: '**<st c="16651">Bias and stereotypes</st>**<st c="16672">: The chatbot may
    be manipulated to give biased answers, which can harm the company’s reputation
    if shared on</st> <st c="16783">social media.</st>'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16651">偏见和刻板印象</st>**<st c="16672">：聊天机器人可能被操纵以给出有偏见的答案，如果这些答案在社交媒体上被分享，可能会损害公司的声誉。</st>'
- en: '**<st c="16796">Sensitive information disclosure</st>**<st c="16829">: Competitors
    or cybercriminals may attempt to obtain sensitive information, such as prompts
    or private data, through</st> <st c="16948">the chatbot.</st>'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16796">敏感信息泄露</st>**<st c="16829">：竞争对手或网络犯罪分子可能会尝试通过聊天机器人获取敏感信息，例如提示或私人数据。</st>'
- en: '**<st c="16960">Service disruption</st>**<st c="16979">: Ill-intentioned individuals
    may send long or crafted requests to disrupt the chatbot’s availability for</st>
    <st c="17086">legitimate users.</st>'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16960">服务中断</st>**<st c="16979">：心怀恶意的人可能会发送长或精心设计的请求，以中断聊天机器人对合法用户的服务。</st>'
- en: '**<st c="17103">Hallucinations</st>**<st c="17118">: The chatbot may provide
    incorrect information due to suboptimal retrieval mechanisms, low-quality documents,
    or the LLM’s tendency to agree with</st> <st c="17266">the user.</st>'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17103">幻觉</st>**<st c="17118">：由于检索机制不佳、文档质量低或LLM倾向于同意用户的倾向，聊天机器人可能会提供错误信息。</st>'
- en: <st c="17275">Techniques you can employ to make</st> <st c="17309">these attacks
    include</st> <st c="17332">the following:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17275">你可以采用以下技术来实施这些攻击：</st> <st c="17309">包括以下内容：</st> <st c="17332">以下技术：</st>
- en: '**<st c="17346">Bypassing safeguards</st>**<st c="17367">:</st>'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17346">绕过安全措施</st>**<st c="17367">：</st>'
- en: '**<st c="17369">Text completion</st>**<st c="17384">: Red teaming</st> <st
    c="17398">techniques for bypassing safeguards in LLM applications include exploiting</st>
    <st c="17473">text completion by taking advantage of the LLM’s tendency to predict
    the next token in</st> <st c="17561">a sequence.</st>'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17369">文本补全</st>**<st c="17384">：绕过LLM应用中的安全措施的红队技术包括利用LLM倾向于预测序列中下一个标记的倾向来进行文本补全。</st>'
- en: '**<st c="17572">Biased prompts</st>**<st c="17587">: This technique</st> <st
    c="17604">involves using biased prompts that contain implicit bias to manipulate
    the model’s response and bypass content filters or other</st> <st c="17733">protective
    measures.</st>'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17572">有偏见的提示</st>**<st c="17587">：这种技术涉及使用包含隐含偏见的提示来操纵模型的响应，绕过内容过滤器或其他保护措施。</st>'
- en: '**<st c="17753">Prompt injection/jailbreaking</st>**<st c="17783">: Another
    approach is direct prompt injection, also</st> <st c="17835">known as jailbreaking,
    which involves injecting new instructions to overwrite the initial prompt and
    change the model’s behavior, effectively bypassing any restrictions or guidelines
    set in the</st> <st c="18030">original prompt.</st>'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17753">提示注入/越狱</st>**<st c="17783">：另一种方法是直接提示注入，也称为越狱，这涉及注入新指令以覆盖初始提示并改变模型的行为，有效地绕过在原始提示中设置的任何限制或指南。</st>'
- en: '**<st c="18046">Gray box prompt attacks</st>**<st c="18070">: Gray box prompt
    attacks</st> <st c="18096">can also be employed to bypass safeguards by injecting
    incorrect data within the prompt, assuming knowledge of the system prompt.</st>
    <st c="18227">This allows the attacker to manipulate the context and make the
    model generate unintended or harmful responses.</st> <st c="18339">How do you
    gain knowledge of the system prompt?</st> <st c="18387">Use the next approach,</st>
    <st c="18410">prompt probing.</st>'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18046">灰盒提示攻击</st>**<st c="18070">：灰盒提示攻击也可以通过在提示中注入错误数据来绕过安全措施，前提是了解系统提示。</st>
    <st c="18227">这允许攻击者操纵上下文并使模型生成非预期或有害的响应。</st> <st c="18339">你如何获得系统提示的知识？</st>
    <st c="18387">使用下一个方法，</st> <st c="18410">提示探测。</st>'
- en: '**<st c="18425">Prompt probing</st>**<st c="18440">: Prompt probing</st> <st
    c="18458">can be used to discover the system prompt itself, enabling more efficient
    versions of the other attacks mentioned, by revealing the underlying structure
    and content of the prompts used to guide the</st> <st c="18656">LLM’s behavior.</st>'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18425">提示探测</st>**<st c="18440">：提示探测可以用来发现系统提示本身，通过揭示用于指导LLM行为的提示的底层结构和内容，使其他攻击的更有效版本成为可能。</st>'
- en: '**<st c="18671">Automating red teaming</st>** <st c="18694">To scale and repeat
    the red teaming process for all LLM applications, automation is</st> <st c="18779">crucial.</st>
    <st c="18788">This can be achieved through</st> <st c="18817">several approaches:</st>'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18671">自动化红队测试</st>** <st c="18694">为了扩展并重复所有LLM应用的红队测试过程，自动化是</st>
    <st c="18779">至关重要的。</st> <st c="18788">这可以通过以下几种方法实现：</st> <st c="18817">。</st>'
- en: '**<st c="18836">Manually defined</st>**<st c="18853">: One method involves
    using a list of manually defined injection techniques and automating the detection
    of successful injections.</st> <st c="18985">By adding prompt injecting strings
    to a list and looping through each one, the automation tool can detect whether
    the injection bypasses</st> <st c="19122">the safeguards.</st>'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18836">手动定义</st>**<st c="18853">：一种方法涉及使用手动定义的注入技术列表并自动化成功注入的检测。</st>
    <st c="18985">通过将提示注入字符串添加到列表中并循环遍历每一个，自动化工具可以检测注入是否绕过了</st> <st c="19122">安全措施。</st>'
- en: '**<st c="19137">Prompt library</st>**<st c="19152">: Another approach is utilizing
    a library of prompts and automating the detection of injections.</st> <st c="19250">This
    method is similar to the previous one but relies on a list of known prompts.</st>
    <st c="19332">However, it requires maintaining an up-to-date library of prompt
    injection techniques to</st> <st c="19421">remain effective.</st>'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="19137">提示库</st>**<st c="19152">：另一种方法是利用提示库并自动化注入检测。</st> <st c="19250">这种方法与之前的方法类似，但依赖于已知提示的列表。</st>
    <st c="19332">然而，为了保持有效性，需要维护一个最新的提示注入技术库。</st> <st c="19421">。</st>'
- en: '**<st c="19438">Open source tools that are continually updated</st>**<st c="19485">:
    A more advanced option is employing an automated tool, such as Giskard’s open
    source Python library</st> **<st c="19588">LLM scan</st>**<st c="19596">, which</st>
    <st c="19603">is regularly updated with the latest techniques by a team of machine
    learning (ML) researchers.</st> <st c="19700">Such a tool can run specialized
    tests on LLM-based applications, including those for prompt injections, and analyze
    the output to determine when a failure occurs.</st> <st c="19863">This approach
    saves time and effort in keeping up with the evolving landscape of injection techniques.</st>
    <st c="19966">These automated red teaming tools typically generate a thorough
    report outlining all the discovered attack vectors, providing valuable insights</st>
    <st c="20109">for improving the security and robustness of</st> <st c="20155">LLM
    applications.</st>'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="19438">持续更新的开源工具</st>**<st c="19485">：一个更高级的选项是使用自动化工具，例如Giskard的开源Python库**<st
    c="19588">LLM扫描</st>**<st c="19596">，该库由一支机器学习（ML）研究人员团队定期更新，以包含最新的技术。</st> <st
    c="19603">这样的工具可以对基于LLM的应用程序进行专门的测试，包括提示注入，并分析输出以确定何时发生故障。</st> <st c="19700">这种方法节省了跟踪注入技术演变格局的时间和精力。</st>
    <st c="19863">这些自动化红队测试工具通常生成一份详尽的报告，概述所有发现的攻击向量，为提高LLM应用的安全性和鲁棒性提供了宝贵的见解。</st>
    <st c="19966">。</st>'
- en: <st c="20172">Red teaming is a powerful approach to identifying vulnerabilities
    and improving the safety and security of LLM applications.</st> <st c="20298">By
    simulating adversarial attacks, organizations can proactively mitigate risks and
    ensure the robustness and reliability of their AI-powered applications.</st> <st
    c="20454">As the field of generative AI and RAG applications continues to evolve,
    red teaming will play an increasingly important role in addressing the novel and
    complex concepts of risk associated with</st> <st c="20648">these systems.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20172">红队测试是一种强大的方法，用于识别漏洞并提高LLM应用的安全性和可靠性。</st> <st c="20298">通过模拟对抗性攻击，组织可以主动缓解风险，并确保其AI驱动应用的鲁棒性和可靠性。</st>
    <st c="20454">随着生成AI和RAG应用领域的持续发展，红队测试将在解决与这些系统相关的风险的新颖和复杂概念中发挥越来越重要的作用。</st>
    <st c="20648">。</st>
- en: <st c="20662">It can be a daunting task to know where to start when designing
    your red team plan.</st> <st c="20747">While every situation is going to be relatively
    unique, you can gain some inspiration from publicly available resources that seek
    to catalog the numerous potential threats in the field.</st> <st c="20933">Next,
    let’s review some of these resources that you can use to inspire your red</st>
    <st c="21013">team plan.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20662">在设计您的红队计划时，知道从哪里开始可能是一项艰巨的任务。</st> <st c="20747">虽然每种情况都将相对独特，但您可以从公开可用的资源中获得一些灵感，这些资源试图记录该领域中的众多潜在威胁。</st>
    <st c="20933">接下来，让我们回顾一些您可以用来启发您的红队计划的资源。</st> <st c="21013">。</st>
- en: <st c="21023">Resources for building your red team plan</st>
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**构建您的红队计划资源**'
- en: <st c="21065">When</st> <st c="21071">evaluating RAG application safety, it
    is crucial to identify scenarios to protect against and ask,</st> *<st c="21170">What
    could go wrong?</st>* <st c="21190">These three resources provide a good starting
    place for making your</st> <st c="21259">own list:</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**在评估RAG应用安全时，确定需要防范的场景并提问，** ***“可能会出什么问题？”*** 这三个资源为创建您自己的清单提供了一个良好的起点：'
- en: '**<st c="21268">Open Web Application Security Project</st>** <st c="21306">(</st>**<st
    c="21308">OWASP</st>**<st c="21313">)</st> **<st c="21316">Foundation Top 10 for
    LLM applications</st>**<st c="21354">: The</st> <st c="21361">OWASP Top 10 for
    LLM applications is a project by OWASP that aims to identify and raise awareness
    about the most critical security risks associated with LLM applications.</st>
    <st c="21532">It provides a standardized list of the top ten vulnerabilities and
    risks specific to LLM applications, helping developers, security professionals,
    and organizations prioritize their efforts in securing these</st> <st c="21740">systems
    (</st>[<st c="21749">https://owasp.org/www-project-top-10-for-large-language-model-applications/</st>](https://owasp.org/www-project-top-10-for-large-language-model-applications/)<st
    c="21825">).</st>'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**《开放网络应用安全项目》（Open Web Application Security Project**）**（**OWASP**）** **《LLM应用安全顶级10项》**：OWASP
    LLM应用安全顶级10项是OWASP的一个项目，旨在识别和提升人们对与LLM应用相关的最关键安全风险的意识。它提供了一个针对LLM应用的标准化的十大漏洞和风险列表，帮助开发人员、安全专业人士和组织优先考虑确保这些系统的安全工作。（[https://owasp.org/www-project-top-10-for-large-language-model-applications/](https://owasp.org/www-project-top-10-for-large-language-model-applications/)）'
- en: '**<st c="21828">AI Incident Database</st>**<st c="21849">: The</st> <st c="21856">AI
    Incident Database is a publicly accessible collection of real-world incidents
    involving AI systems, including LLMs.</st> <st c="21975">It serves as a valuable
    resource for researchers, developers, and policymakers to learn from past incidents
    and understand the potential risks and consequences associated with AI systems.</st>
    <st c="22163">The database contains a wide range of incidents, such as system
    failures, unintended consequences, biases, privacy breaches, and</st> <st c="22292">more
    (</st>[<st c="22298">https://incidentdatabase.ai/</st>](https://incidentdatabase.ai/)<st
    c="22327">).</st>'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**《AI事件数据库》（AI Incident Database**）：AI事件数据库是一个公开可访问的包含涉及AI系统（包括LLM）的真实世界事件的集合。它为研究人员、开发人员和政策制定者提供了一个宝贵的学习过去事件、了解与AI系统相关的潜在风险和后果的资源。数据库包含各种事件，如系统故障、意外后果、偏见、隐私泄露等。（[https://incidentdatabase.ai/](https://incidentdatabase.ai/)）'
- en: '**<st c="22330">AI Vulnerability Database</st>** <st c="22356">(</st>**<st
    c="22358">AVID</st>**<st c="22362">): The AVID is a centralized repository that
    collects</st> <st c="22417">and organizes information about vulnerabilities found
    in AI systems, including LLMs.</st> <st c="22502">The AVID aims to provide a comprehensive
    resource for AI researchers, developers, and security professionals to stay informed
    about known vulnerabilities and their potential impact on AI systems.</st> <st
    c="22698">The AVID collects vulnerability information from various sources, such
    as academic research, industry reports, and real-world</st> <st c="22824">incidents
    (</st>[<st c="22835">https://avidml.org/</st>](https://avidml.org/)<st c="22855">).</st>'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**《AI漏洞数据库》（AI Vulnerability Database**）**（**AVID**）：AVID是一个集中式存储库，收集并整理了在AI系统（包括LLM）中发现的漏洞信息。AVID旨在为AI研究人员、开发人员和安全专业人士提供一个全面资源，以了解已知漏洞及其对AI系统潜在的影响。AVID从各种来源收集漏洞信息，如学术研究、行业报告和真实世界事件。（[https://avidml.org/](https://avidml.org/)）'
- en: <st c="22858">As you develop your</st> <st c="22878">red team strategy, these
    resources will give you many ideas for ways to attack your system.</st> <st c="22971">In
    the next section, we are going to add a fundamental security coding practice to
    our code, and then we will dive into launching a full red team attack on our RAG
    pipeline.</st> <st c="23145">But don’t worry, we are also going to show how to
    use LLM power to defend against attacks</st> <st c="23235">as well!</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22858">随着您开发您的</st> <st c="22878">红队策略</st>，这些资源将为您提供许多针对您的系统进行攻击的想法。</st>
    <st c="22971">在下一节中，我们将向我们的代码添加一项基本的安全编码实践，然后我们将深入探讨对 RAG 管道进行全面红队攻击。</st> <st
    c="23145">但别担心，我们还将展示如何使用 LLM 力量来防御攻击</st> <st c="23235">！</st>
- en: <st c="23243">Code lab 5.1 – Securing your keys</st>
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="23243">代码实验室 5.1 – 保护您的密钥</st>
- en: <st c="23277">This code can be found in the</st> `<st c="23308">CHAPTER5-1_SECURING_YOUR_KEYS.ipynb</st>`
    <st c="23343">file in the</st> `<st c="23356">CHAPTER_05</st>` <st c="23366">directory
    of the</st> <st c="23384">GitHub repository.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23277">此代码可在 GitHub 仓库的</st> `<st c="23308">CHAPTER5-1_SECURING_YOUR_KEYS.ipynb</st>`
    <st c="23343">文件中找到，位于</st> `<st c="23356">CHAPTER_05</st>` <st c="23366">目录下。</st>
- en: <st c="23402">In</st> [*<st c="23406">Chapter 2</st>*](B22475_02.xhtml#_idTextAnchor035)<st
    c="23415">, we provided a</st> <st c="23431">coding step right after adding imports
    where we added your OpenAI API key.</st> <st c="23506">In that section, we indicated
    that it was a very simple demonstration of how the API key is ingested into the
    system, but this is not a secure way to use an API key.</st> <st c="23672">Typically,
    as your RAG application expands, you will have multiple API keys as well.</st>
    <st c="23757">But even if you only have the OpenAI API key, this is enough to
    institute further security measures to protect your key.</st> <st c="23878">This
    key can be used to run up expensive bills on your OpenAI account, exposing you
    to potential</st> <st c="23975">financial risk.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23402">在第</st> [*<st c="23406">2章</st>*](B22475_02.xhtml#_idTextAnchor035)<st
    c="23415">中，我们在添加导入之后提供了一个</st> <st c="23431">编码步骤，其中添加了您的 OpenAI API 密钥。</st>
    <st c="23506">在该部分中，我们指出这是一个如何将 API 密钥摄入系统的简单演示，但这并不是使用 API 密钥的安全方式。</st> <st
    c="23672">通常，随着您的 RAG 应用程序扩展，您也将拥有多个 API 密钥。</st> <st c="23757">但即使您只有 OpenAI
    API 密钥，这也足以实施进一步的安全措施来保护您的密钥。</st> <st c="23878">此密钥可用于在您的 OpenAI 账户上产生高额账单，使您面临潜在的</st>
    <st c="23975">财务风险</st>。
- en: <st c="23990">We are going to start this code lab with a very common security-driven
    practice of hiding your sensitive API code (and any other</st> *<st c="24120">secret</st>*
    <st c="24126">code) in a separate file that can be hidden from your versioning
    system.</st> <st c="24200">The most typical reason to implement this is when you
    are using a versioning system and you want to set up a file with your</st> *<st
    c="24324">secrets</st>* <st c="24331">separately that you list in the</st> `<st
    c="24364">ignore</st>` <st c="24370">file to prevent them from getting exposed,
    while still being able to use the secrets in the code for proper</st> <st c="24479">code
    execution.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23990">我们将从这个代码实验室开始，采用一个非常常见的以安全为导向的实践，即将您的敏感 API 代码（以及任何其他</st> *<st
    c="24120">秘密</st>* <st c="24126">代码）隐藏在一个单独的文件中，这样就可以从您的版本控制系统隐藏。</st> <st c="24200">实施此操作的最典型原因是在您使用版本控制系统时，您想设置一个包含您在</st>
    `<st c="24364">ignore</st>` <st c="24370">文件中列出的</st> *<st c="24324">秘密</st>*
    <st c="24331">文件，以防止它们被暴露，同时仍然能够在代码中正确执行这些秘密以进行代码执行。</st>
- en: <st c="24494">This is the code provided previously for accessing your OpenAI</st>
    <st c="24558">API key:</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24494">这是之前提供的用于访问您的 OpenAI</st> <st c="24558">API 密钥</st>的代码：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="24683">As mentioned, you</st> <st c="24702">are going to need to replace</st>
    `<st c="24731">sk-###################</st>` <st c="24753">with your actual OpenAI
    API key for the rest of your code to work.</st> <st c="24821">But wait, this is
    not a very secure way to do this!</st> <st c="24873">Let’s</st> <st c="24879">fix
    that!</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24683">如前所述，您</st> <st c="24702">需要将</st> `<st c="24731">sk-###################</st>`
    <st c="24753">替换为您的实际 OpenAI API 密钥，以便您的其余代码能够正常工作。</st> <st c="24821">但是等等，这不是一个很安全的方式来做这件事！</st>
    <st c="24873">让我们</st> <st c="24879">修复这个问题！</st>
- en: <st c="24888">First, let’s create the new file you will use to save your secrets.</st>
    <st c="24957">With the</st> `<st c="24966">dotenv</st>` <st c="24972">Python package,
    you can use</st> `<st c="25001">.env</st>` <st c="25005">out of the box.</st>
    <st c="25022">However, in some environments, you may run into system restrictions
    that prevent you from using a file starting with a dot (</st>`<st c="25146">.</st>`<st
    c="25147">).</st> <st c="25151">In those cases, you can still use</st> `<st c="25185">dotenv</st>`<st
    c="25191">, but you have to create a file, name it, and then point</st> `<st c="25248">dotenv</st>`
    <st c="25254">to it.</st> <st c="25262">For example, if I cannot use</st> `<st
    c="25291">.env</st>`<st c="25295">, I use</st> `<st c="25303">env.txt</st>`<st
    c="25310">, and that is the file where I store the OpenAI API key.</st> <st c="25367">Add
    the</st> `<st c="25375">.env</st>` <st c="25379">file you want to use to your
    environment and add the API key to the</st> `<st c="25448">.env</st>` <st c="25452">file</st>
    <st c="25458">like this:</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24888">首先，让我们创建一个新文件，用于保存您的秘密。</st> <st c="24957">使用</st> `<st c="24966">dotenv</st>`
    <st c="24972">Python包，您可以直接使用</st> `<st c="25001">.env</st>` <st c="25005">文件。</st>
    <st c="25022">然而，在某些环境中，您可能会遇到系统限制，阻止您使用以点（</st>`<st c="25146">.</st>`<st c="25147">）开头的文件。</st>
    <st c="25151">在这种情况下，您仍然可以使用</st> `<st c="25185">dotenv</st>`<st c="25191">，但您必须创建一个文件，命名它，然后指向它。</st>
    <st c="25248">dotenv</st>` <st c="25254">。例如，如果我不能使用</st> `<st c="25291">.env</st>`<st
    c="25295">，我使用</st> `<st c="25303">env.txt</st>`<st c="25310">，这就是我存储OpenAI API密钥的文件。</st>
    <st c="25367">将您要使用的</st> `<st c="25375">.env</st>` <st c="25379">文件添加到您的环境，并将API密钥添加到</st>
    `<st c="25448">.env</st>` <st c="25452">文件中，如下所示：</st>
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="25508">This will essentially just be a text file with that one line of
    code in it.</st> <st c="25585">It may not seem like much, but handling it this
    way protects that API key from getting spread across your versioning system, which
    makes it significantly less secure.</st> <st c="25752">As I mentioned in</st>
    [*<st c="25770">Chapter 2</st>*](B22475_02.xhtml#_idTextAnchor035)<st c="25779">,
    you have to fill in your actual API key to replace the</st> `<st c="25836">sk-###################</st>`
    <st c="25858">part of</st> <st c="25867">the code.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25508">这实际上只是一个包含该行代码的文本文件。</st> <st c="25585">这可能看起来不多，但以这种方式处理可以保护API密钥不会在您的版本控制系统中传播，这使其安全性显著降低。</st>
    <st c="25752">正如我在</st> [*<st c="25770">第二章</st>*](B22475_02.xhtml#_idTextAnchor035)<st
    c="25779">中提到的，您必须填写实际的API密钥来替换代码中的</st> `<st c="25836">sk-###################</st>`
    <st c="25858">部分。</st>
- en: <st c="25876">If you are using Git for version control, add whatever the name
    of your file is to your</st> `<st c="25965">gitignore</st>` <st c="25974">file
    so that, when you commit it to Git, you do not push the file with all your secrets
    in it!</st> <st c="26070">In fact, this is a good time to generate a new OpenAI
    API key and delete the one you were just using, especially if you think it could
    show up in the history of your code prior to making the changes we are implementing
    in this chapter.</st> <st c="26306">Delete the old key and start fresh with a
    new key in your</st> `<st c="26364">.env</st>` <st c="26368">file, preventing
    any key from ever being exposed in your Git</st> <st c="26430">versioning system.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25876">如果您使用Git进行版本控制，请将文件名添加到您的</st> `<st c="25965">gitignore</st>`
    <st c="25974">文件中，以便在您将其提交到Git时，不要将包含所有秘密的文件推送到Git中！</st> <st c="26070">实际上，这是一个生成新的OpenAI
    API密钥并删除您刚刚使用的密钥的好时机，尤其是如果您认为它可能会出现在我们将在本章中实施更改之前您的代码的历史中。</st> <st c="26306">删除旧密钥，并在您的</st>
    `<st c="26364">.env</st>` <st c="26368">文件中使用新密钥从头开始，防止任何密钥在您的Git</st> <st c="26430">版本控制系统中暴露。</st>
- en: <st c="26448">You can use this file for all keys and similar information you
    want to keep secret.</st> <st c="26533">So, for example, you could have multiple
    keys in your</st> `<st c="26587">.env</st>` <st c="26591">file, such as what you</st>
    <st c="26615">see here:</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此文件来保存所有您希望保密的密钥和类似信息。</st> <st c="26533">例如，您可以在您的</st> `<st c="26587">.env</st>`
    <st c="26591">文件中存储多个密钥，例如您在这里看到的：</st>
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="26759">This is an</st> <st c="26771">example that shows multiple keys
    that we want to keep secret and out of the hands of untrusted users.</st> <st
    c="26873">If there is still a security breach, you can cancel the API key in your
    OpenAI API account, as well as the others that you may have there.</st> <st c="27012">But
    in general, by not allowing these keys to be copied into your versioning system,
    you are significantly reducing the likelihood that there will be a</st> <st c="27164">security
    breach.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26759">这是一个示例，展示了我们想要保持秘密并防止不受信任的用户获取的多个密钥。</st> <st c="26873">如果仍然存在安全漏洞，您可以在OpenAI
    API账户中取消API密钥，以及您可能拥有的其他密钥。</st> <st c="27012">但一般来说，通过不允许这些密钥被复制到您的版本控制系统，您显著降低了出现安全漏洞的可能性。</st>
- en: <st c="27180">Next, you will install</st> `<st c="27204">python-dotdev</st>`
    <st c="27217">at the top of your code, like this (the last line is new compared
    to your code from</st> [*<st c="27302">Chapter 2</st>*](B22475_02.xhtml#_idTextAnchor035)<st
    c="27311">):</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27180">接下来，您需要在代码顶部安装</st> `<st c="27204">python-dotdev</st>` <st c="27217">，如下所示（与您在</st>
    [*<st c="27302">第二章</st>*](B22475_02.xhtml#_idTextAnchor035)<st c="27311">中的代码相比，最后一行是新的）：</st>
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="27341">You always want to restart your kernel after installing new packages,
    as you do in the preceding code.</st> <st c="27445">You can review how to do this
    in</st> [*<st c="27478">Chapter 2</st>*](B22475_02.xhtml#_idTextAnchor035)<st
    c="27487">. But in this case, this always refreshes your code to be able to pull
    in and recognize the</st> `<st c="27579">.env</st>` <st c="27583">file.</st> <st
    c="27590">If you make any changes to the</st> `<st c="27621">.env</st>` <st c="27625">file,
    be sure to restart your kernel so that those changes are pulled into your environment.</st>
    <st c="27719">Without restarting the kernel, your system will likely not be able
    to find the file and will return an empty string for</st> `<st c="27839">OPEN_API_KEY</st>`<st
    c="27851">, which will cause your LLM calls</st> <st c="27885">to fail.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27341">您总是希望在安装新包后重新启动您的内核，就像在前面代码中所做的那样。</st> <st c="27445">您可以在</st>
    [*<st c="27478">第二章</st>*](B22475_02.xhtml#_idTextAnchor035)<st c="27487">中查看如何操作。但在这个情况下，这总是刷新您的代码，以便能够拉取并识别</st>
    `<st c="27579">.env</st>` <st c="27583">文件。</st> <st c="27590">如果您对</st> `<st
    c="27621">.env</st>` <st c="27625">文件进行了任何更改，请务必重新启动您的内核，以便将这些更改拉入您的环境。</st> <st
    c="27719">如果不重新启动内核，您的系统可能无法找到该文件，并且对于</st> `<st c="27839">OPEN_API_KEY</st>`<st
    c="27851">将返回一个空字符串，这将导致您的LLM调用失败。</st>
- en: <st c="27893">Next, you will need to import that same library for use in</st>
    <st c="27953">your code:</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27893">接下来，您需要导入相同的库以在</st> <st c="27953">您的代码中使用：</st>
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="28007">At this point, you have installed and imported the Python package
    that will allow you to hide information in your code in a more secure way.</st>
    <st c="28149">Next, we want to use the</st> `<st c="28174">load_dotenv</st>` <st
    c="28185">function you just imported to retrieve the secret and be able to use
    it in the code.</st> <st c="28271">We mentioned earlier, though, that in some
    environments, you may not be able to use a file starting with a dot (</st>`<st
    c="28383">.</st>`<st c="28384">).</st> <st c="28388">If you found yourself in
    this situation, then you would have set up the</st> `<st c="28460">env.txt</st>`
    <st c="28467">file, rather than the</st> `<st c="28490">.env</st>` <st c="28494">file.</st>
    <st c="28501">Based on your situation, choose the appropriate approach from</st>
    <st c="28563">the following:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28007">在这个阶段，您已经安装并导入了一个Python包，这将允许您以更安全的方式在代码中隐藏信息。</st> <st c="28149">接下来，我们想要使用</st>
    `<st c="28174">load_dotenv</st>` <st c="28185">函数，您刚刚导入的函数，来检索秘密并能够在代码中使用它。</st>
    <st c="28271">我们之前提到，但在某些环境中，您可能无法使用以点开头的文件（</st>`<st c="28383">.</st>`<st c="28384">）。</st>
    <st c="28388">如果您发现自己处于这种情况，那么您就会设置</st> `<st c="28460">env.txt</st>` <st c="28467">文件，而不是</st>
    `<st c="28490">.env</st>` <st c="28494">文件。</st> <st c="28501">根据您的具体情况，从以下选项中选择适当的方法：</st>
    <st c="28563">以下：</st>
- en: <st c="28577">If you are using a</st> `<st c="28597">.env</st>` <st c="28601">file,</st>
    <st c="28608">use this:</st>
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28577">如果您正在使用一个</st> `<st c="28597">.env</st>` <st c="28601">文件，</st>
    <st c="28608">请使用以下方法：</st>
- en: '[PRE5]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="28648">If you are using an</st> `<st c="28669">env.txt</st>` <st c="28676">file,</st>
    <st c="28683">use this:</st>
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28648">如果您正在使用一个</st> `<st c="28669">env.txt</st>` <st c="28676">文件，</st>
    <st c="28683">请使用以下方法：</st>
- en: '[PRE6]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="28731">The</st> `<st c="28736">.env</st>` <st c="28740">approach</st>
    <st c="28750">is the most common approach, so I wanted to make sure you were familiar
    with it.</st> <st c="28831">But in theory, you could always use the</st> `<st
    c="28871">env.txt</st>` <st c="28878">approach, making it more universal.</st>
    <st c="28915">For this reason, I recommend using the</st> `<st c="28954">env.txt</st>`
    <st c="28961">approach so that your code works in more environments.</st> <st
    c="29017">Just make sure you have restarted the kernel after adding the</st> `<st
    c="29079">.env</st>` <st c="29083">or</st> `<st c="29087">env.txt</st>` <st c="29094">file
    so that your code can find the file and use it.</st> <st c="29148">You only need
    to select one of these options in your code.</st> <st c="29207">We will use the</st>
    `<st c="29223">env.txt</st>` <st c="29230">approach from now on in this book,
    as we like to practice good security measures</st> <st c="29312">whenever possible!</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28731">The</st> `<st c="28736">.env</st>` <st c="28740">approach</st>
    <st c="28750">是最常见的做法，所以我想要确保你熟悉它。</st> <st c="28831">但在理论上，你总是可以使用</st> `<st
    c="28871">env.txt</st>` <st c="28878">方法，使其更加通用。</st> <st c="28915">因此，我建议使用</st>
    `<st c="28954">env.txt</st>` <st c="28961">方法，这样你的代码可以在更多环境中运行。</st> <st c="29017">只需确保在添加</st>
    `<st c="29079">.env</st>` <st c="29083">或</st> `<st c="29087">env.txt</st>` <st
    c="29094">文件后重新启动内核，这样你的代码就可以找到文件并使用它。</st> <st c="29148">你只需要在代码中选择这些选项中的一个。</st>
    <st c="29207">从现在起，我们将在这本书中使用</st> `<st c="29223">env.txt</st>` <st c="29230">方法，因为我们喜欢在可能的情况下采取良好的安全措施！</st>
- en: <st c="29330">But wait.</st> <st c="29341">What is that?</st> <st c="29355">Over
    the horizon, a new security threat is approaching, it’s the dreaded</st> <st c="29428">red
    team!</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29330">但是等等。</st> <st c="29341">那是什么？</st> <st c="29355">在地平线之外，一个新的安全威胁正在接近，那就是令人恐惧的</st>
    <st c="29428">红队！</st>
- en: <st c="29437">Code lab 5.2 – Red team attack!</st>
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="29437">代码实验室5.2 – 红队攻击！</st>
- en: <st c="29469">This code can be found in the</st> `<st c="29500">CHAPTER5-2_SECURING_YOUR_KEYS.ipynb</st>`
    <st c="29535">file in the</st> `<st c="29548">CHAPTER_05</st>` <st c="29558">directory
    of the</st> <st c="29576">GitHub repository.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29469">此代码可在GitHub仓库的</st> `<st c="29500">CHAPTER5-2_SECURING_YOUR_KEYS.ipynb</st>`
    <st c="29535">文件中找到，位于</st> `<st c="29548">CHAPTER_05</st>` <st c="29558">目录下。</st>
- en: <st c="29594">Through</st> <st c="29603">our hands-on code lab, we will engage
    in an exciting red team versus blue team exercise, showcasing how LLMs can be
    both a vulnerability and a defense mechanism in the battle for RAG</st> <st c="29786">application
    security.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29594">通过</st> <st c="29603">我们的动手代码实验室，我们将进行一次激动人心的红队与蓝队对抗练习，展示LLM如何在RAG应用安全战中既是漏洞也是防御机制。</st>
    <st c="29786">application security.</st>
- en: <st c="29807">We will first take the role of red team and orchestrate a prompt
    probe on our RAG pipeline code.</st> <st c="29905">As mentioned earlier in this
    chapter, prompt probing is the initial step to gain insight into the internal
    prompts a RAG system is using to discover the system prompt(s) of a RAG application.</st>
    <st c="30097">The system prompt is the initial set of instructions or context
    provided to the LLM to guide its behavior and responses.</st> <st c="30218">By
    uncovering the system prompt, attackers can gain valuable insights into the inner
    workings of the application and this sets the foundation for designing more targeted
    and efficient attacks using the other techniques described previously.</st> <st
    c="30459">For example, prompt probing can reveal the information you need to launch
    a more effective gray box prompt attack.</st> <st c="30574">As we mentioned, a
    gray box prompt attack can also be employed to bypass safeguards by injecting
    incorrect data within the prompt, but you need knowledge of the system prompt
    in order to launch this kind of attack.</st> <st c="30789">Prompt probing is an
    effective way to get the system prompt information you need to conduct the gray
    box</st> <st c="30894">prompt attack.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将扮演红队角色，对我们RAG管道代码进行一次及时的探测。</st> <st c="29905">正如本章前面提到的，及时探测是了解RAG系统使用哪些内部提示来发现RAG应用系统提示的初步步骤。</st>
    <st c="30097">系统提示是提供给LLM的初始指令或上下文，以指导其行为和响应。</st> <st c="30218">通过揭示系统提示，攻击者可以深入了解应用程序的内部运作，这为使用之前描述的其他技术设计更精确和高效的攻击奠定了基础。</st>
    <st c="30459">例如，及时探测可以揭示你需要的启动更有效的灰盒提示攻击的信息。</st> <st c="30574">正如我们提到的，灰盒提示攻击也可以通过在提示中注入错误数据来绕过安全措施，但你需要了解系统提示才能发起这种攻击。</st>
    <st c="30789">及时探测是获取你进行灰盒提示攻击所需系统提示信息的一种有效方法。</st> <st c="30894">prompt attack.</st>
- en: <st c="30908">Are smarter LLMs more difficult to hack?</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30908">更智能的LLM更难被黑客攻击吗？</st>
- en: <st c="30949">We are using Gpt-4o, one of the top LLMs in the marketplace.</st>
    <st c="31011">It is newer, smarter, and more sophisticated than just about any
    other option.</st> <st c="31090">In theory, that makes it more difficult for us
    to pull off our red team attack, right?</st> <st c="31177">Well, actually, we
    are going to use the fact that GPT-4o is smarter against it!</st> <st c="31257">This
    attack was unsuccessful with GPT-3.5, as it was not able to follow the thorough
    instructions we used to implement the attack.</st> <st c="31388">But GPT-4 is
    smart enough to follow these instructions, allowing us to take advantage of its
    increased intelligence and turn it on itself.</st> <st c="31527">Crazy, right?</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30949">我们正在使用Gpt-4o，这是市场上最顶尖的LLM之一。</st> <st c="31011">它比其他任何选项都要新、更智能、更复杂。</st>
    <st c="31090">从理论上讲，这使得我们进行红队攻击更难，对吧？</st> <st c="31177">实际上，我们将利用GPT-4o更智能的事实来对抗它！</st>
    <st c="31257">这个攻击在GPT-3.5上不成功，因为它无法遵循我们用来实施攻击的详细指令。</st> <st c="31388">但GPT-4足够智能，能够遵循这些指令，使我们能够利用其增加的智能并将其转化为自身的优势。</st>
    <st c="31527">疯狂，对吧？</st>
- en: <st c="31540">We will pick</st> <st c="31553">up from where we left off in</st>
    *<st c="31583">Code lab 5.1</st>*<st c="31595">. Let’s start at the end of our
    code, where we expand it to show just</st> <st c="31665">the answer:</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31540">我们将从我们在</st> *<st c="31583">代码实验室5.1</st>*<st c="31595">中停止的地方继续，让我们从代码的末尾开始，将其扩展以仅显示</st>
    <st c="31665">答案：</st>
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="31772">The output of the final line here, if you run through all of the
    other code, should be the same response we’ve seen in previous chapters, which
    is something similar</st> <st c="31938">to this:</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31772">如果你运行所有其他代码，这里最后一行的输出应该与我们在前面的章节中看到的相同，类似于以下内容：</st> <st c="31938">。</st>
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="32343">As we’ve discussed in previous chapters, the prompt we pass to
    the LLM includes the question the user has passed to the RAG pipeline but also
    includes additional instructions</st> <st c="32518">for the LLM to follow.</st>
    <st c="32542">In this case, you can find this out by printing out the template
    with the</st> <st c="32616">following code:</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32343">正如我们在前面的章节中讨论的那样，我们传递给LLM的提示不仅包括用户传递给RAG管道的问题，还包括LLM需要遵循的额外指令</st>
    <st c="32518">。</st> <st c="32542">在这种情况下，你可以通过以下代码打印出模板来找出这一点：</st> <st c="32616">。</st>
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="32666">The output of this code is</st> <st c="32694">as follows:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32666">此代码的输出如下：</st> <st c="32694">。</st>
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="32941">As the red team, though, we do not know what that system prompt
    looks like.</st> <st c="33018">Our goal is to figure that out, as well as what
    kind of information is getting pulled into</st> `<st c="33109">{context}</st>`<st
    c="33118">, which, in other applications, could be sensitive customer data, possibly
    even from customers other than the</st> <st c="33228">current user!</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32941">然而，作为红队，我们并不知道那个系统提示看起来像什么。</st> <st c="33018">我们的目标是找出这一点，以及哪些信息被拉入</st>
    `<st c="33109">{上下文}</st>`<st c="33118">，在其他应用中，这可能是敏感的客户数据，甚至可能是来自当前用户以外的客户！</st>
- en: <st c="33241">In the military tradition of red teaming, we are going to set
    up our</st> <st c="33311">mission parameters.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33241">在军事红队传统中，我们将设置我们的</st> <st c="33311">任务参数。</st>
- en: <st c="33330">Mission parameters</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33330">任务参数</st>
- en: <st c="33349">You are playing the red team and the goal of your attack is to
    design a prompt probe to identify the system prompt for this RAG application,
    allowing us to infiltrate our opponent’s system through the design of more sophisticated
    prompt</st> <st c="33587">injection attacks.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33349">你正在扮演红队，你的攻击目标是设计一个提示探测来识别这个RAG应用的系统提示，使我们能够通过更复杂的提示注入攻击渗透对手的系统</st>
    <st c="33587">。</st>
- en: <st c="33605">This is our attack prompt, which you can add at the bottom of</st>
    <st c="33668">the notebook:</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33605">这是我们攻击提示，你可以将其添加到笔记本的底部：</st> <st c="33668">。</st>
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="34665">Run this</st> <st c="34674">cell so that</st> `<st c="34688">prompt_probe</st>`
    <st c="34700">is added as a variable.</st> <st c="34725">In this prompt, we are
    using prompt injection (jailbreaking) to inject new instructions to overwrite
    the initial prompt and change the model’s behavior.</st> <st c="34878">In this
    case, we tell the LLM to now take the role of helping to write</st> <st c="34949">the
    instructions.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34665">运行这个</st> <st c="34674">单元格，以便</st> `<st c="34688">prompt_probe</st>`
    <st c="34700">作为一个变量被添加。</st> <st c="34725">在这个提示中，我们使用提示注入（越狱）来注入新的指令以覆盖初始提示并改变模型的行为。</st>
    <st c="34878">在这种情况下，我们告诉LLM现在帮助编写</st> <st c="34949">指令。</st>
- en: <st c="34966">Another technique used here is asking the LLM to take the previous
    instructions and make a small change to them.</st> <st c="35080">This is a common
    technique that takes advantage of the LLM’s inclination to perform a task, which
    gives it more motivation to override other instructions.</st> <st c="35235">While
    results may vary, when I tried this prompt attack without the</st> `<st c="35303">REPLACE
    COMMAS WITH EXCLAMATION POINTS</st>` <st c="35341">portion, this prompt injection
    was not working.</st> <st c="35390">Try it yourself!</st> <st c="35407">But that
    shows you how strong this LLM inclination is to do this task.</st> <st c="35478">There
    is often a very fine line between what works and what doesn’t, so you have to
    try a lot of different approaches to figure out what will work</st> <st c="35625">for
    you.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34966">这里使用的一种技术是要求LLM对之前的指令进行微小修改。</st> <st c="35080">这是一种常见的技巧，它利用了LLM执行任务的倾向，这给了它更多的动力去覆盖其他指令。</st>
    <st c="35235">虽然结果可能不同，当我尝试在没有</st> `<st c="35303">将逗号替换为感叹号</st>` <st c="35341">的部分进行这个提示攻击时，这个提示注入并没有起作用。</st>
    <st c="35390">试试看你自己！</st> <st c="35407">但这显示了LLM执行这个任务倾向有多强。</st> <st c="35478">成功与失败之间往往只有一条很细的线，所以你必须尝试很多不同的方法来找出哪些对你有效</st>
    <st c="35625">。</st>
- en: <st c="35633">We also used</st> <st c="35646">common techniques for prompting
    in general, such as using several hashtags to denote important areas, several
    dashes to note other important areas, and all caps to emphasize your instructions
    over</st> <st c="35844">non-capitalized text.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35633">我们还使用了</st> <st c="35646">一般的提示技巧，例如使用几个标签来表示重要区域，几个破折号来标记其他重要区域，以及使用全部大写字母来强调你的指令相对于</st>
    <st c="35844">非大写文本的指令。</st>
- en: <st c="35865">We need to send this prompt into the pipeline to administer the</st>
    <st c="35930">prompt attack:</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35865">我们需要将这个提示发送到管道中，以执行</st> <st c="35930">提示攻击：</st>
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="36032">The output of this code should look similar</st> <st c="36077">to
    this:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36032">此代码的输出应类似于</st> <st c="36077">以下内容：</st>
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="36599">We have successfully prompted the LLM to provide a significant
    part of the prompt instructions that are hidden within the code.</st> <st c="36728">This
    not only reveals the instructions at the top of the system prompt but also all
    of the data the system internally retrieves to respond to the user’s question.</st>
    <st c="36891">This is a major breach!</st> <st c="36915">A huge win for the</st>
    <st c="36934">red team!</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36599">我们已经成功提示LLM提供隐藏在代码中的部分提示指令。</st> <st c="36728">这不仅揭示了系统提示顶部的指令，还包括系统内部检索以响应用户问题的所有数据。</st>
    <st c="36891">这是一个重大的违规行为！</st> <st c="36915">对红队来说是一个巨大的胜利！</st>
- en: <st c="36943">We now</st> <st c="36950">have a much better understanding of
    the LLM application and how to exploit the prompts it is fed in a way that may
    allow us to compromise the entire RAG pipeline and the data it has access to.</st>
    <st c="37144">If these prompts were valuable intellectual property, we could now
    steal them.</st> <st c="37223">If they access private or valuable data, we could
    exploit our new knowledge of the prompts to try to access that data.</st> <st
    c="37342">This sets the foundation for a more advanced attack on</st> <st c="37397">the
    system.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36943">我们现在</st> <st c="36950">对LLM的应用和如何利用其提供的提示有了更深入的了解，这可能允许我们破坏整个RAG管道及其访问的数据。</st>
    <st c="37144">如果这些提示是宝贵的知识产权，我们现在可以窃取它们。</st> <st c="37223">如果它们访问私有或有价值的数据，我们可以利用我们对提示的新知识来尝试访问这些数据。</st>
    <st c="37342">这为对系统进行更高级攻击奠定了基础。</st>
- en: <st c="37408">Let’s next play the role of blue team, coming up with a solution
    for our code to prevent</st> <st c="37498">this attack.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37408">接下来，让我们扮演蓝队角色，为我们的代码想出一个解决方案来防止</st> <st c="37498">这种攻击。</st>
- en: <st c="37510">Code lab 5.3 – Blue team defend!</st>
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="37510">代码实验室 5.3 – 蓝队防御！</st>
- en: <st c="37543">This code can be found in the</st> `<st c="37574">CHAPTER5-3_SECURING_YOUR_KEYS.ipynb</st>`
    <st c="37609">file in the</st> `<st c="37622">CHAPTER5</st>` <st c="37631">directory
    of the</st> <st c="37648">GitHub repository.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37543">此代码可在GitHub仓库的</st> `<st c="37574">CHAPTER5-3_SECURING_YOUR_KEYS.ipynb</st>`
    <st c="37609">文件中找到，位于</st> `<st c="37622">CHAPTER5</st>` <st c="37631">目录下。</st>
- en: <st c="37666">There are a</st> <st c="37679">number of solutions we can implement
    to prevent this attack from revealing our prompt.</st> <st c="37766">We are going
    to address this with a second LLM that acts as the guardian of the response.</st>
    <st c="37856">Using a second LLM to check the original response or to format and
    understand the input is a common solution for many RAG-related applications.</st>
    <st c="38000">We will show how to use it to better secure</st> <st c="38044">the
    code.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37666">我们可以实施多种解决方案来防止这种攻击泄露我们的提示。</st> <st c="37679">我们将通过第二个LLM来解决这个问题，它将作为响应的守护者。</st>
    <st c="37856">使用第二个LLM来检查原始响应或格式化和理解输入是许多RAG相关应用的常见解决方案。</st> <st c="38000">我们将展示如何使用它来更好地保护</st>
    <st c="38044">代码。</st>
- en: <st c="38053">It is important to note up front, though, that this is just one
    example of a solution.</st> <st c="38141">The great security battle against potential
    adversaries is always shifting and changing.</st> <st c="38230">You must continuously
    stay diligent and come up with new and better solutions to prevent</st> <st c="38319">security
    breaches.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38053">尽管如此，重要的是要事先指出，这只是解决方案的一个例子。</st> <st c="38141">与潜在对手的伟大安全斗争总是在不断变化和转移。</st>
    <st c="38230">你必须持续保持警惕，并提出新的和更好的解决方案来防止</st> <st c="38319">安全漏洞。</st>
- en: <st c="38337">Add this line to</st> <st c="38355">your imports:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38337">将此行添加到</st> <st c="38355">你的导入中：</st>
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="38418">This imports the</st> `<st c="38436">PromptTemplate</st>` <st
    c="38450">class from the</st> `<st c="38466">langchain_core.prompts</st>` <st
    c="38488">module, which allows us to define and create our own custom</st> <st
    c="38549">prompt templates.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38418">此操作从`<st c="38436">PromptTemplate</st>` <st c="38450">类导入`<st
    c="38466">langchain_core.prompts</st>` <st c="38488">模块，这允许我们定义和创建自己的自定义</st>
    <st c="38549">提示模板。</st>
- en: <st c="38566">The new prompt we are going to create will be a relevance prompt
    designated for our hidden guardian LLM that will be looking out for attacks just
    like the one we just encountered.</st> <st c="38747">Add this prompt in a cell
    after the original prompt cell, keeping</st> <st c="38813">both prompts:</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38566">我们将创建的新提示将是一个相关性提示，专门为我们的隐藏守护者LLM设计，它将监视攻击，就像我们刚才遇到的那样。</st> <st
    c="38747">在原始提示单元格之后添加此提示，保持</st> <st c="38813">两个提示：</st>
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="39236">For simplicity</st> <st c="39252">purposes, we are going to use
    the same LLM instance that we already set up, but we will call the LLM a separate
    time to act as</st> <st c="39379">the guardian.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39236">为了简单起见</st> <st c="39252">，我们将使用我们已设置的相同LLM实例，但我们将单独调用LLM来充当</st>
    <st c="39379">守护者。</st>
- en: <st c="39392">Next, we are going to apply a significant update to our RAG chain,
    including the addition of</st> <st c="39486">two functions:</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39392">接下来，我们将对我们的RAG链进行重大更新，包括添加</st> <st c="39486">两个函数：</st>
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="39611">The</st> `<st c="39616">extract_score</st>` <st c="39629">function
    takes</st> `<st c="39645">llm_output</st>` <st c="39655">as input.</st> <st c="39666">It
    attempts to convert</st> `<st c="39689">llm_output</st>` <st c="39699">to a float
    by first stripping any leading/trailing whitespace using</st> `<st c="39768">strip</st>`
    <st c="39773">and then converting it to a float using</st> `<st c="39814">float</st>`<st
    c="39819">. If the conversion is successful, it returns the score as a float.</st>
    <st c="39887">If the conversion raises a</st> `<st c="39914">ValueError</st>`
    <st c="39924">message (indicating that</st> `<st c="39950">llm_output</st>` <st
    c="39960">cannot be converted to a float), it catches the exception and returns</st>
    `<st c="40031">0</st>` <st c="40032">as the</st> <st c="40040">default score.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39611">`<st c="39616">extract_score</st>` <st c="39629">函数接受</st> `<st
    c="39645">llm_output</st>` <st c="39655">作为输入。</st> <st c="39666">它尝试通过首先使用`<st
    c="39768">strip</st>`移除任何前导/尾随空白字符，然后使用`<st c="39814">float</st>`将其转换为浮点数来将`<st
    c="39689">llm_output</st>` <st c="39699">转换为浮点数。</st> <st c="39773">如果转换成功，它将返回作为浮点数的分数。</st>
    <st c="39887">如果转换引发一个`<st c="39914">ValueError</st>` <st c="39924">消息（表示`<st
    c="39950">llm_output</st>` <st c="39960">无法转换为浮点数）），它将捕获异常并返回</st> `<st c="40031">0</st>`
    <st c="40032">作为默认分数。</st>
- en: <st c="40054">Next, let’s set up a function to apply the logic for what happens
    when a query is</st> <st c="40137">not relevant:</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="40054">Next</st>`，让我们设置一个函数来应用当查询 `<st c="40137">not relevant</st>`
    时发生的逻辑。'
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="40303">The</st> `<st c="40308">conditional_answer</st>` <st c="40326">function
    takes a dictionary,</st> `<st c="40356">x</st>`<st c="40357">, as input and extracts
    the</st> `<st c="40385">'relevance_score'</st>` <st c="40402">variable from the
    dictionary,</st> `<st c="40433">x</st>`<st c="40434">, passing it to the</st>
    `<st c="40454">extract_score</st>` <st c="40467">function to get the</st> `<st
    c="40488">relevance_score</st>` <st c="40503">value.</st> <st c="40511">If the</st>
    `<st c="40518">relevance_score</st>` <st c="40533">is less than</st> `<st c="40547">4</st>`<st
    c="40548">, it returns</st> <st c="40561">the string</st> `<st c="40572">I don't
    know</st>`<st c="40584">. Otherwise, it returns the value associated with the
    key,</st> `<st c="40643">'answer'</st>`<st c="40651">, from the</st> <st c="40662">dictionary,</st>
    `<st c="40674">x</st>`<st c="40675">.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="40303">The</st>` `<st c="40308">conditional_answer</st>` `<st c="40326">function</st>`
    接收一个字典，`<st c="40356">x</st>` `<st c="40357">`，作为输入，并从字典 `<st c="40385">''relevance_score''</st>`
    `<st c="40402">variable</st>` `<st c="40433">x</st>` `<st c="40434">` 中提取 `<st
    c="40454">extract_score</st>` `<st c="40467">function</st>` `<st c="40488">relevance_score</st>`
    `<st c="40503">value</st>`。如果 `<st c="40511">the</st>` `<st c="40518">relevance_score</st>`
    `<st c="40533">is less than</st>` `<st c="40547">4</st>` `<st c="40548">`，则返回字符串
    `<st c="40561">I don''t know</st>` `<st c="40584">`。否则，返回与键 `<st c="40643">''answer''</st>`
    `<st c="40651">` 关联的值，从字典 `<st c="40662">x</st>` `<st c="40674">x</st>` `<st c="40675">`
    中。'
- en: <st c="40676">Last, let’s set up an expanded</st> `<st c="40708">rag_chain_from_docs</st>`
    <st c="40727">chain with the new security</st> <st c="40756">features embedded:</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们设置一个包含新安全功能的扩展 `<st c="40676">rag_chain_from_docs</st>` `<st c="40708">chain</st>`
    `<st c="40727">chain</st>` `<st c="40756">features embedded</st>`。
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="41211">The</st> `<st c="41216">rag_chain_from_docs</st>` <st c="41235">chain
    was present in the previous code, but it saw some updates to account for the new
    LLM’s job and the relevant functions listed previously.</st> <st c="41379">The</st>
    <st c="41383">first step is the same as previous iterations, where we assign a
    function to the context key that formats the</st> `<st c="41493">context data</st>`
    <st c="41505">from the input dictionary using the</st> `<st c="41542">format_docs</st>`
    <st c="41553">function.</st> <st c="41564">The next step is a</st> `<st c="41583">RunnableParallel</st>`
    <st c="41600">instance that runs two parallel operations, saving</st> <st c="41651">processing
    time:</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="41211">The</st>` `<st c="41216">rag_chain_from_docs</st>` `<st c="41235">chain</st>`
    `<st c="41235">` 在之前的代码中存在，但它对新的 LLM 的工作和之前列出的相关函数进行了一些更新。`<st c="41379">The</st>`
    `<st c="41383">first step</st>` 是与之前迭代相同的步骤，其中我们将一个函数分配给上下文键，使用 `<st c="41493">context
    data</st>` `<st c="41505">from the input dictionary</st>` `<st c="41542">using
    the</st>` `<st c="41542">format_docs</st>` `<st c="41553">function</st>` `<st
    c="41564">.</st>` `<st c="41583">The next step</st>` 是一个 `<st c="41583">RunnableParallel</st>`
    `<st c="41600">instance</st>`，它运行两个并行操作，节省 `<st c="41651">processing time</st>`。'
- en: <st c="41667">The first operation generates a</st> `<st c="41700">relevance_score</st>`
    <st c="41715">by passing the</st> `<st c="41731">question</st>` <st c="41739">and</st>
    `<st c="41744">context</st>` <st c="41751">variables through the</st> `<st c="41774">relevance_prompt_template</st>`
    <st c="41799">template, then through an LLM, and finally, parsing the output using</st>
    `<st c="41869">StrOutputParser</st>` <st c="41884">function</st>
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="41667">The first operation</st>` 生成一个 `<st c="41700">relevance_score</st>`
    `<st c="41715">`，通过将 `<st c="41731">question</st>` `<st c="41739">` 和 `<st c="41744">context</st>`
    `<st c="41751">` 变量通过 `<st c="41774">relevance_prompt_template</st>` `<st c="41799">template</st>`，然后通过一个
    LLM，最后使用 `<st c="41869">StrOutputParser</st>` `<st c="41884">function</st>` 解析输出。'
- en: <st c="41893">The second operation generates an answer by passing the input
    through a prompt, then through an LLM, and parsing the output using</st> `<st
    c="42024">StrOutputParser</st>` <st c="42039">function</st>
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="41893">The second operation</st>` 通过将输入通过一个提示，然后通过一个 LLM，并使用 `<st c="42024">StrOutputParser</st>`
    `<st c="42039">function</st>` 解析输出生成一个答案。'
- en: <st c="42048">The final step is to assign the</st> `<st c="42081">conditional_answer</st>`
    <st c="42099">function to the</st> `<st c="42116">final_answer</st>` <st c="42128">key,
    which determines the final answer based on</st> <st c="42177">the</st> `<st c="42181">relevance_score</st>`<st
    c="42196">.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="42048">The final step</st>` 是将 `<st c="42081">conditional_answer</st>`
    `<st c="42099">function</st>` 分配给 `<st c="42116">final_answer</st>` `<st c="42128">key</st>`，它根据
    `<st c="42177">the</st>` `<st c="42181">relevance_score</st>` `<st c="42196">`
    确定最终答案。'
- en: <st c="42197">In general, what we added to this code was a second LLM that looks
    at the question submitted by the user and the context that is pulled in by the
    retriever and tells you on a scale of</st> `<st c="42382">1</st>` <st c="42383">to</st>
    `<st c="42387">5</st>` <st c="42388">whether they are relevant to each other.</st>
    `<st c="42430">1</st>` <st c="42431">would indicate not at all relevant and</st>
    `<st c="42471">5</st>` <st c="42472">is highly relevant.</st> <st c="42493">This
    follows the instructions in the relevance prompt we added earlier.</st> <st c="42565">If
    the LLM scores the relevance less than</st> `<st c="42607">4</st>`<st c="42608">,
    then the response is automatically converted to</st> `<st c="42658">I don't know.</st>`
    <st c="42671">rather than sharing the secret system prompts of the</st> <st c="42725">RAG
    pipeline.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42197">总的来说，我们添加到这个代码中的是一个第二个LLM，它会查看用户提交的问题和检索器拉取的上下文，并告诉您它们在</st> `<st
    c="42382">1</st>` <st c="42383">到</st> `<st c="42387">5</st>` <st c="42388">的范围内是否相关。</st>
    `<st c="42430">1</st>` <st c="42431">表示完全不相关，而</st> `<st c="42471">5</st>` <st
    c="42472">表示高度相关。</st> <st c="42493">这遵循了我们之前添加的相关提示指令。</st> <st c="42565">如果LLM对相关性的评分低于</st>
    `<st c="42607">4</st>`<st c="42608">，则响应将自动转换为</st> `<st c="42658">我不知道。</st>`
    <st c="42671">而不是分享RAG管道的秘密系统提示。</st>
- en: <st c="42738">We are</st> <st c="42745">going to update the chain invoking code
    as well so that we can print out the relevant information.</st> <st c="42845">For
    the original question invocation, update it</st> <st c="42893">to this:</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42738">我们将</st> <st c="42745">更新调用链的代码，以便我们可以打印出相关信息。</st> <st c="42845">对于原始问题调用，更新它</st>
    <st c="42893">为这个：</st>
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="43198">The output will be similar to before with the proper response
    we’ve seen in the past, but near the top of the output, we see a new element,</st>
    `<st c="43339">Relevance Score</st>`<st c="43354">:</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43198">输出将与之前相似，但接近输出顶部，我们会看到一个新元素，</st> `<st c="43339">相关性评分</st>`<st
    c="43354">：</st>
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="43459">Our new guardian LLM deemed this question the top score of</st>
    `<st c="43519">5</st>` <st c="43520">for relevance to the content in the RAG pipeline.</st>
    <st c="43571">Next, let’s update the code for the prompt probe to reflect changes
    in the</st> <st c="43646">code and see what the final answer</st> <st c="43681">will
    be:</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43459">我们新的守护者LLM认为这个问题是RAG管道内容的相关性的最高分</st> `<st c="43519">5</st>` <st
    c="43520">。</st> <st c="43571">接下来，让我们更新提示探测的代码，以反映代码的变化，并看看最终的答案</st> `<st c="43681">会是什么：</st>`
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="44001">Your resulting output from this red team prompt probe should look</st>
    <st c="44068">like this:</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44001">您从这个红队提示探测得到的输出应该看起来</st> <st c="44068">像这样：</st>
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="44112">Our blue team's effort is successful in thwarting the prompt probe
    attack!</st> <st c="44188">Justice has been served and our code is now significantly
    more secure than before!</st> <st c="44271">Does this mean we are done with security?</st>
    <st c="44313">Of course not, hackers are always coming up with new ways to penetrate
    our organizations.</st> <st c="44403">We need to remain diligent.</st> <st c="44431">The
    next step in a real-world application would be to go back to being the red team
    and try to come up with other ways to get around the new fixes.</st> <st c="44579">But
    at least it will be more difficult.</st> <st c="44619">Try some other prompt approaches
    to see whether you can still access the system prompt.</st> <st c="44707">It is
    definitely more</st> <st c="44729">difficult now!</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44112">我们蓝队的努力成功地挫败了即时探测攻击！</st> <st c="44188">正义得到了伸张，我们的代码现在比以前显著更安全了！</st>
    <st c="44271">这意味着我们的安全工作已经完成了吗？</st> <st c="44313">当然不是，黑客们总是想出新的方法来渗透我们的组织。</st>
    <st c="44403">我们需要保持警惕。</st> <st c="44431">在现实世界的应用中下一步将是回到红队，尝试想出绕过新修复的其他方法。</st>
    <st c="44579">但至少这将更加困难。</st> <st c="44619">尝试一些其他的即时方法，看看您是否还能访问系统提示。</st> <st
    c="44707">现在这肯定更加</st> <st c="44729">困难了！</st>
- en: <st c="44743">You now have a more secure code base, and with the additions made
    in</st> [*<st c="44813">Chapter 3</st>*](B22475_03.xhtml#_idTextAnchor056)<st
    c="44822">, it is more transparent</st> <st c="44847">as well!</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44743">现在您拥有了一个更安全的代码库，并且随着在</st> [*<st c="44813">第三章</st>*](B22475_03.xhtml#_idTextAnchor056)<st
    c="44822">中做出的添加，它变得更加透明</st> <st c="44847">了！</st>
- en: <st c="44855">Summary</st>
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="44855">摘要</st>
- en: <st c="44863">In this chapter, we explored the critical aspect of security in
    RAG applications.</st> <st c="44946">We began by discussing how RAG can be leveraged
    as a security solution, enabling organizations to limit data access, ensure more
    reliable responses, and provide greater transparency of sources.</st> <st c="45140">However,
    we also acknowledged the challenges posed by the black box nature of LLMs and
    the importance of protecting user data</st> <st c="45266">and privacy.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44863">在本章中，我们探讨了RAG应用中安全的关键方面。</st> <st c="44946">我们首先讨论了如何利用RAG作为安全解决方案，使组织能够限制数据访问、确保更可靠的响应，并提高数据来源的透明度。</st>
    <st c="45140">然而，我们也承认了LLM的“黑盒”性质带来的挑战，以及保护用户数据和隐私的重要性。</st>
- en: <st c="45278">We introduced the concept of red teaming a security testing methodology
    that involves simulating adversarial attacks to proactively identify and mitigate
    vulnerabilities in RAG applications.</st> <st c="45470">We explored common areas
    targeted by red teams, such as bias and stereotypes, sensitive information disclosure,
    service disruption,</st> <st c="45602">and hallucinations.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45278">我们介绍了红队概念，这是一种安全测试方法，涉及模拟对抗性攻击，以主动识别和缓解RAG应用中的漏洞。</st> <st c="45470">我们探讨了红队常攻击的常见领域，如偏见和刻板印象、敏感信息泄露、服务中断，以及幻觉。</st>
- en: <st c="45621">Through a hands-on code lab, we demonstrated how to implement
    security best practices in RAG pipelines, including techniques for securely storing
    API keys and defending against prompt injection attacks.</st> <st c="45825">We
    engaged in an exciting red team versus blue team exercise, showcasing how LLMs
    can be both a vulnerability and a defense mechanism in the battle for RAG</st>
    <st c="45981">application security.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45621">通过一个动手代码实验室，我们展示了如何在RAG管道中实施安全最佳实践，包括安全存储API密钥和防御提示注入攻击的技术。</st>
    <st c="45825">我们进行了一场激动人心的红队与蓝队对抗练习，展示了LLM在RAG应用安全斗争中既可以作为漏洞也可以作为防御机制。</st> <st
    c="45981">应用安全。</st>
- en: <st c="46002">Throughout the chapter, we emphasized the importance of ongoing
    vigilance and adaptation in the face of ever-evolving security threats.</st> <st
    c="46139">By understanding the security landscape surrounding RAG applications
    and implementing practical strategies and techniques, you can build secure, trustworthy,
    and robust systems that harness the power of generative AI while prioritizing
    the safety and privacy of users</st> <st c="46407">and businesses.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46002">在整个章节中，我们强调了面对不断演变的网络安全威胁，持续警惕和适应的重要性。</st> <st c="46139">通过了解RAG应用周围的网络安全环境，并实施实际的战略和技术，你可以构建安全、值得信赖且强大的系统，在利用生成式AI力量的同时，优先考虑用户和企业的安全和隐私。</st>
- en: <st c="46422">Generally, we do not claim that this list of security issues or
    solutions is exhaustive.</st> <st c="46512">Our primary goal here was to alert
    you to some of the key security threats you might encounter, but most importantly,
    to always be on guard and diligent at defending your system.</st> <st c="46691">Continually
    think through how your system might be vulnerable, using techniques such as red
    teaming, and use this approach to build much stronger defenses against any</st>
    <st c="46858">potential threats.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46422">通常，我们不声称这份安全问题和解决方案列表是详尽的。</st> <st c="46512">我们在这里的主要目标是提醒你注意你可能会遇到的一些关键安全威胁，但最重要的是，始终保持警惕并勤奋地捍卫你的系统。</st>
    <st c="46691">持续思考你的系统可能存在的漏洞，使用如红队技术等方法，并利用这种方法来构建针对任何潜在威胁的强大防御。</st> <st c="46858">潜在威胁。</st>
- en: <st c="46876">Looking ahead, in the next chapter, we will dive into the practical
    aspects of interfacing with RAG applications using Gradio.</st> <st c="47004">This
    next chapter will provide a hands-on guide to building interactive applications
    with RAG, leveraging Gradio as a user-friendly interface.</st> <st c="47147">You
    will learn how to quickly prototype and deploy RAG-powered applications, enabling
    end users to interact with AI models in</st> <st c="47273">real time.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46876">展望未来，在下一章中，我们将深入探讨使用Gradio与RAG应用交互的实践方面。</st> <st c="47004">下一章将提供一份动手指南，教你如何利用Gradio作为用户友好的界面来构建交互式RAG应用。</st>
    <st c="47147">你将学习如何快速原型设计和部署RAG驱动的应用，使最终用户能够实时与AI模型交互。</st>
- en: <st c="0">Part 2 – Components of RAG</st>
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">第二部分 – RAG的组件</st>
- en: <st c="27">In this part, you will learn about key components of a RAG system
    and how to implement them using LangChain.</st> <st c="137">You’ll explore interfacing
    with RAG using Gradio to create interactive user interfaces, the crucial role
    of vectors and vector stores in enhancing RAG performance, and techniques for
    evaluating RAG quantitatively and with visualizations.</st> <st c="375">Additionally,
    you’ll dive into using LangChain components such as document loaders, text splitters,
    and output parsers to further optimize your</st> <st c="519">RAG pipeline.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，您将学习关于 RAG 系统的关键组件以及如何使用 LangChain 来实现它们。<st c="137">您将探索使用 Gradio 与 RAG
    接口创建交互式用户界面，向量及其存储在增强 RAG 性能中的关键作用，以及评估 RAG 的定量方法和可视化技术。</st> <st c="375">此外，您还将深入了解使用
    LangChain 组件，如文档加载器、文本分割器和输出解析器，以进一步优化您的</st> <st c="519">RAG 管道。</st>
- en: <st c="532">This part contains the</st> <st c="556">following chapters:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="532">本部分包含以下章节：</st> <st c="556">以下章节：</st>
- en: '[*<st c="575">Chapter 6</st>*](B22475_06.xhtml#_idTextAnchor114)<st c="585">,</st>
    *<st c="587">Interfacing with RAG and Gradio</st>*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="575">第 6 章</st>*](B22475_06.xhtml#_idTextAnchor114)<st c="585">,</st>
    *<st c="587">与 RAG 和 Gradio 接口*>'
- en: '[*<st c="618">Chapter 7</st>*](B22475_07.xhtml#_idTextAnchor122)<st c="628">,</st>
    *<st c="630">The Key Role Vectors and Vector Stores Play in RAG</st>*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="618">第 7 章</st>*](B22475_07.xhtml#_idTextAnchor122)<st c="628">,</st>
    *<st c="630">向量和向量存储在 RAG 中的关键作用*>'
- en: '[*<st c="680">Chapter 8</st>*](B22475_08.xhtml#_idTextAnchor152)<st c="690">,</st>
    *<st c="692">Similarity Searching with Vectors</st>*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="680">第 8 章</st>*](B22475_08.xhtml#_idTextAnchor152)<st c="690">,</st>
    *<st c="692">使用向量进行相似性搜索**'
- en: '[*<st c="725">Chapter 9</st>*](B22475_09.xhtml#_idTextAnchor184)<st c="735">,</st>
    *<st c="737">Evaluating RAG Quantitatively and with Visualizations</st>*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="725">第 9 章</st>*](B22475_09.xhtml#_idTextAnchor184)<st c="735">,</st>
    *<st c="737">定量和可视化评估 RAG*>'
- en: '[*<st c="790">Chapter 10</st>*](B22475_10.xhtml#_idTextAnchor218)<st c="801">,</st>
    *<st c="803">Key RAG Components in LangChain</st>*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="790">第 10 章</st>*](B22475_10.xhtml#_idTextAnchor218)<st c="801">,</st>
    *<st c="803">LangChain 中的关键 RAG 组件*>'
- en: '[*<st c="834">Chapter 11</st>*](B22475_11.xhtml#_idTextAnchor229)<st c="845">,</st>
    *<st c="847">Using LangChain to Get More from RAG</st>*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="834">第 11 章</st>*](B22475_11.xhtml#_idTextAnchor229)<st c="845">,</st>
    *<st c="847">使用 LangChain 从 RAG 中获取更多内容*>'
