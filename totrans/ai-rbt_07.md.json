["```py\npip install keras\n```", "```py\npip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118\n```", "```py\n    # import the necessary packages\n    from keras.preprocessing.image import ImageDataGenerator from keras.optimizers import Adam\n    from sklearn.model_selection import train_test_split from keras.preprocessing.image import img_to_array from keras.utils import to_categorical\n    import matplotlib.pyplot as plt import numpy as np\n    import cv2 import os\n    from keras.models import Sequential\n    from keras.layers.convolutional import Conv2D\n    from keras.layers.convolutional import MaxPooling2D\n    from keras.layers.core import Activation\n    from keras.layers.core import Flatten\n    from keras.layers.core import Dense\n    from keras import backend as K\n    ```", "```py\n    class ConvNet():\n        @staticmethod\n        def create(width, height, depth, classes):\n            # initialize the network\n            network = Sequential()\n            inputShape = (height, width, depth)\n            # first set of CONV => RELU => POOL layers\n            network.add(Conv2D(50, (10, 10), padding=\"same\", input_shape=inputShape))\n            network.add(Activation(\"relu\"))\n            network.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n            # second set of CONV => RELU => POOL layers\n            network.add(Conv2D(50, (5, 5), padding=\"same\"))\n            network.add(Activation(\"relu\"))\n            network.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n            # third set of CONV => RELU => POOL layers\n            network.add(Conv2D(50, (5, 5), padding=\"same\"))\n            network.add(Activation(\"relu\"))\n            network.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n            # Fully connected ReLU layers\n            network.add(Flatten())\n            network.add(Dense(500))\n            network.add(Activation(\"relu\"))\n            network.add(Dense(500))\n            network.add(Activation(\"relu\"))\n            # softmax classifier\n            network.add(Dense(classes))\n            network.add(Activation(\"softmax\"))\n            # return the constructed network architecture\n            return network\n    ```", "```py\n    EPOCHS = 25 LEARN_RATE = 1e-3\n    BATCH = 32 # batch size - modify if you run out of memory\n    ```", "```py\n    print (\"Loading Images\")\n    images=[]\n    labels=[]\n    #location of your images\n    imgPath = \"c:\\users\\fxgovers\\documents\\book\\chapter7\\train\\\" imageDirs=[\"left\",\"right\",\"center\"]\n    for imgDir in imageDirs:\n     fullPath = imgPath + imgDir\n     # find all the images in this directory \n     allFileNames = \n     os.listdir(fullPath) ifiles=[]\n     label = imgDirs.index(imgDir) # use the integer version of the \n     label # 0= left, 1 = right, 2 = center\n     for fname in allFileNames:\n       if \".jpg\" in fname:\n          ifiles.append(fname)\n    ```", "```py\n    # process all of the images \n    for ifname in ifiles:\n      # load the image, pre-process it, and store it in the data list image = cv2.imread(ifname)\n      # let's get the image to a known size regardless of what was collected \n      image = cv2.resize(image, (800, 600))\n      halfImage = 800*300 # half the pixels\n      # cut the image in half -we take the top half \n      image = image[0:halfimage]\n      #size the image to what we want to put into the neural network image=cv2.resize(image,(224,224))\n      # convert to grayscale\n      image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) #equalize the image to use the full range from 0 to 255 # this gets rid of a lot of illumination variation \n      image = cv2.equalizeHist(image)\n    ```", "```py\n    # gaussian blur the image to remove high frequency noise # we use a 5x kernel\n    image = cv2.GaussianBlur(img,(5,5),0)\n    ```", "```py\n    # convert to a numpy array image = img_to_array(image)\n    # normalize the data to be from 0 to 1\n    image2 = np.array(image, dtype=\"float\") / 255.0 images=images.append(image) labels.append(label)\n    labels = np.array(labels) # convert to array\n    ```", "```py\n    # split data into testing data and training data 80/20\n    (trainData, testData, trainLabel, testLabel) = train_test_split(data, labels, test_size=0.20, random_state=42)\n    ```", "```py\n    # convert the labels from integers to vectors \n    trainLabel = to_categorical(trainLabel, num_classes=3) testLabel = to_categorical(testLabel, num_classes=3)\n    ```", "```py\n    # initialize the artificial neural network print(\"compiling CNN...\")\n    cnn = ConvNet.build(width=224, height=224, depth=1, classes=3) opt = Adam(lr=LEARN_RATE, decay=LEARN_RATE / EPOCHS) model.compile(loss=\"categorical_crossentropy\", optimizer=opt, metrics=[\"accuracy\"])\n    ```", "```py\n    # train the network\n    print(\"Training network. This will take a while\")\n    trainedNetwork = model.fit_generator(aug.flow(trainImage, trainLabel, batch_size=BATCH),\n    validation_data=(testImage, testLable), steps_per_epoch=len(trainImage) // BATCH,\n    epochs=EPOCHS, verbose=1) # save the model to disk\n    print(\"Writing network to disk\") cnn.save(\"nav_model\")\n    ```", "```py\n    cnn.save(\"toybox_model\")\n    ```", "```py\n    import roslib import sys import rospy import cv2\n    from std_msgs.msg import String\n    from sensor_msgs.msg import Image\n    from geometry_msgs.msg import Twist\n    from cv_bridge import CvBridge, CvBridgeError\n    from keras.preprocessing.image import img_to_array\n    from keras.models import load_model\n    import numpy as np\n    ```", "```py\n    class ROSIF():\n     def  init (self):\n      self.bridge = CvBridge()\n      self.image_sub = rospy.Subscriber(\"image_topic\",Image,self.callback)\n      self.cmd_sub = rospy.Subscriber( \"syscommand\",String,self.cmdCallback) self.cmd_pub = rospy.Publisher( \"syscommand\",String,queue_size=10)\n      self.twist_pub = rospy.Publisher(\"cmd_vel\",Twist,queue_size=10)\n      self.newImage = False\n      self.cmdReceived=\"\"\n    def callback(self):\n     try:\n      self.image = self.bridge.imgmsg_to_cv2(data, \"bgr8\") \n      self.newImage = True\n     except CvBridgeError as e:\n      print(e)\n    def cmdCallback(self,data):\n     # receieve a message on syscommand\n     self.cmdReceived = data.data\n    def getCmd(self):\n     cmd = self.cmdReceived\n     self.cmdReceived = \"\" # clear the command so we dont do it twice\n     return cmd\n    ```", "```py\n    def getImage(self):\n      if self.newImage=True:\n        self.newImage = False\n        # reset the flag so we don't process twice return self.image\n        self.newImage = False\n        # we send back a list with zero elements\n        img = []\n        return img\n    ```", "```py\n    # publishing commands back to the robot\n    def pubCmd(self,cmdstr):\n      self.cmd_pub.publish(String(cmdstr)):\n    def pubTwist(self,cmd):\n      if cmd == 0: # turn left \n        turn = -2\n        speed = 1\n      if cmd==1:\n        turn = 2\n        speed = 1\n      if cmd ==3:\n        turn=0 \n        speed = 1 # all stop\n      if cmd==4:\n        turn = 0\n          speed = 0\n        cmdTwist = Twist()\n        cmdTwist.linear.x = speed\n        cmdTwist.angular.z = turn self.twist_pub.publish(cmdTwist)\n    ```", "```py\n    def processImage(img):\n    # need to process the image\n    image = cv2.resize(image, (640, 480))\n    halfImage = 640*240 # half the pixels\n    # cut the image in half -we take the top half image = image[0:halfimage]\n    #size the image to what we want to put into the neural network\n    image=cv2.resize(image,(224,224))\n    # convert to grayscale\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n     #equalize the image to use the ful\n         image = cv2.equalizeHist(image)\n    # gaussian blur the image to remove high freqency noise # we use a 5x kernel\n    image = cv2.GaussianBlur(img,(5,5),0) # convert to a numpy array\n    image = img_to_array(image)\n    # normalize the data to be from 0 to 1\n    image2 = np.array(image, dtype=\"float\") / 255.0 return image2\n    ```", "```py\n    # MAIN PROGRAM\n    ic = image_converter()\n    rosif = ROSIF()\n    rospy.init_node('ROS_cnn_nav')\n    mode = \"OFF\"\n    # load the model for regular navigation\n    navModel = load_model(\"nav_model\")\n    toyboxModel = load_model(\"toybox_model\")\n    ```", "```py\n    while not rospy.is_shutdown():\n      rospy.spin()\n      time.sleep(0.02)\n    ```"]