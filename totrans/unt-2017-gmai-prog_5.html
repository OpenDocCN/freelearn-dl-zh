<html><head></head><body>
        

                            
                    <h1 class="header-title">Flocks and Crowds</h1>
                
            
            
                
<p>Flocks and crowds are two additional core AI concepts we'll be exploring in this book. As you'll see in this chapter, flocks are relatively simple to implement, and they add a fairly extraordinary amount of realism to your simulation in just a few lines of code. Crowds can be a bit more complex, but we'll be exploring some of the powerful tools that come bundled with Unity to get the job done. In this chapter, we'll cover the following topics:</p>
<ul>
<li>Learning the history of flocks and herds</li>
<li>Understanding the concepts behind flocks</li>
<li>Flocking using the traditional algorithm</li>
<li>Using realistic crowds</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning the origins of flocks</h1>
                
            
            
                
<p>The flocking algorithm dates all the way back to the mid-80s. It was first developed by <em>Craig Reynolds</em>, who developed it for use in films, the most famous adaptation of the technology being the swarm of bats in <em>Batman Returns</em> in 1992, for which he won an Oscar. Since then, the use of the flocking algorithm has expanded beyond the world of film into various fields, from games to scientific research. Despite being relatively efficient and accurate, the algorithm is also very simple to understand and implement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the concepts behind flocks and crowds</h1>
                
            
            
                
<p>As with previous concepts, it's easiest to understand flocks and herds by relating them to the real-life behaviors they model. As simple as it sounds, these concepts describe a group of objects, or boids as they are called in artificial intelligence lingo, moving together as a group. The flocking algorithm gets its name from the behavior birds exhibit in nature, where a group of birds follow one another toward a common destination, mostly keeping a fixed distance from each other. The emphasis here is on the group. We've explored how single agents can move and make decisions on their own, but flocks are a relatively computationally efficient way of simulating large groups of agents moving in unison while modeling unique movement in each boid that doesn't rely on randomness or predefined paths.</p>
<p>The implementation that we'll be building in this chapter for flocking is built upon the concepts originally developed by Craig Reynolds himself. There are many ways to approach Reynolds' flocking behavior, and in our example we've gone with a single-threaded optimized version that allocates no memory. Performance will vary based on the hardware, but generally speaking, the more boids in your flock, the more CPU time it will take to compute the swarm's direction. There are three basic concepts that define how a flock works, and these concepts have been around since the algorithm's introduction in the 80s:</p>
<ul>
<li><strong>Separation</strong>: This means maintaining a distance with other neighbors in the flock to avoid collision. The following diagram illustrates this concept:</li>
</ul>
<div><img height="152" width="203" src="img/5376f28d-d54f-44bd-a6e5-c7d01e066b7e.png"/></div>
<p>Diagram of separation in flocking</p>
<p>In the preceding image, the middle boid is shown moving in a direction away from the rest of the boids, without changing its heading.</p>
<ul>
<li><strong>Alignment</strong>: This means to moving in the same direction as the flock, and with the same velocity. The following image illustrates this concept:</li>
</ul>
<div><img height="140" width="188" src="img/3aaf5ba6-bd9e-42cb-8ada-f15b9a95c815.png"/></div>
<p>Diagram of alignment in flocking</p>
<p>In the preceding image, the boid in the middle is shown changing its heading toward the arrow to match the heading of the boids surrounding it.</p>
<ul>
<li><strong>Cohesion</strong>: This means maintaining a maximum distance from the flock's center. The following image illustrates this concept:</li>
</ul>
<div><img height="143" width="192" src="img/f7a635d5-684e-45b9-9556-04746229e91e.png"/></div>
<p>Diagram of cohesion in flocking</p>
<p>In the preceding image, the boid to the right of the flock moves in the direction of the arrow to be within the minimum distance to its nearest group of boids.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Reynolds algorithm</h1>
                
            
            
                
<p>Without further ado, let's dive into the Reynolds flocking algorithm. There are two main scripts for our flocking implementation: <kbd>Boid.cs</kbd> and <kbd>FlockController.cs</kbd>. The sample code for this chapter provides a scene with all the necessary setup for testing. You'll also notice a third script named <kbd>TargetMovement.cs</kbd>, which we use to move a target that our flock will follow around the scene. </p>
<p>For our boid, we can use a simple cube as a prefab. Of course, feel free to replace the cube with any art you want. Let's add the <kbd>Boid.cs</kbd> script to our boid prefab. The code looks like this:</p>
<pre>using UnityEngine;<br/><br/>public class Boid : MonoBehaviour <br/>{<br/>    [SerializeField]<br/>    private FlockController flockController;<br/>    <br/>    //The modified direction for the boid.<br/>    private Vector3 targetDirection;<br/>    //The Boid's current direction.<br/>    private Vector3 direction;<br/><br/>    public FlockController FlockController <br/>    {<br/>        get { return flockController; }<br/>        set { flockController = value; }<br/>    }<br/>    <br/>    public Vector3 Direction { get { return direction; }}<br/><br/>    private void Awake() <br/>    {<br/>        direction = transform.forward.normalized;<br/>        if(flockController != null) <br/>        {<br/>            Debug.LogError("You must assign a flock controller!");<br/>        }<br/>    }<br/><br/>    private void Update() {<br/>        targetDirection = FlockController.Flock(this, transform.localPosition, direction);<br/>        if(targetDirection == Vector3.zero)<br/>        {<br/>            return;<br/>        }<br/>        direction = targetDirection.normalized;<br/>        direction *= flockController.SpeedModifier;<br/>        transform.Translate(direction * Time.deltaTime);<br/>    } <br/>}</pre>
<p>Right off the bat, you'll notice a reference to <kbd>FlockController</kbd>, which we will create next. You can think of <kbd>FlockController</kbd> as the shared brain of the swarm/flock. Each boid does not need to be aware of its neighbors directly, because <kbd>FlockController</kbd> handles this information separately. This allows us to keep the boid code nice and tidy.</p>
<p>We initialize the direction vector in our <kbd>Awake</kbd> method, and we make sure that the <kbd>FlockController</kbd> is assigned, or we log an error. There are several ways you can enforce null-safety, such as creating the instance if not provided, but in our case we'll assume you assigned the value via the inspector.</p>
<p>The <kbd>Update</kbd> method does the rest of the workit calls the <kbd>Flock()</kbd> method on <kbd>FlockController</kbd> and passes in a reference to itself, its local position, and its direction. This will return a vector that we then normalize to keep movement from appearing jerky or too fast, and apply the movement by using <kbd>Transform.Translate()</kbd>. As usual, make sure you're easing the movement over the <kbd>Time.deltaTime</kbd> to ensure smooth frame-to-frame movement.</p>
<p>It's important to note that we make sure to cache as many <kbd>Vector3</kbd> variables as needed. Avoid allocations by avoiding the use of <kbd>new Vector3()</kbd> where possible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the FlockController</h1>
                
            
            
                
<p>The <kbd>FlockController</kbd> is going to handle the orchestration of the entire flock. There is a quite a bit going on here in terms of variables. Let's take a look at <kbd>FlockController.cs</kbd> chunk by chunk:</p>
<pre>private int flockSize = 20;</pre>
<p>Here, we simply assign the size of our flock. You'll see this value being used up ahead in the <kbd>Awake</kbd> method:</p>
<pre>private float speedModifier = 5;<br/><br/>[SerializeField]<br/>private float alignmentWeight = 1;<br/><br/>[SerializeField]<br/>private float cohesionWeight = 1;<br/><br/>[SerializeField]<br/>private float separationWeight = 1;<br/><br/>[SerializeField]<br/>private float followWeight = 5;</pre>
<p>We then declare a series of modifier and weight values. <kbd>speedModifier</kbd> directly affects how fast our boids can move. Tweak this as needed. The three values following <kbd>speedModifier</kbd> are weight values for alignment, cohesion, and separation, respectively. These values will multiply their weight in the final calculation of all the direction vectors that drive the movement of the boid. <kbd>followWeight</kbd> is used to weight the effect of the target's delta versus the boid. If you want the boids to follow the target more closely, increase this value.</p>
<pre>[SerializeField]<br/>private Boid prefab;<br/>[SerializeField]<br/>private float spawnRadius = 3.0f;<br/>private Vector3 spawnLocation = Vector3.zero;<br/><br/>[SerializeField]<br/>public Transform target;</pre>
<p>The following chunk of variables defines some more setup variables that we assign in the inspector. First, we have the prefab of the boid to spawn (which should have the <kbd>Boid.cs</kbd> component attached to it). <kbd>spawnRadius</kbd> is used to avoid artifacts that may come from spawning all the boids on top of each other if we were to spawn them all on one point. Instead, we spawn them within the given radius, as defined in this variable. Lastly, <kbd>target</kbd> is a reference to the transform of the target our flock/swarm will follow. In our test scene, it's a sphere with the <kbd>TargetMovement.cs</kbd> component attached to it.</p>
<p>Let's take a look at the <kbd>Awake</kbd> method:</p>
<pre>private void Awake()<br/>{<br/>    flockList = new List&lt;Boid&gt;(flockSize); <br/>    for (int i = 0; i &lt; flockSize; i++)<br/>    {<br/>        spawnLocation = Random.insideUnitSphere * spawnRadius + transform.position;<br/>        Boid boid = Instantiate(prefab, spawnLocation, transform.rotation) as Boid;<br/><br/>        boid.transform.parent = transform;<br/>        boid.FlockController = this;<br/>        flockList.Add(boid);<br/>    }<br/>}</pre>
<p>We iterate through a loop enough times to spawn enough boids for our <kbd>flockSize</kbd> variable. This is where our <kbd>spawnLocation</kbd> and <kbd>spawnRadius</kbd> come into play. Unity's <kbd>Random.insideUnitSphere</kbd> generates the random position, which we add to our transform's position to get the actual spawn location. We then instantiate the boid prefab, while assigning to a <kbd>Boid</kbd> instance, which we then add to our <kbd>flockList</kbd>. Also note that we assign the boid instance's <kbd>FlockController</kbd> property in this step.</p>
<p>Keep in mind that instantiating prefabs can be slow in Unity, so increasing the number of boids in the flock will lead to a huge performance dip during the instantiation frame. </p>
<p>The only other method in this class is the <kbd>Flock()</kbd> method, which we saw being called from <kbd>Boid</kbd> earlier. This does all the computation for the individual boids' directions. It looks like this:</p>
<pre>public Vector3 Flock(Boid boid, Vector3 boidPosition, Vector3 boidDirection)<br/>{<br/>    flockDirection = Vector3.zero;<br/>    flockCenter = Vector3.zero;<br/>    targetDirection = Vector3.zero;<br/>    separation = Vector3.zero;<br/><br/>    for (int i = 0; i &lt; flockList.Count; ++i) <br/>    {<br/>        Boid neighbor = flockList[i];<br/>        //Check only against neighbors.<br/>        if (neighbor != boid) <br/>        {<br/>            //Aggregate the direction of all the boids.<br/>            flockDirection += neighbor.Direction;<br/>            //Aggregate the position of all the boids.<br/>            flockCenter += neighbor.transform.localPosition;<br/>            //Aggregate the delta to all the boids.<br/>            separation += neighbor.transform.localPosition - boidPosition;<br/>            separation *= -1;<br/>        }<br/>    }<br/>    //Alignment. The average direction of all boids.<br/>    flockDirection /= flockSize;<br/>    flockDirection = flockDirection.normalized * alignmentWeight;<br/><br/>    //Cohesion. The centroid of the flock.<br/>    flockCenter /= flockSize;<br/>    flockCenter = flockCenter.normalized * cohesionWeight;<br/><br/>    //Separation.<br/>    separation /= flockSize;<br/>    separation = separation.normalized * separationWeight;<br/><br/>    //Direction vector to the target of the flock.<br/>    targetDirection = target.localPosition - boidPosition;<br/>    targetDirection = targetDirection * followWeight;<br/><br/>    return flockDirection + flockCenter + separation + targetDirection;<br/>}</pre>
<p>The method takes some information about our <kbd>Boid</kbd>, as well as a copy of it. We then iterate through every boid in the <kbd>flockList</kbd> and assign the boid at the current iteration's index to a temporary value called <kbd>neighbor</kbd>. To avoid doing multiple loops, we do several things in the same <kbd>for</kbd> loop:</p>
<ul>
<li>Sum up all the neighbors' directions</li>
<li>Sum up all the neighbors' positions</li>
<li>Sum up the position deltas to all neighbors</li>
</ul>
<p>Once done with the loop (and thus aggregating all of the preceding values), we calculate the following:</p>
<ul>
<li>The flock direction, which we get by averaging the direction of all the boids. Since we've already got the sum of all the directions, we just divide it by the number of boids, the <kbd>flockSize</kbd>. We then normalize the value and apply the weight we defined earlier. This will give us our alignment.</li>
<li>Similarly, we get the centroid of the flock by averaging all the positions of all the boids. As with direction, we normalize the vector before applying the weighting. The <kbd>flockCenter</kbd> gives us our cohesion vector.</li>
<li>You may be seeing a pattern here, right? As with the previous two values, we average, normalize, then weight our separation value.</li>
<li><kbd>targetDirection</kbd> is a bit different. We first take the delta between the boid's position and the target's position, then we apply the weight. We don't normalize this value in this implementation, but feel free to experiment by doing so. Normalizing this value won't break the simulation, but you may notice your boids casually floating away from the target if it moves too fast.</li>
</ul>
<p class="mce-root">With all of the values—cohesion, alignment, and separation—calculated, we add them up and return them to the <kbd>Boid</kbd> instance that called the method. The boid will use this vector as its target direction, as we saw in the <kbd>Boid.cs</kbd> file. </p>
<p>Because we could potentially have dozens or hundreds of boids, it's important to avoid any unnecessary computations at runtime. If you profile our implementation, you'll notice it allocates no memory whatsoever, meaning you won't have any annoying stuttering due to garbage collection. While the system will slow down as the boid count goes into the hundreds due to its single-threaded nature, having a few dozen boids is very fast. As you can see in the following screenshot, having a small flock flying around can be computed in less than a millisecond:</p>
<div><img height="238" width="319" src="img/55fe85bc-eac2-400e-a151-842a32fae26a.png"/></div>
<p>The stats panel showing our scene's performance</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The flock target</h1>
                
            
            
                
<p>Last, but not least, we have our flock target. To reiterate, you can use any art you like, or you can stick with the handsome little sphere in the provided sample project. The code for the target component is in the <kbd>TargetMovement.cs</kbd> file. The contents look like this:</p>
<pre>using UnityEngine;<br/><br/>public class TargetMovement : MonoBehaviour <br/>{<br/>    [SerializeField]<br/>    private Vector3 bounds;<br/>    [SerializeField]<br/>    private float moveSpeed = 10.0f;<br/>    [SerializeField]<br/>    private float turnSpeed = 3.0f;<br/>    [SerializeField]<br/>    private float targetPointTolerance = 5.0f;<br/><br/>    private Vector3 initialPosition;<br/>    private Vector3 nextMovementPoint;<br/>    private Vector3 targetPosition;<br/>    <br/>    private void Awake() <br/>    {<br/>        initialPosition = transform.position;<br/>        CalculateNextMovementPoint();<br/>    }<br/><br/>    private void Update () <br/>    {<br/>        transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);<br/>        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(nextMovementPoint - transform.position), turnSpeed * Time.deltaTime);<br/><br/>        if(Vector3.Distance(nextMovementPoint, transform.position) &lt;= targetPointTolerance) <br/>        {<br/>            CalculateNextMovementPoint();<br/>        }<br/>    }<br/><br/>    private void CalculateNextMovementPoint()<br/>    {<br/>        float posX = Random.Range(initialPosition.x - bounds.x, initialPosition.x + bounds.x);<br/>        float posY = Random.Range(initialPosition.y - bounds.y, initialPosition.y + bounds.y);<br/>        float posZ = Random.Range(initialPosition.z - bounds.z, initialPosition.z + bounds.z);<br/>        targetPosition.x = posX;<br/>        targetPosition.y = posY;<br/>        targetPosition.z = posZ;<br/>        nextMovementPoint = initialPosition + targetPosition; <br/>    }<br/>}</pre>
<p>There are two main chunks of work in this class. First, <kbd>Update</kbd> moves the game object towards the <kbd>forward</kbd> vector, while rotating it towards the <kbd>targetPosition</kbd>. We provide two variables to modify the move and turn speed: <kbd>moveSpeed</kbd> and <kbd>turnSpeed</kbd>, respectively. We then check whether we've arrived at the destination point by comparing the distance to it against a tolerance radius that we define in <kbd>targetPointTolerance</kbd>. If we're close enough, we then set the next target point by calling <kbd>CalculateNextMovementPoint()</kbd>.</p>
<p>In <kbd>CalculateNextMovementPoint()</kbd>, we set a random target position, but constrain it based on our bounds values, relative to the position of the target when we first run the script, as we set the <kbd>initialPosition</kbd> in <kbd>Awake</kbd>. Constraining this point will prevent the target from slowly deviating away from our game area and floating off into the sunset. Dramatic as it may be, it's not quite the effect we're going for here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The scene layout</h1>
                
            
            
                
<p>Now that we have all of our code covered, let's take a look at our scene. Our sample scene looks like the following screenshot:</p>
<div><img height="238" width="509" src="img/fb0618ef-90db-4055-be9c-5c970a4da466.png"/></div>
<p>An overview of our scene layout</p>
<p>As you can see in the preceding screenshot, there isn't a lot of complexity to our setup. We have a plane, some environment cubes for perspective, a light, a camera, and our target. The full hierarchy looks like the following screenshot:</p>
<div><img height="213" width="382" src="img/e3512b5a-05c6-446e-a545-a47b397cf1bd.png"/></div>
<p>Our scene hierarchy with FlockController highlighted</p>
<p class="mce-root">As you can see from the preceding screenshot, we have a Directional light, and nested underneath it is a reflection probe. This is strictly for making the scene look nice, and has essentially no functional value, but hey, a little vanity never hurt anyone! We then have an empty game object named FlockController, which our <kbd>FlockController</kbd> script is attached to. The Target game object is a sphere with a bright yellow material and the <kbd>TargetMovement</kbd> script attached to it. All of the environment blocks are nested under the Environment game object, which in this case is a plane. The last three items are there to drive our camera, which will automatically lock on to our target, and keep it in frame. As it is outside the scope of this book, we'll skip over how the camera works, but if you're the curious type, you'll want to explore the official Unity documentation for more information on <strong>Cinemachine</strong> and <strong>Timeline</strong>, which drive the camera in our scene.</p>
<p>Back to the matter at hand—let's take a look at the <kbd>FlockController</kbd>, which looks like the following screenshot:</p>
<div><img height="224" width="380" src="img/a75fa6d5-c731-4065-89cb-7d2ec8322047.png"/></div>
<p>The FlockController component</p>
<p>The preceding screenshot shows the values we have set in the sample scene. As you can see, the separation weight is a bit higher than the rest. Feel free to tweak the weight values in play mode to see how it affects the boids' behavior. Next, let's take a look at the target game object. The following screenshot shows our sample setup:</p>
<div><img height="116" width="457" class="aligncenter size-full wp-image-412 image-border" src="img/3b639f13-9322-4063-9078-79fe5cf80c49.png"/></div>
<p>The test values for our target movement script</p>
<p>The screenshot shows the optimal values for our test scene. Tweaking the bounds might result in some wild camera movement, but play with the move and turn speed to see how it affects the scene in play mode. Lastly, let's take a look at our boid prefab, which has the <kbd>Boid</kbd> component on it. The provided sample project's boid settings can be seen in the following screenshot:</p>
<div><img height="240" width="395" class="aligncenter size-full wp-image-413 image-border" src="img/6d7cd9c4-38d7-4dd5-880a-2e7c785a7cf7.png"/></div>
<p>All the components and setup for the Boid game object</p>
<p>There isn't too much excitement in the preceding screenshot. As you can see, the Flock Controller is empty (because we assign it via code at runtime), and there are no other values to be tweaked on the boid itself, besides the appearance if you feel so inclined, but our neon green cube is a work of art, if I do say so myself.</p>
<p>When you hit play, you'll see your boids spawn and follow the target as it zooms around the scene. It'll look something like the following screenshot:</p>
<div><img height="255" width="455" src="img/a2c2f552-2999-4cd5-a261-ee41ca3f3e40.png"/></div>
<p>Our flock of boids swarming towards the target sphere</p>
<p>And just like that, we've created our very own flocking system. It's highly encouraged that you not only tweak the values in the inspector, but that you take a stab at modifying the code. The easiest way to see how a value affects the entire system is to either remove it, or increase it by a ridiculous amount. Next, we'll take a look at crowds in Unity 2017.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using crowds</h1>
                
            
            
                
<p>Crowd simulations are far less cut-and-dried. There really isn't any <em>one</em> way to implement them in a general sense. While not a strict definition, the term "crowd simulation" generally refers to simulating crowds of humanoid agents navigating an area while avoiding each other and the environment. Like flocks, the use of crowd simulations has been widely used in films. For example, the epic armies of Rohan, Gondor, and Mordor battling one another in <em>The Lord of the Rings</em> were completely procedurally generated using the crowd simulation software <strong>Massive</strong>, which was created for use in the film. While the use of crowd algorithms is not as widespread in video games as in films, certain genres rely on the concept more than others. Real-time strategy games often involve armies of characters moving in unison across the screen, and many sandbox games simulate dense cities with many agents on-screen going about their day while avoiding each other, the player, and even traffic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a simple crowd simulation</h1>
                
            
            
                
<p>Our implementation will be quick, simple, and effective, and it will focus on using Unity's NavMesh feature. Thankfully, NavMesh will handle much of the heavy lifting for us. Our sample Crowds scene has a simple walking surface with a NavMesh baked onto it, a couple of targets, and two teams of capsules, as shown in the following screenshot:</p>
<div><img height="196" width="463" src="img/1959a40f-bac4-421e-bb75-c5579d0a08f1.png"/></div>
<p>The classic scenario: red versus blue</p>
<p>In the preceding screenshot, we can see that our red and blue targets are opposite their teams: red and blue, respectively. Your guess is as good as mine as to why the blue and red clans just can't get along, but it'll work for our sample, so I'm just going to let them do their thing. The setup is straightforward. Each capsule has a <kbd>CrowdAgent.cs</kbd> component attached to it, and when you hit play, each agent will head towards their target while avoiding each other and the oncoming capsules from the opposite team. Once they reach their destination, they will gather around the target.</p>
<p>This setup takes our example from <a href="503803fe-f343-4a0c-835f-463c98005182.xhtml">Chapter 4</a>, <em>Finding Your Way </em>and takes it to the next level. Now we have large groups of agents that are not only navigating to a target location, but doing so while avoiding large groups of agents at the same time. As you can see, Unity's NavMesh handles these interactions beautifully. The system is efficient and very robust.</p>
<p>While the game is running, you can even select a single capsule or a group of them in the editor to see their behavior visualized. As long as you have the navigation window active, you'll be able to see some debugging information about your NavMesh and the agents on it, as you can see in the following screenshot:</p>
<div><img height="343" width="360" class="aligncenter size-full wp-image-427 image-border" src="img/54ded18e-6ecc-4350-ae27-39cf54c1c6a0.jpg"/></div>
<p>The debug view from an agent's perspective</p>
<p>It's worth checking this out in the editor to really get an idea of how this looks in motion, but we've labeled a few key elements in the preceding screenshot:</p>
<ol>
<li>This is the destination arrow that points toward the <kbd>NavMeshAgent</kbd> destination, which for this little guy is <kbd>RedTarget</kbd>. All this arrow cares about is where the destination is, regardless of the direction the agent is facing or moving toward.</li>
<li>This arrow is the heading arrow. It shows the actual direction the agent is moving in. The direction of the agent takes into account several factors, including the position of its neighbors, space on the NavMesh, and the destination.</li>
<li>This debug menu allows you to show a few different things. In our case, we enabled Show Avoidance and Show Neighbours.</li>
</ol>
<ol start="4">
<li>Speaking of avoidance, this cluster of squares, ranging from dark to light and floating over the agents, represents the areas to avoid between our agent and the destination. The darker squares indicate areas that are densely populated by other agents or blocked by the environment, while the lighter-white squares indicate areas that are safe to walk through. Of course, this is a dynamic display, so watch it change as you play in the editor.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the CrowdAgent component</h1>
                
            
            
                
<p>The <kbd>CrowdAgent</kbd> component is incredibly simple, but gets the job done. As mentioned earlier, Unity does most of the heavy lifting for us. The following code gives our <kbd>CrowdAgent</kbd> a destination:</p>
<pre>using UnityEngine; 
using System.Collections; 
 
[RequireComponent(typeof(NavMeshAgent))] 
public class CrowdAgent : MonoBehaviour <br/>{         
    public Transform target; 
 
    private NavMeshAgent agent; 
 
    void Start () <br/>    { 
        agent = GetComponent&lt;NavMeshAgent&gt;(); 
        agent.speed = Random.Range(4.0f, 5.0f); 
        agent.SetDestination(target.position); 
    } 
}</pre>
<p class="mce-root">The script requires a component of type <kbd>NavMeshAgent</kbd>, which it assigns to the <kbd>agent</kbd> variable on <kbd>Start()</kbd>. We then set its speed randomly between two values for some added visual variety in our simulation. Lastly, we set its destination to be the position of the target marker. The target marker is assigned via the inspector, as you can see in the following screenshot:</p>
<div><img height="314" width="310" src="img/ab320924-64ec-410f-809f-2b8ca35d8525.png"/></div>
<p>The inspector settings for the NavMeshAgent</p>
<p>The preceding screenshot illustrates a red capsule's <kbd>CrowdAgent</kbd> component with RedTarget (Transform) set as its Target. For fun, you can try setting different targets. Since the only requirement is that it be of type <kbd>Transform</kbd>, you could even set another agent as the target!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding some fun obstacles</h1>
                
            
            
                
<p>Without having to do anything else in our code, we can make a few changes to our scene layout and enable a few components provided by Unity to dramatically alter the behavior of our agents. In our <kbd>CrowdsObstacles</kbd> scene, we've added a few walls to the environment, creating a maze-like layout for our red and blue teams of capsules to traverse, as you can see in the following screenshot:</p>
<div><img height="851" width="1950" class="aligncenter size-full wp-image-428 image-border" src="img/248be45b-ff66-4947-9771-ba2dcfdc1296.png"/></div>
<p>Let the games begin!</p>
<p>The fun part about this example is that, because of the randomized speed of each agent, the results will be totally different each time you run the game. As the agents move through the environment, they'll be blocked by teammates or opposing agents and will be forced to re-route and find the quickest route to their target. Of course, this concept is not new to us, as we saw <kbd>NavMeshAgent</kbd> avoiding obstacles in <a href="503803fe-f343-4a0c-835f-463c98005182.xhtml">Chapter 4</a>, <em>Finding Your Way</em>, except that we have many, many more agents in this scenario. To add a bit more fun to the example, we've also added a simple up-down animation to one of the walls and a <kbd>NavMeshObstacle</kbd> component, which looks something like this:</p>
<div><img height="332" width="442" src="img/e4d97355-d9ae-465b-9eb5-67d6500a0d9d.png"/></div>
<p>NavMeshObstacle looks a bit different in Unity 2017</p>
<p>Note that our obstacle does not need to be set to Static when we are using this component. Our obstacle is mostly box-like, so we leave the default Shape setting as Box (Capsule is another choice). The Size and Center options let us move the outline of our shape around and resize it, but the default settings fit our shape perfectly, which is what we want, so let's leave that alone. The next option, Carve, is important. It essentially does exactly what it says; it carves a space out of the NavMesh, as shown in the following screenshot:</p>
<div><img src="img/12c743d8-ed57-48d0-9ec6-e2b15056d012.jpg"/></div>
<p>The same obstacle at two different points of its up-down animation</p>
<p>The left screenshot shows the space carved out when the obstacle is on the surface, while the NavMesh is connected in the right screenshot when the obstacle is raised off the surface. We can leave Time to Stationary and Move Threshold as they are, but we do want to make sure that Carve Only Stationary is turned off. This is because our obstacle is moving, and if we didn't tick this box, it would not carve out the space from the NavMesh, and our agents would be trying to move through the obstacle whether it was up or down, which is not the behavior we are after in this case.</p>
<p>As the obstacle moves up and down and the mesh is carved out and reconnected, you'll notice the agents changing their heading. With the navigation debug options enabled, we can also see a very interesting visualization of everything going on with our agents at any given moment. It may seem a bit cruel to mess with our poor agents like this, but we're doing it for science!</p>
<p>The following screenshot gives us a glimpse into the chaos and disorder we're subjecting our poor agents to:</p>
<div><img height="234" width="468" src="img/8d98f34b-bff9-4c65-ad54-1be5fd8138bf.jpg"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>I'm secretly rooting for the blue team</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to implement a flocking behavior system. We implemented it using custom direction vectors to control the boids' movement that we calculated by applying Craig Reynolds' three main flocking concepts—alignment, coherence, and separation. We then applied our flocking behavior to the flying objects, but you can apply the techniques in these examples to implement other character behaviors, such as fish shoaling, insects swarming, or land animals herding. You'll only have to implement different leader movement behaviors, such as limiting movement along the <em>y</em> axis for characters that can't move up and down. For a 2D game, we would just freeze the <em>y</em> position. For 2D movement along uneven terrain, we would have to modify our script to not put any forces in the <em>y</em> direction. </p>
<p>We also took a look at crowd simulation and even implemented our own version of it using Unity's NavMesh system, which we first learned about in <a href="503803fe-f343-4a0c-835f-463c98005182.xhtml">Chapter 4</a>, <em>Finding Your Way</em>. We learned how to visualize our agents' behavior and decision-making process.</p>
<p>In the next chapter, we'll look at the behavior tree pattern and learn to implement our own version of it from scratch.</p>


            

            
        
    </body></html>