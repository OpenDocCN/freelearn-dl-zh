- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Behavior Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the universe of game development, **behavior trees** are hierarchical structures
    that govern the decision-making processes of AI characters, determining their
    actions and reactions during gameplay. As a game programmer, delving into the
    intricacies of behavior trees is crucial, as it will empower you with the ability
    to craft dynamic, intelligent, and engaging virtual entities that enhance the
    player’s game experience.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to provide a gentle introduction to behavior trees and Blackboards,
    as well as their application within the Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be covering the following topics
  prefs: []
  type: TYPE_NORMAL
- en: Explaining behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding behavior trees in Unreal Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Blackboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no technical requirements to follow this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining behavior trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its broader sense, a behavior tree is a mathematical model used in many fields
    of computer science, including video games. It outlines the transition between
    a finite set of tasks in a modular manner. The power of behavior trees lies in
    their ability to create intricate tasks from simple components, without going
    into the details of how each component is implemented. While behavior trees share
    some similarities with hierarchical state machines – where states are organized
    in a hierarchy, allowing for better reuse of behaviors – the primary distinction
    lies in the fact that tasks, not states, serve as the fundamental elements of
    behavior. The main advantage is their intuitive nature, making them less prone
    to errors; this is why they are highly favored within the game development industry.
  prefs: []
  type: TYPE_NORMAL
- en: Today’s video games are increasingly intricate, leading to a proportional complexity
    in AI characters. Hence, the maintenance of these characters – or agents – is
    crucial. Unlike systems such as finite state machines, which become difficult
    to maintain as the number of states increases, behavior trees offer a practical
    and scalable solution for decision-making processes. When an agent executes a
    behavior tree, it conducts a **depth-first search** to locate and execute the
    lowest-level leaf node.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantages of behavior trees over other systems lie in their scalability,
    expressiveness, and extensibility. Unlike other systems, behavior trees do not
    involve explicit transitions between states; instead, each node in the tree specifies
    how to run its children. This stateless nature eliminates the need to track previously
    executed nodes to determine the next set of behaviors. The expressiveness of behavior
    trees stems from the use of various levels of abstraction, implicit transitions,
    and complex control structures for composite nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, in behavior trees, transitions occur through calls and return values
    exchanged between tree nodes, facilitating a two-way control transfer mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior tree structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A behavior tree is visually depicted as a tree structure with nodes categorized
    as **root** , **control flow** , and **execution** – or **tasks** . In this representation,
    each node may have a parent node and one or more children. In particular, the
    following is worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: The root node has no parents and only one child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow nodes have one parent and at least one child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution nodes have one parent and no children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A behavior tree is executed starting from the root, which sends execution triggers
    to its child nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a control flow node is reached, it will control the execution and flow
    of decision-making within the tree, determining which tasks or sub-trees should
    be executed based on certain conditions or rules.
  prefs: []
  type: TYPE_NORMAL
- en: Every time an execution node is triggered, it will execute a specific task,
    reporting back to its parent with a status of *running* if the task is ongoing,
    *success* if the objective is accomplished, or *failure* if the task is unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7* *.1* shows an example of a behavior tree execution, starting from
    the root, going to a control flow node, and finally executing a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Behavior tree example](img/Figure_7.1_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Behavior tree example
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Behavior tree nodes are executed from top to bottom and left to right; this
    is also the way they are usually numbered.
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying that there isn’t just one way to implement behavior trees.
    That’s why in the next section, I’ll dive into all the nitty-gritty details about
    the Unreal Engine system.
  prefs: []
  type: TYPE_NORMAL
- en: What is a behavior tree in Unreal Engine?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unreal Engine, behavior trees are assets that are edited in a similar way
    to Blueprints – that is, visually – by adding and linking a set of nodes with
    specific functionalities to form a **behavior tree graph** . During the execution
    of logic in a behavior tree, a separate asset known as a Blackboard – further
    details on this will be provided later in this chapter – is used to retain information
    that the behavior tree requires to make well-informed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: A behavior tree is handled by a **BehaviorTreeComponent** instance that is held
    by the **AIController** instance. It should be noted that the component is not
    automatically attached to the controller; you will need to add it through C++
    or Blueprints. If no component is present, it will automatically be created at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing Unreal Engine behavior trees with other behavior tree systems,
    one key distinction to keep in mind is their event-driven nature, which prevents
    constant code execution. Instead of continuously checking for relevant changes,
    an Unreal Engine behavior tree listens for events that can prompt tree modifications.
    Using an event-driven architecture provides performance enhancements and debugging
    capabilities benefits – this is something I will show in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior tree node instancing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It needs to be noted that behavior trees exist as **shared objects** in your
    project; this means that all agents using a behavior tree will share the same
    instance, and all shared objects will be unable to store agent-specific data.
    The main advantages of using shared nodes are CPU speed improvement and reduced
    memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Agent-specific data can be leveraged in many ways – one being the Blackboard
    that we will see later in this chapter – to give you more flexibility on how to
    use your behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Another such method is instancing single nodes; this will grant each AI agent
    using a behavior tree a unique instance of the node at the cost of higher performance
    and memory usage. An example of a node using such a method is the **PlayAnimation**
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Order of execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously mentioned, behavior tree nodes are executed from top to bottom
    and left to right and Unreal Engine is no exception. Nodes are numbered following
    this convention to easily track the execution order. *Figure 7* *.2* shows a behavior
    tree from the **Lyra Starter Game** project, showing the nodes with their corresponding
    sequence numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Behavior tree sequence](img/Figure_7.2_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Behavior tree sequence
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, a root node is never numbered because it is not considered
    part of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have received a gentle introduction to behavior trees and
    how they are executed. The next section will delve deeper into the Unreal Engine
    system to help you better understand how to incorporate behavior trees effectively
    into your games.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding behavior trees in Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding behavior trees and what they are made of is essential for designing
    effective AI systems in Unreal Engine; in this section, I will be presenting you
    with the key concepts associated with behavior trees to help you start developing
    your own AI characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal Engine, there are five types of elements in behavior trees:'
  prefs: []
  type: TYPE_NORMAL
- en: Root node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide you with a comprehensive understanding of each type, I will present
    them individually, ensuring a clear depiction of their respective functions.
  prefs: []
  type: TYPE_NORMAL
- en: The root node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The root node functions as the initial point for a behavior tree; it holds
    a distinct position within the tree and is governed by a set of special rules:'
  prefs: []
  type: TYPE_NORMAL
- en: There can be only one such node in the tree structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can have only one connection, and if this connection is removed, then the
    entire tree is disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not support the attachment of decorator or service nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Root node](img/Figure_7.3_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Root node
  prefs: []
  type: TYPE_NORMAL
- en: Task nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Task nodes are responsible for performing actions such as moving an AI or adjusting
    Blackboard values. A task will not stop its execution until a failure or success
    result is reported.
  prefs: []
  type: TYPE_NORMAL
- en: A task node can also have one or more decorators or services attached, allowing
    for more complex behaviors and interactions within the game environment.
  prefs: []
  type: TYPE_NORMAL
- en: Task nodes
  prefs: []
  type: TYPE_NORMAL
- en: Tasks are identified by a purple color.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Task examples](img/Figure_7.4_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Task examples
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine includes a set of pre-built tasks that are readily available for
    use. These tasks address the most generic scenarios that developers are likely
    to require. However, tasks can be extended to allow you to create your own custom
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a partial list of some of the tasks that will be available to you as
    standard features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finish With Result** : Once executed, this node will instantly finish with
    a defined result – **Succeeded** , **Failed** , **Aborted** , or **In Progress**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move To** : Once executed, it will move the AI agent to a target location
    by using the Navigation System'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move Directly Toward** : Once executed, it will move the AI agent to a target
    location without using the Navigation System'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wait** : Once executed, it will cause the behavior tree to wait on this node
    until a specified time has passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play Animation** : Once executed, this node will play a specified animation
    asset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play Sound** : Once executed, this node will play a specified sound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, tasks represent individual actions or operations that an AI
    agent can perform; you can use them to create simple actions or combine several
    to create more complex behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Composite nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composite nodes define the root of a branch and set the rules for its execution;
    additionally, they are the only nodes that can be applied to the root node of
    a behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: A composite node can also have decorators and services applied, enabling more
    complex logic in it. Once a service is applied, it will be active while the children
    of the composite are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Composite nodes
  prefs: []
  type: TYPE_NORMAL
- en: Composites are identified by a grey color.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three composite nodes available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selectors**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple parallels**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequences**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s examine them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selector nodes execute their children sequentially from left to right, and they
    will halt execution as soon as one of them succeeds. When a child of a selector
    node succeeds, the selector itself is considered successful. On the other hand,
    if all the selector’s children fail, the selector node itself is marked as failed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Selector node](img/Figure_7.5_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Selector node
  prefs: []
  type: TYPE_NORMAL
- en: Simple parallels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simple parallel nodes enable the execution of a single main task node concurrently
    with a complete tree. After the main task is completed, you may decide – through
    the **Finish Mode** attribute – whether the node should immediately finish, halting
    the secondary tree, or whether it should wait for the secondary tree to finish
    before completing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Simple Parallel node](img/Figure_7.6_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Simple Parallel node
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sequence nodes run their children sequentially from left to right. They halt
    execution when a child fails. If a child fails, the sequence also fails. Unlike
    selectors, the success of the sequence is achieved only when all its children
    succeed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Sequence node](img/Figure_7.7_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Sequence node
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decorators – sometimes also referred to as conditionals – are used to determine
    whether a branch in the tree, or even a single node, can be executed. They must
    be attached to either a composite or a task node.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators play a crucial role in determining the execution path of branches
    within the behavior tree; they essentially act as decision-makers, evaluating
    whether a specific branch or individual node should proceed with execution. They
    serve as a condition, assessing the viability of continuing down a particular
    branch, signaling a precautionary failure if the task – or a sub-tree – is destined
    to fail. This preemptive action helps prevent the decorator from attempting to
    carry out a task – or sub-tree – that is bound to fail due to various reasons
    such as insufficient information or outdated objectives.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are identified by a blue color.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Decorator applied to a Selector](img/Figure_7.8_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Decorator applied to a Selector
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine includes a set of pre-built decorators that are readily available
    for use, but they can be extended to allow you to create your own custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a partial list of some of the tasks that will be available to you as
    standard features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blackboard** : Will check whether a value has been set – or not set – on
    a given Blackboard key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite** : Will let you create some more advanced logic than built-in
    nodes by using **AND** , **OR** , and **NOT** nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cooldown** : Will lock the execution of a node or a branch until a predefined
    time has passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Does Path Exists** : Will check whether a path is found between two points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop** : Will loop a node or a branch indefinitely – or a number of times,
    if set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most decorators include an **Inverse Condition** property, that will let you,
    well... invert the condition, giving you more flexibility. As an example, you
    may use the same decorator in a behavior tree to execute different tasks under
    opposite conditions.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you may use **Does Path Exist** to move an AI agent to a target
    point and use **Inverse Condition** on another instance of **Does Path Exist**
    to look for an alternative target point.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, decorators serve as decision points that determine whether a
    certain action or branch within the behavior tree should be executed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services can be attached to composite or task nodes and run at specific intervals
    – defined in the **Interval** attribute – while their branch is active. They are
    commonly employed for conducting checks and updating the Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: Once triggered by a task or a composite, a service will keep executing regardless
    of the number of parent-child levels being executed below the owing node.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs: []
  type: TYPE_NORMAL
- en: Services are identified by a green color.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Service applied to a Selector](img/Figure_7.9_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Service applied to a Selector
  prefs: []
  type: TYPE_NORMAL
- en: 'Services are very specific to the behavior tree you are developing; this means
    that, most probably, you will have to create your own custom ones. However, Unreal
    Engine provides two pre-built services that are readily available for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default Focus** : This enables quick access to an actor from the AI controller
    instead of using a Blackboard key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run EQS** : This can be used to regularly execute an EQS – more on this in
    [*Chapter 11*](B31016_11.xhtml#_idTextAnchor218) , *Understanding the Environment
    Query System* – at assigned intervals. It can also update a specified Blackboard
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having covered the various types of nodes that make up a behavior tree, it’s
    now time to get into the next section in order to delve into Blackboard assets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Blackboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unreal Engine, the Blackboard is a crucial component of behavior trees; it
    acts as a memory space – some sort of brain – where AI agents can read and write
    data during their decision-making process. This means that developers will be
    able to query and update information stored within it.
  prefs: []
  type: TYPE_NORMAL
- en: The Blackboard is created as a **Blackboard Data** asset, which will be assigned
    to a behavior tree, and it contains a set of variables – named keys – that store
    specific information of predefined types. These keys can be accessed and manipulated
    during runtime to influence the decision-making of AI characters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Blackboard example](img/Figure_7.10_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Blackboard example
  prefs: []
  type: TYPE_NORMAL
- en: A key can be set to **Instance Synced** ; in this case, the key itself will
    be synchronized across all instances of the Blackboard. This synchronization ensures
    that any changes made to the value of the key will be reflected consistently across
    all instances of the AI agents sharing the same behavior tree and Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – The Instance Synced property](img/Figure_7.11_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – The Instance Synced property
  prefs: []
  type: TYPE_NORMAL
- en: 'A Blackboard can store up to 255 keys and it supports the following data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FVector**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FRotator**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bool**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int32**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UClass**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UObject**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FName**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UEnum**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FString**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A Blackboard cannot store arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The **BlackboardComponent** instance will allow you to query data from a Blackboard
    and store data in the Blackboard itself. The creation system follows a similar
    pattern to the **BehaviorTreeComponent** , as explained previously in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its apparent simplicity, understanding how a Blackboard works is crucial
    for ensuring the effective functioning of your AI agents.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to the behavior tree system. Beginning with
    a brief theoretical overview, we saw how behavior trees function in Unreal Engine
    and learned about the key components that constitute the entire system. Finally,
    we discussed the Blackboard asset, a crucial element for the effective operation
    of behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for the upcoming chapter, where we will guide you back into action
    and make you craft a behavior tree for our very own dummy character. Specifically,
    you will be creating your own custom services and tasks in order to give our soon-to-be
    AI agent a proper AI brain. Brace yourself, because things are about to get intriguingly
    wild and – sometimes – delightfully chaotic!
  prefs: []
  type: TYPE_NORMAL
