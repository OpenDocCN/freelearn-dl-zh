<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer153">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 class="chapterTitle" id="_idParaDest-111"><span class="koboSpan" id="kobo.2.1">Using LLMs with Structured Data</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to cover yet </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.4.1">another great capability of </span><strong class="keyWord"><span class="koboSpan" id="kobo.5.1">large language models</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.7.1">LLMs</span></strong><span class="koboSpan" id="kobo.8.1">): the ability to handle structured, tabular data. </span><span class="koboSpan" id="kobo.8.2">We will see how, thanks to plugins and an agentic approach, we can use LLMs as a natural language interface between us and our structured data, reducing the gap between the business user and the structured information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">During this chapter, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Introduction to the main structured data systems</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Using tools and plugins to connect LLMs to tabular data</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Building a database copilot with LangChain</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you will be able to build your own natural language interface for your data estate and be able to combine unstructured with structured sources.</span></p>
<h1 class="heading-1" id="_idParaDest-112"><span class="koboSpan" id="kobo.14.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.15.1">To complete the tasks in this chapter, you will need the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">A Hugging Face account and user access token.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">An OpenAI account and user access token.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Python 3.7.1 or later version.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Python packages: Make sure to have the following Python packages installed: </span><code class="inlineCode"><span class="koboSpan" id="kobo.20.1">langchain</span></code><span class="koboSpan" id="kobo.21.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">python-dotenv</span></code><span class="koboSpan" id="kobo.23.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.24.1">huggingface_hub</span></code><span class="koboSpan" id="kobo.25.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.26.1">streamlit</span></code><span class="koboSpan" id="kobo.27.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.28.1">sqlite3</span></code><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">Those can be easily installed via </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">pip install</span></code><span class="koboSpan" id="kobo.31.1"> in your terminal.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.32.1">You can find all the code and examples in the book’s GitHub repository at </span><a href="Chapter_08.xhtml"><span class="url"><span class="koboSpan" id="kobo.33.1">https://github.com/PacktPublishing/Building-LLM-Powered-Applications</span></span></a><span class="koboSpan" id="kobo.34.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-113"><span class="koboSpan" id="kobo.35.1">What is structured data?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.36.1">In previous chapters, we focused on how LLMs can handle textual data. </span><span class="koboSpan" id="kobo.36.2">In fact, those models are, as the name suggests, “language” models, meaning</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.37.1"> that they have been trained and are able to handle unstructured text data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.38.1">Nevertheless, unstructured data only refers to a portion of the overall data realm that applications can handle. </span><span class="koboSpan" id="kobo.38.2">Generally, data can be categorized into three types, which are as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.39.1">Unstructured data</span></strong><span class="koboSpan" id="kobo.40.1">: This refers to </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.41.1">data that doesn’t have a specific or predefined format. </span><span class="koboSpan" id="kobo.41.2">It lacks a consistent structure, making it challenging to organize and analyze using traditional databases. </span><span class="koboSpan" id="kobo.41.3">Examples of unstructured data include:</span><ul>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.42.1">Text documents: Emails, social media posts, articles, and reports.</span></li>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.43.1">Multimedia: Images, videos, audio recordings.</span></li>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.44.1">Natural language text: Chat logs, transcriptions of spoken conversations.</span></li>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.45.1">Binary data: Files without a specific data format, such as proprietary file formats.</span></li>
</ul>
</li>
</ul>
<div class="note-one">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.47.1">When it comes to storing unstructured data, NoSQL databases play a crucial role, due to their flexible schema-less design, which allows them to handle various data types like text, images, and videos efficiently. </span><span class="koboSpan" id="kobo.47.2">The term “NoSQL” originally stood for “non-SQL” or “not only SQL” to emphasize that these databases don’t rely solely on the</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.48.1"> traditional </span><strong class="keyWord"><span class="koboSpan" id="kobo.49.1">Structured Query Language</span></strong><span class="koboSpan" id="kobo.50.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.51.1">SQL</span></strong><span class="koboSpan" id="kobo.52.1">) to manage and query data. </span><span class="koboSpan" id="kobo.52.2">NoSQL databases emerged as a response to the limitations of relational databases, particularly their rigid schema requirements and difficulties in scaling horizontally.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.53.1">An example of a NoSQL database is MongoDB, a</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.54.1"> document-oriented NoSQL database, which stores data in JSON-like documents, making it highly effective for managing diverse unstructured content; similarly, Cassandra, with its wide-column store model, excels at handling large volumes of data across many commodity servers, providing high availability without compromising performance. </span><span class="koboSpan" id="kobo.54.2">This flexibility enables NoSQL databases to adapt to the volume, variety, and velocity of unstructured data, accommodating rapid changes and scaling easily. </span><span class="koboSpan" id="kobo.54.3">Traditional relational databases, with their rigid schema requirements, struggle to manage such diversity and volume efficiently.</span></p>
</div>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.55.1">Structured data</span></strong><span class="koboSpan" id="kobo.56.1">: This type of data is organized and formatted with a clear structure, typically into rows and </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.57.1">columns. </span><span class="koboSpan" id="kobo.57.2">It follows a fixed schema, making it easy to store, retrieve, and analyze using relational databases. </span><span class="koboSpan" id="kobo.57.3">Examples of structured data include:</span><ul>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.58.1">Relational databases: Data </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.59.1">stored in tables with predefined columns and data types.</span></li>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.60.1">Spreadsheets: Data organized in rows and columns in software like Microsoft Excel.</span></li>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.61.1">Sensor data: Recorded measurements like temperature, pressure, and time in a structured format.</span></li>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.62.1">Financial data: Transaction records, balance sheets, and income statements.</span></li>
</ul>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.63.1">Semi-structured data</span></strong><span class="koboSpan" id="kobo.64.1">: This falls between the two categories. </span><span class="koboSpan" id="kobo.64.2">While it doesn’t adhere to a rigid structure like </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.65.1">structured data, it has some level of organization and may contain tags or other markers that provide context. </span><span class="koboSpan" id="kobo.65.2">Examples of semi-structured data include:</span><ul>
<li class="bulletList level-2"><strong class="keyWord"><span class="koboSpan" id="kobo.66.1">eXtensible Markup Language</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.68.1">XML</span></strong><span class="koboSpan" id="kobo.69.1">) files: They use tags to structure data, but the specific tags and their </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.70.1">arrangement can vary.</span></li>
<li class="bulletList level-2"><strong class="keyWord"><span class="koboSpan" id="kobo.71.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.72.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.73.1">JSON</span></strong><span class="koboSpan" id="kobo.74.1">): This is used for data interchange and allows for nested structures</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.75.1"> and key-value pairs.</span></li>
<li class="bulletList level-2"><span class="koboSpan" id="kobo.76.1">NoSQL databases: Storing data in a format that doesn’t require a fixed schema, allowing for flexibility.</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.77.1">In summary, unstructured data lacks a defined format, structured data follows a strict format, and semi-structured data has some level of structure but is more flexible than structured data. </span><span class="koboSpan" id="kobo.77.2">The distinction between these types of data is important as it impacts how they are stored, processed, and analyzed in various applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.78.1">However, regardless of its nature, querying structured data involves using a query language or methods specific to that database technology. </span><span class="koboSpan" id="kobo.78.2">For example, for SQL databases, SQL is used to interact with relational databases. </span><span class="koboSpan" id="kobo.78.3">Henceforth, to extract data from tables, you need to know this specific language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.79.1">But what if we want to ask questions in natural language to our structured data? </span><span class="koboSpan" id="kobo.79.2">What if our application could provide us not only with a sterile numeric answer but rather with a conversational answer, which also gives us context about the number? </span><span class="koboSpan" id="kobo.79.3">This is exactly what we will try to achieve in the next </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.80.1">sections with our LLM-powered applications. </span><span class="koboSpan" id="kobo.80.2">More specifically, we are going build something that we’ve already defined in </span><em class="chapterRef"><span class="koboSpan" id="kobo.81.1">Chapter 2</span></em><span class="koboSpan" id="kobo.82.1">: a </span><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">copilot</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">Since we</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.85.1"> are going to mount our copilot to a relational database, we will </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.86.1">name our application </span><strong class="keyWord"><span class="koboSpan" id="kobo.87.1">DBCopilot</span></strong><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">First, let’s look at what relational databases are.</span></p>
<h1 class="heading-1" id="_idParaDest-114"><span class="koboSpan" id="kobo.89.1">Getting started with relational databases</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.90.1">The concept of relational databases was first proposed by E.F. </span><span class="koboSpan" id="kobo.90.2">Codd, an IBM researcher, in 1970. </span><span class="koboSpan" id="kobo.90.3">He defined the rules and principles of the relational model, which aimed to provide a simple and consistent way of </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.91.1">accessing and manipulating data. </span><span class="koboSpan" id="kobo.91.2">He also introduced SQL, which became the standard language for querying and manipulating relational databases. </span><span class="koboSpan" id="kobo.91.3">Relational databases have become widely used in various domains</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.92.1"> and applications, such as e-commerce, inventory </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.93.1">management, payroll, </span><strong class="keyWord"><span class="koboSpan" id="kobo.94.1">customer relationship management</span></strong><span class="koboSpan" id="kobo.95.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.96.1">CRM</span></strong><span class="koboSpan" id="kobo.97.1">), and </span><strong class="keyWord"><span class="koboSpan" id="kobo.98.1">business intelligence</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.100.1">BI</span></strong><span class="koboSpan" id="kobo.101.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.102.1">In this section, we are going to cover the main aspects of a relational database. </span><span class="koboSpan" id="kobo.102.2">Then, we will start working with the sample database we will use in our DBCopilot, the Chinook database. </span><span class="koboSpan" id="kobo.102.3">We will inspect this database and explore how to connect to remote tables using Python.</span></p>
<h2 class="heading-2" id="_idParaDest-115"><span class="koboSpan" id="kobo.103.1">Introduction to relational databases</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.104.1">A relational database is a type of database </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.105.1">that stores and organizes data in structured tables with rows and columns. </span><span class="koboSpan" id="kobo.105.2">Each row represents a record, and each column represents a field or attribute. </span><span class="koboSpan" id="kobo.105.3">The relationships between tables are established through keys, primarily the primary key and foreign key. </span><span class="koboSpan" id="kobo.105.4">This allows for efficient querying and manipulation of data using SQL. </span><span class="koboSpan" id="kobo.105.5">These databases are commonly used for various applications like websites and business management systems, due to their ability to manage structured data effectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.106.1">To have a better understanding of relational databases, let’s consider an example of a database of a library. </span><span class="koboSpan" id="kobo.106.2">We’ll have two tables: one for books and another for authors. </span><span class="koboSpan" id="kobo.106.3">The relationship between them will be established using primary and foreign keys.</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.107.1">Definition</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.108.1">A primary key is like the unique</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.109.1"> fingerprint of each record in a table. </span><span class="koboSpan" id="kobo.109.2">It’s a special column that holds a value that’s distinct for each row in that table. </span><span class="koboSpan" id="kobo.109.3">Think of it as the “identity” of a record. </span><span class="koboSpan" id="kobo.109.4">Having a primary key is important because it guarantees that no two records in the same table will share the same key. </span><span class="koboSpan" id="kobo.109.5">This uniqueness makes it easy to locate, modify, and manage individual records in the table.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.110.1">A foreign key is a bridge between </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.111.1">two tables. </span><span class="koboSpan" id="kobo.111.2">It’s a column in one table that references the primary key column in another table. </span><span class="koboSpan" id="kobo.111.3">This reference creates a link between the data in the two tables, establishing a relationship. </span><span class="koboSpan" id="kobo.111.4">The purpose of the foreign key is to maintain data consistency and integrity across related tables. </span><span class="koboSpan" id="kobo.111.5">It ensures that if a change is made in the primary key table, the related data in the other table remains accurate. </span><span class="koboSpan" id="kobo.111.6">By using foreign keys, you can retrieve information from multiple tables that are connected, enabling you to understand how different pieces of data are related to each other.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.112.1">Let’s take a closer look at our </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.113.1">example, as shown in the following image:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.114.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B21714_08_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.115.1">Figure 8.1: An example of the relationship between two tables in a database</span></p>
<p class="normal"><span class="koboSpan" id="kobo.116.1">In this example, the Authors table contains information about authors, including their ID, name, and birth year. </span><span class="koboSpan" id="kobo.116.2">The Books table includes details about books, including the book’s ID, title, and a foreign key called AuthorID, which references the corresponding author in the Authors table (with AuthorID as the primary key). </span><span class="koboSpan" id="kobo.116.3">This way, you can use SQL queries to retrieve information like finding all books written by a specific author or the birth year of an author based on the book they wrote. </span><span class="koboSpan" id="kobo.116.4">The relational structure allows for efficient management </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.117.1">and retrieval of data in a structured manner.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.118.1">Some of the main database systems in the market include:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.119.1">SQL databases</span></strong><span class="koboSpan" id="kobo.120.1">: These are </span><strong class="keyWord"><span class="koboSpan" id="kobo.121.1">relational database management systems</span></strong><span class="koboSpan" id="kobo.122.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.123.1">RDBMS</span></strong><span class="koboSpan" id="kobo.124.1">) that use SQL for data </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.125.1">manipulation and querying. </span><span class="koboSpan" id="kobo.125.2">Examples include MySQL, PostgreSQL, and Microsoft SQL Server.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.126.1">Oracle Database</span></strong><span class="koboSpan" id="kobo.127.1">: A widely-used</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.128.1"> RDBMS that offers advanced features and scalability for large-scale applications.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.129.1">SQLite:</span></strong><span class="koboSpan" id="kobo.130.1"> A self-contained, serverless, and</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.131.1"> zero-configuration SQL database engine commonly used in embedded systems and mobile applications.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.132.1">IBM Db2</span></strong><span class="koboSpan" id="kobo.133.1">: A family of data management </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.134.1">products, including relational database servers, developed by IBM.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.135.1">Amazon Web Services (AWS) RDS</span></strong><span class="koboSpan" id="kobo.136.1">: A managed relational database service offered by Amazon, providing options for</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.137.1"> various databases like MySQL, PostgreSQL, SQL Server, and more.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.138.1">Google Cloud SQL</span></strong><span class="koboSpan" id="kobo.139.1">: A managed database</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.140.1"> service by Google Cloud Platform, supporting MySQL, PostgreSQL, and SQL Server.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.141.1">Redis</span></strong><span class="koboSpan" id="kobo.142.1">: An open-source, in-memory</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.143.1"> data structure store that can be used as a database, cache, and message broker.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.144.1">In this chapter, we are going to use SQLite database, which also offers a seamless integration with Python. </span><span class="koboSpan" id="kobo.144.2">But before we do that, let’s understand the database we’ll be using.</span></p>
<h2 class="heading-2" id="_idParaDest-116"><span class="koboSpan" id="kobo.145.1">Overview of the Chinook database</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.146.1">The Chinook database is a sample </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.147.1">database that can be used for learning and practicing SQL. </span><span class="koboSpan" id="kobo.147.2">It is based on a fictional digital media store and contains</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.148.1"> data about artists, albums, tracks, customers, invoices, and more. </span><span class="koboSpan" id="kobo.148.2">The Chinook database is available for various database management systems, such as SQL Server, Oracle, MySQL, PostgreSQL, SQLite, and DB2.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.149.1">Here are some features of this</span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.150.1"> database:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.151.1">It uses real data from an iTunes library, which makes it more realistic and interesting.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.152.1">It has a clear and simple data model, which makes it easy to understand and query.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.153.1">It covers more features of SQL, such as subqueries, joins, views, and triggers.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.154.1">It is compatible with </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.155.1">multiple database servers, which makes it more versatile and portable.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.156.1">You can find the configuration instructions at </span><a href="https://database.guide/2-sample-databases-sqlite/"><span class="url"><span class="koboSpan" id="kobo.157.1">https://database.guide/2-sample-databases-sqlite/</span></span></a><span class="koboSpan" id="kobo.158.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.159.1">You can see an illustration of the relationship among the database’s tables here:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.160.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B21714_08_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.161.1">Figure 8.2: Diagram of Chinook Database (source: </span><a href="https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python"><span class="koboSpan" id="kobo.162.1">https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python</span></a><span class="koboSpan" id="kobo.163.1">)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.164.1">As you can see, there are 11 tables, all related</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.165.1"> to each other with primary and foreign keys. </span><span class="koboSpan" id="kobo.165.2">In the upcoming paragraph, we will see how LLMs will be able to navigate among those tables, capturing their relationships and gathering relevant information. </span><span class="koboSpan" id="kobo.165.3">But before jumping to LLMs, let’s first inspect the Chinook database a bit more by setting up the connection with Python.</span></p>
<h2 class="heading-2" id="_idParaDest-117"><span class="koboSpan" id="kobo.166.1">How to work with relational databases in Python</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.167.1">To work with relational databases in Python, you need to use a library that can connect to the database and execute </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.168.1">SQL queries. </span><span class="koboSpan" id="kobo.168.2">Some of these</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.169.1"> libraries are as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">SQLAlchemy</span></code><span class="koboSpan" id="kobo.171.1">: This is an open-source SQL toolkit and </span><strong class="keyWord"><span class="koboSpan" id="kobo.172.1">object-relational mapper</span></strong><span class="koboSpan" id="kobo.173.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.174.1">ORM</span></strong><span class="koboSpan" id="kobo.175.1">) for Python. </span><span class="koboSpan" id="kobo.175.2">It allows</span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.176.1"> you to create, read, update, and delete data from relational databases using Python objects and methods. </span><span class="koboSpan" id="kobo.176.2">It supports many database engines, such as SQLite, MySQL, PostgreSQL, and Oracle.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">Psycopg</span></code><span class="koboSpan" id="kobo.178.1">: This is a popular database connector for PostgreSQL. </span><span class="koboSpan" id="kobo.178.2">It enables you to execute SQL queries and access PostgreSQL features from Python. </span><span class="koboSpan" id="kobo.178.3">It is fast, reliable, and thread-safe.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">MySQLdb</span></code><span class="koboSpan" id="kobo.180.1">: This is a database connector for MySQL. </span><span class="koboSpan" id="kobo.180.2">It allows you to interact with MySQL databases from Python using the DB-API 2.0 specification. </span><span class="koboSpan" id="kobo.180.3">It is one of the oldest and most widely used Python libraries for MySQL, but its development is mostly frozen.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">cx_Oracle</span></code><span class="koboSpan" id="kobo.182.1">: This is a database connector for Oracle Database. </span><span class="koboSpan" id="kobo.182.2">It enables you to connect to Oracle databases and use SQL and PL/SQL features from Python. </span><span class="koboSpan" id="kobo.182.3">It supports advanced features such</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.183.1"> as object types, </span><strong class="keyWord"><span class="koboSpan" id="kobo.184.1">Large Objects</span></strong><span class="koboSpan" id="kobo.185.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.186.1">LOBs</span></strong><span class="koboSpan" id="kobo.187.1">), and arrays.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">sqlite3</span></code><span class="koboSpan" id="kobo.189.1">: This is a database connector for SQLite3, a widely used, lightweight, serverless, self-contained, and open-source relational database management system. </span><span class="koboSpan" id="kobo.189.2">You can use sqlite3 to create, query, update, and delete data from </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">SQLite</span></code><span class="koboSpan" id="kobo.191.1"> databases in your Python programs</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.192.1">Since we are going to work with SQLite, we will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">sqlite3</span></code><span class="koboSpan" id="kobo.194.1"> module, which you will need to install via </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">pip install sqlite3</span></code><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">Some of the features of sqlite3 are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.197.1">It follows the DB-API 2.0 specification, which defines a standard interface for Python database access modules.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.198.1">It supports transactions, which allow you to execute multiple SQL statements as a single unit of work and roll back in case of errors.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.199.1">It allows you to use Python objects as parameters and results for SQL queries, using various adapters and converters.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.200.1">It supports user-defined functions, aggregates, collations, and authorizers, which enable you to extend the functionality of SQLite with Python code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.201.1">It has a built-in row factory, which returns query results as named tuples or dictionaries instead of plain tuples.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.202.1">Let’s see an example of this</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.203.1"> connection using our Chinook database:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.204.1">The database can be downloaded locally from </span><a href="https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip"><span class="url"><span class="koboSpan" id="kobo.205.1">https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip</span></span></a><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">You will only need to unzip the </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">chinook.db</span></code><span class="koboSpan" id="kobo.208.1"> file and it will be</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.209.1"> ready to be consumed. </span><span class="koboSpan" id="kobo.209.2">In the following code, we are initializing a connection (</span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">conn</span></code><span class="koboSpan" id="kobo.211.1">) to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">chinook.db</span></code><span class="koboSpan" id="kobo.213.1">, which will be used to interact with the database. </span><span class="koboSpan" id="kobo.213.2">Then, we will save our tables in a pandas object with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">read_sql</span></code><span class="koboSpan" id="kobo.215.1"> module, which allows you to run SQL queries against your database:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.216.1">import</span></span><span class="koboSpan" id="kobo.217.1"> sqlite3
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.218.1">import</span></span><span class="koboSpan" id="kobo.219.1"> pandas </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.220.1">as</span></span><span class="koboSpan" id="kobo.221.1"> pd
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.222.1">## creating a connection</span></span><span class="koboSpan" id="kobo.223.1">
database = </span><span class="hljs-string"><span class="koboSpan" id="kobo.224.1">'chinook.db'</span></span><span class="koboSpan" id="kobo.225.1">
conn = sqlite3.connect(database)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.226.1">## importing tables</span></span><span class="koboSpan" id="kobo.227.1">
tables = pd.read_sql(</span><span class="hljs-string"><span class="koboSpan" id="kobo.228.1">"""SELECT name, type</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.229.1">                        FROM sqlite_master</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.230.1">                         WHERE type IN ("table", "view");"""</span></span><span class="koboSpan" id="kobo.231.1">, conn)
</span></code></pre>
</li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.232.1">Here is the output that we can see:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.233.1"><img alt="A screenshot of a black screen  Description automatically generated" src="../Images/B21714_08_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.234.1">Figure 8.3: A list of tables within the Chinook database</span></p>
<div class="note-one">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.235.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.236.1">Column names might be slightly different as the online database is updated over time. </span><span class="koboSpan" id="kobo.236.2">To get up-to-date columns’ naming conventions, you can run the following command:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.237.1">pd.read_sql("PRAGMA table_info(customers);", conn)
print(customer_columns)
</span></code></pre>
</div>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.238.1">We can also inspect the</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.239.1"> single table to gather </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.240.1">some relevant data. </span><span class="koboSpan" id="kobo.240.2">For example, let’s say we want to see the top five countries per album sales:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.241.1">pd.read_sql("""
SELECT c.country AS Country, SUM(i.total) AS Sales
FROM customer c
JOIN invoice i ON c.customer_id = i.customer_id
GROUP BY Country
ORDER BY Sales DESC
LIMIT 5;
""", conn)
</span></code></pre>
</li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.242.1">Here is the corresponding output:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.243.1"><img alt="A screenshot of a cellphone  Description automatically generated" src="../Images/B21714_08_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.244.1">Figure 8.4: Top 5 countries with highest sales</span></p>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.245.1">Finally, we can also use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">matplotlib</span></code><span class="koboSpan" id="kobo.247.1"> Python library to create useful diagrams about the database’s statistics. </span><span class="koboSpan" id="kobo.247.2">In the following Python snippet, we are going to run an</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.248.1"> SQL query to extract </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.249.1">the number of tracks grouped by genre, and then plot the result using </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">matplotlib</span></code><span class="koboSpan" id="kobo.251.1"> as follows:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.252.1">import</span></span><span class="koboSpan" id="kobo.253.1"> matplotlib.pyplot </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.254.1">as</span></span><span class="koboSpan" id="kobo.255.1"> plt
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.256.1"># Define the SQL query</span></span><span class="koboSpan" id="kobo.257.1">
sql = </span><span class="hljs-string"><span class="koboSpan" id="kobo.258.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.259.1">SELECT g.Name AS Genre, COUNT(t.track_id) AS Tracks</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.260.1">FROM genre g</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.261.1">JOIN track t ON g.genre_id = t.genre_id</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.262.1">GROUP BY Genre</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.263.1">ORDER BY Tracks DESC;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.264.1">"""</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.265.1"># Read the data into a dataframe</span></span><span class="koboSpan" id="kobo.266.1">
data = pd.read_sql(sql, conn)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.267.1"># Plot the data as a bar chart</span></span><span class="koboSpan" id="kobo.268.1">
plt.bar(data.Genre, data.Tracks)
plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.269.1">"Number of Tracks by Genre"</span></span><span class="koboSpan" id="kobo.270.1">)
plt.xlabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.271.1">"Genre"</span></span><span class="koboSpan" id="kobo.272.1">)
plt.ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.273.1">"Tracks"</span></span><span class="koboSpan" id="kobo.274.1">)
plt.xticks(rotation=</span><span class="hljs-number"><span class="koboSpan" id="kobo.275.1">90</span></span><span class="koboSpan" id="kobo.276.1">)
plt.show()
</span></code></pre>
</li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.277.1">We’ll see the following output:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.278.1"><img alt="A graph of tracks with blue bars  Description automatically generated" src="../Images/B21714_08_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.279.1">Figure 8.5: Number of tracks by genre</span></p>
<p class="normal"><span class="koboSpan" id="kobo.280.1">As you can see, in order to gather </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.281.1">relevant information from our database, we used the syntax of SQL. </span><span class="koboSpan" id="kobo.281.2">Our goal is to gather information by simply asking in natural language, and we are going to do so starting in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-118"><span class="koboSpan" id="kobo.282.1">Implementing the DBCopilot with LangChain</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.283.1">In this section, we are going to cover the</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.284.1"> architecture and implementation steps behind a DBCopilot application, a natural language interface to chat with</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.285.1"> database-structured data. </span><span class="koboSpan" id="kobo.285.2">In the upcoming sections, we will explore how to achieve that by leveraging a powerful LangChain component called SQL Agent.</span></p>
<h2 class="heading-2" id="_idParaDest-119"><span class="koboSpan" id="kobo.286.1">LangChain agents and SQL Agent</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.287.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.288.1">Chapter 4</span></em><span class="koboSpan" id="kobo.289.1">, we introduced the concept of </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.290.1">LangChain agents, defining them as entities</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.291.1"> that drive decision making within LLM-powered applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">Agents have access to a suite of tools and can decide which tool to call based on the user input and the context. </span><span class="koboSpan" id="kobo.292.2">Agents are dynamic and adaptive, meaning that they can change or adjust their actions based on the situation or the goal.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.293.1">In this chapter, we will see agents in action, using the following LangChain components:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">create_sql_agent</span></code><span class="koboSpan" id="kobo.295.1">: An agent designed to interact with relational databases</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">SQLDatabaseToolkit</span></code><span class="koboSpan" id="kobo.297.1">: A toolkit to provide the agent with the required non-parametric knowledge</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">OpenAI</span></code><span class="koboSpan" id="kobo.299.1">: An LLM to act as the reasoning engine behind the agent, as well as the generative engine to produce conversational results</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.300.1">Let’s start with our implementation by following these steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.301.1">We’ll first initialize all the components and establish the connection to the Chinook database, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">SQLDatabase</span></code><span class="koboSpan" id="kobo.303.1"> LangChain component (which uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">SQLAlchemy</span></code><span class="koboSpan" id="kobo.305.1"> under the hood and is used to connect to our database):
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.306.1">from</span></span><span class="koboSpan" id="kobo.307.1"> langchain.agents </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.308.1">import</span></span><span class="koboSpan" id="kobo.309.1"> create_sql_agent
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.310.1">from</span></span><span class="koboSpan" id="kobo.311.1"> langchain.llms </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.312.1">import</span></span><span class="koboSpan" id="kobo.313.1"> OpenAI
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.314.1">from</span></span><span class="koboSpan" id="kobo.315.1"> langchain.chat_models </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.316.1">import</span></span><span class="koboSpan" id="kobo.317.1"> ChatOpenAI
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.318.1">from</span></span><span class="koboSpan" id="kobo.319.1"> langchain.agents.agent_toolkits </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.320.1">import</span></span><span class="koboSpan" id="kobo.321.1"> SQLDatabaseToolkit
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.322.1">from</span></span><span class="koboSpan" id="kobo.323.1"> langchain.sql_database </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.324.1">import</span></span><span class="koboSpan" id="kobo.325.1"> SQLDatabase
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.326.1">from</span></span><span class="koboSpan" id="kobo.327.1"> langchain.llms.openai </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.328.1">import</span></span><span class="koboSpan" id="kobo.329.1"> OpenAI
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.330.1">from</span></span><span class="koboSpan" id="kobo.331.1"> langchain.agents </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.332.1">import</span></span><span class="koboSpan" id="kobo.333.1"> AgentExecutor
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.334.1">from</span></span><span class="koboSpan" id="kobo.335.1"> langchain.agents.agent_types </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.336.1">import</span></span><span class="koboSpan" id="kobo.337.1"> AgentType
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.338.1">from</span></span><span class="koboSpan" id="kobo.339.1"> langchain.chat_models </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.340.1">import</span></span><span class="koboSpan" id="kobo.341.1"> ChatOpenAI
llm = OpenAI()
db = SQLDatabase.from_uri(</span><span class="hljs-string"><span class="koboSpan" id="kobo.342.1">'sqlite:///chinook.db'</span></span><span class="koboSpan" id="kobo.343.1">)
toolkit = SQLDatabaseToolkit(db=db, llm=llm)
agent_executor = create_sql_agent(
    llm=llm,
    toolkit=toolkit,
    verbose=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.344.1">True</span></span><span class="koboSpan" id="kobo.345.1">,
    agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
)
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.346.1">Before running the </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.347.1">agent, let’s first inspect its available tools:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.348.1">[tool.name </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.349.1">for</span></span><span class="koboSpan" id="kobo.350.1"> tool </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.351.1">in</span></span><span class="koboSpan" id="kobo.352.1"> toolkit.get_tools()]
</span></code></pre>
</li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.353.1">Here is the output:</span></p>
<pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.354.1">['sql_db_query', 'sql_db_schema', 'sql_db_list_tables', 'sql_db_query_checker']
</span></code></pre>
<p class="normal-one"><span class="koboSpan" id="kobo.355.1">Those tools have the following capabilities:</span></p>
<ul>
<li class="bulletList level-2"><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">sql_db_query</span></code><span class="koboSpan" id="kobo.357.1">: This takes as</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.358.1"> input a detailed and correct SQL query, and it outputs a result from the database. </span><span class="koboSpan" id="kobo.358.2">If the query is not correct, an error message will be returned.</span></li>
<li class="bulletList level-2"><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">sql_db_schema</span></code><span class="koboSpan" id="kobo.360.1">: This takes as input a comma-separated list of tables, and it outputs the schema and sample rows for those tables.</span></li>
<li class="bulletList level-2"><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">sql_db_list_tables</span></code><span class="koboSpan" id="kobo.362.1">: This takes as input an empty string, and it outputs a comma-separated list of tables in the database.</span></li>
<li class="bulletList level-2"><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">sql_db_query_checker</span></code><span class="koboSpan" id="kobo.364.1">: This tool double-checks whether the query is correct before executing it.</span></li>
</ul>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.365.1">Let’s now execute our agent with a simple query to describe the </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">playlisttrack</span></code><span class="koboSpan" id="kobo.367.1"> table:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.368.1">agent_executor.run(</span><span class="hljs-string"><span class="koboSpan" id="kobo.369.1">"Describe the playlisttrack table"</span></span><span class="koboSpan" id="kobo.370.1">)
</span></code></pre>
</li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.371.1">The following output is then obtained (the output is truncated – you can find the full output in the book’s GitHub repository):</span></p>
<pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.372.1">&gt; </span></span><span class="language-bash"><span class="koboSpan" id="kobo.373.1">Entering new AgentExecutor chain...</span></span><span class="koboSpan" id="kobo.374.1">
Action: sql_db_list_tables
Action Input:
Observation: album, artist, customer, employee, genre, invoice, invoice_line, media_type, playlist, playlist_track, track
Thought: The table I need is playlist_track
Action: sql_db_schema
Action Input: playlist_track
Observation:
CREATE TABLE playlist_track (
[...]
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.375.1">&gt; </span></span><span class="language-bash"><span class="koboSpan" id="kobo.376.1">Finished chain.</span></span><span class="koboSpan" id="kobo.377.1">
'The playlist_track table contains the playlist_id and track_id columns. </span><span class="koboSpan" id="kobo.377.2">It has a primary key of playlist_id and track_id. </span><span class="koboSpan" id="kobo.377.3">There is also a foreign key reference to the track and playlist tables. </span><span class="koboSpan" id="kobo.377.4">Sample rows include (1, 3402), (1, 3389), and (1, 3390).'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.378.1">As you can see, with a simple question in natural language, our agent was able to understand its semantics, translate it into an SQL query, extract the relevant information, and use it as context to </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.379.1">generate the response.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1">But how was it able to do all of</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.381.1"> that? </span><span class="koboSpan" id="kobo.381.2">Under the hood, the SQL agent comes with a default prompt template, which makes it tailored to this type of activity. </span><span class="koboSpan" id="kobo.381.3">Let’s see the default template of the LangChain component:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.382.1">print</span></span><span class="koboSpan" id="kobo.383.1">(agent_executor.agent.llm_chain.prompt.template)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.384.1">Here is the output obtained:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.385.1">You are an agent designed to interact with a SQL database.
</span><span class="koboSpan" id="kobo.385.2">Given an input question, create a syntactically correct sqlite query to run, then look at the results of the query and return the answer.
</span><span class="koboSpan" id="kobo.385.3">Unless the user specifies a specific number of examples they wish to obtain, always limit your query to at most 10 results.
</span><span class="koboSpan" id="kobo.385.4">You can order the results by a relevant column to return the most interesting examples in the database.
</span><span class="koboSpan" id="kobo.385.5">Never query for all the columns from a specific table, only ask for the relevant columns given the question.
</span><span class="koboSpan" id="kobo.385.6">You have access to tools for interacting with the database.
</span><span class="koboSpan" id="kobo.385.7">Only use the below tools. </span><span class="koboSpan" id="kobo.385.8">Only use the information returned by the below tools to construct your final answer.
</span><span class="koboSpan" id="kobo.385.9">You MUST double check your query before executing it. </span><span class="koboSpan" id="kobo.385.10">If you get an error while executing a query, rewrite the query and try again.
</span><span class="koboSpan" id="kobo.385.11">DO NOT make any DML statements (INSERT, UPDATE, DELETE, DROP etc.) to the database.
</span><span class="koboSpan" id="kobo.385.12">If the question does not seem related to the database, just return "I don't know" as the answer.
</span><span class="koboSpan" id="kobo.385.13">sql_db_query: Input to this tool is a detailed and correct SQL query, output is a result from the database. </span><span class="koboSpan" id="kobo.385.14">If the query is not correct, an error message will be returned. </span><span class="koboSpan" id="kobo.385.15">If an error is returned, rewrite the query, check the query, and try again. </span><span class="koboSpan" id="kobo.385.16">If you encounter an issue with Unknown column 'xxxx' in 'field list', using sql_db_schema to query the correct table fields.
</span><span class="koboSpan" id="kobo.385.17">sql_db_schema: Input to this tool is a comma-separated list of tables, output is the schema and sample rows for those tables. 
</span><span class="koboSpan" id="kobo.385.18">Be sure that the tables actually exist by calling sql_db_list_tables first! </span><span class="koboSpan" id="kobo.385.19">Example Input: 'table1, table2, table3'
sql_db_list_tables: Input is an empty string, output is a comma separated list of tables in the database.
</span><span class="koboSpan" id="kobo.385.20">sql_db_query_checker: Use this tool to double check if your query is correct before executing it. </span><span class="koboSpan" id="kobo.385.21">Always use this tool before executing a query with sql_db_query!
</span><span class="koboSpan" id="kobo.385.22">Use the following format:
Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [sql_db_query, sql_db_schema, sql_db_list_tables, sql_db_query_checker]
Action Input: the input to the action
...
</span><span class="koboSpan" id="kobo.385.23">Question: {input}
Thought: I should look at the tables in the database to see what I can query.  </span><span class="koboSpan" id="kobo.385.24">Then I should query the schema of the most relevant tables.
</span><span class="koboSpan" id="kobo.385.25">{agent_scratchpad}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.386.1">Thanks to this prompt template, the agent is able to use the proper tools and generate a SQL query, without modifying the underlying </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.387.1">database (you can see the explicit rule not to run any </span><strong class="keyWord"><span class="koboSpan" id="kobo.388.1">data manipulation language</span></strong><span class="koboSpan" id="kobo.389.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.390.1">DML</span></strong><span class="koboSpan" id="kobo.391.1">) statements).</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.392.1">Definition</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.393.1">DML is a class of SQL statements that are used to query, edit, add, and delete row-level data from database tables or views. </span><span class="koboSpan" id="kobo.393.2">The main DML statements are as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.394.1">SELECT</span></code><span class="koboSpan" id="kobo.395.1">: This is used to retrieve data from one or more tables or views based on specified criteria.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">INSERT</span></code><span class="koboSpan" id="kobo.397.1">: This is used to insert new data records or rows into a table.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.398.1">UPDATE</span></code><span class="koboSpan" id="kobo.399.1">: This is used to modify the values of existing data records or rows in a table.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">DELETE</span></code><span class="koboSpan" id="kobo.401.1">: This is used to remove one or more data records or rows from a table.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">MERGE</span></code><span class="koboSpan" id="kobo.403.1">: This is used to combine the data from two tables into one based on a common column.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.404.1">DML statements are used to store, modify, retrieve, delete, and update data in a database.</span></li>
</ul>
</div>
<p class="normal"><span class="koboSpan" id="kobo.405.1">We can also see how the agent is</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.406.1"> able to correlate more than one table </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.407.1">within the database:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.408.1">agent_executor.run(</span><span class="hljs-string"><span class="koboSpan" id="kobo.409.1">'what is the total number of tracks and the average length of tracks by genre?'</span></span><span class="koboSpan" id="kobo.410.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.411.1">From the first lines of the chain, you can see that </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">Action Input</span></code><span class="koboSpan" id="kobo.413.1"> invokes two tables – track and genre:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.414.1">&gt; Entering new AgentExecutor chain...
</span><span class="koboSpan" id="kobo.414.2">Action: sql_db_list_tables
Action Input:
Observation: album, artist, customer, employee, genre, invoice, invoice_line, media_type, playlist, playlist_track, track
Thought: I should look at the schema of the track </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">and</span></span><span class="koboSpan" id="kobo.416.1"> genre tables.
</span><span class="koboSpan" id="kobo.416.2">Action: sql_db_schema
Action Input: track, genre
[…]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.417.1">The following is the output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.418.1">'The top 10 genres by track count and average track length are Rock (1297 tracks with an average length of 283910.04 ms), Latin (579 tracks with an average length of 232859.26 ms), Metal (374 tracks with an average length of 309749.44 ms), Alternative &amp; Punk (332 tracks with an average length of 234353.85 ms), Jazz (130 tracks with an average length of 291755.38 ms), TV Shows (93 tracks with an average length of 2145041.02 ms), Blues (81 tracks with an average length of 270359.78 ms), Classical (74 tracks with an average length of 293867.57 ms), Drama (64 tracks with an average length of 2575283.78 ms), and R&amp;B/Soul (61 tracks with an average length of 220066.85 ms).'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.419.1">Now, the question is as follows: are we sure that we are getting the proper result? </span><span class="koboSpan" id="kobo.419.2">A nice way to double-check this</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.420.1"> would be to print the SQL query that the agent ran against the </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.421.1">database. </span><span class="koboSpan" id="kobo.421.2">To do so, we can modify the default prompt to ask the agent to explicitly show us the reasoning behind its result.</span></p>
<h2 class="heading-2" id="_idParaDest-120"><span class="koboSpan" id="kobo.422.1">Prompt engineering</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.423.1">As we saw in the previous chapter, pre-built LangChain agents and chains come with default prompts, which make it easier to</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.424.1"> tailor them toward their goals. </span><span class="koboSpan" id="kobo.424.2">Nevertheless, we can customize that prompt and pass it as a parameter to our component. </span><span class="koboSpan" id="kobo.424.3">For example, let’s say that we want our SQL agent to print the SQL query it used to return the result.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.425.1">First of all, we have to understand which kind of prompt chunks the SQL Agent is able to take as parameters. </span><span class="koboSpan" id="kobo.425.2">To do so, we can simply inspect the objects running </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">create_sql_agent</span></code><span class="koboSpan" id="kobo.427.1">.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.428.1"><img alt="" role="presentation" src="../Images/B21714_08_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.429.1">Figure 8.6: A screenshot of the description of the SQL agent</span></p>
<p class="normal"><span class="koboSpan" id="kobo.430.1">The Agent takes a prompt prefix and a format instruction, which are merged and constitute the default prompt we</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.431.1"> inspected in the previous section. </span><span class="koboSpan" id="kobo.431.2">To make our agent more self-explanatory, we will create two variables, </span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">prefix</span></code><span class="koboSpan" id="kobo.433.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">format_instructions</span></code><span class="koboSpan" id="kobo.435.1">, which will be passed as parameters and that slightly modify the default prompt as follows (you can find the whole prompts in the GitHub repository at </span><a href="Chapter_08.xhtml"><span class="url"><span class="koboSpan" id="kobo.436.1">https://github.com/PacktPublishing/Building-LLM-Powered-Applications</span></span></a><a href="https://github.com/PacktPublishing/Building-Large-Language-Model-Applications"/><span class="koboSpan" id="kobo.437.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.438.1">We have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.439.1">prompt_prefix</span></code><span class="koboSpan" id="kobo.440.1">, which is already configured as follows:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.441.1">prefix: </span><span class="hljs-string"><span class="koboSpan" id="kobo.442.1">'str'</span></span><span class="koboSpan" id="kobo.443.1"> = </span><span class="hljs-string"><span class="koboSpan" id="kobo.444.1">'You are an agent designed to interact with a SQL database.\nGiven an input question, create a syntactically correct {dialect} query to run, then look at the results of the query and return the answer.\nUnless the user specifies a specific number of examples they wish to obtain, always limit your query to at most {top_k} results.\nYou can order the results by a relevant column to return the most interesting examples in the database.\nNever query for all the columns from a specific table, only ask for the relevant columns given the question.\nYou have access to tools for interacting with the database.\nOnly use the below tools. </span><span class="koboSpan" id="kobo.444.2">Only use the information returned by the below tools to construct your final answer.\nYou MUST double check your query before executing it. </span><span class="koboSpan" id="kobo.444.3">If you get an error while executing a query, rewrite the query and try again.\n\nDO NOT make any DML statements (INSERT, UPDATE, DELETE, DROP etc.) to the database.\n\nIf the question does not seem related to the database, just return "I don\'t know" as the answer.\n'</span></span><span class="koboSpan" id="kobo.445.1">,
</span></code></pre>
</li>
</ul>
<p class="normal-one"><span class="koboSpan" id="kobo.446.1">To this, we will add the following line of instruction:</span></p>
<pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.447.1">As part of your final answer, ALWAYS include an explanation of how to got to the final answer, including the SQL query you run. </span><span class="koboSpan" id="kobo.447.2">Include the explanation </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.448.1">and</span></span><span class="koboSpan" id="kobo.449.1"> the SQL query </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.450.1">in</span></span><span class="koboSpan" id="kobo.451.1"> the section that starts </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.452.1">with</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.453.1">"Explanation:"</span></span><span class="koboSpan" id="kobo.454.1">.
</span></code></pre>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.455.1">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">prompt_format_instructions</span></code><span class="koboSpan" id="kobo.457.1">, we</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.458.1"> will add the following example of explanation using few-shot learning, which we covered in </span><em class="chapterRef"><span class="koboSpan" id="kobo.459.1">Chapter 1</span></em><span class="koboSpan" id="kobo.460.1">:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.461.1">Explanation:
&lt;===Beginning of an Example of Explanation:
I joined the invoices </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.462.1">and</span></span><span class="koboSpan" id="kobo.463.1"> customers tables on the customer_id column, which </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.464.1">is</span></span><span class="koboSpan" id="kobo.465.1"> the common key between them. </span><span class="koboSpan" id="kobo.465.2">This will allowed me to access the Total </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.466.1">and</span></span><span class="koboSpan" id="kobo.467.1"> Country columns </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.468.1">from</span></span><span class="koboSpan" id="kobo.469.1"> both tables. </span><span class="koboSpan" id="kobo.469.2">Then I grouped the records by the country column </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.470.1">and</span></span><span class="koboSpan" id="kobo.471.1"> calculate the </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.472.1">sum</span></span><span class="koboSpan" id="kobo.473.1"> of the Total column </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">for</span></span><span class="koboSpan" id="kobo.475.1"> each country, ordered them </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.476.1">in</span></span><span class="koboSpan" id="kobo.477.1"> descending order </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.478.1">and</span></span><span class="koboSpan" id="kobo.479.1"> limited the SELECT to the top </span><span class="hljs-number"><span class="koboSpan" id="kobo.480.1">5.</span></span><span class="koboSpan" id="kobo.481.1">
```sql
SELECT c.country AS Country, SUM(i.total) AS Sales
FROM customer c
JOIN invoice i ON c.customer_id = i.customer_id
GROUP BY Country
ORDER BY Sales DESC
LIMIT </span><span class="hljs-number"><span class="koboSpan" id="kobo.482.1">5</span></span><span class="koboSpan" id="kobo.483.1">;
```sql
===&gt;End of an Example of Explanation
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.484.1">Now, let’s pass those prompt chunks as parameters to our agent and print the result (I will omit the whole chain here, but you can see it in the GitHub repository):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.485.1">agent_executor = create_sql_agent(
    prefix=prompt_prefix,
    format_instructions = prompt_format_instructions,
    llm=llm,
    toolkit=toolkit,
    verbose=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.486.1">True</span></span><span class="koboSpan" id="kobo.487.1">,
    top_k=</span><span class="hljs-number"><span class="koboSpan" id="kobo.488.1">10</span></span><span class="koboSpan" id="kobo.489.1">
)
result = agent_executor.run(</span><span class="hljs-string"><span class="koboSpan" id="kobo.490.1">"What are the top 5 best-selling albums and their artists?"</span></span><span class="koboSpan" id="kobo.491.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.492.1">print</span></span><span class="koboSpan" id="kobo.493.1">(result)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.494.1">Here is the obtained</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.495.1"> output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.496.1">The top 5 best-selling albums and their artists are 'A Matter of Life and Death' by Iron Maiden, 'BBC Sessions [Disc 1] [live]' by Led Zeppelin, 'MK III The Final Concerts [Disc 1]' by Deep Purple, 'Garage Inc. </span><span class="koboSpan" id="kobo.496.2">(Disc 1)' by Metallica and 'Achtung Baby' by U2.
</span><span class="koboSpan" id="kobo.496.3">Explanation: I joined the album and invoice tables on the album_id column and joined the album and artist tables on the artist_id column. </span><span class="koboSpan" id="kobo.496.4">This allowed me to access the title and artist columns from the album table and the total column from the invoice table. </span><span class="koboSpan" id="kobo.496.5">Then I grouped the records by the artist column and calculated the sum of the Total column for each artist, ordered them in descending order and limited the SELECT to the top 5.
</span><span class="koboSpan" id="kobo.496.6">```sql
SELECT al.title AS Album, ar.name AS Artist, SUM(i.total) AS Sales
FROM album al
JOIN invoice i ON al.album_id = i.invoice_id
JOIN artist ar ON al.artist_id = ar.artist_id
GROUP BY ar.name
ORDER BY Sales
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.497.1">Now, in our result, we have a clear explanation of the thought process as well as the printed query our agent made for us. </span><span class="koboSpan" id="kobo.497.2">This is key if we want to double-check the correctness of the reasoning procedure happening in the backend of our agent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.498.1">This is already extremely useful, but we want to bring it to the next level: we want our DBCopilot to also be able to generate graphs and save results in our local file system. </span><span class="koboSpan" id="kobo.498.2">To achieve this goal, we need to add tools to our agent, and we are going to do so in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-121"><span class="koboSpan" id="kobo.499.1">Adding further tools</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.500.1">In order to make our DBCopilot more versatile, there are two further capabilities we need to add:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.501.1">PythonREPLTool</span></strong><span class="koboSpan" id="kobo.502.1">: This tool allows you to interact with the Python programming language using natural language. </span><span class="koboSpan" id="kobo.502.2">You can use this tool to write, run, and debug Python code </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.503.1">without having to use a script file or an IDE. </span><span class="koboSpan" id="kobo.503.2">You can also use this tool to access and manipulate various Python modules, libraries, and data structures.</span><strong class="keyWord"><span class="koboSpan" id="kobo.504.1"> We will need this tool to produce the matplotlib graphs from the SQL query’s results.</span></strong></li>
</ul>
<div class="note-one">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.505.1">Definition</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.506.1">REPL is an acronym for read-eval-print loop, which is </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.507.1">a term that describes an interactive shell or environment that allows you to execute code and see the results immediately. </span><span class="koboSpan" id="kobo.507.2">REPL is a common feature of many programming languages, such as Python, Ruby, and Lisp.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.508.1">In the context of LangChain, REPL is a feature that allows you to interact with LangChain agents and tools using natural language. </span><span class="koboSpan" id="kobo.508.2">You can use REPL in LangChain to test, debug, or experiment with different agents and tools without having to write and run a script file. </span><span class="koboSpan" id="kobo.508.3">You can also use REPL in LangChain to access and manipulate various data sources, such as databases, APIs, and web pages.</span></p>
</div>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.509.1">FileManagementToolkit</span></strong><span class="koboSpan" id="kobo.510.1">: This is a set of tools, or toolkit, that allows you to interact with the file system of your computer or device using natural language. </span><span class="koboSpan" id="kobo.510.2">You can use this toolkit to</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.511.1"> perform various operations on files and directories, such as creating, deleting, renaming, copying, moving, searching, reading, and writing. </span><span class="koboSpan" id="kobo.511.2">You can also use this toolkit to access and manipulate the metadata and attributes of files and directories, such as name, size, type, date, and permissions.</span></li>
</ul>
<p class="normal-one"><span class="koboSpan" id="kobo.512.1">We will need this toolkit to save the graphs generated by our agent in our working directory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.513.1">Now, let’s see how we can add these</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.514.1"> tools to our DBCopilot:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.515.1">First, we define the list of tools for our agent:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.516.1">from</span></span><span class="koboSpan" id="kobo.517.1">  langchain_experimental.tools.python.tool </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.518.1">import</span></span><span class="koboSpan" id="kobo.519.1"> PythonREPLTool
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.520.1">from</span></span><span class="koboSpan" id="kobo.521.1">  langchain_experimental.python </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.522.1">import</span></span><span class="koboSpan" id="kobo.523.1"> PythonREPL
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.524.1">from</span></span><span class="koboSpan" id="kobo.525.1"> langchain.agents.agent_toolkits </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.526.1">import</span></span><span class="koboSpan" id="kobo.527.1"> FileManagementToolkit
working_directory  = os.getcwd()
tools = FileManagementToolkit(
    root_dir=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.528.1">str</span></span><span class="koboSpan" id="kobo.529.1">(working_directory),
    selected_tools=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.530.1">"read_file"</span></span><span class="koboSpan" id="kobo.531.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.532.1">"write_file"</span></span><span class="koboSpan" id="kobo.533.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.534.1">"list_directory"</span></span><span class="koboSpan" id="kobo.535.1">],).get_tools()
tools.append(
    PythonREPLTool())
tools.extend(SQLDatabaseToolkit(db=db, llm=llm).get_tools())
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.536.1">In order to leverage that heterogeneous set of tools – SQL Database, Python REPL, and File System (</span><a href="https://python.langchain.com/v0.1/docs/integrations/tools/filesystem/"><span class="url"><span class="koboSpan" id="kobo.537.1">https://python.langchain.com/v0.1/docs/integrations/tools/filesystem/</span></span></a><span class="koboSpan" id="kobo.538.1">) – we cannot work anymore with the SQL Database-specific agent, since its default configurations are meant to only accept SQL-related contents. </span><span class="koboSpan" id="kobo.538.2">Henceforth, we need to set up an agnostic agent that is able to use all of the tools that we provide it with. </span><span class="koboSpan" id="kobo.538.3">For this purpose, we are going to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION</span></code><span class="koboSpan" id="kobo.540.1"> agent type, which is able to use a multi-tool input.</span></li>
</ol>
<p class="normal-one"><span class="koboSpan" id="kobo.541.1">Let’s first start with initializing the agent and asking it to produce a bar chart and save it in the current working directory for the top five countries for sales (note that, for this purpose, I’ve used a chat model as best suited for the type of agent in use):</span></p>
<pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.542.1">from</span></span><span class="koboSpan" id="kobo.543.1"> langchain.chat_models </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.544.1">import</span></span><span class="koboSpan" id="kobo.545.1"> ChatOpenAI
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.546.1">from</span></span><span class="koboSpan" id="kobo.547.1"> langchain.agents </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.548.1">import</span></span><span class="koboSpan" id="kobo.549.1"> initialize_agent, Tool
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.550.1">from</span></span><span class="koboSpan" id="kobo.551.1"> langchain.agents </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.552.1">import</span></span><span class="koboSpan" id="kobo.553.1"> AgentType
model = ChatOpenAI()
agent = initialize_agent(
    tools, model, agent= AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION, verbose=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.554.1">True</span></span><span class="koboSpan" id="kobo.555.1">
)
agent.run(</span><span class="hljs-string"><span class="koboSpan" id="kobo.556.1">"generate a matplotlib bar chart of the top 5 countries for sales from the chinook database. </span><span class="koboSpan" id="kobo.556.2">Save the output in the current working directory as figure.png"</span></span><span class="koboSpan" id="kobo.557.1">)
</span></code></pre>
<p class="normal-one"><span class="koboSpan" id="kobo.558.1">We then receive the following output, showing how, in this case, the agent was also able to dynamically orchestrate the available tools to generate the final answer (I will report here</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.559.1"> just the main actions of the chain – you can see the whole code in the GitHub repository of the book):</span></p>
<pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.560.1">&gt; </span></span><span class="language-bash"><span class="koboSpan" id="kobo.561.1">Entering new AgentExecutor chain...</span></span><span class="koboSpan" id="kobo.562.1">
Action:
```
{
  "action": "sql_db_query",
  "action_input": "SELECT billing_country as Country, SUM(total) as Sales FROM invoices GROUP BY billing_country ORDER BY Sales DESC LIMIT 5"
}
```
[…]
Observation: [('USA', 10405.889999999912), ('Canada', 5489.549999999994), ('Brazil', 4058.999999999997), ('France', 3972.869999999995), ('Germany', 3441.2399999999925)]
[…]
We have successfully retrieved the top 5 countries for sales. </span><span class="koboSpan" id="kobo.562.2">We can now use matplotlib to create a bar chart.
</span><span class="koboSpan" id="kobo.562.3">Action:
```
{
  "action": "Python_REPL",
  "action_input": "import matplotlib.pyplot as plt\nsales_data = [('USA', 10405.89), ('Canada', 5489.55), ('Brazil', 4059.0), ('France', 3972.87), ('Germany', 3441.24)]\n\nx = [item[0] for item in sales_data]\ny = [item[1] for item in sales_data]\nplt.bar(x, y)\nplt.xlabel('Country')\nplt.ylabel('Sales')\nplt.title('Top 5 Countries for Sales')\nplt.show()"
}
```
[…]
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.563.1">&gt; </span></span><span class="language-bash"><span class="koboSpan" id="kobo.564.1">Finished chain.</span></span><span class="koboSpan" id="kobo.565.1">
'Here is the bar chart of the top 5 countries for sales from the Chinook database. </span><span class="koboSpan" id="kobo.565.2">It has been saved as figure.png in the current working directory. </span><span class="koboSpan" id="kobo.565.3">'
</span></code></pre>
<p class="normal-one"><span class="koboSpan" id="kobo.566.1">The following is the generated chart of the top five countries by sales, as requested:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.567.1"><img alt="A graph of blue bars  Description automatically generated" src="../Images/B21714_08_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.568.1">Figure 8.7: Bar chart of top five countries by sales</span></p>
<p class="normal"><span class="koboSpan" id="kobo.569.1">Great! </span><span class="koboSpan" id="kobo.569.2">The agent was able to first invoke</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.570.1"> the SQL tool to retrieve the relevant information, then it used the Python tool to generate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">matplotlib</span></code><span class="koboSpan" id="kobo.572.1"> bar chart. </span><span class="koboSpan" id="kobo.572.2">Then, it used the file system tool to save the result as PNG.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.573.1">Also, in this case, we can modify the prompt of the agent. </span><span class="koboSpan" id="kobo.573.2">For example, we might want the agent to provide an explanation not </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.574.1">only of the SQL query but also of the Python code. </span><span class="koboSpan" id="kobo.574.2">To do so, we need to define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.575.1">prompt_prefix</span></code><span class="koboSpan" id="kobo.576.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.577.1">prompt_format_instructions</span></code><span class="koboSpan" id="kobo.578.1"> variables to be passed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.579.1">kgwargs</span></code><span class="koboSpan" id="kobo.580.1"> to the agent as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.581.1">prompt_prefix = """ Your prefix here
"""
prompt_format_instructions= """
Your instructions here.
</span><span class="koboSpan" id="kobo.581.2">"""
agent = initialize_agent(tools, model, agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION, verbose = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.582.1">True</span></span><span class="koboSpan" id="kobo.583.1">,
                         agent_kwargs={
                            </span><span class="hljs-string"><span class="koboSpan" id="kobo.584.1">'prefix'</span></span><span class="koboSpan" id="kobo.585.1">:prompt_prefix,
                            </span><span class="hljs-string"><span class="koboSpan" id="kobo.586.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.587.1">format_instructions'</span></span><span class="koboSpan" id="kobo.588.1">: prompt_format_instructions })
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.589.1">Thanks to LangChain’s tools components, we were able to extend our DBCopilot capabilities and make it more versatile, depending upon the user’s query.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.590.1">With the same logic, we can tailor our agents to any domain, adding or removing tools so that we can control its perimeter of actions. </span><span class="koboSpan" id="kobo.590.2">Plus, thanks to the prompt customization, we can always refine the agent’s backend logic to make it more customized.</span></p>
<h1 class="heading-1" id="_idParaDest-122"><span class="koboSpan" id="kobo.591.1">Developing the front-end with Streamlit</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.592.1">Now that we have seen the logic</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.593.1"> behind an LLM-powered DBCopilot, it is time to give a GUI to our application. </span><span class="koboSpan" id="kobo.593.2">To do so, we </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.594.1">will once again leverage Streamlit. </span><span class="koboSpan" id="kobo.594.2">As always, you can find the whole Python code in the GitHub book repository at </span><a href="Chapter_08.xhtml"><span class="url"><span class="koboSpan" id="kobo.595.1">https://github.com/PacktPublishing/Building-LLM-Powered-Applications</span></span></a><span class="koboSpan" id="kobo.596.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.597.1">As per the previous sections, you need to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.598.1">.py</span></code><span class="koboSpan" id="kobo.599.1"> file to run in your terminal via </span><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">streamlit run file.py</span></code><span class="koboSpan" id="kobo.601.1">. </span><span class="koboSpan" id="kobo.601.2">In our case, the file will be named </span><code class="inlineCode"><span class="koboSpan" id="kobo.602.1">dbcopilot.py</span></code><span class="koboSpan" id="kobo.603.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.604.1">Here are the main steps to set up the frontend:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.605.1">Configure the application web page:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">import</span></span><span class="koboSpan" id="kobo.607.1"> streamlit </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">as</span></span><span class="koboSpan" id="kobo.609.1"> st
st.set_page_config(page_title=</span><span class="hljs-string"><span class="koboSpan" id="kobo.610.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.611.1">DBCopilot"</span></span><span class="koboSpan" id="kobo.612.1">, page_icon=</span><span class="hljs-string"><span class="koboSpan" id="kobo.613.1">"</span></span><span class="koboSpan" id="kobo.614.1"><img alt="" role="presentation" src="../Images/Icon.png"/></span><span class="hljs-string"><span class="koboSpan" id="kobo.615.1">"</span></span><span class="koboSpan" id="kobo.616.1">)
st.header(</span><span class="hljs-string"><span class="koboSpan" id="kobo.617.1">'</span></span><span class="koboSpan" id="kobo.618.1"><img alt="" role="presentation" src="../Images/Icon.png"/></span><span class="hljs-string"><span class="koboSpan" id="kobo.619.1"> Welcome to DBCopilot, your copilot for structured databases.'</span></span><span class="koboSpan" id="kobo.620.1">)
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.621.1">Import the credentials</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.622.1"> and establish the connection with the Chinook database:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.623.1">load_dotenv()
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.624.1">#os.environ["HUGGINGFACEHUB_API_TOKEN"]</span></span><span class="koboSpan" id="kobo.625.1">
openai_api_key = os.environ[</span><span class="hljs-string"><span class="koboSpan" id="kobo.626.1">'OPENAI_API_KEY'</span></span><span class="koboSpan" id="kobo.627.1">]
db = SQLDatabase.from_uri(</span><span class="hljs-string"><span class="koboSpan" id="kobo.628.1">'sqlite:///chinook.db'</span></span><span class="koboSpan" id="kobo.629.1">)
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.630.1">Initialize the LLM and</span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.631.1"> the toolkit:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.632.1">llm = OpenAI()
toolkit = SQLDatabaseToolkit(db=db, llm=llm)
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.633.1">Initialize the Agent using the prompt variables defined in the previous sections:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="koboSpan" id="kobo.634.1">agent_executor = create_sql_agent(
    prefix=prompt_prefix,
    format_instructions = prompt_format_instructions,
    llm=llm,
    toolkit=toolkit,
    verbose=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.635.1">True</span></span><span class="koboSpan" id="kobo.636.1">,
    top_k=</span><span class="hljs-number"><span class="koboSpan" id="kobo.637.1">10</span></span><span class="koboSpan" id="kobo.638.1">
)
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.639.1">Define Streamlit’s session states to make it conversational and memory aware:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.640.1">if</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.641.1">"messages"</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.642.1">not</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.643.1">in</span></span><span class="koboSpan" id="kobo.644.1"> st.session_state </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.645.1">or</span></span><span class="koboSpan" id="kobo.646.1"> st.sidebar.button(</span><span class="hljs-string"><span class="koboSpan" id="kobo.647.1">"Clear message history"</span></span><span class="koboSpan" id="kobo.648.1">):
    st.session_state[</span><span class="hljs-string"><span class="koboSpan" id="kobo.649.1">"messages"</span></span><span class="koboSpan" id="kobo.650.1">] = [{</span><span class="hljs-string"><span class="koboSpan" id="kobo.651.1">"role"</span></span><span class="koboSpan" id="kobo.652.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.653.1">"assistant"</span></span><span class="koboSpan" id="kobo.654.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.655.1">"content"</span></span><span class="koboSpan" id="kobo.656.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.657.1">"How can I help you?"</span></span><span class="koboSpan" id="kobo.658.1">}]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">for</span></span><span class="koboSpan" id="kobo.660.1"> msg </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">in</span></span><span class="koboSpan" id="kobo.662.1"> st.session_state.messages:
    st.chat_message(msg[</span><span class="hljs-string"><span class="koboSpan" id="kobo.663.1">"role"</span></span><span class="koboSpan" id="kobo.664.1">]).write(msg[</span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">"content"</span></span><span class="koboSpan" id="kobo.666.1">])
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.667.1">Finally, define the logic of the application whenever a user makes a query:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.668.1">if</span></span><span class="koboSpan" id="kobo.669.1"> user_query:
    st.session_state.messages.append({</span><span class="hljs-string"><span class="koboSpan" id="kobo.670.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.671.1">role"</span></span><span class="koboSpan" id="kobo.672.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.673.1">"user"</span></span><span class="koboSpan" id="kobo.674.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.675.1">"content"</span></span><span class="koboSpan" id="kobo.676.1">: user_query})
    st.chat_message(</span><span class="hljs-string"><span class="koboSpan" id="kobo.677.1">"user"</span></span><span class="koboSpan" id="kobo.678.1">).write(user_query)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.679.1">with</span></span><span class="koboSpan" id="kobo.680.1"> st.chat_message(</span><span class="hljs-string"><span class="koboSpan" id="kobo.681.1">"assistant"</span></span><span class="koboSpan" id="kobo.682.1">):
        st_cb = StreamlitCallbackHandler(st.container())
        response = agent_executor.run(user_query, callbacks = [st_cb], handle_parsing_errors=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.683.1">True</span></span><span class="koboSpan" id="kobo.684.1">)
        st.session_state.messages.append({</span><span class="hljs-string"><span class="koboSpan" id="kobo.685.1">"role"</span></span><span class="koboSpan" id="kobo.686.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.687.1">"assistant"</span></span><span class="koboSpan" id="kobo.688.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.689.1">"content"</span></span><span class="koboSpan" id="kobo.690.1">: response})
        st.write(response)
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.691.1">You can run</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.692.1"> your application</span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.693.1"> in the terminal with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">streamlit run copilot.py</span></code><span class="koboSpan" id="kobo.695.1"> command. </span><span class="koboSpan" id="kobo.695.2">The final web page looks as follows:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.696.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B21714_08_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.697.1">Figure 8.8: Screenshot of the front-end of DBCopilot</span></p>
<p class="normal"><span class="koboSpan" id="kobo.698.1">Thanks to</span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.699.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">StreamlitCallbackHandler</span></code><span class="koboSpan" id="kobo.701.1"> module, we</span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.702.1"> can also expand each action the agent took, for example:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.703.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B21714_08_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.704.1">Figure 8.9: Illustration of the agent’s actions during the chain</span></p>
<p class="normal"><span class="koboSpan" id="kobo.705.1">With just a few lines of code, we</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.706.1"> were able to set up a simple</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.707.1"> front-end for our DBCopilot with a conversational user interface.</span></p>
<h1 class="heading-1" id="_idParaDest-123"><span class="koboSpan" id="kobo.708.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.709.1">In this chapter, we saw how LLMs are not only capable of interacting with textual and unstructured data, but also with structured and numeric data. </span><span class="koboSpan" id="kobo.709.2">This is made possible because of two main elements: the natural capabilities of LLMs and, more generally, LFMs for understanding a problem’s statement, planning a resolution, and acting as reasoning engines, as well as a set of tools that extend LLMs’ capabilities with domain-specific skills.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.710.1">In this case, we mainly relied upon LangChain’s SQL Database toolkit, which connects the Agent to an SQL database with a curated prompt. </span><span class="koboSpan" id="kobo.710.2">Furthermore, we extended the Agent’s capabilities even further, making it able to generate matplotlib graphs, with the Python REPL tool, and save the output to our local file system with the File Management tool.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.711.1">In the next chapter, we are going to delve even deeper into the analytical capabilities of LLMs. </span><span class="koboSpan" id="kobo.711.2">More specifically, we are going to cover their capabilities of working with code.</span></p>
<h1 class="heading-1" id="_idParaDest-124"><span class="koboSpan" id="kobo.712.1">References</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.713.1">Chinook Database: </span><a href="https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources"><span class="url"><span class="koboSpan" id="kobo.714.1">https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.715.1">LangChain File system tool: </span><a href="https://python.langchain.com/docs/integrations/tools/filesystem"><span class="url"><span class="koboSpan" id="kobo.716.1">https://python.langchain.com/docs/integrations/tools/filesystem</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.717.1">LangChain Python REPL tool: </span><a href="https://python.langchain.com/docs/integrations/toolkits/python"><span class="url"><span class="koboSpan" id="kobo.718.1">https://python.langchain.com/docs/integrations/toolkits/python</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.719.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.720.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/llm "><span class="url"><span class="koboSpan" id="kobo.721.1">https://packt.link/llm</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.722.1"><img alt="" role="presentation" src="../Images/QR_Code214329708533108046.png"/></span></p>
</div>
</body></html>