<html><head></head><body>
        

                            
                    <h1 class="header-title">Navigation Behavior and Pathfinding</h1>
                
            
            
                
<p class="NormalPACKT">In this chapter, we'll be explaining in detail how the AI character moves around and understands where he can go and where he cannot. For different types of games, there are different solutions and we'll be addressing those solutions in this chapter, exploring common methods that can be used to develop a character that can move correctly on the map. Also we want our character to calculate the best trajectory to arrive at a certain destination, avoiding obstacles and accomplishing goals while doing it. We will introduce how to create a simple navigation behavior, then we will move on to a point to point movement and finally explore in depth how to create a more complex point to point movement (RTS/RPG system).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigation behavior</h1>
                
            
            
                
<p>When we talk about navigation behavior, we are referring to the actions of a character that is confronted with a situation where they need to calculate where to go or what to do. A map can have many points where it is necessary to jump or climb stairs in order to arrive at the final destination. The character should know how to use these actions to keep moving correctly; otherwise, he will fall down a hole or keep walking into a wall where he should be climbing some stairs. To avoid that, we need to plan all of the possibilities available for the character while he is moving, making sure that he can jump or perform any other movement necessary to keep moving into the right direction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing a new direction</h1>
                
            
            
                
<p>One important aspect that the AI character should have is choosing a new direction when he is confronted by an object that is blocking his way and that he cannot pass through. The character should be aware of the objects that are in front of him and, if he cannot keep moving forward in that direction, he should be able to choose a new direction, avoid colliding against the object and keep walking away from it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoid walking against walls</h1>
                
            
            
                
<p>If our character is facing a wall, he will need to know that he cannot pass through that wall and should choose another option. Unless we allow the character to climb the wall or destroy it, the character will need to face a new direction that is not blocked and walk in that new unblocked direction.</p>
<p>We will start with a simple approach that i can be often very useful, and is perhaps the best option, depending on the type of game that we are creating. In the example that we'll be demonstrating, the character in question needs to keep moving around the level just like the <em>PAC-MAN</em>Â enemies. Starting with a basic example, we give our character the freedom to choose which direction to move in, and later on we will add more information to our character's AI so he can pursue a specific objective on the map using this method.</p>
<div><img height="232" width="397" class=" image-border" src="img/1044c2cb-d14c-43bf-9beb-d54c1d9d09a7.png"/></div>
<p>We have created a grid and painted in black the squares where the character AI is not allowed to walk. Now we are going to program our character to move forward until he finds a black square in front of him; then, he will need to choose to turn right or left, making that decision randomly. This will allow our character to move freely on the map without any specific pattern. The code for this is as follows:</p>
<pre>     public float Speed;<br/>     public float facingLeft;<br/>     public float facingRight;<br/>     public float facingBack;<br/>     public static bool availableLeft;<br/>     public static bool availableRight;<br/><br/>     public bool aLeft;<br/>     public bool aRight;<br/><br/>     void Start ()<br/>     {<br/><br/>     }<br/><br/>     void Update ()<br/>     {<br/><br/>         aLeft = availableLeft;<br/>         aRight = availableRight;<br/><br/>         transform.Translate(Vector2.up * Time.deltaTime * Speed);<br/><br/>         if(facingLeft &gt; 270)<br/>         {<br/>             facingLeft = 0;<br/>         }<br/><br/>         if(facingRight &lt; -270)<br/>         {<br/>             facingRight = 0;<br/>         }<br/><br/>     }<br/><br/>     void OnTriggerEnter2D(Collider2D other)<br/>     {<br/><br/>         if(other.gameObject.tag == "BlackCube")<br/>         {<br/>             if(availableLeft == true &amp;&amp; availableRight == false)<br/>             {<br/>                 turnLeft();<br/>             }<br/><br/>             if(availableRight == true &amp;&amp; availableLeft == false)<br/>             {<br/>                 turnRight();<br/>             }<br/><br/>             if(availableRight == true &amp;&amp; availableLeft == true)<br/>             {<br/>                 turnRight();<br/>             }<br/><br/>             if(availableRight == false &amp;&amp; availableLeft == false)<br/>             {<br/>                 turnBack();<br/>             }<br/>         }<br/>     }<br/><br/>     void turnLeft ()<br/>     {<br/>         facingLeft = transform.rotation.eulerAngles.z + 90;<br/>         transform.localRotation = Quaternion.Euler(0, 0, facingLeft);<br/>     }<br/><br/>     void turnRight ()<br/>     {<br/>         facingRight = transform.rotation.eulerAngles.z - 90;<br/>         transform.localRotation = Quaternion.Euler(0, 0, facingRight);<br/>     }<br/><br/>     void turnBack ()<br/>     {<br/>         facingBack = transform.rotation.eulerAngles.z + 180;<br/>         transform.localRotation = Quaternion.Euler(0, 0, facingBack);<br/>     } </pre>
<p>For this example, we added colliders to the black squares to let the character know when he is touching them. This way, he will keep moving until colliding with a black square, and at that point there will be three options: turn left, turn right, or go back. To know which directions are unblocked, we created two separate colliders and added them to our character. Each collider has a script that gives the information to the character to let it know whether that side is free or not.</p>
<p>The <kbd>availableLeft</kbd> Boolean corresponds to the left side, and <kbd>availableRight</kbd> corresponds to the right side. If the left or right collider is in contact with the black square, the value is set to <kbd>false</kbd>. Otherwise, it is set to <kbd>true</kbd>. We are using <kbd>aLeft</kbd> and <kbd>aRight</kbd> simply to check in real time if the values are working correctly. This way, we can see whether there are any issues:</p>
<pre>   public bool leftSide; 
   public bool rightSide; 
 
   void Start () <br/>   { 
         
        if(leftSide == true)<br/>        { 
            rightSide = false; 
        } 
 
        if(rightSide == true)<br/>        { 
            leftSide = false; 
        } 
   } 
    
   void Update () { 
    
   } 
 
    void OnTriggerStay2D(Collider2D other) 
    { 
 
        if(other.gameObject.tag == "BlackCube") 
        { 
            if(leftSide == true &amp;&amp; rightSide == false) 
            { 
                Character.availableLeft = false; 
            } 
 
            if(rightSide == true &amp;&amp; leftSide == false) 
            { 
                Character.availableRight = false; 
            } 
        } 
    } 
 
    void OnTriggerExit2D(Collider2D other) 
    { 
 
        if(other.gameObject.tag == "BlackCube") 
        { 
            if(leftSide == true) 
            { 
                Character.availableLeft = true; 
            } 
 
            if(rightSide == true) 
            { 
                Character.availableRight = true; 
            } 
        } 
} 
 </pre>
<p>When we start the game, we can see that the character AI starts moving around on the white tiles and turning left or right every time he faces a black tile:</p>
<div><img height="170" width="168" class=" image-border" src="img/f29b9264-8591-40c3-9cdc-52281032dae7.png"/></div>
<p>But if we let the game run for a couple of minutes, we realize that the character keeps making the same decisions, and for that reason he will just be walking around a small portion of the map. This is due to the fact that he only makes a decision when colliding with a black tile, ignoring the other opportunities to turn:</p>
<div><img height="197" width="197" class=" image-border" src="img/cfb84437-f25a-47b9-b07c-7c50461bf207.png"/></div>
<div><p class="NormalPACKT">As we can see in the preceding image, the character always follows the same pattern, not an ideal situation if we want him to constantly choose different paths.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing an alternative path</h1>
                
            
            
                
<p>Our character successfully chooses a new direction every time that he approaches a wall, and now we want him to be able to move around all over the map. To make that happen, we are going to add more information into the character to let him know that if there's an available option to turn to the left or right, even if the forward path is free, the character is free to turn. We can use probabilities to determine whether the character is going to turn or not, and for this example we have chosen to give a 90% chance of choosing a new direction if one is available. That way, we can see the results happening very quickly:</p>
<pre>   public float Speed;<br/>   public float facingLeft;<br/>   public float facingRight;<br/>   public float facingBack;<br/>   public static bool availableLeft;<br/>   public static bool availableRight;<br/><br/>   public static int probabilityTurnLeft;<br/>   public static int probabilityTurnRight;public int probabilitySides;<br/><br/>   public bool forwardBlocked;<br/><br/>   public bool aLeft;<br/>   public bool aRight;</pre>
<p class="mce-root">After adding the variables we can move on to the <kbd>Start</kbd> method, everything that will be called on the first frame of the game.</p>
<pre>   void Start ()<br/>   {<br/>       availableLeft = false;<br/>       availableRight = false;<br/>       probabilityTurnLeft = 0;<br/>       probabilityTurnRight = 0;<br/>   }</pre>
<p class="NormalPACKT">Then we can move on the the <kbd>Update</kbd> method, everything that will be called every frame of the game.</p>
<pre>   void Update ()<br/>   {<br/>       aLeft = availableLeft;<br/>       aRight = availableRight;<br/><br/>       transform.Translate(Vector2.up * Time.deltaTime * Speed);<br/><br/>       if(facingLeft &gt; 270)<br/>       {<br/>           facingLeft = 0;<br/>       }<br/><br/>       if(facingRight &lt; -270)<br/>       {<br/>           facingRight = 0;<br/>       }<br/><br/>       if (forwardBlocked == false)<br/>       {<br/>           if (availableLeft == true &amp;&amp; availableRight == false)<br/>           {<br/>              if (probabilityTurnLeft &gt; 10)<br/>              {<br/>                   turnLeft();<br/>              }<br/>           }<br/><br/>           if (availableLeft == false &amp;&amp; availableRight == true)<br/>           {<br/>              if (probabilityTurnRight &gt; 10)<br/>              {<br/>                  turnRight();<br/>              }<br/>           }<br/><br/>           if (availableLeft == true &amp;&amp; availableRight == true)<br/>           {<br/>              probabilityTurnLeft = 0;<br/>              probabilityTurnRight = 0;<br/>           }<br/>       }<br/><br/>   }</pre>
<p class="mce-root">Here we add the trigger functions, what happens when he enters/collides against a 2D object:</p>
<pre>   void OnTriggerEnter2D(Collider2D other)<br/>   {<br/><br/>       if(other.gameObject.tag == "BlackCube")<br/>       {<br/>           forwardBlocked = true;<br/><br/>           if(availableLeft == true &amp;&amp; availableRight == false)<br/>           {<br/>                turnLeft();<br/>           }<br/><br/>           if(availableRight == true &amp;&amp; availableLeft == false)<br/>           {<br/>               turnRight();<br/>           }<br/><br/>           if(availableRight == true &amp;&amp; availableLeft == true)<br/>           {<br/>               probabilitySides = Random.Range(0, 1);<br/>               if(probabilitySides == 0)<br/>               {<br/>                   turnLeft();<br/>               }<br/><br/>               if(probabilitySides == 1)<br/>               {<br/>                   turnRight();<br/>               }<br/><br/>           }<br/><br/>           if(availableRight == false &amp;&amp; availableLeft == false)<br/>           {<br/>               turnBack();<br/>           }<br/>       }<br/>   }<br/><br/>   void OnTriggerExit2D(Collider2D other)<br/>   {<br/>       forwardBlocked = false;<br/>   }<br/><br/><br/>   void  turnLeft ()<br/>   {<br/>       probabilityTurnLeft = 0;<br/>       facingLeft = transform.rotation.eulerAngles.z + 90;<br/>       transform.localRotation = Quaternion.Euler(0, 0, facingLeft);<br/>   }<br/><br/>   void turnRight ()<br/>   {<br/>       probabilityTurnRight = 0;<br/>       facingRight = transform.rotation.eulerAngles.z - 90;<br/>       transform.localRotation = Quaternion.Euler(0, 0, facingRight);<br/>   }<br/><br/>   void turnBack ()<br/>   {<br/>       facingBack = transform.rotation.eulerAngles.z + 180;<br/>       transform.localRotation = Quaternion.Euler(0, 0, facingBack);<br/>   } </pre>
<p>We have added four new variables to our character AI script, the <kbd>probabilityTurnLeft</kbd> static variable, which calculates the probability of the character turning left; <kbd>probabilityTurnRight</kbd>, which calculates the probability of the character turning right; a new probability generator, <kbd>probabilitySides</kbd>, which will decide which way to turn when both are available and the forward path is blocked; and finally, a Boolean, <kbd>forwardBlocked</kbd>, to check whether the forward path is blocked or not. The character needs to check whether the forward path is blocked to know if he can turn or not. This will prevent the character from turning more than once when he is facing a black tile.</p>
<div><img height="223" width="337" class=" image-border" src="img/c8e0b1d1-430f-4dd3-9c13-91a37af048fa.png"/></div>
<p>In the script that controls the side triggers, we added a new variable called <kbd>probabilityTurn</kbd>, which gives the character information about the probabilities. Every time the trigger exits the collider, he calculates the probability and sends a message to the character telling it that the side is free and he can make the decision to turn to that side:</p>
<pre>   public bool leftSide;<br/>   public bool rightSide;<br/>   public int probabilityTurn;<br/><br/>   void Start () <br/>   {<br/>       if(leftSide == true)<br/>      {<br/>          rightSide = false;<br/>       }<br/><br/>       if(rightSide == true)<br/>       {<br/>          leftSide = false;<br/>       }<br/>    }<br/><br/>    void Update () <br/>    {<br/><br/>    }<br/><br/>    void OnTriggerEnter2D(Collider2D other)<br/>    {<br/>       if(other.gameObject.tag == "BlackCube")<br/>       {<br/>           if(leftSide == true &amp;&amp; rightSide == false)<br/>           {<br/>               Character.availableLeft = false;<br/>               probabilityTurn = 0;<br/>               Character.probabilityTurnLeft = probabilityTurn;<br/>           }<br/><br/>           if(rightSide == true &amp;&amp; leftSide == false)<br/>           {<br/>               Character.availableRight = false;<br/>               probabilityTurn = 0;<br/>               Character.probabilityTurnRight = probabilityTurn;<br/>           }<br/>        }<br/>     }<br/><br/>     void OnTriggerStay2D(Collider2D other)<br/>     {<br/><br/>           if(other.gameObject.tag == "BlackCube")<br/>           {<br/>               if(leftSide == true &amp;&amp; rightSide == false)<br/>               {<br/>                   Character.availableLeft = false;<br/>                   probabilityTurn = 0;<br/>                   Character.probabilityTurnLeft = probabilityTurn;<br/>               }<br/><br/>               if(rightSide == true &amp;&amp; leftSide == false)<br/>               {<br/>                   Character.availableRight = false;<br/>                   probabilityTurn = 0;<br/>                   Character.probabilityTurnRight = probabilityTurn;<br/>               }<br/>           }<br/>       }<br/><br/>       void OnTriggerExit2D(Collider2D other)<br/>       {<br/><br/>           if(other.gameObject.tag == "BlackCube")<br/>           {<br/>               if(leftSide == true)<br/>               {<br/>                   probabilityTurn = Random.Range(0, 100);<br/>                   Character.probabilityTurnLeft = probabilityTurn;<br/>                   Character.availableLeft = true;<br/>               }<br/><br/>               if(rightSide == true)<br/>               {<br/>                   probabilityTurn = Random.Range(0, 100);<br/>                   Character.probabilityTurnRight = probabilityTurn;<br/>                   Character.availableRight = true;<br/>               }<br/>           }<br/>        } </pre>
<div><p>If we play the game, we can see the new changes implemented to the character. Now he is unpredictable, choosing different paths every time and moving all around the map, contrary to what we had before. Once this is completed, we can create as many maps as we wish because the character will always find the right path and avoid colliding with the walls.</p>
<div><div><img height="246" width="246" class=" image-border" src="img/a282a072-4894-4427-b877-fd1ab9918f5d.png"/></div>
</div>
<div><p class="NormalPACKT">Testing on a bigger map, the character reacts the same way, moving around the whole map. This means that our main objective has been completed and now we can easily create new maps and use the character as the main enemy of the game so that he will always move differently and does not follow any pattern.</p>
</div>
<div><div><img height="183" width="233" class=" image-border" src="img/dfa3060c-b95e-4edd-a81d-da54e7035429.png"/></div>
</div>
<div><p>We can adjust the percentage values according to the way we want the character to react, and also implement more variables to make it unique to our game idea.</p>
</div>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Point to point movement</h1>
                
            
            
                
<p>Now that we understand the basics of how to create a character that can move freely in a maze genre game, we will take a look at the opposite: how to create a movement pattern from point to point. This is also an important aspect of AI movement, because later on we can combine both techniques to create a character that goes from one point to another, avoiding walls and obstacles.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tower defense genre</h1>
                
            
            
                
<p>Once again, the principle that we will be using to make our character move from one point to another can be applied to both 2D and 3D games. In this example, we'll explore how to create the main characteristic of a Tower Defense game: the enemy pattern. The objective is to have the enemies spawning at a start point and following a path so they can reach the final point. The enemies in a tower defense game usually just have this in mind, so it is a perfect example to test how to create point to point movement.</p>
<p>A <em>Tower Defense</em> game usually consists of two areas: the area where the enemies walk from their start position to the final position, and the area where the player is allowed to build towers that attack the enemies, trying to stop them reaching the final position. Because the player is not allowed to build anything inside the path where the enemies will pass, the AI does not need to be aware of its surroundings because it will always be free to pass through, and because of that we only need to focus on the point to point movement of the characters.</p>
<div><div><img height="235" width="332" class="image-border" src="img/5ff945f5-0dd0-4235-a563-dd77b0ba2ae8.jpg"/></div>
</div>
<div><p>After importing the map and characters that we'll be using in the game, we need to configure the <strong>waypoints</strong> that will be used by the character so they know where they need to go. We can do this by manually adding the coordinates into our code, but to simplify the process we'll create objects in the scene that will serve as waypoints and we delete the 3D mesh because it won't be necessary.</p>
<p>Now we group all the waypoints that we have created and name the group waypoints. Once we have the waypoints in place and grouped together, we can start creating the code that will tell our character how many waypoints it needs to follow. This code is very useful because we can create different maps, using as many waypoints we need, without needing to update the character's code:</p>
<pre>   public static Transform[] points;<br/><br/>   void Awake () <br/>   {<br/>        points = new Transform[transform.childCount];<br/>        for (int i = 0; i &lt; points.Length; i++)<br/>        {<br/>             points[i] = transform.GetChild(i); <br/>         }<br/>   }</pre>
<p>This code will be assigned to the group that we have created, and will count the number of waypoints that he has inside of it and ordering them.</p>
</div>
<div><img height="235" width="413" class=" image-border" src="img/b56bafd3-551f-4ce2-b4f3-539bbee33ed9.png"/></div>
<div><p>The blue spheres that we can see in the preceding image represent the 3D meshes that we have used as waypoints. For this example, the character will follow eight points until he finishes the path. Now let's move on to the AI character code and see how we can make the character move from point to point using the points that we have created.</p>
<p>We start by creating the basic functions of the character, the health and speed. Then we can create a new variable that will tell the character the next position that he needs to move to, and another variable that will be used show which waypoint it needs to follow:</p>
<pre> public float speed;<br/> public int health;<br/><br/> private Transform target;<br/> private int wavepointIndex = 0; </pre>
<p>Now we have the basic variables that are needed to make an enemy character move from point to point until he dies or reaches the end. Let's see how to use these to make it playable:</p>
<pre> public float speed;<br/> public int health;<br/><br/> private Transform target;<br/> private int wavepointIndex = 0;<br/><br/><br/> void Start ()<br/> {<br/>      target = waypoints.points[0];  speed = 10f;<br/> }<br/><br/> void Update ()<br/> {<br/>      Vector3 dir = target.position - transform.position;<br/>      transform.Translate(dir.normalized * speed * Time.deltaTime, <br/>         Space.World);<br/><br/>      if(Vector3.Distance(transform.position, target.position) &lt;= 0.4f)<br/>      {<br/>          GetNextWaypoint();<br/>      }<br/> }<br/><br/> void GetNextWaypoint()<br/> {<br/>      if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>      {<br/>          Destroy(gameObject);<br/>          return;<br/>      }<br/><br/>      wavepointIndex++;<br/>      target = waypoints.points[wavepointIndex];<br/> } </pre>
<p>In the <kbd>Start</kbd> function, the first waypoint that the characters needs to follow is the waypoint number zero, that is, the first on the Transform list that we created in the <kbd>waypoints</kbd> code. Also, we have determined the velocity of the character, and for this example we have chosen <kbd>10f.</kbd></p>
<p>Then in the <kbd>Update</kbd> function the character will calculate the distance between the next position and the current position, using the Vector 3 <kbd>dir</kbd>. The character will constantly be moving, so we have created a line of code that serves as movement for the character, <kbd>transform.Translate</kbd> in this case. Knowing the distance and the speed information, the character will know how far it is from the next position, and once he reaches the desirable distance from that point, he can then move on to the next point. To make this happen, we create an <kbd>if</kbd> statement that will tell to the character that, if he reaches 0.4f (for this example) from the point that he is moving towards, it means that he has already arrived at that destination and can start moving on to the next point, <kbd>GetNextWaypoint()</kbd>.</p>
<p>In the <kbd>GetNextWaypoint()</kbd> function, the character will try to confirm if he has arrived at the final destination. If the character has arrived at the final waypoint, then the object can be destroyed; if not, it can continue to the next waypoint. Here, <kbd>wavepointIndex++</kbd> will add one number to the index every time the character arrives at a waypoint, moving from 0&gt;1&gt;2&gt;3&gt;4&gt;5, and so on.</p>
<p>Now we assign the code to our character and place the character on the start position and test the game to see if it is working properly:</p>
</div>
<p class="packt_figure CDPAlignCenter CDPAlign"><img height="283" width="508" class=" image-border" src="img/216e5d9a-70eb-4a37-b137-12e0f07f1112.png"/></p>
<p>Everything is working as expected: the character will move from one point to another until he arrives at the last one, and then he disappears from the game. However, there are still some improvements we need to make, because the character is facing always the same direction; he does not rotate when he changes direction. Let's take the opportunity to also create the instantiating code that will keep spawning enemies into the map.</p>
<p>In the same way we created an object to define the waypoint, we'll do the same for the start position, creating an object that will simply serve as position, so we can spawn the enemies from that point. To make that happen, we create a simple code just to test the gameplay without it being necessary to manually add the characters to the game:</p>
<pre> public Transform enemyPrefab;<br/> public float timeBetweenWaves = 3f;<br/> public Transform spawnPoint;<br/><br/> private float countdown = 1f;<br/> private int waveNumber = 1;<br/><br/> void Update ()<br/> {<br/>      if(countdown &lt;= 0f)<br/>      {<br/>          StartCoroutine(SpawnWave());<br/>          countdown = timeBetweenWaves;<br/>      }<br/><br/>      countdown -= Time.deltaTime;<br/> }<br/><br/> IEnumerator SpawnWave ()<br/> {<br/>      waveNumber++;<br/><br/>      for (int i = 0; i &lt; waveNumber; i++)<br/>      {<br/>          SpawnEnemy();<br/>          yield return new WaitForSeconds(0.7f);<br/>      }<br/> }<br/><br/> void SpawnEnemy()<br/> {<br/>      Instantiate(enemyPrefab, spawnPoint.position, <br/>            spawnPoint.rotation);<br/> }</pre>
<p>At this moment, we already have a <kbd>wave spawner</kbd> working as well, spawning a new wave of enemies every three seconds. This will help us visualize the gameplay that we are creating for our AI character. We have five variables. <kbd>enemyPrefab</kbd> is the character that we are creating, so the code can spawn him. <kbd>timeBetweenWaves</kbd> represents the time that it will wait before spawning a new wave. The <kbd>spawnPoint</kbd> variable determines the position where the character will appear, the start position. Here, <kbd>countdown</kbd> is the time that we wait before the first wave appears. <kbd>waveNumber</kbd> is the last variable, and serves to count the current wave (usually, this is used to differentiate the enemy difficulty from one wave to another).</p>
<p>If we run the game now, we can see that the number of characters appearing in the game is much more than just one, increasing every three seconds. Doing this at the same time as we develop our AI character is very useful, because if our characters have special abilities or if they have different speeds, we can fix it right away while we are developing them. Because we are just creating a small example, it is expected to work smoothly without any bugs.</p>
<p>Let's test it out now to see what happens:</p>
<div><div><img height="249" width="447" class=" image-border" src="img/b7e68b0e-c3d4-46fe-b3c2-5e83cbf6f08a.png"/></div>
</div>
<div><p>It looks much more interesting now! We can see that the point to point movement is working as intended, and all the characters spawned into the game know where they need to go, following the right path.</p>
<p>We can now update the character code so it can turn to face the next point position while going around corners. To create this, we add a few more lines to the enemy code:</p>
<pre> public float speed;<br/> public int health;<br/> public float speedTurn;<br/><br/> private Transform target;<br/> private int wavepointIndex = 0;<br/><br/><br/> void Start ()<br/> {<br/>      target = waypoints.points[0];<br/>      speed = 10f;<br/>      speedTurn = 0.2f;<br/> }<br/><br/> void Update ()<br/> {<br/>      Vector3 dir = target.position - transform.position;<br/>      transform.Translate(dir.normalized * speed * Time.deltaTime, <br/>            Space.World);<br/><br/>      if(Vector3.Distance(transform.position, target.position) &lt;= 0.4f)<br/>      {<br/>          GetNextWaypoint();<br/>      }<br/><br/>      Vector3 newDir = Vector3.RotateTowards(transform.forward, dir, <br/>            speedTurn, 0.0F);<br/><br/>      transform.rotation = Quaternion.LookRotation(newDir);<br/> }<br/><br/> void GetNextWaypoint()<br/> {<br/>      if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>      {<br/>          Destroy(gameObject);<br/>          return;<br/>      }<br/><br/>      wavepointIndex++;<br/>      target = waypoints.points[wavepointIndex];<br/> } </pre>
<p>As we can see in the preceding code, we have added a new variable called <kbd>speedTurn</kbd>, which will represent the velocity of our character when turning, and in the <kbd>start</kbd> function we have determined the speed value as <kbd>0.2f</kbd>. Then, in the update function, we calculate the velocity by multiplying this number by <kbd>Time.deltaTime</kbd>, giving a constant value regardless of the <kbd>FPS</kbd> number that the player is experiencing. Then we have created a new <kbd>Vector3</kbd> variable called <kbd>newDir</kbd>, which will make our character turn towards the target position.</p>
<p>Now if we test the game once more, we can see that the characters turn towards their next point position:</p>
</div>
<div><div><img height="265" width="473" class=" image-border" src="img/1642b11f-90fc-45b4-963c-77087671c1fb.png"/></div>
</div>
<div><p>At this point, we can see that the AI characters are reacting correctly, moving from point to point as intended and turning towards their next position. Now we have the basics of a tower defense game and, we could add unique code to create a new and enjoyable game.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Racing genre</h1>
                
            
            
                
<p class="NormalPACKT">Point to point movement is a method that can be applied to practically any game genre and it has been extensively used over the years. Our next example is a racing game, where the AI drivers use point to point movement to compete against the player. To create this, we would need a road and a driver and then we'll place the waypoints on the road and tell our AI driver to follow that path. It's very similar to what we have done before but with some behavior differences in our character because we don't want it to look rigid when he is turning and also there will be other drivers on the same map and they cannot overlap one on top of another.</p>
<p class="NormalPACKT">Without further ado let's start, first we need to establish the map, which in this case is the race track:</p>
<div><div><img height="235" width="332" class="image-border" src="img/c07ab290-7a8e-49e6-b4e4-85875acb3f11.jpg"/></div>
</div>
<div><p>After designing our race track, we need to define every point position that our drivers need to go to, and because we have a lot of curves, we need to create more point positions than we had before so that the car follows the road smoothly.</p>
<p>We have done the same process as before, creating objects inside the game and using them as position references only:</p>
</div>
<div><div><img height="195" width="346" class=" image-border" src="img/b80e6720-a2e8-49bd-b363-a49d2197a342.png"/></div>
</div>
<div><p>This is our map with the waypoints in place, and as we can see, there are more points on the curves. This is very important if we want to achieve a smooth transition from one point to another.</p>
<p>Now let's group all the waypoints again, and this time we'll create a different code. Instead of creating a code that manages the waypoints, we will be implementing that calculation inside of our AI driver code and creating a simple code to apply to each waypoint to specify the next position to follow.</p>
<p>There are many ways that we can develop our code, and depending on our preferences or the game genre that we are working on, some methods can work better than others. In this case, we have found that using the code we developed for our Tower Defense character does not fit with this game genre.</p>
<p>Starting with the AI driver code, we have used ten variables, as shown in the following code block:</p>
<pre> public static bool raceStarted = false;<br/><br/> public float aiSpeed = 10.0f;<br/> public float aiTurnSpeed = 2.0f;<br/> public float resetAISpeed = 0.0f;<br/> public float resetAITurnSpeed = 0.0f;<br/><br/> public GameObject waypointController;<br/> public List&lt;Transform&gt; waypoints;<br/> public int currentWaypoint = 0;<br/> public float currentSpeed;<br/> public Vector3 currentWaypointPosition; </pre>
<p>The first one, <kbd>raceStarted</kbd>, is a static Boolean that will tell our driver whether the race has started. This takes into consideration the fact that the race only begins when the green light appears; if not, <kbd>raceStarted</kbd> is set to <kbd>false</kbd>. Next, we have <kbd>aiSpeed</kbd>, which represents the velocity of the car. This is a simplified version for test proposes; otherwise, we would need speed functions to determine how fast can the car is going according to the gear that is set. <kbd>aiTurnSpeed</kbd> represents the velocity of the car when he is turning, how fast we want the car to steer when he is facing a new direction. Next, we have the <kbd>waypointController</kbd>, which will be linked to the waypoints group; and the <kbd>waypoints</kbd> list, which will be taken from that group.</p>
<p>Here, <kbd>currentWaypoint</kbd> will tell our driver which waypoint number he is currently following. The <kbd>currentSpeed</kbd> variable will show the current velocity of the car. Finally, <kbd>currentWaypointPosition</kbd> is the Vector 3 position of the waypoint that the car will be following:</p>
<pre> void Start () <br/> {<br/>       GetWaypoints();<br/>       resetAISpeed = aiSpeed;<br/>       resetAITurnSpeed = aiTurnSpeed;<br/> }</pre>
<p>In our <kbd>start</kbd> function, we have only three lines of code: <kbd>GetWaypoints()</kbd>, which will access all of the waypoints that exist inside of the group, and <kbd>resetAISpeed</kbd> and <kbd>resetAITurnSpeed</kbd>, which reset the speed values because they will influence the rigid body placed on the car:</p>
<pre>  void Update () <br/>  {<br/>       if(raceStarted)<br/>       {<br/>           MoveTowardWaypoints();    <br/>       }<br/>  }</pre>
<p>In the update function, we have a simple <kbd>if</kbd> statement that checks whether the race has started or not. If the race has started, then he can proceed to the next step, which is the most important for our AI driver, <kbd>MoveTowardWaypoints()</kbd>. For this example, we have not stated anything while the car is waiting for the green light, but we could have implemented the engine starting and the pre-acceleration of the car, for example:</p>
<pre>  void GetWaypoints()<br/>  {<br/>    Transform[] potentialWaypoints = waypointController.<br/>        GetComponentsInChildren&lt;Transform&gt;();<br/><br/>    waypoints = new List&lt;Transform&gt;();<br/><br/>    for each(Transform potentialWaypoint in potentialWaypoints)<br/>     {<br/>        if(potentialWaypoint != waypointController.transform)<br/>        {<br/>           waypoints.Add(potentialWaypoint);    <br/>        }<br/>     } <br/>  } </pre>
<p>Next, we have <kbd>GetWaypoints()</kbd>, which was instantiated in the <kbd>Start</kbd> function. Here, we access the <kbd>waypointController</kbd> group and retrieve all the position information regarding the waypoints that are stored inside it. Because we will be ordering the waypoints in a different code, we don't need to do that here:</p>
<pre>  void MoveTowardWaypoints()<br/>  {<br/>     float currentWaypointX = waypoints[currentWaypoint].position.x;<br/>     float currentWaypointY = transform.position.y;<br/>     float currentWaypointZ = waypoints[currentWaypoint].position.z;<br/><br/>     Vector3 relativeWaypointPosition = transform.<br/>        InverseTransformPoint (new Vector3(currentWaypointX,   <br/>        currentWaypointY, currentWaypointZ));<br/>     currentWaypointPosition = new Vector3(currentWaypointX, <br/>         currentWaypointY, currentWaypointZ);<br/><br/>     Quaternion toRotation = Quaternion.LookRotation<br/>        (currentWaypointPosition - transform.position);<br/>     transform.rotation = Quaternion.RotateTowards<br/>        (transform.rotation, toRotation, aiTurnSpeed);<br/><br/>     GetComponent&lt;Rigidbody&gt;().AddRelativeForce(0, 0, aiSpeed);<br/><br/>     if(relativeWaypointPosition.sqrMagnitude &lt; 15.0f)<br/>     {<br/>        currentWaypoint++;<br/><br/>        if(currentWaypoint &gt;= waypoints.Count)<br/>        {<br/>           currentWaypoint = 0;    <br/>        }<br/>     }<br/><br/>     currentSpeed = Mathf.Abs(transform.<br/>       InverseTransformDirection<br/>      (GetComponent&lt;Rigidbody&gt;().velocity).z);<br/><br/>     float maxAngularDrag = 2.5f;<br/>     float currentAngularDrag = 1.0f;<br/>     float aDragLerpTime = currentSpeed * 0.1f;<br/><br/>     float maxDrag = 1.0f;<br/>     float currentDrag = 3.5f;<br/>     float dragLerpTime = currentSpeed * 0.1f;<br/><br/>     float myAngularDrag = Mathf.Lerp(currentAngularDrag, <br/>        maxAngularDrag, aDragLerpTime);<br/>     float myDrag = Mathf.Lerp(currentDrag, maxDrag, dragLerpTime);<br/><br/>     GetComponent&lt;Rigidbody&gt;().angularDrag = myAngularDrag;<br/>     GetComponent&lt;Rigidbody&gt;().drag = myDrag;<br/>   } </pre>
<p>Finally, we have the <kbd>MoveTowardsWaypoints()</kbd> function. Because the car has more depth in terms of mobility than a simple Tower Defense character, we decided to expand and implement more content in this part of the code.</p>
<p>First, we retrieve the Vector 3 position of the current waypoint that is being used. We have chosen to retrieve this information and assign the axis separately, and for that reason we have <kbd>currentWaypointX</kbd> for the X axis, <kbd>currentWaypointY</kbd> for the Y axis, and <kbd>currentWaypointZ</kbd> for the Z axis.</p>
<p>Then we create a new Vector 3 direction called <kbd>relativeWaypointPosition</kbd>, which will calculate the distance between the waypoint and the current position of the car and convert from World Space to Local, and in this case we have used <kbd>InverseTransformDirection</kbd>.</p>
</div>
<div><img height="245" width="391" class="image-border" src="img/eca4daa4-b5f5-4418-8cf1-342bca678f56.jpg"/></div>
<div><p class="NormalPACKT">As we can see represented on the preceding graphic, we want to calculate the distance in local space between the car and the waypoint. This will tell to our driver if the waypoint is at his right or left side. This is recommended because the wheels command the car speed and they have an independent rotation value and if we kept working on this game, it would be one feature that would still need to be developed.</p>
<p>To smooth the rotation between one waypoint to another, we have used the following code:</p>
<pre>   Quaternion toRotation = Quaternion.LookRotation<br/>           (currentWaypointPosition - transform.position);<br/>   transform.rotation = Quaternion.RotateTowards<br/>           (transform.rotation, toRotation, aiTurnSpeed);</pre>
<p>This is an updated version of what we used in the Tower Defense. It will make our car move smoothly towards the waypoint that the car is traveling toward. This gives the effect of the car turning; otherwise, he would turn right away towards the waypoint and it would look unrealistic:</p>
<p><img class="image-border" src="img/b510d9d0-00a0-4fa9-8628-e0cb9c7aa616.jpg"/></p>
<p>As we can see, straight lines do not fit the genre that we are currently creating. It works perfectly in other genres, like Tower Defense game, but for a racing game it is necessary to redefine the code to adjust to the situation that we are creating.</p>
</div>
<div><p>The rest of the code is exactly that, adjustments for the situation that we are creating, which is a car moving on a race track. There are force elements such as <kbd>drag</kbd>, which is the friction between the car and the road, represented in this code. When we turn the car, it will slide according to the velocity of the car at that moment, and these details are taken into consideration here, creating a more realistic point to point movement where we can see that the car is reacting according to physics.</p>
<p>This is the full code that we have used in our example:</p>
<pre> public static bool raceStarted = false;<br/><br/> public float aiSpeed = 10.0f;<br/> public float aiTurnSpeed = 2.0f;<br/> public float resetAISpeed = 0.0f;<br/> public float resetAITurnSpeed = 0.0f;<br/><br/> public GameObject waypointController;<br/> public List&lt;Transform&gt; waypoints;<br/> public int currentWaypoint = 0;<br/> public float currentSpeed;<br/> public Vector3 currentWaypointPosition;<br/><br/> void Start () <br/> {<br/>      GetWaypoints();<br/>      resetAISpeed = aiSpeed;<br/>      resetAITurnSpeed = aiTurnSpeed;<br/> }<br/><br/> void Update () <br/> {<br/>    if(raceStarted)<br/>    {<br/>        MoveTowardWaypoints();    <br/>    }<br/> }<br/><br/> void GetWaypoints()<br/>  {<br/>      Transform[] potentialWaypoints =  <br/>        waypointController.GetComponentsInChildren&lt;Transform&gt;();<br/><br/>      waypoints = new List&lt;Transform&gt;();<br/><br/>      foreach(Transform potentialWaypoint in potentialWaypoints)<br/>      {<br/>          if(potentialWaypoint != waypointController.transform)<br/>          {<br/>              waypoints.Add(potentialWaypoint);    <br/>          }<br/>      }<br/> }<br/><br/> void MoveTowardWaypoints()<br/> {<br/>      float currentWaypointX = waypoints[currentWaypoint].position.x;<br/>      float currentWaypointY = transform.position.y;<br/>      float currentWaypointZ = waypoints[currentWaypoint].position.z;<br/><br/>      Vector3 relativeWaypointPosition = transform.<br/>         InverseTransformPoint (new Vector3(currentWaypointX, <br/>         currentWaypointY, currentWaypointZ));<br/>      currentWaypointPosition = new Vector3(currentWaypointX, <br/>         currentWaypointY, currentWaypointZ);<br/><br/>      Quaternion toRotation = Quaternion.<br/>         LookRotation(currentWaypointPosition - transform.position);<br/>      transform.rotation = Quaternion.RotateTowards<br/>         (transform.rotation, toRotation, aiTurnSpeed);<br/><br/>      GetComponent&lt;Rigidbody&gt;().AddRelativeForce(0, 0, aiSpeed);<br/><br/>      if(relativeWaypointPosition.sqrMagnitude &lt; 15.0f)<br/>      {<br/>          currentWaypoint++;<br/><br/>          if(currentWaypoint &gt;= waypoints.Count)<br/>          {<br/>              currentWaypoint = 0;    <br/>           }<br/>      }<br/><br/>      currentSpeed = Mathf.Abs(transform.<br/>          InverseTransformDirection<br/>          (GetComponent&lt;Rigidbody&gt;().velocity).z);<br/><br/>      float maxAngularDrag = 2.5f;<br/>      float currentAngularDrag = 1.0f;<br/>      float aDragLerpTime = currentSpeed * 0.1f;<br/><br/>      float maxDrag = 1.0f;<br/>      float currentDrag = 3.5f;<br/>      float dragLerpTime = currentSpeed * 0.1f;<br/><br/>      float myAngularDrag    = Mathf.Lerp(currentAngularDrag, <br/>          maxAngularDrag, aDragLerpTime);<br/>      float myDrag = Mathf.Lerp(currentDrag, maxDrag, dragLerpTime);<br/><br/>      GetComponent&lt;Rigidbody&gt;().angularDrag = myAngularDrag;<br/>      GetComponent&lt;Rigidbody&gt;().drag = myDrag;<br/> } </pre>
<p>If we start the game and test it, we can see that he is working fine. The car drives by itself, turns smoothly, and completes the track as intended.</p>
<p>Now that we have the basic point to point movement completed, we could implement more functions for the AI driver and start developing the game as we want. It is always recommended to start with the main functions of the gameplay before developing any details. This will help identify any ideas that we had planned for the game that do not work as well as we thought.</p>
</div>
<div><img height="255" width="455" class=" image-border" src="img/e69f4df7-1a8d-444c-82d0-5d93aab94edd.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">MOBA genre</h1>
                
            
            
                
<p>Point to point movement is one of the most commonly used methods to control the movement of a character. It is self-explanatory why it is widely used, because the character moves from one point to another and usually that's we want; we want the character to arrive at certain destination or follow another character. One game genre that also requires this type of movement is the Multiplayer Online Battle Arena (MOBA) games that have become very popular recently. Usually, there are NPC characters that spawn at the start position and follow a predetermined path towards the enemy towers, similar to the Tower Defense enemies, but in this case the AI characters move in the same terrain as the players and can interfere with each other.</p>
<p>The map is divided into two equal parts, where one side needs to fight the other, and for each part it spawns a different platoon that is composed of small enemies called Minions or Creeps. When they are following their path, if one platoon finds the other, they stop moving forward and start attacking. After the battle, the survivors keep moving forward:</p>
<div><img height="266" width="265" class="image-border" src="img/56c70510-4439-4e49-8f62-2511f17d9324.jpg"/></div>
<div><p>In this example we are going to re-create that portion of the game, where the platoon spawns at the start position, follows their path, stops when they find the enemies and keep moving towards their next direction until they win the fight. Then we will create the basic movement of the hero character that is controlled by the player or the computer: both have the freedom to move around the map and the characters needs to follow the direction that is directed by the player or computer while avoiding all obstacles.</p>
<p class="NormalPACKT">We will start by importing the map into our game. We have chosen a generic MOBA style map, like we can see on the following screenshot:</p>
</div>
<div><img height="288" width="516" class=" image-border" src="img/1bc9983d-7af5-4eb5-b1da-4106f407a258.png"/></div>
<div><p class="NormalPACKT">The next step is to create waypoints in the map. Here we will have six different waypoints groups, because each team has three different paths and each platoon can only follow one path. We start from the base position and then we add more waypoints until we reach the enemy base. The following image shows an example of what we have created.</p>
</div>
<div><img height="179" width="341" class="image-border" src="img/113a359a-2c3d-495b-85fe-944a0a3d2418.jpg"/></div>
<div><p>We need to create three different waypoint groups for each team, because there will be three different spawn positions as well; they will work independently from one another. After setting the waypoints, we can group them and assign the code that will gather the position information and the order that the platoon should follow. For this example, we can use the same code that we used for the Tower Defense waypoints, because the way that the enemies follow their path is similar:</p>
<pre> public static Transform[] points;<br/><br/> void Awake () <br/> {<br/>      points = new Transform[transform.childCount];<br/>      for (int i = 0; i &lt; points.Length; i++)<br/>      {<br/>          points[i] = transform.GetChild(i); <br/>      }<br/> }</pre>
<p>Because we have six different waypoint groups, it is necessary to duplicate the same code six times and rename them accordingly. Our <kbd>spawnable</kbd> enemies will later access the right path for them, so it is recommended to rename the groups and codes so that we can easily understand which group represents which lane, for example, 1_Top/1_Middle/1_Bottom and 2_Top/2_Middle/2_Bottom. The number represents their team and the position name represents the position. In this case, we change the name <kbd>points</kbd> in our code to the correct names that represent each lane:</p>
<p>Lane Team 1 Top:</p>
<pre> public static Transform[] 1_Top;<br/><br/> void Awake () <br/> {<br/>      1_Top = new Transform[transform.childCount];<br/>      for (int i = 0; i &lt; 1_Top.Length; i++)<br/>      {<br/>          1_Top[i] = transform.GetChild(i); <br/>      }<br/> }</pre>
<p>Lane Team 1 Middle:</p>
<pre> public static Transform[] 1_Middle;<br/><br/> void Awake () <br/> {<br/>      1_Middle = new Transform[transform.childCount];<br/>      for (int i = 0; i &lt; 1_Top.Length; i++)<br/>      {<br/>          1_Middle[i] = transform.GetChild(i); <br/>      }<br/> }</pre>
<p>Lane Team 1 Bottom:</p>
<pre> public static Transform[] 1_Bottom;<br/><br/> void Awake () <br/> {<br/>      1_Bottom = new Transform[transform.childCount];<br/>      for (int i = 0; i &lt; 1_Top.Length; i++)<br/>      {<br/>          1_Bottom[i] = transform.GetChild(i); <br/>      }<br/> }</pre>
<p>Lane Team 2 Top:</p>
<pre> public static Transform[] 2_Top;<br/><br/> void Awake () <br/> {<br/>      2_Top = new Transform[transform.childCount];<br/>      for (int i = 0; i &lt; 1_Top.Length; i++)<br/>      {<br/>          2_Top[i] = transform.GetChild(i); <br/>      }<br/> }</pre>
<p>Lane Team 2 Middle:</p>
<pre> public static Transform[] 2_Middle;<br/><br/> void Awake () <br/> {<br/>      2_Middle = new Transform[transform.childCount];<br/>      for (int i = 0; i &lt; 2_Middle.Length; i++)<br/>      {<br/>          2_Middle[i] = transform.GetChild(i); <br/>      }<br/> }</pre>
<p>Lane Team 2 Bottom:</p>
<pre> public static Transform[] 2_Bottom;<br/><br/> void Awake () <br/> {<br/>      2_Bottom = new Transform[transform.childCount];<br/>      for (int i = 0; i &lt; 2_Bottom.Length; i++)<br/>      {<br/>          2_Bottom[i] = transform.GetChild(i); <br/>      }<br/> }</pre>
<p>Now that we have created all the groups and codes for each of them, we can move on to the character AI that will follow their path towards the enemy base. We can choose to duplicate the code for each team or integrate everything inside the same code, using <kbd>if</kbd> statements to decide which path the character should follow. For this example, we have chosen to integrate everything in the same code. That way, we can update the character code once and it will work for both teams at the same time. Once again, we can start by using the same code that we used in the enemies from the Tower Defense game. We can change the code so he will fit in the game that we are currently creating:</p>
<pre> public float speed;<br/> public int health;<br/> public float speedTurn;<br/><br/> private Transform target;<br/> private int wavepointIndex = 0;<br/><br/><br/> void Start ()<br/> {<br/>      target = waypoints.points[0];<br/>      speed = 10f;<br/>      speedTurn = 0.2f;<br/> }<br/><br/> void Update ()<br/> {<br/>      Vector3 dir = target.position - transform.position;<br/>      transform.Translate(dir.normalized * speed * Time.deltaTime, <br/>         Space.World);<br/><br/>      if(Vector3.Distance(transform.position, target.position) &lt;= 0.4f)<br/>      {<br/>          GetNextWaypoint();<br/>      }<br/><br/>      Vector3 newDir = Vector3.RotateTowards(transform.forward, dir, <br/>         speedTurn, 0.0F);<br/><br/>      transform.rotation = Quaternion.LookRotation(newDir);<br/> }<br/><br/> void GetNextWaypoint()<br/> {<br/>      if(wavepointIndex &gt;= waypoints.points.Length - 1)<br/>      {<br/>          Destroy(gameObject);<br/>          return;<br/>      }<br/><br/>      wavepointIndex++;<br/>      target = waypoints.points[wavepointIndex];<br/> } </pre>
<p>With this code, we can make the character follow the path and turn smoothly when changing from one point to another. At this point we just need to change the code to make him fit the game genre that we are creating. To do that the first thing we need to consider is changing the name points to the names that we've previously created, and add <kbd>if</kbd> statements to choose which side the character needs to follow.</p>
<p>Let's start by adding the information that distinguish the characters of one team from another. To do that, we need to create two new Boolean variables:</p>
<pre> public bool Team1;<br/> public bool Team2;</pre>
<p class="NormalPACKT">This will let us decide if the character is from Team1 or Team2, both cannot be true at the same time. Now we can implement more details into the character code, to let him know which lane he should walk on:</p>
<pre> public bool Top;<br/> public bool Middle; 
 public bool Bottom; </pre>
<p>We have added three more Booleans that will indicate the lane that the character needs to follow. After working out which team the character is spawning from, another <kbd>if</kbd> statement will be added to determine the lane that the character will follow.</p>
<p>Once we have added those variables, we need to assign the waypoint groups that we created before according to the lane that the character will follow. We can implement that right in the <kbd>start</kbd> function:</p>
<pre>if(Team1 == true)<br/> {<br/>          if(Top == true)<br/>          {<br/>              target = 1_Top.1_Top[0];<br/>          }<br/><br/>          if(Middle == true)<br/>          {<br/>              target = 1_Middle.1_Middle[0];<br/>          }<br/><br/>          if(Bottom == true)<br/>          {<br/>             target = 1_Bottom.1_Top[0];<br/>          }<br/> }<br/><br/> if(Team2 == true)<br/> {<br/>          if(Top == true)<br/>          {<br/>             target = 2_Top.2_Top[0];<br/>          }<br/><br/>          if(Middle == true)<br/>          {<br/>              target = 2_Middle.2_Middle[0];<br/>          }<br/><br/>          if(Bottom == true)<br/>          {<br/>              target = 2_Bottom.2_Top[0];<br/>          }<br/> } </pre>
<p>This allows the character to question the team that it is representing, the lane where it spawned, and the path that he will follow. We need to adjust the rest of the code so it will work for this example. The next modification will be in the <kbd>GetNextWaypoint()</kbd> function. We need to add the <kbd>if</kbd> statements to let the character know the correct next waypoint that he needs to follow, similar to what we did in the <kbd>Start</kbd> function:</p>
<pre>void GetNextWaypoint()<br/>{<br/>    if(Team1 == true)<br/>    {<br/>       if(Top == true)<br/>       {<br/>          if(wavepointIndex &gt;= 1_Top.1_Top.Length - 1)<br/>          {<br/>             Destroy(gameObject);<br/>              return;<br/>           }<br/><br/>           wavepointIndex++;<br/>           target = 1_Top.1_Top[wavepointIndex];<br/>         }<br/><br/>         if(Middle == true)<br/>         {<br/>            if(wavepointIndex &gt;= 1_Middle.1_Middle.Length - 1)<br/>            {<br/>               Destroy(gameObject);<br/>               return;<br/>             }<br/><br/>             wavepointIndex++;<br/>             target = 1_Middle.1_Middle[wavepointIndex];<br/>           }<br/><br/>           if(Bottom == true)<br/>           {<br/>              if(wavepointIndex &gt;= 1_Bottom.1_Bottom.Length - 1)<br/>              {<br/>                 Destroy(gameObject);<br/>                 return;<br/>               }<br/><br/>               wavepointIndex++;<br/>               target = 1_Bottom.1_Bottom[wavepointIndex];<br/>           }<br/>       }<br/><br/>       if(Team2 == true)<br/>       {<br/>         if(Top == true)<br/>         {<br/>            if(wavepointIndex &gt;= 2_Top.2_Top.Length - 1)<br/>            {<br/>                Destroy(gameObject);<br/>                return;<br/>             }<br/><br/>             wavepointIndex++;<br/>             target = 2_Top.2_Top[wavepointIndex];<br/>           }<br/><br/>           if(Middle == true)<br/>           {<br/>              if(wavepointIndex &gt;= 2_Middle.2_Middle.Length - 1)<br/>              {<br/>                 Destroy(gameObject);<br/>                 return;<br/>               }<br/><br/>               wavepointIndex++;<br/>               target = 2_Middle.2_Middle[wavepointIndex];<br/>            }<br/><br/>            if(Bottom == true)<br/>            {<br/>               if(wavepointIndex &gt;= 2_Bottom.2_Bottom.Length - 1)<br/>               {<br/>                 Destroy(gameObject);<br/>                 return;<br/>               }<br/><br/>               wavepointIndex++;<br/>               target = 2_Bottom.2_Bottom[wavepointIndex];<br/>             }<br/>         }<br/>     }  </pre>
<p>At this point, if we add a character to the game and assign it the AI code, it will follow the chosen path:</p>
</div>
<div><img height="293" width="521" class=" image-border" src="img/4be59aba-e3d4-40d2-b4ed-ae187f2fe767.png"/></div>
<div><p>It is working properly, and we are ready to implement more features to create the perfect platoon that follows a path toward the enemy tower and that stops to fight the other platoon or the hero. Any details or uniqueness that we want to add to our platoon can be applied now that we have the basic movement working. Here, we have attached the complete code for the platoon AI character:</p>
<pre>  public float speed;<br/>  public int health;<br/>  public float speedTurn;<br/><br/>  public bool Team1;<br/>  public bool Team2;<br/><br/>  public bool Top;<br/>  public bool Middle;<br/>  public bool Bottom;<br/><br/>  private Transform target;<br/>  private int wavepointIndex = 0;</pre>
<p class="mce-root">After updating the variables in the preceding code we can move on to the <kbd>Start</kbd> method that will be called on the first frame:</p>
<pre>  void Start ()<br/>  {<br/>     if(Team1 == true)<br/>     {<br/>        if(Top == true)<br/>        {<br/>            target = 1_Top.1_Top[0];<br/>         }<br/><br/>         if(Middle == true)<br/>         {<br/>              target = 1_Middle.1_Middle[0];<br/>          }<br/><br/>          if(Bottom == true)<br/>          {<br/>              target = 1_Bottom.1_Top[0];<br/>          }<br/>      }<br/><br/>      if(Team2 == true)<br/>      {<br/>          if(Top == true)<br/>          {<br/>             target = 2_Top.2_Top[0];<br/>           }<br/><br/>          if(Middle == true)<br/>          {<br/>             target = 2_Middle.2_Middle[0];<br/>          }<br/><br/>           if(Bottom == true)<br/>           {<br/>               target = 2_Bottom.2_Top[0];<br/>            }<br/>    }<br/>    speed = 10f;<br/>    speedTurn = 0.2f;<br/>  }</pre>
<p class="mce-root">Here is the <kbd>Update</kbd> method that will be called every frame of the game:</p>
<p>Â </p>
<pre>  void Update ()<br/>  {<br/>     Vector3 dir = target.position - transform.position;<br/>     transform.Translate(dir.normalized * speed * Time.deltaTime, <br/>        Space.World);<br/><br/>     if(Vector3.Distance(transform.position, target.position) &lt;= 0.4f)<br/>     {<br/>         GetNextWaypoint();<br/>     }<br/><br/>     Vector3 newDir = Vector3.RotateTowards(transform.forward, dir, <br/>        speedTurn, 0.0F);<br/><br/>     transform.rotation = Quaternion.LookRotation(newDir);<br/>  }<br/><br/>  void GetNextWaypoint()<br/>  {<br/>      if(Team1 == true)<br/>      {<br/>        if(Top == true)<br/>        {<br/>          if(wavepointIndex &gt;= 1_Top.1_Top.Length - 1)<br/>          {<br/>            Destroy(gameObject);<br/>            return;<br/>          }<br/><br/>          wavepointIndex++;<br/>          target = 1_Top.1_Top[wavepointIndex];<br/>        }<br/><br/>        if(Middle == true)<br/>        {<br/>          if(wavepointIndex &gt;= 1_Middle.1_Middle.Length - 1)<br/>          {<br/>             Destroy(gameObject);<br/>             return;<br/>           }<br/><br/>           wavepointIndex++;<br/>           target = 1_Middle.1_Middle[wavepointIndex];<br/>        }<br/><br/>        if(Bottom == true)<br/>        {<br/>           if(wavepointIndex &gt;= 1_Bottom.1_Bottom.Length - 1)<br/>           {<br/>                Destroy(gameObject);<br/>                return;<br/>            }<br/><br/>            wavepointIndex++;<br/>            target = 1_Bottom.1_Bottom[wavepointIndex];<br/>        }<br/>      }<br/><br/>      if(Team2 == true)<br/>      {<br/>         if(Top == true)<br/>         {<br/>           if(wavepointIndex &gt;= 2_Top.2_Top.Length - 1)<br/>           {<br/>                Destroy(gameObject);<br/>                return;<br/>            }<br/><br/>             wavepointIndex++;<br/>             target = 2_Top.2_Top[wavepointIndex];<br/>          }<br/><br/>          if(Middle == true)<br/>          {<br/>             if(wavepointIndex &gt;= 2_Middle.2_Middle.Length - 1)<br/>             {<br/>                Destroy(gameObject);<br/>                return;<br/>              }<br/><br/>              wavepointIndex++;<br/>              target = 2_Middle.2_Middle[wavepointIndex];<br/>            }<br/><br/>            if(Bottom == true)<br/>            {<br/>              if(wavepointIndex &gt;= 2_Bottom.2_Bottom.Length - 1)<br/>              {<br/>                 Destroy(gameObject);<br/>                 return;<br/>               }<br/><br/>               wavepointIndex++;<br/>               target = 2_Bottom.2_Bottom[wavepointIndex];<br/>             }<br/>         }<br/>     }  </pre>
<p>Another important aspect of a MOBA game is the hero's movement. Even if it's controlled by the player, the character has AI to determine the path that he needs to follow in order to arrive at the chosen destination. To complete this task, we will introduce the point to point method first; then we will continue the same example but using an advanced method that will make our character decide the best path to arrive at the final destination without implementing any waypoints.</p>
<p>This example will also serve as an example of how to create a character that follows the player. To do this, we need to set all the possible paths that the character is allowed follow. We want the AI to avoid colliding with objects or passing through walls, for example:</p>
<p><img class=" image-border" src="img/03647230-0824-4d25-8e17-fc604ca2b630.png"/></p>
</div>
<div><p>Let's focus on this area of the map. As we can see, there are walls and trees blocking a portion of the map, and the characters should not be allowed to pass through them. Using the waypoints method, we will create points on the map that the character should follow if he wants to reach a certain destination. he won't have any specific order like the previous examples that we have created, because the character can move in any direction, and for that reason we cannot predict the path that it will choose.</p>
<p>We start by positioning the waypoints on the walkable positions. This will prevent the character from moving on the non-walkable area:</p>
<p><img class="image-border" src="img/d1894131-e2ba-4822-8573-2cc0a0ae09d0.jpg"/></p>
</div>
<div><p>The stars that we see on the map represent the waypoints that we have created, so we should only place them in the areas that the character is able to walk in. If the character wants to move from one position to another, it must follow the waypoints until it gets to the closest waypoint to the desired destination.</p>
<p>In the gameplay mechanics, we can choose why the character needs to reach a certain destination, such as following the player, going to the base to recover health points, moving towards the enemy wall to destroy it, and many others choices. Independently of what the character AI needs to achieve, it needs to move correctly on the map, and this waypoints system will work in any circumstance.</p>
<p>Here we can find the full code that will make this work. Then we'll explain everything in detail to better understand how to replicate this code so it can work in a different game genre:</p>
<pre>  public float speed;<br/>  private List &lt;GameObject&gt; wayPointsList;<br/>  private Transform target;<br/>  private GameObject[] wayPoints;<br/><br/>  void Start ()<br/>  {<br/><br/>      target = GameObject.FindGameObjectWithTag("target").transform;<br/>      wayPointsList = new List&lt;GameObject&gt;();<br/><br/>      wayPoints = GameObject.FindGameObjectsWithTag("wayPoint");<br/><br/>      for each(GameObject newWayPoint in wayPoints)<br/>      {<br/>         wayPointsList.Add(newWayPoint);<br/>       }<br/>   }<br/><br/>   void Update ()<br/>   {<br/>      Follow();<br/>   }<br/><br/>   void Follow () <br/>   {<br/>      GameObject wayPoint = null;<br/><br/>      if (Physics.Linecast(transform.position, target.position))<br/>      {<br/>         wayPoint = findBestPath();<br/>       }<br/><br/>       else<br/>       {<br/>          wayPoint = GameObject.FindGameObjectWithTag("target");  <br/>        }<br/><br/>        Vector3 Dir = (wayPoint.transform.position - <br/>                transform.position).normalized;<br/>        transform.position += Dir * Time.deltaTime * speed;<br/>        transform.rotation = Quaternion.LookRotation(Dir);<br/>     }<br/><br/>     GameObject findBestPath()<br/>     {<br/>         GameObject bestPath = null;<br/>         float distanceToBestPath = Mathf.Infinity;<br/><br/>         for each(GameObject go in wayPointsList)<br/>         {<br/>            float distToWayPoint = Vector3.<br/>               Distance(transform.position, go.transform.position);<br/>            float distWayPointToTarget = Vector3.<br/>               Distance(go.transform.position, <br/>               target.transform.position);<br/>            float distToTarget = Vector3.<br/>               Distance(transform.position, target.position);<br/>            bool wallBetween = Physics.Linecast<br/>               (transform.position, go.transform.position);<br/><br/>            if((distToWayPoint &lt; distanceToBestPath) <br/>                &amp;&amp; (distToTarget &gt; distWayPointToTarget) <br/>                    &amp;&amp;  (!wallBetween))<br/>             {<br/>                 distanceToBestPath = distToWayPoint;<br/>                 bestPath = go;<br/>             }<br/><br/>             else<br/>             {<br/>                 bool wayPointToTargetCollision = Physics.Linecast<br/>                    (go.transform.position, target.position);<br/>                 if(!wayPointToTargetCollision)<br/>                 {<br/>                      bestPath = go;        <br/>                  }    <br/>             }<br/>         }<br/>         return bestPath;<br/>     } </pre>
<p>If we assign this code into our character and hit the play button, we can test the game and see that what we have created works perfectly. The character should use the waypoint positions to move across the map to reach the desired destination. This method can be used for NPC characters and playable characters as well, because for both cases the characters need to avoid colliding with the wall and obstacles:</p>
<p><img class="image-border" src="img/e9c1db85-e8e7-4e57-b927-b52fb4e025b8.jpg"/></p>
</div>
<div><p>If we continue the example and expand the waypoints across the whole map, we have a basic MOBA game working properly, with a platoon of monsters spawning at each base and following the right path, and hero characters that can move freely on the map without colliding with walls.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Point to point movement and avoiding dynamic objects</h1>
                
            
            
                
<p>Now that we have characters that can follow the right path and avoid static objects, we are ready to move on to the next level and make those characters avoid dynamic objects while moving from point to point. We will revise the three different examples created in this chapter and see how we can add the avoiding technique to the AI characters in those examples.</p>
<p>Those three methods should cover almost every game genre that uses point to point movement as their primary method of locomotion, and we will be able to create new ideas with these examples as a guideline:</p>
<div><img height="264" width="472" class="image-border" src="img/20bf6ea9-cf58-48ad-a4a4-0ff9999b85eb.jpg"/></div>
<div><p>Let's start with the racing game, where we have a car that drives around the track until he finishes the race. If the car drives alone and there's nothing obstructing the path, it won't be necessary to avoid any obstacles, but usually obstacles make the game more interesting or challenging, especially when they are spontaneous and we don't expect them. A great example of this is the Mario Kart game, where they throw bananas and other objects to destabilize the opposing players, and the objects don't have any pre-defined position so the characters can't predict where they're going to be. So it is important for the drivers to have the necessary functions to avoid colliding with those objects and be able to do that in real time.</p>
<p>Assuming that two objects appeared unexpectedly on the road while the AI character was following the next waypoint, we want the character to anticipate the collision and turn around to avoid crashing against the object. The method that we will be using here is a combination of the waypoint movement with the maze movement. The character can only obey one order at a time, he can either respect the waypoint movement or the maze movement, and that's exactly what we need to add on to our code so the character AI can choose the best option according the current situation that he is facing:</p>
<pre>  public static bool raceStarted = false;<br/><br/>  public float aiSpeed = 10.0f;<br/>  public float aiTurnSpeed = 2.0f;<br/>  public float resetAISpeed = 0.0f;<br/>  public float resetAITurnSpeed = 0.0f;<br/><br/>  public GameObject waypointController;<br/>  public List&lt;Transform&gt; waypoints;<br/>  public int currentWaypoint = 0;<br/>  public float currentSpeed;<br/>  public Vector3 currentWaypointPosition;<br/><br/>  public static bool isBlocked;<br/>  public static bool isBlockedFront;<br/>  public static bool isBlockedRight;<br/>  public static bool isBlockedLeft;</pre>
<p class="mce-root">After updating the preceding variables, we can move on to the <kbd>Start</kbd> method. This will be called in the first frame:</p>
<pre>   void Start () <br/>   {<br/>         GetWaypoints();<br/>         resetAISpeed = aiSpeed;<br/>         resetAITurnSpeed = aiTurnSpeed;<br/>    }<br/><br/></pre>
<p class="mce-root">Here is the <kbd>Update</kbd> method that will be called every frame of the game:</p>
<pre>   void Update () <br/>    {<br/>       if(raceStarted &amp;&amp; isBlocked == false)<br/>       {<br/>          MoveTowardWaypoints();    <br/>        }<br/><br/>       if(raceStarted &amp;&amp; isBlockedFront == true <br/>           &amp;&amp; isBlockedLeft == false &amp;&amp; isBlockedRight == false)<br/>        {<br/>            TurnRight();<br/>        }<br/><br/>        if(raceStarted &amp;&amp; isBlockedFront == false<br/>             &amp;&amp; isBlockedLeft == true &amp;&amp; isBlockedRight == false)<br/>        {<br/>             TurnRight();<br/>        }<br/><br/>        if(raceStarted &amp;&amp; isBlockedFront == false <br/>              &amp;&amp; isBlockedLeft == false &amp;&amp; isBlockedRight == true)<br/>        {<br/>             TurnLeft();<br/>        }<br/>     }<br/><br/>     void GetWaypoints()<br/>      {<br/>            Transform[] potentialWaypoints = waypointController.<br/>                GetComponentsInChildren&lt;Transform&gt;();<br/><br/>            waypoints = new List&lt;Transform&gt;();<br/><br/>            for each(Transform potentialWaypoint in potentialWaypoints)<br/>             {<br/>                 if(potentialWaypoint != waypointController.transform)<br/>                 {<br/>                      waypoints.Add(potentialWaypoint);    <br/>                  }<br/>              }<br/>     }<br/><br/>     void MoveTowardWaypoints()<br/>     {<br/>        float currentWaypointX = waypoints[currentWaypoint].position.x;<br/>        float currentWaypointY = transform.position.y;<br/>        float currentWaypointZ = waypoints[currentWaypoint].position.z;<br/><br/>        Vector3 relativeWaypointPosition = transform.<br/>           InverseTransformPoint (new Vector3(currentWaypointX, <br/>           currentWaypointY, currentWaypointZ));<br/>        currentWaypointPosition = new Vector3(currentWaypointX, <br/>           currentWaypointY, currentWaypointZ);<br/><br/>        Quaternion toRotation = Quaternion.<br/>           LookRotation(currentWaypointPosition - transform.position);<br/>        transform.rotation = Quaternion.<br/>           RotateTowards(transform.rotation, toRotation, aiTurnSpeed);<br/><br/>         GetComponent&lt;Rigidbody&gt;().AddRelativeForce(0, 0, aiSpeed);<br/><br/>         if(relativeWaypointPosition.sqrMagnitude &lt; 15.0f)<br/>         {<br/>               currentWaypoint++;<br/><br/>               if(currentWaypoint &gt;= waypoints.Count)<br/>               {<br/>                        currentWaypoint = 0;    <br/>                }<br/>           }<br/><br/>           currentSpeed = Mathf.Abs(transform.<br/>               InverseTransformDirection(GetComponent&lt;Rigidbody&gt;().<br/>               velocity).z);<br/><br/>           float maxAngularDrag = 2.5f;<br/>           float currentAngularDrag = 1.0f;<br/>           float aDragLerpTime = currentSpeed * 0.1f;<br/><br/>           float maxDrag = 1.0f;<br/>           float currentDrag = 3.5f;<br/>           float dragLerpTime = currentSpeed * 0.1f;<br/><br/>           float myAngularDrag = Mathf.Lerp(currentAngularDrag, <br/>                 maxAngularDrag, aDragLerpTime);<br/>           float myDrag = Mathf.Lerp(currentDrag, maxDrag, <br/>                 dragLerpTime);<br/><br/>           GetComponent&lt;Rigidbody&gt;().angularDrag = myAngularDrag;<br/>           GetComponent&lt;Rigidbody&gt;().drag = myDrag;<br/>     }<br/><br/>     void TurnLeft()<br/>     {<br/>         //turning left function here<br/>     }<br/><br/>     void TurnRight()<br/>     {<br/>         //turning right function here<br/>     } </pre>
<p>We have added four new static variables to our code: <kbd>isBlocked</kbd>, <kbd>isBlockedFront</kbd>, <kbd>isBlockedRight</kbd>, and <kbd>isBlockedLeft</kbd>. This will check if the path in front of the car is free from obstacles or not. The car will continue following the waypoint path until something appears and the car needs to turn left or right to pass the obstacle. To make this work, we need to add at least three sensors in front of the car. When they interact with some object, the sensor gives that information to the AI driver, and at this point it will choose the best option according to that information:</p>
</div>
<div><img height="278" width="496" class="image-border" src="img/531474be-12b7-41b5-b7be-e0927c7c62d1.jpg"/></div>
<div><p>As we can see in the preceding image, the car now has three sensors attached to it. In this example, the right sensor will report that it is blocked by an obstacle and the driver will turn left until that side is free again. Once the three sensors report that nothing is obstructing the driver's path, the car will return to following the waypoint that it was previously moving towards. If we notice that the driver doesn't recognize some obstacles, it is recommended to increase the number of sensors to cover a larger area.</p>
<p>Now let's move on to the platoon characters that we created for the MOBA example. Here, we will need to create a different method, because the characters will move towards the next waypoint until they find something, but this time we don't want them to move away. Instead, we want the character to move towards the character that they have found.</p>
</div>
<div><img height="260" width="464" class="image-border" src="img/1b05980d-03bd-42d0-bf1c-52706cf2b4e2.jpg"/></div>
<div><p>To create this, we will add a circular or spherical collider to our character. This will serve as detection. If something triggers that zone, the character will stop moving towards its waypoint and use the position of the hero that triggered the collider as a waypoint to pursue:</p>
<pre>  public float speed; 
  public int health; 
  public float speedTurn; 
 
  public bool Team1; 
  public bool Team2; 
    
  public bool Top; 
  public bool Middle; 
  public bool Bottom; 
 
  private Transform target; 
  private int wavepointIndex = 0; 
 
  static Transform heroTarget; 
  static bool heroTriggered; 
 
 </pre>
<p class="CodePACKT">After updating the preceding variables, we can move on to the <kbd>Start</kbd> method, which will be called on the first frame:</p>
<pre>   void Start () 
   { 
         if(Team1 == true) 
         { 
            if(Top == true) 
            { 
                  target = 1_Top.1_Top[0]; 
             } 
 
              if(Middle == true) 
              { 
                    target = 1_Middle.1_Middle[0]; 
              } 
 
               if(Bottom == true) 
               { 
                   target = 1_Bottom.1_Top[0]; 
                } 
         } 
 
          if(Team2 == true) 
          { 
            if(Top == true) 
            { 
              target = 2_Top.2_Top[0]; 
            } 
 
             if(Middle == true) 
             { 
                target = 2_Middle.2_Middle[0]; 
             } 
 
              if(Bottom == true) 
              { 
                  target = 2_Bottom.2_Top[0]; 
               } 
          } 
          speed = 10f; 
          speedTurn = 0.2f; 
        } 
                 </pre>
<p class="CodePACKT">Here is the <kbd>Update</kbd> method that will be called every frame of the game:</p>
<pre>        void Update () 
        { 
           Vector3 dir = target.position - transform.position; 
           transform.Translate(dir.normalized * speed * Time.deltaTime, <br/>              Space.World); 
 
           if(Vector3.Distance(transform.position, target.position) &lt;=<br/>                 0.4f &amp;&amp; heroTriggered == false) 
            { 
                GetNextWaypoint(); 
             } 
 
             if(heroTriggered == true) 
             { 
                  GetHeroWaypoint(); 
              } 
 
              Vector3 newDir = Vector3.RotateTowards(transform.<br/>                     forward, dir, speedTurn, 0.0F); 
 
              transform.rotation = Quaternion.LookRotation(newDir); 
        } 
 </pre>
<p class="CodePACKT">This <kbd>GetNextWaypoint</kbd> method is used to gather the information regarding the next waypoint that the character needs to follow:</p>
<pre>        void GetNextWaypoint() 
        { 
           if(Team1 == true) 
           { 
              if(Top == true) 
              { 
                 if(wavepointIndex &gt;= 1_Top.1_Top.Length - 1) 
                 { 
                      Destroy(gameObject); 
                      return; 
                  } 
 
                  wavepointIndex++; 
                  target = 1_Top.1_Top[wavepointIndex]; 
                } 
 
                if(Middle == true) 
                { 
                  if(wavepointIndex &gt;= 1_Middle.1_Middle.Length - 1) 
                  { 
                    Destroy(gameObject); 
                    return; 
                   } 
 
                   wavepointIndex++; 
                   target = 1_Middle.1_Middle[wavepointIndex]; 
                } 
 
                if(Bottom == true) 
                { 
                   if(wavepointIndex &gt;= 1_Bottom.1_Bottom.Length - 1) 
                   { 
                      Destroy(gameObject); 
                      return; 
                   } 
 
                    wavepointIndex++; 
                    target = 1_Bottom.1_Bottom[wavepointIndex]; 
                  } 
            } 
 
            if(Team2 == true) 
            { 
               if(Top == true) 
               { 
                  if(wavepointIndex &gt;= 2_Top.2_Top.Length - 1) 
                  { 
                     Destroy(gameObject); 
                     return; 
                  } 
 
                  wavepointIndex++; 
                  target = 2_Top.2_Top[wavepointIndex]; 
                } 
 
                if(Middle == true) 
                { 
                    if(wavepointIndex &gt;= 2_Middle.2_Middle.Length - 1) 
                    { 
                       Destroy(gameObject); 
                       return; 
                     } 
 
                     wavepointIndex++; 
                     target = 2_Middle.2_Middle[wavepointIndex]; 
                  } 
 
                  if(Bottom == true) 
                  { 
                     if(wavepointIndex &gt;= 2_Bottom.2_Bottom.Length - 1) 
                      { 
                         Destroy(gameObject); 
                         return; 
                       } 
 
                       wavepointIndex++; 
                       target = 2_Bottom.2_Bottom[wavepointIndex]; 
                    } 
               } 
    }
 </pre>
<p class="CodePACKT">In the <kbd>GetHeroWaypoint</kbd> method, we set what happens when the character needs to follow the Hero direction, like attacking or any other function:</p>
<pre>    void GetHeroWaypoint() 
    { 
        target = heroTarget.transform; 
    } </pre>
<p>We've added a spherical collider to the character that gives the trigger information to the character, to know if a hero character has entered that zone. If no hero triggered that zone, the character will continue following the waypoint, otherwise it will focus his attention to the hero and use him as a target point.</p>
<p>With this example we learned the core features of the artificial intelligence movement that can be found in a MOBA game and now we can re-create this popular game genre. From this chapter onwards we can create simple to complex navigation systems and use them to make our AI character more active in the game, constantly pursuing an objective even if that objective is moving.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have introduced point to point movement, a method that is widely used in many games today, and we can adapt the codes that we have created to work in practically any game. At this point ,we are able to re-create many popular games and add our personal touch to them. In the next chapter, we'll continue talking about movement, but we will be focusing on an advanced aspect called the Theta algorithm. This will serve as a continuation of what we have learned in this chapter, and we will be able to create a character AI that, without any previous information or positions, will be able to find for itself the best path to follow in order to arrive at a certain destination.</p>


            

            
        
    </body></html>