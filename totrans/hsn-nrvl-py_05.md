# 使用NEAT进行XOR求解器优化

在本章中，您将了解一个经典的计算机科学实验，该实验证明了NEAT算法的有效性，并能创建合适的网络拓扑。在本章中，您将亲身体验编写一个目标函数来指导XOR问题求解器。您还将学习如何选择NEAT算法的正确超参数以帮助解决XOR问题。本章旨在向您介绍如何将NEAT算法应用于解决经典计算机科学问题的基本技术。

完成本章描述的实验和练习后，您将对XOR实验的细节有一个扎实的理解，并获得使用NEAT-Python库编写相关Python源代码所需的实际技能。您还将获得设置NEAT-Python库的超参数和使用可视化工具可视化实验结果的经验。之后，您将准备好开始尝试本书后面将要讨论的更复杂的问题。

在本章中，我们将涵盖以下主题：

+   XOR问题基础

+   如何定义目标函数来指导XOR问题求解器

+   XOR实验的超参数选择

+   运行XOR实验

# 技术要求

为了执行本章描述的实验，应满足以下技术要求：

+   Windows 8/10，macOS 10.13或更高版本，或现代Linux

+   Anaconda Distribution版本2019.03或更高版本

本章的代码可以在[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter3)找到。

# XOR问题基础

在其拓扑中没有任何*隐藏单元*的经典**多层感知器**（**MLP**）或**人工神经网络**（**ANN**）只能正确解决线性可分问题。因此，这种ANN配置不能用于模式识别或控制和`优化`任务。然而，具有一些具有某种非线性激活函数（如sigmoid）的更复杂的MLP架构，可以近似任何函数到给定的精度。因此，非线性可分问题可以用来研究神经进化过程是否可以在求解器表型的ANN中增长任意数量的隐藏单元。

XOR问题求解器是强化学习领域的一个经典计算机科学实验，如果不引入非线性行为到求解器算法中，是无法解决的。该问题的解决方案搜索空间具有最小尺寸，可以用来证明NEAT算法可以从一个非常简单的ANN拓扑结构开始进化，逐渐增加复杂性，找到所有连接都正确布线的适当网络结构。通过展示NEAT算法能够持续地生长适当的拓扑结构，XOR实验也证明了NEAT可以避免适应度值景观中的局部最大值。局部最大值是一个陷阱，求解器可能会陷入其中，产生一个具有错误连接模式的局部冠军。之后，一个局部冠军可能会在种群中占据主导地位，以至于求解器无法解决问题。

下面是一个定义XOR特征的表格：

| **输入1** | **输入2** | **输出** |
| --- | --- | --- |
| 1 | 1 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 0 | 0 | 0 |

XOR是一个二进制逻辑运算符，只有当两个输入中只有一个为真时才返回true。两个输入信号必须通过非线性隐藏单元组合，以产生正确的输出信号。没有线性函数能够正确地将XOR输入组合并分离到它们正确的类别中。

NEAT算法从初始种群开始，该种群编码了一个非常简单的表型，并逐渐进化表型的拓扑结构，直到创建一个合适的ANN。表型ANN的初始结构不包含任何隐藏单元，由两个输入单元、一个输出单元和一个偏置单元组成。两个输入节点和偏置节点连接到输出节点，即初始基因型有三个连接基因和四个节点基因。偏置单元是一种特殊的输入，它始终初始化为大于0的特定值（通常为1.0或0.5）。如果我们希望将神经元单元（输出或隐藏）的激活（通过应用于输入和偏置的总和的相关激活函数计算得出）设置为特定的非零值，那么偏置单元是必要的——如果两个输入的值都是0。

以下图表显示了初始和可能的最小XOR表型：

![](img/86915bea-fd14-4a1b-968f-0196f113782b.png)

初始和最优的XOR表型

表型的人工神经网络（ANN）变得越来越复杂，直到通过包含一个或多个额外的隐藏节点找到最终解决方案。可能的最小求解器只包含一个隐藏节点，NEAT方法通过在更复杂的配置中找到最优求解器配置来展示其能力。

# XOR实验的目标函数

在 XOR 实验中，种群中生物体的适应度定义为正确答案与为所有四个 XOR 输入模式生成的输出总和之间的平方距离。它按以下方式计算：

1.  表型人工神经网络针对所有四个 XOR 输入模式进行激活。

1.  将输出值从每个模式的正确答案中减去，然后将结果的绝对值相加。

1.  在前一步找到的错误值从最大适应度值（*4*）中减去，以计算生物体的适应度。最高的适应度值意味着更好的求解器性能。

1.  计算出的适应度值然后平方，以给生物体提供更多比例的适应度，从而产生给出更接近正确答案的求解器人工神经网络。这种方法使进化压力更加激烈。

因此，目标函数可以定义为以下：

![](img/5e576dee-454e-4fd3-8690-df4ec58c4f68.png)

基于 NEAT-Python 库的相应 Python 源代码如下：

[PRE0]

注意，没有必要将适应度值归一化以适应 `[0,1]` 范围（如基于反向传播的方法那样），因为在训练过程中没有涉及反向梯度计算。生物体的适应度评分直接根据它们的绝对值进行比较。因此，值的范围无关紧要。

您还可以尝试不同的适应度评分计算方法的不同变体。例如，您可以实现一个类似于均方误差的函数，并比较算法针对不同目标函数实现的性能。唯一的要求是目标函数应该为更好的求解器产生更高的适应度评分。

# 超参数选择

本章我们将讨论的 XOR 实验使用 NEAT-Python 库作为框架。NEAT-Python 库定义了一组超参数，这些参数用于控制 NEAT 算法的执行和性能。配置文件存储的格式类似于 Windows .INI 文件；每个部分以方括号内的名称（[*部分*]）开始，后跟由等号（*=*）分隔的键值对。

在本节中，我们将讨论 NEAT-Python 库中的一些超参数，这些参数可以在配置文件的每个部分中找到。

NEAT-Python 库中所有超参数的完整列表可以在 [https://neat-python.readthedocs.io/en/latest/config_file.html](https://neat-python.readthedocs.io/en/latest/config_file.html) 找到。

# NEAT 部分

本节指定了特定于 NEAT 算法的参数。本节包括以下参数：

+   `fitness_criterion`: 从种群中所有基因组的适应度值集中计算终止标准的函数。参数值是标准聚合函数的名称，例如min、max和mean。min和max值用于在种群的最小或最大适应度超过给定的`fitness_threshold`时终止进化过程。当值设置为mean时，种群的平均适应度用作终止标准。

+   `fitness_threshold`: 与适应度比较的阈值值，由`fitness_criterion`函数计算，以测试是否必须终止进化。

+   `no_fitness_termination`: 定义了由前面的参数定义的基于适应度的进化过程终止的标志。当设置为`True`时，进化过程只有在评估了最大代数后才会终止。

+   `pop_size`: 每一代中个体的数量。

+   `reset_on_extinction`: 当由于停滞导致当前代的所有物种灭绝时，控制是否创建新的随机种群的一个标志。如果设置为`False`，在完全灭绝时将抛出`CompleteExtinctionException`异常。

# DefaultStagnation部分

此部分定义了由`DefaultStagnation`类实现的特定于物种停滞例程的参数。此部分包括以下参数：

+   `species_fitness_func`: 用于计算物种适应度的函数名称，即计算属于特定物种的所有生物的聚合适应度值。允许的值是max、min和mean。

+   `max_stagnation`: 在超过`max_stagnation`代数内没有显示出由`species_fitness_func`计算的适应度值提升的物种被认为是停滞的，并可能面临灭绝。

+   `species_elitism`: 无条件保护免受停滞影响的物种数量。其目的是防止在出现新物种之前种群完全灭绝。在种群中，具有最高适应度的指定数量的物种总是能够存活下来，尽管它们没有显示出进一步的适应度提升。

# DefaultReproduction部分

此部分提供了由内置`DefaultReproduction`类实现的繁殖例程的配置。此部分包括以下参数：

+   `elitism`: 每个物种中最适应的个体数量，这些个体在下一代中无变化地复制。这个因素使我们能够保留在上一代中发现的任何有益突变。

+   `survival_threshold`: 每个物种中允许成为下一代父母（即有资格进行有性繁殖[*交叉*]）的有机体比例。通过调整此值，可以定义允许参与繁殖过程的有机体的最低适应度分数。这是因为`survival_threshold`比例是从按适应度降序排列的有机体列表中取出的。

+   `min_species_size`: 繁殖周期后每个物种中保留的有机体最小数量。

# DefaultSpeciesSet部分

本节提供了由内置`DefaultSpeciesSet`类实现的物种形成过程的配置，包括以下参数：

+   `compatibility_threshold`: 控制有机体属于同一物种（基因组距离小于此值）还是不同物种的阈值。较高值意味着进化过程具有较少的物种形成能力。

# DefaultGenome部分

本节定义了用于创建和维护基因组（由`DefaultGenome`类实现）的配置参数。本节包括以下参数：

+   `activation_default`: 用于节点基因中使用的激活函数的名称。

+   `activation_mutate_rate`: 如果基因组支持多个激活函数（例如对于CPPN基因组），则这是突变替换当前节点激活函数为从支持函数列表中取出的新函数的概率（参见`activation_options`）。

+   `activation_options`: 可以由节点基因使用的激活函数的空间分隔列表。

+   `aggregation_default`: 网络节点在激活之前用于从其他节点接收到的任何聚合输入信号的默认聚合函数的名称。

+   `aggregation_mutate_rate`: 如果基因组支持多个聚合函数，则此参数定义了突变替换当前节点聚合函数为聚合函数列表中的新函数的概率（参见`aggregation_options`）。

+   `aggregation_options`: 可以由节点基因使用的聚合函数的空间分隔列表。支持值包括sum（求和）、min（最小值）、max（最大值）、mean（平均值）、median（中位数）和maxabs（最大绝对值）。

+   `compatibility_threshold`: 控制有机体属于同一物种（基因组距离小于此值）还是不同物种的阈值。较高值意味着进化过程具有较少的物种形成能力。

+   `compatibility_disjoint_coefficient`: 在基因组距离计算过程中使用的系数，用于计算不重叠或过剩基因对计算结果的影响。此参数的较高值放大了不重叠或过剩基因在基因组距离计算中的重要性。

+   `compatibility_weight_coefficient`：该系数管理节点基因的偏差和响应属性与连接基因的权重属性之间的基因组距离计算的差异对结果的影响。

+   `conn_add_prob`：引入新连接基因到现有节点基因之间的突变的概率。

+   `conn_delete_prob`：从基因组中删除现有连接基因的突变的概率。

+   `enabled_default`：新创建的连接基因的启用属性的默认值。

+   `enabled_mutate_rate`：切换连接基因启用属性的突变的概率。

+   `feed_forward`：控制生成过程中要生成的表型网络的类型。如果设置为`True`，则不允许循环连接。

+   `initial_connection`：指定新创建基因组的初始连接模式。允许的值包括`unconnected`、`fs_neat_nohidden`、`fs_neat_hidden`、`full_direct`、`full_nodirect`、`partial_direct`和`partial_nodirect`。

+   `node_add_prob`：添加新节点基因的突变的概率。

+   `node_delete_prob`：从基因组中删除现有节点基因及其所有连接的突变的概率。

+   `num_hidden`、`num_inputs`、`num_outputs`：初始种群基因组的隐藏节点、输入节点和输出节点的数量。

+   `single_structural_mutation`：如果设置为`True`，则在进化过程中只允许结构突变，即只允许节点或连接的添加或删除。

# XOR实验超参数

XOR实验从一个非常简单的初始基因组配置开始，该配置只有两个输入节点、一个输出节点和一个特殊的输入——偏差节点。在初始基因组中不引入任何隐藏节点：

[PRE1]

所有网络节点的激活函数是S型，节点输入通过`sum`函数聚合：

[PRE2]

编码网络的类型是前馈全连接：

[PRE3]

在进化过程中，新的网络节点和连接以特定的概率被添加和/或删除：

[PRE4]

所有连接默认启用，由于突变而变为禁用的概率非常低：

[PRE5]

基因组距离高度受父代基因组多余/不连接部分的影响，以促进物种的多样性：

[PRE6]

物种停滞延长到`20`代，并部分防止独特物种灭绝：

[PRE7]

物种内生物的生存阈值被设置为低值，以缩小进化过程，只允许最适应的生物繁殖（按适应性排序的生物列表的前20%）。同时，也引入了精英主义，无条件地将每个物种中两个最适应的个体复制到下一代。最小物种大小也影响物种形成，我们将其保留为默认值：

[PRE8]

物种兼容性阈值控制种群中物种的多样性。此参数的较高值导致种群具有更高的多样性。物种多样性应保持平衡，以保持进化过程按预期方向进行，避免探索过多的搜索向量，同时允许探索创新：

[PRE9]

种群大小设置为`150`，这相当适中，但对于如此简单的XOR问题来说已经足够了。终止标准（`fitness_threshold`）设置为`15.5`，以确保当找到的解决方案与目标（根据我们的`fitness`函数，最大适应度分数为`16.0`）最接近时，进化终止。

在这个任务中，我们感兴趣的是找到能够解决XOR问题的进化冠军，因此我们的终止函数（`fitness_criterion`）是`max`函数，它从种群中的所有生物中选择最大适应度：

[PRE10]

完整的配置文件`xor_config.ini`包含在本章相关源文件存储库的`Chapter3`目录中。

我们只介绍了对NEAT算法性能有重大影响的超参数。这些超参数的值被测试以生成一个工作的XOR求解器，但请随意尝试并看看会发生什么。

# 运行XOR实验

在我们开始处理XOR实验之前，我们需要根据我们选择的NEAT-Python库的要求正确设置我们的Python环境。NEAT-Python库可在PyPI上找到，因此我们可以使用pip命令将其安装到XOR实验的虚拟环境中。

# 环境设置

在我们开始编写与XOR实验相关的代码之前，应该创建适当的Python环境，并将所有依赖项安装到其中。按照以下步骤正确设置工作环境：

1.  使用Anaconda Distribution中的`conda`命令创建一个用于XOR实验的Python 3.5虚拟环境，如下所示：

[PRE11]

确保您的系统中已安装Anaconda Distribution，如[第2章](c673e180-4440-4eea-98f8-8800c77162c8.xhtml)中所述，*Python库和环境设置*。

1.  要使用新创建的虚拟环境，您必须激活它：

[PRE12]

1.  之后，可以使用以下命令将NEAT-Python库安装到活动环境中：

[PRE13]

我们在这里使用NEAT-Python库的特定版本（`0.92`），这是撰写时的最新版本。

1.  最后，我们需要安装可视化工具使用的可选依赖项。这可以通过以下`conda`命令完成：

[PRE14]

现在，我们准备开始编写源代码。

# XOR实验源代码

要开始实验，我们需要使用`mkdir`命令（适用于Linux和macOS）或`md`（适用于Windows）创建一个名为`Chapter3`的目录：

[PRE15]

此目录将保存本章所述实验的所有相关源文件。

然后，我们需要将`xor_config.ini`文件从与本章相关的源代码存储库复制到新创建的目录中。此文件包含 XOR 实验的超参数完整配置，正如我们之前所讨论的。

本书将要讨论的实验使用各种实用工具来可视化结果，帮助我们理解神经进化过程的内部机制。XOR 实验还依赖于本书源代码存储库中`visualize.py`文件中实现的特定可视化实用工具。你需要将此文件复制到`Chapter3`目录中。

Anaconda 分发安装包括 VS Code，这是一个免费的跨平台代码编辑器。在功能方面相当直观，但提供了对 Python 的出色支持，并使得在虚拟环境之间切换变得容易。你可以用它来编写本书中描述的实验的源代码。

最后，在`Chapter3`目录中创建`xor_experiment.py`，并使用你喜欢的 Python 源代码编辑器编写代码：

1.  首先，我们需要定义稍后将要使用的导入：

[PRE16]

1.  接下来，我们需要编写一些适应度评估代码，正如我们之前所描述的：

[PRE17]

永远不要错过在源代码中添加注释的机会，描述函数的目的、输入参数和执行结果。对源代码中一些有趣/棘手的部分进行注释也有利，以便为将来看到它的人（这可能是你！）提供更好的理解。

1.  使用适应度评估函数，你可以编写一个函数来评估当前代的所有生物体，并相应地更新每个基因组的适应度：

[PRE18]

1.  现在我们已经实现了评估单个基因组适应度的函数，并且目标函数已经被定义，是时候实现运行实验的函数了。`run_experiment`函数从配置文件中加载超参数配置并创建初始基因组种群：

[PRE19]

1.  我们对统计数据的积累感兴趣，以评估实验并实时观察过程。保存检查点也非常重要，这允许你在失败的情况下从给定的检查点恢复执行。因此，可以注册两种类型的报告器（标准输出和统计收集器）以及一个检查点收集器，如下所示：

[PRE20]

1.  然后，我们准备通过提供`eval_genome`函数来运行`300`代的神经进化，该函数用于评估每一代种群中每个基因组的适应度分数，直到找到解决方案或过程达到最大代数：

[PRE21]

1.  当 NEAT 算法的执行因成功或达到最大代数而停止时，将返回最健康的基因组。可以检查此基因组是否为赢家，即能否以给定的精度解决 XOR 问题：

[PRE22]

1.  最后，可以可视化收集到的统计信息和最佳匹配基因组，以探索神经进化过程的结果，并查看其从零到最大代数的表现：

[PRE23]

XOR 实验运行器的完整源代码可以在 [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter3/xor_experiment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter3/xor_experiment.py) 文件中找到。

由于前面的代码执行，Matplotlib 将用于渲染收集到的统计图。此外，还将展示最佳匹配基因组的网络图。

# 运行实验和分析结果

要开始实验，应在 `Chapter3` 目录中发出以下命令：

[PRE24]

不要忘记使用 `$ conda activate XOR_neat` 激活 `XOR_neat` 虚拟环境。否则，将引发有关缺少 `neat` 包的错误。

在您选择的终端应用程序中输入前面的命令后，NEAT 算法开始执行，终端窗口开始实时显示中间结果。对于每一代，输出如下：

[PRE25]

在第 43 代，种群的平均健康分数（`6.01675`）与配置文件中设置的完成标准（`fitness_threshold =15.5`）相比相当低。然而，看起来我们有一些有潜力的冠军物种（`ID: 2`），它们正在通过进化具有健康分数 `14.54383` 的冠军生物体来达到目标健康分数阈值，该分数编码了一个由四个节点和七个连接组成的 ANN 表型（大小为 `4,7`）。

种群包括 151 个个体，分为五个物种，具有以下属性：

+   `id` 是物种标识符。

+   `age` 是物种的年龄，即从其创建到现在的代数。

+   `size` 是属于此物种的个体数量。

+   `fitness` 是从其个体（在我们的情况下为最大值）计算出的物种健康分数。

+   `adj fit` 是特定物种的适应性，它已被调整以适应整个种群的健康分数。

+   `stag` 是特定物种的停滞年龄，即自物种上次健康分数改善以来的代数。

当 NEAT 算法找到适当的 XOR 求解器时，终端窗口将显示以下输出。它以关于最终基因组种群和赢家（成功的 XOR 求解器）的一般统计数据开始：

[PRE26]

从前面的输出中，我们可以看到，在代 `44` 中，进化过程创建了一个基因组，该基因组编码了一个表型 ANN，可以以给定的精度解决 XOR 问题。这个基因组属于 `ID:2` 物种的生物，而这个物种在过去七代中已经主导了进化过程。代 `44` 的冠军生物（`ID:6531`）是来自上一代 `ID:2` 物种的一个个体（`ID:5368`）的变异，它失去了一个隐藏节点，现在有三个节点和七个连接（大小：`(3, 7)`）。

然后是最佳基因组部分：

[PRE27]

最佳基因组部分代表了种群冠军的性能统计信息，以及其基因组配置。输入节点具有 IDs `-1` 和 `-2`，并且没有显示，因为它们相对简单，为我们提供了将值输入到网络图中的手段。输出节点和两个隐藏节点分别具有 IDs `0`、`224` 和 `612`。此外，`DefaultNodeGene` 包含了偏置值、激活函数的名称以及用于在每个节点聚合输入的函数的名称。稍后将要介绍的连接基因（`DefaultConnectionGene`）提供了源节点和目标节点的 ID，以及相关的连接权重。

最后，让我们看看 `Output` 部分：

[PRE28]

`Output` 部分表示当接收四个输入数据对时，种群冠军表型的 ANN 生成的输出值。正如我们所见，输出值在指定的精度范围内接近预期值。

`Output` 目录还包含成功解决 XOR 问题的 ANN 图的图表，如下所示：

![图片](img/e46d445a-5e77-42fb-98f4-9c630bc3ebcf.png)

XOR 胜者表型的 ANN

胜者表型的 ANN 接近我们之前描述的优化配置，但它有一个额外的隐藏节点（`ID:612`）。偏置节点在图中没有显示，因为 NEAT-Python 库不会为单独的节点分配偏置；相反，它将偏置值分配给每个网络节点作为属性，这可以在输出列表中看到（每个 `DefaultNodeGene` 都有一个偏置属性）。

一个包含进化过程中适应度变化统计的图表也被保存在 `Output` 目录中：

![图片](img/e1a831ca-8acd-4dd7-a27b-7efeaec0d5ee.png)

种群平均和最佳适应度分数随代数的变化

前面的图表展示了种群在进化过程中的最佳和平均适应度分数的变化。种群的平均适应度略有提高。然而，由于在NEAT算法中引入的物种形成特性，一些物种从最早的一代（`#10`）就表现出卓越的性能，并且得益于对有益突变的保留，它们最终成功地产生了一个冠军生物体，该生物体以给定的精度解决了XOR问题。

`Output`目录还包含物种形成图，如下所示：

![图片](img/34f1a205-b1d0-4253-bba7-28fd754060de.png)

进化过程中种群的多代物种形成

物种形成图展示了物种形成过程如何在生物种群的多代中演变。每个独立的物种都用不同的颜色标记。进化始于一个单一的物种（`ID:1`），它包括整个种群。然后，第二个物种（`ID:2`）在第10代左右出现，并最终产生了一个冠军生物体。此外，在进化的后期阶段，种群在代数`23`、`39`和`42`时分支成了三个更多的物种。

# 练习

现在我们有了基于神经进化的XOR求解器的源代码，尝试通过改变控制进化过程的NEAT超参数进行实验。

其中一个特别感兴趣的参数是`compatibility_threshold`，它可以在配置文件的`DefaultSpeciesSet`部分找到：

+   尝试增加其值并监控种群的物种形成。将算法的新值与默认值（`3.0`）进行比较，看是否有任何改进？

+   如果你减小这个参数的值会发生什么？将其性能与默认值进行比较。

控制进化过程的另一个重要参数是`min_species_size`，它可以在`DefaultReproduction`部分找到。通过改变此参数的值，你可以直接控制每个物种的最小个体数，并隐式地控制物种的多样性：

1.  将`compatibility_threshold`参数值设置为默认值（`3.0`），并尝试在范围 `[2, 8]` 内增加`min_species_size`参数的值。将算法的性能与默认值进行比较。查看物种多样性在代与代之间的变化。通过算法的输出检查是否有任何物种停滞并因超过停滞年龄而被从进化中移除。

1.  将`min_species_size`参数值设置为极高（32）以适应我们的种群，并在物种形成图上寻找进化过程接近结束时物种多样性的爆炸。为什么会发生这种情况？检查表示ANN表型的配置的`Digraph.gv.svg`图。这是否是最优的？

增加物种的最小尺寸使进化过程更加精细，并允许它保留更多有益的突变。因此，我们增加了产生编码最小XOR求解器表型ANN的最优基因组的可能性。

最小XOR求解器的ANN图如下：

![图片](img/aaac3788-1eff-40bb-bdb8-ea1b6d4dcb2b.png)

增加最小物种尺寸的最优ANN表型

正如我们之前提到的，最小XOR求解器的ANN只有一个隐藏节点，如前图所示。

尝试实现一些修改后的代码来解决一个三XOR（A xor B xor C）问题。能否使用我们在本章描述的实验中使用的相同超参数来解决？

# 摘要

在本章中，我们介绍了一个与创建最优XOR求解器相关的经典计算机科学问题。我们讨论了XOR问题的基本原理，并展示了它在神经进化实验中的重要性——它允许你检查NEAT算法是否能够从最简单的ANN配置开始进化出更复杂的ANN拓扑结构。然后，我们定义了最优XOR求解器的目标函数和NEAT超参数的详细描述。之后，我们使用NEAT-Python库，通过定义的目标函数编写了XOR求解器的源代码，并进行了实验。

我们进行的实验结果使我们能够得出种群中物种数量、每个物种的最小尺寸以及算法性能之间的关系，以及产生的ANN拓扑结构。

在下一章中，我们将学习经典的强化学习实验，这些实验通常用作控制策略实现的基准。你将学习如何编写真实物理装置的准确模拟，以及如何使用这些模拟来定义NEAT算法的目标函数。你将亲身体验使用NEAT-Python库编写各种小车平衡控制器的控制策略。
