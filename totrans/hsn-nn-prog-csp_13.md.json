["```py\n/// <summary> A particle. </summary>\npublic struct Particle\n{\n/// <summary> The position of the particle. </summary>\npublic double[] Position;\n/// <summary> The speed of the particle. </summary>\npublic double[] Speed;\n/// <summary> The fitness value of the particle. </summary>\npublic double FitnessValue;\n/// <summary> The best position of the particle. </summary>\npublic double[] BestPosition;\n/// <summary> The best fitness value of the particle. </summary>\npublic double BestFitnessValue;\n}\n```", "```py\nGlobalBest.BestFitnessValue = PSO_Type == PSOType.Minimization ? double.PositiveInfinity : double.NegativeInfinity;\n```", "```py\nSwarm[i].Position = Swarm_Random(lb_domXi, ub_domXi, dimSize);\n```", "```py\nSwarm[i].Speed = Swarm_Random(lb_domXi, ub_domXi, dimSize);\n```", "```py\nSwarm[i].FitnessValue = PSO_Round(Fitness(Swarm[i].Position));\n```", "```py\nSwarm[i].BestFitnessValue = Swarm[i].FitnessValue;\n```", "```py\nSwarm[i].BestPosition = (double[])Swarm[i].Position.Clone();\n```", "```py\nif (IsBetterPosition(Swarm[i].BestFitnessValue, GlobalBest.BestFitnessValue, PSO_Type))\n{\nGlobalBest.BestPosition = (double[])Swarm[i].Position.Clone();\nGlobalBest.BestFitnessValue = Swarm[i].BestFitnessValue;\n}\n```", "```py\nFillPlotSwarmPosition(0, i, Swarm[i].Position);\nFillPlotGlobalPosition(0, GlobalBest.BestPosition);\n```", "```py\nDisplayResult(PSODispType.GlobalBest, \"Iter : 0 \" + GlobalBest.BestFitnessValue + \" :: \" + sResult(GlobalBest.BestPosition));\nfor (int i = 0; i < SwarmSize; i++)\n{\nDisplayResult(PSODispType.Swarm, \"Swarm [\" + i + \"] : \" + Swarm[i].FitnessValue);\nDisplayResult(PSODispType.SwarmPosition, \"Position : \" + sResult(Swarm[i].Position));\nDisplayResult(PSODispType.SwarmPosition, \"Speed : \" + sResult(Swarm[i].Speed));\nDisplayResult(PSODispType.SwarmPosition, \"Best Pos : \" + sResult(Swarm[i].BestPosition));\n}\n```", "```py\nFastRandom _MarkerStyle = new FastRandom();\n```", "```py\nchartPSO?.Series?.Clear();\nnChartControl2?.Charts?[0]?.Series?.Clear();\n```", "```py\nnChartControl2.Charts[0].BoundsMode = BoundsMode.Stretch;\n```", "```py\nfor (int i = 0; i < maxSwarm; i++)\n{\nchartPSO?.Series?.Add(\"Swarm(\" + i + \")\");\nchartPSO.Series[i].ChartType = SeriesChartType.Spline;\nchartPSO.Series[i].MarkerStyle = (MarkerStyle)_MarkerStyle.Next(1, 10);\nchartPSO.Series[i].MarkerSize = 10;\n```", "```py\nfor (int i = 0; i < maxSwarm; i++)\n{\nNLineSeries m_Line1 = (NLineSeries)nChartControl2.Charts[0].Series.Add(SeriesType.Line);\nm_Line1.MultiLineMode = MultiLineMode.Series;\nm_Line1.LineSegmentShape = LineSegmentShape.Tape;\nm_Line1.DataLabelStyle.Visible = false;\nm_Line1.DepthPercent = 50;\nm_Line1.Name = \"Swarm(\" + i + \")\";\n```", "```py\nchartPSO?.Series?.Add(\"GlobalPosition\");\nchartPSO.Series[maxSwarm].ChartType = SeriesChartType.Point;\nchartPSO.Series[maxSwarm].MarkerStyle = MarkerStyle.Diamond;\nchartPSO.Series[maxSwarm].Color = Color.Black;\nchartPSO.Series[maxSwarm].MarkerSize = 20;\n```", "```py\nnChartControl2.Controller?.Tools?.Add(new NTrackballTool());\nnChartControl2.Controller?.Tools?.Add(new NZoomTool());\nnChartControl2.Controller?.Tools?.Add(new NOffsetTool());\nnChartControl2.Controller?.Tools?.Add(new NAxisScrollTool());\nNPanelSelectorTool selector = new NPanelSelectorTool();\nselector.Focus = true;\nnChartControl2.Controller.Tools.Add(selector);\nnChartControl2.Controller.Tools.Add(new NDataZoomTool());\n```", "```py\nswitch (combType.SelectedIndex)\n{\ncase 0:\nPSO_Type = PSOType.Minimization;\nbreak;\ncase 1:\nPSO_Type = PSOType.Maximization;\nbreak;\n}\n```", "```py\ndimSize = Convert.ToInt32(txtdimSize.Text);\nub_domXi = Convert.ToDouble(txtUBXi.Text);\nlb_domXi = Convert.ToDouble(txtLBXi.Text);\nub_SpeedXi = Convert.ToDouble(txtUbSpeedXi.Text);\nlb_SpeedXi = Convert.ToDouble(txtLbSpeedXi.Text);\ndecP = Convert.ToInt32(txtdecP.Text);\n```", "```py\nmaxIter = Convert.ToInt32(txtmaxIter.Text);\nIntertia = Convert.ToDouble(txtW.Text);\nCognitiveWeight = Convert.ToDouble(txtC1.Text);\nSocialWeight = Convert.ToDouble(txtC2.Text);\nwMira = Convert.ToDouble(txtwMira.Text);\n```", "```py\nSwarmSize = Convert.ToInt32(txtSwarmSize.Text);\nSwarm = new Particle[SwarmSize];\n```", "```py\nPlotSwarm = new double[maxIter, SwarmSize, 2];\nPlotGlobal = new double[maxIter, 2];\n```", "```py\npublic double[] Swarm_Random(double a, double b, int n)\n{\ndouble[] x = new double[n];\nfor (int i = 0; i < n; i++)\n{\nx[i] = Swarm_Random(a, b);\n}\nreturn x;\n}\npublic double Swarm_Round(double x) => decP != -1 ? Math.Round(x, decP) : x;\npublic double Swarm_Random() => Swarm_Round(Randd.NextDouble());\npublic double Swarm_Random(double a, double b)\n{\nReturn (a + (b - a) * Swarm_Random());\n}\n```", "```py\nprivate double UpdateSwarmPosition(double Pos, double Speed)\n{\ndouble OutPos = Pos + Speed;\nreturn Math.Max(Math.Min(OutPos, upperBoundDomain), lowerBoundDomain);\n}\n```", "```py\n// Update Swarm Speed\nSwarm[i].Speed[j] = Inertia * Swarm[i].Speed[j] + CognitiveWeight * Swarm_Random() * (Swarm[i].BestPosition[j] - Swarm[i].Position[j]) + SocialWeight * Swarm_Random() * (GlobalBest.BestPosition[j] - Swarm[i].Position[j]);\n// Bound Speed\nSwarm[i].Speed[j] = UpdateSwarmSpeed(Swarm[i].Speed[j]);\nprivate double UpdateSwarmSpeed(double Speed)\n{\nreturn Math.Max(Math.Min(Speed, upperBoundSpeed), lowerBoundSpeed);\n}\n```", "```py\n// setup chart general parameters\nNChart m_Chart = nChartControl2.Charts[0];\nm_Chart.Enable3D = true;\nm_Chart.Width = 60;\nm_Chart.Height = 25;\nm_Chart.Depth = 45;\nm_Chart.Projection.Type = ProjectionType.Perspective;\nm_Chart.Projection.Elevation = 28;\nm_Chart.Projection.Rotation = -17;\nm_Chart.LightModel.SetPredefinedLightModel(PredefinedLightModel.GlitterLeft);\n```", "```py\n// add interlaced stripe to the Y axis\nNScaleStripStyle stripStyle = new NScaleStripStyle(new NColorFillStyle(Color.Beige), null, true, 0, 0, 1, 1);\nstripStyle.SetShowAtWall(ChartWallType.Back, true);\nstripStyle.SetShowAtWall(ChartWallType.Left, true);\nstripStyle.Interlaced = true;\n((NStandardScaleConfigurator)m_Chart.Axis(StandardAxis.PrimaryY).ScaleConfigurator).StripStyles.Add(stripStyle);\n```", "```py\n// show the X axis gridlines\nNOrdinalScaleConfigurator ordinalScale = m_Chart.Axis(StandardAxis.PrimaryX).ScaleConfigurator as NOrdinalScaleConfigurator;\nordinalScale.MajorGridStyle.SetShowAtWall(ChartWallType.Back, true);\nordinalScale.MajorGridStyle.SetShowAtWall(ChartWallType.Floor, true);\n```", "```py\nInitState();\n```", "```py\nadvTree1.Nodes.Clear();\nSW = new Stopwatch();\nSW.Start();\nSwarm_Run();\nSW.Stop();\n```", "```py\nplotSwarmPositions = (double[,,])PlotSwarm.Clone();\nplotGlobalPositions = (double[,])PlotGlobal.Clone();\nmaxIter = plotSwarmPositions.GetLength(0);\nmaxSwarm = plotSwarmPositions.GetLength(1);\n```", "```py\nInitChart();\nInitializeMeshSurfaceChart();\nPlaybackPlot();\n```", "```py\n// Main Loop\nfor (int iter = 1; iter < maxIter; iter++)\n{\nfor (int i = 0; i < SwarmSize; i++)\n{\nfor (int j = 0; j < dimSize; j++)\n```", "```py\nreturn Math.Max(Math.Min(OutPos, upperBoundDomain), lowerBoundDomain);\n```", "```py\nreturn Math.Max(Math.Min(OutPos, upperBoundDomain), lowerBoundDomain);\n```", "```py\nreturn Math.Max(Math.Min(Speed, upperBoundSpeed), lowerBoundSpeed);\n```", "```py\nreturn Math.Max(Math.Min(Speed, upperBoundSpeed), lowerBoundSpeed);\n```", "```py\npublic double Swarm_Round(double x) => decimalPlaces != -1 ? Math.Round(x, decimalPlaces)\n```", "```py\nfor (int i = 0; i < SwarmSize; i++)\n```", "```py\nfor (int iter = 1; iter < maxIter; iter++)\n```", "```py\nSwarm[i].Speed[j] = Inertia * Swarm[i].Speed[j]\n```", "```py\n// Update Swarm Speed\nSwarm[i].Speed[j] = Intertia * Swarm[i].Speed[j]+ CognitiveWeight * Swarm_Random() * (Swarm[i].BestPosition[j] - Swarm[i].Position[j])+ SocialWeight * Swarm_Random() * (GlobalBest.BestPosition[j] - Swarm[i].Position[j]);\n```", "```py\n// Update Swarm Speed\nSwarm[i].Speed[j] = Intertia * Swarm[i].Speed[j] + CognitiveWeight * Swarm_Random() * (Swarm[i].BestPosition[j] - Swarm[i].Position[j])+ SocialWeight * Swarm_Random() * (GlobalBest.BestPosition[j] - Swarm[i].Position[j]);\n```", "```py\nInertia *= InertiaWeight;\n```", "```py\nprivate void PlaybackPlot()\n{\n```", "```py\nint iterN = GetCurrentIteration();\n_Closing = false;\n```", "```py\nif (iterN >= maxIter)\nreturn;\nPlotStatusN = PlotStatus.Play;\n```", "```py\nprogressBarX1.Visible = true;\nprogressBarX1.Minimum = 0;\nprogressBarX1.Maximum = maxIter;\n```", "```py\nfor (int iter = iterN; iter < maxIter; iter++)\n{\n```", "```py\nprogressBarX1.Value = iter;\nif (_Closing)\n{\n_Closing = false;\nprogressBarX1.Visible = false;\nreturn;\n}\n```", "```py\nPlotSwarmIterationPoint();\n```", "```py\nPauseForMilliSeconds(1);\nShowTitle();\n}\nPlotStatusN = PlotStatus.Pause;\nprogressBarX1.Visible = false;\n}\n```", "```py\nprivate void PlotSwarmIterationPoint()\n{\n```", "```py\nintiterN = GetCurrentIteration();\nif (iterN >= maxIter)\nreturn;\nNChart chart = nChartControl2.Charts[0];\nchart.Axis(StandardAxis.PrimaryX).ScaleConfigurator = new NLinearScaleConfigurator();\n```", "```py\nfor (int Swarm = 0; Swarm < maxSwarm; Swarm++)\n{\n```", "```py\nchartPSO.Series[Swarm].Points.AddXY(plotSwarmPositions[iterN, Swarm, 0], plotSwarmPositions[iterN, Swarm, 1]);\n```", "```py\nNLineSeries m_Line1 = (NLineSeries)nChartControl2.Charts[0].Series[Swarm];\nm_Line1.AddDataPoint(new NDataPoint(plotSwarmPositions[iterN, Swarm, 0], plotSwarmPositions[iterN, Swarm, 1]));\n```", "```py\nApplyLineColorRanges(new NRange1DD[] { new NRange1DD(-10, -5), new NRange1DD(5, 10) },\nnew Color[] { Color.Red, Color.Yellow }, m_Line1);\n}\n```", "```py\nchartPSO.Series[maxSwarm].Points.Clear();\nchartPSO.Series[maxSwarm].Points.AddXY(plotGlobalPositions[iterN, 0], plotGlobalPositions[iterN, 1]);\n```", "```py\niterN = Math.Min(iterN + 1, maxIter - 1);\nnChartControl2.Refresh();\npictureBox1.Invalidate();\nShowTitle();\n}\n```", "```py\nprivate void DisplayResult(PSODispType DispType, string Text)\n{\nswitch (DispType)\n{\n```", "```py\ncase PSODispType.GlobalBest:\nNode n1 = new Node();\nn1.Text = Text;\nlastNode = advTree1.Nodes.Add(n1);\nbreak;\n```", "```py\ncase PSODispType.Swarm:\nNode n2 = new Node();\nn2.Text = Text;\nadvTree1?.Nodes?[lastNode]?.Nodes?.Add(n2);\nbreak;\n```", "```py\ncase PSODispType.SwarmPosition:\nNode n = new Node();\nn.Text = Text;\nadvTree1?.Nodes?[lastNode]?.Nodes?.Add(n);\nbreak;\n}\n}\n\n```", "```py\nPublic double xxxxxx(double[] data)\n{\n}\n```", "```py\ninternal double GetFitnessValue(double x, double y)\n{\ndouble[] data = new double[2];\ndata[0] = x;\ndata[1] = y;\n```", "```py\nif (fitnessFunction == \"Sphere\")\nreturn Swarm_Round(SphereFunction(data));\nelse if (fitnessFunction == \"FitnessTest\")\nreturn Swarm_Round(FitnessTestFunction(data));\nelse if (fitnessFunction == \"MSphere\")\nreturn Swarm_Round(MSphereFunction(data));\n}\n```", "```py\npublic double LevyFunction13(double[] data)\n{\ndouble x1 = data[0];\ndouble x2 = data[1];\ndouble term1 = Math.Pow(Math.Sin(3 * Math.PI * x1), 2);\ndouble term2 = Math.Pow((x1 - 1), 2) * (1 + (Math.Pow(Math.Sin(3 * Math.PI * x2),\n2)));\ndouble term3 = Math.Pow((x2 - 1), 2) * (1 + (Math.Pow(Math.Sin(2 * Math.PI * x2), 2)));\nreturn term1 + term2 + term3;\n}\n```", "```py\nf(x,y)=sin2(3πx)+(x−1)2(1+sin2(3πy))+(y−1)2(1+sin2(2πy))\n```", "```py\nelse if (fitnessFunction == \"Shubert\")\nreturn Swarm_Round(ShubertFunction(data));\nelse if (fitnessFunction == \"Levy13\")\nreturn Swarm_Round(LevyFunction13(data));\n```"]