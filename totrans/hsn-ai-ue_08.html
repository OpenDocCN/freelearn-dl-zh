<html><head></head><body>
        

                            
                    <h1 class="header-title">Crowds</h1>
                
            
            
                
<p>In this chapter, we are going to wrap up our talk about what comes built-in in terms of Artificial Intelligence in Unreal. Then, we will embark on a journey in which we will build an interesting AI Behavior Tree from scratch, before checking the huge Debug system (which includes AI Debugging) underneath Unreal.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Crowds in Games</li>
<li>RVO avoidance</li>
<li>Crowd Manager</li>
</ul>
<p>These topics may be short, but that doesn't make them less important or easy to implement. So, let's get started!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Crowds in games</h1>
                
            
            
                
<p>Have you ever been stuck in a busy mall at Christmas or surrounded by a large crowd during a sporting event? Perhaps you were shopping among the bazaars of heavily fragrant spice markets? Now, imagine that all of the people in this environment disappeared. How would this change the mood? Quite significantly, I would imagine. Regardless of how big or how small a crowd of people is within an environment, they definitely add to the overall atmosphere.</p>
<p>Some great examples of crowds in games include the <em>Assassin's Creed</em> series<em>:</em></p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fccc6dba-124d-44ea-8dd0-250b0171e317.png"/></p>
<p>Crowds in <em>Assassin's Creed: Syndicate</em></p>
<p>Crowds can include both interactive NPCs and those that simply just wander around, minding their own business. In some cases, like in <em>Assassin's Creed</em>, members of the crowd will play an important role such as requiring you to protect them, offering you protection, or even requiring your resources (e.g. beggars asking for money). In other situations, crowds will have no impact on your gameplay other than getting in your way!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building believable crowds</h1>
                
            
            
                
<p>While crowds are large collections of people, usually with a common purpose when in a given location, they require a bit of thought behind their creation. It's not as simple as dumping a bunch of NPCs, giving them some autonomy (e.g. via artificial intelligence), and pressing play. Building a believable crowd requires us to consider a few things.</p>
<p>The first consideration is the different kinds of people that should be there. Going back to our example of spice markets, you're likely to find shop merchants, buyers, beggars, children, and so on. In the following screenshot from the game <em>Stacking</em>, there are no large crowds or groups of people:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/34952a76-1d08-4c60-a5ee-5ce52452a4db.png"/></p>
<p>A small crowd in <em>Stacking</em></p>
<p>However, in <em>Dead Rising</em>, as shown in the following screenshot, there is quite an extensive crowd of people (zombies, in this case), all trying to attack you:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f6cc5ae1-2397-4f4e-9dfb-d6230e0dde77.png" style="width:45.08em;height:31.25em;"/></p>
<p>A big crowd of zombies attacking the player in <em>Dead Rising</em></p>
<p>The next consideration is more of an aesthetic one. For instance, depending on its location in both space and time, the type of movement, clothes, ages, etc., will also vary. It is highly unlikely (unless that is the angle you're going for) that you will have characters dressed as if they are going to a 1930s cocktail party, if you're attacking templars during the third crusade.</p>
<p>Then, we have the aural consideration. What does this crowd sound like? Are they loud or are do they speak in soft murmurs? Perhaps there are bikes whizzing past with kids ringing their bells. All of these aspects are important in creating a convincing crowd.</p>
<p>Last, but not least, we have the crowd's movement. How do they move? Do they follow a specific path, are they guided down particular areas, or are they free to roam wherever they choose?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animals</h1>
                
            
            
                
<p>Now, not all crowds take on human (or part/like human) form. Crowds can also exist in terms of groups of animals. As we discussed previously, the same considerations also need to be taken into account when developing crowds of animals. You also have to pay attention to how animals interact with each other because it is quite different from the way humans do. For example, wolves are likely to be in different sized crowds, or "packs", than, say, a  flock of vultures or a herd of deer, as in the following image:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d74ac053-f9eb-4918-87d0-c8e854d85461.png" style="width:27.33em;height:33.33em;"/></p>
<p>(Top): Attacking groups of Vultures in <em>Assassin's Creed: Origins</em><br/>
(Bottom): Herd of deer in <em>Far Cry 4</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Crowd movement</h1>
                
            
            
                
<p>When it comes to more technical aspects of a crowd's functionality, we must consider the extent of interaction that a crowd has with the player. For example, if a player hits them while running past them, do members of the crowd respond? If so, how?</p>
<p>In games like Pro Evolution Soccer, FIFA, Rocket League, etc., crowds don't interact with the player beyond cheering or booing, depending on the situation. Of course, they also add to the atmosphere with inaudible chanting/conversations/cheering:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c833ee5c-e8c1-42d3-9ab0-591e8488f296.png"/></p>
<p>Crowd in <em>FIFA 2018</em></p>
<p>Often, this behavior is created by using cleverly animated (vertex) materials to simulate a large crowd that the player sees only over a distance and doesn't interact with. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Crowd dynamics and creating realistic behavior</h1>
                
            
            
                
<p>Since we have talked about some of the characteristics that help to create realistic crowd behavior, let's talk about the ways that we can implement this from a more technical standpoint.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flow-based</h1>
                
            
            
                
<p>These types of approaches focus on the crowd rather than its components. This means that the distinctive behaviors of individuals (within the crowd) occur due to input from their surroundings.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Entity-based</h1>
                
            
            
                
<p>These types of approaches mean that the characters in these crowds do not have any autonomy. This is because their behavior is based on a set of predefined rules that are meant to simulate social/psychological influences that occur in individuals that are a part of a crowd. In this way, all the movements of characters are determined by these rules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Agent-based</h1>
                
            
            
                
<p>This is perhaps the most dynamic and flexible approach to crowds. In agent-based approaches, characters are autonomous and can interact with individuals. This is to say that each character within a crowd of this type has (to a certain extent) a level of intelligence, which allows them to react based on a set of rules that are influenced by their surroundings.</p>
<p>This is the kind of approach that we will be using with our AI systems, and, in this chapter, we will explore the built-in Unreal systems that handle crowds.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Crowds in Unreal</h1>
                
            
            
                
<p>In Unreal, handling a huge crowd might be challenging, especially if you are going to have a complicated system. In fact, a crowd system needs to run fast and make the crowd behave realistically.</p>
<p>Having a huge crowd that built-in systems don't scale properly means that you are probably basing (almost) your entire gameplay on the crowd. In this case, you should go for implementing your own Crowd system, even by modifying the built-in one. However, for most games, the built-in systems are more than enough.</p>
<p>In Unreal, there are two built-in systems for crowd simulation/management. These are as follows:</p>
<ul>
<li>UCharacterMovementComponent's RVO</li>
<li>Detour Crowd System</li>
</ul>
<p>Although it is possible to keep them both running, it is not advisable to do so. So, be sure to use the one that suits your needs the best, or create your own.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reciprocal Velocity Obstacles (RVO)</h1>
                
            
            
                
<p><strong>Reciprocal Velocity Obstacles</strong> (<strong>RVO</strong>) is an algorithm that was discovered by the three researchers Jur van den Berg, Ming C. Lin, and Dinesh Manocha in 2008 in their paper "<em>Reciprocal Velocity Obstacles for Real-Time Multi-Agent Navigation</em>".</p>
<p>The RVO algorithm is path agnostic, which means that it is not aware of the path that the agent is following, nor the navmesh where the agent is navigating. Moreover, each agent navigates independently of one another without explicit communication. As a result, RVO is very fast to run, even for a large number of agents, and provides sufficient realistic behavior if the number of incoming collisions is limited.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RVO in Unreal</h1>
                
            
            
                
<p>The implementation of the RVO algorithm within the Unreal Engine goes way back to the Unreal Development Kit, or UDK (UE3). In UE4, you can find the algorithm that was implemented within the Character Movement Component.</p>
<p>To activate RVO on a specific character, open up its <em>Character Movement Component</em> and navigate to the <em>Character Movement: Avoidance</em> section. Here, you will be able to turn on the algorithm and set a few settings, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/812b9af2-4c28-4a59-94ab-faf157ff92b2.png" style="width:26.00em;height:16.33em;"/></p>
<p>The following settings are available (you need to click on the little arrow at the bottom to expand all the settings):</p>
<ul>
<li style="font-weight: 400"><strong>Use RVOAvoidance</strong>: Specifies whether or not the RVO algorithm is used on this character.</li>
<li style="font-weight: 400"><strong>Avoidance Consideration Radius</strong>: The RVO algorithm will consider only obstacles that fall within this radius. Hence, if nothing is within this radius, RVO will not change the course of the character. On the other hand, if obstacles (e.g. other characters) are present within this radius, RVO will try to avoid them. This parameter is really important, and it needs to be tweaked properly (depending on what kind of obstacles your character will encounter) when RVO is used.</li>
<li style="font-weight: 400"><strong>Avoidance Weight</strong>: This indicates how heavily RVO needs to intervene on the avoidance of the obstacles. In fact, the algorithm will try to average between the direction the character is heading, and a direction to avoid the obstacles. This is the strength of the RVO algorithms and determines its behavior. The default value is 0.5, which works in the majority of cases.</li>
<li style="font-weight: 400"><strong>Avoidance UID</strong>: This is an identification number that is automatically generated when RVO is used (you cannot set it). It is important when you want to interact with the Avoidance Manager (see the <em>RVO in C++</em> section for more information).</li>
<li style="font-weight: 400"><strong>Avoidance Group</strong>: This indicates which avoidance group(s) this character belongs to.</li>
<li style="font-weight: 400"><strong>Groups to Avoid</strong>: This indicates which of the avoidance groups this character needs to avoid.</li>
<li style="font-weight: 400"><strong>Groups to ignore</strong>: This indicates which of the avoidance groups this character needs to ignore, and thus not take them into consideration when performing RVO avoidance.</li>
</ul>
<div><br/>
In the case of multiplayer games, the RVO algorithm will only run on the server.</div>
<p>This is enough to use the algorithm and use it in production for your game. However, if you are curious and want to dig a little bit deeper, move on to the following subsection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced RVO settings</h1>
                
            
            
                
<p>This section is divided in two sections: what we can do in a blueprint, and what we can do in C++.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RVO in Blueprint</h1>
                
            
            
                
<p>If you have a reference to the character component, you will notice that you can read all of its variables (all of the Get-functions are here), but that you cannot set them (there are no Set-functions), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9ae2af71-d930-4de6-adb1-f72b4f3c0587.png" style="width:42.25em;height:28.50em;"/></p>
<p>It seems like you cannot turn RVO on and off any time you like during gameplay in Blueprint, but this is not true. In fact, it is still possible to slightly change RVO settings in real-time (at gameplay time). In particular, you can change whether RVO is running or not with the following node:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c7259a3c-19e0-42a4-9db9-62b3d8164b52.png" style="width:34.08em;height:11.50em;"/></p>
<p>The reason why you cannot edit the bool variable directly is clear if you look at the C++ implementation, in which the character needs to be registered to an RVO manager. In fact, it might be the first time that RVO is turned on, and all the initialization (e.g. registering to the RVO manager) needs to be handled.</p>
<p>Moreover, you can also change in which avoidance group(s) the character belongs and which ones, instead, should be avoided, by using the following two nodes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/46b8286b-bc65-4980-8b98-bcca6dbf1912.png" style="width:33.58em;height:20.50em;"/></p>
<p>Besides these three functions, you are pretty limited in what you can do in real-time with RVO, but C++ unlocks new possibilities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RVO in C++</h1>
                
            
            
                
<p>Of course, every time you reach the C++ realm in Unreal, your possibilities gets really wide in terms of what you can do. In this section, we explore some of these possibilities.</p>
<p>First of all, you will have direct access to the <em>UAvoidanceManager</em>, which stores data of all the agents that use RVO.</p>
<p>From a reference of the <em>Character Movement Component</em>, you can retrieve the <em><strong>Avoidance UID</strong></em>, which can be used to query the Avoidance Manager on getting the <em>FNavAvoidanceData</em> structure, which holds the specific avoidance data of the character. Besides having access to the data in the structure, you can use it to further query the <em>Avoidance Manager</em> to obtain more grain information.</p>
<p>Let's say you want to do manual velocity planning. You can gain access to the current velocity by using the <kbd>GetAvoidanceVelocity()</kbd> function.</p>
<p>However, the best way to learn about all of your possibilities is by looking at the source code. In particular, you will need to look at the following file: <kbd>Runtime/Engine/Classes/AI/Navigation/AvoidanceManager.h</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RVO observations</h1>
                
            
            
                
<p>The following are some of my observations from using this approach:</p>
<ul>
<li style="font-weight: 400">Since it is path and navmesh agnostic, the agent could potentially be pushed away from the Navmesh. This means that you need to take into consideration this possibility (and how often this might happen, e.g. if your maps have wall boundaries, then the character cannot be pushed away from the navmesh).</li>
<li style="font-weight: 400">If you want RVO working on non-character actors, then you will need to reimplement the RVO algorithm on your own (or adapt your actors to use the Character Movement Component).</li>
<li style="font-weight: 400">RVO might not work well if there are many characters in a very confined space (e.g. non-realistic behavior, such as lateral sliding).</li>
<li style="font-weight: 400">If the Avoidance Consideration Radius is high and the character needs to position itself among other characters, the position might be difficult for the character (and thus lead to strange, weird, and unnatural behaviors).</li>
<li style="font-weight: 400">RVO is very fast, even with many characters running RVO at the same level. In fact, the overhead cost is almost nothing if there are no obstacles, so by using an appropriate Avoidance Consideration Radius, many characters can be handled without any issues.</li>
</ul>
<ul>
<li style="font-weight: 400">You can implement the father of the RVO algorithm, the VO, which is RVO but without weighting. It is even faster if performance is really a concern, but realism will decrease. You can gather more information on this by taking a look at the references in the next section. For instance, by modifying the avoidance manager in the source code of the engine, you will be able to easily implement this algorithm (or anything else of your choice).</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">RVO resources</h1>
                
            
            
                
<p>The following are some further RVO resources you can have a look at:</p>
<ul>
<li style="font-weight: 400">The original RVO paper is available at the following link: <a href="http://gamma.cs.unc.edu/RVO/icra2008.pdf" target="_blank">http://gamma.cs.unc.edu/RVO/icra2008.pdf</a></li>
<li style="font-weight: 400">More information about RVO from the creators: <a href="http://gamma.cs.unc.edu/RVO">http://gamma.cs.unc.edu/RVO</a></li>
<li style="font-weight: 400">RVO version 2 (the version that's implemented within Unreal engine): <a href="http://gamma.cs.unc.edu/RVO2/">http://gamma.cs.unc.edu/RVO2/</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Detour Crowd</h1>
                
            
            
                
<p>Another built-in Unreal system is the <strong><em>Detour Crowd</em></strong>. It is based on the <em>Recats Library</em>, and in contrast to RVO, it will take into consideration the Navmesh on which the agents are moving. The system works pretty much out of the box already, but, let's dig deep into how it works and how we can use it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How the Detour Crowd system works</h1>
                
            
            
                
<p>Within your Game World exists an object called <strong>DetourCrowdManager</strong>. It is responsible for coordinating crowds in your game. In particular, an agent that is registered to the <strong>DetourCrowdManager</strong> will be taken into consideration. The <strong>DetourCrowdManager</strong> accepts anything that implements the <strong>ICrowdAgentInterface</strong>, which provides data to the Manager about the agent.</p>
<p>Actually, under the hood, the <em>Detour Crowd Manager</em> is using the Detour Crowd algorithm that was developed by <em>Mikko Mononen</em> in the <em>Recast Library</em>, which has been slightly modified by Epic Games for their needs. Therefore, the Detour Crowd Component offers an interface between the <em>Unreal Framework</em> and the <em>Recast Detour</em>. You can find more information about this by reviewing the resources at the end of this section.</p>
<p class="mce-root">Potentially, you can create an agent by implementing the <strong>ICrowdAgentInterface</strong>. However, Unreal provides you with a special component called <strong>UCrowdFollowingComponent</strong>, which implements the <strong>ICrowdAgentInterface</strong>, along with other functionalities. As a result, anything that has the <strong>UCrowdFollowingComponent</strong> is eligible to be an agent with the Crowd Manager. Actually, the component itself will auto-register itself to the Crowd Manager and will activate the <em>Detour Behaviour</em>.</p>
<p class="mce-root">To make things easier, the <strong>ADetourCrowdAIController</strong> is a pre-made controller that will automatically add the <strong>UCrowdFollowingComponent</strong> to the controller itself. Hence, this time, the system is triggered by the AI Controller from the <strong>Character Movement Component</strong> directly.</p>
<p class="mce-root">The following diagram helps explain this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ace7f5ee-2899-442d-aee4-ffd57beb66bf.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Detour Crowd system</h1>
                
            
            
                
<p>The easiest way to use the <em>Detour Crowd</em> system is by letting your AI controller inheriting from the Detour Crowd AI Controller, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/dce536e2-243b-4ed3-aaa2-da50d8d9b7a6.png" style="width:41.00em;height:42.92em;"/></p>
<p>In C++, you will need to inherit from <strong>ADetourCrowdAIController </strong>(or add the <strong><em>UDetourCrowdFollowingComponent</em></strong> to your controller).</p>
<p class="mce-root"/>
<p>Once you have done this for all the controllers that you want to use the <em>Detour Crowd</em>, the system will pretty much work out of the box.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Detour Crowd settings</h1>
                
            
            
                
<p>If you are using the <strong>UCrowdFollowingComponent</strong>, this component will implement the <strong>ICrowdAgentInterface</strong> by using the <strong>Avoidance Settings</strong> in the <strong>Character Movement Component</strong> (if one is available).</p>
<p>As a result, all the <strong>Avoidance Settings</strong> we saw in the <em>RVO</em> section will be taken into consideration by the <em>Detour Crowd</em>. Therefore, all of the settings that are highlighted in the following screenshot will still be valid for our AI Character:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/48a1a4c1-fc4b-42a3-9881-3535c05cbbac.png"/></p>
<p>Please note that the <strong>Avoidance Weight</strong> will not be taken into consideration by the Detour System since it is an <em>RVO</em>-specific parameter.</p>
<p class="mce-root">Consequently, all the blueprint functions we have seen (e.g. to change the group mask) are also valid.</p>
<p class="mce-root">These were specific settings on a per-character basis, but it is possible to tweak the overall <em>Detour Crowd settings</em>. To do this, navigate into the <strong>Project Settings</strong>, and under the <strong>Engine</strong> section, you will find an entry called <strong>Crowd Manager</strong>, as shown in the following screenshot:</p>
<p><img src="img/9679dcc6-72ea-4e63-b614-5da06ba8b31e.png"/></p>
<p class="mce-root">From here, we have access to all the <strong><em>Detour Crowd Manager settings</em></strong>. Most of these settings are from the original <em>Recast Crowd algorithm</em>, and the <em>Unreal Detour Crowd Manager</em> offers an interface where you can set these variables in the algorithm. Let's start from the easier ones:</p>
<ul>
<li class="mce-root"><strong>Max Agents</strong>: This is the maximum number of agents that the Crowd Manager will handle. Of course, the higher the number, the more agents you can place at once, but this will hit performance. You should plan how many agents your game needs carefully. Moreover, if you look at the source code, this number will be used to allocate the memory that's necessary for the Crowd Manager to handle the agents. This is useful to keep in mind in situations in which memory is low.</li>
<li class="mce-root"><strong>Max Agent Radius</strong>: This is the maximum size that an agent that has detoured from the Crowd Manager can go.</li>
<li class="mce-root"><strong>Max Avoided Agents</strong>: This is the maximum number of agents that the Detour System takes into consideration, and it also called neighbors. In other words, this specifies how many neighbor agents (maximum) should be taken into account for the avoidance behavior.</li>
<li class="mce-root"><strong>Max Avoided Walls</strong>: This is the maximum number of walls (in general, obstacle segments) that the Detour System should take into consideration. It works in a similar fashion to Max Avoided Agents, but asks about how many segments of the surrounding obstacles around the system need to be taken into account.</li>
<li class="mce-root"><strong>Navmesh Check Interval</strong>: This is for implementing how many seconds an agent that has gone off the navmesh should check and recalculate its position (the system will try to push the agent back onto the navmesh).</li>
<li class="mce-root"><strong>Path Optimization Interval</strong>: This checks, in seconds, how often an agent should try to re-optimize its own path.</li>
<li class="mce-root"><strong>Separation Dir Clamp</strong>: When another agent is behind, this value indicates the clamp separation force to left/right (dot product between <em>forward</em> and <em>dirToNei;</em> thus, a value of -1 means that this separation behavior is disabled).</li>
<li class="mce-root"><strong>Path Offset Radius Multiplier</strong>: When the agent is turning close to a corner, an offset to the path is applied. This variable is a multiplier to this offset (so that you are free to reduce and increase this offset).</li>
<li class="mce-root"><strong>Resolve Collisions</strong>: Despite the best efforts of the Detour System, agents may still collide. In such an event, the collision should be handled by the Detour System (with a value of true for this variable). In this case, this variable is set to false and the agents will be using a Character Movement Component. This component will take care of resolving the collision.</li>
</ul>
<p>The <strong>Avoidance Config</strong> parameter, which is shown in the following screenshot, is the heart of how sampling is done within the Detour Crowd Algorithm:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a132e02e-9383-4844-b0c3-3aa648b324bf.png"/></p>
<p><strong>Avoidance Config</strong> is an array of different sampling configurations, with slightly different parameters set. By default, there are four of them, corresponding to different sampling avoidance quality: low, medium, good, and high, respectively.</p>
<p>The quality level is set in the <strong>UCrowdFollowingComponent</strong> with the <strong>AvoidanceQuality</strong> variable, which uses the <strong>ECrowdAvoidanceQuality</strong> enum. If you have a reference to your <strong>UCrowdFollowingComponent</strong>, you can use the <kbd>SetCrowdAvoidanceQuality()</kbd> function.</p>
<p>Going back to the setting, if you want to add or remove a configuration, you will need to create your own version of the <strong>UCrowdFollowingComponent</strong> (alternatively, you can inherit from it and override functions), which takes into consideration a different number of configurations.</p>
<div><br/>
However, changing the number of configuration means that your game/application is making particular use of the <em>Detour System</em>!</div>
<p>Without changing the number of configurations, you can change the settings of these four quality configurations. These parameters are shown in the following screenshot (this is from the first configuration):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/694621a2-55ad-4a41-a1b1-58aedc32f82d.png" style="width:26.50em;height:27.58em;"/></p>
<p>To fully understand these settings, you should get to know how the algorithm works, but let's try and get our head around it without this.</p>
<p>The part of the algorithm that does the sampling starts by creating a set of rings (the number is indicated in the <strong>Adaptive Rings</strong> parameter) around the center point (where the agent is initially, with a bias, due to the <strong>Velocity Bias</strong> parameter, in the direction of the velocity). Each of these rings is sampled (divided) by <strong>Adaptive Division</strong>. Then, the algorithm recursively refines the search by using a smaller set of rings, which are centered on the best sample of the previous iteration. The algorithm repeats this process <strong>Adaptive Depth</strong> times. At each iteration, the best sample is chosen by considering the following, and the different parameters determine the weight (how important the consideration is with respect to the others):</p>
<ul>
<li style="font-weight: 400">Does the direction of the agent match the current velocity? The weight is <strong>DesiredVelocityWeight</strong>.</li>
<li style="font-weight: 400">Does the agent go sideways? The weight is <strong>SideBiasWeight</strong>.</li>
<li style="font-weight: 400">Does the agent collide with any known obstacle? The weight is <strong>ImpactTimeWeight</strong> (it scans a range by considering the current velocity of the agent if it collides using that velocity within <strong>ImpactTimeRange</strong> seconds).</li>
</ul>
<p>The following diagram should help you understand the different parameters:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cb115d43-0ae0-40b4-b1ce-0a47d1a8dee4.png" style="width:29.33em;height:26.58em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugging the Detour Crowd Manager</h1>
                
            
            
                
<p>The Crowd Manager has an integration with the visual logger, which means that, with some work, we can visually debug the Detour Crowd Manager. We will explore this in more detail in <a href="a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml">Chapter 13</a>, <em>Gameplay Debugger</em>, in which we will learn more about the Visual Logger further.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">More crowd resources</h1>
                
            
            
                
<p>Here some resources if you want to extend your knowledge of the Detour Crowd Algorithm and/or explore other alternatives:</p>
<ul>
<li style="font-weight: 400">Mikko Mononen's original Recast Library: <a href="https://github.com/recastnavigation/recastnavigation">https://github.com/recastnavigation/recastnavigation</a></li>
<li style="font-weight: 400">A collection of many interesting research algorithms for handling crowds: <a href="http://gamma.cs.unc.edu/research/crowds">http://gamma.cs.unc.edu/research/crowds</a></li>
</ul>
<p>Of course, you are welcome to keep exploring on your own!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have seen how the Unreal Engine handles crowds. In particular, we have seen two built-in systems. The first one is called <strong><em>Reciprocal Velocity Obstacles (RVO)</em></strong>, which is very fast, but not very precise. The second is the <strong>Detour Crowd</strong>, which is a bit more expensive, but more precise and realistic.</p>
<p>In the next chapter, we will move on and learn how to implement our own <em>Behavior Tree</em> from scratch.</p>


            

            
        
    </body></html>