<html><head></head><body><div><div><h1 id="_idParaDest-232"><em class="italic"><a id="_idTextAnchor219"/>Chapter 11</em>: Programming Encoders with Python</h1>
			<p>It is useful in robotics to sense the movements of motor shafts and wheels. We drove a robot along a path back in <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>, <em class="italic">Drive and Turn – Moving Motors with Python</em>, but it's unlikely that it has stayed on course. Detecting this and traveling a specific distance is useful in creating behaviors. This chapter investigates the choice made by the sensor, as well as how to program the robot to move in a straight line and for a particular distance. We then look at how to make a specific turn. Please note that this chapter does contain math. But don't worry, you'll follow along easily. </p>
			<p>In this chapter, you will learn about the following topics:</p>
			<ul>
				<li>Measuring the distance traveled with encoders</li>
				<li>Attaching encoders to the robot</li>
				<li>Detecting the distance traveled in Python</li>
				<li>Driving in a straight line</li>
				<li>Driving a specific distance</li>
				<li>Making a specific turn</li>
			</ul>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor220"/>Technical requirements</h1>
			<p>Before we get started, make sure you have the following parts:  </p>
			<ul>
				<li>The Raspberry Pi robot and the code from the previous chapter: <a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10</a>.</li>
				<li>Two slotted speed sensor encoders. Search for slotted speed sensor, Arduino speed sensor, LM393 speed sensor, or the Photo Interrupter sensor module. Include the term <em class="italic">3.3 V</em> to ensure its compatible. See the <em class="italic">The encoders we are using</em> section for images of these. </li>
				<li>Long male-to-female jumper cables.</li>
				<li>A ruler to measure the wheels' size on your robot – or better yet, calipers, if you can use them.</li>
			</ul>
			<p>The code for this chapter is available on GitHub: <a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/2XDFae0">https://bit.ly/2XDFae0</a></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor221"/>Measuring the distance traveled with encoders</h1>
			<p><strong class="bold">Encoders</strong> are sensors<a id="_idIndexMarker545"/> that change value <a id="_idIndexMarker546"/>based on the movement of a part. They detect where the shaft is or how many times an axle has turned. These can be rotating or sensing along a straight-line track.</p>
			<p>Sensing how far <a id="_idIndexMarker547"/>something has traveled is also known as <strong class="bold">odometry</strong>, and the<a id="_idIndexMarker548"/> sensors<a id="_idIndexMarker549"/> can also be called <strong class="bold">tachometers</strong>, or <strong class="bold">tachos</strong> for short. The sensors suggested in the <em class="italic">Technical requirements</em> section may also show up as <strong class="bold">Arduino tacho</strong> in <a id="_idIndexMarker550"/>searches. </p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor222"/>Where machines use encoders</h2>
			<p>Our robots use electronic <a id="_idIndexMarker551"/>sensors. Cars and large commercial vehicles use electronic or mechanical sensors for speedometers and tachos.</p>
			<p>Printers and scanners combine encoders with DC motors as an alternative to stepper motors. Sensing how much of an arc the robot has turned through is an essential component of servomechanisms, which we saw in <a href="B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Python to Control Servo Motors</em>. High-end audio or electrical test/measurement systems use these in control dials. These are self-contained modules that look like volume knobs but users can turn them indefinitely. </p>
			<p>With this basic understanding of what encoders are, let's now look at some of their types.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor223"/>Types of encoders</h2>
			<p><em class="italic">Figure 11.1</em> shows<a id="_idIndexMarker552"/> four different encoder sensors, each of which uses different mechanisms to measure movement (1–3), along with an encoder wheel and strip in panel 4:</p>
			<div><div><img src="img/B15660_11_01.jpg" alt="" width="1124" height="690"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Encoder sensors</p>
			<p>These sensors fall into a few categories, as shown in <em class="italic">Figure 11.1</em>, and correspond to the points that follow:</p>
			<ol>
				<li>This is a <strong class="bold">variable resistor</strong>. These <a id="_idIndexMarker553"/>analog devices can measure a turn but don't tend to allow continuous rotation. They have mechanical wipers on a metal or resistant track, which can wear down. This is not strictly an encoder but is handy. On the Raspberry Pi, they require analog-to-digital conversion, so they aren't suitable for this application. Servo motors also use these.</li>
				<li>This motor includes magnet-sensing encoders, highlighted by the white box, known as <strong class="bold">hall-effect sensors</strong>. Magnets on a wheel or strip pass next to the sensor, causing<a id="_idIndexMarker554"/> the sensor values to go high and low.</li>
				<li>This is a standard optical sensor. Using a slot with an IR beam passing through, they sense when the beam is interrupted. Computer trackballs, printers, and robotics use <a id="_idIndexMarker555"/>these. These <a id="_idIndexMarker556"/>produce a chain of pulses. Due to the beam <a id="_idIndexMarker557"/>being interrupted, we call them <strong class="bold">photo interrupters</strong>, <strong class="bold">optical encoders</strong>, or <strong class="bold">opto-interrupters</strong>. We will be using this kind.</li>
				<li>This shows a slotted wheel and a slotted strip for use with optical sensors. The ribbon is suitable for linear encoding and the wheel for encoding turns. They both have transparent and opaque sections. People make a variation using a light sensor and light/dark cells, but these are less common. </li>
			</ol>
			<p>Having seen some of<a id="_idIndexMarker558"/> the types of encoders, let's take a closer look at how they represent speed and movement.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor224"/>Encoding absolute or relative position</h2>
			<p><strong class="bold">Relative encoders</strong> can <a id="_idIndexMarker559"/>encode a relative change in position – that we have taken a certain number of steps clockwise or anticlockwise, or forward/backward along an axis, for example. They can only measure a position relative to the last time we measured by counting the number of slots that have passed. These can also be called <strong class="bold">incremental encoders</strong>. They are inexpensive and straightforward in hardware. Relative encoders are limited in that they memorize the previous position to create the next and accumulate errors.</p>
			<p>Another<a id="_idIndexMarker560"/> type is <strong class="bold">absolute encoders</strong>. These can encode the position along or around an axis to an exact position. Absolute encoders do not need information about the previous position but may need calibrating to determine how an encoding matches a real-world location. </p>
			<p>The following figure shows the types in comparison:</p>
			<div><div><img src="img/B15660_11_02.jpg" alt="" width="1346" height="739"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Comparing absolute and relative sensing</p>
			<p>The diagrams in <em class="italic">Figure 11.2</em> illustrate this difference. The circle on the left represents a movement <em class="italic">by</em> 30 degrees, from a memorized position of 30 degrees. This</p>
			<p> works, assuming <a id="_idIndexMarker561"/>that the original memorized position is accurate. Every time<a id="_idIndexMarker562"/> it is measured, a movement is measured. The circle on the right shows a position <em class="italic">at</em> 60 degrees from a zero point. If a sensor can tell you where something is <em class="italic">at</em>, then it is absolute. If you can tell you how much it has moved <em class="italic">by</em>, it is relative.</p>
			<p>In a crude form, a variable resistor can also be an absolute encoder, as used in servo motors to sense their position. Absolute position encoding can be done through optical or magnetic markers on a wheel or strip, allowing great precision in absolute positioning. These sensors can be bulky or expensive or require many inputs. An absolute encoder strip or wheel is also known as a scale.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor225"/>Encoding direction and speed</h2>
			<p>Basic relative encoding<a id="_idIndexMarker563"/> measures how many wheel slots pass the sensor. This gives the speed and distance. By using two sensors slightly apart, you can also encode the direction. <em class="italic">Figure 11.3</em> shows how this works:</p>
			<div><div><img src="img/B15660_11_03.jpg" alt="" width="534" height="492"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Encoding speed and direction with multiple sensors</p>
			<p>The system on the left encodes the speed. As the slots pass the sensors, they generate electronic pulses. Each pulse has a <strong class="bold">rising</strong> edge, where it goes up, and a <strong class="bold">falling</strong> edge, where it goes down. To count the number of pulses, we can count these edges. If you drive a motor with a direction, you can use a system with a single sensor like this, as we will do in our robot.</p>
			<p>The wheel on the right encodes direction by adding a second sensor. The slot edges will make the sensor value change at different points in a cycle, with a sequence we've labeled <strong class="bold">1</strong>, <strong class="bold">2</strong>, <strong class="bold">3</strong>, <strong class="bold">4</strong>. The direction of the sequence indicates the direction of the wheel, along with its speed. As there are four phases, this is known as quadrature encoding.</p>
			<p>Industrial robots use a <strong class="bold">record-and-replay</strong> interface. The user will hit a record button and push a robot, such<a id="_idIndexMarker564"/> as an arm, through a set of movements, then press a stop button. The user has recorded this set of movements, and they could ask the robot to replay them. </p>
			<p>To build a robot with this record-and-replay system, or a mouse/trackball, the direction is essential information, so the additional complexity needed to encode the directions is required. </p>
			<p>We will use the cheaper and <a id="_idIndexMarker565"/>simpler option in our robot, using a single sensor to measure relative speed only. In our code, we will assume that each wheel's speed sensor is going in the direction we drive.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor226"/>The encoders we are using</h2>
			<p>We will use optical<a id="_idIndexMarker566"/> encoders in a slot shape that fits right above the encoder wheels we added in <a href="B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, <em class="italic">Building Robot Basics – Wheels, Power, and Wiring</em>. These encoders have digital outputs, and we can count the pulses from them in Python to sense how far a wheel has turned. <em class="italic">Figure 11.4</em> shows two types of sensor that I recommend:</p>
			<div><div><img src="img/B15660_11_04.jpg" alt="" width="334" height="234"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – The types of sensor we recommend</p>
			<p>On the left is the FC-03 photo interrupter module, and on the right is the Waveshare photo interrupter module. Modules that have 3.3 V in their supply voltage specification are suitable. Using 5 V-only modules will require level shifters and additional wiring, as discussed in <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>.</p>
			<p>We are going to use encoder wheels that are attached to the motor shafts. These are in line with the wheels. If the encoder wheels are running at a different rate from the wheels, we need to account for this. There are conditions that they cannot account for, such as slipping, as well as wheel and tire sizes. Encoders attached to separate idler wheels give better data, but they are trickier to connect to a robot and keep in contact with the floor. </p>
			<p>Now, you've seen what encoders can do, counting how much a wheel has turned to determine how far you've gone, and you've seen some of the types of encoders and which type to<a id="_idIndexMarker567"/> buy (3.3 V). You've also had a quick overview of how they work, by counting pulses. In the next section, we will build them into the robot.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor227"/>Attaching encoders to the robot</h1>
			<p>Our robot is <a id="_idIndexMarker568"/>now getting quite busy, and our Raspberry Pi is<a id="_idIndexMarker569"/> above the encoder's slots. Due to the slots being under the Raspberry Pi, we should wire them in a little before returning the Raspberry Pi. After bolting in the Raspberry Pi, we wire the encoders to its GPIO, as well as the power and ground.</p>
			<p><em class="italic">Figure 11.5</em> shows what the robot block diagram looks like after attaching the encoders:</p>
			<div><div><img src="img/B15660_11_05.jpg" alt="" width="806" height="763"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Robot block diagram with encoders</p>
			<p>This block diagram adds <a id="_idIndexMarker570"/>a left and right encoder, each with an arrow<a id="_idIndexMarker571"/> for the information flow connecting them to the Raspberry Pi. The highlighted elements are the new ones.</p>
			<p>Before we start changing the robot and making it harder to see, we need to know the number of slots in the encoder wheel for later:</p>
			<div><div><img src="img/B15660_11_06.jpg" alt="" width="693" height="201"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – Encoder wheel</p>
			<p>My encoder wheels, shown in <em class="italic">Figure 11.6</em>, ended up having 20 slots. Ensure you use the number of spaces your encoder wheels have. </p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor228"/>Preparing the encoders</h2>
			<p>Before we can use the<a id="_idIndexMarker572"/> encoder sensors, we need to prepare and fit them. As the encoders are going under the Raspberry Pi, we should attach the male-to-female jump wires to the sensors now. I suggest covering any electrical contacts that are sticking up under the Raspberry Pi with a little insulation tape:</p>
			<div><div><img src="img/B15660_11_07.jpg" alt="" width="1496" height="294"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – The sensors with cable connections</p>
			<p>Notably, the cables should be plugged into the ground (<strong class="bold">GND</strong>), voltage (<strong class="bold">3 V</strong>, <strong class="bold">Vin</strong>, or <strong class="bold">VCC</strong>), and digital output (<strong class="bold">D0</strong>/<strong class="bold">OUT</strong>), as shown in <em class="italic">Figure 11.7</em>. If it is present, do not connect the analog output (<strong class="bold">A0</strong>) pin. If possible, the ground pin should have the darkest color, or the voltage should be the lightest color. To help keep this clear, I suggest wrapping a small strip of insulation tape around the signal line's end. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As these sensors' pin configurations can vary, get a reference photo of the sensor pin labels before putting it under the Raspberry Pi. </p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor229"/>Lifting the Raspberry Pi</h2>
			<p>The encoder sensors<a id="_idIndexMarker573"/> need to go underneath the Raspberry Pi, so the Raspberry Pi needs to be gently lifted (without disrupting the wires) to accommodate them. The sequence of photos in <em class="italic">Figure 11.8</em> shows how to raise it:</p>
			<div><div><img src="img/B15660_11_08.jpg" alt="" width="1127" height="467"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8 – Unscrewing and lifting off the Raspberry Pi</p>
			<p>Refer to <em class="italic">Figure 11.8</em> and carry out the following steps:</p>
			<ol>
				<li value="1">You need to unscrew the bolts holding the Raspberry Pi to the chassis carefully. Put the screws aside for replacing the Raspberry Pi on the robot so that it can gently lift away.</li>
				<li>Gently lift the <a id="_idIndexMarker574"/>Raspberry Pi away from the robot without disrupting the cables. The photo shows how your robot should look.</li>
			</ol>
			<p>Great! Now that the Raspberry Pi is lifted, there is space for fitting the encoders under it.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor230"/>Fitting the encoders onto the chassis</h2>
			<p>Now that you have<a id="_idIndexMarker575"/> wired the encoders, you can fit them to <a id="_idIndexMarker576"/>the robot chassis. As a guide, <em class="italic">Figure 11.9</em> shows a bare chassis with each of the sensor types fitted to show you where you push them in:</p>
			<div><div><img src="img/B15660_11_09.jpg" alt="" width="1010" height="452"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9 – Fitting the encoder sensors</p>
			<p>Refer to <em class="italic">Figure 11.9</em> and complete these steps:</p>
			<ol>
				<li value="1">Gently push<a id="_idIndexMarker577"/> the encoders into the slots around<a id="_idIndexMarker578"/> the encoder wheel.</li>
				<li>The sensors should friction fit into the slots above the encoder wheels and stay in place.</li>
			</ol>
			<p>Once these are in place, you can replace the screws to attach the Raspberry Pi to the chassis. You may need different-sized standoffs to accommodate it.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">At this point, check that all your connections are back in place. The motor wires are likely to have come loose.</p>
			<p>With the encoders attached and the Raspberry Pi back in place, you are ready to wire them in.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor231"/>Wiring the encoders to the Raspberry Pi</h2>
			<p>We can <a id="_idIndexMarker579"/>now start making wire connections for the sensors using<a id="_idIndexMarker580"/> the breadboard. We'll use a circuit diagram to guide our connections.</p>
			<p><em class="italic">Figure 11.10</em> shows the connections for these sensors:</p>
			<div><div><img src="img/B15660_11_10.jpg" alt="" width="1272" height="781"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10 – Circuit for connecting the encoders to the Raspberry Pi</p>
			<p><em class="italic">Figure 11.10</em> shows the circuit for connecting the encoders to the Raspberry Pi. This diagram continues from the circuit seen in <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>. The new connections have thicker wire lines. </p>
			<p>On the right of <em class="italic">Figure 11.10</em> are the right and left encoder modules. The sensor will have a <strong class="bold">VCC</strong>, <strong class="bold">VIN</strong>, <strong class="bold">3 V</strong>, or just <strong class="bold">V</strong> label. Connect this to the 3.3 V line. Find the GND pin labeled <strong class="bold">GND</strong>, <strong class="bold">0V</strong>, or just <strong class="bold">G</strong> and connect it to the black/blue band on the breadboard. The encoders also have a pin labeled <strong class="bold">DO</strong> (digital out), <strong class="bold">SIG</strong> (signal), or just <strong class="bold">S</strong>, connected to a GPIO pin for the digital signal. We connect the digital outputs from the sensors to GPIO pins 4 for the left encoder and 26 for the right encoder.</p>
			<p>Some encoder sensors<a id="_idIndexMarker581"/> have additional connections, such as <strong class="bold">Analog Out</strong> (<strong class="bold">AO</strong>), which we will not use and will leave unconnected. </p>
			<p>Let's perform the following steps:</p>
			<ol>
				<li value="1">Connect the sensor's pins to the breadboard. Pay attention to the labels on the sensor – some have a different pin ordering.</li>
				<li>Connect the Raspberry Pi GPIO pins 4 and 26 to the breadboard.</li>
				<li>Make the breadboard power connections using precut wires.<p class="callout-heading">Important note</p><p class="callout">The number of wire-to-wire points on this robot makes it hard to add new connections or repair. Although beyond the <a id="_idIndexMarker582"/>scope of this book, making custom <strong class="bold">Printed Circuit Boards</strong> (<strong class="bold">PCBs</strong>) makes this thicket of cabling much neater. PCBs are also less fragile and takes up less space. Changing it does, however, come with a cost.</p></li>
			</ol>
			<p>It is possible to <a id="_idIndexMarker583"/>shortcut the breadboard and wire the sensor into<a id="_idIndexMarker584"/> the Raspberry Pi; however, the breadboard helps distribute the power connections and groups the sensor connections. </p>
			<p>We make this circuit in the context of a busy robot with other connections. If the cables from the sensors to the robot are not long enough, use a further set of male-to-female cables, using the same technique seen for the sonar scan in <a href="B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Python to Control Servo Motors</em>. </p>
			<p>In this section, you've learned how to connect the sensors and have made them ready to program. In the next section, we will write some code to test these sensors and then measure distances.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor232"/>Detecting the distance traveled in Python</h1>
			<p>Using encoder<a id="_idIndexMarker585"/> sensor devices requires us to count<a id="_idIndexMarker586"/> pulses. In this section, we will create code to turn on the motors and count pulses for a while. The code validates that the sensors are connected <a id="_idIndexMarker587"/>correctly. We then take this code and make it part of the robot class as <a id="_idIndexMarker588"/>a behavior.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor233"/>Introducing logging</h2>
			<p>So far in our Python <a id="_idIndexMarker589"/>code, we have been using <code>print</code> to output information to see what our robot is doing. This works, but prints can become overwhelming if we print everything we might want to inspect. Logging allows us to still display information, but we can control how much. By importing the <code>logging</code> module, we can take advantage of this.</p>
			<p>First, there are logging levels, with <code>debug</code>, <code>info</code>, <code>warning</code>, and <code>error</code>. While fixing problems or initially developing, <code>debug</code> is useful – it can show everything – while <code>info</code> is used to show a little less than that. The <code>warning</code> and <code>error</code> levels are reserved only for those kinds of problems, so you can filter down to only this level when you are reasonably confident with some code. The <code>logging.basicConfig</code> function allows us to configure a logging level and other logging parameters; you need to configure logging to enable <code>info</code> and <code>debug</code> logging.</p>
			<p>The other thing you can do with logging is to have differently named loggers using the <code>logging.getLogger</code> function. This lets you set different levels for different modules. Using named loggers helps to enable <code>debug</code> from a library module you are using while sticking to <code>info</code> on the main module. </p>
			<p>In this chapter's code, we will start using logging and controlling logging levels to get more detail on what an example is doing, turning the parts on and off at will. When we introduce the PID controller later, this will become very useful indeed. We can use this logging in the next section to show a sensor pulse count.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor234"/>Simple counting</h2>
			<p>This code counts the <a id="_idIndexMarker590"/>number of cycles up and down on each wheel's signal pin, printing the count as we test the sensors. Running this verifies that our sensor connections are working, letting us troubleshoot and move on. It also lays code foundations for tracking wheel movements. We run our motors for about 1 second. Note that this code assumes you are starting with the code from <a href="B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Python to Control Servo Motors</em>:</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can find the following code at <a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py</a>.</p>
			<ol>
				<li value="1">Let's make a file called <code>test_encoders.py</code>, starting with the usual robot classes, <code>import</code> and <code>time</code>, and adding logging:<pre><strong class="bold">from robot import Robot</strong>
<strong class="bold">import time</strong>
<strong class="bold">import logging</strong>
<strong class="bold">...</strong></pre></li>
				<li>Next, we add an import for a GPIO Zero input device. We can use the pin it sets up to count our pulses:<pre><strong class="bold">...</strong>
<strong class="bold">from gpiozero import DigitalInputDevice</strong>
<strong class="bold">logger = logging.getLogger("test_encoders")</strong>
<strong class="bold">...</strong></pre><p>We've also set<a id="_idIndexMarker591"/> up a named logger for our system matching the filename.</p></li>
				<li>The encoders generate pulses; we want to count them and track their state. We use more than one of them. Creating a class from the outset seems like the right strategy. From here, we can pass our I/O pin number to the constructor. The first thing it needs to do is to set up a pulse counter:<pre><strong class="bold">...</strong>
<strong class="bold">class EncoderCounter(object):</strong>
<strong class="bold">    def __init__(self, pin_number):</strong>
<strong class="bold">        self.pulse_count = 0</strong>
<strong class="bold">        ...</strong></pre></li>
				<li>Still in the constructor, we need to set up the device and how we count pulses with it. The device has a <code>.pin</code> object, which we set up using the pin number.<code>.pin</code> has a <code>when_changed</code> event, which we can drop our handler into to be called every time the pin changes. The pin changes from up to down (rising and falling) for every slot:<pre><strong class="bold">      ...</strong>
<strong class="bold">      self.device = DigitalInputDevice(pin=pin_number)</strong>
<strong class="bold">      self.device.pin.when_changed = self.when_changed</strong>
<strong class="bold">  ...</strong></pre></li>
				<li>We need to define a <code>when_changed</code> method for our class to add one to <code>pulse_count</code>. This method must be as small/quick as possible, as GPIO Zero calls it in the background for every pulse change. It takes a <code>time_ticks</code> parameter and a <code>state</code> parameter. We will not use <code>time_ticks</code>, so mark this with an <a id="_idIndexMarker592"/>underscore:<pre><strong class="bold">    ...</strong>
<strong class="bold">    def when_changed(self, _, state):</strong>
<strong class="bold">        self.pulse_count += 1</strong>
<strong class="bold">...</strong></pre></li>
				<li>We can set up our <code>robot</code> object and create an <code>EncoderCounter</code> for each side's sensor. We connected our devices to pins <code>4</code> and <code>26</code>:<pre><strong class="bold">...</strong>
<strong class="bold">bot = Robot()</strong>
<strong class="bold">left_encoder = EncoderCounter(4)</strong>
<strong class="bold">right_encoder = EncoderCounter(26)</strong>
<strong class="bold">...</strong></pre></li>
				<li>To display values, instead of just using <code>sleep</code>, we loop, checking against an end time. Before we log anything, <code>logging.basicConfig</code> sets logging parameters. We start the motors and go into the main loop:<pre><strong class="bold">...</strong>
<strong class="bold">stop_at_time = time.time() + 1</strong>
<strong class="bold">logging.basicConfig(level=logging.INFO)</strong>
<strong class="bold">bot.set_left(90)</strong>
<strong class="bold">bot.set_right(90)</strong>
<strong class="bold">while time.time() &lt; stop_at_time:</strong>
<strong class="bold">    ...</strong></pre><p>In this loop, we log the readings on both sensors. </p></li>
				<li>Since tight loops can cause things to break (such as GPIO Zero calling our code from a sensor thread), it should sleep a little too:<pre><code>f</code> prefix lets us format variables into a string.</p></li>
			</ol>
			<p>You can send this<a id="_idIndexMarker593"/> code to the robot and run it. You can now see the robot veering through the encoder's values. The output should look a little like this:</p>
			<pre>pi@myrobot:~ $ python3 test_encoders.py
INFO:test_encoders:Left: 0 Right: 0
INFO:test_encoders:Left: 0 Right: 1
INFO:test_encoders:Left: 2 Right: 2
INFO:test_encoders:Left: 3 Right: 4
INFO:test_encoders:Left: 5 Right: 7
INFO:test_encoders:Left: 8 Right: 10
INFO:test_encoders:Left: 10 Right: 14
...
INFO:test_encoders:Left: 56 Right: 74</pre>
			<p>The encoders are counting, and it shows that the robot moved less on the left wheel and more on the right wheel, and veered left. The <code>INFO:test_encoders:</code> part is introduced by the logging, showing the logging level and the logger name. The distances are in encoder <em class="italic">ticks</em>, a tick being each counted event.</p>
			<p>You've now tried out this code, but refer to the troubleshooting section if you have any problems.</p>
			<h3 id="_idParaDest-248">Troubleshooting</h3>
			<p>If you find <a id="_idIndexMarker594"/>problems when running this, try the following steps:</p>
			<ul>
				<li>Ensure you started from the <a href="B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Python to Control Servo Motors</em>, code. If you downloaded code from the current chapter, you will likely see GPIO conflicts with the code already set up for the encoders.</li>
				<li>If the encoder values stay at zero, turn off the Raspberry Pi, then go back and carefully check your wiring and pin number usage.  </li>
				<li>Check your wiring – if anything is hot, immediately disconnect the power and verify your wiring.</li>
			</ul>
			<p>You have tested the encoders on the robot, seeing feedback on your screen as they moved. This demonstrates that they are ready to be used in more interesting robot behaviors after adding them to the <code>Robot</code> object.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor235"/>Adding encoders to the Robot object</h2>
			<p>To use this<a id="_idIndexMarker595"/> sensor in other code or behaviors, we should move it<a id="_idIndexMarker596"/> into the <code>Robot</code> object. We can then import our code into the <code>Robot</code> object and set up the two sides with the correct pins. You'll also need to add some cleanup code for the handlers.</p>
			<h3 id="_idParaDest-250">Extracting the class</h3>
			<p>We've already<a id="_idIndexMarker597"/> made the <code>EncoderCounter</code> class, which you can copy from <code>test_encoders.py</code> to the <code>encoder_counter.py</code> (<a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py</a>) file. This code needs the import for <code>DigitalInputDevice</code>, the same constructor, and the <code>when_changed</code> handler: </p>
			<ol>
				<li value="1">Let's start by adding the imports and class declaration. The <code>EncoderCounter</code> class starts the same way as the last section:<pre><strong class="bold">from gpiozero import DigitalInputDevice</strong>
<strong class="bold">class EncoderCounter:</strong>
<strong class="bold">    def __init__(self, pin_number):</strong>
<strong class="bold">        self.pulse_count = 0</strong></pre></li>
				<li>I'm adding a <code>direction</code> member to account for reversing:<pre><strong class="bold">        self.direction = 1</strong></pre></li>
				<li>The constructor (<code>__init__</code>) is finished by setting up the device and assigning a <code>when_changed</code> handler:<pre><strong class="bold">      self.device = DigitalInputDevice(pin=pin_number)</strong>
<strong class="bold">      self.device.pin.when_changed = self.when_changed</strong></pre></li>
				<li>Our <code>when_changed</code> handler should add the direction instead of 1, so it can count up or down:<pre><strong class="bold">    def when_changed(self, time_ticks, state):</strong>
<strong class="bold">        self.pulse_count += self.direction</strong></pre></li>
				<li>We should<a id="_idIndexMarker598"/> also have a method to set this direction, so we can assert to validate our setting, which throws an exception if it doesn't meet the condition with the given text – a cheap but brutal way of ensuring input values make sense:<pre><strong class="bold">    def set_direction(self, direction):</strong>
<strong class="bold">        """This should be -1 or 1."""</strong>
<strong class="bold">        assert abs(direction)==1, "Direction %s should be 1 or -1" % direction</strong>
<strong class="bold">        self.direction = direction</strong></pre></li>
				<li>A reset method means we can handle restarting counters between movements:<pre><strong class="bold">    def reset(self):</strong>
<strong class="bold">        self.pulse_count = 0</strong></pre></li>
				<li>For cleanup, we need a way to stop the counters so that they don't call the handler again:<pre><strong class="bold">    def stop(self):</strong>
<strong class="bold">        self.device.close()</strong></pre></li>
			</ol>
			<p>With the encoder library ready, we can use this in our code. The library means we can reuse our encoder counter in different places, and also that we can substitute a different device with similar properties. To make it available to many behaviors, it will be handy to <a id="_idIndexMarker599"/>import it into the robot library. </p>
			<h3 id="_idParaDest-251">Adding the device to the Robot object</h3>
			<p>We've used <a id="_idIndexMarker600"/>our <code>Robot</code> object as the main interface between code handling the hardware and the behavior code. </p>
			<p>We will modify the <code>robot.py</code> code from <a href="B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Python to Control Servo Motors</em> (<a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py</a>) to add the sensors: </p>
			<ol>
				<li value="1">Start by importing <code>EncoderCounter</code>:<pre><strong class="bold">...</strong>
<strong class="bold">import leds_led_shim</strong>
<strong class="bold">from servos import Servos</strong>
<strong class="bold">from encoder_counter import EncoderCounter</strong>
<strong class="bold">...</strong></pre></li>
				<li>In the <code>__init__</code> constructor method, we need to set up left and right encoders. I did this just after the distance sensors:<pre><strong class="bold">        ...</strong>
<strong class="bold">        # Setup The Distance Sensors</strong>
<strong class="bold">self.left_distance_sensor = DistanceSensor(echo=17, trigger=27, queue_len=2)</strong>
<strong class="bold">        self.right_distance_sensor = DistanceSensor(echo=5, trigger=6, queue_len=2)</strong>
<strong class="bold">        # Setup the Encoders</strong>
<strong class="bold">        self.left_encoder = EncoderCounter(4)</strong>
<strong class="bold">        self.right_encoder = EncoderCounter(26)</strong>
<strong class="bold">        ...</strong></pre></li>
				<li>To make sure that the code cleans up encoder handlers when our <code>Robot</code> object has stopped, we call the encoder's <code>stop</code> methods in the <code>stop_all</code> method:<pre><strong class="bold">        ...</strong>
<strong class="bold">        # Clear the display</strong>
<strong class="bold">        self.leds.clear()</strong>
<strong class="bold">        self.leds.show()</strong>
<strong class="bold">        # Clear any sensor handlers</strong>
<strong class="bold">        self.left_encoder.stop()</strong>
<strong class="bold">        self.right_encoder.stop()</strong>
<strong class="bold">        ...</strong></pre></li>
			</ol>
			<p>The finished code for <code>robot.py</code> with encoders is on GitHub (<a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py</a>). We can now use this to build a behavior to measure the <a id="_idIndexMarker601"/>distance in millimeters. To do so, we'll understand the relationship between encoder ticks and the distance moved in millimeters.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor236"/>Turning ticks into millimeters</h2>
			<p>To calculate real <a id="_idIndexMarker602"/>distances, we need the sizes of the wheels. We cannot account for slipping, but we can find out how much a wheel has turned, which is the same as the encoders. Using the wheel's diameter, we can calculate how far it has turned. Using a ruler or caliper, measure the diameter across the wheel, as shown in <em class="italic">Figure 11.11</em>:</p>
			<div><div><img src="img/B15660_11_11.jpg" alt="" width="1172" height="466"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.11 – Measuring the wheel</p>
			<p>The measurements needed are shown in <em class="italic">Figure 11.11</em>:</p>
			<ol>
				<li value="1">You will need to measure the wheel's diameter, marked <strong class="bold">D</strong> in this figure, and the distance between the wheels, <strong class="bold">W</strong>. The distance <strong class="bold">W</strong> is equivalent to the width from midpoint to midpoint of the two motor-driven wheels on the robot. It is easier to measure, as shown here, the right side of one wheel, all the way across to the right side of the other wheel – which will be the same as midpoint to midpoint. Mine came to about 130 mm. </li>
				<li>You can measure <strong class="bold">D</strong> with calipers, as shown here, by fitting them around the widest part of the wheel. My wheel came to 70 mm, to the nearest mm.</li>
			</ol>
			<p>We know how many slots are on the encoders, and we expect two ticks (the rising and falling) per slot, so we<a id="_idIndexMarker603"/> can take the number of slots times 2, which is the number of ticks per whole-turn of the wheel – in my case, this is 40.</p>
			<p>The number pi, or <img src="img/Formula_11_001.png" alt="" width="14" height="12"/>, is the ratio of the diameter to the circumference of the wheel. To get the circumference, we multiply the diameter by pi, giving us <img src="img/Formula_11_002.png" alt="" width="30" height="17"/>, where <em class="italic">D</em> is the diameter. We can divide pi by the number of total ticks per revolution, and then when we multiply this by the number of ticks counted, <em class="italic">T</em>, and then the diameter, <em class="italic">D</em>, and we get a number for the distance, <em class="italic">d</em>, that the wheel has traveled:</p>
			<p><img src="img/Formula_11_003.png" alt="" width="153" height="47"/></p>
			<p>So, how do we turn this into code? Refer to the following steps:</p>
			<ol>
				<li value="1">Make a new file called <code>test_distance_travelled.py</code>. At the top of the file, we need to import <code>math</code> for the calculations, the <code>Robot</code> object, and <code>time</code>:<pre><strong class="bold">from robot import Robot</strong>
<strong class="bold">import time</strong>
<strong class="bold">import math</strong>
<strong class="bold">import logging</strong>
<strong class="bold">logger = logging.getLogger("test_distance_travelled")</strong>
<strong class="bold">...</strong></pre></li>
				<li>Next, we define our constants – the wheel's diameter and the number of ticks per revolution. Please use the values you obtained, not the ones that I have shown here:<pre><strong class="bold">...</strong>
<strong class="bold">wheel_diameter_mm = 70.0</strong>
<strong class="bold">ticks_per_revolution = 40.0</strong>
<strong class="bold">...</strong></pre></li>
				<li>Create a function to convert the ticks counted into a distance. It's converted into integers since fractions of a millimeter are just not appropriate for this measurement. Since<a id="_idIndexMarker604"/> part of the conversion doesn't change, we make that a constant, too:<pre><strong class="bold">...</strong>
<strong class="bold">ticks_to_mm_const = (math.pi / ticks_per_revolution) * wheel_diameter_mm</strong>
<strong class="bold">def ticks_to_mm(ticks):</strong>
<strong class="bold">    return int(ticks_to_mm_const * ticks)</strong>
<strong class="bold">...</strong></pre></li>
				<li>Next, we define our robot, set up a stop time, and start the motors:<pre><strong class="bold">...</strong>
<strong class="bold">bot = Robot()</strong>
<strong class="bold">stop_at_time = time.time() + 1</strong>
<strong class="bold">logging.basicConfig(level=logging.INFO)</strong>
<strong class="bold">bot.set_left(90)</strong>
<strong class="bold">bot.set_right(90)</strong>
<strong class="bold">...</strong></pre></li>
				<li>In the loop, we display the distance by calling <code>ticks_to_mm</code> on the pulse counts:<pre><strong class="bold">...</strong>
<strong class="bold">while time.time() &lt; stop_at_time:</strong>
<strong class="bold">    logger.info("Left: {} Right: {}".format(</strong>
<strong class="bold">        ticks_to_mm(bot.left_encoder.pulse_count),</strong>
<strong class="bold">        ticks_to_mm(bot.right_encoder.pulse_count)))    time.sleep(0.05)</strong></pre></li>
			</ol>
			<p>When uploaded to the robot and run, the output looks like this:</p>
			<pre>pi@myrobot:~ $ python3 test_distance_travelled.py
INFO:test_distance_travelled:Left: 0 Right: 0
INFO:test_distance_travelled:Left: 5 Right: 0
INFO:test_distance_travelled:Left: 16 Right: 10
INFO:test_distance_travelled:Left: 32 Right: 21
...
...
INFO:test_distance_travelled:Left: 368 Right: 384
INFO:test_distance_travelled:Left: 395 Right: 417</pre>
			<p>This output has shown a clear difference between the travel on the left and the right motors. The right <a id="_idIndexMarker605"/>motor is moving slightly quicker than the left. This difference accumulates, making the robot turn further. So, in the next section, let's use this information to straighten things up.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor237"/>Driving in a straight line</h1>
			<p>By now, you have seen differences in the outputs – that is, a veer. In only 400 mm, my left side is <a id="_idIndexMarker606"/>around 20 mm behind the right, an error that is climbing. Depending on your motors, your robot may have some veer too. It is rare for a robot to have driven perfectly straight. We use the sensors to correct this. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This behavior works better on wooden flooring or MDF boards, and poorly on carpet.</p>
			<p>This correction is still dead reckoning; slipping on surfaces or incorrect measurements can still set this off course. How can we use motors and encoders to correct our course and drive in a straight line?</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor238"/>Correcting veer with a PID</h2>
			<p>A behavior to <a id="_idIndexMarker607"/>self-correct steering and drive in a<a id="_idIndexMarker608"/> straight line needs to vary motor speeds until the wheels have turned the same amount. If the wheels turn the same amount soon enough, then they will account for major course deviations.</p>
			<p>Our robot will use the encoder sensor to measure how much each wheel has turned. We can then consider the difference between these to adjust the motor control and try to keep the motors at the same speed.</p>
			<p>A trick with this is working out how the difference in measurements relates to adjusting motor speeds. This leads us to look at a PID system designed to map errors into adjustment and output values.</p>
			<p>Driving in a straight line needs a closed <strong class="bold">feedback</strong> loop. <em class="italic">Figure 11.12</em> shows how this loop works:</p>
			<div><div><img src="img/B15660_11_12.jpg" alt="" width="1317" height="568"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12 – Closed-loop control of a motor's speed</p>
			<p>We start with an <em class="italic">expected position</em> or <strong class="bold">set point</strong>. The <em class="italic">encoder position</em> gives feedback data from the real world. We get a difference between the setpoint and the encoder position, which we call the <em class="italic">error</em>. The code feeds this into a <em class="italic">controller</em>, which generates a <em class="italic">speed adjustment</em>. The system will then apply that adjustment to the <em class="italic">motor speed</em>, making the motor turn more or less, changing the encoder's feedback.</p>
			<p>To go straight, we take the left motor's value and subtract the right motor to get an encoder difference. Our <em class="italic">expected position</em> is 0. Our <em class="italic">error</em> is then the difference between the encoders. We can then adjust the speeds using the controller.</p>
			<p>We use a <strong class="bold">PID</strong> controller to adjust the<a id="_idIndexMarker609"/> speed of the motors; this has three components:</p>
			<ul>
				<li><strong class="bold">Proportional</strong> (<strong class="bold">P</strong>): The error <a id="_idIndexMarker610"/>value multiplied by a constant. This corrects for immediate errors.</li>
				<li><strong class="bold">Integral</strong> (<strong class="bold">I</strong>): The sum of the <a id="_idIndexMarker611"/>error values so far, multiplied by a constant. This corrects for continuing errors.</li>
				<li><strong class="bold">Derivative</strong> (<strong class="bold">D</strong>): This takes<a id="_idIndexMarker612"/> the difference between the last error value and now and multiplies by a constant. This is to push back a little against sudden changes.</li>
			</ul>
			<p>By manipulating the constants, we <em class="italic">tune</em> how much each factor influences the outcome of the controller. We <a id="_idIndexMarker613"/>won't be using the derivative component<a id="_idIndexMarker614"/> for our behaviors, which is equivalent to having its constant set to zero. </p>
			<p>The integral can give the robot some self-tuning, but it needs to have a very small constant, as high values can make the robot start to wobble instead. We will add the adjustment onto one motor and subtract it from the other.</p>
			<p>The right motor speed is as follows:</p>
			<pre>...
integral_sum = integral_sum  + error
right_motor_speed = speed + (error * proportional_constant) + (integral_sum * integral_constant)
...</pre>
			<p>We need an unused motor speed capacity to be able to speed up a bit. If the speed is too close to 100%, we get clipping. An integral behavior with clipping can make the robot behave quite strangely, so watch out for clipping at 100%! </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Leave headroom for PID adjustments – use no more than 80% of motor speed.</p>
			<p>Now that we have some idea how a PID controller works, let's build one in code.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor239"/>Creating a Python PID controller object</h2>
			<p>The PID controller code is a<a id="_idIndexMarker615"/> fundamental robotics building <a id="_idIndexMarker616"/>block for making straight lines and we'll use it again in later camera-driven chapters. You will use the basic concepts here in many robotic systems:</p>
			<ol>
				<li value="1">We use this in a few places, so let's make a simplified PID control object. I put this in a file named <code>pid_controller.py</code>. Note that this is only a <code>proportional_constant</code> as <code>pK</code> and <code>integral_constant</code> as <code>iK</code>. You can do so if you wish. I've used the longer names in the code examples to make it easier to read.</p></li>
				<li>The following code handles the values for the two components. Handling the integral has the effect of increasing the integral sum:<pre><strong class="bold">...</strong>
<strong class="bold">    def handle_proportional(self, error):</strong>
<strong class="bold">        return self.proportional_constant * error</strong>
<strong class="bold">    def handle_integral(self, error):</strong>
<strong class="bold">        self.integral_sum += error</strong>
<strong class="bold">        return self.integral_constant * self.integral_sum</strong>
<strong class="bold">...</strong></pre></li>
				<li>The following bit of code handles the error to generate the adjustment:<pre><code>p</code> and <code>i</code>; since we log these values, we can configure logging to show them when debugging and tuning the controller.</p></li>
			</ol>
			<p>With the PI code in place, we are ready to make a robot that can combine errors with previous values, scaling them to make them useful in the context of some movement. We will use this PID controller for our straight line adjusting in the next section. </p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor240"/>Writing code to go in a straight line</h2>
			<p>I called this <code>straight_line_drive.py</code> (<a href="https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py">https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py</a>): </p>
			<ol>
				<li value="1">Let's import <a id="_idIndexMarker620"/>the <code>Robot</code> object, <code>time</code>, and our new PI controller. We'll set up logging to get debug from the PID controller. You can tune it back to <code>INFO</code> or take that line out if it's too much:<pre><strong class="bold">from robot import Robot</strong>
<strong class="bold">from pid_controller import PIController</strong>
<strong class="bold">import time</strong>
<strong class="bold">import logging</strong>
<strong class="bold">logger = logging.getLogger("straight_line ")</strong>
<strong class="bold">logging.basicConfig(level=logging.INFO)</strong>
<strong class="bold">logging.getLogger("pid_controller").setLevel(logging.DEBUG)</strong></pre></li>
				<li>Set up the <code>Robot</code> object too, and set up a slightly longer <code>stop_at_time</code> value so that our robot drives a bit further:<pre><strong class="bold">bot = Robot()</strong>
<strong class="bold">stop_at_time = time.time() + 15</strong>
<strong class="bold">...</strong></pre></li>
				<li>Start with a master<a id="_idIndexMarker621"/> speed value of <code>80</code>, and set both motors to this:<pre><strong class="bold">...</strong>
<strong class="bold">speed = 80</strong>
<strong class="bold">bot.set_left(speed)</strong>
<strong class="bold">bot.set_right(speed)</strong>
<strong class="bold">...</strong></pre></li>
				<li>Before going into our main loop, set up the controller. You may need to tune these constants. Note how small the integral constant is:<pre><strong class="bold">...</strong>
<strong class="bold">pid = PIController(proportional_constant=5, integral_constant=0.3)</strong>
<strong class="bold">...</strong></pre></li>
				<li>In the loop, we <code>sleep</code> a little so that our encoders have something to measure. It's also usually a bad idea to have a "tight" loop that doesn't use <code>sleep</code> to give other things a chance to run. Get the encoder values and compute the error:<pre><strong class="bold">...</strong>
<strong class="bold">while time.time() &lt; stop_at_time:</strong>
<strong class="bold">    time.sleep(0.01)</strong>
<strong class="bold">    # Calculate the error</strong>
<strong class="bold">    left = bot.left_encoder.pulse_count</strong>
<strong class="bold">    right = bot.right_encoder.pulse_count</strong>
<strong class="bold">    error = left - right</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>That error needs to be handled by the controller and used to make <code>right_speed</code>: <pre><strong class="bold">    ...</strong>
<strong class="bold">    # Get the speed</strong>
<strong class="bold">    adjustment = pid.get_value(error)</strong>
<strong class="bold">    right_speed = int(speed + adjustment)</strong>
<strong class="bold">    left_speed = int(speed - adjustment)</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>We can then <a id="_idIndexMarker622"/>log debug information here. Notice we have two levels: debug for the error and adjustment and info for the speeds. With the current config set to <code>INFO</code>, we won't see the debug without modifying it:<pre><strong class="bold">    ...</strong>
<strong class="bold">    logger.debug(f"error: {error} adjustment: {adjustment:.2f}")</strong>
<strong class="bold">    logger.info(f"left: {left} right: {right}, left_speed: {left_speed} right_speed: {right_speed}")</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>We then set the motor speeds to the adjusted values and finish the loop:<pre><strong class="bold">    ...</strong>
<strong class="bold">    bot.set_left(left_speed)</strong>
<strong class="bold">    bot.set_right(right_speed)</strong></pre></li>
			</ol>
			<p>When we run this, the robot should be following a fairly straight course. It may start unstable, but should hone in on a constant adjustment:</p>
			<pre>pi@myrobot:~ $ python3 straight_line_drive.py
DEBUG:pid_controller:P: 0, I: 0.00
INFO:straight_line:left: 3 right: 3, left_speed: 80 right_speed: 80
DEBUG:pid_controller:P: 0, I: 0.00
INFO:straight_line:left: 5 right: 5, left_speed: 80 right_speed: 80
DEBUG:pid_controller:P: -4, I: -0.20
INFO:straight_line:left: 5 right: 6, left_speed: 84 right_speed: 75
DEBUG:pid_controller:P: 0, I: -0.20
...
INFO:straight_line:left: 13 right: 15, left_speed: 89 right_speed: 71
DEBUG:pid_controller:P: -8, I: -1.40
INFO:straight_line:left: 15 right: 17, left_speed: 89 right_speed: 70
DEBUG:pid_controller:P: -8, I: -1.80
INFO:straight_line:left: 17 right: 19, left_speed: 89 right_speed: 70
DEBUG:pid_controller:P: -8, I: -2.20
INFO:straight_line:left: 19 right: 21, left_speed: 90 right_speed: 69
...
DEBUG:pid_controller:P: 0, I: 0.60
INFO:straight_line:left: 217 right: 217, left_speed: 79 right_speed: 80
DEBUG:pid_controller:P: 0, I: 0.60
INFO:straight_line:left: 219 right: 219, left_speed: 79 right_speed: 80
DEBUG:pid_controller:P: 0, I: 0.60
INFO:straight_line:left: 221 right: 221, left_speed: 79 right_speed: 80
DEBUG:pid_controller:P: 0, I: 0.60
INFO:straight_line:left: 223 right: 223, left_speed: 79 right_speed: 80</pre>
			<p>The robot starts <a id="_idIndexMarker623"/>with no error as the motors engage, but the right goes faster. At 13 ticks, the controller pulls the adjustment pretty high. Notice how <code>P</code> jumps, but <code>I</code> settles for a constant value after a while, which will keep the robot straight.</p>
			<p>Tuning of the <code>P</code> and <code>I</code> constants and the loop timing may result in earlier corrections – the initial encoder values are too small to be useful.</p>
			<p>Note that this may still end up off course; it accounts for reducing the veer but can adjust too late to stop a small <em class="italic">S</em> shape or other error. It is, however, much straighter than driving <a id="_idIndexMarker624"/>without. Adjusting the PID can help with this.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor241"/>Troubleshooting this behavior</h2>
			<p>Here are a few<a id="_idIndexMarker625"/> steps to take if the robot is wobbling or doesn't manage to travel in a straight line:</p>
			<ul>
				<li>If the robot takes too long to compensate, increase the proportional component.</li>
				<li>If the robot overshoots massively (that is, it swerves one way, then the other), reduce the size of both the proportional and integral PID components.</li>
				<li>If the robot is making increasing wobbles, the integral is too high, and the right speed may be going above 100. Bring down the integral component, and perhaps the requested speed.</li>
				<li>You can set the <code>straight_line</code> logger or <code>basicConfig</code> to debug to see the error value too.</li>
			</ul>
			<p>With the straight line working and driving, you have now corrected veer problems and differences between the sides. You can now build on this; let's take a known distance and drive to it, then stop.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor242"/>Driving a specific distance</h1>
			<p>For driving a specific<a id="_idIndexMarker626"/> distance, we use the PI controller again and incorporate the distance measurements into our encoder object. We calculate how many ticks we want the left wheel to have turned for a given distance, and then use this instead of a timeout component.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor243"/>Refactoring unit conversions into the EncoderCounter class</h2>
			<p>We want the<a id="_idIndexMarker627"/> conversions for our encoders in the <code>EncoderCounter</code> class to use them in these behaviors. Refactoring is the process of moving code or improving code while retaining its functionality. In this case, converting distances is one of the purposes of using encoders, so it makes sense to move this code in there:</p>
			<ol>
				<li value="1">Open up your <code>encoder_counter.py</code> class. First, we need the <code>math</code> import:<pre><strong class="bold">from gpiozero import DigitalInputDevice</strong>
<strong class="bold">import math</strong>
<strong class="bold">...</strong></pre></li>
				<li>At the top of the class, add <code>ticks_to_mm_const</code> as a class variable (not an instance variable) to use it without any instances of the class. Set this to none initially so that we can calculate it:<pre><strong class="bold">...</strong>
<strong class="bold">class EncoderCounter:</strong>
<strong class="bold">    ticks_to_mm_const = None # you must set this up before using distance methods</strong>
<strong class="bold">     ...</strong></pre></li>
				<li>In our class, we want to retrieve the distance the wheel has traveled directly from the encoder, in mm. Add this to the end of the file:<pre><code>ticks_to_mm_const</code> from the class and not <code>self</code> (the instance). </p></li>
				<li>We also want to calculate the opposite: the number of ticks from a distance in mm. To do that, divide the distance in mm by the same constant we multiplied by. This is set to <code>staticmethod</code> so that it does not require later code to use an instance:<pre><strong class="bold">    ...</strong>
<strong class="bold">    @staticmethod</strong>
<strong class="bold">    def mm_to_ticks(mm):</strong>
<strong class="bold">        return mm / EncoderCounter.ticks_to_mm_const</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>Add a way to set the constants in the file (for different robot configurations):<pre><strong class="bold">    ...</strong>
<strong class="bold">    @staticmethod</strong>
<strong class="bold"> def set_constants(wheel_diameter_mm, ticks_per_revolution):</strong>
<strong class="bold">     EncoderCounter.ticks_to_mm_const = (math.pi / ticks_per_revolution) * wheel_diameter_mm</strong>
<strong class="bold">    ...</strong></pre></li>
			</ol>
			<p>When you have<a id="_idIndexMarker628"/> saved this, <code>EncoderCounter</code> can now convert between distance and encoder ticks. We now need to set up the wheel diameters for your particular robot.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor244"/>Setting the constants</h2>
			<p>So far, we can use our<a id="_idIndexMarker629"/> robot metrics in our behaviors. Now, we want the <code>Robot</code> object to store our measurements and register them with the encoders. We can do this in two simple steps:</p>
			<ol>
				<li value="1">In <code>robot.py</code>, just before the constructor, specify some of these numbers:<pre>...
class Robot:
<strong class="bold">    wheel_diameter_mm = 70.0</strong>
<strong class="bold">    ticks_per_revolution = 40.0</strong>
<strong class="bold">    wheel_distance_mm = 140.0</strong>
    def __init__(self, motorhat_addr=0x6f):
        ...</pre></li>
				<li>Register these with the encoders:<pre>        ...
        # Setup the Encoders
<strong class="bold">        EncoderCounter.set_constants(self.wheel_diameter_mm, self.ticks_per_revolution)</strong>
        self.left_encoder = EncoderCounter(4)
        self.right_encoder = EncoderCounter(26)
        ....</pre></li>
			</ol>
			<p>With the constants ready, we've primed our encoders to measure distance. We can use this to make a<a id="_idIndexMarker630"/> behavior to drive a distance.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor245"/>Creating the drive distance behavior</h2>
			<p>I'll put this code <a id="_idIndexMarker631"/>into <code>drive_distance.py</code>:</p>
			<ol>
				<li value="1">Start by importing <code>EncoderCounter</code> to use its metrics, <code>PIController</code>, and the <code>Robot</code> object, and set up a logger:<pre><strong class="bold">from robot import Robot, EncoderCounter</strong>
<strong class="bold">from pid_controller import PIController</strong>
<strong class="bold">import time</strong>
<strong class="bold">import logging</strong>
<strong class="bold">logger = logging.getLogger("drive_distance")</strong>
<strong class="bold">...</strong></pre></li>
				<li>Define the <code>drive_distance</code> function, which takes a robot instance, a distance in ticks, and an optional speed defaulting to 80. We start by making a primary and secondary motor and controller decision:<pre><code>set_left</code> and <code>set_right</code> functions in variables – we can just call the variables like functions. </p></li>
				<li>We now have a well-defined primary and secondary motor. Set up a <code>PIController</code> and start the two motors:<pre><strong class="bold">    ...</strong>
<strong class="bold">    controller = PIController(proportional_constant=5, integral_constant=0.3)</strong>
<strong class="bold">    # start the motors and start the loop</strong>
<strong class="bold">    set_primary(speed)</strong>
<strong class="bold">    set_secondary(speed)</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>Now, we are in the <a id="_idIndexMarker632"/>driving distance loop. We should continue the loop until both encoders reach the right distance. We need to sleep before the rest of the loop so that we have some data for our calculations:<pre><strong class="bold">    ...</strong>
<strong class="bold">    while primary_encoder.pulse_count &lt; distance or secondary_encoder.pulse_count &lt; distance:</strong>
<strong class="bold">        time.sleep(0.01)</strong>
<strong class="bold">        ...</strong></pre></li>
				<li>Get the error and feed it into the controller:<pre><strong class="bold">        ...</strong>
<strong class="bold">        # How far off are we?</strong>
<strong class="bold">        error = primary_encoder.pulse_count - secondary_encoder.pulse_count</strong>
<strong class="bold">        adjustment = controller.get_value(error)</strong>
<strong class="bold">        ...</strong></pre></li>
				<li>We can send this to the motors and debug the data too. Because the adjustment is a non-integer, we allow two decimal places by using <code>{:.2f}</code>:<pre><strong class="bold">        ... </strong>
<strong class="bold">        # How fast should the motor move to get there?</strong>
<strong class="bold">        set_primary(int(speed - adjustment))</strong>
<strong class="bold">        set_secondary(int(speed + adjustment))</strong>
<strong class="bold">        # Some debug</strong>
<strong class="bold">        logger.debug(f"Encoders: primary: {primary_encoder.pulse_count}, secondary: {secondary_encoder.pulse_count}," </strong>
<strong class="bold">                    f"e:{error} adjustment: {adjustment:.2f}")</strong>
<strong class="bold">        logger.info(f"Distances: primary: {primary_encoder.distance_in_mm()} mm, secondary: {econdary_encoder.distance_in_mm()} mm")</strong>
<strong class="bold">...</strong></pre></li>
				<li>Set up the robot, let <a id="_idIndexMarker633"/>it calculate how far you want it to go, and get it moving:<pre><strong class="bold">...</strong>
<strong class="bold">logging.basicConfig(level=logging.INFO)</strong>
<strong class="bold">bot = Robot()</strong>
<strong class="bold">distance_to_drive = 1000 # in mm - this is a meter</strong>
<strong class="bold">distance_in_ticks = EncoderCounter.mm_to_ticks(distance_to_drive)</strong>
<strong class="bold">drive_distance(bot, distance_in_ticks)</strong></pre></li>
				<li>We let the robot cleanup (<code>atexit</code>) stop the motors. </li>
			</ol>
			<p>When you run this, the robot drives a meter and stops. My robot, when stopping, looked like this: </p>
			<pre>INFO:drive_distance:Distances: primary: 997 mm, secondary: 991 mm
INFO:drive_distance:Distances: primary: 1002 mm, secondary: 1002 mm</pre>
			<p>There is a 2 mm overshoot, which it can lose in rounding values and detection time. We can't make partial ticks.</p>
			<p>You have now seen how to make the robot drive a specific distance (or pretty close to it) while trying to stay in a straight line. You've combined the measuring and the PID adjustment tools that you've built throughout this chapter. But what if we want to make turns and measure those? We'll cover this in the next section.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor246"/>Making a specific turn</h1>
			<p>The next task we <a id="_idIndexMarker634"/>can use our encoders for is to make a specific turn. When turning a robot, each wheel is going through an arc. <em class="italic">Figure 11.13</em> illustrates this:</p>
			<div><div><img src="img/B15660_11_13.jpg" alt="" width="1625" height="715"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.13 – Illustrating wheel movement when turning through an arc</p>
			<p>The inner wheel drives a shorter distance than the outer wheel, and from the basics of differential steering, this is how we make the turn. To make an exact turn, we need to calculate these two distances or the ratio between them. <em class="italic">Figure 11.14</em> shows how the wheels and the turn relate to each other:</p>
			<div><div><img src="img/B15660_11_14.jpg" alt="" width="870" height="519"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14 – Relating wheels to turn radiuses</p>
			<p>If we consider the turn radius as setting where the middle of the robot is, an inner wheel's turn radius is the <em class="italic">difference</em> between the turn radius and half the distance between the wheels:</p>
			<p><img src="img/Formula_11_004.png" alt="" width="598" height="57"/></p>
			<p>The outer <a id="_idIndexMarker635"/>wheel's turn radius is the turn radius <em class="italic">added</em> to half the distance:</p>
			<p><img src="img/Formula_11_005.png" alt="" width="606" height="56"/></p>
			<p>We convert our angle to turn into <em class="italic">radians</em>, and we can then multiply this angle by each wheel radius to get the distances that each wheel needs to move through:</p>
			<p><img src="img/Formula_11_006.png" alt="" width="780" height="32"/></p>
			<p><img src="img/Formula_11_007.png" alt="" width="769" height="31"/></p>
			<p>Python has math functions to convert degrees into radians.</p>
			<p>Let's turn these functions into some code, demonstrating it by attempting to drive in a square, making measured 90-degree turns:</p>
			<ol>
				<li value="1">Start with a copy of <code>drive_distance.py</code> and call it <code>drive_square.py</code>. Add the <code>math</code> import, like so:<pre><strong class="bold">from robot import Robot, EncoderCounter</strong>
<strong class="bold">from pid_controller import PIController</strong>
<strong class="bold">import time</strong>
<strong class="bold">import math</strong>
<strong class="bold">import logging</strong>
<strong class="bold">logger = logging.getLogger("drive_square")</strong>
<strong class="bold">...</strong></pre></li>
				<li>We can modify the end of this file to state what we want to do. It can help to name functions that you plan to have, and then implement them to fit. We make it a bit smaller than a meter, too. For a radius to test with, I've added 100 mm to the robot's wheel distance. Anything less than the wheel distance and the center of <a id="_idIndexMarker636"/>the turn is between the wheels instead of outside of them:<pre><strong class="bold">...</strong>
<strong class="bold">bot = Robot()</strong>
<strong class="bold">distance_to_drive = 300 # in mm</strong>
<strong class="bold">distance_in_ticks = EncoderCounter.mm_to_ticks(distance_to_drive)</strong>
<strong class="bold">radius = bot.wheel_distance_mm + 100 # in mm</strong>
<strong class="bold">radius_in_ticks = EncoderCounter.mm_to_ticks(radius)</strong>
...</pre></li>
				<li>Since we are driving in a square, we want to drive four times. For straight lines, drive each wheel the same distance, then make 90-degree arcs of our radius. I've reduced the speed for the arc so that there is less of a slipping problem:<pre><strong class="bold">...</strong>
<strong class="bold">for n in range(4):</strong>
<strong class="bold">    drive_distances(bot, distance_in_ticks, distance_in_ticks)</strong>
<strong class="bold">    drive_arc(bot, 90, radius_in_ticks, speed=50)</strong></pre></li>
				<li>Let's go back up in the file to upgrade our method for driving a distance to one distance to driving two distances, one for each wheel. I've renamed the <code>drive_distance</code> function to <code>drive_distances</code>:<pre><strong class="bold">...</strong>
<strong class="bold">def drive_distances(bot, left_distance, right_distance, speed=80):</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>Depending on the angle we want to turn, either motor could be the outer motor and driving a longer distance. Since there is an upper limit to speed, we choose our primary and secondary motors based on the longer distance. Swap the code that set up the<a id="_idIndexMarker637"/> primary/secondary with this:<pre><code>abs</code>, the absolute value, to decide, because a longer distance in reverse should <em class="italic">still</em> be the primary motor. So, to determine how far the secondary wheel should go, we compute a ratio – to multiply with speed now, and later the primary encoder output. </p></li>
				<li>Since we are using this method more than once, reset the encoder counts. I put this in before setting up <code>PIController</code>:<pre><strong class="bold">    ...</strong>
<strong class="bold">    primary_encoder.reset()</strong>
<strong class="bold">    secondary_encoder.reset()</strong>
<strong class="bold">    </strong>
<strong class="bold">    controller = PIController(proportional_constant=5, integral_constant=0.2)</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>Since we can be going in either direction, set the encoder direction. Python has a <code>copysign</code> method <a id="_idIndexMarker638"/>to determine the sign of a value. Then, start the motors:<pre><strong class="bold">...</strong>
<strong class="bold">    # Ensure that the encoder knows which way it is going</strong>
<strong class="bold">    primary_encoder.set_direction(math.copysign(1, speed))</strong>
<strong class="bold">    secondary_encoder.set_direction(math.copysign(1, secondary_speed))</strong>
<strong class="bold">    # start the motors, and start the loop</strong>
<strong class="bold">    set_primary(speed)</strong>
<strong class="bold">    set_secondary(int(secondary_speed))</strong>
<strong class="bold">...</strong></pre></li>
				<li>When we start this loop, we again need to be aware that one or both motors could be going backward. We use <code>abs</code> again to take off the sign:<pre><strong class="bold">...</strong>
<strong class="bold">    while abs(primary_encoder.pulse_count) &lt; abs(primary_distance) or abs(secondary_encoder.pulse_count) &lt; abs(secondary_distance):</strong>
<strong class="bold">        time.sleep(0.01)</strong>
<strong class="bold">...</strong></pre></li>
				<li>Calculating the error for the secondary depends on the ratio between the two distances:<pre><strong class="bold">...</strong>
<strong class="bold">        # How far off are we?</strong>
<strong class="bold">        secondary_target = primary_encoder.pulse_count * primary_to_secondary_ratio</strong>
<strong class="bold">        error = secondary_target - secondary_encoder.pulse_count</strong>
<strong class="bold">        adjustment = controller.get_value(error)</strong>
<strong class="bold">        ...</strong></pre></li>
				<li>This still goes into the same adjustment calculation through <code>pid</code>; however, this adjustment may also cause a change in direction here. Now, we set the secondary motor<a id="_idIndexMarker639"/> speed:<pre><strong class="bold">      ...</strong>
<strong class="bold">      # How fast should the motors move to get there?</strong>
<strong class="bold">      set_secondary(int(secondary_speed + adjustment))</strong>
<strong class="bold">      secondary_encoder.set_direction(math.copysign(1, secondary_speed+adjustment))</strong>
<strong class="bold">      # Some debug</strong>
<strong class="bold">      logger.debug(f"Encoders: primary: {primary_encoder.pulse_count}, secondary: {secondary_encoder.pulse_count}, e:{error} adjustment: {adjustment:.2f}")</strong>
<strong class="bold">      logger.info(f"Distances: primary: {primary_encoder.distance_in_mm()} mm, secondary: {secondary_encoder.distance_in_mm()} mm")</strong>
<strong class="bold">      ...</strong></pre></li>
				<li>You could expand the debug that we had to take into account for the secondary speed and targets. Now, because we are trying for precision, the primary motor may reach its goal before the secondary and isn't set up to reverse. So, stop this motor when it reaches its goal, and set the base speed of the secondary to zero, which means only adjustments apply, if any. Note that we still use the absolute values here:<pre><strong class="bold">        ...</strong>
<strong class="bold">        # Stop the primary if we need to</strong>
<strong class="bold">        if abs(primary_encoder.pulse_count) &gt;= abs(primary_distance):</strong>
<strong class="bold">            logger.info("primary stop")</strong>
<strong class="bold">            set_primary(0)</strong>
<strong class="bold">            secondary_speed = 0</strong>
<strong class="bold">        ...</strong></pre></li>
			</ol>
			<p>And we are done with the driving distances function. We can use this to drive in a straight line or feed it a separate target distance for each wheel and use that to drive in an arc. We'll take<a id="_idIndexMarker640"/> advantage of that in the next section.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor247"/>Writing the drive_arc function</h2>
			<p>Here is where <a id="_idIndexMarker641"/>we convert to<a id="_idIndexMarker642"/> radians, determine the inner radius, and set up the distances for each wheel to drive. Add this code in <code>drive_square_behaviour.py</code>, after the <code>drive_distances</code> function:</p>
			<ol>
				<li value="1">Start with a function definition and a helpful docstring:<pre><strong class="bold">...</strong>
<strong class="bold">def drive_arc(bot, turn_in_degrees, radius, speed=80):</strong>
<strong class="bold">    """ Turn is based on change in heading. """</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>We turn the robot's width into ticks, the internal measurement of distance, and use half of that to get the wheel radiuses. We also determine which is the inner wheel:<pre><strong class="bold">    ...</strong>
<strong class="bold">    # Get the bot width in ticks</strong>
<strong class="bold">    half_width_ticks = EncoderCounter.mm_to_ticks(bot.wheel_distance_mm/2.0)</strong>
<strong class="bold">    if turn_in_degrees &lt; 0:</strong>
<strong class="bold">        left_radius = radius - half_width_ticks</strong>
<strong class="bold">        right_radius = radius + half_width_ticks</strong>
<strong class="bold">    else:</strong>
<strong class="bold">        left_radius = radius + half_width_ticks</strong>
<strong class="bold">        right_radius = radius - half_width_ticks</strong>
<strong class="bold">    logger.info(f"Arc left radius {left_radius:.2f}, right_radius {right_radius:.2f}")</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>We display the debug on what the radiuses are. Combine this with the turn in radians to get the distances. We convert the absolute value of the turn in degrees. We don't want to reverse into a turn, but to turn the other way:<pre><strong class="bold">    ...</strong>
<strong class="bold">    radians = math.radians(abs(turn_in_degrees))</strong>
<strong class="bold">    left_distance = int(left_radius * radians)</strong>
<strong class="bold">    right_distance = int(right_radius * radians)</strong>
<strong class="bold">    logger.info(f"Arc left distance {left_distance}, right_distance {right_distance}")</strong>
<strong class="bold">    ...</strong></pre></li>
				<li>Finally, feed <a id="_idIndexMarker643"/>these<a id="_idIndexMarker644"/> distances into the <code>drive_distances</code> function:<pre><strong class="bold">    ...</strong>
<strong class="bold">    drive_distances(bot, left_distance, right_distance, speed=speed)</strong>
<strong class="bold">...</strong></pre></li>
			</ol>
			<p>The robot should be able to drive in a square shape. It can still miss due to slipping or inaccuracies in the measurements. Tuning of the proportional and integral control values is required.</p>
			<p>Examining the full code for <code>drive_distances</code> and <code>drive_arc</code>, it may become apparent that there is some repetition in determining the inner/outer and the primary/secondary parts, which you could refactor if you choose.</p>
			<p>This code<a id="_idIndexMarker645"/> may not behave <a id="_idIndexMarker646"/>correctly if reversing through a corner.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor248"/>Summary</h1>
			<p>In this chapter, we saw how to incorporate wheel encoder sensors into our robot and used them to determine how far each wheel has turned. We saw how to use this to get the robot onto a straighter path using a reduced PID controller and then used this to drive a specific distance. We then took the calculations further to calculate turning a corner in terms of wheel movements and driving the robot in a square.</p>
			<p>A PID controller can be used in many situations where you need to apply a difference between a measurement and expectation, and you have seen how to combine this with sensors. You could use the same system to control a heating element connected to a thermal sensor. You could also use encoders to move robots with some precision, where the restricted range of motion used in servo motors does not make sense.</p>
			<p>In the next couple of chapters, we will explore giving our robot even more interactive and intelligent behaviors, with chapters on visual processing using a Raspberry Pi camera, speech processing with Mycroft, and using a smartphone to drive or select modes on the robot remotely.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor249"/>Exercises</h1>
			<ol>
				<li value="1">Try experimenting with turning on different logging levels and differently named loggers, tuning how much output a robot behavior creates.</li>
				<li>For the PID behaviors, tune the PIDs, try high values for the proportional or the integral, and observe how this makes the robot behave. Could you combine this with graphing in <code>matplotlib</code> to observe the PID behavior?</li>
				<li>There are a few ways that the drive distance code could be improved. Applying a <strong class="bold">PID</strong> controller to the distance moved by the primary could make it close in more precisely on the exact distance to travel. Detecting no movement in either encoder could be used to make the code stop after a timeout so that it doesn't drive off without stopping. Try this out.</li>
				<li>You could now use this code to make further geometric shapes or to follow paths without a line. Try adding high-level left turn/right turn 90-degree functions as building blocks for right-angled path construction, then use this to make paths.</li>
				<li>Consider combining the encoding sensors here with distance sensors; it may be possible to start memorizing distances between walls.</li>
			</ol>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor250"/>Further reading</h1>
			<p>Please refer to the following for more information:</p>
			<ul>
				<li>PID control is a deep subject. It is a key area in self-balancing robots, drones, and other autonomous control systems. Here is a great video series so that you can explore these further:<p>YouTube: Brian Douglas – <em class="italic">PID Control – A brief introduction</em>: <a href="https://www.youtube.com/watch?v=UR0hOmjaHp0">https://www.youtube.com/watch?v=UR0hOmjaHp0</a></p></li>
				<li>I've greatly simplified some of the corner-turning algorithms. A very in-depth article on how this was used for a competition-winning LEGO Mindstorms robot holds a more detailed method:<p>GW Lucas – <em class="italic">Using a PID-based Technique For Competitive Odometry and Dead-Reckoning: </em><a href="http://www.seattlerobotics.org/encoder/200108/using_a_pid.html"><em class="italic">http</em>://www.seattlerobotics.org/encoder/200108/using_a_pid.html</a></p></li>
			</ul>
		</div>
	</div></body></html>