- en: Finding Your Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obstacle avoidance is a simple behavior that allows AI entities to reach a target
    point. It's important to note that the specific behavior implemented in this chapter
    is meant to be used for behaviors such as crowd simulation, where the main objective
    of each agent entity is just to avoid the other agents and reach the target. There's
    no consideration of what would be the most efficient and shortest path. We'll
    learn about the A* Pathfinding algorithm in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Path following and steering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom A* Pathfinding implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity's built-in NavMesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following a path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into A*, which is a procedural approach to pathfinding, we'll
    implement a more rudimentary waypoint-based system. While more advanced techniques,
    such as the aforementioned A* method or Unity's NavMesh, will often be the preferred
    method for pathfinding, looking at a simpler, more pure version will help set
    the foundation for understanding more complex pathfinding approaches. Not only
    that, but there are many scenarios in which a waypoint-based system will be more
    than enough, and will allow more fine-tuned control over your AI agent's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a path, which is made up of individual waypoints.
    For our purposes, a waypoint is simply a point in space with an X, Y, and Z value;
    we can simply use a `Vector3` to represent this data. By making a serialized array
    of `Vector3` in our script, we''ll be able to edit the points in the inspector
    without much fuss. If you want to challenge yourself and tweak this system to
    be a bit more user-friendly, you may want to consider using an array of game objects
    instead, and using their position (a `Vector3` ) instead. For demonstration purposes,
    the example provided will stick to the `Vector3` array. After setting up some
    points in our array, we want to end up with a path that looks like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7a9aa21-88e5-4b75-a064-bbd18eb1eefd.png)'
  prefs: []
  type: TYPE_IMG
- en: An object path
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we use some debug lines to draw the connections
    between waypoints. Don't worry, there isn't any magic happening here. By using
    Unity's debug features, we can visualize the path we'll be having our agent traverse.
    Let's deconstruct our `Path.cs` script to see how we achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: The path script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is our `Path.cs` script, which is responsible for managing our waypoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `SerializeField` property can be used to force Unity to serialize a private
    field, and display it in the inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our waypoints'' `Vector3` array is the collection of waypoints in the path
    mentioned earlier. To initialize the waypoints, we must add the script to a game
    object in our scene. In the sample scene, we simply create an empty game object
    and attach the `Path.cs` script to it. For the sake of clarity, we''ve also renamed
    our game object to `Path`. With the `Path` game object ready to go, we can assign
    the path values in the inspector. The sample values look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0964a4e7-6420-4f16-a8a1-120044e65020.png)'
  prefs: []
  type: TYPE_IMG
- en: Path values provided in the sample project
  prefs: []
  type: TYPE_NORMAL
- en: The values in the screenshot here are arbitrary, and can be tweaked to your
    liking. You just need to make sure you have at least two waypoints along your
    path.
  prefs: []
  type: TYPE_NORMAL
- en: The `PathLength` property simply returns the length of our waypoint array. It
    provides a public getter for our private field, and is later used by another script.
    The `radius` variable allows us to define the tolerance for our pathfinding. Rather
    than expecting our agent to be at the precise location of our waypoint, we'll
    use a radius to determine when the agent is *close enough* to consider the waypoint
    visited. The `GetPoint` method is a simple helper to get a waypoint from the array
    at a given index.
  prefs: []
  type: TYPE_NORMAL
- en: It is common and proper practice to make fields `private` by default, especially
    when the data contained is integral to the functionality of the class. In our
    case, the waypoint order, array size, and more should not be modified at runtime,
    so we ensure that external classes can only get data from them by using helper
    methods and properties, and protect them from external changes by making them
    private.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `OnDrawGizmos`, which is a `MonoBehaviour` method that Unity
    automatically calls for us, to draw debug information in the scene view in the
    editor. We can toggle this functionality on and off by setting the value of `isDebug`
    to `true` or `false`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Using the path follower
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll set up our agent to follow the path defined in the previous section.
    We''ll use a simple cube in the example, but feel free to use any art you want.
    Let''s take a closer look at the `Pathing.cs` script provided in the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first group of fields are variables we want serialized so that they can
    be set via the inspector. `path` is a reference to the `Path` object we created
    earlier; we can simply drag and drop the component from the `path` game object
    into this field. `speed` and `mass` are used to calculate the movement of the
    agent along the path. `isLooping` is used to determine whether or not we should
    loop around the path. When true, the agent will reach the last waypoint, then
    go to the first waypoint on the path and start over. Once the values are all assigned,
    the inspector should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37e3073c-4ecc-4d97-8e2f-6c2c3fe32255.png)'
  prefs: []
  type: TYPE_IMG
- en: The pathfinding script inspector with its default values
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Start` method handles the initialization for some of the remaining private
    fields—`direction` and `targetPoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Update` method does a few things for us. First, it does some boilerplate
    null safety checks, it updates the speed of the agent, checks whether the target
    has been reached, calls the `SetNextTarget` method to determine the next target
    point, and finally, applies the direction and rotation changes as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep things nice and readable, we moved some of the functionality out of
    the `Update` method. `TargetReached` is fairly straightforward. It uses the radius
    of `path` to determine if the agent is *close enough* to the target waypoint,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetNextTarget` method is a bit more interesting.  As you can see, it returns
    a `bool`. If we haven''t reached the end of the array, it''ll just increment the
    value, but if the method is unable to set the next point, because we''ve reached
    the end of the array, and `isLooping` is false, it returns false. If you go back
    to our `Update` method for a moment, you''ll see that when this happens, we simply
    return out of `Update` and do nothing. This is because we''ve reached the end
    of the road, and there is nowhere else for our agent to go. In the same scenario,
    but with `isLooping == true` evaluating to true, we reset our next target point
    to the first in the array (0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Steer` method uses the given target point and does some calculations to
    get the new direction and rotation. By subtracting the target point (*b*) from
    the current position (*a*), we get a vector for the direction from *a* to *b*.
    We normalize that vector, then apply the current speed to determine how far to
    move this frame along the new `targetDirection`.  Lastly, we use the mass to ease
    the acceleration between our `targetDirection` and our current direction, and
    return that value as `acceleration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you run the scene, the agent cube will follow the path as expected. If
    you toggle `isLooping` off, the agent will reach the final waypoint and stop there,
    but if you leave it on, the agent will loop around the path infinitely. Try tweaking
    the various settings to see how it affects the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll look at an obstacle avoidance mechanic. To get started, pop open
    the same scene, named `ObstacleAvoidance`. The sample scene is quite straightforward.
    Aside from the camera and directional light, there is a plane with a series of
    blocks that will act as our obstacles, a cube that will act as our agent, and
    a canvas containing some instructional text. The scene will look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57fe2cb7-788a-4b9e-8f71-1d2a7f44ad45.png)'
  prefs: []
  type: TYPE_IMG
- en: The sample scene setup
  prefs: []
  type: TYPE_NORMAL
- en: 'The hierarchy for the preceding scene pictures looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0ee092c-27b6-450d-943c-8988f5a6d3a4.png)'
  prefs: []
  type: TYPE_IMG
- en: The organized hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that this `Agent` object is not a pathfinder. As such, if
    we set too many walls up, our `Agent` might have a hard time finding the target.
    Try a few wall setups and see how our `Agent` performs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our mechanic relies on raycasting to detect obstacles. Rather than just assuming
    every single object is an obstacle, we specifically use a layer named Obstacles
    and filter out everything else. This is not a default layer in Unity, so we have
    to set it up manually. The sample project already has this set up for you, but
    if you wanted to add your own layer, you could access the layer setup window in
    two different ways. The first is through the menus—Edit | **Project Settings**
    | Tags and Layers—and the second method is by selecting the layer dropdown in
    the hierarchy and selecting Add Layer....The following screenshot shows the menu''s
    location in the upper-right corner of the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4de9590a-a78c-40f6-b125-8e3cdf75d258.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Selecting the Tags and Layers menu through the menu shown in the preceding
    screenshot, or through Unity''s menu bar, will open up a window where you can
    freely add, edit, or remove layers (and tags, but we''re not interested in those
    at the moment). Let''s add `Obstacles` in the 8th slot, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/533c8c62-0818-4eaf-a114-585bf6655687.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new layer
  prefs: []
  type: TYPE_NORMAL
- en: 'You should save the project after you make any changes to the settings, but
    there is no dedicated save button for layers specifically. You can now assign
    the layer in the same dropdown in the inspector as the one we just used, as depicted
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a4ce7da-241d-474f-9292-678523a9bcc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Assigning our new layer
  prefs: []
  type: TYPE_NORMAL
- en: Layers are most commonly used by cameras to render a part of the scene, and
    by lights to illuminate only some parts of the scene. But they can also be used
    by raycasting to selectively ignore colliders or create collisions. You can learn
    more about this at [http://docs.unity3d.com/Documentation/Components/Layers.html.](https://docs.unity3d.com/Manual/Layers.html)
  prefs: []
  type: TYPE_NORMAL
- en: Obstacle avoidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our scene is set up, let''s take a look at our avoidance behavior
    script. It contains all the logic for driving our agent, and applies the avoidance
    to the movement of the agent. In the sample project, take a look at the `Avoidance.cs`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll find some familiar field names in the preceding code snippet. Values
    such as movement speed, rotation speed, tolerance radius, and more are similar
    to values we used in our waypoint system. Similarly, we use the `SerializeField` attribute
    to expose our private fields in the inspector for easy editing and assignment,
    while protecting our values from being tampered with by external objects at runtime.
    In the `Start` method, we simply initialize some values. For example, we cache
    a reference to our `Camera.main` here so that we don''t have to do the lookup
    every single time we need a reference to it. Next, let''s look at the `Update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Right off the bat, we call `CheckInput()`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We check whether the user has clicked the left mouse button (by default, it
    is the button mapped to "`0`"). If so, we check for a physics raycast originating
    from the main camera, shooting to the position of the mouse. If we get a positive
    hit, we simply assign the hit point from `mouseHit` to be our new `targetPoint`.
    This is where our agent will attempt to move to. Back to `Update`, we have the
    following lines, right after our `CheckInput()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the direction to our target point, in the same way we did in our
    `Pathing.cs` script, and we normalize that vector so that it has a magnitude of
    no more than 1\. Next, we modify that direction and apply avoidance, by sending
    that direction vector to our `ApplyAvoidance()` method, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Before digging into the preceding code, it's important to understand how Unity
    handles masking layers. As we mentioned earlier, we want our raycast to only hit
    the layers we care about, in this case, our `Obstacles` layer. If you were observant,
    you might have noticed our layer's array has 32 slots, from index 0 to 31\. We
    put our `Obstacles` layer on slot 8 (index 9). The reason for this is that Unity
    represents the layers using a 32-bit int, and each bit represents one of the slots,
    from right to left. Let's break that down visually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to represent a layer mask, where only the first slot (the
    first bit) is active. In this case, we''d assign the bit a value of 1\. It would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you''re still solid on your computer science fundamentals, you''ll remember,
    that in binary, that value translates to an int value of 1\. Let''s say you have
    a mask that only has the first four slots/indices selected. That would like like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once again, converting from binary, it gives us an int value of *15 (1 + 2+
    4 + 8)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our script, we want a mask with only the 9th position active, which would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, doing the math, we know that the int value for that mask is 256\. But
    doing the math manually is inconvenient. Luckily, C# provides some operators to
    manipulate bits. This line in the preceding code does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses a bit shift operator—the left-shift operator, specifically—to create
    our mask. The way it works is fairly straightforward: it takes an int operand
    (the int value on the left-hand side of the expression) with a value of 1, then
    shifts that bit representation to the left eight times. It looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, bitwise operators are helpful, and though they don't always
    lead to very readable code, they're very handy in situations like this one.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find a good discussion on using layermasks on Unity3D online. The
    question-and-answer site can be found at [http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html](http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html).
    Alternatively, you may consider using `LayerMask.GetMask()`, which is Unity's
    built-in method for dealing with named layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, let''s go back to the rest of our `ApplyAvoidance()`
    code. After creating the layer mask, the following lines look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we use a raycast, but this time, the origin is the position of the
    agent, and the direction is its forward vector. You'll also notice that we use
    an overload of the `Physics.Raycast()` method that takes our `layerMask` as an
    argument, meaning our raycast will only hit objects in our obstacles layer. When
    a hit does occur, we get the normal of the surface we hit and calculate the new
    direction vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bit of our `Update` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, you may recognize some of this code, as it's very similar to the code
    used in the `Pathing.cs` script. If we've come within the acceptable radius of
    our destination, we do nothing. Otherwise, we rotate the agent and move it forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sample scene, you can find an `Agent` game object with the `Avoidance.cs`
    script attached. The inspector with all the values assigned will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6145a7df-3c30-4bf1-b6be-bbb983ae9fe8.png)'
  prefs: []
  type: TYPE_IMG
- en: Agent inspector view
  prefs: []
  type: TYPE_NORMAL
- en: Try tweaking the values to see what kinds of results you can get. Simply hit
    play and click around the scene to tell your agent to move. You may notice that,
    even though the agent is intelligently avoiding the obstacles, it won't always
    take the most efficient route to its target destination. That's where A* comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: A* Pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we'll  implement the A* algorithm in a Unity environment using C#.
    The A* Pathfinding algorithm is widely used in games and interactive applications
    even though there are other algorithms, such as Dijkstra's algorithm, because
    of its simplicity and effectiveness. We've briefly covered this algorithm previously,
    in [Chapter 1](070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml), *The Basics of AI
    in Games*, but let's review the algorithm again from an implementation perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the A* algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly touched on the A* algorithm earlier in the book, so let's review
    the basics before we dive into our implementation. For starters, we need to create
    a grid-based representation of our map. The best option for this is a 2D array.
    This grid and all of its associated data will be contained in our `GridManager`
    class. The `GridManager` class will contain a list of `Node` objects that represent
    each cell in our grid. The nodes themselves will contain some additional data
    about themselves, such as their heuristic cost and whether or not they are an
    obstacle node.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to keep two lists—our open list, that is, our list of nodes
    to explore, and our closed list, which will contain nodes we've already visited.
    We'll implement these in our `PriorityQueue` class, which provides some additional
    helper functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, our A* algorithm, implemented in the `AStar` class, must do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin at the starting node and put it in the open list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As long as the open list has some nodes in it, we''ll perform the following
    processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the first node from the open list and keep it as the current node. (This
    is assuming that we've sorted the open list and the first node has the least cost
    value, which will be mentioned at the end of the code.)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the neighboring nodes of this current node that are not obstacle types,
    such as a wall or canyon, that can't be passed through.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each neighbor node, check if this neighbor node is already in the closed
    list. If not, we''ll calculate the total cost (`F`) for this neighbor node using
    the following formula:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding formula, `G` is the total cost from the start node to this
    node and `H` is the total cost from this node to the final target node.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: Store this cost data in the neighbor node object. Also, store the current node
    as the parent node as well. Later, we'll use this parent node data to trace back
    the actual path.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Put this neighbor node in the open list. Sort the open list in ascending order,
    ordered by the total cost to reach the target node.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no more neighbor nodes to process, put the current node in the
    closed list and remove it from the open list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to step 2 using the next node in the open list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have completed this process, your current node should be in the target
    goal node position, but only if there's an obstacle-free path to reach the goal
    node from the start node. If it is not at the goal node, there's no available
    path to the target node from the current node position. If there's a valid path,
    all we have to do now is trace back from the current node's parent node until
    we reach the start node again. This will give us a path list of all the nodes
    that we chose during our pathfinding process, ordered from the target node to
    the start node. We then just reverse this path list, since we want to know the
    path from the start node to the target goal node.
  prefs: []
  type: TYPE_NORMAL
- en: This is a general overview of the algorithm we're going to implement in Unity
    using C#. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get started with A*, we''ll have to take the concepts and apply
    them as concrete implementations in the code. In our sample code, we break the
    A* system into a few key components: the `Node`, `GridManager`, `PriorityQueue`,
    and `AStart` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's break down what each class does in the following few sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Node class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can think of the `Node` class as a container for all of the relevant information
    about each tile in our grid. We store information about things such as the cost
    of the node, the parent of the node, and its position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In code, we represent our G and H costs as `gCost` and `hCost`, respectively.
    G refers to the cost from the start node to this node, and H refers to the estimated
    cost from this node to the end node. Depending on how comfortable you get with
    A*, you might consider renaming them something a bit more descriptive. In our
    example, we want to adhere as closely as possible to the *on paper* version of
    the names of concepts, for the purpose of explaining the C# implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The class provides a simple constructor that takes no arguments, and one overload
    that takes in a position, which prepopulates the position field with the passed-in
    value. There's nothing too fancy here.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that our class implements the `IComparable` interface,
    which requires us to implement the `CompareTo()` method to satisfy the interface
    contract requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of an interface as a contract. On its own, it does nothing. You
    cannot implement any logic in an interface. By inheriting from an interface, you're
    simply agreeing to implement all the methods with the provided signatures in the
    implementing class. That way, any other class that wants to call a given method
    from an interface on your class can assume that the method exists.
  prefs: []
  type: TYPE_NORMAL
- en: The actual implementation of the method compares the given node to this node
    based on their `hCost`. We'll take a look at its usage later on.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the priority queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We represent our open and closed list using the `PriorityQueue` class. This
    approach allows us to implement some helper methods for our own convenience. The
    `PriorityClass.cs` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There isn't much of note in this code, but the `Sort()` method in particular
    is interesting. Remember the `CompareTo()` method in the `Node` class? The `ArrayList.Sort()`
    actually relies on the implementation of `CompareTo()` in the node class to sort
    the array. More specifically, it will sort according to the node's `hCost`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our grid manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GridManager` class does a lot of the heavy lifting in terms of arranging
    and visualizing our grid. Compared to some of the code we''ve seen so far in this
    book, it''s a fairly lengthy class, since it provides several helper methods.
    Pop open the `GridManager.cs` class to follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start off by setting up some variables. We specify how many rows and columns
    are in our grid, and we specify their size (in world units). There isn't much
    else of note here, but we should point out that the `Node[,]` syntax indicates
    that we are initializing a 2D array of `nodes`, which makes sense, since a grid
    is a 2D array itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Awake` method, we see the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply initializes the `obstacleList` game object array by finding things
    tagged as `"Obstacle"`. `Awake` then calls two setup methods: `InitializeNodes()`
    and `CalculateObstacles()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The names of these methods are to the point, so as you may have guessed, `InitializeNodes()`
    initializes our nodes, and does so by populating the `nodes` 2D array. This code
    invokes a helper method, `GetGridCellCenter()`, which we''ll look at later on,
    but the approach is fairly straightforward. We loop through the 2D array, column
    by column and row by row, and we create nodes spaced apart according to the grid
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `CalculateObstacles()` method simply runs through the list of obstacles
    we initialized during `Awake`, determines which grid slot the obstacle occupies,
    and marks the node at that grid slot as an obstacle using `MarkAsObtacle()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GridManager` class has a few helper methods to traverse the grid and get
    the grid cell data. The following is a list of some of them with brief descriptions
    of what they do. The implementation is simple, so we won''t go into the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetGridCellCenter`: Given an index for a cell, it returns the center position
    (in world space) of that cell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetGridCellPositionAtIndex`: Returns the origin position of the cell (the
    corner). Used as a helper for `GetGridCellCenter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetGridIndex`: Given a position (as a `Vector3` in world space), it returns
    the cell closest to the position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetRowOfIndex` and `GetColumnOfIndex`: Just as the names say, they return
    the row or column of the cell at the given index. For example, in a 2 x 2 grid,
    the cell at index 2 (starting from 0), would be in row 2, column 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have some methods that help with figuring out the neighbors to a given
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we have `GetNeighbors()`, which uses the given node's position in the
    grid to figure out which cells are to the bottom, top, right, and left of it.
    It assigns the node as a neighbor using `AssignNeighbor()`, which does some validation,
    such as checking that the potential neighbor is within bounds (of the array),
    and that the neighbor is not marked as an obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have `OnDrawGizmos()` and `DebugDrawGrid()`, which display the grid
    of the size we specified in our scene view for debugging. Next up, the meat and
    potatoes. We tie it all together with our `AStar` class.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into our A* implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AStar` class is the actual implementation of the A* algorithm. This is
    where the magic happens. The code in the `AStar.cs` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There is quite a bit to go over here, so let''s break it down, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We start off by declaring our open and closed lists, which will contain visited
    and non-visited nodes, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implement a method called `EstimateHeuristicCost`
    to calculate the cost between the two given nodes. The calculation is simple.
    We just find the direction vector between the two by subtracting one position
    vector from another. The magnitude of this resultant vector gives the direct distance
    from the current node to the goal node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have our `FindPath` method, which does most of the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It initializes our open and closed lists. At first, we'll only have the starting
    node in our `openList`. We also initialize the `gCost`, which is zero, because
    the distance to the starting node (itself) is zero. We then assign the `hCost`
    using the `EstimateHeuristicCost()` method we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need a reference to our `GridManager` going forward, so we get it using
    `FindObjectOfType()` and do some null checking. Next, we begin processing the
    open list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code implementation resembles the  A* algorithm that we have previously
    discussed. This would be a good time to brush up on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In plain English, the preceding code can be described as following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the first node of our `openList`. Keep in mind that our `openList` is always
    sorted after a new node is added so that the first node is always the node with
    the lowest estimated cost to the goal node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the current node is already at the goal node. If so, exit the
    `while` loop and build the `path` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array list to store the neighboring nodes of the current node being
    processed. Use the `GetNeighbors()` method to retrieve the neighbors from the
    grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For every node in the `neighbors` array, we check whether it's already in the `closedList`.
    If not, we calculate the cost values, update the node properties with the new
    cost values as well as the parent node data, and put it in `openList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the current node to `closedList` and remove it from `openList`. Rinse and
    repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there are no more nodes in the `openList`, our current node should be at
    the target node if there''s a valid path available. Then, we just call the `CalculatePath()` method
    with the current node as the argument. The `CalcualtePath()` method looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `CalculatePath` method traces through each node's parent node object and
    builds an array list. This gives us an array list with nodes from the target node
    to the start node. Since we want a path array from the start node to the target
    node, we just call the `Reverse` method. And that's it! With our algorithm and
    helper classes out of the way, we can move on to our test script, which ties it
    all together.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a TestCode class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the A* algorithm implemented via our `AStar` class (and the
    associated helper classes), we actually implement it using the `TestCode` class.
    The `TestCode.cs` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare our variables here, and once again set up a variable to hold a reference
    to our `GridManager`. Then, the `Start` method does some initialization and fires
    off our `FindPath()` method, as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Update` method, we check for the path at intervals, which is a brute
    force approach to refreshing the path if the goal moves at runtime. You may want
    to consider implementing this code using an event to avoid unnecessary overhead
    in every frame (or interval, in this case).  The `FindPath()` method called in
    `Start` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, it takes the positions of our start and end game objects. Then, it creates
    new `Node` objects using the helper methods `GridManager` and `GetGridIndex` to
    calculate their respective row and column index positions inside the grid. With
    those necessary values ready to go, we just call the `AStar.FindPath` method with
    the start node and goal node, and store the returned array list in the local `pathArray` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement the `OnDrawGizmos` method to draw and visualize the path
    found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We look through our `pathArray` and use the `Debug.DrawLine` method to draw
    the lines connecting the nodes from the `pathArray`. With this, we'll be able
    to see a green line connecting the nodes from start to end, forming a path, when
    we run and test our game.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it in the sample scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sample scene looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bf044e3-b835-4b83-a532-d91330a844ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Our sample scene with the pathfinding grid drawn over it
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, there is a red starting node, a
    green goal node, a plane, and some light grey obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is a snapshot of our scene hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbba19a3-4926-4f98-a3a6-1c838fb01703.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few things to note in the preceding screenshot (and yes, you can
    ignore the Directional light, as it''s just here to make our scene look pretty).
    First, we have grouped all of our obstacles under a parent `Obstacles` transform.
    Second, we have separate game objects for our `TestCode` class and our `GridManager`
    class as children under the `Scripts` game object. As you saw in the code sample
    earlier, there are some fields exposed in the `GridManager`, which should look
    like the following screenshot in our sample scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55d90b5e-b284-45aa-89fa-8cadb8d5b5db.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the previous screenshot, we have Show Grid ticked to true.
    This will enable us to see the grid in the scene view.
  prefs: []
  type: TYPE_NORMAL
- en: Testing all the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve looked at how everything is wired up, hit the play button and
    observe how a path will be drawn from our start node to our goal node, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2787783f-c474-4af1-9961-a2922a66afc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we''re checking for the path at intervals inside the `Update` loop, we
    can move the goal node in play mode, and see the path updated. The following screenshot
    shows the new path after moving our goal node to a different location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5df973a4-dca9-429c-a40d-da569c2122c2.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, since the goal is closer, so is the most optimal path to reach
    it. In a little more than a nutshell, that is A*. A very powerful algorithm can
    be distilled down to a few classes totaling a few hundred lines of code (with
    most of it due to formatting and commenting).
  prefs: []
  type: TYPE_NORMAL
- en: A* vs IDA*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml), *The Basics of AI
    in Games*, we mentioned some of the differences between A* and IDA*. Now that
    you've implemented A*, you can see that the A* implementation keeps a few things
    in memory—the path array, the open list, and the closed list. At different points
    in the implementation, you may allocate more or less memory as you iterate through
    your lists. In this regard, A* is greedier than IDA*, but keep in mind that in
    most cases, on modern hardware, this is not an issue—even with much larger grids
    than ours.
  prefs: []
  type: TYPE_NORMAL
- en: The IDA* approach only looks at the the current iteration's adjacent/neighbor
    spots, and because it keeps no record of the visited nodes, it may end up visiting
    the same node multiple times. In similar circumstances, this means a much lower
    memory overhead than the faster A* version.
  prefs: []
  type: TYPE_NORMAL
- en: While the point can be argued, it is this humble author's opinion that IDA*
    is not a relevant pattern in modern game development—even on resource-conscious
    applications, such as mobile games. In other fields, one could make a stronger
    case for the iterative deepening approach, but, fortunately, even aging mobile
    devices have copious amounts of memory relative to the needs of the 99% of games
    that will implement some sort of pathfinding.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll learn how to use Unity's built-in navigation mesh generator that
    can make pathfinding for AI agents a lot easier. Early in the Unity 5.x cycle,
    NavMesh was made available to all users, including personal edition licensees,
    whereas it was previously a Unity Pro-only feature. Before the release of 2017.1,
    the system was upgraded to allow a component-based workflow, but as it requires
    an additional downloadable package that, at the time of writing is only available
    as a preview, we will stick to the default scene-based workflow. Don't worry,
    the concepts carry over, and when the final implementation eventually makes its
    way to 2017.x, there shouldn't be drastic changes.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Unity's NavMesh component system, head over to GitHub: [https://github.com/Unity-Technologies/NavMeshComponents](https://github.com/Unity-Technologies/NavMeshComponents).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will dive in and explore all that this system has to offer. AI pathfinding
    needs a representation of the scene in a particular format; we've seen that using
    a 2D grid (array) for A* Pathfinding on a 2D map. AI agents need to know where
    the obstacles are, especially the static obstacles. Dealing with collision avoidance
    between dynamically moving objects is another subject, primarily known as steering
    behaviors. Unity has a built-in tool for generating a NavMesh that represents
    the scene in a context that makes sense for our AI agents to find the optimum
    path to the target. Pop open the demo project and navigate to the NavMesh scene
    to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting our map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have the demo scene, NavMesh, open, it should look something like
    this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02e11547-8b78-46c9-9dc8-c33d3dc12349.png)'
  prefs: []
  type: TYPE_IMG
- en: A scene with obstacles and slopes
  prefs: []
  type: TYPE_NORMAL
- en: This will be our sandbox to explain and test the NavMesh system functionality.
    The general setup is similar to an RTS (real-time strategy) game. You control
    the blue tank. Simply click at a location to make the tank move to that location.
    The yellow indicator is the current target location for the tank.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation Static
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to point out is that you need to mark any geometry in the scene
    that will be baked into the NavMesh as Navigation Static. You may have encountered
    this elsewhere, such as in Unity''s light-mapping system, for example. Setting
    game objects as static is easy. You can easily toggle the `Static` flag on for
    all purposes (navigation, lighting, culling, batching and so on), or you can use
    the dropdown to specifically select what you want. The toggle is found in the
    top-right corner of the inspector for the selected object(s). Look at this screenshot
    for a general idea of what you''re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0161c6b5-9d49-441d-95d0-2ae159fb52bf.png)'
  prefs: []
  type: TYPE_IMG
- en: The Navigation Static property
  prefs: []
  type: TYPE_NORMAL
- en: You can do this on a per-object basis, or, if you have a nested hierarchy of
    game objects in your hierarchy, you can apply the setting to the parent and Unity
    will prompt you to apply it to all children.
  prefs: []
  type: TYPE_NORMAL
- en: Baking the navigation mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The navigation settings for the navigation mesh are applied via the Navigation
    window on a scene-wide basis. You can open the window by navigating to **Window**
    | Navigation in the menu bar. Like any other window, you can detach it to be free-floating,
    or you can dock it. Our screenshots show it docked as a tab next to the hierarchy,
    but you can place this window anywhere you please.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the window open, you''ll notice four separate tabs. It''ll look something
    like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68e75312-5685-42a9-96e3-b01c3f0626d0.png)'
  prefs: []
  type: TYPE_IMG
- en: The Navigation window
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the preceding screenshot shows the Bake tab selected, but your
    editor might have one of the other tabs selected by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at each tab, starting from the left and working our way
    to the right, starting with the Agents tab, which looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a779bdea-6e25-4b36-9b20-3755c36c7b83.png)'
  prefs: []
  type: TYPE_IMG
- en: The Agents tab
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re working on a different project, you may find that some of these
    settings are different than what we set them to in the sample project from which
    the preceding screenshot was taken. At the top of the tab, you can see a list
    where you can add additional agent types by pressing the "+" button. You can remove
    any of these additional agents by selecting it and pressing the "-" button. The
    window provides a nice visual of what the various settings do as you tweak them.
    Let''s take a look at what each setting does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The name of the agent type to be displayed in the Agent Types dropdown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radius**: Think of it as the agent''s "personal space". Agents will try to
    avoid getting too cozy with other agents based on this value, as it uses it for
    avoidance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: As you may have guessed, it dictates the height of the agent, which
    it can use for vertical avoidance (passing under things, for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Height**: This value determines how high of an obstacle the agent can
    climb over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Slope**: As we''ll see in the coming section, this value determines the
    max angle up which an agent can climb. This can be used to make steep areas of
    the map inaccessible to the agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have the Areas tab, which looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b31fe55-c3a0-472e-87cd-78a44d7518d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, Unity provides some default area
    types that cannot be edited: Walkable, Not Walkable, and Jump. In addition to
    naming and creating new areas, you can assign default costs to these areas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Areas serve two purposes: making areas accessible or inaccessible per agent,
    and marking areas as less desirable in terms of navigation cost. For example,
    you may have an RPG where demon enemies cannot enter areas marked as "holy ground."
    You could also have areas of your map marked something like "marsh" or "swamp,"
    which your agent could avoid based on the cost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third tab, Bake, is probably the most important. It allows you to create
    the actual NavMesh for your scene. You''ll recognize some of the settings. The
    Bake tab looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9482433-91a8-4304-89d5-7925486b76e0.png)'
  prefs: []
  type: TYPE_IMG
- en: The Bake tab
  prefs: []
  type: TYPE_NORMAL
- en: The agent size settings in this tab dictate how agents interact with the environment,
    whereas the settings in the Agents tab dictate how they interact with other agents
    and moving objects, but they control the same parameters, so we'll skip those
    here. The Drop Height and Jump Distance control how far an agent can "jump" to
    reach a portion of the NavMesh that is not directly connected to the one the agent
    is currently on. We'll go over this in more detail up ahead, so don't sweat it
    if you're not quite sure what that means yet.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some advanced settings that are generally collapsed by default.
    Simply click the drop-down triangle by the Advanced heading to unfold these options.
    You can think of the Manual Voxel Size setting as the "quality" setting. The smaller
    the size, the more detail you can capture in the mesh. The Min Region Area is
    used to skip baking platforms or surfaces below the given threshold. The Height
    Mesh gives you more detailed vertical data when baking the mesh. For example,
    it will help preserve the proper placement of your agent when climbing up stairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Clear button will clear any NavMesh data for the scene, and the Bake button
    will create the mesh for your scene. The process is fairly fast. As long as you
    have the window selected, you''ll be able to see the NavMesh generated by the
    Bake button in your scene view. Go ahead and hit the Bake button to see the results.
    In our sample scene, you should end up with something that looks like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/635a02ba-4a0d-4ee6-9277-a65afb81f0f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The blue areas represent the NavMesh. We''ll revisit this up ahead. For now,
    let''s move on to the final tab, the Object tab, which looks like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5ffe1e0-94f7-4695-8040-59605f694720.png)'
  prefs: []
  type: TYPE_IMG
- en: The three buttons pictured in the preceding screenshot, All, Mesh Renderers,
    and Terrains, act as filters for your scene. These are helpful when working in
    complex scenes with lots of objects in the hierarchy. Selecting an option will
    filter out that type in your hierarchy to make them easier to select. You can
    use this when digging through your scene looking for objects to mark as navigation
    static.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NavMesh agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our scene set up with a NavMesh, we need a way for our agent
    to use this information. Luckily for us, Unity provides a Nav Mesh Agent component
    we can throw onto our character. The sample scene has a game object named `Tank` with
    the component already attached to it. Take a look at it in the hierarchy, and
    it should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/499a8c22-cba6-4488-bef5-93251b35904d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are quite a few settings here, and we won''t go over all of them, since
    they''re fairly self-explanatory and you can find the full descriptions in the
    official Unity documentation, but let''s point out a few key things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Agent Type: Remember the Agents tab in the Navigation window? The agent types
    you define there will be selectable here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Auto Traverse Off Mesh Link: We''ll get into Off Mesh Links up ahead, but this
    setting allows the agent to automatically use that feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Area Mask: The areas you set up in the Areas tab of the Navigation window will
    be selectable here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s it. The component handles 90% of the heavy lifting for you: placement
    on the path, pathfinding, obstacle avoidance, and so on. The only thing you need
    to do is provide the agent with a target destination. Let''s look at that next.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a destination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've set up our AI agent, we need a way to tell it where to go. Our
    sample project provides a script named `Target.cs` that does just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple class that does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Shoots a ray from the camera origin to the mouse world position using a ray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the marker position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the destination property of all the NavMesh agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is fairly straightforward. The entire class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things happening here. In the `Start` method, we initialize
    our `navAgents` array by using the `FindObjectsOfType()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateTargets()` method runs through our `navAgents` array and sets their
    target destination to the given `Vector3`. This is really the key to making it
    work. You can use any mechanism you wish to actually get the target destination,
    and all you need to do to get the agent to move there is set the `NavMeshAgent.destination`
    field; the agent will do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample uses a click-to-move approach, so whenever the player clicks, we
    shoot a ray from the camera into the world towards the mouse cursor, and if we
    hit something, we assign that hit position as the new `targetPosition` for the
    agent. We also set the target marker accordingly for easy in-game visualization
    of the target destination.
  prefs: []
  type: TYPE_NORMAL
- en: To test it out, make sure you baked the NavMesh as described in the previous
    section, then enter play mode, and select any area on the map. If you go click-happy,
    you may notice there are some areas your agent *can't *reach—the top of the red
    cubes, the top-most platform, and the platform towards the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the red cubes, they''re too far up. The ramp leading up to the
    top-most platform is too steep, as per our Max Slope settings, and the agent can''t
    climb up to it. The following screenshots illustrate how the Max Slope settings
    affect the NavMesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/904da452-21f6-4b35-a585-2345c9ba07c3.png)'
  prefs: []
  type: TYPE_IMG
- en: NavMesh with the max slope value set to 45
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tweak the Max Slope to something like 51, then hit the Bake button again
    to re-bake the NavMesh, it will yield results like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54e13722-f590-42e5-ba54-3183912d0e99.png)'
  prefs: []
  type: TYPE_IMG
- en: NavMesh with the max slope value set to 51
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can tweak your level design to make entire areas inaccessible
    by foot with a simple value tweak. An example where this would be helpful is if
    you had a platform or ledge that you need a rope, ladder, or elevator to get to.
    Maybe even a special skill, such as the ability to climb? I'll let your imagination
    do the work and think of all the fun ways to use this.
  prefs: []
  type: TYPE_NORMAL
- en: Making sense of Off Mesh Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that our scene features two gaps. The first one is accessible
    to our agent, but the one near the bottom of the screen is too far away. This
    is not completely arbitrary. Unity''s **Off Mesh Links **effectively bridge the
    gap between segments of the NavMesh that are not connected. You can see these
    links in the editor, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4693841c-e10a-4d94-af62-ffd22c91c00f.png)'
  prefs: []
  type: TYPE_IMG
- en: The blue circles with the connecting lines are links
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways that Unity can generate these links. The first we've already
    covered. Remember the Jump Distance value in the Bake tab of the Navigation window?
    Unity will automatically use that value to generate the links for us when baking
    the NavMesh. Try tweaking the value in our test scene to 5 and re-baking. Notice
    how, now, the platforms are linked? That's because the meshes are within the newly-specified
    threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the value back to 2 and re-bake. Now, let''s look at the second method.
    Create spheres that will be used to connect the two platforms. Place them roughly
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb8605c-b1bf-415e-bd12-df06565ec324.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may already see where this is going, but let''s walk through the process
    to get these connected. In this case, I''ve named the sphere on the right `start`,
    and the sphere on the left `end`. You''ll see why in a second. Next up, add the
    Off Mesh Link component on the platform on the right (relative to the preceding
    screenshot). You''ll notice the component has `start` and `end` fields. As you
    may have guessed, we''re going to drop the spheres we created earlier into their
    respective slots—the start sphere in the `start` field, and the end sphere in
    the `end` field. Our inspector will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc74506a-1d1a-4785-88a9-5ccf1d71e15d.png)'
  prefs: []
  type: TYPE_IMG
- en: The Cost Override value kicks in when you set it to a positive number. It will
    apply a cost multiplier to using this link, as opposed to, potentially, a more
    cost-effective route to the target.
  prefs: []
  type: TYPE_NORMAL
- en: The Bi Directional value allows the agent to move in both directions when set
    to true. You can turn this off to create one-way links in your level design. The
    Activated value is just what it says. When set to false, the agent will ignore
    this link. You can turn it on and off to create gameplay scenarios where the player
    has to hit a switch to activate it, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t have to re-bake to enable this link. Take a look at your NavMesh
    and you''ll see that it looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20e91bab-332b-4d17-95f5-69100fbe091e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the smaller gap is still automatically connected, and now we
    have a new link generated by our Off Mesh Link component between the two spheres.
    Enter play mode and click on the far platform, and, as expected, the agent can
    now navigate to the detached platform, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97ffd6be-d9c6-45ad-9478-ab8bff38fa9e.png)'
  prefs: []
  type: TYPE_IMG
- en: In your own levels, you may need to tweak these settings to get the exact results
    you expect, but combining these features gives you a lot of power out-of-the-box.
    You can have a simple game up and running fairly quickly using Unity's NavMesh
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now navigated your way to the end of this chapter (pun unapologetically
    intended). From simple waypoints, to the efficient and fast A* algorithm, to Unity's
    own powerful and robust NavMesh system, we've added some important and flexible
    tools to your game-making toolbelt. Not only do these concepts play well with
    each other, but they also work well with other systems we've already seen in this
    book, and we'll explore in those next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter,we'll start to look at how we can create efficient and realistic
    simulations for groups of agents that need to move in unison. Let's get to it!
  prefs: []
  type: TYPE_NORMAL
