- en: Behavior Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavior trees** (**BTs**) have been gaining popularity among game developers
    very steadily. Over the last decade, BTs have become the pattern of choice for
    many developers when it comes to implementing behavioral rules for their AI agents.
    Games such as *Halo* and *Gears of War* are among the more famous franchises to
    make extensive use of BTs. An abundance of computing power in PCs, gaming consoles,
    and mobile devices has made them a good option for implementing AI in games of
    all types and scopes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of a behavior tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of using existing behavior tree solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement our own behavior tree framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a basic tree using our framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of behavior trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behavior trees got their name from their hierarchical, branching system of
    nodes with a common parent, known as the root. As you''ve surely learned by now from
    reading this book, behavior trees too mimic the real thing they are named after—in
    this case, trees and their branching structure. If we were to visualize a behavior
    tree, it would look something like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fb25fdb-a320-469f-bc7a-41275648a156.png)'
  prefs: []
  type: TYPE_IMG
- en: A basic tree structure
  prefs: []
  type: TYPE_NORMAL
- en: Of course, behavior trees can be made up of any number of nodes and child nodes.
    The nodes at the very end of the hierarchy are referred to as leaf nodes, just
    like a tree. Nodes can represent behaviors or tests. Unlike state machines, which
    rely on transition rules to traverse through them, a BT's flow is defined strictly
    by each node's order within the larger hierarchy. A BT begins evaluating from
    the top of the tree (based on the preceding visualization), then continues through
    each child, which, in turn, runs through each of its children until a condition
    is met or the leaf node is reached. BTs always begin evaluating from the root
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding different node types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The names of the different types of node may vary depending on who you ask,
    and even nodes themselves are sometimes referred to as tasks. While the complexity
    of a tree is dependent entirely upon the needs of the AI, the high-level concepts
    about how BTs work are fairly easy to understand if we look at each component
    individually. The following is true for each node regardless of what type of node
    we''re referring to. A node will always return one of the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Success**: The condition the node was checking for has been met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failure**: The condition the node was checking for was not, and will not,
    be met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running**: The validity of the condition the node is checking for has not
    been determined. Think of this as our "please wait" state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the potential complexity of a BT, most implementations are asynchronous,
    which, at least for Unity, means that evaluating a tree will not block the game
    from continuing other operations. The evaluation process of the various nodes
    in a BT can take several frames, if necessary. If you had to evaluate several
    trees on any number of agents at a time, you can imagine how it would negatively
    affect the performance of the program to have to wait for each of them to return
    a true or false to the root node. This is why the "running" state is important.
  prefs: []
  type: TYPE_NORMAL
- en: Defining composite nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composite nodes are called so as they have one or more children. Their state
    is based entirely upon the result of evaluating their children, and while their
    children are being evaluated, they will be in a "running" state. There are a couple
    of composite node types, which are mostly defined by how their children are evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequences**: The defining characteristic of a sequence is that the entire
    sequence of children needs to complete successfully in order for it to evaluate
    as a success itself. If any of the children at any step of the sequence return
    false, the sequence itself will report a failure. It is important to note that,
    in general, sequences are executed from left to right. The following figures show
    a successful sequence and a failed sequence, respectively:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b830e1a0-c291-4a84-a362-6692b4382d0c.png)'
  prefs: []
  type: TYPE_IMG
- en: A successful sequence node
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/713f4462-2fe4-48ae-b937-c0d4f1e675d0.png)'
  prefs: []
  type: TYPE_IMG
- en: An unsuccessful sequence node
  prefs: []
  type: TYPE_NORMAL
- en: '**Selectors**: By comparison, selectors are much more forgiving parents to
    their children nodes. If any one of the children nodes in a selector sequence
    returns true, the selector says, "eh, good enough!" and returns true immediately,
    without evaluating any more of its children. The only way a selector node will
    return false is if all of its children are evaluated and none of them return a
    success.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, each composite node type has its use depending on the situation.
    You can think of the different types of sequence nodes as "and" and "or" conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding decorator nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The biggest difference between a composite node and a decorator node is that
    a decorator can have exactly one child, and one child only. At first, this may
    seem unnecessary as you would, in theory, be able to get the same functionality
    by containing the condition in the node itself rather than relying on its child,
    but the decorator node is special in that it essentially takes the state returned
    by the child and evaluates the response based on its own parameters. A decorator
    can even specify how its children are evaluated and how often they are evaluated.
    These are some common decorator types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inverter**: Think of the inverter as a NOT modifier. It takes the opposite
    of the state returned by its child. For example, if the child returns TRUE, the
    decorator evaluates as FALSE, and vice versa. This is the equivalent of having
    the `!` operator in front of a Boolean in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeater**: This repeats the evaluation of the child a specified (or infinite)
    number of times until it evaluates as either TRUE or FALSE as determined by the
    decorator. For example, you may want to wait indefinitely until a certain condition
    is met, such as "having enough energy" before a character uses an attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limiter**: This simply limits the number of times a node will be evaluated
    to avoid getting an agent stuck in an awkward infinite behavior loop. This decorator,
    in contrast to the repeater, can be used to make sure a character only tries to,
    for example, kick the door open so many times before giving up and trying something
    else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some decorator nodes can be used for debugging and testing your trees, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fake state**: This always evaluates true or false as specified by the decorator.
    This is very helpful for asserting certain behavior in your agent. For example,
    you can also have the decorator maintain a fake "running" state indefinitely to
    see how other agents around it will behave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breakpoint**: Just like a breakpoint in code, you can have this node fire
    off logic to notify you via debug logs or other methods that the node has been
    reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types are not monolithic archetypes that are mutually exclusive. You can
    combine these types of nodes to suit your needs. Just be careful not to combine
    too much functionality into one decorator to the point where it may be more efficient
    or convenient to use a sequence node instead.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the leaf node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly covered leaf nodes earlier in the chapter to make a point about the
    structure of a BT, but leaf nodes, in reality, can be just about any sort of behavior.
    They are magical in the sense that they can be used to describe any sort of logic
    your agent can have. A leaf node can specify a walk function, shoot command, or
    kick action. It doesn't matter what it does or how you decide to have it evaluate
    its states, it just has to be the last node in its own hierarchy and return any
    of the three states a node can return.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the existing solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unity asset store is an excellent resource for developers. Not only are
    you able to purchase art, audio, and other kinds of assets, but it is also populated
    with a large number of plugins and frameworks. Most relevant to our purposes,
    there are a number of behavior tree plugins available on the asset store, ranging
    from free to a few hundred dollars. Most, if not all, provide some sort of GUI
    to make visualizing and arranging a fairly painless experience.
  prefs: []
  type: TYPE_NORMAL
- en: There are many advantages of going with an off-the-shelf solution from the asset
    store. Many of the frameworks include advanced functionality such as runtime (and
    often visual) debugging, robust APIs, serialization, and data-oriented tree support.
    Many even include sample leaf logic nodes to use in your game, minimizing the
    amount of coding you have to do to get up and running.
  prefs: []
  type: TYPE_NORMAL
- en: The previous edition of this book, *Unity 4.x Game AI Programming*, focused
    on developer AngryAnt's Behave plugin, which is currently available as Behave
    2 for Unity on the asset store as a paid plugin, which continues to be an excellent
    choice for your behavior tree needs (and so much more). It is a very robust, performant,
    and excellently designed framework.
  prefs: []
  type: TYPE_NORMAL
- en: Some other alternatives are **Behavior Machine** and **Behavior Designer**,
    which offer different pricing tiers (Behavior Machine even offers a free edition)
    and a wide array of useful features. Many other options can be found for free
    around the web as both generic C# and Unity-specific implementations. Ultimately,
    as with any other system, the choice of rolling your own or using an existing
    solution will depend on your time, budget, and project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a basic behavior tree framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a fully-fledged implementation of a behavior tree with a GUI and its many
    node types and variations is outside the scope of this book, we can certainly
    focus on the core principles to get a solid grasp of what the concepts we've covered
    in this chapter look like in action. Provided with this chapter is the basic framework
    for a behavior tree. Our example will focus on simple logic to highlight the functionality
    of the tree, rather than muddy up the example with complex game logic. The goal
    of our example is to make you feel comfortable with what can seem like an intimidating
    concept in game AI, and give you the necessary tools to build your own tree and
    expand upon the provided code if you do so.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a base Node class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a base functionality that needs to go into every node. Our simple
    framework will have all the nodes derived from a base abstract `Node.cs` class.
    This class will provide said base functionality or at least the signature to expand
    upon that functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The class is fairly simple. Think of `Node.cs` as a blueprint for all the other
    node types to be built upon. We begin with the `NodeReturn` delegate, which is
    not implemented in our example, but the next two fields are. However, `m_nodeState`
    is the state of a node at any given point. As we learned earlier, it will be either
    `FAILURE`, `SUCCESS`, or `RUNNING`. The `nodeState` value is simply a getter for
    `m_nodeState` since it is protected and we don't want any other area of the code
    directly setting `m_nodeState` inadvertently.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have an empty constructor, for the sake of being explicit, even though
    it is not being used. Lastly, we have the meat and potatoes of our `Node.cs` class—the
    `Evaluate()` method. As we'll see in the classes that implement `Node.cs`, `Evaluate()`
    is where the magic happens. It runs the code that determines the state of the
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Extending nodes to selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a selector, we simply expand upon the functionality that we described
    in the `Node.cs` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned earlier in the chapter, selectors are composite nodes: this means
    that they have one or more child nodes. These child nodes are stored in the `m_nodes
    List<Node>` variable. Although it''s conceivable that one could extend the functionality
    of this class to allow adding more child nodes after the class has been instantiated,
    we initially provide this list via the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: The next portion of the code is a bit more interesting as it shows us a real
    implementation of the concepts we learned earlier. The `Evaluate()` method runs
    through all of its child nodes and evaluates each one individually. As a failure
    doesn't necessarily mean a failure for the entire selector, if one of the children
    returns `FAILURE`, we simply continue on to the next one. Inversely, if any child
    returns `SUCCESS`, then we're all set; we can set this node's state accordingly
    and return that value. If we make it through the entire list of child nodes and
    none of them have returned `SUCCESS`, then we can essentially determine that the
    entire selector has failed and we assign and return a `FAILURE` state.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequences are very similar in their implementation, but as you might have guessed
    by now, the `Evaluate()` method behaves differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Evaluate()` method in a sequence will need to return true for all the child
    nodes, and if any one of them fails during the process, the entire sequence fails,
    which is why we check for `FAILURE` first and set and report it accordingly. A
    `SUCCESS` state simply means we get to live to fight another day, and we continue
    on to the next child node. If any of the child nodes are determined to be in the
    `RUNNING` state, we report that as the state for the node, and then the parent
    node or the logic driving the entire tree can evaluate it again.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a decorator as an inverter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of `Inverter.cs` is a bit different, but it derives from `Node`,
    just like the rest of the nodes. Let''s take a look at the code and spot the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, since a decorator only has one child, we don't have `List<Node>`,
    but rather a single node variable, `m_node`. We pass this node in via the constructor
    (essentially requiring it), but there is no reason you couldn't modify this code
    to provide an empty constructor and a method to assign the child node after instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Evalute()` implementation implements the behavior of an inverter that
    we described earlier in the chapter: when the child evaluates as `SUCCESS`, the
    inverter reports a `FAILURE`, and when the child evaluates as `FAILURE`, the inverter
    reports a `SUCCESS`. The `RUNNING` state is reported normally.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a generic action node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we arrive at `ActionNode.cs`, which is a generic leaf node to pass in some
    logic via a delegate. You are free to implement leaf nodes in any way that fits
    your logic, as long as it derives from `Node`. This particular example is equal
    parts flexible and restrictive. It''s flexible in the sense that it allows you
    to pass in any method matching the delegate signature, but is restrictive for
    this very reason—it only provides one delegate signature that doesn''t take in
    any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The key for making this node work is the `m_action` delegate. For those familiar
    with C++, a delegate in C# can be thought of as a function pointer of sorts. You
    can also think of a delegate as a variable containing (or more accurately, pointing
    to) a function. This allows you to set the function to be called at runtime. The
    constructor requires you to pass in a method matching its signature, and is expecting
    that method to return a `NodeStates` enum. That method can implement any logic
    you want, as long as these conditions are met. Unlike other nodes we've implemented,
    this one doesn't fall through to any state outside of the switch itself, so it
    defaults to a `FAILURE` state. You may choose to default to a `SUCCESS` or `RUNNING`
    state, if you so wish, by modifying the default return.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily expand on this class by deriving from it or simply making the
    changes to it that you need. You can also skip this generic action node altogether
    and implement one-off versions of specific leaf nodes, but it's good practice
    to reuse as much code as possible. Just remember to derive from `Node` and implement
    the required code!
  prefs: []
  type: TYPE_NORMAL
- en: Testing our framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The framework that we just reviewed is nothing more than this. It provides us
    with all the functionality we need to make a tree, but we have to make the actual
    tree ourselves. For the purposes of this book, a somewhat manually constructed
    tree is provided.
  prefs: []
  type: TYPE_NORMAL
- en: Planning ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we set up our tree, let''s look at what we''re trying to accomplish.
    It is often helpful to visualize a tree before implementing it. Our tree will
    count up from zero to a specified value. Along the way, it will check whether
    certain conditions are met for that value and report its state accordingly. The
    following diagram illustrates the basic hierarchy for our tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0d1c39a-65d9-4ff9-978c-b834ab6f2d10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For our tests, we will use a three-tier tree, including the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node 1**: This is our root node. It has children, and we want to be able
    to return a success if any of the children are a success, so we''ll implement it
    as a selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 2a**: We''ll implement this node using an `ActionNode`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 2b**: We''ll use this node to demonstrate how our inverter works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 2c**: We''ll run the same `ActionNode` from node **2a** again, and see
    how that affects our tree''s evaluation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 3**: Node **3** happens to be the lone node in the third tier of the
    tree. It is the child of the **2b** decorator node. This means that if it reports
    `SUCCESS`, **2b** will report a `FAILURE`, and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we're still a bit vague on the implementation details, but the
    preceding diagram will help us to visualize our tree as we implement it in code.
    Keep it handy for reference as we go through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Examining our scene setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve now looked at the basic structure of our tree, and before we jump in
    and dig into the actual code implementation, let''s look at our scene setup. The
    following screenshot shows our hierarchy; the nodes are highlighted for emphasis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b10126b-cb0d-411d-b231-77911792460a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The setup is quite simple. There is a quad with a world-space canvas, which
    is simply to display some information during the test. The nodes highlighted in
    the preceding screenshot will be referenced in the code later, and we''ll be using
    them to visualize the status of each individual node. The actual scene looks something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4cd6829-b2ae-44fd-b785-2c6b0611cc40.png)'
  prefs: []
  type: TYPE_IMG
- en: Our actual layout mimics the diagram we created earlier
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have one node or box representing each of the nodes that
    we laid out in our planning phase. These are referenced in the actual test code
    and will be changing colors according to the state that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the MathTree code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without further ado, let''s have a look at the code driving our test. This
    is `MathTree.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first few variables are simply used for debugging. The three color variables
    are the colors we'll be assigning to our node boxes to visualize their state.
    By default, `RUNNING` is yellow, `SUCCESS` is green, and `FAILED` is red. This
    is pretty standard stuff; let's move along.
  prefs: []
  type: TYPE_NORMAL
- en: We then declare our actual nodes. As you can see, `m_rootNode` is a selector,
    as we mentioned earlier. Notice that we do not assign any of the node variables
    yet, since we have to pass in some data to their constructors.
  prefs: []
  type: TYPE_NORMAL
- en: We then have the references to the boxes we saw in our scene. These are just
    game objects that we drag and drop into the inspector (we'll have a look at that
    after we inspect the code).
  prefs: []
  type: TYPE_NORMAL
- en: We then have a couple of `int` values, which will make more sense as we look
    at the logic, so we'll skip over these. Lastly, we have a unity UI Text variable
    that will display some values for us during the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get into the initialization of our actual nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of organization, we declare our nodes from the bottom of the tree
    to the top of the tree, or the root node. We do this because we cannot instantiate
    a parent without passing in its child nodes, so we have to instantiate the child
    nodes first. Notice that `m_node2A`, `m_node2C`, and `m_node3` are action nodes,
    so we pass in delegates (we'll look at these methods next). Then, `m_node2B`,
    being a selector, takes in a node as a child, in this case `m_node3`. After we've
    declared these tiers, we throw all the tier 2 nodes into a list because our tier
    1 node, the root node, is a selector that requires a list of children to be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we''ve instantiated all of our nodes, we kick off the process and begin
    evaluating our root node using its `Evaluate()` method. The `UpdateBoxes()` method
    simply updates the `box` game objects that we declared earlier with the appropriate
    colors; we''ll look at that later on in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is not a whole lot to discuss here. Do notice that, because we set this
    tree up manually, we check each node individually and get its `nodeState` and
    set the colors using the `SetSucceeded` and `SetFailed` methods. Let''s move on
    to the meaty part of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we have `NotEqualToTarget()`, which is the method we passed into our
    decorator's child action node. We're essentially setting ourselves up for a double
    negative here, so try to follow along. This method returns a success if the current
    value is *not* equal to the target value, and returns false otherwise. The parent
    inverter decorator will then evaluate to the opposite of what this node returns.
    So, if the value is not equal, the inverter node will fail; otherwise, it will
    succeed. If you're feeling a bit lost at this point, don't worry. It will all
    make sense when we see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: The next method is the `AddTen()` method, which is the method passed into our
    other two action nodes. It does exactly what the name implies—it adds 10 to our
    `m_currentValue` variable, then checks whether it's equal to our `m_targetValue`,
    and evaluates as `SUCCESS` if so, and `FAILURE` if not.
  prefs: []
  type: TYPE_NORMAL
- en: The last few methods are self-explanatory so we will not go over them.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a pretty good idea of how the code works, let''s see it in
    action. First things first, however. Let''s make sure our component is properly
    set up. Select the Tree game object from the hierarchy, and its inspector should
    look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53ca85d6-29e9-4025-a991-7409bda131a8.png)'
  prefs: []
  type: TYPE_IMG
- en: The default settings for the component
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the state colors and box references have already been assigned
    for you, as well as the `m_valueLabel` variable. The `m_targetValue` variable
    has also been assigned for you via code. Make sure to leave it at (or set it to)
    20 before you hit play. Play the scene, and you''ll see your boxes lit up, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30f951fc-e54e-4b01-946c-39cddfcb89c0.png)'
  prefs: []
  type: TYPE_IMG
- en: The boxes lit up, indicating the result of each node's evaluation
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, our root node evaluated to `SUCCESS`, which is what we intended,
    but let''s examine why, one step at a time, starting at tier 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node 2A**: We started with `m_currentValue` at `0`, so upon adding `10` to
    it, it''s still not equal to our `m_targetValue` (`20`) and it fails. Thus, it
    is red.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 2B**: As it evaluates its child, once again, `m_currentValue` and `m_targetValue`
    are not equal. This returns `SUCCESS`. Then, the inverter logic kicks in and reverses
    this response so that it reports `FAILURE` for itself. So, we move on to the last
    node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 2C**: Once again, we add `10` to `m_currentValue`. It then becomes `20`,
    which is equal to `m_targetValue`, and evaluates as `SUCCESS`, so our root node
    is successful as a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The test is simple, but it illustrates the concepts clearly. Before we consider
    the test a success, let''s run it one more time, but change `m_targetValue` first.
    Set it to `30` in the inspector, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05297735-8c83-48f3-9238-37fc70d5a36f.png)'
  prefs: []
  type: TYPE_IMG
- en: The updated value is highlighted
  prefs: []
  type: TYPE_NORMAL
- en: 'A small change, to be sure, but it will change how the entire tree evaluates.
    Play the scene again, and we will end up with the set of nodes lit up, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abe6813b-80d5-4d18-998c-3e6956516a24.png)'
  prefs: []
  type: TYPE_IMG
- en: A clearly different result from our first test
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, all but one of the child nodes of our root failed, so it reports
    `FAILURE` for itself. Let''s look at why:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node 2A**: Nothing really changes here from our original example. Our `m_currentValue`
    variable starts at `0` and ends up at `10`, which is not equal to our `m_targetValue`
    of `30`, so it fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 2B**: This evaluates its child once more, and because the child node
    reports `SUCCESS`, it reports `FAILURE` for itself, and we move on to the next
    node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node 2C**: Once again, we add `10` to our `m_currentValue` variable, adding
    up to `20`, which, after having changed the `m_targetValue` variable, no longer
    evaluates to `SUCCESS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The current implementation of the nodes will have unevaluated nodes default
    to `SUCCESS`. This is because of our enum order, as you can see in `NodeState.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our enum, `SUCCESS` is the first enumeration, so if a node never gets evaluated,
    the default value is never changed. If you were to change the `m_targetValue`
    variable to `10`, for example, all the nodes would light up to green. This is
    simply a by-product of our test implementation and doesn't actually reflect any
    design issues with our nodes. Our `UpdateBoxes()` method updates all the boxes
    whether they were evaluated or not. In this example, node **2A** would immediately
    evaluate as `SUCCESS`, which, in turn, would cause the root node to report `SUCCESS`,
    and neither node **2B**, **2C**, nor **3** would be evaluated at all, having no
    effect on the evaluation of the tree as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: You are highly encouraged to play with this test. Change the root node implementation
    from a selector to a sequence, for example. By simply changing `public Selector
    m_rootNode;` to `public Sequence m_rootNode;` and `m_rootNode = new Selector(rootChildren);`
    to `m_rootNode = new Sequence(rootChildren);`, you can test a completely different
    set of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: HomeRock card game example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To further illustrate potential uses for BTs, let''s take a look at the second
    example for this chapter included in the sample code. In the `CardGame` Unity
    scene, you''ll find an implementation of a turn-based card game, where the player
    and the AI opponent have three different abilities: attack, heal, and defend.
    The user gets to pick which ability to use on their turn, and the AI will use
    a BT to decide which course of action to take. The game ends when a player reaches
    0 hit points. The following image illustrates our game view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edbf4249-ce47-411a-8f09-b2f88adf1cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: Game screen for HomeRock—Heroes of Unity
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, the player can select their attack by clicking on one of
    the cards, which have been spruced up with some flavor text. The player's hit
    points are displayed in the lower-left corner, and the AI enemy's hit points are
    displayed in the top-right corner of the screen. The premise is simple, even if
    the example is a bit silly. Let's take a look at the scene setup before we dive
    into the code.
  prefs: []
  type: TYPE_NORMAL
- en: The scene setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are quite a few things going on in this scene, as this example is a bit
    more complex than previous ones in this book. We''ll touch on each element, but
    will keep our focus on the topic at hand: behavior trees. Let''s take a look at
    the scene hierarchy, which looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fef2c18f-c18a-4b31-bbca-dc61b05fd4da.png)'
  prefs: []
  type: TYPE_IMG
- en: The scene hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: In the hierarchy depicted in this screenshot, we'll find a few game-related
    elements, and you may also notice that the canvas has quite a few elements nested
    under it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Game game object has two components on it—the Animator, which controls
    the game states, and the `Game.cs` component, which controls the game flow and
    rules. First, let''s take a look at the game states. The Animator has a reference
    to the `GameFlowStateMachine`**, **which looks like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f8240a2-b289-4426-97c5-48141acb07d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The state machine depicted has a few boilerplate states, such as **MainMenu**
    and **GameEnd**. You''ll notice that **MainMenu** is our entry point. While our
    sample doesn''t have a main menu, you could use this state to implement your own.
    In the sample, the state just automatically transitions to the **GameIntro** state.
    Again, **GameIntro** is provided as a staging area for you to implement any intro
    sequences or animations, but defaults to transitioning to the next stage, **MainGame**.
    Finally, we have **GameEnd**, which you can transition to from any state, so long
    as you hit the `EndGame` trigger. You may have noticed that **MainGame** is a
    nested tree, and if we double-click on it to dive into its contents, we''ll find
    a tree that looks like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/173343d3-c345-43a8-9e30-796a1d003f3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The setup shown in the previous screenshot is simple enough—there is a player
    turn and an enemy turn. These simply bounce back and forth whenever we set the
    `EndTurn` trigger. Next, we have our `Game.cs` component, which looks like this
    in the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddc54488-6113-444e-8ff0-785c1c3f4bd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, we can see that the Game component has some references
    to other scripts in our scene. We''ll get to those in a minute, but do notice
    that there is a reference to our state machine. Let''s dive into the `Game.cs`
    code to see what''s going on under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we have all the serialized values we saw in the inspector just a moment
    ago, along with a private, non-serialized value, the `turn` value. This value
    flips between 0 and 1 for the player's turn and the AI's turn, respectively. Our
    `Awake` method does some setup, it initializes values in the `EnemyBehaviorTree.cs`
    script, and it adds some callbacks to the enemy AI controller and our player controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EvaluateAITree()` method simply wraps the enemy''s BT''s `Evaluate()`
    method. We do this for some pseudo-decoupling. Lastly, the `EndTurn()` method
    does a few things: it checks whether either of the players'' health is below 0,
    and ends the game if so; it also toggles the turn value, sets the appropriate
    trigger on the state machine, and updates the turn message on the `UIController`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next in our scene''s hierarchy, nested under the Game game object, we have
    a HumanPlayer game object, and an EnemyAI game object. Both have a `Player.cs`
    script, which simply contains data and methods that control that player''s values.
    The screenshot here shows the values for the HumanPlayer game object''s Player
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8278b54c-7710-4075-afa4-9a43382c4310.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to get a better idea of what the values shown in the preceding screenshot
    do, let''s take a look at the `Player.cs` script and break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first few values are fairly simple. We have the player's max health represented
    by `maxHealth` and their current health represented by `currentHealth`. We use
    a value called `lowHealthThreshold` for the AI to make some decisions. It gives
    us the ability to modify the AI's behavior based on its or its opponent's health.
  prefs: []
  type: TYPE_NORMAL
- en: We then list out some ability parameters. The `minHealAmount` and `maxHealAmount`
    represent the healing ability's lower and upper limits, respectively. The same
    goes for the `minDamage` and `maxDamage` fields for the attack ability. In the
    case of `isBuffed`, we use a bool to represent whether or not the player is "buffed,"
    which is a generic term in some game genres to denote that a character or player
    has a beneficial gameplay status. There are some properties and initialization
    in our `Awake` method, and then a series of ability methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `Buff()` method simply sets the `isBuffed` value to true. We use this in
    our damage calculation later on. The `Heal()` method picks a random number between
    the range specified by `minHealAmount` and `maxHealAmount`, and restores that
    much health to the player's `currentHealth` value. Lastly, the `Damage()` method
    applies a random amount of damage to the player (by subtracting from its current
    health), which is halved when the player's `isBuffed` flag is set to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now take a look at the next component of the HumanPlayer game object,
    the `PlayerController.cs` script. The component''s inspector values can be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e378e9c3-c256-4e55-adb3-4afd8cb3865a.png)'
  prefs: []
  type: TYPE_IMG
- en: The inspector showing all the assigned values for the player controller
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice some references to its own `Player.cs` component as well as
    the enemy AI''s component. The Buttons section contains references to the ability
    card''s UI buttons. The code for the class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables up top are fairly straightforward, and they are the very values
    we just saw in the inspector. You''ll also find an `onActionExecuted` event here,
    which, if you remember, gets assigned from the `Game.cs` script''s `Awake()` function.
    In this class''s `Awake()`, we assign an `onClick` handler for each of the buttons:
    **Defend**, **Heal**, and **Attack**. Each of the methods calls the appropriate
    ability method on the `Player.cs` script, and then calls `EndTurn()`, which, in
    turn, calls the `onActionExecuted` callback. Refer back to the `Game.cs` script
    for what that does.'
  prefs: []
  type: TYPE_NORMAL
- en: The enemy state machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EnemyAI` game object has its own `Player.cs` script, as we saw earlier,
    but it also has the script we''re most interested in: the `EnemyBehaviorTree.cs`
    component. This component contains the BT for our enemy agent, along with some
    helper functionality. Let''s take a look at that code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We start off with some declarations as usual. Most notably, we declare our
    nodes here. We have some familiar nodes, the `ActionNode`, the `Sequence`, and
    the `Selector`, which you should be familiar with by now. But you may have also
    noticed an unfamiliar node as well—the `RandomBinaryNode`.  Before digging deeper
    into the `EnemyBehaviorTree.cs` code, let''s take a look at the `RandomBinaryNode.cs`
    file to see what this node type does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the node is very simple. We "roll" a random value between 0
    and 1 (keeping in mind that `Random.Range(int, int)` has an exclusive upper range,
    meaning it can return up to that value, but not including it), and return a `SUCCESS`
    state when the `roll` is `0`, and `FAILURE` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the `EnemyBehaviorTree.cs` class, we have another delegate/event
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `onActionExecuted` event on the `PlayerController.cs` class,
    this one will be called after the AI executes its action and triggers the end-of-turn
    checks. Up next, we have the `Start()` method, which is important as it sets up
    our node structure, starting from the lowest-level nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand what''s going on in this section of the code, let''s take
    a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bf4df0e-541f-4a2e-b823-8de031061df3.png)'
  prefs: []
  type: TYPE_IMG
- en: Enemy turn behavior tree
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the enemy turn is broken up into three steps—health check,
    attack check, and buff check. The health check node is a simple `ActionNode`.
    In this case, we''re modeling a fairly conservative agent, so it prioritizes its
    own health versus being aggressive. The node invokes the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have the attack check node, which is also an `ActionNode`. This one
    then checks if the human player''s health is low, and attacks if so, in an attempt
    to go for the kill. This is the function it invokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have a buff check node, that is actually a sequence, with two children
    nodes. The idea here is that if it did not heal, and it did not attack, the agent
    will attempt to buff itself. However, because this would lead to a loop where
    it buffs itself, the player attacks (thus removing the buff), and it buffs itself
    over and over until its health is low, we add a randomization factor via the `RandomBinaryNode`
    node. The actual buff check calls the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The root node itself is a `Selector`, so that it only requires one child to
    return `SUCCESS` for it to return `SUCCESS` itself. However, we do not use the
    root node''s state value in this example. The last part of our AI code is the
    `Execute()` method, which as you may notice, is a coroutine. We do this to give
    the illusion that the AI is "thinking" about its move. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We evaluate the state of each node, and act accordingly. In the case that all
    nodes report a `FAILURE`, we fall back to an `else` clause that attacks the enemy.
    At each stage we debug the AI's "process" via debug logs. After all the `if` checks,
    we simply fire off our callback, which in turn calls the `EndTurn()` method we
    passed in earlier via the `Game.cs` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bit of code to look at for this example is the `EnemyTurnState.cs`
    `StateMachineBehaviour` script. It''s attached to the Enemy Turn state in the
    state machine. In it, we only implement the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `OnStateEnter` logs some information to the console, then calls
    the `EvaluteAITree()` method on the `Game.cs` script, which in turn calls the
    `Evaluate()` method on the `EnemyBehaviorTree.cs` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnStateExit` method simply logs out some information to the console, so
    that when we enter play mode in the editor, we''ll see an output that looks like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f665a42-a8cd-4a47-8db9-fc754505a97e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the console after the AI's first turn, where
    neither the AI agent nor the player have sustained enough damage for them to heal
    or attack, and the AI opted to defend itself instead, using the **Buff** ability.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All you have to do is hit play, and play along. Each game should play differently
    depending on how the randomness of the abilities and the `RandomBinaryNode` play
    out. As you can see, even with the simple three-branch behavior tree used here,
    we're able to create a huge number of possible outcomes for the game. Adding more
    branches to suit your game design can give your game added challenge, replay value,
    and unpredictability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dug into how a behavior tree works, and then we looked at
    each individual type of node that can make up a behavior tree. We also learned
    the different scenarios where some nodes would be more helpful than others. After
    looking at some off-the-shelf solutions available in the Unity asset store, we
    applied this knowledge by implementing our own basic behavior tree framework in
    C# and explored its inner workings. With the knowledge and the tools out of the
    way, we created a sample behavior tree using our framework to test the concepts
    learned throughout the chapter. We then went on to explore the implementation
    of *HomeRock*, a sample card game that showcases an AI opponent. This knowledge
    prepares us to harness the power of behavior trees in games and take our AI implementations
    to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 7](4dbbb008-faf0-41a9-87d5-391ac3af5781.xhtml),
    *Using Fuzzy Logic to Make Your AI Seem Alive*, we'll look at new ways to add
    complexity and functionality to the concepts we've learned in this chapter, modifying
    behavior trees and FSMs, which we covered in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)*,*
    *Finite State Machines and You*, via the concept of fuzzy logic.
  prefs: []
  type: TYPE_NORMAL
