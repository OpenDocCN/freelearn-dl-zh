- en: 'Function Optimizations: How and Why'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: bAnd now it's time to have some fun. We are going to develop a very powerful,
    three-dimensional application that you won't find anywhere else. This application
    will allow you to visualize how individual functions optimize over time, with
    a two and three-dimensional graphic of each. The source code for this application
    is located in the instructions given for access of the book's source code. This
    application will be very unique in that we will use a mixture of open source and
    third-party controls to create an unbelievably powerful application. Open source
    doesn't handle everything all the time, and for those of you serious about graphics
    I wanted to expose you to some controls aside from the open source standards such
    as ZedGraph, Microsoft Charting Controls, and others. As you will see in a moment,
    the difference is astounding and worth the ride. You can decide later if you want
    to change anything back to completely open source.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to show you how we can use Particle Swarm Optimization to
    enhance visualizations of function optimizations. By doing so  you will see how
    each particle in the swarm converges to the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to accomplish the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a Visual Studio WinForms project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a function optimization tester
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement graphic controls for our visualizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talk about various third-party controls used in this project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the various hyperparameters available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to tune and adjust hyperparameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the effect of adjusting hyperparameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the purpose of functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to add new functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate adding a new function and running a test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have a basic knowledge of .NET development using Microsoft
    Visual Studio and C#. You will need to download the code for this chapter from
    the book's website.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see Code in Action: [http://bit.ly/2ppBmvI](http://bit.ly/2ppBmvI).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, let me show you the product we are going to create.
    When we are done you will have an application that allows you to view graphically
    how a function minimizes or maximizes over iterations. This is contrary to the
    typical text-based representations of such systems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/244ea886-fc86-4f45-bd1e-f3a6354126b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is a very visual application. Let's go ahead and break
    this down into sections that we will refer to as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: The first section is the three-dimensional plot and is located on our main page.
    Three dimensions can provide much more insight into the path that each particle
    in the swarm takes, and the swarm itself is taking. It is also much easier to
    see when a particle or the swarm converges on the global minimum. For this plot
    we will use the incredible Nevron chart control. You can find more information
    about this Chart control at [https://www.nevron.com/products-open-vision-nov-chart-control-overview.aspx](https://www.nevron.com/products-open-vision-nov-chart-control-overview.aspx).
    The main user interface is developed with DotNetBar. For those looking for a different
    user interface with all the bells and whistles such as crumbbars, tabs, grids,
    listviews, charts, sparklines, and more, this is a great and more affordable choice
    than say Infragistics or DevExpress. You can find more information about this
    suite of controls at [http://www.devcomponents.com/dotnetbar/](http://www.devcomponents.com/dotnetbar/)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45942ee6-311c-4ef9-819f-5b1e1bec58bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Main Page
  prefs: []
  type: TYPE_NORMAL
- en: 'The second section is the two-dimensional plot, and is located on our fourth
    page, the **Charts** tab. Some people would also call this type of plot a spaghetti
    plot. Its job is to plot the swarm on a two-dimensional plane. For this plot we
    will use the Microsoft Chart control. As you can see, this control becomes very
    busy when trying to plot on a two-dimensional surface. The more particles in the
    swarm that you have, the busier your chart will become:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4424b8f-313f-4448-9fb1-f4fea9e7fed4.png)'
  prefs: []
  type: TYPE_IMG
- en: 2D Visualization
  prefs: []
  type: TYPE_NORMAL
- en: 'The third section is the information tree, and is located on our third page,
    the **Details** tab. This tree houses detailed information from each iteration.
    The total number of iterations is a hyperparameter we will discuss shortly. Each
    iteration will track all swarm particle information such as position, speed, best
    position, and fitness, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7a92a0-9f87-40c3-9676-7be2a34e354d.png)'
  prefs: []
  type: TYPE_IMG
- en: Information Tree
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth section is the function hyperparameters and is located on our main
    page. These parameters control the function and function optimizations and are
    essential for plotting both the two and three-dimensional plots. The individual
    parameters themselves will be discussed in a later section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dea8c0c-0baf-4411-8942-256ca28657bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth section is the plot replay controls, also located on our main page
    at the bottom, underneath the hyperparameters. Aside from running the main function
    optimization iteration loop, they are responsible for replaying the function optimization
    plot for both the two and three-dimensional plots. You can play, pause, rewind,
    step forward, and step backward, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c1d72a7-4206-4d74-b41b-905a23cf8861.png)'
  prefs: []
  type: TYPE_IMG
- en: Run controls
  prefs: []
  type: TYPE_NORMAL
- en: With the details behind us, let's move on to discussing exactly how we are going
    to create our application. Let the fun begin!
  prefs: []
  type: TYPE_NORMAL
- en: Function minimization and maximization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function minimization and maximization are the process of finding the smallest
    and largest value of a given function. Let's talk briefly about that value.
  prefs: []
  type: TYPE_NORMAL
- en: If the value is within a given range, then it is called the local extrema; if
    it is within the entire domain of a function then it is called the global extrema.
    Let's say we have a function f, and it's defined against a domain X. The maximum,
    or global, point at x* is f(x*) is greater than or equal to f(x) for all x in
    the domain X. Conversely, the function's global minimum point at x* is f(x*) is
    less than or equal to f(x) for all x in the domain X.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simpler fashion, the maximum point is also called the maximum value, and
    the minimum point is called the minimum value, of the function. The global maximum
    or minimum is either the highest or lowest function value in the entire domain
    space (search space), and the local maximum or minimum is the highest or lowest
    value in a defined neighborhood within that search space (it is not allowed to
    reside on the boundary at all), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7eb27d7-f4ad-4896-b80d-b47b71219a96.png)'
  prefs: []
  type: TYPE_IMG
- en: Global and Local Optimums
  prefs: []
  type: TYPE_NORMAL
- en: 'In this simple illustration, **D** is the global minimum and **G** is the global
    maximums. **A**, **C**, and **E** are local maximums (it is important to note
    that a function can have more than one global or local maximum or minimum). **B**
    and **F** are considered local minimum. **X**, **Y**, and **Z** exist around the
    minimum value **F**, since the value of **Y** is less than both **X** and **Z**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a40b965b-5c2c-4935-ad0c-c837894bdf10.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Tape Plot
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a real example. Let's say we are using the function sin(x). The maximum
    value for this function is +1, and the minimum value would be -1\. Therefore,
    we have the global minimum and maximum. Sin(x) can take on any value between negative
    and positive infinity, but over all of these values, the maximum can only be +1
    and, the minimum can only be -1.
  prefs: []
  type: TYPE_NORMAL
- en: If we then restrict the search space (global domain) to between 0 and 90 (sometimes
    people call this the interval), sin(x) will now have a minimum of 0, and its value
    will be 0\. However, the global or maximum value will now be 90 and the value
    is 1, because we restricted our search space to between 0 and 90\. All values
    of sin(x) will lie between 0 and 1, within the interval of 0 to 90.
  prefs: []
  type: TYPE_NORMAL
- en: What is a particle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main components we are going to be dealing with is what is known
    as a **particle—**hence, Particle Swarm Optimization. To briefly provide an analogy
    as to what a particle is, let's look at it this way. Let's say that we see a flock
    of birds flying in the sky. Each bird in this flock is a particle. We see a school
    of fish swimming in the water. Each fish is a particle. We knocked down that bee
    hive and were attacked by hundreds of bees. Each bee that attacked us was, you
    got it, a particle!
  prefs: []
  type: TYPE_NORMAL
- en: Each particle has fitness values which, once evaluated by the fitness function
    to be optimized, will tell us how it ranks in the swarm. Additionally, we also
    have velocities that direct the flying of each particle. The particles, like the
    birds, fly through our problem space by following the *optimum* particle, which
    would be the leader of the flock of birds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know exactly what a particle is, how do we describe it in computational
    terms? We will define a structure like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With that behind us, let''s go ahead and create our project. You should have
    Microsoft Visual Studio installed and open. If you have not installed Microsoft
    Visual Studio yet, you can install the free Community Version from the Microsoft
    web site. Once this is complete, open Microsoft Visual Studio and create a Windows
    Forms project as shown in the following screenshot. In our instance we are using
    .NET version 4.7.1\. Feel free to use whatever version you have, but it needs
    to be at least version 4.5.2 or higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/376b6c61-cf99-46d5-861e-30e450919bc0.png)'
  prefs: []
  type: TYPE_IMG
- en: New Project Window
  prefs: []
  type: TYPE_NORMAL
- en: Next, let me mention that our user interface is created with a third-party product
    called **DotNetBar**. This is a fantastic, light weight user-interface library.
    It can be found here: [http://www.devcomponents.com/dotnetbar/](http://www.devcomponents.com/dotnetbar/)[.We
    are now free to begin to focus on the formulation of our project. We will need
    to initialize some general areas of our program, such as the Swarm, the Chart,
    and the State.](http://www.devcomponents.com/dotnetbar/)
  prefs: []
  type: TYPE_NORMAL
- en: Swarm initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, we need to initialize our swarm and all the variables and properties
    that go along with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the process, let''s create a particle called `GlobalBest` (which I
    will refer to throughout the book as `gbest`) and initialize its best fitness
    value to either positive or negative infinity, depending upon whether the user
    has selected a strategy of `Minimization` or `Maximization`. We do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will determine which swarm size the user desires, and then initialize
    all the particles in the swarm. Each particle will have several properties that
    will need to be initialized. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Fitness value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Best fitness value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Best position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, we need to check and see if the individual particles'' best
    fitness value (`pbest`) is better than the global particle (the team''s) fitness
    value (`gbest`). If so we will update the global particle to that best position
    and fitness value and the other particles will follow it. We do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will fill the swarm and global plot matrix like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we will update our information tree with all the details
    associated with the swarm now. To do so we need to iterate through the entire
    swarm and record our information for display. Since we are using a Windows Tree
    Control, we will plot each swarm particle as a separate node, indicated by the
    identifier `PSODisplayType.Swarm`. The information underneath each node will be
    indicated by the identifier `PSODisplayType.SwarmPosition`. We accomplish this
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Chart initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, which we will call the workbench for short, we are dealing
    with two charts. The first chart is three-dimensional, the second is two-dimensional.
    Each one reflects the same data albeit from a different perspective. In our chart
    initialization function, we will initialize both charts at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '`chartPSO` is the name of our two-dimensional Microsoft Chart Control chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nChartControl2` is the name of our three-dimensional Nevron chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not use the same control for both visualizations? That certainly could have
    been the case, but this way you, the reader, get exposure to two different types
    of control and can decide which you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we will do is to create a random variable called `_MarkerStyle`.
    Each particle will have a different marker style in the two-dimensional plot,
    and we will use this random variable to control the correct creation of the style
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next on our list of things to do is to clear the series data from both controls,
    just in case there is data left over. We do so with the following two lines of
    code. Remember, `chartPSO` is our two-dimensional chart and, `nChartControl2`
    is our three-dimensional chart control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the best visualization from our three-dimensional control, we need to
    ensure that it fits the entire chart area. We do that by setting the bounds mode
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to make sure that each particle in the swarm has an area of representation
    in both charts. We do that by iterating through the swarm size and setting each
    variable correctly. We start by adding the two-dimensional chart configuration
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then the three-dimensional chart configuration, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s set the final variables of the two-dimensional chart as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, to give our three-dimensional chart the most flexibility for use,
    we need to add the following toolbars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: State initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the swarm and chart created and initialized, we now focus on initializing
    the state of the application itself. This means we are going to collect all the
    user-defined values and use them to initialize the hyperparameters themselves.
    We will delve into each in more detail in our chapter on hyperparameters, but
    for now you just need to be aware that they exist. Let's talk about each as it
    relates to state initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will determine the strategy we will use to initialize our function
    optimization. We will store this choice in a variable labeled `PSO_Type`. Our
    two choices of strategy are `Minimization` and `Maximization`. We determine the
    type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will initialize the number of dimensions, upper and lower bounds,
    and speed limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue with initializing our inertia, cognitive, and social intelligence
    weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One of our most critical hyperparameters relates to our swarm and its population
    size – how many particles will be in the swarm. Remember, even though we have
    not placed boundary checks in the source code itself, this value should ideally
    be a value between 5 and 40\. I often use a value of 5 to start my testing. We
    determine the swarm size by looking at the value that the user entered like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we initialize our global variables to track the maximum efficiency
    of the swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Controlling randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the initialize process continues, position, speed, and fitness are initialized
    in the Swarm Initialization section. Here''s a brief look at how we do randomization.
    We start with each of those hyperparameters, and then randomize the values between
    the upper and lower bounds we stated in our hyperparameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Updating the swarm position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The swarm position is the current position of the swarm relative to the global
    optimum – in this case, the hidden treasure. It is constrained within the upper
    and lower domain bounds as shown in the following. But remember, these two are
    hyperparameters entered in the same panel!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Updating the swarm speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The swarm speed is the speed at which the entire swarm heads towards the global
    optimum, that is, the hidden treasure. It is first calculated based upon the formula
    seen as follows, and then constrained within the upper and lower bound speed hyperparameter
    values. As you can see, we also apply various weights and randomization values
    to calculate and adjust the speed, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Main program initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the main form initially loads, this is when our main initialization process
    begins. Let's walk through this method and talk about what exactly happens. In
    this method we are concerned with three-dimensional chart initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we establish some general parameters for the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we handle showing our interlaced strip on the back-left wall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we handle showing our *x* axis gridlines like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Running Particle Swarm Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our main functions in place and everything initialized from our hyperparameters,
    we can now focus on being able to run higher level functions. One of our PSO functions
    is the `PSORun` method. This method is executed once the user clicks on the **Run**
    button ![](img/366eaec3-5a3a-40c4-b358-f73338c16da5.png). Let's walk through this
    higher-level function now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we do is to initialize our state by calling our `InitState` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After this we will clear out our information tree, create a new stopwatch responsible
    for timing our function, then run our `Swarm_Run` method. This will perform the
    actual function optimization behind the scenes, which usually will happen in just
    milliseconds depending upon the swarm size, iterations, and dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the variables responsible for tracking the global and individual
    positions of the entire swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we initialize our charts, and play back the swarm''s plot at a
    much slower pace so the end user can see what has transpired. We do this via a
    call to the three methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we initially start our application, we have the proverbial blank slate.
    After initialization, we have completed the following items. Please note that
    the numbers relate to the screenshot showing the screen, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our parameters are initialized to the default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our three-dimensional chart is initialized to the default values and has no
    series data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/35b11939-5834-4c79-870b-166287b77a41.png)'
  prefs: []
  type: TYPE_IMG
- en: Blank 3D Chart
  prefs: []
  type: TYPE_NORMAL
- en: Run button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The run button executes the Particle Swarm Optimizer based upon the function
    and the strategy selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce918769-844c-4710-801f-e5e34cc38514.png)'
  prefs: []
  type: TYPE_IMG
- en: Rewind button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rewind button completely rewinds a PSO plot to the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc09e7cd-7384-4262-842f-d65c8961a217.png)'
  prefs: []
  type: TYPE_IMG
- en: Back button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Back button takes one step backward in the particle swarm optimization
    test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bddde3e5-68d8-4b7e-89ed-0a75a6ed1bc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Play button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Play button replays a particle swarm optimization run from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54050c94-424d-47b9-8876-88bf985e9df3.png)'
  prefs: []
  type: TYPE_IMG
- en: Pause button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Pause button pauses a replay of a particle swarm optimization run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73f9d717-3342-4c2a-8c5f-e55cc94ab5e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Forward button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Forward button takes one step forward in the particle swarm optimization
    test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59c35c1a-236b-4860-a84b-8113a789b85a.png)'
  prefs: []
  type: TYPE_IMG
- en: Hyperparameters and tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyperparameters in general are parameters used for tuning various machine learning
    functions. This is no different in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the front screen of our application, the following is what our hyperparameter
    panel looks like. We will discuss each hyperparameter in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9f7006f-5d01-4754-8b6c-e7218c1f6a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: Parameters
  prefs: []
  type: TYPE_NORMAL
- en: Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a list of all available functions for optimization. Simply select the
    function you would like to use, set the strategy and other parameters, and click
    the **Run** button. Please see the function optimization reference for more detailed
    information about each function. There are over 50 different functions currently
    available at the time of writing, and we will cover in a later chapter how you
    can add many of your own, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06d8aac6-1d08-4c4c-9bf6-144ddbdbe355.png)'
  prefs: []
  type: TYPE_IMG
- en: Functions
  prefs: []
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of strategy one can apply to function optimization. You
    can either *maximize* or *minimize* your function optimization, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cacd44fa-51a2-4071-a715-245bc4057f54.png)'
  prefs: []
  type: TYPE_IMG
- en: What do we mean by this? When we talk of maximizing or minimizing a function,
    what we mean is what the minimum or maximum value of that function can be. This
    is usually discussed in terms of either a *global range* or *local range*.
  prefs: []
  type: TYPE_NORMAL
- en: A global range would mean we want to determine the minimum or maximum value
    of the function over the whole range of input over which the function can be defined.
    This is commonly known as the domain of the function.
  prefs: []
  type: TYPE_NORMAL
- en: A local range, on the other hand, would mean we want to determine the minimum
    or maximum value of the function over the given local range, which will be a subset
    of the global range.
  prefs: []
  type: TYPE_NORMAL
- en: Dim size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dimension size is used within the main loop (the final inner loop) to process
    the optimization for the function selected. 2 is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1464a482-8d72-41f9-90e6-d05fdc3772cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Upper bound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The upper bound is the upper limit of constraint which the swarm must adhere
    to. This is used to update the swarm position and to scale it within range. 10
    is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f22b1902-19f1-4bcf-9dff-c1ed08803731.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please note that, depending upon the function you are optimizing, the upper
    and lower bounds could be quite different from the default. Consult the reference
    guide for your function and see what the upper and lower constraints are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Upper Bound = 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81242ff8-a8a8-4c0a-86e1-86943f8b0094.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Upper Bound = 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fcfbe87-aa33-4e04-bb23-758c9fa223ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Lower bound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the lower limit of constraint which the swarm must adhere to. This
    is used to update the swarm position and to scale it within range. -10 is the
    default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2f0b983-fc5b-4387-a0df-9529b159dc31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Upper bound speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The upper bound speed is used to help determine the swarm speed. 10 is the
    default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/058bc8d8-438a-45ab-9f2d-7439095fb534.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Upper Bound Speed = 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08b29e94-bcfe-4f19-9c37-9048bc5c35ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Upper Bound Speed = 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e66d7cf3-498b-42d6-bc2a-141bf941f379.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Lower bound speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The lower bound speed is used to help determine the swarm speed. **-10** is
    the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1feab5d0-c808-4d8a-897d-fe8847ad25aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Decimal places
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the total number of decimal places rounding occurs to. 5 is the default
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d053175-9ba6-4080-88c9-bf5e513a6f35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Swarm size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The total size of the swarm. This equates to the total number of particles
    available for optimization. There is a considerable amount of theory as to the
    appropriate number to use here. Remember, as we stated before, no free lunch!
    Generally, a value of 20-40 seems to be the most widely acceptable. 20 is the
    default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dda0a875-d56a-458e-9e8e-c5bd652b82f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Swarm Size = 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b862f6ff-512d-4541-ac02-be36b595cfa8.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Swarm Size = 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30141ee-b78e-4570-8b76-60cce9883f4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Max iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The total number of iterations used for testing. 100 is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b6973c4-15e6-4d80-a504-8d604529f802.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Max Iterations = 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e717c141-9978-44a7-ae8c-5846317065e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Max Iterations = 25:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf12eea9-6fb7-4c33-8a8a-6dd807f916ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Inertia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inertia weight was initially introduced to balance optimization between the global
    and local search abilities. In our case, inertia is multiplied by the inertia
    weight to adjust the swarm speed. Generally, the accepted values range from 0.4
    to 1 for this variable. 0.729 is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73048129-cd53-45e7-b79d-5216229d392f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inertia = 0.729:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5b20d6d-23a3-485c-9c84-11e0a4387a51.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Inertia = 0.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/818ef43f-69e4-4f9b-9249-b2643cd689ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Social weight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Social weight is used to adjust the swarm speed. It is the factor that determines
    the extent to which the particle will follow the swarms'' best solution. **1.49445**
    is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfde6d77-883c-443f-b63f-35e3fb18473b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Social Weight = 1.49445:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64167fb4-2449-400b-8904-beeb5d202b3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Social Weight = 1.19445:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b93ee286-5a6b-4a8d-ab91-ea68550f94df.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Cognitive weight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cognitive weight is also used to adjust the swarm speed. It is the factor that
    determines the extent to which the particle will follow its own best solution.
    **1.49445** is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b632277a-a99d-4a40-b848-d44b0c272893.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Cognitive Weight = 1.49445:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07bd0de0-54be-40f0-89ea-4c2f1037fc28.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Cognitive Weight = 1.19445:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00a52014-dbec-4266-b792-d0e3743b2e56.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Inertia weight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The inertia weight is multiplied by the inertia during each iteration of function
    optimization. **0.99** is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4b52868-ccf5-4ac2-9697-32397edb56e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Inertia Weight = 0.99:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bb3b6e3-15ad-4bcc-856a-1ccaa038c1ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Inertia Weight = 0.75:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6574ac58-cfad-4f4c-a097-3543263e4fe4.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Plot
  prefs: []
  type: TYPE_NORMAL
- en: Understanding visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will go over some of the many that you will see in our program.
    This includes both two and three dimensional plots.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding two-dimensional visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our application, we have several two-dimensional visualizations that we
    need to explain. The first is the two-dimensional plot of the function optimization,
    be it maximized or minimized. This visualization is shown as follows. Remember,
    for this we are using Microsoft Chart control, which is available from: [https://www.microsoft.com/en-us/download/details.aspx?id=14422](https://www.microsoft.com/en-us/download/details.aspx?id=14422):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87685f4f-aeb3-4924-b4e2-f972cc48eb8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 2D Visualization
  prefs: []
  type: TYPE_NORMAL
- en: For each particle that we are plotting (up to a maximum of 10), we will have
    a different marker style. A marker is the diamonds, circles, x's, and so on that
    you see plotted in the preceding diagram. We will also rotate colors based upon
    each particle being a different color. If you are not viewing this book in color,
    you hopefully will have shades of grey.
  prefs: []
  type: TYPE_NORMAL
- en: The lines you are seeing in the preceding diagram (or, to be more technically
    accurate, the splines you are seeing above them) are the plots of each particle
    in the swarm. The global optimum value (gbest) is the black diamond in the middle
    of the plot area. As you can see, we always remain within the bounds of our hyperparameters.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding three-dimensional visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In my opinion, the three-dimensional view is the easiest to interpret and the
    most intuitive, especially if it is a part of your model verification package
    that you will show to someone else. You can easily see in the following when each
    particle arrives (if it arrives) at a global optimum. The result is a flat line
    indicated by one or more line segments at the 0 axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/788b27ad-8ffd-4ec1-bd9c-b3d377b9e9bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D Visualization
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several toolbars available for working with the three-dimensional
    view, of which you have rotational options, placement options, color options,
    and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3953198f-65d4-4cf9-a9fa-afc3ca24752c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use the **Trackball** to rotate the chart to see the view from virtually
    any direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a64b8b6b-353c-40a4-8bb8-9ac3274bbebd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just select the Trackball, and then select the chart, click on the left mouse
    button and drag the chart to your new view like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07820860-528d-4834-897d-5b318d69b014.png)'
  prefs: []
  type: TYPE_IMG
- en: Rotating the View
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the lighting of the chart by changing the **Predefined Light
    Model**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dc1e107-6484-460b-afe8-3cab516afe88.png)'
  prefs: []
  type: TYPE_IMG
- en: Pre-defined Light Models
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then select from any of the predefined models, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5ea8878-b212-4641-a077-6177f4f10cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: Pre-defined Light Models
  prefs: []
  type: TYPE_NORMAL
- en: 'The depth and width controls allow you to change both dimensions on the chart
    to suit your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6f91dd2-ac97-49a7-b575-86679e4e16ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Simply click on the button you desire and continue to click to apply the transformation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63af16a4-b83e-4515-b090-784cd81227c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Transformations
  prefs: []
  type: TYPE_NORMAL
- en: '**Nudging** allows you to make minor adjustments to the chart area and location.
    You can **Nudge** up, down, left, or right, as well as any combination of these,
    by simply clicking on the button(s) you desire, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/823de99e-b81e-4c1d-b9b0-a26dd3369c3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the main toolbar, you can open, save, and print charts, a valuable feature
    if you need to have images for a report based upon your testing. You can also use
    the Chart editor and Chart Wizard, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b43bf5b5-44ad-421c-a06d-f817bf476c3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Simply select the button you desire, in this case **Show Chart Wizard**, and
    the wizard dialog will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4c99515-66e5-40c1-88de-065b203c8165.png)'
  prefs: []
  type: TYPE_IMG
- en: Chart Wizard
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the 3D button to switch between two and three-dimensional views
    of the same chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two dimensional view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa2a936e-5955-48a3-a1d9-2f6ddb24457b.png)'
  prefs: []
  type: TYPE_IMG
- en: 2D View
  prefs: []
  type: TYPE_NORMAL
- en: 'This can change to 3D with the click of a single button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7098bcc-3403-444a-ad14-051806e91dfb.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D View
  prefs: []
  type: TYPE_NORMAL
- en: Plotting results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following section details how our information is displayed once results
    have been obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Playing back results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the swarm optimization is complete, the job of playing back the results
    comes to the forefront. Our main function in replaying plots is called `PlaybackPlot`.
    Let''s discuss the function in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Get our current iteration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have played back all our points, then leave, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the progress bar, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Go through all iterations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the progress bar value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Plot a single swarm iteration point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Briefly pause to allow the UI to remain responsive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice in the preceding function a call to `PlotSwarmIterationPoint`.
    This function call (or method, if you prefer) is responsible for plotting a single
    movement of the particles. One step, if you will. Let''s take you through that
    function and describe what is happening, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have reached our final iteration, then leave, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to plot a single point for each particle in the swarm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a series for each point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a data point for the series we just created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Dynamically handle the colors based upon the range values each particle is
    in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a point for the optimal global position, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the next iteration in line, paint the control, and show the text for what
    is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Updating the information tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The information tree is on the **Details** tab page of our user interface.
    It houses the information treeview control. Depending upon the `PSODispType`,
    we will either create a new node or use the one previously created to write out
    our text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a brand-new node in the tree. This is the highest level for a particle
    in the tree and represents the global best values found, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Add details to the previous node. This is an individual particle in the swarm,
    and its sub details will be plotted in our next function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Add details to the previous node. These are the exact details of the particle,
    and form the bottom-level node for this particle in the swarm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. We now have a fully populated information tree!
  prefs: []
  type: TYPE_NORMAL
- en: Adding new optimization functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the beautiful things about our visual test workbench is the ease of which
    we can add new optimization functions for testing.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some problems are evaluated in terms of quality versus correct or incorrect.
    Such problems are known as optimization problems because the goal is the identification
    of the optimal value. Functions (sometimes called cost functions, objective functions,
    error functions, and so on.) achieve that goal by mapping n-dimensional real-valued
    items into one-dimensional real-valued items (some folks will prefer the termspaces
    over items' as it more closely aligns with the total search space we have talked
    about).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of function we will deal with. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimization**: Looking for the solution with the smallest value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximization**: Looking for the solution with the largest value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not always the case that we can find the minimum or maximum, but sometimes
    must settle on a value that we deem sufficiently good enough for what we are trying
    to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding new functions is a very simple process comprised of only a few steps
    to follow. The steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function based upon the signatures shown as follows
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new function name to the `GetFitnessValue` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new function name to the user interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now cover these steps on by one. First, we will deal with the function
    signature itself. The function signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, xxxxxx is the name of the function that will be displayed in the UI,
    as you can see in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/664a9681-2b7d-4abe-a439-7fa0af2b2524.png)'
  prefs: []
  type: TYPE_IMG
- en: Optimization Function Window
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, you must update the `GetFitnessValue` function so that it knows
    how to relate what is displayed on the user interface to an actual function. Here
    is a sample of what that function looks like. We will in fill this information
    later in the *Let''s add a new function* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fitnessFunction` text is what appears in the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a new function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time for us to demonstrate how to add a new function. The function
    we are going to deal with is a modified version of the original `Levy` function
    and is the 13^(th) version known to exist. This function is a minimization function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function itself, which you can find in the visual workbench source code,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Definitely a lot of math there, right? Many times, functions such as this would
    be created in editors that make the math much easier to view. For instance, if
    I were to represent this code mathematically, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to take that and plot it with a tool such as MATLAB, here''s what
    it would look like graphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42e7ede3-45e2-4a5d-a2ff-c4b4424e281f.png)'
  prefs: []
  type: TYPE_IMG
- en: Our view under MATLAB
  prefs: []
  type: TYPE_NORMAL
- en: Why did I say and show all of that? Because, as you use this tool to validate
    your testing, you need to be able to relay, and sometimes justify, this information
    to others. No doubt just showing the C# code will not be enough, and the math
    and visualizations are many times what others expect to see. Don't let that put
    you off; you'll see how easy it is to create these functions, and our application
    makes it very easy to produce the kind of information you need.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back on track with adding that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have added our new function, we now need to add it to the `GetFitnessValue` function
    so that what is selected in the user interface can relate to our specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is complete, we need to add it to our dropdown function list box
    on the user interface. Just select the combo box on the user interface, go to
    the Items property, and click on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0343899-78ed-4fc3-9251-8b194acf6865.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, simply add the text you want displayed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e34ab8e6-a27f-40ab-9196-43902e75229d.png)'
  prefs: []
  type: TYPE_IMG
- en: String Collection Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is complete, build the project, run it, and you should see the function
    displayed in the dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16f6292e-3643-4298-a51c-c2b208c1eb1b.png)'
  prefs: []
  type: TYPE_IMG
- en: New Function
  prefs: []
  type: TYPE_NORMAL
- en: 'After you select the Levy13 function, click on the **Run** button and voilà,
    you''ve successfully added a new function and tested its execution. You can view
    the two and three-dimensional plots as a validation of your success. Before you
    reach your maximum number of iterations (100 in this case), you should have reached
    a global optimum of 0 (the flat tape segments on the right-hand side of the three-dimensional
    plot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6943263-95b1-4cf4-ae80-a031e9121240.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D View
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed functions, what they are, and why we use them.
    We developed a very powerful and flexible application with which to test function
    optimization. We also showed you the complete process of adding a new function
    and how to run it once added. You are now free to add as many new functions as
    you like; just follow the process outlined herein and you should have no problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to replace back propagation with
    particle swarm-optimized algorithms, so hold on to your hats!
  prefs: []
  type: TYPE_NORMAL
