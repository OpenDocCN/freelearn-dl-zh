["```py\n    # %pip install -U langgraph langchain_community langchain_openai tavily-python\n    ```", "```py\n    import getpass\n    import os\n    def _set_if_undefined(var: str):\n        if not os.environ.get(var):\n            os.environ[var] = getpass.getpass(f\"{var}=\")\n    _set_if_undefined(\"TAVILY_API_KEY\")\n    _set_if_undefined(\"OPENAI_API_KEY\")\n    ```", "```py\n    from typing import List\n    from typing_extensions import TypedDict\n    class ReWOO(TypedDict):\n        task: str\n        plan_string: str\n        steps: List\n        results: dict\n        result: str\n    ```", "```py\n    from langchain_openai import ChatOpenAI\n    model = ChatOpenAI(model=\"gpt-4o\")\n    prompt = \"\"\"For the following task, create a series of plans that can solve the problem step-by-step. For each plan, specify which external tool and its corresponding input should be used to gather evidence. You can store the evidence in a variable #E (e.g., #E1, #E2, #E3, etc.) that can be referenced by subsequent tools. Note that all the variables are independent, so make sure to include all necessary information in each tool input.\n    Tools can be one of the following:\n    Google[input]: A search engine worker that retrieves results from Google. Use this when you need concise answers or information about a specific topic. The input should be a search query.\n    LLM[input]: A pretrained Large Language Model (like me). Use this when you need to leverage general world knowledge, common sense, or perform complex reasoning. Prioritize this tool when you are confident in solving the problem without external assistance. The input can be any instruction or question.\n    Calculator[input]: A tool that can perform mathematical calculations. Use this when you need to perform arithmetic operations. The input should be a valid mathematical expression.\n    WolframAlpha[input]: A computational knowledge engine. Use this when you need to solve equations, perform symbolic calculations, or get data-driven answers. The input should be a query in Wolfram Language or natural language related to a math or science problem.\n    For example,\n    Task: Alice, Bob, and Carol earned a total of $540 from their part-time jobs last week. Alice earned y dollars. Bob earned $20 more than three times what Alice earned, and Carol earned $15 more than Bob. How much money did Carol earn?\n    Plan: Given Alice earned y dollars, translate the problem into algebraic expressions and solve with Wolfram Alpha.\n    #E1 = WolframAlpha[Solve y + (3y + 20) + ((3y + 20) + 15) = 540]\n    Plan: Find out the amount of money Alice earned.\n    #E2 = LLM[What is y, given #E1]\n    Plan: Calculate the amount of money Carol earned.\n    #E3 = Calculator[((3 * #E2) + 20) + 15]\n    Begin!\n    Describe your plans with rich details. Each Plan should be followed by only one #E.\n    Task: {task}\"\"\"\n    ```", "```py\n    import re\n    from langchain_core.prompts import ChatPromptTemplate\n    regex_pattern = (\n        r\"Plan:\\s*(.+)\\s*(#E\\d+)\\s*=\\s*(\\w+)\\s*\"\n        r\"\\[([^\\]]+)\\]\"\n    )\n    prompt_template = ChatPromptTemplate.from_messages(\n        [(\"user\", prompt)]\n    )\n    planner = prompt_template | model\n    def get_plan(state: ReWOO):\n        task = state[\"task\"]\n        result = planner.invoke({\"task\": task})\n        matches = re.findall(regex_pattern, result.content)\n        return {\"steps\": matches, \"plan_string\": result.content}\n    ```", "```py\n    from langchain_community.tools.tavily_search import TavilySearchResults\n    search = TavilySearchResults()\n    def _get_current_task(state: ReWOO):\n        if \"results\" not in state or state[\"results\"] is None:\n            return 1\n        if len(state[\"results\"]) == len(state[\"steps\"]):\n            return None\n        else:\n            return len(state[\"results\"]) + 1\n    def tool_execution(state: ReWOO):\n        _step = _get_current_task(state)\n        _, step_name, tool, tool_input = state[\"steps\"][_step - 1]\n        _results = (state[\"results\"] or {}) if \"results\" in state else {}\n        for k, v in _results.items():\n            tool_input = tool_input.replace(k, v)\n        if tool == \"Google\":\n            result = search.invoke(tool_input)\n        elif tool == \"LLM\":\n            result = model.invoke(tool_input)\n        else:\n            raise ValueError\n        _results[step_name] = str(result)\n        return {\"results\": _results}\n    ```", "```py\n    solve_prompt = \"\"\"Solve the following task or problem. To solve the problem, we have made step-by-step Plan and \\\n    retrieved corresponding Evidence to each Plan. Use them with caution since long evidence might \\\n    contain irrelevant information.\n    {plan}\n    Now solve the question or task according to provided Evidence above. Respond with the answer\n    directly with no extra words.\n    Task: {task}\n    Response:\"\"\"\n    def solve(state: ReWOO):\n        plan = \"\"\n        for _plan, step_name, tool, tool_input in state[\"steps\"]:\n            _results = (\n                (state[\"results\"] or {}) if \"results\" in state else {}\n            )\n            for k, v in _results.items():\n                tool_input = tool_input.replace(k, v)\n                step_name = step_name.replace(k, v)\n            plan += (\n                f\"Plan: {_plan}\\n\"\n                f\"{step_name} = {tool}[{tool_input}]\\n\"\n            )\n        prompt = solve_prompt.format(plan=plan, task=state[\"task\"])\n        result = model.invoke(prompt)\n        return {\"result\": result.content}\n    ```", "```py\n    def _route(state):\n        _step = _get_current_task(state)\n        if _step is None:\n            return \"solve\"\n        else:\n            return \"tool\"\n    from langgraph.graph import END, StateGraph, START\n    graph = StateGraph(ReWOO)\n    graph.add_node(\"plan\", get_plan)\n    graph.add_node(\"tool\", tool_execution)\n    graph.add_node(\"solve\", solve)\n    graph.add_edge(\"plan\", \"tool\")\n    graph.add_edge(\"solve\", END)\n    graph.add_conditional_edges(\"tool\", _route)\n    graph.add_edge(START, \"plan\")\n    app = graph.compile()\n    ```", "```py\n    task = \"what is the exact hometown of the 2024 mens australian open winner\"\n    for s in app.stream({\"task\": task}):\n        print(s)\n        print(\"---\")\n    ```"]