<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Designing Behavior Trees - Part I</h1>
                </header>
            
            <article>
                
<p>This chapter (and the two that follow) will take you through a more practical approach of what we have learned so far. In particular, we will be focusing on how to implement a <em>Behavior Tree</em> so that we can chase our character in the game.</p>
<p>In fact, we will use all the content from <a href="00781951-41e3-4e33-8512-052e7aecfd15.xhtml">Chapter 2</a>, <em>Behavior Trees and Blackboards</em>, along with a <em>blackboard</em>, to execute these actions, a <em>NavMesh</em> to move around the environment, and the <em>Perception System</em> to sense the Player.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to design a <strong>Behavior Tree</strong>, starting from the <strong>Expected Behavior</strong></li>
<li>Analyzing the nodes that we might need on a <strong>Behavior Tree</strong></li>
<li>Implementing a <strong>Custom Decorator</strong> (both in Blueprint and C++) to check boolean variables</li>
<li>Implementing a <strong>Custom Task</strong> (both in Blueprint and C++) to find a random location around the character</li>
<li>Using the <strong>Navigation System</strong> to query the <strong>NavMesh</strong> to find the random location</li>
<li>Implementing a <strong>Custom AI Controller</strong> (both in Blueprint and C++) to use the <strong>Perception System</strong></li>
<li>Using the <strong>Perception System</strong> to sense the Player</li>
</ul>
<p>We will cover more in the two chapters that follow.</p>
<p><span>We will be implementing everything in both Blueprint and C++ to give you a broader idea of what you can use. Alternatively, if you already know what you want to use, you can just follow one of the two implementations.</span></p>
<p>If you want to follow along, I'm creating this example by starting a clean project (in my case, I'm doing this in C++, but if you want to follow just the Blueprint part of this chapter, you can use the Blueprint Template), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9913e998-403a-4d77-b1d4-e4193bd36503.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Unreal Project Browser</div>
<p>The project is called <kbd>BehaviorTreeDesign</kbd> and I am using the <kbd>Third Person</kbd> template.</p>
<p>With all this said and done, let's dive in!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Expected Behavior</h1>
                </header>
            
            <article>
                
<p>The first step in <strong>Designing a Behavior Tree</strong> is to pin down the <strong>Expected Behavior</strong> we would like to see in our character. This seems like a simple phase, but trying to take all the cases into consideration isn't trivial. However, it will avoid many headaches later on.</p>
<p>While writing down the <strong>Expected Behavior</strong>, try to be as specific as possible. If something is unclear, try to rephrase it. The sentences that you use should be short and always add information. Don't be scared if you have sentences starting with "In this case…" or "If…", because it will just mean that you are taking all the different possibilities into consideration. Once you have written it, read it out loud, maybe to a friend, and ask him/her if he/she clearly understands its meaning.</p>
<p>This is my attempt of describing the behavior we are going to implement in this chapter: "<em>The agent checks whether it has the player in sight. If it is true, then it chases the player until he/she is no longer in sight. If the player is not in sight, then the agent goes to the last location where it saw the player (if the location is known). Otherwise, the agent chooses a random location around it and goes to that location</em>"</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the Nodes</h1>
                </header>
            
            <article>
                
<p>After you've written the <strong>Expected Behavior</strong>, the next step is to analyze it so that you understand which kind of Behavior Tree nodes we will need. Of course, we can always add them at a later stage, but it is better to try and anticipate as much as possible so that you can proceed smoothly during the creation of the <strong>Behavior Tree</strong>. Let's break down the expected behavior so that we can try and understand which node we need to implement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nodes that already exist</h1>
                </header>
            
            <article>
                
<p>We need to check which part of our behavior already exists in our project, and whether it is either a built-in functionality or whether we have <span>already </span>created the node for that functionality (maybe for another <em>AI Behavior Tree</em>).</p>
<p>"The agent checks whether it has the player in sight. If it is true, <strong>then it chases the player</strong> until he/she is no longer in sight. If the player is not in sight, <strong>then the agent goes</strong> to the last location where it saw the player (if the location is known). Otherwise, the agent chooses a random location around it <strong>and goes to that location</strong>."</p>
<p>In particular, it's worth noting that we already have a <em>Behavior Tree Task</em> already built in that allows the agent to chase after an object or reach a location. Therefore, all the highlighted parts of the <strong>Expected Behavior</strong> are covered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorator – check variable</h1>
                </header>
            
            <article>
                
<p>"<em><strong>The agent checks whether it has the player in sight.</strong> If it is true, then it chases the player until he/she is no longer in sight. If the player is not in sight, then the agent goes to the last location where it saw the player (if the location is known). Otherwise, the agent chooses a random location around it and goes to that location.</em>"</p>
<p>To perform this check, we need to decide how the agent is going to "<em>perceive</em>" the player. In chapter 5, we saw how the built-in perception system works, and for such a trivial task, the system is more than perfect. Therefore, it is worth using it. However, we need to transfer this information into the <em>Behavior Tree</em>. Therefore, we need to start making assumptions on how we will implement the whole AI Behavior. For now, let's assume that this information regarding whether the player is in sight or not is stored within a boolean <em>Blackboard</em> variable. As a result, we need to implement a decorator that it is able to check this boolean variable.</p>
<div class="packt_infobox">You could also use the <strong><em>Blackboard</em></strong> decorator (which is displayed for "<em>Blackboard Based Conditions</em>") to check whether a variable is assigned or not and use that to determine whether the player is on-sight or not. However, since the main goal of this chapter is to learn how to build a <em>Behavior Tree</em> from scratch from a practical point of view, it is more useful for you to create an extra Decorator node so that you are more familiar with the process of creating Decorators as well.</div>
<p>Also, while designing nodes, we need to try and be as general as possible, so that if we have a similar need in another <em>Behavior Tree</em>, we can reuse the node we have created. Therefore, we can create a check, by using a <em>Decorator</em> node, for boolean variables in general, and we will use this to check if a variable in our Blackboard tells us whether the player is in sight.</p>
<p>Once we have established this, we need to think about how we are going to implement the node. In this specific case, it is quite straightforward, but to keep things as general as possible, let's think of other possible use of this node.</p>
<p>For instance, what if we want to check if the variable is false instead? Actually, we will need this functionality (you will understand why later in this chapter). Thankfully, Unreal has us covered. In fact, there is a handy checkbox in the details panel of a decorator named <span class="packt_screen">Inverse Condition</span>, which (as the name suggests) inverts the result of the condition, allowing us somehow check for the opposite:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/31dbc4e1-05da-4da0-b4b2-d6d922fc889f.png" style="width:18.25em;height:5.58em;"/></p>
<div class="packt_infobox">As an exercise, ignore this checkbox and try to implement your own version of inverting the condition. Even though it has no practical application, and <em>it is actually bad practice</em> doing something like that, it is still a useful exercise so that you can understand how inputs are given to a Decorator. In this exercise, there are two inputs for this node: the Blackboard key value (which is assumed to be a boolean type) to check, and another boolean variable to establish if the check is on the "true" or "false" value of the variable. </div>
<p>Without further ado, let's move on to the actual implementation of this node. As usual, I will do this both in Blueprint and C++.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Check Variable Blueprint implementation</h1>
                </header>
            
            <article>
                
<p>First of all, let's create a new <em>Decorator</em> (recall that you can either create it from the Behavior Tree editor or from the content browser; the first one is easier, but you need to have a Behavior Tree open). Either way, name it <kbd>BTDecorator_CheckBooleanVariableBP</kbd> (the ending "BP" is only used to distinguish it from the C++ version of it, since you might be doing both. In a real project, you usually have only one version).</p>
<p class="mce-root"/>
<div class="packt_infobox">In case you close the Editor without adding anything to your Decorator (for instance, to rename it), when you open it, you might see a screen like the following:<br/>
<br/>
<img src="assets/316baf07-e302-48ce-a75e-1e41272142f5.png"/><br/>
<br/>
In this case, just click on <span class="packt_screen">Open Full Blueprint Editor</span> to go to the Blueprint Editor.</div>
<p>As we stated previously, we just need a single variable of type <em>Blackboard Key Selector</em> as input, which we will name <kbd>BoolVariableToCheckKey</kbd>. This holds a reference to the blackboard boolean variable we would like to check. Moreover, it needs to be public (open the eye next to the variable name) so that it can be seen within the Behavior Tree Editor. This is what it should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7f519881-0e2a-4c95-bcbf-970d46852696.png" style="width:21.00em;height:17.75em;"/></p>
<p class="mce-root"/>
<p>Next, we need to implement/override the Perform Condition Check AI function, which can be found in the override dropdown menu, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fdda5624-65be-4d03-82cb-6a4535584d5a.png" style="width:28.67em;height:33.25em;"/></p>
<p>Once the function has been created, this is what it looks like by default:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3219c375-c950-417b-8bdd-2bb9aabbd08d.png" style="width:29.50em;height:10.08em;"/></p>
<p>First, we need to retrieve the boolean value of our Blackboard Key, which can be done by using the <span class="packt_screen">Get Blackboard Value as Bool</span> node. Then, we can plug the <span class="packt_screen">Return Value</span> pin of this node into the <span class="packt_screen">Return Value</span> pin of the <span class="packt_screen">Return Node</span>. This is what the final graph should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f992d09e-7b7d-4380-a276-9921f6ae99b0.png"/></p>
<p>Save the Blueprint, and the Decorator will be ready. If you wish, you can place it somewhere in a Behavior Tree to see if the inputs show up properly. In particular, this is what it looks like when placed in a Behavior Tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/da35b790-3f7a-4120-9b33-6aec5b2b2a82.png" style="width:26.00em;height:14.33em;"/></p>
<p>Finally, the <em>Details Panel</em> of the <em>Decorator</em> (within the Behavior Tree Editor) should look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/44f5ba63-ae9c-4620-932b-5436d5043dcd.png" style="width:32.00em;height:25.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Check Variable C++ implementation</h1>
                </header>
            
            <article>
                
<div class="packt_infobox"><span>For details on how to extend a Decorator, you can have a look at Chapter </span><span>6, <em>Extending Behavior Trees</em>.</span></div>
<p class="CDPAlignLeft CDPAlign">First of all, let's create a new C++ class that inherits from <strong>UBTDecorator</strong>. You need to search for all the classes and select <span class="packt_screen">BTDecorator</span>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/388abf62-0800-45bd-bc08-c3a388b07634.png"/></p>
<p>Then, you can rename your class <kbd>BTDecorator_CheckBoolVariable</kbd>. Also, if you wish, you can place the file in a sub-folder, such as <kbd>AI</kbd>. As example of this is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/10f67242-1c45-49b8-b87d-c862005b9df6.png"/></p>
<p class="mce-root">Press <span class="packt_screen">Create Class</span>, and your <em>Decorator</em> class will be created.</p>
<div class="packt_infobox">After you have created the Class, Unreal will try to compile your code. If you haven't set up your Public Dependencies in your project properly (as we learned back in Chapter 1 and Chapter 2; and especially in <a href="e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml">Chapter 6</a>, <em>Extending Behavior Trees</em>), you should have a message similar to the following:<br/>
<br/>
<img src="assets/46a5e21d-866f-460a-98c0-a5ab82df2271.png"/><br/>
<br/>
However, when you try to compile from Visual Studio, this is what the error will look like:<br/>
<br/>
<img src="assets/79958f18-57ed-4757-869c-14b6efa97c40.png"/><br/>
<br/>
Therefore, you need to change your <kbd>.cs</kbd> file (in our case, <strong><em>BehaviorTreeDesign.cs</em></strong>), and add "<strong>GameplayTasks</strong>" and "<strong>AIModule</strong>" as public dependencies, as shown in the following code:<br/>
<kbd>PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", <strong>"GameplayTasks", "AIModule"</strong> });</kbd><br/>
Now, you should be able compile without any issues.</div>
<p>In the header file, we need to add an input variable, the <em>Blackboard Key Selector</em> that references a Boolean, named <kbd>BoolVariableToCheck</kbd>. We also need to expose this variable to the Behavior Tree editor by using the <kbd>UPROPERTY()</kbd> macro, as shown in the following code:</p>
<pre>protected:<br/>  UPROPERTY(EditAnywhere, Category = Blackboard)<br/>  FBlackboardKeySelector BoolVariableToCheck;</pre>
<p>Then, we need to override the <kbd>CalculateRawConditionValue()</kbd> method, which is public, and so its override needs to be public as well. Insert (always in the header file) the following lines of code:</p>
<pre class="mce-root">public:<br/>  virtual bool CalculateRawConditionValue(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) const override;</pre>
<p>Next, we need to implement this function.</p>
<p>First, we need to retrieve <kbd>BlackboardComponent</kbd>, which allows us to resolve and get the values from the Blackboard Key Selectors. Thankfully, we can retrieve it from <kbd>BeheviorTreeComponent</kbd> (on which this decorator is running), which is passed to the node as a variable named <kbd>OwnerComp</kbd>. However, to use <kbd>BlackboardComponent</kbd>, we need to include its definition in our <kbd>.cpp</kbd> file, with the following statement:</p>
<pre>#include "BehaviorTree/BlackboardComponent.h"</pre>
<p>If, for some reason, this <kbd>BlackboardComponen<strong>t</strong></kbd> is invalid (this might happen if you create a Behavior Tree in your Project but you have no Blackboards; otherwise this is difficult to do, since the Behavior Tree editor automatically picks a Blackboard), we can just <kbd>return false</kbd>:</p>
<pre>  //Get BlackboardComponent<br/>  const UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();<br/>  if (BlackboardComp == NULL)<br/>  {<br/>    return false;<br/>  }</pre>
<p>Then, we need to retrieve and return the value, as a Boolean, from our <em>Blackboard Key Selector</em> variable. This is how we can do this:</p>
<pre>  //Perform Boolean Variable Check<br/>  return BlackboardComp-&gt;GetValueAsBool(BoolVariableToCheck.SelectedKeyName);</pre>
<p>This is what the whole function should look like:</p>
<pre>#include "BTDecorator_CheckBoolVariable.h"<br/>#include "BehaviorTree/BlackboardComponent.h"<br/><br/>bool UBTDecorator_CheckBoolVariable::CalculateRawConditionValue(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory) const<br/>{<br/>  //Get BlackboardComponent<br/>  const UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();<br/>  if (BlackboardComp == NULL)<br/>  {<br/>    return false;<br/>  }<br/><br/>  //Perform Boolean Variable Check<br/>  return BlackboardComp-&gt;GetValueAsBool(BoolVariableToCheck.SelectedKeyName);<br/>}</pre>
<p>Save your code and the <em>Decorator</em> will be ready. If you wish, you can place it somewhere in a Behavior Tree to see if the inputs show up properly. This is how it appears on the tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/422eb950-b1dd-4b45-9463-869ff7ef2fc9.png"/></p>
<p>The <em>Details Panel</em> of the <em>Decorator</em> (within the <em>Behavior Tree Editor</em>) should look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8de3bb38-097b-4ba6-acfe-048188582fa5.png"/></p>
<div class="packt_tip">As you may have noticed, the description of our Decorator doesn't change based on which variable we put into it, nor does it have an icon. If you are working on a large project, paying attention to these details might help you and your team greatly. In this small example, I will leave this as an exercise. You can consult <a href="94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml" target="_blank"/><a href="94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml" target="_blank">Chapter 5</a>, <em>Agent Awareness</em>, for more information on how to do it. You can also consult the source code, in particular, <kbd>BTDecorator_TimeLimit</kbd>, which implements functions such as <kbd>GetStaticDescription()</kbd>, <kbd>DescribeRuntimeValues()</kbd>, and <kbd>GetNodeIconName()</kbd>. In this section, we are going to implement the <kbd><strong>GetStaticDescription()</strong></kbd> function so that you can get used to implementing these kinds of functions as well.</div>
<p>If you haven't read the preceding tip box, do so. Now, we are going to implement the <kbd>GetStaticDescription()</kbd> function for our Decorator so that we can see which Blackboard key has been selected for the <kbd>BoolVariableToCheck</kbd> variable.</p>
<p>To start, we need to add the following override to the header file:</p>
<pre><span> </span>virtual FString GetStaticDescription() const override;</pre>
<p>Then, we can implement it by returning an <kbd>FString</kbd> that has been formatted with the <kbd>Printf()</kbd> function. By using a <kbd><strong><em>?</em></strong></kbd> statement, we can determine whether the Key has been set or not and show the right string value:</p>
<pre>FString UBTDecorator_CheckBoolVariable::GetStaticDescription() const<br/>{<br/>  return FString::Printf(TEXT("%s: '%s'"), TEXT("Bool Variable to Check"), BoolVariableToCheck.IsSet() ? *BoolVariableToCheck.SelectedKeyName.ToString() : TEXT(""));<br/>}</pre>
<p>If you compile and add the decorator to the <em>Behavior Tree</em>, this is what it should look like now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7fa4cbce-e87b-414b-8b45-283ee4a83644.png" style="width:17.58em;height:13.00em;"/></p>
<p>Much better! Now, it's time to implement a <em>Behavior Tree Task</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Task – Find Random Location</h1>
                </header>
            
            <article>
                
<p>"<em>The agent checks whether it has the player in sight. If it is true, then it chases the player until he/she is no longer in sight. If the player is not in sight, then the agent goes to the last location where it saw the player (if the location is known). Otherwise, <strong>the agent chooses a random location around it</strong> and goes to that location.</em>"</p>
<p>During our Behavior, the agent selects a random location around it. This means that we need to create a Task that, starting from the current location of the agent, picks a random location that it will go to. Moreover, we should add that this location needs to be reachable by the agent. Thankfully, we have some pre-made functions to query the <em>Navigation Mesh</em> and select a <em>Random Location</em> for us.</p>
<p>This also means that we need to assume that we have a <em>Navigation Mesh</em> available for our agent. Since this is the case, we can use this node. However, we still need to create a Task that can be executed in the Behavior Tree, and that stores this value properly somewhere in the <em>Blackboard</em>.</p>
<p>Thinking like a general node, we would like to add some additional options so that we can customize the behavior. For instance, how far away would we like this Random Location could be?</p>
<p>We have two input variables. The first is a Blackboard Key Selector that holds the Random Location we want to go to (since we need to save it in the Blackboard). The second will be just a float indicating the maximum Radius of where this Random Location can be taken.</p>
<p>Once again, we will do this process both in Blueprint and C++ (so you can choose the implementation you are the most comfortable with).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Find Random Location Blueprint implementation</h1>
                </header>
            
            <article>
                
<p>Create a <em>Blueprint Behavior Tree Task</em> (read the previous chapter to learn how to do this) and name it <kbd>BTT_FindRandomLocation</kbd>.</p>
<p>Create the two variables we need, one of the Blackboard Key Selector type named "<strong>RandomDestination</strong>" and the other one of the <em>float</em> type named "<strong>Radius</strong>". For the float, set a <em>default value different from zero</em>, for example, <strong>3,000</strong>. Finally, make them both <em>public</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a468655a-fa71-456f-889c-251fbc347ab0.png" style="width:17.00em;height:18.83em;"/></p>
<p>Let's implement/override the <span class="packt_screen">Receive Execute AI</span> event, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/213ae0da-f314-4ce1-8ec8-a6798e9bf7ad.png" style="width:22.75em;height:22.58em;"/></p>
<p>From the event, we can retrieve the <strong><em>Controller Pawn</em></strong> actor (the agent) from which we can get its location, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c186e44a-50d1-4ead-9fba-8f9c044a075f.png" style="width:34.33em;height:15.83em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Then, we can use the <span class="packt_screen">GetRandomReachablePointInRadius</span> node to generate a random reachable location within the <em>NavMesh</em>. We need to use as <em>Location</em> as the <em>Origin</em> from the <span class="packt_screen">Controlled Pawn</span> (the agent), and <strong><em>Radius</em></strong> as our <em><strong>Radius</strong> variable</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed4b6c2d-d15c-4e60-b65c-2c183b5d1c06.png" style="width:45.33em;height:16.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Find Random Location Blueprint</div>
<p>From the return value of the <span class="packt_screen">GetRandomReachablePointInRadius</span> node, we create a <span class="packt_screen">Branch</span> node. However, the call to generate the random location can fail. If it does, we need to terminate the task with an <em>insuccess (not Success)</em>. From the <strong>Branch True</strong> pin, we can set the <strong>Random Location</strong> in our <strong>Destination Key</strong> variable, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/36d272b2-4c18-4306-a5ec-eb1a34081192.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Find Random Location Blueprint</span></div>
<p>Then, regardless of the <strong>Branch</strong> (from both the end of the <strong>Set Blackboard Value as Vector</strong> node and from the <strong>False</strong> pin of the <strong>Branch</strong>), we need to <strong>Finish Execute</strong> the task. To do this, we can plug the return value of the <strong><em>GetRandomReachablePointInRadius</em></strong><span> node into the <strong>Success</strong> pin of the <strong>Finish Execute</strong>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c9895ca1-6178-4528-b5a6-dfc26b666c29.png"/></p>
<p>This concludes our task, which we can now save.</p>
<p>If we place this node in a <em>Behavior Tree</em>, this is what it will look like: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f18433ed-d3ef-404c-b4a6-b47f94fa3ce1.png" style="width:28.08em;height:22.17em;"/></p>
<p><span>The</span> <em>Details Panel</em> <span>will look as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e7e5ce98-e3df-4d62-bac7-c5f57941f576.png"/></p>
<p>If you want, you can read the next section to learn how to implement this task in C++, otherwise, you are free to skip the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Find Random Location C++ implementation</h1>
                </header>
            
            <article>
                
<p>Creating the Find Random Location task in C++ will be a bit more complicated than creating the Decorator, since we need to retrieve many components and check if they are valid.</p>
<p>First of all, create a C++ <strong>Behavior Tree Task</strong> that inherits from <strong>UBTTaskNode</strong> by selecting <span class="packt_screen">BTTaskNode</span> as the class you want to extend, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/839a566c-bd87-4113-8832-6fc2e2886660.png"/></p>
<p>Then, we can name it <kbd>BTTaskNode_FindRandomLocation</kbd> and place it (as we did for the Decorator) inside a folder, such as <kbd>AI</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/02f6f9e1-cdc7-4e23-bb65-49e540d8c474.png"/></p>
<p>First of all, in the header file, we need to add our two variables. The first one is the <em>Blackboard Key Selector</em> named <kbd>DestinationVector</kbd>, which will hold the reference to the newly calculated Destination. The second is a <em>float</em> containing a parametrization of the <strong><em>Radius</em></strong> (in which we will select a Random Reachable Point). Moreover, both of them need to be accessible to the <em>Behavior Tree Editor</em>; hence we need to expose them by using the <kbd>UPROPERTY()</kbd> macro. We need to use the following lines of code for these two variables:</p>
<pre>UPROPERTY(EditAnywhere, Category = Blackboard)<br/>    FBlackboardKeySelector DestinationVector;<br/><br/>UPROPERTY(EditAnywhere, Category = Parameters)<br/>    float Radius = 300.f;</pre>
<p>As always, in the header file, we need to override the <kbd>ExecuteTask()</kbd> method, which will be called when this task needs to be executed:</p>
<pre><span> </span>virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;</pre>
<p>This is what the whole header file should look like:</p>
<pre>#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "BehaviorTree/BTTaskNode.h"<br/>#include "BTTaskNode_FindRandomLocation.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class BEHAVIORTREEDESIGN_API UBTTaskNode_FindRandomLocation : public UBTTaskNode<br/>{<br/>  GENERATED_BODY()<br/><br/>  UPROPERTY(EditAnywhere, Category = Blackboard)<br/>  FBlackboardKeySelector DestinationVector;<br/><br/>  UPROPERTY(EditAnywhere, Category = Parameters)<br/>  float Radius = 300.f;<br/><br/>  virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;<br/>};</pre>
<p>Now, that we are getting to our <kbd>.cpp</kbd> file, we need to do some preparation, especially in the <kbd>include</kbd> statements. In fact, we are going to use the <strong>Blackboard Component</strong> (like we did for the Decorator), the <strong>Navigation System</strong>, and the <strong>AI Controller </strong>classes. Thus, we need to include all of them, which we can do by using the following code:</p>
<pre>#include "BTTaskNode_FindRandomLocation.h"<br/>#include "BehaviorTree/BlackboardComponent.h"<br/>#include "NavigationSystem.h"<br/>#include "AIController.h"</pre>
<p>So, let's define <span>the </span><kbd>ExecuteTask()</kbd><span> function</span>:</p>
<pre><strong>EBTNodeResult::Type UBTTaskNode_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)</strong><br/><strong>{</strong><br/><em>  //[REST OF THE CODE]</em><br/><strong>}</strong></pre>
<p>Then, we need to start filling up the <kbd>ExecuteTask()</kbd> function. The first thing we need to do is get the <strong>Blackboard Component</strong>. In case this component is not available (as explained in the <em>D</em><em>ecorator</em> section, this seldom happens, but it still might), we need to return that the Task has failed, as shown in the following code:</p>
<pre>EBTNodeResult::Type UBTTaskNode_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  <br/><strong>  //Get Blackboard Component</strong><br/><strong>  UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();</strong><br/><strong>  if (BlackboardComp == NULL)</strong><br/><strong>  {</strong><br/><strong>    return EBTNodeResult::Failed;</strong><br/><strong>  }</strong><br/><br/><em> //[REST OF THE CODE]</em><br/><br/>}</pre>
<p>From the Blackboard Component, we can retrieve the <strong><em>Controlled Pawn</em></strong> of the AI Controller that is running this instance of the <em>Behavior Tree</em>. This can be done by using a couple of GET functions. However, once again, the <em>Pawn</em> needs to be checked for its validity, and in case it isn't valid, then the tasks need to return a failure:</p>
<pre>EBTNodeResult::Type UBTTaskNode_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  <br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Get Controlled Pawn</strong><br/><strong>  APawn* ControlledPawn = OwnerComp.GetAIOwner()-&gt;GetPawn();</strong><br/><strong>  if (!ControlledPawn) {</strong><br/><strong>    return EBTNodeResult::Failed;</strong><br/><strong>  }</strong><br/><br/><em> //[REST OF THE CODE]</em><br/><br/>}</pre>
<p>Next, we need to get our Navigation System. As per Unreal 4.21, we will use the <kbd>UNavigationSystemV1</kbd> class to do so.</p>
<div class="packt_infobox">Starting from Unreal 4.20, the Navigation System has been refactored. Therefore, many functions and classes became deprecated. If the version of your Engine is below 4.20, this code will not work. In this case, you will need to use the <kbd>UNavigationSystem</kbd> class. This isn't covered in this book since it may only be of interest to a few readers with specific needs of using an old version of the engine.</div>
<p>To get the <strong>Current Navigation System</strong>, we need to specify the <strong>World</strong> from which we want to retrieve this data by using a specific function named <kbd>GetCurrent()</kbd> (referring to the Navigation System). Once we have obtained the Navigation System, we want to check its validity, and in case it isn't valid, then we make the Task fail:</p>
<pre>EBTNodeResult::Type UBTTaskNode_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  <br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Get Navigation System</strong><br/><strong>  UNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(GetWorld());</strong><br/><strong>  if (!NavSys)</strong><br/><strong>  {</strong><br/><strong>    return EBTNodeResult::Failed;</strong><br/><strong>  }</strong><br/><br/><em> //[REST OF THE CODE]</em><br/><br/>}</pre>
<p>There's one more step to go before we can perform the query on the Navigation System. We need to create a variable of the <kbd>FNavLocation</kbd> type named <kbd>Result</kbd>, which is a structure that our <strong>Navigation System</strong> will fill with the result of our query. In our case, we are only interested in the Location. As a result, the <strong>Navigation System</strong> is able to perform the query:</p>
<pre>EBTNodeResult::Type UBTTaskNode_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  <br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Prepare variables for Query</strong><br/><strong>  FNavLocation Result;</strong><br/><strong>  FVector Origin = ControlledPawn-&gt;GetActorLocation();</strong><br/><br/><em> //[REST OF THE CODE]</em><br/><br/>}</pre>
<p>The request to the Query can be done by using the <kbd>GetRandomReachablePointInRadius()</kbd> function. It has three mandatory parameters, which are the <strong><em>Origin</em></strong> from where this query needs to be performed, the <strong>Radius</strong>, and the Structure to return the result. In fact, its pure return value is a <em>boolean</em> that indicates if the query has succeeded or not, which we can use to check whether the task has failed or not:</p>
<pre>EBTNodeResult::Type UBTTaskNode_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  <br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Perform Query</strong><br/><strong>  bool bSuccess = NavSys-&gt;GetRandomReachablePointInRadius(Origin, Radius, Result);</strong><br/><strong>  if (!bSuccess) {</strong><br/><strong>    return EBTNodeResult::Failed;</strong><br/><strong>  }</strong><br/><br/><em> //[REST OF THE CODE]</em><br/><br/>}</pre>
<p>In case we were able to get a random point, we need to assign it within the blackboard and return that the task has succeeded:</p>
<pre>EBTNodeResult::Type UBTTaskNode_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  <br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Save Result and return success</strong><br/><strong>  BlackboardComp-&gt;SetValueAsVector(DestinationVector.SelectedKeyName, Result.Location);</strong><br/><strong>  return EBTNodeResult::Succeeded;</strong><br/>}</pre>
<p>If you try to compile this right now, you will get an error. The reason for this is that we have been using the <strong>Navigation System</strong>, but it was not included in the public dependencies of our module. Also, if you didn't include <kbd>AIModule</kbd> and <kbd>GameplayTasks</kbd>, this is the right moment to add them so that you can compile the code without any errors.</p>
<p>Open the <kbd>BehaviourTreeDesign.Build.cs</kbd> file and add the <kbd>NavigationSystem</kbd> module to the public dependencies, as shown in the following code:</p>
<pre><span> </span>PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", "GameplayTasks", "AIModule", <strong>"NavigationSystem"</strong> });</pre>
<p>Now, we can compile without any problems.</p>
<p>If we add this <em>Task</em> node to our <em>Behavior Tree</em>, this is what it will look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f133e894-985e-4ac6-a049-b7d18ac6e2cc.png" style="width:20.33em;height:21.00em;"/></p>
<p>The <em>Details Panel</em> looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e75a182b-6372-4420-98a0-e7fa37f5398c.png" style="width:24.33em;height:24.00em;"/></p>
<p>As we discussed earlier for the Decorator, it is always good practice to implement the functions that describe the node so that we can use it easier. I understand that we might not have an icon ready, but at least we can change the description to show which variables we have assigned.</p>
<p>To do this, we need to implement/override the <kbd>GetStaticDescription()</kbd> function. Declare it in the header file by adding the following line:</p>
<pre><span> </span>virtual FString GetStaticDescription() const override;</pre>
<p>Then, in the <kbd>.cpp</kbd> file, we need to return a <kbd>FString</kbd> that has been formatted to show the variables of the Task. In particular, we want to show the <kbd>DestinationKey</kbd> and how big the <strong><em>Radius</em></strong> is. We can easily format the string with the <kbd>Printf()</kbd> function, as shown in the following code:</p>
<pre>FString UBTTaskNode_FindRandomLocation::GetStaticDescription() const<br/>{<br/>  <br/>  return FString::Printf(TEXT("%s: '%s'"), TEXT("DestinationKey"), DestinationVector.IsSet() ? *DestinationVector.SelectedKeyName.ToString() : TEXT(""))<br/>      .Append(FString::Printf(TEXT("\n%s: '%s'"), TEXT("Radius"), *FString::SanitizeFloat(Radius)));<br/>}</pre>
<p class="mce-root"/>
<p>If we compile and add this <em>Task</em> again to a <em>Behavior Tree</em>, this is how it should appear now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed04c8ee-fde0-494c-83e3-195571c7af7c.png" style="width:22.33em;height:24.50em;"/></p>
<p>This concludes the implementation of our Task in C++.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AI Controller</h1>
                </header>
            
            <article>
                
<p>From the <em>Expected Behavior</em>, we have concluded that we need a <em>Perception System</em> to check whether the agent is able to see the <em>Player</em>.</p>
<p>Once again, we can create our AI Controller both in Blueprint or C++.</p>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the AI Controller in Blueprint</h1>
                </header>
            
            <article>
                
<p>First of all, create a new AI Controller and name it <kbd>BP_ChasingAIController</kbd> by selecting the <kbd>AIController</kbd> <em>Class</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ab550be6-e01b-42e0-980d-12cdc944bffb.png" style="width:37.08em;height:42.92em;"/></p>
<p>In the editor, we need to add two variables (so that the Service we build in the next chapter will be able to retrieve the values within them). The first variable is <kbd>LastKnownPlayerPosition</kbd> of type <em>Vector</em>, and the second is <kbd>CanSeePlayer</kbd> of type <em>boolean</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c66c5402-6d59-46b8-9a7f-faad17982be6.png" style="width:19.17em;height:22.42em;"/></p>
<p>Now, we need to add the perception component. So, from the <span class="packt_screen">Components</span> tab, add the <span class="packt_screen">AIPerception</span> system, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c4432dd0-12ca-44cc-ae92-89fd853c7858.png" style="width:18.67em;height:11.17em;"/></p>
<p>Then, in the <span class="packt_screen">Details</span> panel, we need to select the options for it. In particular, we need to set the <em><strong>Sense of Sight</strong></em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a347cbce-dbf7-443a-88f3-71123ec866ed.png" style="width:32.33em;height:24.67em;"/></p>
<p class="mce-root"/>
<p>Next, in the <strong>Sense Of Sight Config</strong> settings, check all the detection flags (as we explained in <a href="94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml" target="_blank">Chapter 5</a>, <em>Agent Awareness</em>, we need to detect the player, which by default is neutral). In the end, this is what the settings should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/30a5a1fd-dfe5-4759-9a1e-e0a1d210da94.png" style="width:39.42em;height:32.25em;"/></p>
<p>From the <span class="packt_screen">Details</span> panel, we need to generate the <span class="packt_screen">On Target Perception Updated</span> event by clicking on the <span class="packt_screen">+</span> symbol next to it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1e405f13-77bc-4be9-afe6-fbd220440243.png"/></p>
<p>Now, we cast the <strong>Actor</strong> pin from the event into our player (for example, <kbd>FirstPersonCharacter</kbd> or <kbd>ThirdPersonCharacter</kbd>, depending which template you choose, or your <em>Player class</em> if you are using this in your project), to check if the object of the perception is actually the player:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fb1ce399-58af-4be4-9762-64fc8b6b3a5e.png"/></p>
<p>Then, we break the <strong>Stimulus</strong> pin to get the <strong>Stimulus Location</strong>, which we store inside the <strong>LastKnownPlayerPosition</strong> variable, and <strong>Successfully Sensed</strong>, which we store inside the <strong><em>CanSeePlayer</em></strong> variable. Of course, these Set functions need to be placed after the cast. This is the final code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b1764676-a86c-4155-9f82-3be7b25e148d.png"/></p>
<p>The <strong><em>AI Controller</em></strong> is now ready to be used.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the AI Controller in C++</h1>
                </header>
            
            <article>
                
<p>First of all, create a new class that inherits from <kbd>AIController</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b4597ce4-e182-428c-83b9-3b6d54550a0c.png"/></p>
<p>Then, name it <kbd>ChasingAIController</kbd> and place it in our <kbd>AI</kbd> folder, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a9513b1a-fed0-46f3-a42e-90ad4c67cfdb.png"/></p>
<p>As we explained in the Chapter about the <em>Perception</em>, we first need to include the classes that concern the perception to be able to use them. Add the following <kbd>#include</kbd> statements in the header file:</p>
<pre>#include "Perception/AIPerceptionComponent.h"<br/>#include "Perception/AISense_Sight.h"<br/>#include "Perception/AISenseConfig_Sight.h"</pre>
<p>Next, we need to add the declaration of our <strong><em>Class Constructor</em></strong>, since we will be using one to set up our controller. Just below the <kbd>GENERATE_BODY()</kbd> macro, add the following code:</p>
<pre>  GENERATED_BODY()<br/><br/><strong>  AChasingAIController();</strong></pre>
<p>We need to keep track of the <kbd>PerceptionComponent</kbd> that we will add to the controller. However, the AI Controller base class, has already a reference to a Perception Component, so we don't need to declare it. You will find this very signature in the base class:</p>
<pre>  UPROPERTY(VisibleDefaultsOnly, Category = AI)<br/>  UAIPerceptionComponent* PerceptionComponent;</pre>
<p>However, we need to have a reference to the <em>Sight Configuration</em> that we will create, so we need this variable:</p>
<pre>UAISenseConfig_Sight* SightConfig;</pre>
<p>Since in the next chapter we will create a service that will gather some variables from this controller, we need to make two public variables. The first variable is the <kbd>LastKnownPlayerPosition</kbd> of type Vector, and the second is <kbd>CanSeePlayer</kbd> of type boolean. You can add them in the header with the following snippet of code:</p>
<pre class="mce-root">public:<br/>  FVector LastKnownPlayerPosition;<br/>  bool bCanSeePlayer;</pre>
<p>Finally, in our header file, we need to <strong>add a delegate</strong> for our Perception System that will update our variables. We can call this delegate <kbd>OnTargetPerceptionUpdated()</kbd> and make it protected. It has <kbd>AActor*</kbd> and <kbd>FAIStimuli</kbd> as inputs, as shown in the following code:</p>
<pre>protected:<br/>  UFUNCTION()<br/>  void OnTargetPerceptionUpdate(AActor* Actor, FAIStimulus Stimulus);</pre>
<p>Now, we need to create the <strong>Perception Component</strong> in the <strong>Constructor</strong> of the class. Add the following code:</p>
<pre>AChasingAIController::AChasingAIController() {<br/><br/><strong>  //Creating the AI Perception Component</strong><br/><strong>  PerceptionComponent = CreateDefaultSubobject&lt;UAIPerceptionComponent&gt;(TEXT("SightPerceptionComponent"));</strong><br/><br/>  //<em>[REST OF THE CODE]</em><br/><br/>}</pre>
<p>Then, we need to create the <em>Sight Sense</em>, and configure it to set all the <kbd>DetectionByAffiliation</kbd> to true, as shown in the following code:</p>
<pre>AChasingAIController::AChasingAIController() {<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Create the Sight Sense and Configure it</strong><br/><strong>  SightConfig = CreateDefaultSubobject&lt;UAISenseConfig_Sight&gt;(FName("Sight Config"));</strong><br/><strong>  SightConfig-&gt;DetectionByAffiliation.bDetectEnemies = true;</strong><br/><strong>  SightConfig-&gt;DetectionByAffiliation.bDetectNeutrals = true;</strong><br/><strong>  SightConfig-&gt;DetectionByAffiliation.bDetectFriendlies = true;</strong><br/><br/>  //<em>[REST OF THE CODE]</em><br/><br/>}</pre>
<p>Now that we have <kbd>PerceptionComponent</kbd> and <kbd>SightConfig</kbd>, we need to assign the latter to the first:</p>
<pre>AChasingAIController::AChasingAIController() {<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Assigning the Sight Sense to the AI Perception Component</strong><br/><strong>  PerceptionComponent-&gt;ConfigureSense(*SightConfig);</strong><br/><strong>  PerceptionComponent-&gt;SetDominantSense(SightConfig-&gt;GetSenseImplementation());</strong><br/><br/>  //<em>[REST OF THE CODE]</em><br/><br/>}</pre>
<p>The last step is to <strong><em>bind our delegate</em></strong> function to the <strong>Perception System</strong>, as shown in the following code:</p>
<pre>AChasingAIController::AChasingAIController() {<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Binding the OnTargetPerceptionUpdate function</strong><br/><strong>  PerceptionComponent-&gt;OnTargetPerceptionUpdated.AddDynamic(this, &amp;AChasingAIController::OnTargetPerceptionUpdate);</strong><br/><br/>}</pre>
<p>Now, we need to implement our <kbd>OnTargetPerceptionUpdate()</kbd> Delegate. First of all, we need to include the header file of our Player class. In this example case, we have a C++ class named <kbd>BehaviorTreeDesignCharacter</kbd> (the Blueprint <kbd>ThirdPersonCharacter</kbd> inherits from this class). In my case, I added the following #<kbd>include</kbd> statement (you can include the one of your Player class):</p>
<pre>#include "BehaviorTreeDesignCharacter.h"</pre>
<p>In particular, we need to check if the Actor (passed as input) is really the <em>Player</em> class, which we can do with a cast (to the Player class we have included):</p>
<pre>void AChasingAIController::OnTargetPerceptionUpdate(AActor * Actor, FAIStimulus Stimulus)<br/>{<br/><strong>  if(Cast&lt;ABehaviorTreeDesignCharacter&gt;(Actor)){</strong><br/><br/><strong>  }</strong><br/>}</pre>
<p>If this is the case, we can use the <strong><em>Stimulus</em></strong> input to retrieve the <kbd>StimulusLocation</kbd> if it <kbd>WasSuccessfullySensed</kbd> and assign it to our <kbd>LastKnownPlayerPosition</kbd> and <kbd>CanSeePlayer</kbd> variables, as shown in the following code:</p>
<pre>void AChasingAIController::OnTargetPerceptionUpdate(AActor * Actor, FAIStimulus Stimulus)<br/>{<br/>  if(Cast&lt;ABehaviorTreeDesignCharacter&gt;(Actor)){<br/><strong>    LastKnownPlayerPosition = Stimulus.StimulusLocation;</strong><br/><strong>    bCanSeePlayer = Stimulus.WasSuccessfullySensed();</strong><br/>  }<br/>}</pre>
<p>The AI Controller is now ready to be used!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the AI Controller</h1>
                </header>
            
            <article>
                
<p>Regardless of whether you used a Blueprint or C++ implementation, you need to assign the controller to your Chasing Agent. Whether you do so directly in the blueprint, or directly in the instanced version of the game, under the Pawn settings, you need to change the AI Controller so that it's the one we just created. We also need to ensure that the AI is able to auto-posses this pawn.</p>
<p>As a result, you should have something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/517ef3f9-0354-4e9b-b043-728261e5817c.png"/></p>
<p>Now, we have (almost) all the pieces to build our Chasing agent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started to look at our in-depth example of how to create a <strong><em>Behavior Tree</em></strong>, and have used all of the systems we have encountered so far.</p>
<p>In particular, we have seen how we can write down the <strong><em>Expected Behavior</em></strong> and work from there to gather all the different pieces that we need to build our AI. We have <span>seen how we can do this in both C++ and Blueprint. The pieces we have created were a </span><strong><em>Custom Decorator</em></strong>, to check <em>boolean</em> variables in our <strong>Behavior Tree</strong>,<strong> </strong>a<strong> </strong><strong>Custom Task</strong>, to find a random location by using the <strong>Navigation System</strong>, and a <strong>Custom AI Controller</strong> so that we can use the <strong>Perception System</strong> to sense the <strong>Player</strong>.</p>
<p>In the next chapter, we will continue with this example and build the last piece we need so that we can update the variables for the Chasing Behavior. At the end of the next chapter, you will be ready to build the Behavior Tree. So, let's move on!</p>


            </article>

            
        </section>
    </body></html>