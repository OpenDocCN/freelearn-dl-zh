["```py\n    private void Update () {\n        if (m_IsAI) {\n            return;\n        }\n        …\n    ```", "```py\n    // We need to make Fire public.\n    public void Fire (){\n        // Set the fired flag so only Fire is only called\n        // once. \n        m_Fired = true;\n        // Create an instance of the shell and store a\n        // reference to its rigidbody.\n        Rigidbody shellInstance = Instantiate (m_Shell, \n          m_FireTransform.position,\n          m_FireTransform.rotation) as Rigidbody;\n    // New lines: if AI, we shoot with average force. \n        if (m_IsAI) {\n    m_CurrentLaunchForce = \n              m_MaxLaunchForce / 2.0f;\n        }\n        // Set the shell's velocity to the launch force in\n        // the fire position's forward direction.\n        shellInstance.velocity = \n          m_CurrentLaunchForce * m_FireTransform.forward;\n        // Change the clip to the firing clip and play it. \n        m_ShootingAudio.clip = m_FireClip;\n        m_ShootingAudio.Play ();\n        // Reset the launch force. This is a precaution in\n        // case of missing button events.\n        m_CurrentLaunchForce = m_MinLaunchForce;\n    }\n    ```", "```py\n    // Reference to the prefab the players will control.\n    public GameObject m_TankPrefab;\n    // Reference to the prefab the AI will control.\n    public GameObject m_TankAIPrefab;\n    ```", "```py\n    private void SpawnAllTanks(){\n        // Spaw the Player\n        m_Tanks[0].m_Instance = Instantiate(m_TankPrefab,\n           m_Tanks[0].m_SpawnPoint.position,\n           m_Tanks[0].m_SpawnPoint.rotation);\n        m_Tanks[0].m_PlayerNumber = 01;\n        m_Tanks[0].Setup();\n        // Spawn the AI Tanks\n        for (int i = 1; i < m_Tanks.Length; i++) {\n            m_Tanks[i].m_Instance =\n              Instantiate(m_TankAIPrefab,\n              m_Tanks[i].m_SpawnPoint.position,\n              m_Tanks[i].m_SpawnPoint.rotation);\n            m_Tanks[i].m_PlayerNumber = i + 1;\n            m_Tanks[i].Setup();\n        }\n    }\n    ```", "```py\n    using UnityEngine;\n    using System.Collections;\n    public class FSM : Complete.TankMovement {\n        // Next destination position of the NPC Tank\n        protected Vector3 destPos;\n        // List of points for patrolling\n        protected GameObject[] pointList;\n        protected virtual void Initialize() { } \n        protected virtual void FSMUpdate() { } \n        protected virtual void FSMFixedUpdate() { }\n        // Use this for initialization\n        void Start() {\n            Initialize();\n        }\n        // Update is called once per frame \n        void Update() {\n            FSMUpdate();\n        }\n        void FixedUpdate() {\n            FSMFixedUpdate();\n        }\n    }\n    ```", "```py\n    using UnityEngine;\n    using System;\n    using UnityEngine.AI;\n    public class AITankController : FSM {\n        public Complete.TankShooting tankShooter;\n        public Complete.TankHealth tankHealth;\n        public float playerChaseRadius = 15.0f;\n        public float platerAttackRadius = 10.0f;\n        public float shootRate = 3.0f;\n        public float targetReachedRadius = 5.0f;\n        private bool isDead = false;\n        private float elapsedTime = 0.0f;\n        private GameObject player = null;\n        private NavMeshAgent navMeshAgent;\n        public enum FSMState {\n            None, Patrol, Attack, Dead,\n        }\n        // Current state that the NPC is reaching\n        public FSMState curState;\n    …\n    ```", "```py\n        //Initialize the Finite state machine for the NPC tank\n        protected override void Initialize() {\n            navMeshAgent = GetComponent<NavMeshAgent>();\n            // Get the list of points \n            pointList = GameObject.FindGameObjectsWithTag(\n              \"PatrolPoint\");\n            int rndIndex = UnityEngine.Random.Range(0,\n              pointList.Length);\n            destPos =\n              pointList[rndIndex].transform.position;\n        }\n    ```", "```py\n        // ...\n        private AudioSource m_ExplosionAudio \n        private ParticleSystem m_ExplosionParticles\n        private float m_CurrentHealth;\n        private bool m_Dead;\n        public float CurrentHealth { get; }\n        // ...\n    ```", "```py\n        protected override void FSMUpdate() {\n            switch (curState) {\n                case FSMState.Patrol: \n                    UpdatePatrolState();\n                    break; \n                case FSMState.Attack: \n                    UpdateAttackState(); \n                    break;\n                case FSMState.Dead: \n                    UpdateDeadState();\n                    break;\n            }\n            elapsedTime += Time.deltaTime;\n            // Go to dead state is no health left\n            if (tankHealth.CurrentHealth <= 0) {\n                curState = FSMState.Dead;\n            }\n        }\n    ```", "```py\n        private void UpdateDeadState() {\n            if (!isDead) {\n                Debug.Log(\"Dead\");\n            }\n        }\n    ```", "```py\n        private void UpdateAttackState() {\n            Collider[] players = Physics.OverlapSphere(\n              Transform.position, playerChaseRadius,\n              LayerMask.GetMask(\"Players\"));\n            if (players.Length == 0) {\n                curState = FSMState.Patrol;\n                player = null;\n                navMeshAgent.enabled = true; \n                return;\n            }\n            player = players[0].gameObject;\n            Vector3 _direction = \n              (player.transform.position – \n               transform.position).normalized;\n            Quaternion _lookRotation =\n              Quaternion.LookRotation(_direction);\n            transform.rotation = \n              Quaternion.Slerp(transform.rotation,\n              _lookRotation, Time.deltaTime * 3);\n            if (elapsedTime > shootRate) {\n                tankShooter.Fire(); \n                elapsedTime = 0;\n            }\n        }\n    ```", "```py\n        private void UpdatePatrolState() {\n            Collider[] players = Physics.OverlapSphere(\n              transform.position, playerAttackRadius,\n              LayerMask.GetMask(\"Players\")\"));\n            if (players.Length > 0) {\n                curState = FSMState.Attack;\n                player = players[0].gameObject;\n                navMeshAgent.enabled = false;\n                return;\n            }\n            if (IsInCurrentRange(destPos)) {\n                int rndIndex = UnityEngine.Random.Range(0,\n                  pointList.Length);\n                destPos =\n                  pointList[rndIndex].transform.position;\n            }\n            navMeshAgent.destination = destPos;\n        }\n    ```", "```py\n        protected bool IsInCurrentRange(Vector3 pos) {\n            float xPos = \n              Mathf.Abs(pos.x - transform.position.x);\n            float zPos = \n              Mathf.Abs(pos.z - transform.position.z);\n            if (xPos <= targetReachedRadius  && zPos <=\n                targetReachedRadius ) return true;\n            return false;\n        }\n    ```"]