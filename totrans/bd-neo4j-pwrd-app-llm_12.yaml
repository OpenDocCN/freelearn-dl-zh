- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Creating an Intelligent Recommendation System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建智能推荐系统
- en: Now that we have loaded the data into a graph, and looked at how we can augment
    the graph using Langchain4j and Spring AI, along with generating recommendations,
    we will look at how we can go further to improve the recommendations by leveraging
    **Graph Data Science** (**GDS**) **algorithms** and machine learning. We will
    review the GDS algorithms provided by Neo4j to go beyond the recommendation system
    we created in the previous chapter. We will also learn how to use the GDS algorithms
    to build collaborative filtering as well as content-based approaches to provide
    recommendations. We will also take a look at the results after we run the algorithms
    to review how our approach is working and whether we are on the right path to
    build a better recommendation system. We will try to understand why these algorithms
    are better than the approach we implemented in the previous chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据加载到图中，并查看如何使用Langchain4j和Spring AI以及生成推荐来增强图，我们将探讨如何进一步利用**图形数据科学**（**GDS**）**算法**和机器学习来改进推荐。我们将回顾Neo4j提供的GDS算法，以超越我们在上一章中创建的推荐系统。我们还将学习如何使用GDS算法构建协同过滤以及基于内容的推荐方法。我们还将查看算法运行后的结果，以审查我们的方法是否有效，以及我们是否走上了构建更好推荐系统的正确道路。我们将试图理解为什么这些算法比我们在上一章中实现的方法更好。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Improving recommendations with GDS algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDS算法改进推荐
- en: Understanding the power of communities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解社区的力量
- en: Combining collaborative filtering and content-based approaches
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合协同过滤和基于内容的策略
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will be using a Java IDE environment to work with the Langchain4j and Spring
    AI projects. You will need to have these installed and know how to work with them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Java IDE环境来与Langchain4j和Spring AI项目一起工作。您需要安装这些项目并了解如何使用它们。
- en: Setting up the environment
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: We will be starting from the graph database we built in the last chapter. The
    code is tested with the Neo4j `5.21.2` version of the database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一章中构建的图数据库开始。代码与Neo4j `5.21.2`版本的数据库进行了测试。
- en: To set up the environment, you will need
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置环境，您需要
- en: 'Neo4j Desktop with the following plugins installed. :'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了以下插件的Neo4j Desktop：
- en: APOC plugin – `5.21.2`
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: APOC插件 – `5.21.2`
- en: Graph Data Science library – `2.9.0`
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据科学库 – `2.9.0`
- en: '*Figure 10.1* shows how to install these plugins for a DBMS.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.1* 展示了如何为数据库管理系统安装这些插件。'
- en: '![Figure 10.1 — Install plugins in Neo4j Desktop](img/B31107_10_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 — 在Neo4j Desktop中安装插件](img/B31107_10_01.png)'
- en: Figure 10.1 — Install plugins in Neo4j Desktop
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 — 在Neo4j Desktop中安装插件
- en: When you select the DBMS in Neo4j Desktop, on the right side, it shows its details.
    Click on the **Plugins** tab and select the plugins. Once that is expanded, click
    on the **Install and Restart** button.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Neo4j Desktop中选择数据库管理系统时，在右侧，它会显示其详细信息。单击**插件**选项卡并选择插件。一旦展开，单击**安装和重启**按钮。
- en: Next, we will look at the database dump required for this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看本章所需的数据库转储。
- en: Getting the database ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据库
- en: 'Before you begin, you will need to create the communities. It will take some
    time for the similarity and community detection algorithms to complete. Thus,
    it is recommended to download the database dump from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/hmreco_post_augment_with_summary_communities](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/hmreco_post_augment_with_summary_communities).dump
    and use it to create a database in Neo4j Desktop. You can use these instructions
    to load this dump into Neo4j Desktop: [https://neo4j.com/docs/desktop-manual/current/operations/create-from-dump/](https://neo4j.com/docs/desktop-manual/current/operations/create-from-dump/).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，您需要创建社区。相似性和社区检测算法的完成需要一些时间。因此，建议从[https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/hmreco_post_augment_with_summary_communities](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/hmreco_post_augment_with_summary_communities).dump下载数据库转储，并使用它来在Neo4j
    Desktop中创建数据库。您可以使用以下说明将此转储加载到Neo4j Desktop中：[https://neo4j.com/docs/desktop-manual/current/operations/create-from-dump/](https://neo4j.com/docs/desktop-manual/current/operations/create-from-dump/)。
- en: This database dump has all the `SUMMER_2019_SIMILAR` relationships created and
    the communities are identified.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据库转储已创建所有 `SUMMER_2019_SIMILAR` 关系，并已识别社区。
- en: Let’s start with using the GDS algorithms to enhance our knowledge graph for
    improved recommendations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用GDS算法来增强我们的知识图，以改善推荐开始。
- en: Improving recommendations with GDS algorithms
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDS算法改进推荐
- en: In this section, we will look at how we can enhance the graph further to gain
    more insights into the graph to build a better recommendation system. We will
    start with the graph database we created in the last chapter. For reference, you
    can download it from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何进一步优化图，以获得更多关于图的洞察，从而构建一个更好的推荐系统。我们将从上一章中创建的图数据库开始。为了参考，您可以从[https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip)下载它。
- en: 'The Neo4j GDS algorithms ([https://neo4j.com/docs/graph-data-science/current/](https://neo4j.com/docs/graph-data-science/current/))
    will help us enhance the graph. This process includes the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GDS算法([https://neo4j.com/docs/graph-data-science/current/](https://neo4j.com/docs/graph-data-science/current/))将帮助我们增强图。此过程包括以下步骤：
- en: Calculate the similarity between customers based on the embeddings we have created
    and create a similar relationship between these customers. For this purpose, we
    will leverage the **K-Nearest Neighbors** (**KNN**) algorithm ([https://neo4j.com/docs/graph-data-science/current/algorithms/knn/](https://neo4j.com/docs/graph-data-science/current/algorithms/knn/)).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据我们创建的嵌入计算客户之间的相似性，并在这些客户之间创建相似关系。为此，我们将利用**K-Nearest Neighbors**（**KNN**）算法([https://neo4j.com/docs/graph-data-science/current/algorithms/knn/](https://neo4j.com/docs/graph-data-science/current/algorithms/knn/))。
- en: Run the community detection algorithm to group the customers based on similar
    relationships. For this purpose, we will leverage the **Louvain community detection**
    algorithm ([https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/)).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行社区检测算法，根据相似关系将客户分组。为此，我们将利用**Louvain社区检测**算法([https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/))。
- en: First, we will utilize the KNN algorithm to enhance the graph.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将利用KNN算法来增强图。
- en: Computing similarity with the KNN algorithm
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用KNN算法计算相似性
- en: The **K-Nearest Neighbors** (**KNN**) algorithm collects node pairs, computes
    a distance value between a node and its neighbors, and creates a relationship
    between the node and its **top K** neighbors. The distance is calculated based
    on node properties. We need to provide a homogeneous graph for this algorithm.
    When all the nodes and relationships are the same, it is called a **homogeneous
    graph**. The node pairs we provide to the KNN algorithm do not need any node labels
    or relationship types.  The KNN algorithm just needs node pairs that are connected
    and an optional property that can be used as the context of the relationship between
    them. You can read more about this at [https://neo4j.com/docs/graph-data-science/current/algorithms/knn](https://neo4j.com/docs/graph-data-science/current/algorithms/knn).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**K-Nearest Neighbors**（**KNN**）算法收集节点对，计算节点与其邻居之间的距离值，并在节点与其**前K个**邻居之间创建关系。距离是根据节点属性计算的。我们需要提供一个同质图来使用此算法。当所有节点和关系都相同时，它被称为**同质图**。我们提供给KNN算法的节点对不需要任何节点标签或关系类型。KNN算法只需要连接的节点对，以及一个可选的属性，该属性可以用作它们之间关系的上下文。您可以在[https://neo4j.com/docs/graph-data-science/current/algorithms/knn](https://neo4j.com/docs/graph-data-science/current/algorithms/knn)上了解更多信息。'
- en: 'To use this algorithm, we need to follow this process:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此算法，我们需要遵循以下过程：
- en: Project graph of interest to apply the algorithm.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将感兴趣的图项目应用于算法。
- en: 'Invoke the algorithm with the appropriate configuration. There are three modes
    of this algorithm:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的配置调用算法。此算法有三种模式：
- en: '**Stream**: This applies the algorithm to the in-memory graph and streams the
    results. You can use the stream mode to inspect the results and see if they are
    what we want.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stream**：此模式将算法应用于内存中的图，并流式传输结果。您可以使用流模式来检查结果，看看是否符合我们的期望。'
- en: '**Mutate**: This applies the algorithm to the in-memory graph and writes the
    data back to the in-memory graph. The actual database does not change. The mutate
    method is used when we want to update the in-memory graph and want to process
    it later for different purposes.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变异**：这将在内存图中应用算法并将数据写回内存图。实际数据库不会改变。当我们要更新内存图并希望以后用于不同目的时，使用变异方法。'
- en: '**Write**: This applies the algorithm to the in-memory graph and writes the
    relationships back to the actual database. This mode is used when we are sure
    of the process and want to write the results back to the graph immediately.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入**：这将在内存图中应用算法并将关系写回实际数据库。当我们对过程有信心并希望立即将结果写回图时，使用此模式。'
- en: We will start with graph projection. Since we have written the embeddings on
    the `SUMMER_2019` relationships, we will use those for processing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从图投影开始。由于我们在 `SUMMER_2019` 关系中写入了嵌入，我们将使用这些嵌入进行处理。
- en: 'This Cypher projects the graph in memory to be able to invoke this algorithm:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Cypher 将内存中的图投影以调用此算法：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Normally, we will use the properties on the node to build a projection. Here,
    we have written the embedding value on a relationship, as this embedding is created
    to represent the summer 2019 season purchases. If we had written that embedding
    on the `Customer` node, then if we wanted to understand the customer purchase
    behavior for various scenarios, we would need to use some clever naming to write
    those to only the `Customer` node. By writing that embedding on the relationship,
    we are preserving the context of the embedding in the graph.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将使用节点上的属性来构建投影。这里，我们将嵌入值写入关系，因为此嵌入是为了表示 2019 年夏季的购买而创建的。如果我们将其写入 `Customer`
    节点，那么如果我们想了解各种场景下的客户购买行为，我们就需要使用一些巧妙的命名来只将这些写入 `Customer` 节点。通过将嵌入写入关系，我们在图中保留了嵌入的上下文。
- en: We can see from the preceding Cypher that we are retrieving the embedding from
    the relationship and adding it as a source node property in the projection. Now,
    let us invoke the algorithm to write back similar relationships to the graph.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的 Cypher 可以看出，我们正在从关系中检索嵌入并将其作为投影中的源节点属性添加。现在，让我们调用算法将类似的关系写回图中。
- en: 'This Cypher invokes the algorithm to write back the results:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Cypher 调用算法将结果写回：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the Cypher, we can see we are invoking the `write` mode of the algorithm.
    The algorithm will calculate the similarity between Customers by using **cosine
    similarity** on the embeddings, with a cut-off score of `0.9`, pick the top 5
    neighbors in the order of similarity score, and write a relationship named `SUMMER_2019_SIMILAR`
    between those customers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Cypher 中，我们可以看到我们正在调用算法的 `write` 模式。该算法将通过在嵌入上使用 **余弦相似度** 来计算客户之间的相似度，阈值分数为
    `0.9`，按相似度分数的顺序选择前 5 个邻居，并在这些客户之间写入一个名为 `SUMMER_2019_SIMILAR` 的关系。
- en: '**Note**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Cosine similarity calculates the angle between two vectors. So, if the vectors
    are farther apart, then the similarity value will be close to 0\. If they are
    closer to each other, then the similarity value will be close to 1\. If you want
    to read more about it, you can read at [https://en.wikipedia.org/wiki/Cosine_similarity](https://en.wikipedia.org/wiki/Cosine_similarity).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦相似度计算两个向量之间的角度。因此，如果向量彼此更远，则相似度值将接近 0。如果它们彼此更近，则相似度值将接近 1。如果您想了解更多信息，可以阅读[https://en.wikipedia.org/wiki/Cosine_similarity](https://en.wikipedia.org/wiki/Cosine_similarity)。
- en: Similar scores can be between 0 and 1\. If the score is closer to 0 between
    2 entities, then they are not similar to each other. If it is close to 1, then
    they are more similar. We are using `0.9` as the similarity cutoff as we are generating
    embeddings based on the summary text generated – customers might have a higher
    similarity score. We don’t want a similar relationship between customers because
    there are some keywords that are similar. We will validate this assumption in
    later steps. We are limiting ourselves to the top five (`k` `=5`) similar customer
    behaviors, to get closer recommendations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相似度分数可以在 0 和 1 之间。如果两个实体之间的分数接近 0，则它们彼此不相似。如果接近 1，则它们更相似。我们使用 `0.9` 作为相似度阈值，因为我们基于生成的摘要文本生成嵌入
    - 客户可能具有更高的相似度分数。我们不希望客户之间存在相似关系，因为有一些关键词是相似的。我们将在后续步骤中验证此假设。我们将限制自己只考虑前五个（`k`
    `=5`）相似客户行为，以获得更接近的推荐。
- en: '**Note**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Please note that the KNN algorithm is a non-deterministic algorithm by default.
    This means that different runs might give different results. You can learn more
    about this at [https://neo4j.com/docs/graph-data-science/2.14/algorithms/knn/](https://neo4j.com/docs/graph-data-science/2.14/algorithms/knn/).
    If you want deterministic results, then you must ensure that the concurrency parameter
    is set to one and the `randomSeed` parameter is explicitly set.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，KNN算法默认是一个非确定性算法。这意味着不同的运行可能会得到不同的结果。您可以在[https://neo4j.com/docs/graph-data-science/2.14/algorithms/knn/](https://neo4j.com/docs/graph-data-science/2.14/algorithms/knn/)了解更多信息。如果您想要确定性结果，则必须确保并发参数设置为1，并且显式设置`randomSeed`参数。
- en: 'Once the algorithm is invoked, we need to remove the graph projection. Otherwise,
    it will keep using the memory in the database server:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用算法，我们需要删除图投影。否则，它将继续使用数据库服务器中的内存：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This Cypher will drop the graph and clear the memory used by the graph projection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此Cypher将删除图并清除图投影使用的内存。
- en: We will take a look at community detection next, based on the `SUMMER_2019_SIMILAR`
    relationship.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于`SUMMER_2019_SIMILAR`关系查看社区检测。
- en: For this, we will be leveraging the Louvain community detection algorithm, which
    is the most popular community detection algorithm.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将利用Louvain社区检测算法，这是最受欢迎的社区检测算法。
- en: Detecting communities with the Louvain algorithm
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Louvain算法检测社区
- en: The **Louvain algorithm** relies on the similarity scores between entities and
    groups them into communities. It takes large, networked data and groups it into
    smaller, tighter-knit communities by looking at the neighbors and their relationships.  This
    hierarchical clustering algorithm recursively merges communities into a single
    node and executes the modularity clustering on the condensed graphs. It maximizes
    a modularity score for each community, evaluating how much more densely connected
    the nodes within a community are compared to how connected they would be in a
    random network. We want to group our customers in more tight-knit groups in a
    more automated way to provide broader recommendations. You can read more about
    this at [https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Louvain算法**依赖于实体和组之间的相似度分数，并将它们分组到社区中。它通过查看邻居及其关系，将大型、网络化数据分组到更小、更紧密的社区中。这个层次聚类算法递归地将社区合并成一个节点，并在压缩图上执行模块度聚类。它为每个社区最大化模块度分数，评估社区内节点之间的连接密度与它们在随机网络中连接密度的差异。我们希望通过更自动化的方式将客户分组到更紧密的群体中，以提供更广泛的推荐。您可以在[https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/)了解更多信息。'
- en: The approach is very similar to how we invoked the KNN algorithm. To use this
    algorithm, we need to follow this process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们调用KNN算法的方式非常相似。要使用此算法，我们需要遵循以下过程。
- en: Project graph of interest to apply the algorithm.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将感兴趣的图项目应用于算法。
- en: Invoke the algorithm with the appropriate configuration. There are three modes
    of this algorithm.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的配置调用算法。此算法有三种模式。
- en: '**Stream**: This applies the algorithm to the in-memory graph and streams the
    results. You can use the stream mode to inspect the results and see if they are
    what we want.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流式处理**：将算法应用于内存中的图，并将结果流式传输。您可以使用流式处理模式来检查结果，看看是否符合我们的预期。'
- en: '**Mutate**: This applies the algorithm to the in-memory graph and writes the
    data back to the in-memory graph. The actual database has not changed. The `mutate`
    method is used when we want to update the in-memory graph and want to process
    it later for different purposes.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变异**：将算法应用于内存中的图，并将数据写回内存中的图。实际数据库没有改变。当我们要更新内存中的图并希望以后用于不同目的时，使用`mutate`方法。'
- en: '**Write**: This applies the algorithm to the in-memory graph and writes the
    relationships back to the actual database. This mode is used when we are sure
    of the process and want to write the results back to the graph immediately.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入**：将算法应用于内存中的图，并将关系写回实际数据库。当我们对过程有信心并希望立即将结果写回图时，使用此模式。'
- en: 'Let’s start with **graph projection**. We will use the `SUMMER_2019_SIMILAR`
    relationship and the `score` value saved on that relationship to perform community
    detection:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**图投影**开始。我们将使用`SUMMER_2019_SIMILAR`关系及其上保存的`score`值来执行社区检测：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding Cypher creates an in-memory projection named `communityGraph`.
    It takes the source node, target node, and the score on the `SUMMER_2019_SIMILAR`
    relationship to build the projection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the projection is built, we can use this Cypher to perform community detection:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This Cypher performs the community detection and writes back the community ID
    as a property named `summer_2019_community` on the `Customer` node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Once the community detection is complete, we need to drop the graph projection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This Cypher will drop the graph and clear the memory used by the graph projection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this Cypher to inspect how many communities are created:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This Cypher gives all communities, in the order of how many customers belong
    to that community. The response would look as shown in *Figure 10.2*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 — Communities with customer counts](img/B31107_10_02.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 — Communities with customer counts
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the Louvain community detection algorithm is a non-deterministic
    algorithm by default. This means that different runs might give different results.
    You can learn more about this at [https://neo4j.com/docs/graph-data-science/2.14/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/2.14/algorithms/louvain/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built communities, let us take a look at the communities generated.
    In the next section, we will inspect a few of these communities to observe whether
    they group customers based on their purchase behavior.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the power of communities
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor059), we looked at
    finding similar customers using vector similarity and how to provide recommendations
    for a customer. Let’s revisit *Figure 9.10* and *Figure 9.11*. *Figure 9.10* displays
    the purchase history of customers similar to a particular customer. *Figure 9.11*
    shows the recommendations for a customer based on the purchases of similar customers.
    The purchase history and customer recommendations are a result of the Cypher queries
    we worked on in the *Fine-tuning your recommendations* section to understand vector
    similarity usage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a deeper look at communities and see why they
    might be better than leveraging simple vector similarity to find similar customers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The following Cyphers are related to the database shared in the *Technical
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: requirements* section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: From the Cypher we ran in the last section, *Detecting communities with the
    Louvain  algorithm*, let us pick a community that has a good number of customers
    in it. We will take a look at the community with ID `133`, which has around `1,242`
    customers in it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Cypher displays the customer purchase summary without the article
    details for the first five customers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we run community detection, the community IDs generated can be different
    for each run. So, if you have run your own Cypher script to create the customer
    communities, you need to take a look at the communities and use those IDs to validate
    the data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行社区检测时，每次运行生成的社区ID可能都不同。所以，如果你已经运行了自己的Cypher脚本来创建客户社区，你需要查看这些社区并使用那些ID来验证数据。
- en: 'When we run the preceding Cypher script, the output looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的Cypher脚本时，输出看起来像这样：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the summary descriptions, we can see the customers in this community prefer
    to buy casual and lingerie clothing together.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从摘要描述中，我们可以看出这个社区的顾客更喜欢一起购买休闲和内衣服装。
- en: 'Let’s take a look at the articles purchased by these customers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些客户购买的文章：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This Cypher gives this output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Cypher语句给出了以下输出：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are limiting ourselves to the first three articles so that we won’t look
    at a lot of data here. We can see from the articles purchased that the summaries
    summarize the customer’s purchase behavior well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们限制自己只查看前三篇文章，这样我们不会在这里查看大量数据。我们可以从购买的文章中看到，摘要很好地总结了客户的购买行为。
- en: Let us look at how the customer age group to communities’ correlation exists.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看客户年龄组与社区之间的相关性是如何存在的。
- en: 'The following Cypher gives us the most frequently occurring age group in a
    community age group in a community:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Cypher语句为我们提供了社区中年龄组最频繁出现的年龄段：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The results will look as shown in *Figure 10.3*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如图*图10.3*所示。
- en: '| Community | Age Group | Ratio |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 社区 | 年龄组 | 比率 |'
- en: '| 1899 | “Youth” | 60.87 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 1899 | “青年” | 60.87 |'
- en: '| 5823 | “Adult” | 56.68 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 5823 | “成人” | 56.68 |'
- en: '| 770 | “Youth” | 47.9 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 770 | “青年” | 47.9 |'
- en: '| 1729 | “Youth” | 46.92 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 1729 | “青年” | 46.92 |'
- en: '| 4602 | “Youth” | 45.71 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 4602 | “青年” | 45.71 |'
- en: '| 133 | “Youth” | 44.61 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 133 | “青年” | 44.61 |'
- en: '| 921 | “Youth” | 44.17 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 921 | “青年” | 44.17 |'
- en: '| 3444 | “Youth” | 41.73 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 3444 | “青年” | 41.73 |'
- en: '| 649 | “Youth” | 41.62 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 649 | “青年” | 41.62 |'
- en: '| 1881 | “Youth” | 41.26 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 1881 | “青年” | 41.26 |'
- en: '| 1696 | “Old” | 41.06 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 1696 | “老年” | 41.06 |'
- en: '| 2381 | “Old” | 40.94 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 2381 | “老年” | 40.94 |'
- en: '| 6010 | “Old” | 37.67 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 6010 | “老年” | 37.67 |'
- en: '| 713 | “Youth” | 37.64 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 713 | “青年” | 37.64 |'
- en: '| 760 | “Youth” | 36.09 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 760 | “青年” | 36.09 |'
- en: '| 1875 | “Old” | 35.09 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 1875 | “老年” | 35.09 |'
- en: '| 2778 | “Youth” | 34.47 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 2778 | “青年” | 34.47 |'
- en: Figure 10.3 — Most frequently occurring age group and its ratio in every community
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 — 每个社区中最频繁出现的年龄组和其比率
- en: We can see most communities are dominated by the **Age Group****,** **Youth**,
    who are aged between 20 and 30\. Let us look at one of the communities where the
    **Youth** age group is not dominant. Let us look at community **5823**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到大多数社区都由**年龄组**，**青年**主导，他们的年龄在20到30岁之间。让我们看看一个**青年**年龄组不是主导的社区。让我们看看社区**5823**。
- en: 'This Cypher gives us the first five customers’ purchase summary of community
    `5823`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Cypher语句给出了社区`5823`前五个客户的购买摘要：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you perform a similarity search for a specific customer using their vector
    embedding, the results will primarily be other individual customers whose vector
    representations are close to the target customer’s vector. You may observe a degree
    of heterogeneity. An important caveat is that when we solely rely on finding similar
    customers to a target customer, based on vector distance, we might miss out on
    potentially relevant recommendations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用特定客户的向量嵌入进行相似度搜索时，结果将主要是其他与目标客户向量表示接近的个体客户。你可能观察到一定程度的不一致性。一个重要的注意事项是，当我们仅仅基于向量距离寻找与目标客户相似的客户时，我们可能会错过潜在的相关推荐。
- en: 'Take a look at the following results:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下结果：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These summaries show this community leans toward people who have kids. After
    observing the communities and a few customer summaries in those communities, we
    are able to understand the purchase behaviors better than just going by vector
    similarity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些摘要显示这个社区倾向于有孩子的家庭。在观察了这些社区和其中的一些客户摘要后，我们能够比仅仅根据向量相似度更好地理解购买行为。
- en: Our next step is to combine collaborative filtering and content-based approaches
    to give better recommendations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是将协同过滤和基于内容的途径结合起来，以提供更好的推荐。
- en: Combining collaborative filtering and content-based approaches
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合协同过滤和基于内容的途径
- en: '**Collaborative filtering** involves providing recommendations based on customer
    similarity based on their purchases, using which we have built customer communities,
    or using article similarity based on their characteristics. **Content-based filtering**
    allows providing recommendations based on article attributes or characteristics.
    We will take a look at how we can combine both of these approaches to provide
    better recommendations.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**协同过滤**涉及根据客户的购买相似性提供推荐，我们据此构建了客户社区，或者根据他们的特征进行文章相似性过滤。**基于内容的过滤**允许根据文章属性或特征提供推荐。我们将探讨如何结合这两种方法以提供更好的推荐。'
- en: 'We will try these scenarios:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试以下场景：
- en: '**Scenario 1**: Filtering articles that belong to other communities'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景1**：过滤属于其他社区的文章'
- en: '**Scenario 2**: Filtering articles by characteristics and belonging to other
    communities'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景2**：根据特征过滤并属于其他社区的文章'
- en: Let’s discuss Scenario 1 first.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论场景1。
- en: 'Scenario 1: Filtering articles that belong to other communities'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**场景1**：过滤属于其他社区的文章'
- en: In this scenario, we will first find all the articles purchased by all the customers
    in the same community. Next, we will find the articles purchased by customers
    who belong to other communities.  The articles that belong to other communities
    will then be removed. This is followed by filtering out (removing) these articles
    (belonging to other communities).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们首先找到所有同一社区内所有客户购买的商品。接下来，我们将找到属于其他社区的客户购买的商品。然后，我们将移除属于其他社区的商品。随后，我们将过滤掉（移除）这些属于其他社区的商品。
- en: For this scenario, we will pick the customer identified by `000ae8a03447710b4de81d85698dfc0559258c93136650efc2429fcca80d699a`
    from community `1696`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，我们将从社区`1696`中选取由`000ae8a03447710b4de81d85698dfc0559258c93136650efc2429fcca80d699a`标识的客户。
- en: 'Let us look at the purchase summary for this customer:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这位客户的购买摘要：
- en: '[PRE14]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This Cypher gives us this output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Cypher给出了以下输出：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let us get recommendations for this customer – the articles that they have
    not purchased earlier, using the following Cypher:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为这位客户获取推荐——他们之前未购买的商品，使用以下Cypher：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Get the articles purchased by this customer:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取这位客户购买的商品：
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Get the articles purchased by customers in the same community as the original
    customer:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与原始客户属于同一社区的客户购买的商品：
- en: '[PRE18]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Get the articles purchased by customers that are not in the same community
    as the original customer:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取不属于与原始客户同一社区的客户购买的商品：
- en: '[PRE19]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remove the articles purchased by customers outside the community the original
    customer belongs to:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除原始客户所属社区外的客户购买的商品：
- en: '[PRE20]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remove the articles purchased by the original customer from the `onlyInCommunityArticles`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`onlyInCommunityArticles`中移除原始客户购买的商品：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Provide 10 recommended articles from the remaining list. We are limiting this
    to 10 articles for simplicity and demonstration purposes. We can look at all the
    articles and maybe group them by other aspects and provide different recommendations:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从剩余列表中提供10篇推荐文章。为了简单和演示目的，我们限制为10篇文章。我们可以查看所有文章，并可能根据其他方面进行分组，提供不同的推荐：
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we get the articles purchased by the customer first. Then, we retrieve
    all the articles of the community the customer belongs to. After that, we get
    all the articles customers belonging to other communities purchased. We get the
    subset of the articles purchased only by customers in the community. From this
    set, we remove the articles the customer purchased and provide the articles as
    recommendations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取客户购买的商品。然后，我们检索客户所属社区的所有商品。之后，我们获取属于其他社区的客户购买的所有商品。我们从这些商品中获取仅由社区内客户购买的商品子集。从这个集合中，我们移除客户购买的商品，并将这些商品作为推荐提供。
- en: The output of this query would look as shown in *Figure 10.4*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的输出将如图10.4所示。
- en: '| Id | Desc |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| Id | Desc |'
- en: '| 0708679001 | Slim-fit, ankle-length jeans in washed, superstretch denim with
    a high waist, zip fly, fake front pockets and real back pockets. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0708679001 | 紧身，脚踝长牛仔裤，水洗，超弹力牛仔布，高腰，拉链前开，假前口袋和真后口袋。|'
- en: '| 0834749001 | Oversized jumper in a soft rib knit containing some wool with
    a polo neck, low dropped shoulders, long, voluminous sleeves, and wide ribbing
    at the cuffs and hem. The polyester content of the jumper is recycled. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 0834749001 | 超大号柔软罗纹针织衫，含有部分羊毛，圆领，低落肩，长袖，袖口和下摆宽罗纹。该运动衫的聚酯含量为回收材料。|'
- en: '| 0513701002 | V-neck T-shirts in organic cotton jersey. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 0513701002 | 有机棉针织圆领T恤。 |'
- en: '| 0522374003 | Jumper in a soft, fine knit with dropped shoulders, long sleeves
    and gently rounded hem. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 0522374003 | 一件柔软、精细针织的落肩长袖毛衣，下摆圆滑。 |'
- en: '| 0522374001 | Jumper in a soft, fine knit with dropped shoulders, long sleeves
    and gently rounded hem. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 0522374001 | 一件柔软、精细针织的落肩长袖毛衣，下摆圆滑。 |'
- en: '| 0687041002 | Long-sleeved, fitted top in soft, organic cotton jersey with
    a deep neckline, buttons at the top and a rounded hem. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 0687041002 | 长袖合身上衣，柔软的有机棉针织，深领口，顶部有纽扣和圆下摆。 |'
- en: '| 0724567004 | Pyjamas with a strappy top and shorts in soft satin with lace
    details. Top with a V-neck and narrow adjustable shoulder straps. Shorts with
    narrow elastication at the waist. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 0724567004 | 带有细肩带和短裤的睡衣，柔软缎面，有蕾丝装饰。上衣有V领和窄可调节肩带。短裤腰部有窄弹性。 |'
- en: '| 0785086001 | Short satin nightslip with a V-neck, lace trims at the top and
    hem, and adjustable spaghetti shoulder straps. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 0785086001 | V领缎面睡衣，顶部和下摆有蕾丝装饰，可调节的细肩带。 |'
- en: '| 0725353002 | Bell-shaped, knee-length skirt in woven fabric with a high waist
    and a concealed zip and hook-and-eye fastening in one side. Lined. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 0725353002 | 高腰、包臀的针织裙，侧面有隐藏的拉链和钩扣闭合。有衬里。 |'
- en: '| 0604655007 | Pyjamas in printed cotton jersey. Short-sleeved top with a round
    neck. Bottoms with an elasticated waist and wide, gently tapered legs with ribbed
    hems. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0604655007 | 印花棉针织睡衣。圆领短袖上衣。底部有弹性腰围和宽大的、略微收窄的腿，边缘有罗纹。 |'
- en: Figure 10.4  — Recommendations by filtering out the articles purchased by a
    customer and by customers outside the community
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4  — 通过过滤客户购买的文章和社区外客户购买的文章进行推荐
- en: These recommendations do seem to fit into the customer purchase summary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些推荐似乎符合客户的购买摘要。
- en: Now let us look at scenario 2.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看场景 2。
- en: 'Scenario 2: Filtering articles by characteristics and belonging to other communities'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景 2：通过特征和属于其他社区过滤文章
- en: In this scenario, we want to add article characteristics to the query. This
    means, for a customer, we will first find all the articles purchased by the community
    with certain characteristics. Then we will find the communities these articles
    belong to and remove the articles that belong to other communities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们希望将文章特征添加到查询中。这意味着，对于一个客户，我们首先找到社区中以特定特征购买的 所有文章。然后我们将找到这些文章所属的社区，并移除属于其他社区的文章。
- en: For this purpose, we will choose community `5823` and the customer with ID `00281c683a8eb0942e22d88275ad756309895813e0648d4b97c7bc8178502b33`.
    Let us look at this customer’s purchases.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将选择社区 `5823` 和 ID 为 `00281c683a8eb0942e22d88275ad756309895813e0648d4b97c7bc8178502b33`
    的客户。让我们看看这位客户的购买情况。
- en: 'This Cypher gives us this information:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 Cypher 给我们以下信息：
- en: '[PRE23]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Based on the preceding Cypher we get this output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的 Cypher 我们得到以下输出：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since this customer is buying clothing from the `"Kids Boy"` section, let us
    retrieve recommendations that belong to this section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这位客户正在购买 `"Kids Boy"` 部分的服装，让我们检索属于此部分的建议。
- en: 'This Cypher gives us recommendations by adding this section’s details to the
    earlier query. Let us get the Customer with ID: `00281c683a8eb0942e22d88275ad756309895813e0648d4b97c7bc8178502b33`
    and the section named `Kids Boy`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 Cypher 通过将此部分的详细信息添加到早期查询中，给出推荐。让我们获取 ID 为：`00281c683a8eb0942e22d88275ad756309895813e0648d4b97c7bc8178502b33`
    的客户和名为 `Kids Boy` 的部分：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Get the articles purchased by this customer that belong to the section of importance:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取该客户购买且属于重要部分的文章：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Get the articles that belong to the section of importance purchased by customers
    in the same community as the original customer:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与原始客户属于同一社区的客户购买的重要部分的文章：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Get the articles that belong to the section of importance purchased by customers
    in the communities outside the one the original customer belongs to:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取原始客户所属社区之外的其他社区的客户购买的重要部分的文章：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Remove the articles purchased by customers outside the community from the articles
    purchased by customers in the community of the original customer:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从原始客户所属社区的客户购买的文章中移除社区外客户购买的文章：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Remove the articles purchased by the original customer from the list of articles
    we got in the previous step:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一步得到的文章列表中移除原始客户购买的文章：
- en: '[PRE30]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Provide 10 of these articles as recommendations:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供以下 10 篇文章作为推荐：
- en: '[PRE31]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we run this query, we will see the output shown in *Figure 10.5*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个查询时，我们将看到*图10.5*所示的输出：
- en: '| Id | Desc |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Id | Desc |'
- en: '| 0505507003 | 5-pocket slim-fit jeans in washed stretch denim with an adjustable
    elasticated waist and zip fly. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 0505507003 | 洗涤弹力牛仔布5口袋修身牛仔裤，可调节弹性腰带和拉链式前门襟。 |'
- en: '| 0704150011 | Long-sleeved top in sweatshirt fabric with a motif on the front
    and ribbing around the neckline, cuffs and hem. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 0704150011 | 前面有图案、领口、袖口和下摆处有罗纹的套头衫长袖上衣。 |'
- en: '| 0701969005 | Shorts in soft, patterned cotton twill with an elasticated drawstring
    waist, fake fly and side pockets. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 0701969005 | 软质、图案棉斜纹布短裤，弹性抽绳腰带，假拉链和侧口袋。 |'
- en: '| 0595548001 | Shorts in soft, washed denim with an elasticated drawstring
    waist and a back pocket. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 0595548001 | 软质洗涤牛仔布短裤，弹性抽绳腰带和后口袋。 |'
- en: '| 0704150006 | Long-sleeved top in sweatshirt fabric with a motif on the front
    and ribbing around the neckline, cuffs and hem. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 0704150006 | 前面有图案、领口和袖口处有罗纹的套头衫长袖上衣。 |'
- en: '| 0626380001 | Top in soft, patterned cotton jersey with long sleeves, an open
    chest pocket and slits at the hem. Slightly longer at the back. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 0626380001 | 长袖套头衫，柔软的图案棉质圆领T恤，胸前开口口袋和下摆开叉。后身略长。 |'
- en: '| 0701972005 | Shorts in woven fabric with an adjustable elasticated waist
    and decorative drawstring. Zip fly and button, diagonal side pockets and welt
    back pockets. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 0701972005 | 织物短裤，可调节弹性腰带和装饰性抽绳。拉链式前门襟和纽扣，斜侧口袋和贴袋。 |'
- en: '| 0771489001 | T-shirts in airy cotton jersey with a chest pocket and short
    slits in the sides. Longer at the back. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 0771489001 | 空气棉质圆领T恤，胸前口袋和侧面短开叉。后身略长。 |'
- en: '| 0705911001 | Vest top in cotton jersey with a print motif and a ribbed trim
    around the neckline and armholes. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 0705911001 | 棉质圆领T恤，带有印花图案和领口及袖口罗纹装饰。 |'
- en: '| 0666327011 | T-shirt in soft cotton jersey with a motif on the front. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 0666327011 | 前面有图案的柔软棉质圆领T恤。 |'
- en: Figure 10.5 — Recommendations that consider purchases and article attributes
    by filtering out the articles purchased by the customer and by customers outside
    the community
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 — 通过过滤掉客户和社区外客户的购买文章，考虑购买和文章属性进行推荐的示例
- en: The demonstrations in this chapter showed how, by using these approaches, we
    can provide different types of recommendations based on similar purchases by other
    customers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的演示展示了如何通过使用这些方法，根据其他客户的相似购买提供不同类型的推荐。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to go beyond a basic recommendation application
    and leverage graph algorithms to enhance the graph and provide more appropriate
    recommendations. We explored how we can use the KNN similarity algorithm and community
    detection to gain hidden insights into the data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何超越基本的推荐应用程序，利用图算法来增强图并提供更合适的推荐。我们探讨了如何使用KNN相似度算法和社区检测来从数据中获得隐藏的洞察。
- en: In the upcoming chapters, we will take a look at how we can deploy these applications
    in the cloud and what best practices we can follow for deployment.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何将这些应用程序部署到云中，以及我们可以在部署过程中遵循的最佳实践。
