- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an Intelligent Recommendation System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have loaded the data into a graph, and looked at how we can augment
    the graph using Langchain4j and Spring AI, along with generating recommendations,
    we will look at how we can go further to improve the recommendations by leveraging
    **Graph Data Science** (**GDS**) **algorithms** and machine learning. We will
    review the GDS algorithms provided by Neo4j to go beyond the recommendation system
    we created in the previous chapter. We will also learn how to use the GDS algorithms
    to build collaborative filtering as well as content-based approaches to provide
    recommendations. We will also take a look at the results after we run the algorithms
    to review how our approach is working and whether we are on the right path to
    build a better recommendation system. We will try to understand why these algorithms
    are better than the approach we implemented in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Improving recommendations with GDS algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the power of communities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining collaborative filtering and content-based approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using a Java IDE environment to work with the Langchain4j and Spring
    AI projects. You will need to have these installed and know how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be starting from the graph database we built in the last chapter. The
    code is tested with the Neo4j `5.21.2` version of the database.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the environment, you will need
  prefs: []
  type: TYPE_NORMAL
- en: 'Neo4j Desktop with the following plugins installed. :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APOC plugin – `5.21.2`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph Data Science library – `2.9.0`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 10.1* shows how to install these plugins for a DBMS.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 — Install plugins in Neo4j Desktop](img/B31107_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 — Install plugins in Neo4j Desktop
  prefs: []
  type: TYPE_NORMAL
- en: When you select the DBMS in Neo4j Desktop, on the right side, it shows its details.
    Click on the **Plugins** tab and select the plugins. Once that is expanded, click
    on the **Install and Restart** button.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the database dump required for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the database ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you begin, you will need to create the communities. It will take some
    time for the similarity and community detection algorithms to complete. Thus,
    it is recommended to download the database dump from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/hmreco_post_augment_with_summary_communities](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/hmreco_post_augment_with_summary_communities).dump
    and use it to create a database in Neo4j Desktop. You can use these instructions
    to load this dump into Neo4j Desktop: [https://neo4j.com/docs/desktop-manual/current/operations/create-from-dump/](https://neo4j.com/docs/desktop-manual/current/operations/create-from-dump/).'
  prefs: []
  type: TYPE_NORMAL
- en: This database dump has all the `SUMMER_2019_SIMILAR` relationships created and
    the communities are identified.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with using the GDS algorithms to enhance our knowledge graph for
    improved recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Improving recommendations with GDS algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how we can enhance the graph further to gain
    more insights into the graph to build a better recommendation system. We will
    start with the graph database we created in the last chapter. For reference, you
    can download it from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Neo4j GDS algorithms ([https://neo4j.com/docs/graph-data-science/current/](https://neo4j.com/docs/graph-data-science/current/))
    will help us enhance the graph. This process includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the similarity between customers based on the embeddings we have created
    and create a similar relationship between these customers. For this purpose, we
    will leverage the **K-Nearest Neighbors** (**KNN**) algorithm ([https://neo4j.com/docs/graph-data-science/current/algorithms/knn/](https://neo4j.com/docs/graph-data-science/current/algorithms/knn/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the community detection algorithm to group the customers based on similar
    relationships. For this purpose, we will leverage the **Louvain community detection**
    algorithm ([https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we will utilize the KNN algorithm to enhance the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Computing similarity with the KNN algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **K-Nearest Neighbors** (**KNN**) algorithm collects node pairs, computes
    a distance value between a node and its neighbors, and creates a relationship
    between the node and its **top K** neighbors. The distance is calculated based
    on node properties. We need to provide a homogeneous graph for this algorithm.
    When all the nodes and relationships are the same, it is called a **homogeneous
    graph**. The node pairs we provide to the KNN algorithm do not need any node labels
    or relationship types.  The KNN algorithm just needs node pairs that are connected
    and an optional property that can be used as the context of the relationship between
    them. You can read more about this at [https://neo4j.com/docs/graph-data-science/current/algorithms/knn](https://neo4j.com/docs/graph-data-science/current/algorithms/knn).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this algorithm, we need to follow this process:'
  prefs: []
  type: TYPE_NORMAL
- en: Project graph of interest to apply the algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the algorithm with the appropriate configuration. There are three modes
    of this algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stream**: This applies the algorithm to the in-memory graph and streams the
    results. You can use the stream mode to inspect the results and see if they are
    what we want.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutate**: This applies the algorithm to the in-memory graph and writes the
    data back to the in-memory graph. The actual database does not change. The mutate
    method is used when we want to update the in-memory graph and want to process
    it later for different purposes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write**: This applies the algorithm to the in-memory graph and writes the
    relationships back to the actual database. This mode is used when we are sure
    of the process and want to write the results back to the graph immediately.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with graph projection. Since we have written the embeddings on
    the `SUMMER_2019` relationships, we will use those for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Cypher projects the graph in memory to be able to invoke this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Normally, we will use the properties on the node to build a projection. Here,
    we have written the embedding value on a relationship, as this embedding is created
    to represent the summer 2019 season purchases. If we had written that embedding
    on the `Customer` node, then if we wanted to understand the customer purchase
    behavior for various scenarios, we would need to use some clever naming to write
    those to only the `Customer` node. By writing that embedding on the relationship,
    we are preserving the context of the embedding in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the preceding Cypher that we are retrieving the embedding from
    the relationship and adding it as a source node property in the projection. Now,
    let us invoke the algorithm to write back similar relationships to the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Cypher invokes the algorithm to write back the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the Cypher, we can see we are invoking the `write` mode of the algorithm.
    The algorithm will calculate the similarity between Customers by using **cosine
    similarity** on the embeddings, with a cut-off score of `0.9`, pick the top 5
    neighbors in the order of similarity score, and write a relationship named `SUMMER_2019_SIMILAR`
    between those customers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Cosine similarity calculates the angle between two vectors. So, if the vectors
    are farther apart, then the similarity value will be close to 0\. If they are
    closer to each other, then the similarity value will be close to 1\. If you want
    to read more about it, you can read at [https://en.wikipedia.org/wiki/Cosine_similarity](https://en.wikipedia.org/wiki/Cosine_similarity).
  prefs: []
  type: TYPE_NORMAL
- en: Similar scores can be between 0 and 1\. If the score is closer to 0 between
    2 entities, then they are not similar to each other. If it is close to 1, then
    they are more similar. We are using `0.9` as the similarity cutoff as we are generating
    embeddings based on the summary text generated – customers might have a higher
    similarity score. We don’t want a similar relationship between customers because
    there are some keywords that are similar. We will validate this assumption in
    later steps. We are limiting ourselves to the top five (`k` `=5`) similar customer
    behaviors, to get closer recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the KNN algorithm is a non-deterministic algorithm by default.
    This means that different runs might give different results. You can learn more
    about this at [https://neo4j.com/docs/graph-data-science/2.14/algorithms/knn/](https://neo4j.com/docs/graph-data-science/2.14/algorithms/knn/).
    If you want deterministic results, then you must ensure that the concurrency parameter
    is set to one and the `randomSeed` parameter is explicitly set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the algorithm is invoked, we need to remove the graph projection. Otherwise,
    it will keep using the memory in the database server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This Cypher will drop the graph and clear the memory used by the graph projection.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at community detection next, based on the `SUMMER_2019_SIMILAR`
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will be leveraging the Louvain community detection algorithm, which
    is the most popular community detection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting communities with the Louvain algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Louvain algorithm** relies on the similarity scores between entities and
    groups them into communities. It takes large, networked data and groups it into
    smaller, tighter-knit communities by looking at the neighbors and their relationships.  This
    hierarchical clustering algorithm recursively merges communities into a single
    node and executes the modularity clustering on the condensed graphs. It maximizes
    a modularity score for each community, evaluating how much more densely connected
    the nodes within a community are compared to how connected they would be in a
    random network. We want to group our customers in more tight-knit groups in a
    more automated way to provide broader recommendations. You can read more about
    this at [https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/).
  prefs: []
  type: TYPE_NORMAL
- en: The approach is very similar to how we invoked the KNN algorithm. To use this
    algorithm, we need to follow this process.
  prefs: []
  type: TYPE_NORMAL
- en: Project graph of interest to apply the algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the algorithm with the appropriate configuration. There are three modes
    of this algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stream**: This applies the algorithm to the in-memory graph and streams the
    results. You can use the stream mode to inspect the results and see if they are
    what we want.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutate**: This applies the algorithm to the in-memory graph and writes the
    data back to the in-memory graph. The actual database has not changed. The `mutate`
    method is used when we want to update the in-memory graph and want to process
    it later for different purposes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write**: This applies the algorithm to the in-memory graph and writes the
    relationships back to the actual database. This mode is used when we are sure
    of the process and want to write the results back to the graph immediately.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with **graph projection**. We will use the `SUMMER_2019_SIMILAR`
    relationship and the `score` value saved on that relationship to perform community
    detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding Cypher creates an in-memory projection named `communityGraph`.
    It takes the source node, target node, and the score on the `SUMMER_2019_SIMILAR`
    relationship to build the projection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the projection is built, we can use this Cypher to perform community detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This Cypher performs the community detection and writes back the community ID
    as a property named `summer_2019_community` on the `Customer` node.
  prefs: []
  type: TYPE_NORMAL
- en: Once the community detection is complete, we need to drop the graph projection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This Cypher will drop the graph and clear the memory used by the graph projection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this Cypher to inspect how many communities are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This Cypher gives all communities, in the order of how many customers belong
    to that community. The response would look as shown in *Figure 10.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 — Communities with customer counts](img/B31107_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 — Communities with customer counts
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the Louvain community detection algorithm is a non-deterministic
    algorithm by default. This means that different runs might give different results.
    You can learn more about this at [https://neo4j.com/docs/graph-data-science/2.14/algorithms/louvain/](https://neo4j.com/docs/graph-data-science/2.14/algorithms/louvain/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built communities, let us take a look at the communities generated.
    In the next section, we will inspect a few of these communities to observe whether
    they group customers based on their purchase behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the power of communities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor059), we looked at
    finding similar customers using vector similarity and how to provide recommendations
    for a customer. Let’s revisit *Figure 9.10* and *Figure 9.11*. *Figure 9.10* displays
    the purchase history of customers similar to a particular customer. *Figure 9.11*
    shows the recommendations for a customer based on the purchases of similar customers.
    The purchase history and customer recommendations are a result of the Cypher queries
    we worked on in the *Fine-tuning your recommendations* section to understand vector
    similarity usage.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a deeper look at communities and see why they
    might be better than leveraging simple vector similarity to find similar customers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The following Cyphers are related to the database shared in the *Technical
  prefs: []
  type: TYPE_NORMAL
- en: requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: From the Cypher we ran in the last section, *Detecting communities with the
    Louvain  algorithm*, let us pick a community that has a good number of customers
    in it. We will take a look at the community with ID `133`, which has around `1,242`
    customers in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Cypher displays the customer purchase summary without the article
    details for the first five customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we run community detection, the community IDs generated can be different
    for each run. So, if you have run your own Cypher script to create the customer
    communities, you need to take a look at the communities and use those IDs to validate
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the preceding Cypher script, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the summary descriptions, we can see the customers in this community prefer
    to buy casual and lingerie clothing together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the articles purchased by these customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This Cypher gives this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are limiting ourselves to the first three articles so that we won’t look
    at a lot of data here. We can see from the articles purchased that the summaries
    summarize the customer’s purchase behavior well.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at how the customer age group to communities’ correlation exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Cypher gives us the most frequently occurring age group in a
    community age group in a community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The results will look as shown in *Figure 10.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Community | Age Group | Ratio |'
  prefs: []
  type: TYPE_TB
- en: '| 1899 | “Youth” | 60.87 |'
  prefs: []
  type: TYPE_TB
- en: '| 5823 | “Adult” | 56.68 |'
  prefs: []
  type: TYPE_TB
- en: '| 770 | “Youth” | 47.9 |'
  prefs: []
  type: TYPE_TB
- en: '| 1729 | “Youth” | 46.92 |'
  prefs: []
  type: TYPE_TB
- en: '| 4602 | “Youth” | 45.71 |'
  prefs: []
  type: TYPE_TB
- en: '| 133 | “Youth” | 44.61 |'
  prefs: []
  type: TYPE_TB
- en: '| 921 | “Youth” | 44.17 |'
  prefs: []
  type: TYPE_TB
- en: '| 3444 | “Youth” | 41.73 |'
  prefs: []
  type: TYPE_TB
- en: '| 649 | “Youth” | 41.62 |'
  prefs: []
  type: TYPE_TB
- en: '| 1881 | “Youth” | 41.26 |'
  prefs: []
  type: TYPE_TB
- en: '| 1696 | “Old” | 41.06 |'
  prefs: []
  type: TYPE_TB
- en: '| 2381 | “Old” | 40.94 |'
  prefs: []
  type: TYPE_TB
- en: '| 6010 | “Old” | 37.67 |'
  prefs: []
  type: TYPE_TB
- en: '| 713 | “Youth” | 37.64 |'
  prefs: []
  type: TYPE_TB
- en: '| 760 | “Youth” | 36.09 |'
  prefs: []
  type: TYPE_TB
- en: '| 1875 | “Old” | 35.09 |'
  prefs: []
  type: TYPE_TB
- en: '| 2778 | “Youth” | 34.47 |'
  prefs: []
  type: TYPE_TB
- en: Figure 10.3 — Most frequently occurring age group and its ratio in every community
  prefs: []
  type: TYPE_NORMAL
- en: We can see most communities are dominated by the **Age Group****,** **Youth**,
    who are aged between 20 and 30\. Let us look at one of the communities where the
    **Youth** age group is not dominant. Let us look at community **5823**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Cypher gives us the first five customers’ purchase summary of community
    `5823`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you perform a similarity search for a specific customer using their vector
    embedding, the results will primarily be other individual customers whose vector
    representations are close to the target customer’s vector. You may observe a degree
    of heterogeneity. An important caveat is that when we solely rely on finding similar
    customers to a target customer, based on vector distance, we might miss out on
    potentially relevant recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These summaries show this community leans toward people who have kids. After
    observing the communities and a few customer summaries in those communities, we
    are able to understand the purchase behaviors better than just going by vector
    similarity.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to combine collaborative filtering and content-based approaches
    to give better recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Combining collaborative filtering and content-based approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Collaborative filtering** involves providing recommendations based on customer
    similarity based on their purchases, using which we have built customer communities,
    or using article similarity based on their characteristics. **Content-based filtering**
    allows providing recommendations based on article attributes or characteristics.
    We will take a look at how we can combine both of these approaches to provide
    better recommendations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**: Filtering articles that belong to other communities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scenario 2**: Filtering articles by characteristics and belonging to other
    communities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss Scenario 1 first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 1: Filtering articles that belong to other communities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scenario, we will first find all the articles purchased by all the customers
    in the same community. Next, we will find the articles purchased by customers
    who belong to other communities.  The articles that belong to other communities
    will then be removed. This is followed by filtering out (removing) these articles
    (belonging to other communities).
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario, we will pick the customer identified by `000ae8a03447710b4de81d85698dfc0559258c93136650efc2429fcca80d699a`
    from community `1696`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the purchase summary for this customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This Cypher gives us this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us get recommendations for this customer – the articles that they have
    not purchased earlier, using the following Cypher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the articles purchased by this customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the articles purchased by customers in the same community as the original
    customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the articles purchased by customers that are not in the same community
    as the original customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the articles purchased by customers outside the community the original
    customer belongs to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the articles purchased by the original customer from the `onlyInCommunityArticles`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide 10 recommended articles from the remaining list. We are limiting this
    to 10 articles for simplicity and demonstration purposes. We can look at all the
    articles and maybe group them by other aspects and provide different recommendations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we get the articles purchased by the customer first. Then, we retrieve
    all the articles of the community the customer belongs to. After that, we get
    all the articles customers belonging to other communities purchased. We get the
    subset of the articles purchased only by customers in the community. From this
    set, we remove the articles the customer purchased and provide the articles as
    recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this query would look as shown in *Figure 10.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Id | Desc |'
  prefs: []
  type: TYPE_TB
- en: '| 0708679001 | Slim-fit, ankle-length jeans in washed, superstretch denim with
    a high waist, zip fly, fake front pockets and real back pockets. |'
  prefs: []
  type: TYPE_TB
- en: '| 0834749001 | Oversized jumper in a soft rib knit containing some wool with
    a polo neck, low dropped shoulders, long, voluminous sleeves, and wide ribbing
    at the cuffs and hem. The polyester content of the jumper is recycled. |'
  prefs: []
  type: TYPE_TB
- en: '| 0513701002 | V-neck T-shirts in organic cotton jersey. |'
  prefs: []
  type: TYPE_TB
- en: '| 0522374003 | Jumper in a soft, fine knit with dropped shoulders, long sleeves
    and gently rounded hem. |'
  prefs: []
  type: TYPE_TB
- en: '| 0522374001 | Jumper in a soft, fine knit with dropped shoulders, long sleeves
    and gently rounded hem. |'
  prefs: []
  type: TYPE_TB
- en: '| 0687041002 | Long-sleeved, fitted top in soft, organic cotton jersey with
    a deep neckline, buttons at the top and a rounded hem. |'
  prefs: []
  type: TYPE_TB
- en: '| 0724567004 | Pyjamas with a strappy top and shorts in soft satin with lace
    details. Top with a V-neck and narrow adjustable shoulder straps. Shorts with
    narrow elastication at the waist. |'
  prefs: []
  type: TYPE_TB
- en: '| 0785086001 | Short satin nightslip with a V-neck, lace trims at the top and
    hem, and adjustable spaghetti shoulder straps. |'
  prefs: []
  type: TYPE_TB
- en: '| 0725353002 | Bell-shaped, knee-length skirt in woven fabric with a high waist
    and a concealed zip and hook-and-eye fastening in one side. Lined. |'
  prefs: []
  type: TYPE_TB
- en: '| 0604655007 | Pyjamas in printed cotton jersey. Short-sleeved top with a round
    neck. Bottoms with an elasticated waist and wide, gently tapered legs with ribbed
    hems. |'
  prefs: []
  type: TYPE_TB
- en: Figure 10.4  — Recommendations by filtering out the articles purchased by a
    customer and by customers outside the community
  prefs: []
  type: TYPE_NORMAL
- en: These recommendations do seem to fit into the customer purchase summary.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us look at scenario 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 2: Filtering articles by characteristics and belonging to other communities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scenario, we want to add article characteristics to the query. This
    means, for a customer, we will first find all the articles purchased by the community
    with certain characteristics. Then we will find the communities these articles
    belong to and remove the articles that belong to other communities.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we will choose community `5823` and the customer with ID `00281c683a8eb0942e22d88275ad756309895813e0648d4b97c7bc8178502b33`.
    Let us look at this customer’s purchases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Cypher gives us this information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Based on the preceding Cypher we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since this customer is buying clothing from the `"Kids Boy"` section, let us
    retrieve recommendations that belong to this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Cypher gives us recommendations by adding this section’s details to the
    earlier query. Let us get the Customer with ID: `00281c683a8eb0942e22d88275ad756309895813e0648d4b97c7bc8178502b33`
    and the section named `Kids Boy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the articles purchased by this customer that belong to the section of importance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the articles that belong to the section of importance purchased by customers
    in the same community as the original customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the articles that belong to the section of importance purchased by customers
    in the communities outside the one the original customer belongs to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the articles purchased by customers outside the community from the articles
    purchased by customers in the community of the original customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the articles purchased by the original customer from the list of articles
    we got in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide 10 of these articles as recommendations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run this query, we will see the output shown in *Figure 10.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Id | Desc |'
  prefs: []
  type: TYPE_TB
- en: '| 0505507003 | 5-pocket slim-fit jeans in washed stretch denim with an adjustable
    elasticated waist and zip fly. |'
  prefs: []
  type: TYPE_TB
- en: '| 0704150011 | Long-sleeved top in sweatshirt fabric with a motif on the front
    and ribbing around the neckline, cuffs and hem. |'
  prefs: []
  type: TYPE_TB
- en: '| 0701969005 | Shorts in soft, patterned cotton twill with an elasticated drawstring
    waist, fake fly and side pockets. |'
  prefs: []
  type: TYPE_TB
- en: '| 0595548001 | Shorts in soft, washed denim with an elasticated drawstring
    waist and a back pocket. |'
  prefs: []
  type: TYPE_TB
- en: '| 0704150006 | Long-sleeved top in sweatshirt fabric with a motif on the front
    and ribbing around the neckline, cuffs and hem. |'
  prefs: []
  type: TYPE_TB
- en: '| 0626380001 | Top in soft, patterned cotton jersey with long sleeves, an open
    chest pocket and slits at the hem. Slightly longer at the back. |'
  prefs: []
  type: TYPE_TB
- en: '| 0701972005 | Shorts in woven fabric with an adjustable elasticated waist
    and decorative drawstring. Zip fly and button, diagonal side pockets and welt
    back pockets. |'
  prefs: []
  type: TYPE_TB
- en: '| 0771489001 | T-shirts in airy cotton jersey with a chest pocket and short
    slits in the sides. Longer at the back. |'
  prefs: []
  type: TYPE_TB
- en: '| 0705911001 | Vest top in cotton jersey with a print motif and a ribbed trim
    around the neckline and armholes. |'
  prefs: []
  type: TYPE_TB
- en: '| 0666327011 | T-shirt in soft cotton jersey with a motif on the front. |'
  prefs: []
  type: TYPE_TB
- en: Figure 10.5 — Recommendations that consider purchases and article attributes
    by filtering out the articles purchased by the customer and by customers outside
    the community
  prefs: []
  type: TYPE_NORMAL
- en: The demonstrations in this chapter showed how, by using these approaches, we
    can provide different types of recommendations based on similar purchases by other
    customers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to go beyond a basic recommendation application
    and leverage graph algorithms to enhance the graph and provide more appropriate
    recommendations. We explored how we can use the KNN similarity algorithm and community
    detection to gain hidden insights into the data.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will take a look at how we can deploy these applications
    in the cloud and what best practices we can follow for deployment.
  prefs: []
  type: TYPE_NORMAL
