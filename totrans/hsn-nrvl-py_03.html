<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Python Libraries and Environment Setup</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">This chapter introduces the Python libraries that we can use in order to implement the neuroevolution algorithms we described in the previous chapter. We will also discuss the strengths and weaknesses of each library that's presented. In addition to this, we will provide basic usage examples. Then, we will consider how to set up the environment for the experiments that we will perform later in this book and examine common ways to do this in the Python ecosystem. Finally, we will demonstrate how to set up a working environment using Anaconda Distribution, which is a popular tool for managing Python dependencies and virtual environments among data scientists. In this chapter, you will learn how to start using Python to experiment with the neuroevolution algorithms that will be covered in this book.</span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul class="ul1">
<li class="li1"><span>Suitable </span>Python libraries for neuroevolution experiments</li>
<li class="li1">Environment setup</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Suitable Python libraries for neuroevolution experiments</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The Python programming language is one of the most popular languages for activities related to machine learning and research and development in the field of artificial intelligence. The most prominent frameworks are either written in Python or provide corresponding interfaces. Such popularity can be explained by Python's short learning curve and its nature as a scriptable language, which allows experiments to take place quickly. Thus, following a general trend in the machine learning community, several libraries were written in Python with the support for neuroevolution, and the number of libraries continues to grow over time. In this section, w</span><span class="s1">e will look at the most stable Python libraries for experiments in the field of evolutionary algorithms.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NEAT-Python</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As its name suggests, this is the NEAT algorithm's implementation through the Python programming language. The <span>NEAT-Python</span> library provides the implementation of the standard NEAT methods for the genetic evolution of the genomes of organisms in a population. It implements utilities to convert the genotype of the organism into its phenotype (an artificial neural network) and provides convenient methods to load and save the genome configurations, along with the NEAT parameters. Additionally, it implements useful routines so that it can collect statistics about evolutionary process execution and a way to save/load intermediate checkpoints. Checkpoints allow us to save the state of the evolutionary process periodically and restore the process's execution from the saved checkpoint data later.</span></p>
<p class="p2"><span class="s1">The pros of the NEAT-Python algorithm are as follows:</span></p>
<ul class="ul1">
<li class="li2"><span class="s1">It has a stable implementation.</span></li>
<li class="li2"><span class="s1">It is comprehensively documented.</span></li>
<li class="li2"><span class="s1">It is available through the PIP package manager for easy installation.</span></li>
<li class="li2"><span class="s1">It has a built-in statistics collection and support for storing execution checkpoints, as well as restoring execution from a given checkpoint.</span></li>
<li class="li2"><span class="s1">It provides multiple types of activation functions.</span></li>
<li class="li2"><span class="s1">It supports the continuous-time recurrent neural network phenotypes.</span></li>
<li class="li2"><span class="s1">It can be easily extended to support various NEAT modifications.</span></li>
</ul>
<p class="p2"><span class="s1">The cons of the NEAT-Python algorithm are as follows:</span></p>
<ul class="ul1">
<li class="li2"><span class="s1">Only the NEAT algorithm is implemented by default.</span></li>
<li class="li2"><span class="s1">It is in a maintenance-only state right now and no active development has been done recently.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NEAT-Python usage example</h1>
                </header>
            
            <article>
                
<p>The following is a general example of how to use the NEAT-Python library, without any particular problem in mind. It describes the typical steps to be taken and how to obtain the necessary results. We will use this library extensively throughout this book. You can skip to the next chapter for the concrete usage example, but you should follow through to the end of this chapter to learn more about alternative libraries. Let's get started:</p>
<ol>
<li><span class="s2">Load the NEAT settings and the initial genome configuration:<br/></span></li>
</ol>
<pre style="padding-left: 60px"><span class="s2">config = neat.Config(neat.DefaultGenome, neat.DefaultReproduction, neat.DefaultSpeciesSet, neat.DefaultStagnation, config_file)<br/></span></pre>
<p style="padding-left: 60px">Here, the <kbd>config_file</kbd> parameter <span>points to the file that contains the NEAT-Python library settings and the default configuration of the initial genome.</span></p>
<ol start="2">
<li>Create a population of organisms from the configuration data:</li>
</ol>
<pre style="padding-left: 60px">p = neat.Population(config)</pre>
<ol start="3">
<li>Add the statistics reporter and checkpoints collector:</li>
</ol>
<pre style="padding-left: 60px"># Output progress to the stdout<br/>p.add_reporter(neat.StdOutReporter(True)) <br/>stats = neat.StatisticsReporter()<br/>p.add_reporter(stats)<br/>p.add_reporter(neat.Checkpointer(5))</pre>
<ol start="4">
<li>Run the evolution process over a specific number of generations (<kbd>300</kbd>, in our case):</li>
</ol>
<pre style="padding-left: 60px">winner = p.run(eval_genomes, 300)</pre>
<p style="padding-left: 60px">Here, <kbd>eval_genomes</kbd> <span class="s2">is a function that's used to evaluate the genomes of all the organisms in the population against a particular fitness function and </span><kbd>winner</kbd> is the best performing genotype found.</p>
<ol start="5">
<li>The phenotype ANN can be created from a genome as follows:</li>
</ol>
<pre style="padding-left: 60px">winner_ann = neat.nn.FeedForwardNetwork.create(winner, config)</pre>
<ol start="6">
<li>After that, the ANN can be queried with input data to calculate the results:</li>
</ol>
<pre style="padding-left: 60px">for xi in xor_inputs: <br/>    output = winner_ann.activate(xi)<br/>    print(xi, output) # print results</pre>
<div class="p1 packt_infobox"><span class="s1">The library is available at <a href="https://github.com/CodeReclaimers/neat-python"><span class="s2">https://github.com/CodeReclaimers/neat-python</span></a>.</span></div>
<p>The preceding source code is to give you a feeling of the library. The full code examples will be provided in the chapters that follow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PyTorch NEAT</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">This library is built around the NEAT-Python library. It provides easy integration for artifacts that have been produced by the NEAT-Python library with the <em>PyTorch</em> platform. As a result, it becomes possible to convert the NEAT genome into a phenotype ANN, which is based on the PyTorch implementation of recurrent neural networks. Also, it allows us to represent <strong>Compositional Pattern Producing Networks</strong> (<strong>CPPNs</strong>) as PyTorch structures, which are the primary building blocks of the HyperNEAT method. The main advantage of integration with PyTorch is that it allows us to utilize GPUs for computing, potentially accelerating the evolutionary process due to the increased rate of evaluation of the genomes of organisms in the evolving population.</span></p>
<p class="p1"><span class="s1">The pros of PyTorch NEAT are as follows:</span></p>
<ul class="ul1">
<li class="li1"><span class="s1">It is built around a stable NEAT-Python library, which makes it possible for us to use all of its benefits.</span></li>
<li class="li1"><span class="s1">Integration with the PyTorch framework.</span></li>
<li class="li1"><span class="s1">It is GPU accelerated for the evaluation of NEAT genomes.</span></li>
<li class="li1"><span class="s1">It includes CPPN implementation, which is a building block of the HyperNEAT algorithm.</span></li>
<li class="li1"><span class="s1">Integration with the OpenAI GYM environment.</span></li>
</ul>
<p class="p1"><span>The cons of </span><span>PyTorch NEAT are as follows:</span></p>
<ul class="ul1">
<li class="li1"><span class="s1">Only the NEAT algorithm is fully implemented.</span></li>
<li class="li1"><span class="s1">It provides only partial support for the HyperNEAT algorithm's implementation.</span></li>
</ul>
<div class="packt_infobox">For more details about OpenAI GYM, go to <a href="https://gym.openai.com">https://gym.openai.com</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PyTorch NEAT usage example</h1>
                </header>
            
            <article>
                
<p>The following is an example of using the PyTorch NEAT library to implement a cartpole balancing controller. This is only being presented as an overview. Later in this book, we will dive deeper into the pole balancing problem in more detail. Let's get started:</p>
<ol>
<li>Load the NEAT settings and seed genome configuration:</li>
</ol>
<pre style="padding-left: 60px">config = neat.Config(neat.DefaultGenome, neat.DefaultReproduction, <br/>      neat.DefaultSpeciesSet, neat.DefaultStagnation, config_file)</pre>
<p style="padding-left: 60px"><span class="s2">Here, the <kbd>config_file</kbd> file stores the NEAT algorithm settings, along with the default genome configuration.</span></p>
<ol start="2">
<li>Create a population of organisms from the configuration data:</li>
</ol>
<pre class="p1" style="padding-left: 60px"><span class="s1">pop </span><span class="s2">=</span><span class="s1"> neat.Population(config)</span></pre>
<ol start="3">
<li>Prepare the multi-environment genome evaluator based on PyTorch and OpenAI GYM:</li>
</ol>
<pre style="padding-left: 60px">def make_env(): <br/>    return gym.make("CartPole-v0")<br/><br/>def make_net(genome, config, bs): <br/>    return RecurrentNet.create(genome, config, bs)<br/><br/>def activate_net(net, states): <br/>    outputs = net.activate(states).numpy()<br/>    return outputs[:, 0] &gt; 0.5<br/><br/>evaluator = MultiEnvEvaluator( <br/>    make_net, activate_net, make_env=make_env, <br/>    max_env_steps=max_env_steps<br/>)<br/><br/>def eval_genomes(genomes, config): <br/>    for _, genome in genomes:<br/>        genome.fitness = evaluator.eval_genome(genome, config)</pre>
<p class="p1" style="padding-left: 60px"><span class="s1">Here, the call</span> to the <kbd><span class="s2">gym.</span><span class="s2">make("</span><span class="s1">CartPole-v0"</span><span class="s2">)</span></kbd><span class="s2"> function is the call to the OpenAI GYM framework to create a single-pole balancing environment.</span></p>
<ol start="4">
<li>Add the statistics and log reporter:</li>
</ol>
<pre style="padding-left: 60px">stats = neat.StatisticsReporter()<br/>pop.add_reporter(stats)<br/>reporter = neat.StdOutReporter(True)<br/>pop.add_reporter(reporter)<br/>logger = LogReporter("neat.log", evaluator.eval_genome)<br/>pop.add_reporter(logger)</pre>
<ol start="5">
<li>Run the evolution process over a specific number of generations (<kbd>100</kbd>, in our case):</li>
</ol>
<pre class="p1" style="padding-left: 60px"><span class="s1">winner = pop.run(eval_genomes, 100)</span></pre>
<p class="p1" style="padding-left: 60px"><span class="s1">Here, </span><kbd>eval_genomes</kbd> <span class="s1">is a function for evaluating the genomes of all the organisms in a population against a certain fitness function, and the</span> <kbd>winner</kbd> is the best performing genotype found.</p>
<ol start="6">
<li>The phenotype ANN can be created from a genome, as shown in the following code:</li>
</ol>
<pre class="p2" style="padding-left: 60px"><span class="s2">winner_ann = RecurrentNet.create(genome, config, bs)</span></pre>
<p class="p4" style="padding-left: 60px"><span class="s2">Here, the </span><kbd>genome</kbd> is the NEAT genome configuration, <kbd>config </kbd>is an object that encapsulates the NEAT settings, and <kbd>bs</kbd> is a parameter that indicates the desired batch size.</p>
<ol start="7">
<li>After that, the ANN can be queried with the input data to obtain the results:</li>
</ol>
<pre class="p1" style="padding-left: 60px"><span class="s2">action = winner_ann.activate(states).numpy()</span></pre>
<p class="p1" style="padding-left: 30px"><span class="s2">Here,</span> <kbd>action</kbd> is the action specifier to be used in the simulation and <kbd>states</kbd> is the tensor that includes the current state of the environment that was obtained from the simulator.</p>
<div class="p1 packt_infobox"><span class="s1">The library's source code is available at <a href="https://github.com/uber-research/PyTorch-NEAT"><span class="s2">https://github.com/uber-research/PyTorch-NEAT</span></a>.</span></div>
<p><span>The preceding source code is to give you a feeling of the library. The full code examples will be provided in the chapters that follow.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MultiNEAT</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">MultiNEAT is the most universal library among the libraries we will discuss in this book since it supports the standard NEAT algorithm and two crucial extensions: HyperNEAT and ES-HyperNEAT. Also, the MultiNEAT library provides an implementation of a Novelty Search optimization method. The library is written in the C++ programming language but provides a comprehensive Python interface. The MultiNEAT Python wheel is also available through the Anaconda package manager, which makes it easy to install and use in any OS.</span></p>
<p class="p1"><span class="s1">The pros of the MultiNEAT library are as follows:</span></p>
<ul class="ul1">
<li class="li1"><span class="s1">Stable implementation</span></li>
<li class="li1"><span class="s1">Implements a multitude of algorithms from the NEAT family, such as the following:</span>
<ul>
<li class="li1"><span class="s1">NEAT</span></li>
<li class="li1"><span class="s1">HyperNEAT</span></li>
<li class="li1"><span class="s1">ES-HyperNEAT</span></li>
</ul>
</li>
<li>Provides an implementation of the Novelty Search optimization method</li>
<li class="li1"><span class="s1">Supports plastic neural networks through Hebbian learning </span></li>
<li class="li1"><span class="s1">Provides visualization of genotypes and phenotypes through OpenCV in Python</span></li>
<li class="li1"><span class="s1">Integration with the OpenAI GYM environment</span></li>
<li class="li1"><span class="s1">Comprehensive documentation</span></li>
</ul>
<p class="p1">The cons of the MultiNEAT library are as follows:</p>
<ul class="ul1">
<li class="li1"><span class="s1">No GPU support</span></li>
<li class="li1"><span class="s1">Does not support checkpoints</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MultiNEAT usage example</h1>
                </header>
            
            <article>
                
<p>The following is an example of using the MultiNEAT library to implement the XOR solver using neuroevolution. This is just an overview, without the implementation of the <span>XOR</span> fitness score evaluator (<kbd>evaluate_xor</kbd>), which will be discussed in the next chapter. Let's get started:</p>
<ol>
<li>Create the NEAT configuration settings:</li>
</ol>
<pre style="padding-left: 60px">params = NEAT.Parameters()<br/>params.PopulationSize = 100<br/># The rest of the settings omitted for brevity</pre>
<ol start="2">
<li>Create a minimal genome configuration and spawn a population of organisms from this genome:</li>
</ol>
<pre style="padding-left: 60px">g = NEAT.Genome(0, 3, 0, 1, False, <br/>      NEAT.ActivationFunction.UNSIGNED_SIGMOID,<br/>      NEAT.ActivationFunction.UNSIGNED_SIGMOID, 0, params, 0)<br/>pop = NEAT.Population(g, params, True, 1.0, i)</pre>
<ol start="3">
<li>Run the evolution process over <kbd>1000</kbd> generations or until the winner is found:</li>
</ol>
<pre class="p1" style="padding-left: 60px"><span class="s1">for generation in range(1000):<br/>    </span><span class="s1"># Evaluate genomes<br/>    </span><span class="s1">genome_list = NEAT.GetGenomeList(pop)<br/>    </span><span class="s1">fitnesses = EvaluateGenomeList_Serial(genome_list, <br/>                            evaluate_xor, display=False)<br/>    </span><span class="s1">[genome.SetFitness(fitness) for genome, fitness in zip(genome_list, fitnesses)]<br/>    <br/>    </span><span class="s1"># Evaluate fitness value against specific threshold<br/>    </span><span class="s1">best = max(fitness_list)<br/>    </span><span class="s1">if best &gt; 15.0:<br/>        </span><span class="s1"># get the phenotype of a best organism<br/>        </span><span class="s1">net = NEAT.NeuralNetwork()<br/>        </span><span class="s1">pop.Species[0].GetLeader().BuildPhenotype(net)<br/>        # return the fitness and phenotype ANN of the winner</span><span class="s1"><br/>        </span><span class="s1">return (best, net)<br/><br/>    </span><span class="s1"># Next epoch<br/>    </span><span class="s1">pop.Epoch()</span></pre>
<ol start="4">
<li>The following is the query winner phenotype ANN, along with some inputs to get results:</li>
</ol>
<pre class="mce-root" style="padding-left: 90px">net.Input( [ 1.0, 0.0, 1.0 ] )<br/>net.Activate()<br/>output = net.Output()</pre>
<div class="p1 packt_infobox"><span class="s1">You can find this library at <a href="https://github.com/peter-ch/MultiNEAT"><span class="s2">https://github.com/peter-ch/MultiNEAT</span></a>.</span></div>
<p><span>The preceding source code is to give you a feeling of the library. The full code examples will be provided in the chapters that follow.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deep Neuroevolution</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1"><strong>Deep Neural Networks</strong> (<strong>DNNs</strong>) demonstrate outstanding performance improvements in tasks related to pattern recognition and reinforcement learning by utilizing the parallel processing capabilities of modern GPUs. In the context of neuroevolution, it is particularly interesting to explore how conventional <strong>deep reinforcement learning</strong> (<strong>deep RL</strong>) methods can be compared to the ones based on Deep Neuroevolution. To answer this question, the research team from UberAI labs created and released the corresponding library in the Python programming language, which uses the TensorFlow framework to handle computations related to neural network training on GPU devices.</span></p>
<p class="p1"><span class="s1">The library provides an implementation of the simple <strong>genetic algorithm</strong> (<strong>GA</strong>) and the Novelty Search optimization method. It also provides an implementation of the Evolution Strategies method, which is another kind of evolutionary algorithm. </span></p>
<p>You can find more details about the Evolution Strategies method at Hans-Georg Beyer, <em>The Theory of Evolution Strategies.</em> Springer April 27, 2001.</p>
<p class="mce-root"/>
<p class="p1"><span class="s1">The pros of Deep Neuroevolution are as follows:</span></p>
<ul class="ul1">
<li class="li1"><span class="s1">Stable implementation</span></li>
<li class="li1"><span class="s1">GPU-enabled through integration with TensorFlow</span></li>
<li class="li1"><span class="s1">The ability to work directly with high-dimensional problems, such as learning to act directly from pixels</span></li>
<li class="li1"><span class="s1">Provides an implementation of the Novelty Search optimization method</span></li>
<li class="li1"><span class="s1">Gradient-free method to optimize DNNs</span></li>
<li class="li1"><span class="s1">Provides visualization of the learning process through the <strong>Visual Inspector for Neuroevolution</strong> (<strong>VINE</strong>)</span></li>
<li class="li1"><span class="s1">Provides integration with the OpenAI GYM environment</span></li>
<li class="li1"><span class="s1">Provides integration with the Atari games environment</span></li>
</ul>
<p class="p1"><span>The disadvantage of </span><span>Deep Neuroevolution is that it d</span><span class="s1">oes not provide an implementation of the NEAT family of neuroevolution algorithms, that is, NEAT, HyperNEAT, and ES-HyperNEAT.</span></p>
<p class="p1"><span class="s1">The genetic algorithm that's implemented in the Deep Neuroevolution library controls the evolution of a population of organisms that have genomes encoding a vector of<span> learning parameters (connection weights) for </span>a deep neural network. At every generation, each genotype is evaluated and produces a fitness score. After that, the specific number of organisms are selected uniformly at random from the top best-fit individuals to become parents of the next generation. The genotype of each selected parent organism is then mutated by adding Gaussian noise. Also, the algorithm uses the notion of elitism, in which the specific number of best-fit organisms from the previous generation are added to the next without any modifications being made. The crossover operator is not applied during the evolutionary process to simplify the algorithm. </span><span class="s1">The topology of the DNN that's used in this algorithm is fixed and set by experimenters manually.</span></p>
<p>Let's refer to the following simple genetic algorithm:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-750 image-border" src="assets/c7ca6ede-758b-438f-8ad4-475abc2cbcb6.png" style="width:44.50em;height:41.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The simple genetic algorithm</div>
<div class="p1 packt_infobox"><span class="s1">More details about the implementation of Deep Neuroevolution is available at <a href="https://github.com/uber-research/deep-neuroevolution">https://github.com/uber-research/deep-neuroevolution</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing Python neuroevolution libraries</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The following table provides a quick comparison between the Python libraries we've discussed in this chapter:</span></p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td/>
<td>
<p><strong>NEAT-Python</strong></p>
</td>
<td>
<p><strong>PyTorch NEAT</strong></p>
</td>
<td>
<p><strong>MultiNEAT</strong></p>
</td>
<td>
<p><strong>Deep Neuroevolution</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>NEAT</strong></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
</tr>
<tr>
<td>
<p><strong>HyperNEAT</strong></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Partial (CPPN only)</p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
</tr>
<tr>
<td>
<p><strong>ES-HyperNEAT</strong></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
</tr>
<tr>
<td>
<p><strong>Novelty Search</strong></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
</tr>
<tr>
<td>
<p><strong>OpenAI GYM</strong></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
</tr>
<tr>
<td>
<p><strong>Visualization</strong></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
</tr>
<tr>
<td>
<p><strong>GPU support</strong></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
</tr>
<tr>
<td>
<p><strong>PIP</strong></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
</tr>
<tr>
<td>
<p><strong><span>Anaconda</span></strong></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
</tr>
<tr>
<td>
<p><strong><span>Checkpoints</span></strong></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
<td>
<p><span>No</span></p>
</td>
<td>
<p><span>Yes</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The NEAT-Python library provides excellent visualization integration and is easy to use. However, it has a significant drawback in that it is implemented solely in Python and, as a result, has a very slow execution speed. It is only suitable for simple problems.</p>
<p class="mce-root">The MultiNEAT Python library has core implemented in C++, which gives it slightly better performance compared to the NEAT-Python library. It can be used for solving more complex tasks requiring the creation of larger phenotype ANNs. Also, it provides the implementation of the HyperNEAT and ES-HyperNEAT methods, which makes it the right choice for tasks related to training large-scale ANNs.</p>
<p class="mce-root">The Deep Neuroevolution library is the most advanced neuroevolution implementation and allows us to employ the powers of GPUs to handle training tasks with millions of trainable parameters. This can be found in the visual imagery processing domain.</p>
<p><span>Later in this book, we will get to know each Python library better and put them into practice.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environment setup</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">When working with Python libraries, it is essential to set up a working environment properly. There are a lot of dependencies, including the Python language version and the binaries that are available in the system; all of these must be aligned and have compatible versions. As a result of this process, the conflicting configurations of libraries and language versions can be easily created, adding to the frustration and hours of debugging and bug fixes. To solve this problem, the concept of the virtual environment was introduced in the Python programming language. A virtual environment allows us to create isolated Python environments that contain all the necessary dependencies and executables that are used in a particular Python project. Such a virtual environment can be easily created and deleted after it is no longer needed, without leaving any remains in the system.</span></p>
<p class="p1"><span class="s1">Among the most popular tools for working with Python virtual environments, we can highlight the following:</span></p>
<ul class="ol1">
<li class="li1"><span class="s1">Pipenv</span></li>
<li class="li1"><span class="s1">Virtualenv</span></li>
<li class="li1"><span class="s1">Anaconda</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pipenv</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Pipenv is a tool that combines package manager with the virtual environments manager. The main goal is to make it easy for developers to set up a unique working environment for a particular project with all the necessary dependencies included.</span></p>
<p class="p1"><span class="s1">It can be installed with PIP (the package installer for Python) using the following command:</span></p>
<pre class="p1"><strong><span class="s1">$</span><span class="s2"> pip install --user pipenv</span></strong></pre>
<p class="p1"><span class="s1">The preceding command installs the <kbd>pipenv</kbd> tool into the user space to prevent it from breaking any system-wide packages.</span></p>
<p class="p1"><span class="s1">To install all the dependencies and create a new virtual environment (if not present) for your project, change into the project's directory and run the installation process, as follows:</span></p>
<pre><strong>$ cd my_project_folder</strong><br/><strong>$ pipenv install &lt;package&gt;</strong></pre>
<p class="p1"><span class="s1">This command creates a new virtual environment in <kbd>my_project_folder</kbd> and installs <kbd>&lt;package&gt;</kbd> into it. That's it.</span></p>
<p class="p1"><span class="s1">It is possible to provide a configuration file (Pipfile) that specifies which packages should be installed, as well as other information that's specific to the build process. When you run</span> <kbd>install</kbd> for the first time, the Pipfile will be created automatically if it doesn't exist yet.</p>
<div class="p1 packt_infobox"><span class="s1">More details about the tool can be found at  <a href="https://pipenv.kennethreitz.org/en/latest/">https://pipenv.kennethreitz.org/en/latest/</a><a href="https://docs.pipenv.org/en/latest/">.</a></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Virtualenv</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Virtualenv is a tool that's used to create isolated Python environments, starting from Python v3.3, and is partially integrated into the standard library under the <kbd>venv</kbd> module. The major problem that's addressed by this tool is maintaining the unique set of dependencies, versions, and permissions for each Python project independently.</span> <span class="s1">Virtualenv handles this by creating</span> <span>a separate environment</span><span> </span><span>with its own installation directories</span><span> </span><span>for each project. This </span>prevents us from sharing any dependencies and libraries with other projects<span>.</span> <span>Also, it is possible to block access to globally installed libraries.</span></p>
<p class="p1"><span class="s1">Virtualenv is a pure virtual environments manager and it doesn't provide any package manager routines. Therefore, it is usually used along with the package manager to manage dependencies of your project, such as PIP. Let's take a look at Virtualenv:</span></p>
<ol>
<li class="p1"><span class="s1">Install Virtualenv with PIP as follows:</span></li>
</ol>
<pre class="p1" style="padding-left: 60px"><strong><span class="s1">$</span><span class="s2"> pip install virtualenv</span></strong></pre>
<ol start="2">
<li>Test that the installation was successful:</li>
</ol>
<pre class="p3" style="padding-left: 60px"><strong><span class="s2">$</span><span class="s1"> virtualenv --version</span></strong></pre>
<ol start="3">
<li>Create a virtual environment for your project with the following commands:</li>
</ol>
<pre class="p3" style="padding-left: 60px"><strong>$ cd my_project_folder</strong><br/><strong>$ virtualenv venv</strong></pre>
<p class="p2" style="padding-left: 60px"><span class="s1">This command creates a new virtual environment in</span> <kbd>my_project_folder</kbd><span class="s1">. The fresh environment includes a folder with Python executable files inside it, as well as a copy of</span> the PIP <span class="s1">library, which is a package manager that allows us to install other dependencies.</span></p>
<ol start="4">
<li>Before you start using it, you need to activate the virtual environment with the following command, which can be typed into the Terminal application of your choice:</li>
</ol>
<pre class="p1" style="padding-left: 60px"><strong><span class="s1">$ source /path/to/ENV/bin/activate</span></strong></pre>
<p class="p3" style="padding-left: 60px"><span class="s1">After the preceding command, all the necessary environment variables will be set to the correct values that are specific to your project, and the current session of the Terminal application will use it for any subsequent commands that are entered.</span></p>
<ol start="5">
<li>Additional packages can be easily installed into an active environment with PIP:</li>
</ol>
<pre class="p1" style="padding-left: 60px"><strong><span class="s2">$</span><span class="s1"> pip install sqlite</span></strong></pre>
<p class="p3"><span class="s1">The preceding command installs the SQLite package in the currently active environment.</span></p>
<p class="p3"><span class="s1">If no package name is provided after the</span> <kbd>pip install</kbd> <span class="s1">command, the pip manager will look for a <kbd>requirements.txt</kbd> file in the current directory for the specification of the packages to be installed.</span></p>
<div class="p3 packt_infobox"><span class="s1">You can find more details at <a href="https://virtualenv.pypa.io/en/latest/"><span class="s3">https://virtualenv.pypa.io/en/latest/</span></a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Anaconda</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Anaconda Distribution is a package and a virtual environment manager that is popular among data scientists and machine learning professionals because it provides easy access to an extensive collection of tailored scientific libraries (over 1,500+) and useful tools. Apart from this, it allows you to write source code and execute scripts in Python and R from one place. With Anaconda, it is possible to easily create, save, load, and switch between virtual environments, as well as install thousands of packages from the repository that have been reviewed and maintained by the Anaconda team into each virtual environment.</span></p>
<div class="p1 packt_infobox"><span class="s1">To install Anaconda, you need to download the installer that's appropriate to your operating system from <a href="https://www.anaconda.com/distribution/"><span class="s2">https://www.anaconda.com/distribution/</span></a>.</span></div>
<p class="p1"><span class="s1">After that, the new environment for your project can be created with the following command:</span></p>
<pre class="p3"><strong>$ cd my_project_folder</strong><br/><strong>$ conda create --name ENV_NAME &lt;package&gt;</strong></pre>
<p class="p1"><span class="s1">The preceding command creates a new virtual environment for your project and installs into it the specified package or multiple packages. Additional packages can be easily installed into a fresh environment later, after it's been activated.</span></p>
<p class="p1"><span class="s1">All the environments that are available in the system can be listed with the following command:</span></p>
<pre class="p4"><strong><span class="s1">$ conda env list</span></strong></pre>
<p class="p1"><span class="s1">Any existing environment can be activated as follows:</span></p>
<pre class="p4"><strong><span class="s1">$ conda activate ENV_NAME</span></strong></pre>
<p class="p1"><span class="s1">To deactivate the current active environment, use the following command:</span></p>
<pre class="p4"><strong><span class="s1">$ conda deactivate</span></strong></pre>
<p class="p1"><span class="s1">Additional libraries can be installed into the current environment either through standard PIP or by using the</span> <kbd>conda install</kbd> <span class="s1">command:</span></p>
<pre class="p4"><strong><span class="s1">$ conda install sqlite</span></strong></pre>
<p class="p1"><span class="s1">After the preceding command, SQLite will be installed into the currently active environment.</span></p>
<p class="p1"><span class="s1">In this book, we will use Anaconda to manage the dependencies and environments for most of our projects.</span></p>
<div class="packt_infobox"><span>If you are interested in finding out more, please make yourself familiar with all available Anaconda commands at </span><a href="https://docs.conda.io/projects/conda/en/latest/commands.html">https://docs.conda.io/projects/conda/en/latest/commands.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In this chapter, we learned about four popular Python libraries that we can use for experiments in the field of neuroevolution. We discussed the strengths and weaknesses of each library that was presented, and reviewed the basic examples of using these libraries in Python. After that, we looked at how to set up the environment for Python-based experiments to avoid the side effects of having multiple versions of the same library in the Python path. We found that the best way to do this is to create isolated virtual environments for each Python project, and considered several popular solutions created by the open source community to help with this task. Finally, we introduced Anaconda Distribution, which includes, among other useful things, the package manager and an environment manager. For the rest of this book, we will use Anaconda to handle setting up the environment in our experiments properly.</span></p>
<p class="mce-root">In the next chapter, we will discuss how the NEAT algorithm can be used to solve the classic computer science problem. You will write the XOR problem solver using the NEAT-Python library we discussed in this chapter. We will also discuss the hyperparameters that are used to configure the NEAT algorithm and how they can be adjusted to increase the performance of the neuroevolution process.</p>


            </article>

            
        </section>
    </body></html>