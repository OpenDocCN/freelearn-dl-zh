["```py\nusing UnityEngine;\n\npublic class Boid : MonoBehaviour \n{\n    [SerializeField]\n    private FlockController flockController;\n\n    //The modified direction for the boid.\n    private Vector3 targetDirection;\n    //The Boid's current direction.\n    private Vector3 direction;\n\n    public FlockController FlockController \n    {\n        get { return flockController; }\n        set { flockController = value; }\n    }\n\n    public Vector3 Direction { get { return direction; }}\n\n    private void Awake() \n    {\n        direction = transform.forward.normalized;\n        if(flockController != null) \n        {\n            Debug.LogError(\"You must assign a flock controller!\");\n        }\n    }\n\n    private void Update() {\n        targetDirection = FlockController.Flock(this, transform.localPosition, direction);\n        if(targetDirection == Vector3.zero)\n        {\n            return;\n        }\n        direction = targetDirection.normalized;\n        direction *= flockController.SpeedModifier;\n        transform.Translate(direction * Time.deltaTime);\n    } \n}\n```", "```py\nprivate int flockSize = 20;\n```", "```py\nprivate float speedModifier = 5;\n\n[SerializeField]\nprivate float alignmentWeight = 1;\n\n[SerializeField]\nprivate float cohesionWeight = 1;\n\n[SerializeField]\nprivate float separationWeight = 1;\n\n[SerializeField]\nprivate float followWeight = 5;\n```", "```py\n[SerializeField]\nprivate Boid prefab;\n[SerializeField]\nprivate float spawnRadius = 3.0f;\nprivate Vector3 spawnLocation = Vector3.zero;\n\n[SerializeField]\npublic Transform target;\n```", "```py\nprivate void Awake()\n{\n    flockList = new List<Boid>(flockSize); \n    for (int i = 0; i < flockSize; i++)\n    {\n        spawnLocation = Random.insideUnitSphere * spawnRadius + transform.position;\n        Boid boid = Instantiate(prefab, spawnLocation, transform.rotation) as Boid;\n\n        boid.transform.parent = transform;\n        boid.FlockController = this;\n        flockList.Add(boid);\n    }\n}\n```", "```py\npublic Vector3 Flock(Boid boid, Vector3 boidPosition, Vector3 boidDirection)\n{\n    flockDirection = Vector3.zero;\n    flockCenter = Vector3.zero;\n    targetDirection = Vector3.zero;\n    separation = Vector3.zero;\n\n    for (int i = 0; i < flockList.Count; ++i) \n    {\n        Boid neighbor = flockList[i];\n        //Check only against neighbors.\n        if (neighbor != boid) \n        {\n            //Aggregate the direction of all the boids.\n            flockDirection += neighbor.Direction;\n            //Aggregate the position of all the boids.\n            flockCenter += neighbor.transform.localPosition;\n            //Aggregate the delta to all the boids.\n            separation += neighbor.transform.localPosition - boidPosition;\n            separation *= -1;\n        }\n    }\n    //Alignment. The average direction of all boids.\n    flockDirection /= flockSize;\n    flockDirection = flockDirection.normalized * alignmentWeight;\n\n    //Cohesion. The centroid of the flock.\n    flockCenter /= flockSize;\n    flockCenter = flockCenter.normalized * cohesionWeight;\n\n    //Separation.\n    separation /= flockSize;\n    separation = separation.normalized * separationWeight;\n\n    //Direction vector to the target of the flock.\n    targetDirection = target.localPosition - boidPosition;\n    targetDirection = targetDirection * followWeight;\n\n    return flockDirection + flockCenter + separation + targetDirection;\n}\n```", "```py\nusing UnityEngine;\n\npublic class TargetMovement : MonoBehaviour \n{\n    [SerializeField]\n    private Vector3 bounds;\n    [SerializeField]\n    private float moveSpeed = 10.0f;\n    [SerializeField]\n    private float turnSpeed = 3.0f;\n    [SerializeField]\n    private float targetPointTolerance = 5.0f;\n\n    private Vector3 initialPosition;\n    private Vector3 nextMovementPoint;\n    private Vector3 targetPosition;\n\n    private void Awake() \n    {\n        initialPosition = transform.position;\n        CalculateNextMovementPoint();\n    }\n\n    private void Update () \n    {\n        transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);\n        transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(nextMovementPoint - transform.position), turnSpeed * Time.deltaTime);\n\n        if(Vector3.Distance(nextMovementPoint, transform.position) <= targetPointTolerance) \n        {\n            CalculateNextMovementPoint();\n        }\n    }\n\n    private void CalculateNextMovementPoint()\n    {\n        float posX = Random.Range(initialPosition.x - bounds.x, initialPosition.x + bounds.x);\n        float posY = Random.Range(initialPosition.y - bounds.y, initialPosition.y + bounds.y);\n        float posZ = Random.Range(initialPosition.z - bounds.z, initialPosition.z + bounds.z);\n        targetPosition.x = posX;\n        targetPosition.y = posY;\n        targetPosition.z = posZ;\n        nextMovementPoint = initialPosition + targetPosition; \n    }\n}\n```", "```py\nusing UnityEngine; \nusing System.Collections; \n\n[RequireComponent(typeof(NavMeshAgent))] \npublic class CrowdAgent : MonoBehaviour \n{         \n    public Transform target; \n\n    private NavMeshAgent agent; \n\n    void Start () \n    { \n        agent = GetComponent<NavMeshAgent>(); \n        agent.speed = Random.Range(4.0f, 5.0f); \n        agent.SetDestination(target.position); \n    } \n}\n```"]