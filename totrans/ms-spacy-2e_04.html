<html><head></head><body>
  <div id="_idContainer060">
   <h1 class="chapter-number" id="_idParaDest-57">
    <a id="_idTextAnchor056">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor057">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Mastering Rule-Based Matching
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Rule-based information extraction is indispensable for any
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.4.1">
      natural language processing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      NLP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     ) pipeline.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     Certain types of entities, such as times, dates, and telephone
    </span>
    <a id="_idIndexMarker163">
    </a>
    <span class="koboSpan" id="kobo.8.1">
     numbers, have distinct formats that can be recognized by a set of rules without having to train
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      statistical models.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.10.1">
     In this chapter, you will learn how to quickly extract information from text by matching patterns and phrases.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     You will use
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.11.1">
      morphological
     </span>
    </strong>
    <strong class="bold">
     <a id="_idIndexMarker164">
     </a>
    </strong>
    <strong class="bold">
     <span class="koboSpan" id="kobo.12.1">
      features
     </span>
    </strong>
    <span class="koboSpan" id="kobo.13.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.14.1">
      parts-of-speech
     </span>
    </strong>
    <span class="koboSpan" id="kobo.15.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.16.1">
      POS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.17.1">
     ) tags,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.18.1">
      regular expressions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.19.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.20.1">
      regexes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.21.1">
     ), and
    </span>
    <a id="_idIndexMarker165">
    </a>
    <span class="koboSpan" id="kobo.22.1">
     other spaCy features to form pattern objects to feed to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.23.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     You will continue with fine-graining statistical models with rule-based matching to lift statistical models to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      better accuracies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     By the end of this chapter, you will know about a vital part of information extraction.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     You will also be able to extract entities of specific formats, as well as entities specific to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      your domain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.30.1">
       Token-based matching
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.31.1">
      Creating patterns
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.32.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.33.1">
        PhraseMatcher
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.34.1">
      Creating patterns
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.35.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.36.1">
        SpanRuler
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.37.1">
      Combining spaCy models
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.38.1">
       and matchers
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-59">
    <a id="_idTextAnchor058">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     The code of this chapter can be found at
    </span>
    <a href="https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition">
     <span class="koboSpan" id="kobo.41.1">
      https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition
     </span>
    </a>
    <span class="koboSpan" id="kobo.42.1">
     .
    </span>
    <span class="koboSpan" id="kobo.42.2">
     We are using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.43.1">
      Python 3.10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.44.1">
     and
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.45.1">
       spaCy 3.7.4
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-60">
    <a id="_idTextAnchor059">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     Token-based matching
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     Some NLU tasks can be solved
    </span>
    <a id="_idIndexMarker166">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     without the help of any statistical model.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     One of those ways is a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.50.1">
      regex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.51.1">
     , which
    </span>
    <a id="_idIndexMarker167">
    </a>
    <span class="koboSpan" id="kobo.52.1">
     we use to match a predefined set of patterns to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      our text.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     A regex is a sequence of characters that specifies a search pattern.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     A regex describes a set of strings that follows the specified pattern.
    </span>
    <span class="koboSpan" id="kobo.54.3">
     These patterns can include letters, digits, and characters with special meanings, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.57.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.58.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.59.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.60.1">
     .
    </span>
    <span class="koboSpan" id="kobo.60.2">
     Python’s built-in library,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.61.1">
      re
     </span>
    </strong>
    <span class="koboSpan" id="kobo.62.1">
     , provides great support to define and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      match regexes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.64.1">
     What does a regex look like, then?
    </span>
    <span class="koboSpan" id="kobo.64.2">
     The following regex matches the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      following strings:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.66.1">
"Barack Obama"
"Barack Obama"
"Barack Hussein Obama"
reg = r"Barack\s(Hussein\s)?Obama"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     This pattern can be read as follows: the string
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      Barack
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     can be followed optionally by the string
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      Hussein
     </span>
    </strong>
    <span class="koboSpan" id="kobo.71.1">
     (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.72.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.73.1">
     character in a regex means optional; that is,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.74.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     occurrence) and should be followed by the string
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.78.1">
      Obama
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     .
    </span>
    <span class="koboSpan" id="kobo.79.2">
     The inter-word spaces can be a single-space character, a tab, or any other whitespace character (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      \s
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     matches all sorts of whitespace characters, including the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      newline character).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     It’s not very readable, even for such a short and uncomplicated pattern, is it?
    </span>
    <span class="koboSpan" id="kobo.83.2">
     Some downsides of regexes are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.84.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.85.1">
      Difficult
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.86.1">
       to read
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.87.1">
      Difficult
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.88.1">
       to debug
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.89.1">
      Error-prone with space, punctuation, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.90.1">
       number characters
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     For these reasons, many software engineers don’t like to work with regexes in their production code.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     spaCy provides a very clean, readable, production-level, and maintainable alternative: the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.92.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.93.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.93.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.94.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.95.1">
     class can match our predefined rules to the sequence of tokens in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.96.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.97.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.98.1">
      Span
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     As we will see in this chapter, the rules can also refer to the token or its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      linguistic attributes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     Let’s start with a basic example of how to call the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.102.1">
       Matcher
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      class:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.104.1">
      First, we import the library, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.105.1">
       Matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.106.1">
      object, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.107.1">
       Span
      </span>
     </strong>
     <span class="koboSpan" id="kobo.108.1">
      token, and load
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.109.1">
       the model:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.110.1">
import spacy
from spacy.matcher import Matcher
from spacy.tokens import Span
nlp = spacy.load("en_core_web_sm")</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.111.1">
      Now, we instantiate the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.112.1">
       Matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.113.1">
      object passing the vocabulary of the model, define a pattern, and add it to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.114.1">
       Matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.115.1">
      object with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.116.1">
       label
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.117.1">
        morningGreeting
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.118.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.119.1">
matcher = Matcher(nlp.vocab)
pattern = [{"LOWER": "good"}, {"LOWER": "morning"}, 
           {"IS_PUNCT": True}]
matcher.add("morningGreeting", [pattern])</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.120.1">
      Finally, we can
     </span>
     <a id="_idIndexMarker168">
     </a>
     <span class="koboSpan" id="kobo.121.1">
      process the text.
     </span>
     <span class="koboSpan" id="kobo.121.2">
      To visualize the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.122.1">
       Span
      </span>
     </strong>
     <span class="koboSpan" id="kobo.123.1">
      objects with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.124.1">
       displaCy
      </span>
     </strong>
     <span class="koboSpan" id="kobo.125.1">
      , we will add the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.126.1">
       Span
      </span>
     </strong>
     <span class="koboSpan" id="kobo.127.1">
      objects to a list and attribute
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.128.1">
       doc.spans["sc"]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.129.1">
      to this list.
     </span>
     <span class="koboSpan" id="kobo.129.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.130.1">
       sc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.131.1">
      instance is the default
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.132.1">
       span_key
      </span>
     </strong>
     <span class="koboSpan" id="kobo.133.1">
      value (group of arbitrary
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.134.1">
       Span
      </span>
     </strong>
     <span class="koboSpan" id="kobo.135.1">
      objects).
     </span>
     <span class="koboSpan" id="kobo.135.2">
      Here is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.136.1">
       the code:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.137.1">
doc = nlp("Good morning, I want to reserve a ticket.")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    spans.append(Span(doc, start, end, 
                      nlp.vocab.strings[match_id]))
doc.spans["sc"] = spans</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.138.1">
      Now, let’s show the spans
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.139.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.140.1">
        displacy
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.141.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.142.1">
from spacy import displacy
displacy.render(doc, style="span")</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.143.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.144.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.145.1">
     shows the result of the previous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.146.1">
      code block:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer041">
     <span class="koboSpan" id="kobo.147.1">
      <img alt="Figure 4.1 – Span matches of our first Matcher pattern" src="image/B22441_04_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.148.1">
     Figure 4.1 – Span matches of our first Matcher pattern
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.149.1">
     You can read the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     pattern of the preceding
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.152.1">
      step 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.153.1">
     list
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.155.1">
      A token whose lowered text
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.156.1">
       is
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.157.1">
        good
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.158.1">
      A token whose lowered text
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.159.1">
       is
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.160.1">
        morning
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.161.1">
      A token that is punctuation (that is, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.162.1">
       IS_PUNCT
      </span>
     </strong>
     <span class="koboSpan" id="kobo.163.1">
      feature
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.164.1">
       is
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.165.1">
        True
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.166.1">
       )
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     A match result is a list of triplets in the form
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      (match id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.170.1">
      start position
     </span>
    </strong>
    <span class="koboSpan" id="kobo.171.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      end position)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     .
    </span>
    <span class="koboSpan" id="kobo.173.2">
     As you might have noticed, the whitespace between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      Good
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.176.1">
      morning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     didn’t matter at all.
    </span>
    <span class="koboSpan" id="kobo.177.2">
     Indeed, we could have put two whitespaces in between, written down
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.178.1">
      Good morning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     , and the result would be identical.
    </span>
    <span class="koboSpan" id="kobo.179.2">
     Why?
    </span>
    <span class="koboSpan" id="kobo.179.3">
     Because
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     matches only tokens and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      token attributes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     A pattern always
    </span>
    <a id="_idIndexMarker169">
    </a>
    <span class="koboSpan" id="kobo.184.1">
     refers to a continuous sequence of token objects, and every item in bracelets corresponds to one token object.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     Let’s go back to the pattern in the preceding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      code snippet:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.186.1">pattern = [{"LOWER": "good"}, {"LOWER": "morning"},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.187.1">           {"IS_PUNCT": True}]</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     The result is always a three-token match.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     Can we add more than one pattern?
    </span>
    <span class="koboSpan" id="kobo.188.3">
     The answer is yes.
    </span>
    <span class="koboSpan" id="kobo.188.4">
     Let’s see it with an example,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      as follows:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.190.1">
      Import the libraries and set the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.191.1">
       Matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.192.1">
      object just
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.193.1">
       as before:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.194.1">
import spacy
from spacy.matcher import Matcher
from spacy.tokens import Span
nlp = spacy.load("en_core_web_sm")
matcher = Matcher(nlp.vocab)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.195.1">
      Define the two patterns and add them to the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.196.1">
        Matcher
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.197.1">
       object:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.198.1">
pattern1 = [{"LOWER": "good"}, {"LOWER": "morning"}, 
</span><strong class="bold"><span class="koboSpan" id="kobo.199.1">            </span></strong><span class="koboSpan" id="kobo.200.1">{"IS_PUNCT": True}]
matcher.add("morningGreeting", [pattern1])
pattern2 = [{"LOWER": "good"}, {"LOWER": "evening"}, 
</span><strong class="bold"><span class="koboSpan" id="kobo.201.1">            </span></strong><span class="koboSpan" id="kobo.202.1">{"IS_PUNCT": True}]
matcher.add("eveningGreeting", [pattern2])</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.203.1">
      Process the text, send the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.204.1">
       doc
      </span>
     </strong>
     <span class="koboSpan" id="kobo.205.1">
      object to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.206.1">
       Matcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.207.1">
      object and store the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.208.1">
       Span
      </span>
     </strong>
     <span class="koboSpan" id="kobo.209.1">
      objects in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.210.1">
       a list:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.211.1">
doc = nlp("Good morning, I want to reserve a ticket. </span><span class="koboSpan" id="kobo.211.2">I will then say good evening!")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.212.1">
      Now, we can
     </span>
     <a id="_idIndexMarker170">
     </a>
     <span class="koboSpan" id="kobo.213.1">
      display the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.214.1">
       Span
      </span>
     </strong>
     <span class="koboSpan" id="kobo.215.1">
      objects
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.216.1">
       with displacy:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.217.1">
from spacy import displacy
displacy.render(doc, style="span")</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.218.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.219.1">
      .2
     </span>
    </em>
    <span class="koboSpan" id="kobo.220.1">
     shows the result using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      new pattern:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer042">
     <span class="koboSpan" id="kobo.222.1">
      <img alt="Figure 4.2 – Span matches using two patterns" src="image/B22441_04_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.223.1">
     Figure 4.2 – Span matches using two patterns
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     In the preceding code example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      pattern1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      pattern2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     differ only by one token:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.229.1">
      evening
     </span>
    </strong>
    <span class="koboSpan" id="kobo.230.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      morning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     .
    </span>
    <span class="koboSpan" id="kobo.232.2">
     Instead
    </span>
    <a id="_idIndexMarker171">
    </a>
    <span class="koboSpan" id="kobo.233.1">
     of writing two patterns, can we say evening or morning using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.234.1">
      IN
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.235.2">
     Let’s learn more about it in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.236.1">
      next section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-61">
    <a id="_idTextAnchor060">
    </a>
    <span class="koboSpan" id="kobo.237.1">
     Extended syntax support
    </span>
   </h2>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.238.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.239.1">
     allows patterns
    </span>
    <a id="_idIndexMarker172">
    </a>
    <span class="koboSpan" id="kobo.240.1">
     to be more expressive by allowing some operators inside the curly braces.
    </span>
    <span class="koboSpan" id="kobo.240.2">
     These operators are for extended comparison and look similar to Python’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.241.1">
      in
     </span>
    </strong>
    <span class="koboSpan" id="kobo.242.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.243.1">
      not in
     </span>
    </strong>
    <span class="koboSpan" id="kobo.244.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.245.1">
      comparison
     </span>
    </strong>
    <span class="koboSpan" id="kobo.246.1">
     operators.
    </span>
    <span class="koboSpan" id="kobo.246.2">
     You can see a full list of attributes in spaCy’s documentation, available at
    </span>
    <a href="https://spacy.io/api/matcher/#patterns">
     <span class="koboSpan" id="kobo.247.1">
      https://spacy.io/api/matcher/#patterns
     </span>
    </a>
    <span class="koboSpan" id="kobo.248.1">
     .
    </span>
    <span class="koboSpan" id="kobo.248.2">
     Previously we matched
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.249.1">
      good evening
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.251.1">
      good morning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.252.1">
     with two different patterns.
    </span>
    <span class="koboSpan" id="kobo.252.2">
     Now, we can match
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.253.1">
      good morning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.254.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.255.1">
      evening
     </span>
    </strong>
    <span class="koboSpan" id="kobo.256.1">
     with one pattern with the help of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.257.1">
      IN
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.259.1">
pattern = [{"LOWER": "good"},
           {"LOWER": {"IN": ["morning", "evening"]}},
           {"IS_PUNCT": True}]
matcher.add("greetings",  [pattern])
doc = nlp("Good morning, I'm here. </span><span class="koboSpan" id="kobo.259.2">I'll say good evening!!")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans</span></pre>
   <p>
    <span class="koboSpan" id="kobo.260.1">
     Comparison operators usually go together with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.261.1">
      LENGTH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.262.2">
     Here’s an example of finding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.263.1">
      long tokens:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.264.1">
pattern = [{"LENGTH": {"&gt;=" : 10}}]
matcher.add("longWords",  [pattern])
doc = nlp("I suffered from Trichotillomania when I was in college. </span><span class="koboSpan" id="kobo.264.2">The doctor prescribed me Psychosomatic medicine.")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.265.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.266.1">
      .3
     </span>
    </em>
    <span class="koboSpan" id="kobo.267.1">
     shows the matches using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      this pattern:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer043">
     <span class="koboSpan" id="kobo.269.1">
      <img alt="Figure 4.3 – Matches using LENGTH pattern" src="image/B22441_04_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.270.1">
     Figure 4.3 – Matches using LENGTH pattern
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.271.1">
     In the next section, we
    </span>
    <a id="_idIndexMarker173">
    </a>
    <span class="koboSpan" id="kobo.272.1">
     will explore some of the most used token attributes used to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      create patterns.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-62">
    <a id="_idTextAnchor061">
    </a>
    <span class="koboSpan" id="kobo.274.1">
     Token attributes
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.275.1">
     Let’s go over some
    </span>
    <a id="_idIndexMarker174">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     useful token pattern keys with examples.
    </span>
    <span class="koboSpan" id="kobo.276.2">
     We used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      LOWER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     in the preceding examples; it means the lowercase form of the token text.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      ORTH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.281.1">
      TEXT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.282.1">
     are similar to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.283.1">
      LOWER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     : they mean an exact match of the token text, including the case.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     Here’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.285.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.286.1">pattern = [{"TEXT": "Bill"}]</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.287.1">
     The preceding code will match
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      Bill
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     but
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      not
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.291.1">
       bill
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.293.1">
     The next block of token attributes is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      IS_ALPHA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      IS_ASCII
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.298.1">
      IS_DIGIT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.299.1">
     .
    </span>
    <span class="koboSpan" id="kobo.299.2">
     These features are handy for finding number tokens and ordinary words.
    </span>
    <span class="koboSpan" id="kobo.299.3">
     The following pattern matches a sequence of two tokens, a number followed by an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      ordinary word:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.301.1">
pattern = [{"IS_DIGIT": True},{"IS_ALPHA": True}]
matcher.add("numberAndPlainWord",  [pattern])
doc1 = nlp("I met him at 2 o'clock.")
matches = matcher(doc1)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc1, start, end, pattern_name))
doc1.spans["sc"] = spans
displacy.render(doc1, style="span")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.302.1">
     In the preceding code segment,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.303.1">
      2 o'clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     didn’t match the pattern because
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.305.1">
      o'clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     contains an apostrophe, which is not an alphabetic character (alphabetic characters are digits, letters, and
    </span>
    <a id="_idIndexMarker175">
    </a>
    <span class="koboSpan" id="kobo.307.1">
     the underscore character).
    </span>
    <span class="koboSpan" id="kobo.307.2">
     Let’s test the pattern using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.308.1">
      another sentence:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.309.1">
doc2 = nlp("He brought me 2 apples.")
matches = matcher(doc2)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc2, start, end, pattern_name))
doc2.spans["sc"] = spans
displacy.render(doc2, style="span")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.310.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.311.1">
      .4
     </span>
    </em>
    <span class="koboSpan" id="kobo.312.1">
     shows that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.313.1">
      2 apples
     </span>
    </strong>
    <span class="koboSpan" id="kobo.314.1">
     matched because the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.315.1">
      apples
     </span>
    </strong>
    <span class="koboSpan" id="kobo.316.1">
     token consists
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      of letters:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer044">
     <span class="koboSpan" id="kobo.318.1">
      <img alt="Figure 4.4 – Match using number and plain word pattern" src="image/B22441_04_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.319.1">
     Figure 4.4 – Match using number and plain word pattern
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      IS_LOWER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.322.1">
      IS_UPPER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.323.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.324.1">
      IS_TITLE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     are useful attributes for recognizing the token’s casing.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.326.1">
      IS_UPPER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.327.1">
     is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.328.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     if the token is all uppercase letters, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      IS_TITLE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.332.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.333.1">
     if the token starts with a capital letter.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      IS_LOWER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      True
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     if the token is all lowercase letters.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     Imagine we want to find emphasized words in a text; one way is to look for tokens with all uppercase letters.
    </span>
    <span class="koboSpan" id="kobo.337.3">
     Uppercase tokens usually have significant weights in sentiment analysis models.
    </span>
    <span class="koboSpan" id="kobo.337.4">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.339.1">
pattern = [{"IS_UPPER": True}]
matcher.add("capitals",  [pattern])
doc = nlp("Take me out of your SPAM list. </span><span class="koboSpan" id="kobo.339.2">We never asked you to contact me. </span><span class="koboSpan" id="kobo.339.3">If you write again we'll SUE!!!!")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans
displacy.render(doc, style="span")</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      IS_PUNCT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.342.1">
      IS_SPACE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.343.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.344.1">
      IS_STOP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.345.1">
     are usually used in patterns that include some helper tokens and
    </span>
    <a id="_idIndexMarker176">
    </a>
    <span class="koboSpan" id="kobo.346.1">
     correspond to punctuation, space, and stopword tokens (stopwords are common words of a language that do not carry much information, such as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.347.1">
      a
     </span>
    </em>
    <span class="koboSpan" id="kobo.348.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.349.1">
      an
     </span>
    </em>
    <span class="koboSpan" id="kobo.350.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.351.1">
      the
     </span>
    </em>
    <span class="koboSpan" id="kobo.352.1">
     in English).
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.353.1">
      IS_SENT_START
     </span>
    </strong>
    <span class="koboSpan" id="kobo.354.1">
     is another useful attribute; it matches sentence start tokens.
    </span>
    <span class="koboSpan" id="kobo.354.2">
     Here’s a pattern for sentences that start with the word
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.355.1">
      can
     </span>
    </em>
    <span class="koboSpan" id="kobo.356.1">
     and the second word has a capitalized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      first letter:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.358.1">
      In this pattern, we will put two attributes into one brace.
     </span>
     <span class="koboSpan" id="kobo.358.2">
      The first item in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.359.1">
       pattern
      </span>
     </strong>
     <span class="koboSpan" id="kobo.360.1">
      means that a token that is the first token of the sentence and whose lowered text
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.361.1">
       is
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.362.1">
        can
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.363.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.364.1">
pattern = [{"IS_SENT_START": True, "LOWER": "can"}, {"IS_TITLE": True}]
matcher.add("canThenCapitalized", [pattern])</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.365.1">
      Now, we process the text and show
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.366.1">
       the matches:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.367.1">
doc2 = nlp("Can Sally swim?")
matches = matcher(doc2)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc2, start, end, pattern_name))
doc2.spans["sc"] = spans
displacy.render(doc2, style="span")</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.368.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.369.1">
      .5
     </span>
    </em>
    <span class="koboSpan" id="kobo.370.1">
     shows the matches of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.371.1">
      preceding list:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer045">
     <span class="koboSpan" id="kobo.372.1">
      <img alt="Figure 4.5 – Match using two tokens" src="image/B22441_04_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.373.1">
     Figure 4.5 – Match using two tokens
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     We can add as many attributes to the braces as we like.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     For instance,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.375.1">
      {"IS_SENT_START": False, "IS_TITLE": True, "LOWER": "bill"}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.376.1">
     is a completely v
    </span>
    <a id="_idIndexMarker177">
    </a>
    <span class="koboSpan" id="kobo.377.1">
     alid attribute dictionary, and it describes a token that is capitalized, not the first token of the sentence, and has the text
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      bill
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     .
    </span>
    <span class="koboSpan" id="kobo.379.2">
     So, it is the set of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      bill
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     instances that do not appear as the first word of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.382.1">
      a sentence.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.383.1">
      LIKE_NUM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.384.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.385.1">
      LIKE_URL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.387.1">
      LIKE_EMAIL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.388.1">
     are attributes that are related to token shape; – we discussed them in
    </span>
    <a href="B22441_03.xhtml#_idTextAnchor045">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.389.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.390.1">
     .
    </span>
    <span class="koboSpan" id="kobo.390.2">
     These attributes match tokens that look like numbers, URLs,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.391.1">
      and emails.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     Now, let’s see the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      POS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      TAG
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.397.1">
      DEP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.399.1">
      LEMMA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.401.1">
      SHAPE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.402.1">
     linguistic attributes.
    </span>
    <span class="koboSpan" id="kobo.402.2">
     You saw these token attributes in the previous chapter; now, we’ll use them in token matching.
    </span>
    <span class="koboSpan" id="kobo.402.3">
     The following code snippet spots sentences that start with an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      auxiliary verb:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.404.1">
pattern = [{"IS_SENT_START": True, "TAG": "MD"}]
matcher.add("sentStartAuxBVerb", [pattern])
doc = nlp("Will you go there?")
matches = matcher(doc)</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.405.1">
      MD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     is the tag for modal and auxiliary verbs.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     The preceding code snippet is a standard way of finding yes/no question sentences.
    </span>
    <span class="koboSpan" id="kobo.406.3">
     In such cases, we usually look for sentences that start with a modal or an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.407.1">
      auxiliary verb.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.408.1">
     When we want to extract the meaning of a word, we usually combine
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.409.1">
      TEXT/LEMMA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.410.1">
     with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.411.1">
      POS/TAG
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     .
    </span>
    <span class="koboSpan" id="kobo.412.2">
     For instance, the word match is to go together when it’s a verb, or it can be a fire starter tool when it’s a noun.
    </span>
    <span class="koboSpan" id="kobo.412.3">
     In this case, we make the distinction
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      as follows:
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.414.1">
      {"LEMMA": "match", "
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.415.1">
       POS": "VERB"}
      </span>
     </strong>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      {"LEMMA": "match", "
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.417.1">
       POS": "NOUN"}
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     Similarly, you can combine other linguistic features with token shape attributes to make sure that you extract only the pattern you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      mean to.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.420.1">
     We’ll see more examples
    </span>
    <a id="_idIndexMarker178">
    </a>
    <span class="koboSpan" id="kobo.421.1">
     of combining linguistic features with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.422.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     class in the upcoming sections.
    </span>
    <span class="koboSpan" id="kobo.423.2">
     Now, we’ll move on to another very practical feature of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     patterns:
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.426.1">
      regex-like operators.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor062">
    </a>
    <span class="koboSpan" id="kobo.427.1">
     Regex-like operators
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     At the beginning of the
    </span>
    <a id="_idIndexMarker179">
    </a>
    <span class="koboSpan" id="kobo.429.1">
     chapter, we pointed out
    </span>
    <a id="_idIndexMarker180">
    </a>
    <span class="koboSpan" id="kobo.430.1">
     that spaCy’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     class offers
    </span>
    <a id="_idIndexMarker181">
    </a>
    <span class="koboSpan" id="kobo.433.1">
     a cleaner and more readable equivalent to regex operations, indeed much cleaner and much more readable.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     The most common regex operations are optional match (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.434.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.435.1">
     ), match at least once (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.436.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.437.1">
     ), and match 0 or more times (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.438.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.439.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.439.2">
     You can see a full list of spaCy’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.440.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.441.1">
     operators here:
    </span>
    <a href="https://spacy.io/api/matcher/#patterns">
     <span class="koboSpan" id="kobo.442.1">
      https://spacy.io/api/matcher/#patterns
     </span>
    </a>
    <span class="koboSpan" id="kobo.443.1">
     .
    </span>
    <span class="koboSpan" id="kobo.443.2">
     The very first example regex of this chapter was matching Barack Obama’s first name, with the middle name being optional.
    </span>
    <span class="koboSpan" id="kobo.443.3">
     The regex was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.444.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.445.1">R"Barack\s(Hussein\s)?Obama</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.446.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.447.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.448.1">
     operator after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.449.1">
      Hussein
     </span>
    </strong>
    <span class="koboSpan" id="kobo.450.1">
     means the pattern in the brackets is optional, hence this regex matches both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.451.1">
      Barack Obama
     </span>
    </strong>
    <span class="koboSpan" id="kobo.452.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.453.1">
      Barack Hussein Obama
     </span>
    </strong>
    <span class="koboSpan" id="kobo.454.1">
     .
    </span>
    <span class="koboSpan" id="kobo.454.2">
     We use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.455.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     operator in a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.457.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.458.1">
     pattern
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.459.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.460.1">
pattern = [{"LOWER": "barack"},
           {"LOWER": "hussein", "OP": "?"},
           {"LOWER": "obama"}]
matcher.add("obamaNames",  [pattern])
doc1 = nlp("Barack Obama visited France.")
doc2 = nlp("Barack Hussein Obama visited France.")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.461.1">
     Here, by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.462.1">
      "OP": "?"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.463.1">
     in the second list item, we made this token optional.
    </span>
    <span class="koboSpan" id="kobo.463.2">
     The matcher picked
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.464.1">
      Barack Obama
     </span>
    </strong>
    <span class="koboSpan" id="kobo.465.1">
     in the first
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.466.1">
      doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.467.1">
     object and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.468.1">
      Barack Hussein Obama
     </span>
    </strong>
    <span class="koboSpan" id="kobo.469.1">
     in the second one, as you can see in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.470.1">
       Figure 4
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.471.1">
       .6
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.472.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer046">
     <span class="koboSpan" id="kobo.473.1">
      <img alt="Figure 4.6 – Matches using regex" src="image/B22441_04_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.474.1">
     Figure 4.6 – Matches using regex
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.475.1">
     We previously pointed out that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.476.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.477.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.478.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.479.1">
     operators have the same meaning as their regex counterparts.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.480.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.481.1">
     means the token should occur at least once, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.482.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.483.1">
     means the token can
    </span>
    <a id="_idIndexMarker182">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     occur 0 or
    </span>
    <a id="_idIndexMarker183">
    </a>
    <span class="koboSpan" id="kobo.485.1">
     more times.
    </span>
    <span class="koboSpan" id="kobo.485.2">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.486.1">
      some examples:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.487.1">
pattern = [{"LOWER": {"IN": ["hello", "hi", "hallo"]}, "OP":"+"}, 
           {"IS_PUNCT": True}]
matcher.add("greetings",  [pattern])
doc1 = nlp("Hello hello hello, how are you?")
doc2 = nlp("Hi, how are you?")
doc3 = nlp("How are you?")
for doc in [doc1, doc2, doc3]:
    spans = []
    matches = matcher(doc)
    for match_id, start, end in matches:
        pattern_name = nlp.vocab.strings[match_id]
        spans.append(Span(doc, start, end, pattern_name))
    doc.spans["sc"] = spans
    displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.488.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.489.1">
      .7
     </span>
    </em>
    <span class="koboSpan" id="kobo.490.1">
     shows what happens when we use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.491.1">
      +
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.492.1">
      operator:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer047">
     <span class="koboSpan" id="kobo.493.1">
      <img alt="Figure 4.7 – Matches using the + operator" src="image/B22441_04_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.494.1">
     Figure 4.7 – Matches using the + operator
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.495.1">
     In the pattern, the first token reads as any one of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      hello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.498.1">
      hi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.499.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.500.1">
      hallo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.501.1">
     should occur one or more times.
    </span>
    <span class="koboSpan" id="kobo.501.2">
     Notice the greedy nature of the pattern (each
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.502.1">
      hello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.503.1">
     instance gets a match).
    </span>
    <span class="koboSpan" id="kobo.503.2">
     The second doc also has a match, but the third one doesn’t (since it does not have any of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.504.1">
      hello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.505.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.506.1">
      hi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.507.1">
     , or
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.508.1">
       hallo
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.509.1">
      words).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     When we come to the results of the first doc objects matches, we see that there are not one but three distinct matches.
    </span>
    <span class="koboSpan" id="kobo.510.2">
     This is completely normal because there are indeed three sequences matching the pattern.
    </span>
    <span class="koboSpan" id="kobo.510.3">
     If you have a closer look at the match results, all of them match
    </span>
    <a id="_idIndexMarker184">
    </a>
    <span class="koboSpan" id="kobo.511.1">
     the
    </span>
    <a id="_idIndexMarker185">
    </a>
    <span class="koboSpan" id="kobo.512.1">
     pattern we created, because they all match the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.513.1">
      (
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.514.1">
       hello)+
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.515.1">
      pattern.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     Let’s do the same pattern with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.517.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.518.1">
     and see what happens
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.519.1">
      this time:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.520.1">
pattern = [{"LOWER": {"IN": ["hello", "hi", "hallo"]},
            "OP": "*"}, {"IS_PUNCT": True}]
matcher.add("greetings",  [pattern])
doc1 = nlp("Hello hello hello, how are you?")
doc2 = nlp("Hello, how are you?")
doc3 = nlp("How are you?")
for doc in [doc1, doc2, doc3]:
    spans = []
    matches = matcher(doc)
    for match_id, start, end in matches:
        pattern_name = nlp.vocab.strings[match_id]
        spans.append(Span(doc, start, end, pattern_name))
    doc.spans["sc"] = spans
    displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.521.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.522.1">
      .8
     </span>
    </em>
    <span class="koboSpan" id="kobo.523.1">
     shows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      the results:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer048">
     <span class="koboSpan" id="kobo.525.1">
      <img alt="Figure 4.8 – Matches using the * operator" src="image/B22441_04_08.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.526.1">
     Figure 4.8 – Matches using the * operator
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.527.1">
     Now, punctuation
    </span>
    <a id="_idIndexMarker186">
    </a>
    <span class="koboSpan" id="kobo.528.1">
     marks alone without a greeting word
    </span>
    <a id="_idIndexMarker187">
    </a>
    <span class="koboSpan" id="kobo.529.1">
     are picked.
    </span>
    <span class="koboSpan" id="kobo.529.2">
     This is not what you want in your NLP
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.530.1">
      applications, probably.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.531.1">
     The preceding example is a good example that we should be careful of while creating our patterns; sometimes, we get unwanted matches.
    </span>
    <span class="koboSpan" id="kobo.531.2">
     For this reason, we usually consider using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      IS_SENT_START
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     and take care of the rest with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      *
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.535.1">
      operator.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.536.1">
     The spaCy
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.537.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.538.1">
     class also accepts a very special pattern, a wildcard token pattern.
    </span>
    <span class="koboSpan" id="kobo.538.2">
     A wildcard token will match any token.
    </span>
    <span class="koboSpan" id="kobo.538.3">
     We usually use it for words we want to pick independent from their text or attributes or for words we ignore.
    </span>
    <span class="koboSpan" id="kobo.538.4">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.539.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.540.1">
matcher = Matcher(nlp.vocab)
pattern = [{"LOWER": "name"},{"LEMMA": "be"},{}]
matcher.add("pickName", [pattern])
doc = nlp("My name is Alice and his name was Elliot.")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans
displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.541.1">
     Here, we wanted
    </span>
    <a id="_idIndexMarker188">
    </a>
    <span class="koboSpan" id="kobo.542.1">
     to
    </span>
    <a id="_idIndexMarker189">
    </a>
    <span class="koboSpan" id="kobo.543.1">
     capture the first names in the sentence.
    </span>
    <span class="koboSpan" id="kobo.543.2">
     We achieved it by parsing out token sequences in the form
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      name is/was/be firstname
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     .
    </span>
    <span class="koboSpan" id="kobo.545.2">
     The first token pattern,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      LOWER: "name"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     , matches the tokens whose lowered text is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     .
    </span>
    <span class="koboSpan" id="kobo.549.2">
     The second token pattern,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.550.1">
      LEMMA: "be"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.551.1">
     , matches the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.552.1">
      is
     </span>
    </strong>
    <span class="koboSpan" id="kobo.553.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.554.1">
      was
     </span>
    </strong>
    <span class="koboSpan" id="kobo.555.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.556.1">
      be
     </span>
    </strong>
    <span class="koboSpan" id="kobo.557.1">
     tokens.
    </span>
    <span class="koboSpan" id="kobo.557.2">
     The third token is the wildcard token,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      {}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     , which means any token.
    </span>
    <span class="koboSpan" id="kobo.559.2">
     We pick up any token that comes after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.560.1">
      name is/was/be
     </span>
    </strong>
    <span class="koboSpan" id="kobo.561.1">
     with this pattern.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.562.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.563.1">
      .9
     </span>
    </em>
    <span class="koboSpan" id="kobo.564.1">
     shows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.565.1">
      the results:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer049">
     <span class="koboSpan" id="kobo.566.1">
      <img alt="Figure 4.9 – Matches using wildcard token" src="image/B22441_04_09.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.567.1">
     Figure 4.9 – Matches using wildcard token
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.568.1">
     We also use a wildcard token when we want to ignore a token.
    </span>
    <span class="koboSpan" id="kobo.568.2">
     Let’s make an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.569.1">
      example together:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.570.1">
pattern = [{"LEMMA": "forward"}, {}, {"LOWER": "email"}]
matcher.add("forwardMail",  [pattern])
doc1 = nlp("I forwarded his email to you.")
doc2 = nlp("I forwarded an email to you.")
doc3 = nlp("I forwarded the email to you.")
for doc in [doc1, doc2, doc3]:
    spans = []
    matches = matcher(doc)
    for match_id, start, end in matches:
        pattern_name = nlp.vocab.strings[match_id]
        spans.append(Span(doc, start, end, pattern_name))
    doc.spans["sc"] = spans
    displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.571.1">
     It’s just the opposite of the previous example.
    </span>
    <span class="koboSpan" id="kobo.571.2">
     Here, we wanted to pick up
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.572.1">
      forward email
     </span>
    </strong>
    <span class="koboSpan" id="kobo.573.1">
     sequences, and we allowed that one token to come between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.574.1">
      forward
     </span>
    </strong>
    <span class="koboSpan" id="kobo.575.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.576.1">
      email
     </span>
    </strong>
    <span class="koboSpan" id="kobo.577.1">
     .
    </span>
    <span class="koboSpan" id="kobo.577.2">
     In this case, the semantically important part is the forwarding an email action; whose email is it doesn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.578.1">
      matter much.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.579.1">
     We have
    </span>
    <a id="_idIndexMarker190">
    </a>
    <span class="koboSpan" id="kobo.580.1">
     mentioned
    </span>
    <a id="_idIndexMarker191">
    </a>
    <span class="koboSpan" id="kobo.581.1">
     regexes quite a lot in this chapter so far, so now, it’s time to see how spaCy’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.582.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.583.1">
     class makes use of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.584.1">
      regex syntax.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor063">
    </a>
    <span class="koboSpan" id="kobo.585.1">
     Regex support
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.586.1">
     When we match individual
    </span>
    <a id="_idIndexMarker192">
    </a>
    <span class="koboSpan" id="kobo.587.1">
     tokens, usually we want to allow some variations, such as common typos, UK/US English character differences, and so on.
    </span>
    <span class="koboSpan" id="kobo.587.2">
     Regexes are very handy for this task, and spaCy
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.588.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.589.1">
     offers full support for token-level regex matching.
    </span>
    <span class="koboSpan" id="kobo.589.2">
     Let’s explore how we can use regexes for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.590.1">
      our applications:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.591.1">
pattern = [{"POS": "PRON"},
           {"TEXT": {"REGEX": "[Tt]ravell?ed"}}]
matcher.add("regex", [pattern])
doc1 = nlp("I travelled by bus.")
doc2 = nlp("She traveled by bike.")
for doc in [doc1, doc2]:
    spans = []
    matches = matcher(doc)
    for match_id, start, end in matches:
        pattern_name = nlp.vocab.strings[match_id]
        spans.append(Span(doc, start, end, pattern_name))
    doc.spans["sc"] = spans
    displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.592.1">
     Here, our second token pattern is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.593.1">
      [Tt]ravell?ed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.594.1">
     , which means the token can be capitalized or not.
    </span>
    <span class="koboSpan" id="kobo.594.2">
     Also, there’s an optional
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.595.1">
      l
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     instance after the first
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.597.1">
      l
     </span>
    </strong>
    <span class="koboSpan" id="kobo.598.1">
     instance.
    </span>
    <span class="koboSpan" id="kobo.598.2">
     Allowing twin vowels and ise/ize alteration is a standard way of dealing with British and American
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.599.1">
      English variations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.600.1">
     Another way of using
    </span>
    <a id="_idIndexMarker193">
    </a>
    <span class="koboSpan" id="kobo.601.1">
     regexes is using them not only with text but also with POS tags.
    </span>
    <span class="koboSpan" id="kobo.601.2">
     What does the following code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.602.1">
      segment do?
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.603.1">
pattern = [{"TAG": {"REGEX": "^V"}}]
matcher.add("verbs",  [pattern])
doc = nlp("I went to Italy; he has been there too. </span><span class="koboSpan" id="kobo.603.2">His mother also has told me she wants to visit Rome.")
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans
displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.604.1">
     We have extracted
    </span>
    <a id="_idIndexMarker194">
    </a>
    <span class="koboSpan" id="kobo.605.1">
     all the finite verbs (you can think of a finite verb as a non-modal verb).
    </span>
    <span class="koboSpan" id="kobo.605.2">
     How did we do it?
    </span>
    <span class="koboSpan" id="kobo.605.3">
     Our token pattern includes the regex
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.606.1">
      ^V
     </span>
    </strong>
    <span class="koboSpan" id="kobo.607.1">
     , which means all fine-grained POS tags that start with V:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.608.1">
      VB
     </span>
    </strong>
    <span class="koboSpan" id="kobo.609.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.610.1">
      VGD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.612.1">
      VBG
     </span>
    </strong>
    <span class="koboSpan" id="kobo.613.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.614.1">
      VBN
     </span>
    </strong>
    <span class="koboSpan" id="kobo.615.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.616.1">
      VBP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.617.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.618.1">
      VBZ
     </span>
    </strong>
    <span class="koboSpan" id="kobo.619.1">
     .
    </span>
    <span class="koboSpan" id="kobo.619.2">
     Then, we extracted tokens with verbal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.620.1">
      POS tags.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-65">
    <a id="_idTextAnchor064">
    </a>
    <span class="koboSpan" id="kobo.621.1">
     Matcher online demo
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.622.1">
     spaCy
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.623.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     offers
    </span>
    <a id="_idIndexMarker195">
    </a>
    <span class="koboSpan" id="kobo.625.1">
     a tool on its online demo page:
    </span>
    <a href="https://explosion.ai/demos/matcher">
     <span class="koboSpan" id="kobo.626.1">
      https://explosion.ai/demos/matcher
     </span>
    </a>
    <span class="koboSpan" id="kobo.627.1">
     .
    </span>
    <span class="koboSpan" id="kobo.627.2">
     We can create patterns and test them against the text we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.628.1">
      want, interactively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.629.1">
     In
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.630.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.631.1">
      .10
     </span>
    </em>
    <span class="koboSpan" id="kobo.632.1">
     , we can see a match example.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     On the right side, we can select the attributes, values, and operators (such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.633.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.634.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.635.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.636.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.637.1">
      !
     </span>
    </strong>
    <span class="koboSpan" id="kobo.638.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.639.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.640.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.640.2">
     After making this selection, the demo outputs the corresponding pattern string on the right side, below the checkboxes.
    </span>
    <span class="koboSpan" id="kobo.640.3">
     On the left side, we first choose the spaCy language model we want (in this example, English core small), then see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.641.1">
      the results:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer050">
     <span class="koboSpan" id="kobo.642.1">
      <img alt="Figure 4.10 – spaCy’s Rule-based Matcher Explorer" src="image/B22441_04_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.643.1">
     Figure 4.10 – spaCy’s Rule-based Matcher Explorer
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.644.1">
     spaCy’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.645.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.646.1">
     demo helps you to see why your pattern matched or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.647.1">
      didn’t match.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-66">
    <a id="_idTextAnchor065">
    </a>
    <span class="koboSpan" id="kobo.648.1">
     Creating patterns with PhraseMatcher
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.649.1">
     While processing
    </span>
    <a id="_idIndexMarker196">
    </a>
    <span class="koboSpan" id="kobo.650.1">
     financial, medical, or legal text, we
    </span>
    <a id="_idIndexMarker197">
    </a>
    <span class="koboSpan" id="kobo.651.1">
     often have long lists and dictionaries and we want to scan the text against our lists.
    </span>
    <span class="koboSpan" id="kobo.651.2">
     As we saw in the previous section,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.652.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.653.1">
     patterns are quite handcrafted; we coded each token individually.
    </span>
    <span class="koboSpan" id="kobo.653.2">
     If you have a long list of phrases,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.654.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.655.1">
     is not very handy.
    </span>
    <span class="koboSpan" id="kobo.655.2">
     It’s not possible to code all the terms one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.656.1">
      by one.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.657.1">
     spaCy offers a solution for comparing text against long dictionaries – the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.658.1">
      PhraseMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.659.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.659.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.660.1">
      PhraseMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.661.1">
     class helps us match long dictionaries.
    </span>
    <span class="koboSpan" id="kobo.661.2">
     Let’s get started with a basic example of using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.662.1">
      PhraseMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.663.1">
     to match terms defined in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.664.1">
      a list:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.665.1">
      Import the library and the class and instantiate the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.666.1">
       nlp
      </span>
     </strong>
     <span class="koboSpan" id="kobo.667.1">
      pipeline
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.668.1">
       as usual:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.669.1">
import spacy
from spacy.matcher import PhraseMatcher
nlp = spacy.load("en_core_web_sm")</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.670.1">
      Now we can instantiate the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.671.1">
       PhraseMatcher
      </span>
     </strong>
     <span class="koboSpan" id="kobo.672.1">
      object and call
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.673.1">
       nlp.make_doc()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.674.1">
      on the terms one by one to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.675.1">
       create patterns:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.676.1">
matcher = PhraseMatcher(nlp.vocab)
terms = ["Angela Merkel", "Donald Trump", "Alexis Tsipras"]
patterns = [nlp.make_doc(term) for term in terms]
matcher.add("politiciansList", patterns)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.677.1">
      Finally, we check
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.678.1">
       the matches:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.679.1">
doc = nlp("3 EU leaders met in Berlin. </span><span class="koboSpan" id="kobo.679.2">German chancellor Angela Merkel first welcomed the US president Donald Trump. </span><span class="koboSpan" id="kobo.679.3">The following day Alexis Tsipras joined them in Brandenburg.")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans
displacy.render(doc, style="span")</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.680.1">
     This way, we match the patterns by their exact text values, as shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.681.1">
       Figure 4
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.682.1">
       .11
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.683.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer051">
     <span class="koboSpan" id="kobo.684.1">
      <img alt="Figure 4.11 – Matches using PhraseMatcher" src="image/B22441_04_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.685.1">
     Figure 4.11 – Matches using PhraseMatcher
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     What if we want to match
    </span>
    <a id="_idIndexMarker198">
    </a>
    <span class="koboSpan" id="kobo.687.1">
     them
    </span>
    <a id="_idIndexMarker199">
    </a>
    <span class="koboSpan" id="kobo.688.1">
     with other attributes?
    </span>
    <span class="koboSpan" id="kobo.688.2">
     Here’s an example of matching by the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.689.1">
       LOWER
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.690.1">
      attribute.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.691.1">
     First, we create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.692.1">
      PhraseMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.693.1">
     instance, passing an additional argument,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.694.1">
      attr=LOWER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.695.1">
     .
    </span>
    <span class="koboSpan" id="kobo.695.2">
     This way,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.696.1">
      PhraseMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.697.1">
     uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.698.1">
      token.lower
     </span>
    </strong>
    <span class="koboSpan" id="kobo.699.1">
     attribute during
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.700.1">
      the match:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.701.1">
matcher = PhraseMatcher(nlp.vocab, attr="LOWER")
terms = ["Asset", "Investment", "Derivatives", "Demand", "Market"]
patterns = [nlp.make_doc(term) for term in terms]
matcher.add("financeTerms", patterns)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.702.1">
     Now, let’s display
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.703.1">
      the results:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.704.1">
doc = nlp("During the last decade, derivatives market became an asset class of their own and influenced the financial landscape strongly.")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans
displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.705.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.706.1">
      .12
     </span>
    </em>
    <span class="koboSpan" id="kobo.707.1">
     shows the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.708.1">
      match results:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer052">
     <span class="koboSpan" id="kobo.709.1">
      <img alt="Figure 4.12 – Matches using the PhraseMatcher LOWER attribute" src="image/B22441_04_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.710.1">
     Figure 4.12 – Matches using the PhraseMatcher LOWER attribute
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.711.1">
     Another possible usage of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.712.1">
      PhraseMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.713.1">
     is matching the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.714.1">
      SHAPE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.715.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.715.2">
     This matching strategy can be
    </span>
    <a id="_idIndexMarker200">
    </a>
    <span class="koboSpan" id="kobo.716.1">
     used
    </span>
    <a id="_idIndexMarker201">
    </a>
    <span class="koboSpan" id="kobo.717.1">
     on system logs, where IP numbers, dates, and other numerical values occur a lot.
    </span>
    <span class="koboSpan" id="kobo.717.2">
     The good thing here is that you do not need to worry about how the numbers are tokenized; you just leave it to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.718.1">
      PhraseMatcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.719.1">
     .
    </span>
    <span class="koboSpan" id="kobo.719.2">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.720.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.721.1">
matcher = PhraseMatcher(nlp.vocab, attr="SHAPE")
ip_nums = ["127.0.0.0", "127.256.0.0"]
patterns = [nlp.make_doc(ip) for ip in ip_nums]
matcher.add("IPNums", patterns)
doc = nlp("This log contains the following IP addresses: 192.1.1.1 and 192.160.1.1 .")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans
displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.722.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.723.1">
      .13
     </span>
    </em>
    <span class="koboSpan" id="kobo.724.1">
     shows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.725.1">
      the results:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer053">
     <span class="koboSpan" id="kobo.726.1">
      <img alt="Figure 4.13 – Matches using the PhraseMatcher SHAPE attribute" src="image/B22441_04_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.727.1">
     Figure 4.13 – Matches using the PhraseMatcher SHAPE attribute
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.728.1">
     Handy, right?
    </span>
    <span class="koboSpan" id="kobo.728.2">
     We matched the tokens and phrases successfully; now, let’s move on to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.729.1">
      named entity recognition
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.731.1">
      NER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.732.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.732.2">
     Named
    </span>
    <a id="_idIndexMarker202">
    </a>
    <span class="koboSpan" id="kobo.733.1">
     entity extraction is an essential component of any
    </span>
    <a id="_idIndexMarker203">
    </a>
    <span class="koboSpan" id="kobo.734.1">
     NLP
    </span>
    <a id="_idIndexMarker204">
    </a>
    <span class="koboSpan" id="kobo.735.1">
     system, and most of the pipelines you’ll design will include an NER component.
    </span>
    <span class="koboSpan" id="kobo.735.2">
     The next section is devoted to rule-based named
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.736.1">
      entity extraction.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-67">
    <a id="_idTextAnchor066">
    </a>
    <span class="koboSpan" id="kobo.737.1">
     Creating patterns with SpanRuler
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.738.1">
     spaCy’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.739.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.740.1">
     component
    </span>
    <a id="_idIndexMarker205">
    </a>
    <span class="koboSpan" id="kobo.741.1">
     allows us to add spans
    </span>
    <a id="_idIndexMarker206">
    </a>
    <span class="koboSpan" id="kobo.742.1">
     to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.743.1">
      Doc.spans
     </span>
    </strong>
    <span class="koboSpan" id="kobo.744.1">
     and/or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.745.1">
      Doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.746.1">
     dictionaries using token-based rules or exact
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.747.1">
      phrase matches.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.748.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.749.1">
     is not a matcher; it’s a pipeline component that we can add to our pipeline via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.750.1">
      nlp.add_pipe
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     .
    </span>
    <span class="koboSpan" id="kobo.751.2">
     When it finds a match, the match is appended to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.752.1">
      doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.753.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.754.1">
      doc.spans
     </span>
    </strong>
    <span class="koboSpan" id="kobo.755.1">
     .
    </span>
    <span class="koboSpan" id="kobo.755.2">
     If adding to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.758.1">
      ent_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.759.1">
     will be the label we pass in the pattern.
    </span>
    <span class="koboSpan" id="kobo.759.2">
     Let’s see it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.760.1">
      in action:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.761.1">
      First, define a pattern for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.762.1">
       the entity:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.763.1">
patterns = [{"label": "ORG",
            "pattern": [{"LOWER": "chime"}]}]</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.764.1">
      Now, we add the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.765.1">
       SpanRuler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.766.1">
      component.
     </span>
     <span class="koboSpan" id="kobo.766.2">
      By default, it adds the spans to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.767.1">
       doc.spans
      </span>
     </strong>
     <span class="koboSpan" id="kobo.768.1">
      , and we want to add it to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.769.1">
       doc.ents
      </span>
     </strong>
     <span class="koboSpan" id="kobo.770.1">
      , so we specify that in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.771.1">
       the config:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.772.1">
span_ruler = nlp.add_pipe(
    "span_ruler", config={"annotate_ents":True})</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.773.1">
      Now, we can add the pattern to the component and process
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.774.1">
       the text:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.775.1">
span_ruler.add_patterns(patterns)
doc = nlp("I have an acccount with chime since 2017")
displacy.render(doc, style="ent")</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.776.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.777.1">
      .14
     </span>
    </em>
    <span class="koboSpan" id="kobo.778.1">
     shows the entity
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.779.1">
      we’ve matched:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer054">
     <span class="koboSpan" id="kobo.780.1">
      <img alt="Figure 4.14 – Entity created with SpanRuler" src="image/B22441_04_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.781.1">
     Figure 4.14 – Entity created with SpanRuler
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.782.1">
     We can see in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.783.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.784.1">
      .14
     </span>
    </em>
    <span class="koboSpan" id="kobo.785.1">
     that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.786.1">
      chime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.787.1">
     token was added to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.788.1">
      Doc.ents
     </span>
    </strong>
    <span class="koboSpan" id="kobo.789.1">
     dictionary.
    </span>
    <span class="koboSpan" id="kobo.789.2">
     If you don’t want
    </span>
    <a id="_idIndexMarker207">
    </a>
    <span class="koboSpan" id="kobo.790.1">
     to
    </span>
    <a id="_idIndexMarker208">
    </a>
    <span class="koboSpan" id="kobo.791.1">
     override the existing entities, you can set
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.792.1">
      overwrite
     </span>
    </strong>
    <span class="koboSpan" id="kobo.793.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.794.1">
      False
     </span>
    </strong>
    <span class="koboSpan" id="kobo.795.1">
     .
    </span>
    <span class="koboSpan" id="kobo.795.2">
     Let’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.796.1">
      try that:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.797.1">
nlp.remove_pipe("span_ruler")
patterns = [{"label": "ORG",
            "pattern": [{"LOWER": "chime"}]}]
span_ruler = nlp.add_pipe(
    "span_ruler", config={"annotate_ents":True, "overwrite":False})
span_ruler.add_patterns(patterns)
doc = nlp("I have an acccount with chime since 2017")
displacy.render(doc, style="ent")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.798.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.799.1">
      .15
     </span>
    </em>
    <span class="koboSpan" id="kobo.800.1">
     shows the result.
    </span>
    <span class="koboSpan" id="kobo.800.2">
     Now, the entity added by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      ner
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     component is also present (you will learn more about components and pipelines in
    </span>
    <a href="B22441_05.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.803.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.804.1">
      ):
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer055">
     <span class="koboSpan" id="kobo.805.1">
      <img alt="Figure 4.15 – Entities created with SpanRuler and the ner component" src="image/B22441_04_15.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.806.1">
     Figure 4.15 – Entities created with SpanRuler and the ner component
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.807.1">
     That’s it – easy, yet powerful.
    </span>
    <span class="koboSpan" id="kobo.807.2">
     We added our own entity with just a couple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.808.1">
      of lines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.809.1">
     Now that we’ve
    </span>
    <a id="_idIndexMarker209">
    </a>
    <span class="koboSpan" id="kobo.810.1">
     seen
    </span>
    <a id="_idIndexMarker210">
    </a>
    <span class="koboSpan" id="kobo.811.1">
     how to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.812.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.813.1">
     class and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.814.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.815.1">
     to extract information, we’ll move on to an exclusive section of quick and very
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.816.1">
      handy recipes.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-68">
    <a id="_idTextAnchor067">
    </a>
    <span class="koboSpan" id="kobo.817.1">
     Combining spaCy models and matchers
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.818.1">
     In this section, we’ll go
    </span>
    <a id="_idIndexMarker211">
    </a>
    <span class="koboSpan" id="kobo.819.1">
     through some recipes that will guide you through the entity extraction types you might encounter in your NLP journey.
    </span>
    <span class="koboSpan" id="kobo.819.2">
     All the examples are ready-to-use and real-world recipes.
    </span>
    <span class="koboSpan" id="kobo.819.3">
     Let’s start with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.820.1">
      number-formatted entities.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-69">
    <a id="_idTextAnchor068">
    </a>
    <span class="koboSpan" id="kobo.821.1">
     Extracting an IBAN
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.822.1">
     An
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.823.1">
      IBAN
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     is an important
    </span>
    <a id="_idIndexMarker212">
    </a>
    <span class="koboSpan" id="kobo.825.1">
     entity type that occurs
    </span>
    <a id="_idIndexMarker213">
    </a>
    <span class="koboSpan" id="kobo.826.1">
     in finance and banking frequently.
    </span>
    <span class="koboSpan" id="kobo.826.2">
     We’ll learn how to parse
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.827.1">
      it out.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.828.1">
     An IBAN is an international number format for bank account numbers.
    </span>
    <span class="koboSpan" id="kobo.828.2">
     It has the format of a two-digit country code followed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.829.1">
      by numbers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.830.1">
     How can we create a pattern for an IBAN?
    </span>
    <span class="koboSpan" id="kobo.830.2">
     We start with two capital letters, followed by two digits.
    </span>
    <span class="koboSpan" id="kobo.830.3">
     Then, any number of digits can follow.
    </span>
    <span class="koboSpan" id="kobo.830.4">
     We can express the country code and the next two digits
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.831.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.832.1">{"SHAPE": "XXdd"}</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.833.1">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.834.1">
      XX
     </span>
    </strong>
    <span class="koboSpan" id="kobo.835.1">
     corresponds to two capital letters, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.836.1">
      dd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.837.1">
     is two digits.
    </span>
    <span class="koboSpan" id="kobo.837.2">
     Then, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.838.1">
      XXdd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.839.1">
     pattern matches the first block of the IBAN perfectly.
    </span>
    <span class="koboSpan" id="kobo.839.2">
     How about the rest of the digit blocks?
    </span>
    <span class="koboSpan" id="kobo.839.3">
     For the rest of the blocks, we need to match a block of one to four digits.
    </span>
    <span class="koboSpan" id="kobo.839.4">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.840.1">
      \d{1,4}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.841.1">
     regex means a token consisting of one to four digits.
    </span>
    <span class="koboSpan" id="kobo.841.2">
     This pattern will match a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.842.1">
      digit block:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.843.1">{"TEXT": {"REGEX": "\d{1,4}"}}</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.844.1">
     We have a number of these blocks, so the pattern to match the digit blocks of an IBAN is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.845.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.846.1">{"TEXT": {"REGEX": "\d{1,4}"}, "OP": "+"}</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.847.1">
     Then, we combine the first shape block with the rest of the blocks.
    </span>
    <span class="koboSpan" id="kobo.847.2">
     Let’s check the full code of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.848.1">
      the pattern:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.849.1">
      Define the pattern and add it to the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.850.1">
        Matcher
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.851.1">
       object:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.852.1">
pattern = [{"SHAPE": "XXdd"},
           {"TEXT": {"REGEX": "\d{1,4}"}, "OP":"+"}]
matcher = Matcher(nlp.vocab)
matcher.add("ibanNum",  [pattern])</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.853.1">
      Now, let’s add
     </span>
     <a id="_idIndexMarker214">
     </a>
     <span class="koboSpan" id="kobo.854.1">
      the code to display
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.855.1">
       the
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker215">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.856.1">
       matches:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.857.1">
doc = nlp("My IBAN number is BE71 0961 2345 6769, please send the money there.")
doc1 = nlp("My IBAN number is FR76 3000 6000 0112 3456 7890 189, please send the money there.")
for doc in [doc, doc1]:
    spans = []
    matches = matcher(doc)
    for match_id, start, end in matches:
        pattern_name = nlp.vocab.strings[match_id]
        spans.append(Span(doc, start, end, pattern_name))
    doc.spans["sc"] = spans
    displacy.render(doc, style="span")</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.858.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.859.1">
      .16
     </span>
    </em>
    <span class="koboSpan" id="kobo.860.1">
     shows the result.
    </span>
    <span class="koboSpan" id="kobo.860.2">
     You can always follow a similar strategy when parsing numeric entities: first, divide the entity into some meaningful parts/blocks, then try to determine the shape or the length of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.861.1">
      individual blocks:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer056">
     <span class="koboSpan" id="kobo.862.1">
      <img alt="Figure 4.16 – Extracting IBANs" src="image/B22441_04_16.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.863.1">
     Figure 4.16 – Extracting IBANs
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.864.1">
     We
    </span>
    <a id="_idIndexMarker216">
    </a>
    <span class="koboSpan" id="kobo.865.1">
     successfully
    </span>
    <a id="_idIndexMarker217">
    </a>
    <span class="koboSpan" id="kobo.866.1">
     parsed IBANs.
    </span>
    <span class="koboSpan" id="kobo.866.2">
     Now, we’ll extract another type of common numeric entity:
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.867.1">
      phone numbers.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-70">
    <a id="_idTextAnchor069">
    </a>
    <span class="koboSpan" id="kobo.868.1">
     Extracting phone numbers
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.869.1">
     Phone numbers can
    </span>
    <a id="_idIndexMarker218">
    </a>
    <span class="koboSpan" id="kobo.870.1">
     have very different formats depending on the country, and matching phone numbers is often a tricky business.
    </span>
    <span class="koboSpan" id="kobo.870.2">
     The best strategy here is to be specific about the country phone number format you want to parse.
    </span>
    <span class="koboSpan" id="kobo.870.3">
     If there are several countries, you can add corresponding individual patterns to the matcher.
    </span>
    <span class="koboSpan" id="kobo.870.4">
     If you have too many countries, then you can relax some conditions and go for a more general pattern (we’ll see how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.871.1">
      do that).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.872.1">
     Let’s start with the US phone number format.
    </span>
    <span class="koboSpan" id="kobo.872.2">
     A US number is written as (541) 754-3010 domestically or +1 (541) 754-3010 internationally.
    </span>
    <span class="koboSpan" id="kobo.872.3">
     We can form our pattern with an optional
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.873.1">
      +1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.874.1">
     instance, then a three-digit area code, then two blocks of numbers separated with an optional
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.875.1">
      -
     </span>
    </strong>
    <span class="koboSpan" id="kobo.876.1">
     instance.
    </span>
    <span class="koboSpan" id="kobo.876.2">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.877.1">
      the pattern:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.878.1">{"TEXT": "+1", "OP": "?"}, {"TEXT": "("}, {"SHAPE": "ddd"}, {"TEXT": ")"}, {"SHAPE": "ddd"}, {"TEXT": "-", "OP": "?"}, {"SHAPE": "dddd"}</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.879.1">
     Let’s see an example of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.880.1">
      the pattern:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.881.1">
pattern = [{"TEXT": "+1", "OP": "?"}, {"TEXT": "("},
           {"SHAPE": "ddd"}, {"TEXT": ")"},
           {"SHAPE": "ddd"}, {"TEXT": "-", "OP": "?"},
           {"SHAPE": "dddd"}]
matcher = Matcher(nlp.vocab)
matcher.add("usPhonNum",  [pattern])</span></pre>
   <p>
    <span class="koboSpan" id="kobo.882.1">
     Next, we have some
    </span>
    <a id="_idIndexMarker219">
    </a>
    <span class="koboSpan" id="kobo.883.1">
     example sentences and the code to display
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      the matches:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.885.1">
doc1 = nlp("You can call my office on +1 (221) 102-2423 or email me directly.")
doc2 = nlp("You can call me on (221) 102 2423 or text me.")
for doc in [doc1, doc2]:
    spans = []
    matches = matcher(doc)
    for match_id, start, end in matches:
        pattern_name = nlp.vocab.strings[match_id]
        spans.append(Span(doc, start, end, pattern_name))
    doc.spans["sc"] = spans
    displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.886.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.887.1">
      .17
     </span>
    </em>
    <span class="koboSpan" id="kobo.888.1">
     shows the results.
    </span>
    <span class="koboSpan" id="kobo.888.2">
     How about we make the pattern more general to apply to other countries as well?
    </span>
    <span class="koboSpan" id="kobo.888.3">
     In this case, we can start with a one-to-three-digit country code, followed by some digit blocks.
    </span>
    <span class="koboSpan" id="kobo.888.4">
     It will match a broader set of numbers, so it’s better to be careful not to match other numeric entities in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.889.1">
      your text:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer057">
     <span class="koboSpan" id="kobo.890.1">
      <img alt="Figure 4.17 – Extracting phone numbers" src="image/B22441_04_17.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.891.1">
     Figure 4.17 – Extracting phone numbers
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.892.1">
     We’ll move on to
    </span>
    <a id="_idIndexMarker220">
    </a>
    <span class="koboSpan" id="kobo.893.1">
     textual entities from numeric entities.
    </span>
    <span class="koboSpan" id="kobo.893.2">
     Now, we’ll process social media text and extract different types of entities that can occur in social
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.894.1">
      media text.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-71">
    <a id="_idTextAnchor070">
    </a>
    <span class="koboSpan" id="kobo.895.1">
     Extracting mentions
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.896.1">
     Imagine analyzing
    </span>
    <a id="_idIndexMarker221">
    </a>
    <span class="koboSpan" id="kobo.897.1">
     a dataset of social media posts about companies and products, and your task is to find out which companies are mentioned in which ways.
    </span>
    <span class="koboSpan" id="kobo.897.2">
     The dataset will contain these sorts
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.898.1">
      of sentences:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.899.1">
CafeA is very generous with the portions.
</span><span class="koboSpan" id="kobo.899.2">CafeB is horrible, we waited for mins for a table.
</span><span class="koboSpan" id="kobo.899.3">RestaurantA is terribly expensive, stay away!
</span><span class="koboSpan" id="kobo.899.4">RestaurantB is pretty amazing, we recommend.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.900.1">
     What we’re looking for is, most probably, patterns of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.901.1">
      BusinessName is/was/be adverb*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.902.1">
     adjective form.
    </span>
    <span class="koboSpan" id="kobo.902.2">
     The following pattern
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.903.1">
      would work:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.904.1">[{"ENT_TYPE": "ORG"}, {"LEMMA": "be"}, {"POS": "ADV", "OP": "*"}, {"POS": "ADJ"}]</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.905.1">
     Here, we look for an organization type entity, followed by an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.906.1">
      is/was/be
     </span>
    </strong>
    <span class="koboSpan" id="kobo.907.1">
     instance, then optional adverbs, and finally,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.908.1">
      an adjective.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.909.1">
     What if you want to extract a specific business – let’s say, the company ACME?
    </span>
    <span class="koboSpan" id="kobo.909.2">
     All you have to do is replace the first token with the specific
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.910.1">
      company name:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.911.1">[{"LOWER": "acme"}, {"LEMMA": "be"}, {"POS": "ADV", "OP": "*"}, {"POS": "ADJ"}]</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.912.1">
     That’s it – easy peasy!
    </span>
    <span class="koboSpan" id="kobo.912.2">
     After extracting the social media mentions, the next thing to do is to extract
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.913.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker222">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.914.1">
      hashtags.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-72">
    <a id="_idTextAnchor071">
    </a>
    <span class="koboSpan" id="kobo.915.1">
     Hashtag extraction
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.916.1">
     Processing social
    </span>
    <a id="_idIndexMarker223">
    </a>
    <span class="koboSpan" id="kobo.917.1">
     media text has some challenges.
    </span>
    <span class="koboSpan" id="kobo.917.2">
     Social media text has an unusual token type:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.918.1">
      hashtags
     </span>
    </strong>
    <span class="koboSpan" id="kobo.919.1">
     .
    </span>
    <span class="koboSpan" id="kobo.919.2">
     They
    </span>
    <a id="_idIndexMarker224">
    </a>
    <a id="_idIndexMarker225">
    </a>
    <span class="koboSpan" id="kobo.920.1">
     have a huge impact on the text’s meaning.
    </span>
    <span class="koboSpan" id="kobo.920.2">
     The hashtag refers to the subject/object of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.921.1">
      the sentence.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.922.1">
     A hashtag consists of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.923.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.924.1">
     character at the beginning, then followed by a word of ASCII characters, with no inter-word spaces.
    </span>
    <span class="koboSpan" id="kobo.924.2">
     Some examples are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.925.1">
      #MySpace
     </span>
    </strong>
    <span class="koboSpan" id="kobo.926.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.927.1">
      #MondayMotivation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.928.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.928.2">
     The spaCy tokenizer tokenizes these words into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.929.1">
      two tokens:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.930.1">
doc = nlp("#MySpace")
print([token.text for token in doc])
&gt;&gt;&gt; ['#', 'MySpace']</span></pre>
   <p>
    <span class="koboSpan" id="kobo.931.1">
     As a result, our pattern needs to match two tokens: the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.932.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.933.1">
     character and the rest.
    </span>
    <span class="koboSpan" id="kobo.933.2">
     The following pattern will match a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.934.1">
      hashtag easily:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.935.1">{"TEXT": "#"}, {"IS_ASCII": True}</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.936.1">
     The following pattern extracts
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.937.1">
      a hashtag:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.938.1">
pattern = [{"TEXT": "#"}, {"IS_ASCII": True}]
matcher = Matcher(nlp.vocab)
matcher.add("hashTag",  [pattern])</span></pre>
   <p>
    <span class="koboSpan" id="kobo.939.1">
     Now, let’s display the matches using the sentence
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.940.1">
      "Start working out
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.941.1">
       now #WeekendShred"
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.942.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.943.1">
doc = nlp("Start working out now #WeekendShred")
matches = matcher(doc)
spans = []
for match_id, start, end in matches:
    pattern_name = nlp.vocab.strings[match_id]
    spans.append(Span(doc, start, end, pattern_name))
doc.spans["sc"] = spans
displacy.render(doc, style="span")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.944.1">
     Pretty easy as well.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.945.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.946.1">
      .18
     </span>
    </em>
    <span class="koboSpan" id="kobo.947.1">
     shows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.948.1">
      the result:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer058">
     <span class="koboSpan" id="kobo.949.1">
      <img alt="Figure 4.18 – Matches the hashTag pattern" src="image/B22441_04_18.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.950.1">
     Figure 4.18 – Matches the hashTag pattern
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.951.1">
     Emoji is another unusual token and has the potential to assign the sentiment to a sentence.
    </span>
    <span class="koboSpan" id="kobo.951.2">
     We can also extract emoji tokens using the spacymoji
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.952.1">
      package (
     </span>
    </span>
    <a href="https://spacy.io/universe/project/spacymoji">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.953.1">
       https://spacy.io/universe/project/spacymoji
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.954.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.955.1">
     Now, let’s extract
    </span>
    <a id="_idIndexMarker226">
    </a>
    <span class="koboSpan" id="kobo.956.1">
     some entities.
    </span>
    <span class="koboSpan" id="kobo.956.2">
     We’ll start with the common procedure of expanding named entities in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.957.1">
      next section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-73">
    <a id="_idTextAnchor072">
    </a>
    <span class="koboSpan" id="kobo.958.1">
     Expanding named entities
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.959.1">
     Often, we would like
    </span>
    <a id="_idIndexMarker227">
    </a>
    <span class="koboSpan" id="kobo.960.1">
     to expand a named entity’s span to the left or to the right.
    </span>
    <span class="koboSpan" id="kobo.960.2">
     Imagine you want to extract
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.961.1">
      PERSON
     </span>
    </strong>
    <span class="koboSpan" id="kobo.962.1">
     type named entities with titles so that you can deduce the gender or profession easily.
    </span>
    <span class="koboSpan" id="kobo.962.2">
     spaCy’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.963.1">
      NER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.964.1">
     class already extracts person names, so how about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.965.1">
      the titles?
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.966.1">
doc = nlp("Ms. </span><span class="koboSpan" id="kobo.966.2">Smith left her house 2 hours ago.")
print(doc.ents)
&gt;&gt;&gt; (Smith, 2 hours ago)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.967.1">
     As you see, the word
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.968.1">
      Ms.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.969.1">
     is not included in the named entity because it’s not a part of the person’s name.
    </span>
    <span class="koboSpan" id="kobo.969.2">
     A quick solution is to make a new entity type
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.970.1">
      called
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.971.1">
       TITLE
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.972.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.973.1">
nlp.remove_pipe("span_ruler")
patterns = [{"label": "TITLE",
             "pattern": [{"LOWER": {"IN": [
                 "ms.", "mr.", "mrs.", "prof.", "dr."]}}]}]
ruler = nlp.add_pipe("span_ruler", 
                     config={"annotate_ents":True, "overwrite":False})
ruler.add_patterns(patterns)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.974.1">
     Now, let’s display the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.975.1">
      matches again:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.976.1">
doc = nlp("Ms. </span><span class="koboSpan" id="kobo.976.2">Smith left her house")
displacy.render(doc, style="ent")</span></pre>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.977.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.978.1">
      .19
     </span>
    </em>
    <span class="koboSpan" id="kobo.979.1">
     shows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.980.1">
      the result:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer059">
     <span class="koboSpan" id="kobo.981.1">
      <img alt="Figure 4.19 – Expanding entities with Matcher" src="image/B22441_04_19.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.982.1">
     Figure 4.19 – Expanding entities with Matcher
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.983.1">
     This is a quick and
    </span>
    <a id="_idIndexMarker228">
    </a>
    <span class="koboSpan" id="kobo.984.1">
     very handy recipe.
    </span>
    <span class="koboSpan" id="kobo.984.2">
     You’ll come across parsing titles a lot if you process wiki text or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.985.1">
      financial text.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor073">
    </a>
    <span class="koboSpan" id="kobo.986.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.987.1">
     In this chapter, you learned how to do rule-based matching with linguistic and token-level features.
    </span>
    <span class="koboSpan" id="kobo.987.2">
     You learned about the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.988.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.989.1">
     class, spaCy’s rule-based matcher.
    </span>
    <span class="koboSpan" id="kobo.989.2">
     We explored the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.990.1">
      Matcher
     </span>
    </strong>
    <span class="koboSpan" id="kobo.991.1">
     class by using it with different token features, such as shape, lemma, text, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.992.1">
      entity type.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.993.1">
     Then, you learned about
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.994.1">
      SpanRuler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.995.1">
     , another lifesaving class that you can achieve a lot with.
    </span>
    <span class="koboSpan" id="kobo.995.2">
     You also learned how to extract named entities with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.996.1">
       SpanRuler
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.997.1">
      class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.998.1">
     Finally, we put together what you learned in this chapter and your previous knowledge and combined linguistic features with rule-based matching with several examples.
    </span>
    <span class="koboSpan" id="kobo.998.2">
     You learned how to extract patterns, entities of specific formats, and entities specific to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.999.1">
      your domain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1000.1">
     With this chapter, you completed the linguistic features.
    </span>
    <span class="koboSpan" id="kobo.1000.2">
     In the next chapter, we’ll use all this knowledge to extract semantic representations from text using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1001.1">
      spaCy pipelines.
     </span>
    </span>
   </p>
  </div>
 </body></html>