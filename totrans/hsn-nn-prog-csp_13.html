<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Function Optimizations: How and Why</h1>
                </header>
            
            <article>
                
<p>bAnd now it's time to have some fun. We are going to develop a very powerful, three-dimensional application that you won't find anywhere else. This application will allow you to visualize how individual functions optimize over time, with a two and three-dimensional graphic of each. The source code for this application is located in the instructions given for access of the book's source code. This application will be very unique in that we will use a mixture of open source and third-party controls to create an unbelievably powerful application. Open source doesn't handle everything all the time, and for those of you serious about graphics I wanted to expose you to some controls aside from the open source standards such as ZedGraph, Microsoft Charting Controls, and others. As you will see in a moment, the difference is astounding and worth the ride. You can decide later if you want to change anything back to completely open source.</p>
<p>We are also going to show you how we can use Particle Swarm Optimization to enhance visualizations of function optimizations. By doing so  you will see how each particle in the swarm converges to the optimal solution.</p>
<p>In this chapter, we are going to accomplish the following:</p>
<ul>
<li>Build a Visual Studio WinForms project</li>
<li>Create a function optimization tester</li>
<li>Implement graphic controls for our visualizations</li>
<li>Talk about various third-party controls used in this project</li>
<li>Learn about the various hyperparameters available</li>
<li>Learn to tune and adjust hyperparameters</li>
<li>Learn the effect of adjusting hyperparameters</li>
<li>Learn about the purpose of functions</li>
<li>Learn how to add new functions</li>
<li>Demonstrate adding a new function and running a test</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have a basic knowledge of .NET development using Microsoft Visual Studio and C#. You will need to download the code for this chapter from the book's website.</p>
<p><span>Check out the following video to see Code in Action: <a href="http://bit.ly/2ppBmvI">http://bit.ly/2ppBmvI</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>Before we get started, let me show you the product we are going to create. When we are done you will have an application that allows you to view graphically how a function minimizes or maximizes over iterations. This is contrary to the typical text-based representations of such systems, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1287 image-border" src="assets/244ea886-fc86-4f45-bd1e-f3a6354126b4.png" style="width:106.33em;height:65.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>As you can see, this is a very visual application. Let's go ahead and break this down into sections that we will refer to as we progress.</p>
<p>The first section is the three-dimensional plot and is located on our main page. Three dimensions can provide much more insight into the path that each particle in the swarm takes, and the swarm itself is taking. It is also much easier to see when a particle or the swarm converges on the global minimum. For this plot we will use the incredible Nevron chart control. You can find more information about this Chart control at <a href="https://www.nevron.com/products-open-vision-nov-chart-control-overview.aspx">https://www.nevron.com/products-open-vision-nov-chart-control-overview.aspx</a>. The main user interface is developed with DotNetBar. For those looking for a different user interface with all the bells and whistles such as crumbbars, tabs, grids, listviews, charts, sparklines, and more, this is a great and more affordable choice than say Infragistics or DevExpress. You can find more information about this suite of controls at <a href="http://www.devcomponents.com/dotnetbar/">http://www.devcomponents.com/dotnetbar/</a></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1288 image-border" src="assets/45942ee6-311c-4ef9-819f-5b1e1bec58bf.png" style="width:106.42em;height:65.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Main Page</div>
<p>The second section is the two-dimensional plot, and is located on our fourth page, the <strong>Charts</strong> tab. Some people would also call this type of plot a spaghetti plot. Its job is to plot the swarm on a two-dimensional plane. For this plot we will use the Microsoft Chart control. As you can see, this control becomes very busy when trying to plot on a two-dimensional surface. The more particles in the swarm that you have, the busier your chart will become:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1289 image-border" src="assets/e4424b8f-313f-4448-9fb1-f4fea9e7fed4.png" style="width:106.58em;height:65.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">2D Visualization</div>
<p>The third section is the information tree, and is located on our third page, the <strong>Details</strong> tab. This tree houses detailed information from each iteration. The total number of iterations is a hyperparameter we will discuss shortly. Each iteration will track all swarm particle information such as position, speed, best position, and fitness, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1290 image-border" src="assets/9c7a92a0-9f87-40c3-9676-7be2a34e354d.png" style="width:106.67em;height:64.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Information Tree</div>
<p>The fourth section is the function hyperparameters and is located on our main page. These parameters control the function and function optimizations and are essential for plotting both the two and three-dimensional plots. The individual parameters themselves will be discussed in a later section:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1dea8c0c-0baf-4411-8942-256ca28657bd.png" style="width:14.58em;height:34.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Parameters</div>
<p>The fifth section is the plot replay controls, also located on our main page at the bottom, underneath the hyperparameters. Aside from running the main function optimization iteration loop, they are responsible for replaying the function optimization plot for both the two and three-dimensional plots. You can play, pause, rewind, step forward, and step backward, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1145 image-border" src="assets/4c1d72a7-4206-4d74-b41b-905a23cf8861.png" style="width:11.92em;height:6.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Run controls</div>
<p>With the details behind us, let's move on to discussing exactly how we are going to create our application. Let the fun begin!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function minimization and maximization</h1>
                </header>
            
            <article>
                
<p>Function minimization and maximization are the process of finding the smallest and largest value of a given function. Let's talk briefly about that value.</p>
<p>If the value is within a given range, then it is called the local extrema; if it is within the entire domain of a function then it is called the global extrema. Let's say we have a function f, and it's defined against a domain X. The maximum, or global, point at x* is f(x*) is greater than or equal to f(x) for all x in the domain X. Conversely, the function's global minimum point at x* is f(x*) is less than or equal to f(x) for all x in the domain X.</p>
<p>In a simpler fashion, the maximum point is also called the maximum value, and the minimum point is called the minimum value, of the function. The global maximum or minimum is either the highest or lowest function value in the entire domain space (search space), and the local maximum or minimum is the highest or lowest value in a defined neighborhood within that search space (it is not allowed to reside on the boundary at all), as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e7eb27d7-f4ad-4896-b80d-b47b71219a96.png" style="width:22.67em;height:15.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Global and Local Optimums</div>
<p><span>In this simple illustration, <strong>D</strong> is the global minimum and <strong>G</strong> is the global maximums. <strong>A</strong>, <strong>C</strong>, and <strong>E</strong> are local maximums (it is important to note that a function can have more than one global or local maximum or minimum). <strong>B</strong> and <strong>F</strong> are considered local minimum. <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> exist around the minimum</span> <span>value <strong>F</strong>, since the value of <strong>Y</strong> is less than both <strong>X</strong> and <strong>Z</strong></span><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1292 image-border" src="assets/a40b965b-5c2c-4935-ad0c-c837894bdf10.png" style="width:22.00em;height:24.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Tape Plot</div>
<p>Let's take a real example. Let's say we are using the function sin(x). The maximum value for this function is +1, and the minimum value would be -1. Therefore, we have the global minimum and maximum. Sin(x) can take on any value between negative and positive infinity, but over all of these values, the maximum can only be +1 and, the minimum can only be -1.</p>
<p>If we then restrict the search space (global domain) to between 0 and 90 (sometimes people call this the interval), sin(x) will now have a minimum of 0, and its value will be 0. However, the global or maximum value will now be 90 and the value is 1, because we restricted our search space to between 0 and 90. All values of sin(x) will lie between 0 and 1, within the interval of 0 to 90.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a particle?</h1>
                </header>
            
            <article>
                
<p>One of the main components we are going to be dealing with is what is known as a <strong>particle—</strong>hence, Particle Swarm Optimization. To briefly provide an analogy as to what a particle is, let's look at it this way. Let's say that we see a flock of birds flying in the sky. Each bird in this flock is a particle. We see a school of fish swimming in the water. Each fish is a particle. We knocked down that bee hive and were attacked by hundreds of bees. Each bee that attacked us was, you got it, a particle!</p>
<p>Each particle has fitness values which, once evaluated by the fitness function to be optimized, will tell us how it ranks in the swarm. Additionally, we also have velocities that direct the flying of each particle. The particles, like the birds, fly through our problem space by following the <em>optimum</em> particle, which would be the leader of the flock of birds.</p>
<p>Now that we know exactly what a particle is, how do we describe it in computational terms? We will define a structure like the following:</p>
<pre>/// &lt;summary&gt; A particle. &lt;/summary&gt;<br/>public struct Particle<br/>{<br/>/// &lt;summary&gt; The position of the particle. &lt;/summary&gt;<br/>public double[] Position;<br/>/// &lt;summary&gt; The speed of the particle. &lt;/summary&gt;<br/>public double[] Speed;<br/>/// &lt;summary&gt; The fitness value of the particle. &lt;/summary&gt;<br/>public double FitnessValue;<br/>/// &lt;summary&gt; The best position of the particle. &lt;/summary&gt;<br/>public double[] BestPosition;<br/>/// &lt;summary&gt; The best fitness value of the particle. &lt;/summary&gt;<br/>public double BestFitnessValue;<br/>}</pre>
<p>With that behind us, let's go ahead and create our project. You should have Microsoft Visual Studio installed and open. If you have not installed Microsoft Visual Studio yet, you can install the free Community Version from the Microsoft web site. Once this is complete, open Microsoft Visual Studio and create a Windows Forms project as shown in the following screenshot. In our instance we are using .NET version 4.7.1. Feel free to use whatever version you have, but it needs to be at least version 4.5.2 or higher:</p>
<p> </p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1157 image-border" src="assets/376b6c61-cf99-46d5-861e-30e450919bc0.png" style="width:37.17em;height:34.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">New Project Window</div>
<p>Next, let me mention that our user interface is created with a third-party product called <strong>DotNetBar</strong>. This is a fantastic, light weight user-interface library. It can be found here: <a href="http://www.devcomponents.com/dotnetbar/">http://www.devcomponents.com/dotnetbar/</a><a href="http://www.devcomponents.com/dotnetbar/">.<strong><em> </em></strong>We are now free to begin to focus on the formulation of our project. We will need to initialize some general areas of our program, such as the Swarm, the Chart, and the State.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swarm initialization</h1>
                </header>
            
            <article>
                
<p>To begin, we need to initialize our swarm and all the variables and properties that go along with it.</p>
<p>To begin the process, let's create a particle called <kbd>GlobalBest</kbd> (which I will refer to throughout the book as <kbd>gbest</kbd>) and initialize its best fitness value to either positive or negative infinity, depending upon whether the user has selected a strategy of <kbd>Minimization</kbd> or <kbd>Maximization</kbd>. We do so like this:</p>
<pre>GlobalBest.BestFitnessValue = PSO_Type == PSOType.<strong>Minimization<br/></strong>? double.<strong>PositiveInfinity</strong> : double.<strong>NegativeInfinity</strong>;</pre>
<p>Next, we will determine which swarm size the user desires, and then initialize all the particles in the swarm. Each particle will have several properties that will need to be initialized. They are:</p>
<p>Position:</p>
<pre>Swarm[<strong>i</strong>].Position = Swarm_Random(lb_domXi, ub_domXi, dimSize);</pre>
<p>Speed:</p>
<pre>Swarm[<strong>i</strong>].Speed = Swarm_Random(lb_domXi, ub_domXi, dimSize);</pre>
<p>Fitness value:</p>
<pre>Swarm[<strong>i</strong>].FitnessValue = PSO_Round(Fitness(Swarm[<strong>i</strong>].Position));</pre>
<p>Best fitness value:</p>
<pre>Swarm[<strong>i</strong>].BestFitnessValue = Swarm[<strong>i</strong>].FitnessValue;</pre>
<p>Best position:</p>
<pre>Swarm[<strong>i</strong>].BestPosition = (double[])Swarm[<strong>i</strong>].Position.Clone();</pre>
<p>With this done, we need to check and see if the individual particles' best fitness value (<kbd>pbest</kbd>) is better than the global particle (the team's) fitness value (<kbd>gbest</kbd>). If so we will update the global particle to that best position and fitness value and the other particles will follow it. We do so like this:</p>
<pre>if (IsBetterPosition(Swarm[<strong>i</strong>].BestFitnessValue, GlobalBest.BestFitnessValue, PSO_Type))<br/>{<br/>GlobalBest.BestPosition = (double[])Swarm[<strong>i</strong>].Position.Clone();<br/>GlobalBest.BestFitnessValue = Swarm[<strong>i</strong>].BestFitnessValue;<br/>}</pre>
<p>Next, we will fill the swarm and global plot matrix like this:</p>
<pre>FillPlotSwarmPosition(0, <strong>i</strong>, Swarm[<strong>i</strong>].Position);<br/>FillPlotGlobalPosition(0, GlobalBest.BestPosition);</pre>
<p>Once this is done, we will update our information tree with all the details associated with the swarm now. To do so we need to iterate through the entire swarm and record our information for display. Since we are using a Windows Tree Control, we will plot each swarm particle as a separate node, indicated by the identifier <kbd>PSODisplayType.Swarm</kbd>. The information underneath each node will be indicated by the identifier <kbd>PSODisplayType.SwarmPosition</kbd>. We accomplish this like this:</p>
<pre>DisplayResult(PSODispType.<strong>GlobalBest</strong>, "Iter : 0 " + GlobalBest.BestFitnessValue + " :: " + sResult(GlobalBest.BestPosition));<br/>for (int <strong>i</strong> = 0; <strong>i</strong> &lt; SwarmSize; <strong>i</strong>++)<br/>{<br/>DisplayResult(PSODispType.<strong>Swarm</strong>, "Swarm [" + <strong>i</strong> + "] : " + Swarm[<strong>i</strong>].FitnessValue);<br/>DisplayResult(PSODispType.<strong>SwarmPosition</strong>, "Position : " + sResult(Swarm[<strong>i</strong>].Position));<br/>DisplayResult(PSODispType.<strong>SwarmPosition</strong>, "Speed : " + sResult(Swarm[<strong>i</strong>].Speed));<br/>DisplayResult(PSODispType.<strong>SwarmPosition</strong>, "Best Pos : " + sResult(Swarm[<strong>i</strong>].BestPosition));<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chart initialization</h1>
                </header>
            
            <article>
                
<p>In our application, which we will call the workbench for short, we are dealing with two charts. The first chart is three-dimensional, the second is two-dimensional. Each one reflects the same data albeit from a different perspective. In our chart initialization function, we will initialize both charts at the same time.</p>
<ul>
<li><kbd>chartPSO</kbd> is the name of our two-dimensional Microsoft Chart Control chart</li>
<li><kbd>nChartControl2</kbd> is the name of our three-dimensional Nevron chart</li>
</ul>
<p>Why not use the same control for both visualizations? That certainly could have been the case, but this way you, the reader, get exposure to two different types of control and can decide which you prefer.</p>
<p>The first thing that we will do is to create a random variable called <kbd>_MarkerStyle</kbd>. Each particle will have a different marker style in the two-dimensional plot, and we will use this random variable to control the correct creation of the style like this:</p>
<pre>FastRandom _MarkerStyle = new FastRandom();</pre>
<p>Next on our list of things to do is to clear the series data from both controls, just in case there is data left over. We do so with the following two lines of code. Remember, <kbd>chartPSO</kbd> is our two-dimensional chart and, <kbd>nChartControl2</kbd> is our three-dimensional chart control:</p>
<pre>chartPSO?.Series?.Clear();<br/>nChartControl2?.Charts?[0]?.Series?.Clear();</pre>
<p>To get the best visualization from our three-dimensional control, we need to ensure that it fits the entire chart area. We do that by setting the bounds mode like this:</p>
<pre>nChartControl2.Charts[0].BoundsMode = BoundsMode.<strong>Stretch</strong>;</pre>
<p>Now, we need to make sure that each particle in the swarm has an area of representation in both charts. We do that by iterating through the swarm size and setting each variable correctly. We start by adding the two-dimensional chart configuration first:</p>
<pre>for (int <strong>i</strong> = 0; <strong>i</strong> &lt; maxSwarm; <strong>i</strong>++)<br/>{<br/>chartPSO?.Series?.Add("Swarm(" + <strong>i</strong> + ")");<br/>chartPSO.Series[<strong>i</strong>].ChartType = SeriesChartType.<strong>Spline</strong>;<br/>chartPSO.Series[<strong>i</strong>].MarkerStyle = (MarkerStyle)_MarkerStyle.Next(1, 10);<br/>chartPSO.Series[<strong>i</strong>].MarkerSize = 10;</pre>
<p>And then the three-dimensional chart configuration, like this:</p>
<pre>for (int <strong>i</strong> = 0; <strong>i</strong> &lt; maxSwarm; <strong>i</strong>++)<br/>{<br/>NLineSeries m_Line1 = (NLineSeries)nChartControl2.Charts[0].Series.Add(SeriesType.<strong>Line</strong>);<br/>m_Line1.MultiLineMode = MultiLineMode.<strong>Series</strong>;<br/>m_Line1.LineSegmentShape = LineSegmentShape.<strong>Tape</strong>;<br/>m_Line1.DataLabelStyle.Visible = false;<br/>m_Line1.DepthPercent = 50;<br/>m_Line1.Name = "Swarm(" + <strong>i</strong> + ")";</pre>
<p>Next, let's set the final variables of the two-dimensional chart as follows:</p>
<pre>chartPSO?.Series?.Add("GlobalPosition");<br/>chartPSO.Series[maxSwarm].ChartType = SeriesChartType.<strong>Point</strong>;<br/>chartPSO.Series[maxSwarm].MarkerStyle = MarkerStyle.<strong>Diamond</strong>;<br/>chartPSO.Series[maxSwarm].Color = Color.Black;<br/>chartPSO.Series[maxSwarm].MarkerSize = 20;</pre>
<p>And finally, to give our three-dimensional chart the most flexibility for use, we need to add the following toolbars:</p>
<pre>nChartControl2.Controller?.Tools?.Add(new NTrackballTool());<br/>nChartControl2.Controller?.Tools?.Add(new NZoomTool());<br/>nChartControl2.Controller?.Tools?.Add(new NOffsetTool());<br/>nChartControl2.Controller?.Tools?.Add(new NAxisScrollTool());<br/>NPanelSelectorTool selector = new NPanelSelectorTool();<br/>selector.Focus = true;<br/>nChartControl2.Controller.Tools.Add(selector);<br/>nChartControl2.Controller.Tools.Add(new NDataZoomTool());</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State initialization</h1>
                </header>
            
            <article>
                
<p>With the swarm and chart created and initialized, we now focus on initializing the state of the application itself. This means we are going to collect all the user-defined values and use them to initialize the hyperparameters themselves. We will delve into each in more detail in our chapter on hyperparameters, but for now you just need to be aware that they exist. Let's talk about each as it relates to state initialization.</p>
<p>First, we will determine the strategy we will use to initialize our function optimization. We will store this choice in a variable labeled <kbd>PSO_Type</kbd>. Our two choices of strategy are <kbd>Minimization</kbd> and <kbd>Maximization</kbd>. We determine the type like this:</p>
<pre>switch (combType.SelectedIndex)<br/>{<br/>case 0:<br/>PSO_Type = PSOType.<strong>Minimization</strong>;<br/>break;<br/>case 1:<br/>PSO_Type = PSOType.<strong>Maximization</strong>;<br/>break;<br/>}</pre>
<p>Next, we will initialize the number of dimensions, upper and lower bounds, and speed limits:</p>
<pre>dimSize = Convert.ToInt32(txtdimSize.Text);<br/>ub_domXi = Convert.ToDouble(txtUBXi.Text);<br/>lb_domXi = Convert.ToDouble(txtLBXi.Text);<br/>ub_SpeedXi = Convert.ToDouble(txtUbSpeedXi.Text);<br/>lb_SpeedXi = Convert.ToDouble(txtLbSpeedXi.Text);<br/>decP = Convert.ToInt32(txtdecP.Text);</pre>
<p>We continue with initializing our inertia, cognitive, and social intelligence weights:</p>
<pre>maxIter = Convert.ToInt32(txtmaxIter.Text);<br/>Intertia = Convert.ToDouble(txtW.Text);<br/>CognitiveWeight = Convert.ToDouble(txtC1.Text);<br/>SocialWeight = Convert.ToDouble(txtC2.Text);<br/>wMira = Convert.ToDouble(txtwMira.Text);</pre>
<p>One of our most critical hyperparameters relates to our swarm and its population size – how many particles will be in the swarm. Remember, even though we have not placed boundary checks in the source code itself, this value should ideally be a value between 5 and 40. I often use a value of 5 to start my testing. We determine the swarm size by looking at the value that the user entered like this:</p>
<pre>SwarmSize = Convert.ToInt32(txtSwarmSize.Text);<br/>Swarm = new Particle[SwarmSize];</pre>
<p>Finally, we initialize our global variables to track the maximum efficiency of the swarm:</p>
<pre>PlotSwarm = new double[maxIter, SwarmSize, 2];<br/>PlotGlobal = new double[maxIter, 2];</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling randomness</h1>
                </header>
            
            <article>
                
<p>As the initialize process continues, position, speed, and fitness are initialized in the Swarm Initialization section. Here's a brief look at how we do randomization. We start with each of those hyperparameters, and then randomize the values between the upper and lower bounds we stated in our hyperparameters:</p>
<pre>public double[] Swarm_Random(double a, double b, int n)<br/>{<br/>double[] x = new double[n];<br/>for (int <strong>i</strong> = 0; <strong>i</strong> &lt; n; <strong>i</strong>++)<br/>{<br/>x[<strong>i</strong>] = Swarm_Random(a, b);<br/>}<br/>return x;<br/>}<br/>public double Swarm_Round(double x) =&gt; decP != -1 ? Math.Round(x, decP) : x;<br/>public double Swarm_Random() =&gt; Swarm_Round(Randd.NextDouble());<br/>public double Swarm_Random(double a, double b)<br/>{<br/>Return (a + (b - a) * Swarm_Random());<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the swarm position</h1>
                </header>
            
            <article>
                
<p>The swarm position is the current position of the swarm relative to the global optimum – in this case, the hidden treasure. It is constrained within the upper and lower domain bounds as shown in the following. But remember, these two are hyperparameters entered in the same panel!:</p>
<pre>private double UpdateSwarmPosition(double Pos, double Speed)<br/>{<br/>double OutPos = Pos + Speed;<br/>return Math.Max(Math.Min(OutPos, upperBoundDomain), lowerBoundDomain);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the swarm speed</h1>
                </header>
            
            <article>
                
<p>The swarm speed is the speed at which the entire swarm heads towards the global optimum, that is, the hidden treasure. It is first calculated based upon the formula seen as follows, and then constrained within the upper and lower bound speed hyperparameter values. As you can see, we also apply various weights and randomization values to calculate and adjust the speed, like this:</p>
<pre>// Update Swarm Speed<br/>Swarm[<strong>i</strong>].Speed[<strong>j</strong>] = Inertia * Swarm[<strong>i</strong>].Speed[<strong>j</strong>] + CognitiveWeight * Swarm_Random() * (Swarm[<strong>i</strong>].BestPosition[<strong>j</strong>] - Swarm[<strong>i</strong>].Position[<strong>j</strong>]) + SocialWeight * Swarm_Random() * (GlobalBest.BestPosition[<strong>j</strong>] - Swarm[<strong>i</strong>].Position[<strong>j</strong>]);<br/>// Bound Speed<br/>Swarm[<strong>i</strong>].Speed[<strong>j</strong>] = UpdateSwarmSpeed(Swarm[<strong>i</strong>].Speed[<strong>j</strong>]);<br/>private double UpdateSwarmSpeed(double Speed)<br/>{<br/>return Math.Max(Math.Min(Speed, upperBoundSpeed), lowerBoundSpeed);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main program initialization</h1>
                </header>
            
            <article>
                
<p>When the main form initially loads, this is when our main initialization process begins. Let's walk through this method and talk about what exactly happens. In this method we are concerned with three-dimensional chart initialization.</p>
<p>First, we establish some general parameters for the chart:</p>
<pre>// setup chart general parameters<br/>NChart m_Chart = nChartControl2.Charts[0];<br/>m_Chart.Enable3D = true;<br/>m_Chart.Width = 60;<br/>m_Chart.Height = 25;<br/>m_Chart.Depth = 45;<br/>m_Chart.Projection.Type = ProjectionType.<strong>Perspective</strong><span>;<br/></span>m_Chart.Projection.Elevation = 28;<br/>m_Chart.Projection.Rotation = -17;<br/>m_Chart.LightModel.SetPredefinedLightModel(PredefinedLightModel.<strong>GlitterLeft</strong><span>);</span></pre>
<p>Next, we handle showing our interlaced strip on the back-left wall:</p>
<pre>// add interlaced stripe to the Y axis<br/>NScaleStripStyle stripStyle = new NScaleStripStyle(new NColorFillStyle(Color.Beige), null, true, 0, 0, 1, 1);<br/>stripStyle.SetShowAtWall(ChartWallType.<strong>Back</strong><span>, true);<br/></span>stripStyle.SetShowAtWall(ChartWallType.<strong>Left</strong><span>, true);<br/></span>stripStyle.Interlaced = true;<br/>((NStandardScaleConfigurator)m_Chart.Axis(StandardAxis.<strong>PrimaryY</strong><span>).ScaleConfigurator).StripStyles.Add(stripStyle);</span></pre>
<p>Finally, we handle showing our <em>x</em> axis gridlines like this:</p>
<pre>// show the X axis gridlines<br/>NOrdinalScaleConfigurator ordinalScale = m_Chart.Axis(StandardAxis.<strong>PrimaryX</strong><span>).ScaleConfigurator as NOrdinalScaleConfigurator;<br/></span>ordinalScale.MajorGridStyle.SetShowAtWall(ChartWallType.<strong>Back</strong><span>, true);<br/></span>ordinalScale.MajorGridStyle.SetShowAtWall(ChartWallType.<strong>Floor</strong><span>, true);</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running Particle Swarm Optimization</h1>
                </header>
            
            <article>
                
<p>With our main functions in place and everything initialized from our hyperparameters, we can now focus on being able to run higher level functions. One of our PSO functions is the <kbd>PSORun</kbd> method. This method is executed once the user clicks on the <strong>Run</strong> button <img class="alignnone size-full wp-image-1294 image-border" src="assets/366eaec3-5a3a-40c4-b358-f73338c16da5.png" style="width:3.33em;height:1.83em;"/>. Let's walk through this higher-level function now.</p>
<p>The first thing that we do is to initialize our state by calling our <kbd>InitState</kbd> function:</p>
<pre>InitState();</pre>
<p>After this we will clear out our information tree, create a new stopwatch responsible for timing our function, then run our <kbd>Swarm_Run</kbd> method. This will perform the actual function optimization behind the scenes, which usually will happen in just milliseconds depending upon the swarm size, iterations, and dimensions:</p>
<pre>advTree1.Nodes.Clear();<br/>SW = new Stopwatch();<br/>SW.Start();<br/>Swarm_Run();<br/>SW.Stop();</pre>
<p>Next, we create the variables responsible for tracking the global and individual positions of the entire swarm:</p>
<pre>plotSwarmPositions = (double[,,])PlotSwarm.Clone();<br/>plotGlobalPositions = (double[,])PlotGlobal.Clone();<br/>maxIter = plotSwarmPositions.GetLength(0);<br/>maxSwarm = plotSwarmPositions.GetLength(1);</pre>
<p>And finally, we initialize our charts, and play back the swarm's plot at a much slower pace so the end user can see what has transpired. We do this via a call to the three methods as follows:</p>
<pre>InitChart();<br/>InitializeMeshSurfaceChart();<br/>PlaybackPlot();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our user interface</h1>
                </header>
            
            <article>
                
<p>When we initially start our application, we have the proverbial blank slate. After initialization, we have completed the following items. Please note that the numbers relate to the screenshot showing the screen, shown as follows:</p>
<ul>
<li>Our parameters are initialized to the default values</li>
<li>Our three-dimensional chart is initialized to the default values and has no series data:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1295 image-border" src="assets/35b11939-5834-4c79-870b-166287b77a41.png" style="width:106.75em;height:65.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Blank 3D Chart</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Run button</h1>
                </header>
            
            <article>
                
<p>The run button executes the Particle Swarm Optimizer based upon the function and the strategy selected:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1296 image-border" src="assets/ce918769-844c-4710-801f-e5e34cc38514.png" style="width:3.75em;height:2.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rewind button</h1>
                </header>
            
            <article>
                
<p>The Rewind button completely rewinds a PSO plot to the beginning:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1297 image-border" src="assets/dc09e7cd-7384-4262-842f-d65c8961a217.png" style="width:3.33em;height:2.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Back button</h1>
                </header>
            
            <article>
                
<p>The Back button takes one step backward in the particle swarm optimization test run:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1298 image-border" src="assets/bddde3e5-68d8-4b7e-89ed-0a75a6ed1bc3.png" style="width:3.33em;height:2.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Play button</h1>
                </header>
            
            <article>
                
<p>The Play button replays a particle swarm optimization run from the beginning:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1299 image-border" src="assets/54050c94-424d-47b9-8876-88bf985e9df3.png" style="width:3.33em;height:2.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pause button</h1>
                </header>
            
            <article>
                
<p>The Pause button pauses a replay of a particle swarm optimization run:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1300 image-border" src="assets/73f9d717-3342-4c2a-8c5f-e55cc94ab5e8.png" style="width:3.25em;height:2.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Forward button</h1>
                </header>
            
            <article>
                
<p>The Forward button takes one step forward in the particle swarm optimization test run:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1301 image-border" src="assets/59c35c1a-236b-4860-a84b-8113a789b85a.png" style="width:2.83em;height:1.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hyperparameters and tuning</h1>
                </header>
            
            <article>
                
<p>Hyperparameters in general are parameters used for tuning various machine learning functions. This is no different in our application.</p>
<p>On the front screen of our application, the following is what our hyperparameter panel looks like. We will discuss each hyperparameter in detail:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e9f7006f-5d01-4754-8b6c-e7218c1f6a1e.png" style="width:16.00em;height:29.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Parameters</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Function</h1>
                </header>
            
            <article>
                
<p>This is a list of all available functions for optimization. Simply select the function you would like to use, set the strategy and other parameters, and click the <strong>Run</strong> button. Please see the function optimization reference for more detailed information about each function. There are over 50 different functions currently available at the time of writing, and we will cover in a later chapter how you can add many of your own, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1302 image-border" src="assets/06d8aac6-1d08-4c4c-9bf6-144ddbdbe355.png" style="width:11.25em;height:36.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Functions</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strategy</h1>
                </header>
            
            <article>
                
<p>There are two types of strategy one can apply to function optimization. You can either <em>maximize</em> or <em>minimize</em> your function optimization, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cacd44fa-51a2-4071-a715-245bc4057f54.png" style="width:16.58em;height:4.83em;"/></p>
<p>What do we mean by this? When we talk of maximizing or minimizing a function, what we mean is what the minimum or maximum value of that function can be. This is usually discussed in terms of either a <em>global range</em> or <em>local range</em>.</p>
<p>A global range would mean we want to determine the minimum or maximum value of the function over the whole range of input over which the function can be defined. This is commonly known as the domain of the function.</p>
<p>A local range, on the other hand, would mean we want to determine the minimum or maximum value of the function over the given local range, which will be a subset of the global range.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dim size</h1>
                </header>
            
            <article>
                
<p><span>Dimension size is used within the main loop (the final inner loop) to process the optimization for the function selected. 2 is the default value:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1464a482-8d72-41f9-90e6-d05fdc3772cd.png" style="width:18.25em;height:1.58em;"/></p>
<p>The relevant code is as follows:</p>
<pre>// Main Loop<br/>for (int <strong>iter</strong> = 1; <strong>iter</strong> &lt; maxIter; <strong>iter</strong>++)<br/>{<br/>for (int <strong>i</strong> = 0; <strong>i</strong> &lt; SwarmSize; <strong>i</strong>++)<br/>{<br/>for (int <strong>j</strong> = 0; <strong>j</strong> &lt; dimSize; <strong>j</strong>++)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Upper bound</h1>
                </header>
            
            <article>
                
<p>The upper bound is the upper limit of constraint which the swarm must adhere to. This is used to update the swarm position and to scale it within range. 10 is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f22b1902-19f1-4bcf-9dff-c1ed08803731.png" style="width:17.17em;height:1.58em;"/></p>
<p>Please note that, depending upon the function you are optimizing, the upper and lower bounds could be quite different from the default. Consult the reference guide for your function and see what the upper and lower constraints are:</p>
<pre>return Math.Max(Math.Min(OutPos, upperBoundDomain), lowerBoundDomain);</pre>
<p>Upper Bound = 10:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1303 image-border" src="assets/81242ff8-a8a8-4c0a-86e1-86943f8b0094.png" style="width:44.83em;height:13.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Upper Bound = 20:</p>
<p> </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7fcfbe87-aa33-4e04-bb23-758c9fa223ab.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lower bound</h1>
                </header>
            
            <article>
                
<p>This is the lower limit of constraint which the swarm must adhere to. This is used to update the swarm position and to scale it within range. -10 is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2f0b983-fc5b-4387-a0df-9529b159dc31.png" style="width:17.25em;height:1.75em;"/></p>
<p>The relevant code is as follows:</p>
<pre>return Math.Max(Math.Min(OutPos, upperBoundDomain), lowerBoundDomain);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Upper bound speed</h1>
                </header>
            
            <article>
                
<p>The upper bound speed is used to help determine the swarm speed. 10 is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/058bc8d8-438a-45ab-9f2d-7439095fb534.png" style="width:17.00em;height:1.67em;"/></p>
<p>The code is as follows:</p>
<pre>return Math.Max(Math.Min(Speed, upperBoundSpeed), lowerBoundSpeed);</pre>
<p>Upper Bound Speed = 10:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/08b29e94-bcfe-4f19-9c37-9048bc5c35ec.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Upper Bound Speed = 20:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e66d7cf3-498b-42d6-bc2a-141bf941f379.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lower bound speed</h1>
                </header>
            
            <article>
                
<p>The lower bound speed is used to help determine the swarm speed. <strong>-10</strong> is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1feab5d0-c808-4d8a-897d-fe8847ad25aa.png" style="width:15.58em;height:1.58em;"/></p>
<p>The code is as follows:</p>
<pre>return Math.Max(Math.Min(Speed, upperBoundSpeed), lowerBoundSpeed);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decimal places</h1>
                </header>
            
            <article>
                
<p>This is the total number of decimal places rounding occurs to. 5 is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9d053175-9ba6-4080-88c9-bf5e513a6f35.png" style="width:17.25em;height:1.75em;"/></p>
<p>The code is as follows:</p>
<pre>public double Swarm_Round(double x) =&gt; decimalPlaces != -1 ? Math.Round(x, decimalPlaces)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swarm size</h1>
                </header>
            
            <article>
                
<p>The total size of the swarm. This equates to the total number of particles available for optimization. There is a considerable amount of theory as to the appropriate number to use here. Remember, as we stated before, no free lunch! Generally, a value of 20-40 seems to be the most widely acceptable. 20 is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dda0a875-d56a-458e-9e8e-c5bd652b82f3.png" style="width:16.33em;height:1.58em;"/></p>
<p>The code is as follows:</p>
<pre>for (int <strong>i</strong> = 0; <strong>i</strong> &lt; SwarmSize; <strong>i</strong>++)</pre>
<p>Swarm Size = 10:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1308 image-border" src="assets/b862f6ff-512d-4541-ac02-be36b595cfa8.png" style="width:75.58em;height:22.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Swarm Size = 3:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b30141ee-b78e-4570-8b76-60cce9883f4e.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Max iterations</h1>
                </header>
            
            <article>
                
<p>The total number of iterations used for testing. 100 is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1b6973c4-15e6-4d80-a504-8d604529f802.png" style="width:15.08em;height:1.75em;"/></p>
<p>The code is as follows:</p>
<pre>for (int <strong>iter</strong> = 1; <strong>iter</strong> &lt; maxIter; <strong>iter</strong>++)</pre>
<p>Max Iterations = 100:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1311 image-border" src="assets/e717c141-9978-44a7-ae8c-5846317065e0.png" style="width:43.50em;height:12.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Max Iterations = 25:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1313 image-border" src="assets/bf12eea9-6fb7-4c33-8a8a-6dd807f916ad.png" style="width:76.08em;height:21.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inertia</h1>
                </header>
            
            <article>
                
<p>Inertia weight was initially introduced to balance optimization between the global and local search abilities. In our case, inertia is multiplied by the inertia weight to adjust the swarm speed. Generally, the accepted values range from 0.4 to 1 for this variable. 0.729 is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/73048129-cd53-45e7-b79d-5216229d392f.png" style="width:14.92em;height:1.67em;"/></p>
<p>The code is as follows:</p>
<pre>Swarm[<strong>i</strong>].Speed[<strong>j</strong>] = Inertia * Swarm[<strong>i</strong>].Speed[<strong>j</strong>]</pre>
<p>Inertia = 0.729:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1314 image-border" src="assets/e5b20d6d-23a3-485c-9c84-11e0a4387a51.png" style="width:75.67em;height:20.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Inertia = 0.4:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1315 image-border" src="assets/818ef43f-69e4-4f9b-9249-b2643cd689ec.png" style="width:75.08em;height:20.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Social weight</h1>
                </header>
            
            <article>
                
<p>Social weight is used to adjust the swarm speed. It is the factor that determines the extent to which the particle will follow the swarms' best solution. <strong>1.49445</strong> is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bfde6d77-883c-443f-b63f-35e3fb18473b.png" style="width:16.58em;height:1.67em;"/></p>
<p>The code is as follows:</p>
<pre>// Update Swarm Speed<br/>Swarm[<strong>i</strong>].Speed[<strong>j</strong>] = Intertia * Swarm[<strong>i</strong>].Speed[<strong>j</strong>]+ CognitiveWeight * Swarm_Random() * (Swarm[<strong>i</strong>].BestPosition[<strong>j</strong>] - Swarm[<strong>i</strong>].Position[<strong>j</strong>])+ SocialWeight * Swarm_Random() * (GlobalBest.BestPosition[<strong>j</strong>] - Swarm[<strong>i</strong>].Position[<strong>j</strong>]);</pre>
<p>Social Weight = 1.49445:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1316 image-border" src="assets/64167fb4-2449-400b-8904-beeb5d202b3b.png" style="width:75.42em;height:20.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Social Weight = 1.19445:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1317 image-border" src="assets/b93ee286-5a6b-4a8d-ab91-ea68550f94df.png" style="width:75.33em;height:20.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cognitive weight</h1>
                </header>
            
            <article>
                
<p>Cognitive weight is also used to adjust the swarm speed. It is the factor that determines the extent to which the particle will follow its own best solution. <strong>1.49445</strong> is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b632277a-a99d-4a40-b848-d44b0c272893.png" style="width:15.92em;height:1.75em;"/></p>
<p>The code is as follows:</p>
<pre><span>// Update Swarm Speed</span><br/>Swarm[<strong>i</strong>].Speed[<strong>j</strong>] = Intertia * Swarm[<strong>i</strong>].Speed[<strong>j</strong>] + CognitiveWeight * Swarm_Random() * (Swarm[<strong>i</strong>].BestPosition[<strong>j</strong>] - Swarm[<strong>i</strong>].Position[<strong>j</strong>])+ SocialWeight * Swarm_Random() * (GlobalBest.BestPosition[<strong>j</strong>] - Swarm[<strong>i</strong>].Position[<strong>j</strong>]);</pre>
<p>Cognitive Weight = 1.49445:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1318 image-border" src="assets/07bd0de0-54be-40f0-89ea-4c2f1037fc28.png" style="width:75.75em;height:20.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Cognitive Weight = 1.19445:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1319 image-border" src="assets/00a52014-dbec-4266-b792-d0e3743b2e56.png" style="width:46.25em;height:12.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inertia weight</h1>
                </header>
            
            <article>
                
<p>The inertia weight is multiplied by the inertia during each iteration of function optimization. <strong>0.99</strong> is the default value:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1321 image-border" src="assets/f4b52868-ccf5-4ac2-9697-32397edb56e7.png" style="width:19.92em;height:2.17em;"/></p>
<p>The code is as follows:</p>
<pre>Inertia *= InertiaWeight;</pre>
<p>Inertia Weight = 0.99:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1322 image-border" src="assets/0bb3b6e3-15ad-4bcc-856a-1ccaa038c1ae.png" style="width:75.42em;height:20.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>
<p>Inertia Weight = 0.75:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1323 image-border" src="assets/6574ac58-cfad-4f4c-a097-3543263e4fe4.png" style="width:76.42em;height:21.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Plot</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding visualizations</h1>
                </header>
            
            <article>
                
<p>In this section we will go over some of the many that you will see in our program. This includes both two and three dimensional plots.<br/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding two-dimensional visualizations</h1>
                </header>
            
            <article>
                
<p>For our application, we have several two-dimensional visualizations that we need to explain. The first is the two-dimensional plot of the function optimization, be it maximized or minimized. This visualization is shown as follows. Remember, for this we are using Microsoft Chart control, which is available from: <a href="https://www.microsoft.com/en-us/download/details.aspx?id=14422">https://www.microsoft.com/en-us/download/details.aspx?id=14422</a>:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img class="alignnone size-full wp-image-1324 image-border" src="assets/87685f4f-aeb3-4924-b4e2-f972cc48eb8a.png" style="width:56.00em;height:40.08em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">2D Visualization</div>
<p>For each particle that we are plotting (up to a maximum of 10), we will have a different marker style. A marker is the diamonds, circles, x's, and so on that you see plotted in the preceding diagram. We will also rotate colors based upon each particle being a different color. If you are not viewing this book in color, you hopefully will have shades of grey.</p>
<p>The lines you are seeing in the preceding diagram (or, to be more technically accurate, the splines you are seeing above them) are the plots of each particle in the swarm. The global optimum value (gbest) is the black diamond in the middle of the plot area. As you can see, we always remain within the bounds of our hyperparameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding three-dimensional visualizations</h1>
                </header>
            
            <article>
                
<p>In my opinion, the three-dimensional view is the easiest to interpret and the most intuitive, especially if it is a part of your model verification package that you will show to someone else. You can easily see in the following when each particle arrives (if it arrives) at a global optimum. The result is a flat line indicated by one or more line segments at the 0 axis:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1325 image-border" src="assets/788b27ad-8ffd-4ec1-bd9c-b3d377b9e9bc.png" style="width:78.00em;height:48.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D Visualization</div>
<p>There are several toolbars available for working with the three-dimensional view, of which you have rotational options, placement options, color options, and more:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1326 image-border" src="assets/3953198f-65d4-4cf9-a9fa-afc3ca24752c.png" style="width:60.00em;height:6.25em;"/></p>
<p>You can use the <strong>Trackball</strong> to rotate the chart to see the view from virtually any direction:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1327 image-border" src="assets/a64b8b6b-353c-40a4-8bb8-9ac3274bbebd.png" style="width:10.33em;height:6.33em;"/></p>
<p>Just select the Trackball, and then select the chart, click on the left mouse button and drag the chart to your new view like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1348 image-border" src="assets/07820860-528d-4834-897d-5b318d69b014.png" style="width:55.17em;height:32.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Rotating the View</div>
<p>You can change the lighting of the chart by changing the <strong>Predefined Light Model</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1349 image-border" src="assets/2dc1e107-6484-460b-afe8-3cab516afe88.png" style="width:15.50em;height:6.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Pre-defined Light Models</span></div>
<p>You can then select from any of the predefined models, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1350 image-border" src="assets/e5ea8878-b212-4641-a077-6177f4f10cc4.png" style="width:13.83em;height:29.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Pre-defined Light Models</div>
<p>The depth and width controls allow you to change both dimensions on the chart to suit your needs:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f6f91dd2-ac97-49a7-b575-86679e4e16ac.png" style="width:16.00em;height:6.58em;"/></p>
<p>Simply click on the button you desire and continue to click to apply the transformation, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1353 image-border" src="assets/63af16a4-b83e-4515-b090-784cd81227c6.png" style="width:40.42em;height:23.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Transformations</div>
<p><strong>Nudging</strong> allows you to make minor adjustments to the chart area and location. You can <strong>Nudge</strong> up, down, left, or right, as well as any combination of these, by simply clicking on the button(s) you desire, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1354 image-border" src="assets/823de99e-b81e-4c1d-b9b0-a26dd3369c3a.png" style="width:10.25em;height:5.75em;"/></p>
<p>In the main toolbar, you can open, save, and print charts, a valuable feature if you need to have images for a report based upon your testing. You can also use the Chart editor and Chart Wizard, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1355 image-border" src="assets/b43bf5b5-44ad-421c-a06d-f817bf476c3d.png" style="width:21.50em;height:6.08em;"/></p>
<p>Simply select the button you desire, in this case <strong>Show Chart Wizard</strong>, and the wizard dialog will appear:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1356 image-border" src="assets/e4c99515-66e5-40c1-88de-065b203c8165.png" style="width:82.75em;height:50.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Chart Wizard</div>
<p>You can also use the 3D button to switch between two and three-dimensional views of the same chart.</p>
<p>The two dimensional view:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1357 image-border" src="assets/aa2a936e-5955-48a3-a1d9-2f6ddb24457b.png" style="width:41.50em;height:19.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">2D View</div>
<p>This can change to 3D with the click of a single button:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1358 image-border" src="assets/a7098bcc-3403-444a-ad14-051806e91dfb.png" style="width:43.33em;height:20.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D View</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Plotting results</h1>
                </header>
            
            <article>
                
<p>The following section details how our information is displayed once results have been obtained.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Playing back results</h1>
                </header>
            
            <article>
                
<p>Once the swarm optimization is complete, the job of playing back the results comes to the forefront. Our main function in replaying plots is called <kbd>PlaybackPlot</kbd>. Let's discuss the function in detail:</p>
<pre>private void PlaybackPlot()<br/>{</pre>
<p>Get our current iteration, as follows:</p>
<pre>int iterN = GetCurrentIteration();<br/>_Closing = false;</pre>
<p>If we have played back all our points, then leave, as follows:</p>
<pre>if (iterN &gt;= maxIter)<br/>return;<br/>PlotStatusN = PlotStatus.<strong>Play</strong>;</pre>
<p>Update the progress bar, as follows:</p>
<pre>progressBarX1.Visible = true;<br/>progressBarX1.Minimum = 0;<br/>progressBarX1.Maximum = maxIter;</pre>
<p>Go through all iterations, as follows:</p>
<pre>for (int <strong>iter</strong> = iterN; <strong>iter</strong> &lt; maxIter; <strong>iter</strong>++)<br/>{</pre>
<p>Update the progress bar value, as follows:</p>
<pre>progressBarX1.Value = <strong>iter</strong>;<br/>if (_Closing)<br/>{<br/>_Closing = false;<br/>progressBarX1.Visible = false;<br/>return;<br/>}</pre>
<p>Plot a single swarm iteration point, as follows:</p>
<pre>PlotSwarmIterationPoint();</pre>
<p>Briefly pause to allow the UI to remain responsive, as follows:</p>
<pre>PauseForMilliSeconds(1);<br/>ShowTitle();<br/>}<br/>PlotStatusN = PlotStatus.<strong>Pause</strong>;<br/>progressBarX1.Visible = false;<br/>}</pre>
<p>You will notice in the preceding function a call to <kbd>PlotSwarmIterationPoint</kbd>. This function call (or method, if you prefer) is responsible for plotting a single movement of the particles. One step, if you will. Let's take you through that function and describe what is happening, as follows:</p>
<pre>private void PlotSwarmIterationPoint()<br/>{</pre>
<p>If we have reached our final iteration, then leave, as follows:</p>
<pre>int<strong>iterN</strong> = GetCurrentIteration();<br/>if (<strong>iterN</strong> &gt;= maxIter)<br/>return;<br/>NChart chart = nChartControl2.Charts[0];<br/>chart.Axis(StandardAxis.<strong>PrimaryX</strong>).ScaleConfigurator = new NLinearScaleConfigurator();</pre>
<p>We need to plot a single point for each particle in the swarm, as follows:</p>
<pre>for (int <strong>Swarm</strong> = 0; <strong>Swarm</strong> &lt; maxSwarm; <strong>Swarm</strong>++)<br/>{</pre>
<p>Add a series for each point, as follows:</p>
<pre>chartPSO.Series[<strong>Swarm</strong>].Points.AddXY(plotSwarmPositions[<strong>iterN</strong>, <strong>Swarm</strong>, 0], plotSwarmPositions[<strong>iterN</strong>, <strong>Swarm</strong>, 1]);</pre>
<p>Add a data point for the series we just created, as follows:</p>
<pre>NLineSeries m_Line1 = (NLineSeries)nChartControl2.Charts[0].Series[<strong>Swarm</strong>];<br/>m_Line1.AddDataPoint(new NDataPoint(plotSwarmPositions[<strong>iterN</strong>, <strong>Swarm</strong>, 0], plotSwarmPositions[<strong>iterN</strong>, <strong>Swarm</strong>, 1]));</pre>
<p>Dynamically handle the colors based upon the range values each particle is in, as follows:</p>
<pre>ApplyLineColorRanges(new NRange1DD[] { new NRange1DD(-10, -5), new NRange1DD(5, 10) },<br/>new Color[] { Color.Red, Color.Yellow }, m_Line1);<br/>}</pre>
<p>Now, add a point for the optimal global position, as follows:</p>
<pre>chartPSO.Series[maxSwarm].Points.Clear();<br/>chartPSO.Series[maxSwarm].Points.AddXY(plotGlobalPositions[<strong>iterN</strong>, 0], plotGlobalPositions[<strong>iterN</strong>, 1]);</pre>
<p>Get the next iteration in line, paint the control, and show the text for what is going on:</p>
<pre>iterN = Math.Min(<strong>iterN</strong> + 1, maxIter - 1);<br/>nChartControl2.Refresh();<br/>pictureBox1.Invalidate();<br/>ShowTitle();<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the information tree</h1>
                </header>
            
            <article>
                
<p>The information tree is on the <strong>Details</strong> tab page of our user interface. It houses the information treeview control. Depending upon the <kbd>PSODispType</kbd>, we will either create a new node or use the one previously created to write out our text:</p>
<pre>private void DisplayResult(PSODispType DispType, string Text)<br/>{<br/>switch (DispType)<br/>{</pre>
<p>Create a brand-new node in the tree. This is the highest level for a particle in the tree and represents the global best values found, as follows:</p>
<pre>case PSODispType.<strong>GlobalBest</strong>:<br/>Node n1 = new Node();<br/>n1.Text = Text;<br/>lastNode = advTree1.Nodes.Add(n1);<br/>break;</pre>
<p>Add details to the previous node. This is an individual particle in the swarm, and its sub details will be plotted in our next function, as follows:</p>
<pre>case PSODispType.<strong>Swarm</strong>:<br/>Node n2 = new Node();<br/>n2.Text = Text;<br/>advTree1?.Nodes?[lastNode]?.Nodes?.Add(n2);<br/>break;</pre>
<p>Add details to the previous node. These are the exact details of the particle, and form the bottom-level node for this particle in the swarm, as follows:</p>
<pre>case PSODispType.<strong>SwarmPosition</strong>:<br/>Node n = new Node();<br/>n.Text = Text;<br/>advTree1?.Nodes?[lastNode]?.Nodes?.Add(n);<br/>break;<br/>}<br/>}<br/><br/></pre>
<p>And that's it. We now have a fully populated information tree!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding new optimization functions</h1>
                </header>
            
            <article>
                
<p>One of the beautiful things about our visual test workbench is the ease of which we can add new optimization functions for testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The purpose of functions</h1>
                </header>
            
            <article>
                
<p>Some problems are evaluated in terms of quality versus correct or incorrect. Such problems are known as optimization problems because the goal is the identification of the optimal value. Functions (sometimes called cost functions, objective functions, error functions, and so on.) achieve that goal by mapping n-dimensional real-valued items into one-dimensional real-valued items (some folks will prefer the termspaces over items' as it more closely aligns with the total search space we have talked about).</p>
<p>There are two types of function we will deal with. They are:</p>
<ul>
<li><strong>Minimization</strong>: Looking for the solution with the smallest value</li>
<li><strong>Maximization</strong>: Looking for the solution with the largest value</li>
</ul>
<p>It is not always the case that we can find the minimum or maximum, but sometimes must settle on a value that we deem sufficiently good enough for what we are trying to accomplish.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding new functions</h1>
                </header>
            
            <article>
                
<p>Adding new functions is a very simple process comprised of only a few steps to follow. The steps are:</p>
<ol>
<li>Create a new function based upon the signatures shown as follows</li>
<li>Add the new function name to the <kbd>GetFitnessValue</kbd> function</li>
<li>Add the new function name to the user interface</li>
</ol>
<p>Let's now cover these steps on by one. First, we will deal with the function signature itself. The function signature is as follows:</p>
<pre>Public double <strong>xxxxxx</strong>(double[] data)<br/>{<br/>}</pre>
<p>Here, xxxxxx is the name of the function that will be displayed in the UI, as you can see in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1360 image-border" src="assets/664a9681-2b7d-4abe-a439-7fa0af2b2524.png" style="width:10.92em;height:12.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Optimization Function Window</div>
<p>After this, you must update the <kbd>GetFitnessValue</kbd> function so that it knows how to relate what is displayed on the user interface to an actual function. Here is a sample of what that function looks like. We will in fill this information later in the <em>Let's add a new function</em> section:</p>
<pre>internal double GetFitnessValue(double x, double y)<br/>{<br/>double[] data = new double[2];<br/>data[0] = x;<br/>data[1] = y;</pre>
<p>The <kbd>fitnessFunction</kbd> text is what appears in the user interface:</p>
<pre>if (fitnessFunction == "Sphere")<br/>return Swarm_Round(SphereFunction(data));<br/>else if (fitnessFunction == "FitnessTest")<br/>return Swarm_Round(FitnessTestFunction(data));<br/>else if (fitnessFunction == "MSphere")<br/>return Swarm_Round(MSphereFunction(data));<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Let's add a new function</h1>
                </header>
            
            <article>
                
<p>Now it's time for us to demonstrate how to add a new function. The function we are going to deal with is a modified version of the original <kbd>Levy</kbd> function and is the 13<sup>th</sup> version known to exist. This function is a minimization function.</p>
<p>The function itself, which you can find in the visual workbench source code, looks like this:</p>
<pre>public double LevyFunction13(double[] data)<br/>{<br/>double x1 = data[0];<br/>double x2 = data[1];<br/>double term1 = Math.Pow(Math.Sin(3 * Math.<strong>PI</strong> * x1), 2);<br/>double term2 = Math.Pow((x1 - 1), 2) * (1 + (Math.Pow(Math.Sin(3 * Math.<strong>PI</strong> * x2),<br/>2)));<br/>double term3 = Math.Pow((x2 - 1), 2) * (1 + (Math.Pow(Math.Sin(2 * Math.<strong>PI</strong> * x2), 2)));<br/>return term1 + term2 + term3;<br/>}</pre>
<p>Definitely a lot of math there, right? Many times, functions such as this would be created in editors that make the math much easier to view. For instance, if I were to represent this code mathematically, it would look like this:</p>
<pre><span class="mjx-char">f</span><span class="mjx-char">(</span><span class="mjx-char">x</span><span class="mjx-char">,</span><span class="mjx-char">y</span><span class="mjx-char">)=</span><span class="mjx-char">sin</span><span class="mjx-char">2</span><span class="mjx-char">(3</span><span class="mjx-char">πx</span><span class="mjx-char">)+(</span><span class="mjx-char">x</span><span class="mjx-char">−1)</span><span class="mjx-char">2</span><span class="mjx-char">(1+</span><span class="mjx-char">sin</span><span class="mjx-char">2</span><span class="mjx-char">(3</span><span class="mjx-char">πy</span><span class="mjx-char">))+(</span><span class="mjx-char">y</span><span class="mjx-char">−1)</span><span class="mjx-char">2</span><span class="mjx-char">(1+</span><span class="mjx-char">sin</span><span class="mjx-char">2</span><span class="mjx-char">(2</span><span class="mjx-char">πy</span><span class="mjx-char">))</span></pre>
<p>If we were to take that and plot it with a tool such as MATLAB, here's what it would look like graphically:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42e7ede3-45e2-4a5d-a2ff-c4b4424e281f.png" style="width:35.67em;height:27.00em;"/></p>
<p class="CDPAlignCenter CDPAlign">Our view under MATLAB</p>
<p>Why did I say and show all of that? Because, as you use this tool to validate your testing, you need to be able to relay, and sometimes justify, this information to others. No doubt just showing the C# code will not be enough, and the math and visualizations are many times what others expect to see. Don't let that put you off; you'll see how easy it is to create these functions, and our application makes it very easy to produce the kind of information you need.</p>
<p>Let's get back on track with adding that function.</p>
<p>Once we have added our new function, we now need to add it to the <kbd>GetFitnessValue</kbd> function so that what is selected in the user interface can relate to our specific function:</p>
<pre>else if (fitnessFunction == "Shubert")<br/>return Swarm_Round(ShubertFunction(data));<br/>else if (fitnessFunction == "Levy13")<br/>return Swarm_Round(LevyFunction13(data));</pre>
<p>Once this is complete, we need to add it to our dropdown function list box on the user interface. Just select the combo box on the user interface, go to the <span class="packt_screen">Items</span> property, and click on the button:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1361 image-border" src="assets/c0343899-78ed-4fc3-9251-8b194acf6865.png" style="width:16.67em;height:19.50em;"/></p>
<p>Next, simply add the text you want displayed, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1362 image-border" src="assets/e34ab8e6-a27f-40ab-9196-43902e75229d.png" style="width:34.42em;height:25.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">String Collection Editor</div>
<p>Once this is complete, build the project, run it, and you should see the function displayed in the dropdown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1363 image-border" src="assets/16f6292e-3643-4298-a51c-c2b208c1eb1b.png" style="width:16.67em;height:39.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">New Function</div>
<p>After you select the <span class="packt_screen">Levy13</span> function, click on the <strong>Run</strong> button and voilà, you've successfully added a new function and tested its execution. You can view the two and three-dimensional plots as a validation of your success. Before you reach your maximum number of iterations (100 in this case), you should have reached a global optimum of 0 (the flat tape segments on the right-hand side of the three-dimensional plot):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1364 image-border" src="assets/f6943263-95b1-4cf4-ae80-a031e9121240.png" style="width:55.75em;height:34.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">3D View</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed functions, what they are, and why we use them. We developed a very powerful and flexible application with which to test function optimization. We also showed you the complete process of adding a new function and how to run it once added. You are now free to add as many new functions as you like; just follow the process outlined herein and you should have no problems.</p>
<p>In the next chapter, we are going to learn how to replace back propagation with particle swarm-optimized algorithms, so hold on to your hats!</p>


            </article>

            
        </section>
    </body></html>