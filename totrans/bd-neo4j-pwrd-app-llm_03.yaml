- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building a Foundational Understanding of Knowledge Graph for Intelligent Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为智能应用建立知识图谱的基础理解
- en: In the previous chapter, we looked at what RAG is and at a few simple examples
    of how we can implement RAG flow, along with LLMs. In this chapter, we will take
    a look at what knowledge graphs are and how graphs can make **Retrieval-Augmented
    Generation** (**RAG**) more effective. We will explore how to model knowledge
    graphs and how Neo4j can be used for this purpose. We will look at how data modeling
    with the Neo4j data persistence approach can help build more powerful knowledge
    graphs. We will also look at data store persistence approaches, from **Relational
    Database Management Systems** (**RDBMSs**) to Neo4j knowledge graphs, to get a
    better understanding of data using various data models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了什么是RAG以及如何结合LLMs实现RAG流程的一些简单示例。在本章中，我们将探讨知识图谱是什么以及图如何使**检索增强生成**（**RAG**）更加有效。我们将探讨如何建模知识图谱以及Neo4j如何用于此目的。我们将探讨使用Neo4j数据持久化方法进行数据建模如何帮助构建更强大的知识图谱。我们还将探讨从**关系数据库管理系统**（**RDBMSs**）到Neo4j知识图谱的数据存储持久化方法，以更好地理解使用各种数据模型的数据。
- en: We will embark on an exciting journey to understand how the fusion of RAG models
    and Neo4j’s robust graph database capabilities enables the creation of intelligent
    applications that leverage structured knowledge bases for enhanced performance
    and results.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将踏上激动人心的旅程，了解RAG模型与Neo4j强大的图数据库功能的融合如何使创建利用结构化知识库以增强性能和结果的应用程序成为可能。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding the importance of graph data modeling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图数据建模的重要性
- en: Combining the power of RAG and Neo4j knowledge graphs with GraphRAG
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合RAG和Neo4j知识图谱的力量，使用GraphRAG
- en: Enhancing knowledge graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强知识图谱
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we dive into the practical aspects of building a knowledge graph for
    RAG integration with Neo4j, it is essential to set up the necessary tools and
    environments. Here are the technical requirements for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何为与Neo4j集成构建知识图谱的实际方面之前，设置必要的工具和环境是至关重要的。以下是本章的技术要求：
- en: '**Neo4j database**: You can use Neo4j Desktop for a local setup or Neo4j Aura
    for a cloud-based solution. Download Neo4j Desktop from the Neo4j download center:
    [https://neo4j.com/download/](https://neo4j.com/download/). For Neo4j Aura, visit
    Neo4j Aura: [https://neo4j.com/product/neo4j-graph-database/](https://neo4j.com/product/neo4j-graph-database/).
    Neo4j offers two primary cloud-based services – AuraDB and AuraDS:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j数据库**：您可以使用Neo4j Desktop进行本地设置或使用Neo4j Aura进行基于云的解决方案。从Neo4j下载中心下载Neo4j
    Desktop：[https://neo4j.com/download/](https://neo4j.com/download/)。对于Neo4j Aura，请访问Neo4j
    Aura：[https://neo4j.com/product/neo4j-graph-database/](https://neo4j.com/product/neo4j-graph-database/)。Neo4j提供两种主要的基于云的服务——AuraDB和AuraDS：'
- en: '**AuraDB** is a fully managed graph database service tailored for developers
    building intelligent applications. It supports flexible schemas, native storage
    of relationships, and efficient querying with the Cypher language. AuraDB offers
    a free tier, enabling users to explore graph data without incurring costs. Learn
    more about AuraDB at [https://neo4j.com/product/auradb/](https://neo4j.com/product/auradb/).'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AuraDB**是一个为构建智能应用程序的开发者量身定制的完全托管的图数据库服务。它支持灵活的模式、关系的原生存储以及使用Cypher语言的高效查询。AuraDB提供免费层，使用户能够在不产生成本的情况下探索图数据。在[https://neo4j.com/product/auradb/](https://neo4j.com/product/auradb/)了解更多关于AuraDB的信息。'
- en: '**AuraDS** is a fully managed Neo4j Graph Data Science instance that can be
    used to build data science applications. You can learn more about it at [https://neo4j.com/docs/aura/graph-analytics/](https://neo4j.com/docs/aura/graph-analytics/).'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AuraDS**是一个完全托管的Neo4j图数据科学实例，可用于构建数据科学应用程序。您可以在[https://neo4j.com/docs/aura/graph-analytics/](https://neo4j.com/docs/aura/graph-analytics/)了解更多信息。'
- en: '**DB Browser for SQLite**: This tool is used to query SQLite databases easily
    [https://sqlitebrowser.org/](https://sqlitebrowser.org/).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DB Browser for SQLite**：此工具用于轻松查询SQLite数据库。[https://sqlitebrowser.org/](https://sqlitebrowser.org/)。'
- en: '**Cypher query language**: Before starting with this chapter, you will need
    to familiarize yourself with Cypher, Neo4j’s query language. Neo4j provides excellent
    Cypher tutorials. If you are unfamiliar with Cypher, Neo4j provides excellent
    tutorials and fundamental courses on GraphAcademy ([https://graphacademy.neo4j.com/](https://graphacademy.neo4j.com/))
    to help you get started. You can also read this book to learn about Cypher in
    detail: Graph Data Processing with Cypher ([https://www.packtpub.com/en-us/product/graph-data-processing-with-cypher-9781804611074](https://www.packtpub.com/en-us/product/graph-data-processing-with-cypher-9781804611074)).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cypher查询语言**: 在开始本章之前，您需要熟悉Cypher，Neo4j的查询语言。Neo4j提供了优秀的Cypher教程。如果您不熟悉Cypher，Neo4j提供了优秀的教程和GraphAcademy的基本课程
    ([https://graphacademy.neo4j.com/](https://graphacademy.neo4j.com/))，以帮助您入门。您还可以阅读这本书来详细了解Cypher：Graph
    Data Processing with Cypher ([https://www.packtpub.com/en-us/product/graph-data-processing-with-cypher-9781804611074](https://www.packtpub.com/en-us/product/graph-data-processing-with-cypher-9781804611074)).'
- en: '**Python environment**: Python 3.8 or higher is recommended. Ensure you have
    it installed. You can download it from the official Python website [https://www.python.org/downloads/](https://www.python.org/downloads/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python环境**: 推荐使用Python 3.8或更高版本。请确保您已安装它。您可以从官方Python网站下载它 [https://www.python.org/downloads/](https://www.python.org/downloads/).'
- en: '**Neo4j Python Driver**: This allows you to interact with your Neo4j database
    from Python. Install it using `pip`:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j Python驱动程序**: 这允许您从Python与Neo4j数据库交互。使用`pip`安装它：'
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**GitHub repository**: All the code and resources for this chapter are available
    in the following GitHub repository: [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs).
    Navigate to the `ch3` folder for the specific content related to this chapter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub仓库**: 本章的所有代码和资源都可在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs)。导航到`ch3`文件夹以获取与本章相关的具体内容。'
- en: Ensure you have all these tools and libraries installed and configured before
    proceeding. This setup will enable you to follow along with the examples and exercises
    seamlessly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已安装并配置了所有这些工具和库。此设置将使您能够无缝地跟随示例和练习。
- en: Understanding the importance of graph data modeling
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图数据建模的重要性
- en: Before we go ahead with looking at how **GraphRAG flow** works with Neo4j, let
    us take a step back and understand how we can model knowledge graphs. We will
    take some simple data and try to look at how we model that data in RDBMSs and
    graphs. We will also see how this modeling differs depending on how we see that
    data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续查看GraphRAG流程如何与Neo4j协同工作之前，让我们退一步，了解我们如何建模知识图。我们将使用一些简单的数据，并尝试查看我们在RDBMS和图形中如何建模这些数据。我们还将看到这种建模如何根据我们看待数据的方式而有所不同。
- en: Graphs force us to think in different ways and see the data from different perspectives
    depending on what we are trying to solve. While this might seem like a problem,
    it is actually opens a lot of doors. For a long time, we have been taught to think
    of the RDBMS storage approach in terms of **Entity-Relationship** (**ER**) diagrams.
    This approach was good for representing/persisting data when there were limitations
    in the technology, and storage costs were very high. With technologies evolving
    and hardware becoming cheaper, new avenues have opened and new approaches to model
    data are possible. Graphs are well suited to take advantage of this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图形迫使我们以不同的方式思考，并从不同的角度看待数据，这取决于我们试图解决的问题。虽然这看起来可能像是一个问题，但实际上它实际上打开了许多大门。长期以来，我们一直被教导用**实体-关系**（**ER**）图来思考RDBMS存储方法。当技术有限制且存储成本非常高时，这种方法对于表示/持久化数据是好的。随着技术的进步和硬件的降价，新的途径已经打开，新的数据建模方法成为可能。图形非常适合利用这一点。
- en: To think about new ways of modeling data, we might have to unlearn some of the
    ways we are used to representing data using ER diagrams. While this seems simple,
    in reality, it might be a bit difficult. The learning and unlearning process is
    similar to in the neural plasticity prism goggles experiment, depicted in the
    following figure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑新的数据建模方式，我们可能不得不放弃一些我们习惯于使用ER图表示数据的方法。虽然这看起来很简单，但在现实中可能有点困难。学习和放弃的过程类似于以下图中描述的神经可塑性棱镜眼镜实验。
- en: '![Figure 3.1 — Neural plasticity prism goggles experiment](img/B31107_03_1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 — 神经可塑性棱镜眼镜实验](img/B31107_03_1.png)'
- en: Figure 3.1 — Neural plasticity prism goggles experiment
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 — 神经可塑性棱镜眼镜实验
- en: The experiment involves wearing prism goggles to perform a simple task. It takes
    some time for the mind to adjust to the shift in vision to perform the task correctly.
    When the participant takes off the goggles, it takes some time to be able to perform
    the same task again. It is the same with data modeling. We might have to unlearn
    a few of the approaches we used to rely on before we can build a better graph
    data model. You can read more about this experiment at [https://sfa.cems.umn.edu/neural-plasticity-prism-goggle-experiment](https://sfa.cems.umn.edu/neural-plasticity-prism-goggle-experiment).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验涉及佩戴棱镜眼镜执行一个简单的任务。大脑需要一段时间来调整视觉变化以正确完成任务。当参与者取下眼镜时，需要一段时间才能再次执行相同的任务。数据建模也是如此。我们可能需要放弃一些我们之前依赖的方法，才能构建更好的图数据模型。您可以在[https://sfa.cems.umn.edu/neural-plasticity-prism-goggle-experiment](https://sfa.cems.umn.edu/neural-plasticity-prism-goggle-experiment)上了解更多关于这个实验的信息。
- en: We will take a look at how we consume data in real life to understand whether
    there are any other approaches that can help us in building a good graph data
    model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究我们在现实生活中如何消费数据，以了解是否有其他方法可以帮助我们构建一个好的图数据模型。
- en: For example, let us consider a library or a bookstore to understand how our
    data or information consumption drives how the books are laid out. In a library,
    the books are laid out by category and last name of the author. This is similar
    to how we leverage indexes to find data. But there may be other sections at the
    entrance of the library that highlight new releases and popular books. This is
    done to make sure people can find these quickly. Trying to model these aspects
    in an RDBMS is difficult. But the graph database approach in Neo4j makes it quite
    easy to do this by leveraging multiple labels. This enables graph databases to
    help us build a data model that helps with the easy and efficient consumption
    of data. With graphs, we might have to try and change our thought process and
    try a few different data modeling approaches. Our initial approaches may not be
    completely correct, but we need to keep adjusting the data models to get to an
    acceptable data model that works for us. With RDBMSs and other technologies, the
    data model is rigid, and not getting it right can have a huge impact. This is
    where Neo4j stands out. Its optional flexible schema approach helps us get started
    with a data model that might not be optimal in the beginning, but we can tune
    it incrementally without needing to start from scratch.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个图书馆或书店来了解我们的数据或信息消费是如何驱动书籍布局的。在图书馆中，书籍是按照类别和作者姓氏排列的。这与我们利用索引查找数据的方式相似。但图书馆入口处可能还有其他区域突出显示新书和热门书籍。这样做是为了确保人们可以快速找到这些书籍。在关系型数据库管理系统（RDBMS）中尝试模拟这些方面是困难的。但Neo4j中的图数据库方法通过利用多个标签使这变得相当容易。这使得图数据库能够帮助我们构建一个有助于轻松高效消费数据的数据模型。使用图，我们可能需要尝试改变我们的思维方式，并尝试几种不同的数据建模方法。我们的初始方法可能并不完全正确，但我们需要不断调整数据模型，以达到一个对我们来说可接受的数据模型。在RDBMS和其他技术中，数据模型是固定的，如果做得不对，可能会产生巨大的影响。这正是Neo4j脱颖而出的地方。其可选的灵活模式方法帮助我们从一个可能最初并不理想的数据模型开始，但我们可以在不从头开始的情况下逐步调整它。
- en: 'We will take some small, simple data and look at data modeling with an RDBMS
    and graph. The data we will be trying to model looks as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些小型、简单的数据，并查看使用RDBMS和图进行的数据建模。我们将尝试建模的数据如下所示：
- en: 'A person with the following required details:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有以下必要细节的人：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Five rentals the person has lived at, in the following format:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下格式中的人居住过的五个租赁地址：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this seems simple, it is enough for us to understand the nuances of how
    this data can be represented in an RDBMS and graph.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来很简单，但它足以让我们理解如何在关系型数据库管理系统（RDBMS）和图中表示这些数据的细微差别。
- en: 'These are the questions we would like to answer using this data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们希望通过这些数据来回答的问题：
- en: What is the latest address the person named *John Doe* is living at?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约翰·多伊（John Doe）目前居住的最新地址是哪里？
- en: What is the first address the person named *John Doe* lived at?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约翰·多伊（John Doe）最初居住的地址是哪里？
- en: What is the third address the person named *John Doe* lived at?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约翰·多伊（John Doe）居住的第三个地址是哪里？
- en: Let’s take a look at how this data can be modeled in an RDBMS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些数据如何在关系型数据库管理系统（RDBMS）中建模。
- en: RDBMS data modeling
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统（RDBMS）数据建模
- en: 'In this section, we will take a look at the RDBMS data modeling aspects of
    the sample data we defined previously. The following figure represents the data
    model as an ER diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看先前定义的样本数据的 RDBMS 数据建模方面。以下图表示数据模型作为一个实体关系图：
- en: '![Figure 3.2 — ER diagram](img/B31107_03_2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 — 实体关系图](img/B31107_03_2.png)'
- en: Figure 3.2 — ER diagram
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 — 实体关系图
- en: There are three tables in this data model. The `Person` table contains the person
    details. The `Address` table contains the address details. The `Person_Address`
    table contains the rental details along with references to the `Person` and `Address`
    tables. We use this join table to represent the rental details, to avoid duplicating
    the data of `Person` or `Address` entities. We need to be extra sure of the details
    when we are building these data models, as changing them can be quite time-consuming,
    depending on how much we are changing. If we are splitting a table into multiple
    tables, then the data migration can be quite a task.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据模型中有三个表。`Person` 表包含个人详细信息。`Address` 表包含地址详细信息。`Person_Address` 表包含租赁详情，以及
    `Person` 和 `Address` 表的引用。我们使用这个连接表来表示租赁详情，以避免重复 `Person` 或 `Address` 实体的数据。在构建这些数据模型时，我们需要格外注意细节，因为更改它们可能相当耗时，具体取决于我们更改了多少。如果我们把一个表拆分成多个表，那么数据迁移可能是一项相当大的任务。
- en: 'You can use this tutorial to create the SQLite database: [https://datacarpentry.org/sql-socialsci/02-db-browser.html](https://datacarpentry.org/sql-socialsci/02-db-browser.html).
    We will use that SQLite database to load the data and validate queries to answer
    the questions we defined before.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此教程创建 SQLite 数据库：[https://datacarpentry.org/sql-socialsci/02-db-browser.html](https://datacarpentry.org/sql-socialsci/02-db-browser.html)。我们将使用该
    SQLite 数据库来加载数据并验证查询以回答我们之前定义的问题。
- en: 'The following SQL script creates the tables:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 脚本创建表：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next SQL script inserts the data into the tables:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 脚本将数据插入到表中：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once we load the data, it will look like this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了数据，它看起来会是这样。
- en: '![Figure 3.3 — Data stored in an RDBMS](img/B31107_03_3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 — RDBMS 中存储的数据](img/B31107_03_3.png)'
- en: Figure 3.3 — Data stored in an RDBMS
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 — RDBMS 中存储的数据
- en: 'We will now see how we can query data from the RDBMS:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何从 RDBMS 中查询数据：
- en: '**Query 1 – Get the latest address**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 1 – 获取最新地址**'
- en: 'Let’s take a look at the following SQL query to answer the first question:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下 SQL 查询以回答第一个问题：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the query, we can see that we are relying on the end column value to be
    null to determine which is the latest address. This is the logic to determine
    what the last address is in the SQL query.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从查询中，我们可以看到我们依赖于末列值为空来确定哪个是最新的地址。这是在 SQL 查询中确定最后一个地址的逻辑。
- en: '**Query 2****– Get the first address**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 2** – 获取第一个地址'
- en: 'We will take a look at the SQL query to answer the second question:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 SQL 查询以回答第二个问题：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the query, we can see that we are relying on the search-sort-filter pattern
    to get to the data we want, with the logic in the SQL query.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从查询中，我们可以看到我们依赖于搜索-排序-过滤模式来获取我们想要的数据，SQL 查询中的逻辑。
- en: '**Query 3 – Get the third address**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 3 – 获取第三个地址**'
- en: 'We will take a look at SQL query to answer the third question:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 SQL 查询以回答第三个问题：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, in this query also we can see that we are relying on the pattern *Search-Sort-Filter*
    to get to the data we wanted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这个查询中我们也可以看到我们依赖于搜索-排序-过滤模式来获取我们想要的数据。
- en: We will now look at how this data can be modeled with graphs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何使用图来建模这些数据。
- en: 'Graph data modeling: basic approach'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图数据建模：基本方法
- en: For illustration purposes, we will use the most common and simplest way to model
    this data in a graph.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我们将使用在图中建模此数据最常见和最简单的方法。
- en: '![Figure 3.4 — Basic graph data model](img/B31107_03_4.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 — 基本图数据模型](img/B31107_03_4.png)'
- en: Figure 3.4 — Basic graph data model
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 — 基本图数据模型
- en: 'This aligns with how we normally express the information in English:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们通常用英语表达信息的方式一致：
- en: '**Person** *lives at* **Address**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Person** *居住在* **Address**'
- en: In this sentence, the **nouns** are represented as **nodes**, and the **verb**
    is represented as a **relationship**. This data model approach is pretty simple
    and almost resembles the ER diagram of the RDBMS data model. The only difference
    here is that the join table that represents the rental is modeled as a relationship.
    The advantage of this type of data persistence is that it reduces the index lookup
    cost. In RDBMSs, the biggest cost in terms of data retrieval is the join table’s
    index lookup cost. As the data size increases, that lookup cost keeps on increasing.
    We can reduce that cost with this approach.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个句子中，**名词**被表示为**节点**，而**动词**被表示为**关系**。这种数据模型方法相当简单，几乎类似于RDBMS数据模型的ER图。这里唯一的区别是，表示租赁的连接表被建模为关系。这种类型的数据持久化的优点是它减少了索引查找成本。在RDBMS中，数据检索方面最大的成本是连接表的索引查找成本。随着数据量的增加，这种查找成本会持续增加。我们可以通过这种方法来减少这种成本。
- en: '**Note**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can use this tutorial to create the Neo4j database if you are using Neo4j
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Neo4j，你可以使用这个教程来创建Neo4j数据库。
- en: 'Desktop: [https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/](https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面：[https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/](https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/).
- en: 'Alternatively, you can use this tutorial to create a database in the cloud:
    [https://neo4j.com/docs/aura/auradb/getting-started/create-database/](https://neo4j.com/docs/aura/auradb/getting-started/create-database/).
    There is a free option available. This would be optimal for those who may not
    or do not want to install Neo4j Desktop locally. Neo4j Aura is a fully managed
    graph-database-as-a-service solution.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用这个教程在云中创建数据库：[https://neo4j.com/docs/aura/auradb/getting-started/create-database/](https://neo4j.com/docs/aura/auradb/getting-started/create-database/)。这里有一个免费选项可用。这对于可能不想或不需要在本地安装Neo4j
    Desktop的人来说可能是最佳选择。Neo4j Aura是一个完全管理的图数据库即服务解决方案。
- en: Let’s look at the following graph queries to understand this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图查询来理解这一点。
- en: 'The following Cypher script sets up the indexes for faster data load and retrieval.
    This can be thought of as a schema:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Cypher脚本设置了索引以加快数据加载和检索。这可以被视为一个模式：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This Cypher script creates two unique constraints to make sure we don’t have
    duplicate **Person** and **Address** nodes. We also added an index to speed up
    the person lookup using the name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Cypher脚本创建了两个唯一约束，以确保我们不会有两个重复的**Person**和**Address**节点。我们还添加了一个索引，以加快使用名称查找人员的速度。
- en: 'Once the schema is set up, we can use this Cypher script to load the data into
    Neo4j:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好模式，我们就可以使用这个Cypher脚本来将数据加载到Neo4j中：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once we load the data, it looks like this in the graph.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了数据，在图中看起来就像这样。
- en: '![Figure 3.5 — Representation of Person Rentals using graph data modeling,
    basic approach](img/B31107_03_5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 — 使用图数据建模表示人员租赁的基本方法](img/B31107_03_5.png)'
- en: Figure 3.5 — Representation of Person Rentals using graph data modeling, basic
    approach
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 — 使用图数据建模表示人员租赁的基本方法
- en: 'Now, we will create the Cypher queries analogous to the retrievals we performed  with
    the RDBMS queries in the previous section:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建与上一节中使用的RDBMS查询类似的Cypher查询：
- en: '**Query 1 – Get the latest address**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询1 – 获取最新地址**'
- en: 'The following Cypher query gets us the latest address:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Cypher查询获取我们最新的地址：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we look at this query, it is much simpler than the SQL query we saw earlier.
    Still, the result depends on how we mark the last address, by not having the `end`
    property set on the relationship. So, the logic to know what the last address
    is still part of the query, like in the SQL query. We can see that we are checking
    the values in the relationship and trying to use indexes, as shown in the following
    code, on the join table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个查询，它比我们之前看到的SQL查询要简单得多。然而，结果取决于我们如何标记最后一个地址，即不设置关系的`end`属性。因此，确定最后一个地址的逻辑仍然是查询的一部分，就像在SQL查询中一样。我们可以看到，我们在检查关系中的值，并尝试在连接表上使用索引，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just avoiding these indexes itself can get us better performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 仅避免这些索引本身就可以获得更好的性能。
- en: '**Query 2 – Get the first address**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询2 – 获取第一个地址**'
- en: 'This Cypher fetches us the first address:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Cypher查询为我们获取了第一个地址：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the query, we can see that we are relying on the search-sort-filter pattern
    to get to the data we want, similar to the SQL query. The logic to determine what
    the first address is part of the Cypher query.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从查询中，我们可以看到我们依赖于搜索-排序-过滤模式来获取我们想要的数据，类似于SQL查询。确定第一个地址的逻辑是Cypher查询的一部分。
- en: '**Query 3 – Get the third address**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 3 – 获取第三个地址**'
- en: 'This Cypher gets us the third address:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Cypher 查询为我们获取第三个地址：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similar to the previous query, we had to rely on search-sort-filter to get to
    the data we wanted. The logic to determine what the third address is part of the
    Cypher query.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的查询类似，我们必须依赖搜索排序过滤来获取我们想要的数据。确定第三个地址的逻辑是 Cypher 查询的一部分。
- en: Next, we will dive into a more nuanced approach to graph data modeling.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨图形数据建模的更细致的方法。
- en: 'Graph data modeling: advanced approach'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形数据建模：高级方法
- en: We will look at this data differently and build a data model. This model is
    influenced by how we consume the data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用不同的方式查看这些数据并构建一个数据模型。这个模型受我们如何消费数据的影响。
- en: '![Figure 3.6 — Representation of Person Rentals using graph data modeling,
    consumption approach](img/B31107_03_6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 — 使用图形数据建模表示 Person Rentals 的消费方法](img/B31107_03_6.png)'
- en: Figure 3.6 — Representation of Person Rentals using graph data modeling, consumption
    approach
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 — 使用图形数据建模表示 Person Rentals，消费方法
- en: At first look, this looks closer to the RDBMS ER diagram. We have **Person**,
    **Address**, and **Rental** nodes. That’s where the similarity ends. We can see
    that **Person** is connected to the **Rental** node via a **FIRST** or **LATEST**
    relationship. **Rental** may have a **NEXT** relationship to another **Rental**
    node. The **Rental** node is connected to an **Address**, too. The model might
    look a bit complex. Once we load the data and see how it is connected, it makes
    more sense.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎更接近 RDBMS ER 图。我们有 **Person**、**Address** 和 **Rental** 节点。但相似之处到此为止。我们可以看到
    **Person** 通过一个 **FIRST** 或 **LATEST** 关系与 **Rental** 节点连接。**Rental** 可能与另一个 **Rental**
    节点有一个 **NEXT** 关系。**Rental** 节点也连接到一个 **Address**。模型可能看起来有点复杂。一旦我们加载数据并看到它是如何连接的，它就更有意义了。
- en: 'This Cypher script sets up the indexes for faster data load and retrieval:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Cypher 脚本设置了索引以加快数据加载和检索：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see the indexes are the same as in the previous model. We have not added
    any indexes or constraints to the **Rental** node.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到索引与之前的模型相同。我们没有为 **Rental** 节点添加任何索引或约束。
- en: 'This Cypher script loads the data into Neo4j:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Cypher 脚本将数据加载到 Neo4j 中：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once the data is loaded, it will look like this in the graph (*Figure 3.7*).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载后，在图中将看起来像这样（*图 3.7*）。
- en: '![Figure 3.7 — Representation of Person Rentals with a Rental sequence graph](img/B31107_03_7.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 — 使用图形数据建模表示 Person Rentals 的租赁序列图](img/B31107_03_7.png)'
- en: Figure 3.7 — Representation of Person Rentals with a Rental sequence graph
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 — 使用图形数据建模表示 Person Rentals 的租赁序列图
- en: 'We can see that the data stored in the graph is way different from before.
    **Person** is connected to only the first and last rentals. Each of those rentals
    from first to last is connected via a **NEXT** relationship:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，存储在图中的数据与之前大不相同。**Person** 只与第一个和最后一个租赁相关联。从第一个到最后的每个租赁都通过一个 **NEXT**
    关系连接：
- en: '**Query 1 – Get the latest address**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 1 – 获取最新地址**'
- en: 'This Cypher query gets us the latest address:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Cypher 查询为我们获取最新的地址：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that this query is very different from the previous graph and SQL
    queries. In the previous graph model, the Cypher query was similar to the SQL
    query in determining what the last address is. Here, the query looks similar to
    a sentence in English (*Person’s latest address*).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个查询与之前的图形和 SQL 查询非常不同。在之前的图形模型中，Cypher 查询在确定最后一个地址方面与 SQL 查询相似。在这里，查询看起来类似于一句英文（*Person’s
    latest address*）。
- en: While the query looks simpler and easier to understand for most people, is it
    worth representing the data in this way? In this scenario, we will use more storage
    to be able to represent data in an elaborate manner. Let’s profile the queries
    from the initial graph data model to this data model and see whether there is
    any advantage.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查询看起来对大多数人来说更简单、更容易理解，但这种表示数据的方式值得吗？在这种情况下，我们将使用更多的存储空间来以更详细的方式表示数据。让我们分析从初始图形数据模型到这个数据模型的查询，看看是否有任何优势。
- en: '![Figure 3.8 — Basic graph model versus advanced graph model – query 1 profiles](img/B31107_03_8.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 — 基本图形模型与高级图形模型 – 查询 1 分析](img/B31107_03_8.png)'
- en: Figure 3.8 — Basic graph model versus advanced graph model – query 1 profiles
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 — 基本图形模型与高级图形模型 – 查询 1 分析
- en: From the **query profiles**, we can see the initial graph data model took 18
    **db hits** (accesses) and 312 bytes of memory to perform the operation. The current
    graph data model took 12 db hits and 312 bytes of memory to perform the operation.
    We can see the new data model is able to perform this query more optimally. As
    the data grows, the previous graph data model will take more time to perform the
    operation and the db hits will grow linearly with the number of relationships
    the person has. With the current data model, it would stay relatively constant.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **查询配置文件** 中，我们可以看到初始图数据模型执行操作需要 18 **数据库访问**（访问）和 312 字节的内存。当前图数据模型执行操作需要
    12 次数据库访问和 312 字节的内存。我们可以看到，新的数据模型能够更优化地执行这个查询。随着数据量的增长，之前的图数据模型将需要更多的时间来执行操作，数据库访问次数将与该人拥有的关系数量线性增长。使用当前数据模型，它将保持相对稳定。
- en: Now let us look at query 2.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看查询 2。
- en: '**Query 2 – Get the first address**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 2 – 获取第一个地址**'
- en: 'This Cypher query gets us to the first address:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Cypher 查询获取我们到第一个地址：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that this query looks exactly like the previous one, except for the
    relationship we are traversing. We are not using the *search-sort-filter* pattern
    anymore here. This is the biggest advantage of this data model. This model also
    makes it easy for us to use a graph as a structure to retrieve the data. Also,
    it means the logic to determine what data we are looking at is not coded into
    the query in the form of some property comparisons. Let us compare the query profiles
    to see whether this gives us any advantage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个查询与上一个查询几乎完全相同，只是我们遍历的关系不同。我们不再使用 *search-sort-filter* 模式。这是这种数据模型的最大优势。这种模型还使我们能够轻松地将图用作结构来检索数据。这也意味着确定我们正在查看的数据的逻辑并没有以某些属性比较的形式编码到查询中。让我们比较查询配置文件，看看这是否给我们带来任何优势。
- en: '![Figure 3.9 — Basic graph model versus advanced graph model – query 2 profiles](img/B31107_03_9.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 — 基本图模型与高级图模型对比 – 查询 2 配置文件](img/B31107_03_9.png)'
- en: Figure 3.9 — Basic graph model versus advanced graph model – query 2 profiles
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 — 基本图模型与高级图模型对比 – 查询 2 配置文件
- en: We can see the query execution plan for the initial graph data model is larger
    and more complex than the current data model. With the initial graph data model,
    it took 19 db hits and 1,020 bytes of memory to perform the operation. With the
    current data model, the plan is almost similar to query 1\. It took 12 db hits
    and 312 bytes of memory. We can see that the ordering is causing us to use more
    memory and will consume more CPU cycles. As **Person** is connected to more addresses,
    the initial graph data model will take more memory and db hits as performance
    will slowly degrade. With the current data model, the performance will remain
    relatively constant.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对于初始图数据模型，查询执行计划比当前数据模型更大、更复杂。使用初始图数据模型，执行操作需要 19 次数据库访问和 1,020 字节的内存。使用当前数据模型，计划几乎与查询
    1 相似。执行操作需要 12 次数据库访问和 312 字节的内存。我们可以看到，排序导致我们使用了更多的内存，并将消耗更多的 CPU 周期。随着**Person**与更多地址的连接，初始图数据模型将需要更多的内存和数据库访问，性能将逐渐下降。使用当前数据模型，性能将保持相对稳定。
- en: '**Query 3 – Get the third address**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 3 – 获取第三个地址**'
- en: 'This Cypher query gets us the third address:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Cypher 查询获取第三个地址：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see from the query that the way it is written is to traverse to the first
    rental and skip the next rental to get to the third rental. This is how we normally
    look at data and it feels natural to express the query this way to retrieve the
    data. Again, we are not relying on the *search-sort-filter* pattern. Let us compare
    the query profiles to see whether this gives us any advantage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从查询中看到，它的编写方式是遍历到第一个租赁，跳过下一个租赁以到达第三个租赁。这是我们通常查看数据的方式，并以这种方式检索数据感觉自然。同样，我们不再依赖于
    *search-sort-filter* 模式。让我们比较查询配置文件，看看这是否给我们带来任何优势。
- en: '![Figure 3.10 — Basic graph model versus advanced graph model – query 3 profiles](img/B31107_03_10.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 — 基本图模型与高级图模型对比 – 查询 3 配置文件](img/B31107_03_10.png)'
- en: Figure 3.10 — Basic graph model versus advanced graph model – query 3 profiles
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 — 基本图模型与高级图模型对比 – 查询 3 配置文件
- en: We can see from these profiles that the current data model query profile is
    a bit more involved than the previous queries. The initial graph data model took
    19 db hits and 1,028 bytes to perform the operation. The current graph data model
    took 16 db hits and 336 bytes to perform the operation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些配置文件中，我们可以看到当前数据模型查询配置文件比之前的查询要复杂一些。初始图数据模型执行操作需要 19 次数据库访问和 1,028 字节。当前图数据模型执行操作需要
    16 次数据库访问和 336 字节。
- en: '**Note**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Query profiling** is the best way to understand how the query works.  If
    we are not happy with the query performance, profiling helps us understand which
    areas of the query execution we want to improve or change for better performance.
    You can read more about this at [https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/](https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询分析**是了解查询工作原理的最佳方式。如果我们对查询性能不满意，分析可以帮助我们了解哪些查询执行区域需要改进或更改以提高性能。你可以在 [https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/](https://neo4j.com/docs/cypher-manual/current/planning-and-tuning/)
    上了解更多相关信息。'
- en: From analyzing the queries and data models, we can see that taking a fresher
    look at how the data models are defined can have a huge impact in terms of performance
    and cost to perform the same operations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析查询和数据模型，我们可以看到，重新审视数据模型的定义可以在性能和执行相同操作的成本方面产生巨大影响。
- en: Another advantage of the current data model is that if we do want to track how
    the rentals are working from an address perspective, we can add just another relationship,
    say, **NEXT_RENTAL**, between the rentals for the same address. This would give
    us a different perspective of the same data. Trying to represent the data like
    this in an RDBMS or other data persistence layers would be difficult. This is
    where Neo4j with its flexibility to be able to persist relationships to avoid
    the join index cost and optional schema is better suited to build knowledge graphs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当前数据模型的另一个优点是，如果我们确实想从地址的角度跟踪租赁情况，我们可以在同一地址的租赁之间添加另一个关系，比如说 **NEXT_RENTAL**。这将为我们提供同一数据的另一种视角。在
    RDBMS 或其他数据持久化层中尝试以这种方式表示数据将是困难的。这正是 Neo4j 的优势所在，它具有灵活性，能够持久化关系以避免连接索引成本和可选模式，这使得它更适合构建知识图谱。
- en: A good graph data model makes the **retriever in RAG flow** more effective.
    It makes retrieving relevant data faster and easier, as we have explored here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的图数据模型可以使 RAG 流中的 **检索器** 更有效。它使得检索相关数据更快、更简单，正如我们在这里所探讨的。
- en: We will take a look at how we can use knowledge graphs as part of RAG flow next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何将知识图谱作为 RAG 流的一部分来使用。
- en: Combining the power of RAG and Neo4j knowledge graphs with GraphRAG
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RAG 和 Neo4j 知识图谱的强大功能结合到 GraphRAG 中
- en: In the previous chapter, we looked at the **retriever**, which is the heart
    of RAG flows. The retriever leverages data stores to retrieve relevant information
    to provide to LLMs to get the best response to our question. Retrievers can work
    with various data stores as needed. The data store capabilities can greatly determine
    how useful, quick, and effective the information retrieved is. This is where graphs
    play a great role. That’s how **GraphRAG** came into being.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 **检索器**，它是 RAG 流的核心。检索器利用数据存储来检索相关信息，以提供给 LLM 以获得对我们问题的最佳回答。检索器可以根据需要与各种数据存储一起工作。数据存储功能可以极大地决定检索到的信息的有用性、速度和有效性。这正是图发挥重要作用的地方。这就是
    **GraphRAG** 产生的原因。
- en: '**Note**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can read more about GraphRAG and how it is effective at [https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/](https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/)
    and [https://microsoft.github.io/graphrag/](https://microsoft.github.io/graphrag/).
    For a comprehensive understanding of GraphRAG, you can refer to Microsoft’s research
    paper titled *From Local to Global: A Graph RAG Approach to Query-Focused Summarization*
    ([https://arxiv.org/abs/2404.16130](https://arxiv.org/abs/2404.16130)). Additionally,
    Microsoft has made the GraphRAG project available on GitHub ([https://github.com/microsoft/graphrag](https://github.com/microsoft/graphrag)),
    providing resources and tools for implementing this approach.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/](https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/)
    和 [https://microsoft.github.io/graphrag/](https://microsoft.github.io/graphrag/)
    上了解更多关于 GraphRAG 及其如何有效利用的信息。为了全面了解 GraphRAG，你可以参考微软的研究论文《从局部到全局：基于图 RAG 的查询聚焦摘要方法》([https://arxiv.org/abs/2404.16130](https://arxiv.org/abs/2404.16130))。此外，微软已在
    GitHub 上发布了 GraphRAG 项目([https://github.com/microsoft/graphrag](https://github.com/microsoft/graphrag))，提供了实施此方法所需资源和工具。
- en: The Neo4j graph database excels at persisting the data as a property graph with
    nodes and relationships. This makes it easy to store and retrieve data in an intuitive
    manner and serves the data stores for RAG retrievers. This approach allows for
    more accurate, contextually aware, and reliable AI-driven applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 图数据库擅长以属性图的形式持久化数据，其中包含节点和关系。这使得以直观的方式存储和检索数据变得容易，并为 RAG 检索器提供数据存储。这种方法允许实现更准确、上下文感知和可靠的
    AI 驱动应用程序。
- en: We will now build a GraphRAG flow that combines the power of RAG and knowledge
    graphs for improved LLM responses.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建一个 GraphRAG 流程，结合 RAG 和知识图谱的力量以改善 LLM 响应。
- en: 'GraphRAG: enhancing RAG models with Neo4j'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphRAG：通过 Neo4j 增强RAG模型
- en: In the previous chapter, we discussed the flow of information in a chat application
    with a RAG model (refer to *Figure 3.5*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了具有 RAG 模型的聊天应用中的信息流（参见图 3.5）。
- en: Now we will see how this workflow can be augmented to generate improved responses
    for the chat application. *Figure 3.11* shows the workflow of GraphRAG, where
    a user’s prompt is processed through an LLM API, retrieving relevant information
    from Neo4j, and then combined with the prompt before being sent to an LLM API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何增强此工作流程以生成改进的聊天应用响应。*图 3.11* 展示了 GraphRAG 的工作流程，其中用户的提示通过 LLM API
    处理，从 Neo4j 中检索相关信息，然后与提示结合在一起，再发送到 LLM API。
- en: '![Figure 3.11 — Workflow of GraphRAG](img/B31107_03_11.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 — GraphRAG 的工作流程](img/B31107_03_11.png)'
- en: Figure 3.11 — Workflow of GraphRAG
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 — GraphRAG 的工作流程
- en: The LLM API generates a response using both the prompt and the relevant information
    from the Neo4j knowledge graph, providing the user with accurate and contextually
    enriched results. By combining the capabilities of Neo4j and RAG models, GraphRAG
    enhances relevance with more domain context.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: LLM API 使用提示和来自 Neo4j 知识图谱的相关信息生成响应，为用户提供准确且上下文丰富的结果。通过结合 Neo4j 和 RAG 模型的功能，GraphRAG
    通过更多的领域上下文增强了相关性。
- en: Let us build a simple graph to showcase this GraphRAG flow.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的图来展示这个 GraphRAG 流程。
- en: Building a knowledge graph for RAG integration
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 RAG 集成构建知识图谱
- en: For this example, we will use limited data for demonstration purposes to build
    the graph, focusing on movies and their plots.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们将使用有限的数据进行演示，以构建图，重点关注电影及其剧情。
- en: 'Python code example: Setting up a knowledge graph in Neo4j'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 代码示例：在 Neo4j 中设置知识图谱
- en: 'By following along with the provided code example, you will learn how to set
    up a Neo4j database, define nodes and relationships, and perform basic queries
    using Cypher:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过跟随提供的代码示例，您将学习如何设置 Neo4j 数据库，定义节点和关系，并使用 Cypher 执行基本查询：
- en: '**Set up the Neo4j database**: Before running the code, ensure you have access
    to a Neo4j database. You can use either of the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置 Neo4j 数据库**：在运行代码之前，请确保您有权访问 Neo4j 数据库。您可以使用以下任一选项：'
- en: '**Neo4j Desktop**: Install and run it locally (download Neo4j Desktop: [https://neo4j.com/download/](https://neo4j.com/download/))'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j Desktop**：本地安装并运行它（下载 Neo4j Desktop：[https://neo4j.com/download/](https://neo4j.com/download/))'
- en: '**Neo4j AuraDB**: This is a cloud-hosted option (learn more about AuraDB at
    [https://neo4j.com/product/auradb/](https://neo4j.com/product/auradb/))'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j AuraDB**：这是一个云托管选项（了解更多关于 AuraDB 的信息：[https://neo4j.com/product/auradb/](https://neo4j.com/product/auradb/))'
- en: Start your database instance and note the connection credentials (e.g., URI,
    username, and password).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的数据库实例并记录连接凭据（例如，URI、用户名和密码）。
- en: '**Install the necessary Python libraries**: You will need the following Python
    libraries:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装必要的 Python 库**：您需要以下 Python 库：'
- en: '**Neo4j Python Driver**: To interact with the database'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j Python 驱动程序**：用于与数据库交互'
- en: '**Pandas**: For handling data structures and analysis'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pandas**：用于处理数据结构和分析'
- en: 'Install these libraries using the following command:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令安装这些库：
- en: '[PRE19]'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Connect to the database and set up the knowledge graph**: Once your Neo4j
    database is running and the required Python libraries are installed, you can use
    the following Python script to set up a simple knowledge graph. In this example,
    we will create a graph for IMDb movies and their plots, with nodes representing
    movies and plots and relationships indicating which plot belongs to which movie.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接到数据库并设置知识图谱**：一旦您的 Neo4j 数据库运行并且已安装所需的 Python 库，您可以使用以下 Python 脚本设置一个简单的知识图谱。在此示例中，我们将创建一个包含电影及其剧情的图，节点代表电影和剧情，关系表示哪个剧情属于哪部电影。'
- en: '**Note**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: We will not be using any external dataset, rather, we will be using a hardcoded
    data set to showcase the graph model and the GraphRAG flow. We will be exploring
    full-fledged data loading and the GraphRAG flow in *Chapters 4* and *5*. This
    example is to showcase the GraphRAG flow aspects only.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会使用任何外部数据集，而是将使用硬编码的数据集来展示图模型和GraphRAG流程。我们将在第4章和第5章中探索完整的数据加载和GraphRAG流程。此示例仅用于展示GraphRAG流程的方面。
- en: 'We will first build a simple graph. We will be using this simple graph to showcase
    where and how Neo4j fits in the GraphRAG flow:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建一个简单的图。我们将使用这个简单的图来展示Neo4j在GraphRAG流程中的位置和作用：
- en: 'Import the `GraphDatabase` library and define Neo4j connectivity and credentials:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`GraphDatabase`库并定义Neo4j连接性和凭证：
- en: '[PRE20]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let us create a few nodes:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些节点：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to create relationships:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建关系：
- en: '[PRE22]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we visualize the data that we created, it would look as shown in *Figure
    3.12*:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们可视化我们创建的数据，它将看起来如图3.12所示：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 3.12 — Sample graph showing movies and plots](img/B31107_03_12.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 — 显示电影和剧情的示例图](img/B31107_03_12.png)'
- en: Figure 3.12 — Sample graph showing movies and plots
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 — 显示电影和剧情的示例图
- en: '5\. We will now retrieve the data using a Cypher query:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 我们现在将使用Cypher查询检索数据：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '6\. If we run this, we can see the output as shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 如果我们运行它，我们可以看到如下所示的输出：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can find the complete code at [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/imdb_kg.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/imdb_kg.py).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/imdb_kg.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/imdb_kg.py)找到完整的代码。
- en: Now that we have built the basic graph, let us use it in the GraphRAG flow.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了基本的图，让我们在GraphRAG流程中使用它。
- en: Integrating RAG with your Neo4j knowledge graph
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将RAG与Neo4j知识图谱集成
- en: To integrate RAG models with Neo4j, you need to configure the models to query
    the graph database. This typically involves setting up an API or a middleware
    layer that facilitates communication between the RAG models and Neo4j.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要将RAG模型与Neo4j集成，您需要配置模型以查询图数据库。这通常涉及设置一个API或中间件层，以促进RAG模型和Neo4j之间的通信。
- en: 'An example integration workflow is provided here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个示例集成工作流程：
- en: '**User input:** The user provides a prompt. In the following code example,
    the prompt is predefined in the script as an example (`"The Matrix"`). Users can
    modify this to test other movies or prompts:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户输入**：用户提供一个提示。在以下代码示例中，提示信息在脚本中预定义作为示例（`"The Matrix"`）。用户可以修改它以测试其他电影或提示：'
- en: '[PRE26]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Query generation**: The prompt is processed, and a Cypher query is generated
    to retrieve relevant information from Neo4j. For example, the query might fetch
    the plot of the movie mentioned in the prompt:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查询生成**：提示信息被处理，并生成一个Cypher查询以从Neo4j中检索相关信息。例如，查询可能会获取提示中提到的电影的剧情：'
- en: '[PRE27]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Data retrieval**: The Cypher query is executed, and the relevant data (e.g.,
    the plot of *The Matrix*) is fetched from the knowledge graph:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据检索**：执行Cypher查询，并从知识图谱中获取相关数据（例如，《黑客帝国》的剧情）：'
- en: '[PRE28]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**RAG model processing**: The retrieved data is combined with the original
    prompt and passed to the RAG model for further processing, allowing the model
    to generate a richer and context-aware response:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**RAG模型处理**：检索到的数据与原始提示信息结合，并传递给RAG模型进行进一步处理，允许模型生成更丰富和上下文感知的响应：'
- en: '[PRE29]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Response generation**: The RAG model generates a response using the enriched
    prompt (e.g., “The plot of *The Matrix* is: ‘A computer hacker learns from mysterious
    rebels about the true nature of his reality and his role in the war against its
    controllers.’”):'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**响应生成**：RAG模型使用增强的提示信息（例如，“《黑客帝国》的剧情是：‘一个计算机黑客从神秘的叛军那里了解到他现实世界的真实性质以及他在对抗其控制者的战争中的角色。’”）生成响应：'
- en: '[PRE30]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is a sample output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例输出：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The full version of the code in this chapter is placed at: [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/neo4j_rag.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/neo4j_rag.py).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中代码的完整版本放置在：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/neo4j_rag.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch3/neo4j_rag.py)。
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With an understanding of how to build and query a basic knowledge graph, as
    well as how to integrate RAG models with Neo4j, you are now equipped with the
    foundational skills needed to create intelligent, context-aware applications.
    Next, we will take a look at a few approaches to enhance knowledge graphs. We
    will just be introducing these concepts here and will be exploring them in more
    detail upcoming chapters for building intelligent applications.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解如何构建和查询基本知识图，以及如何将RAG模型与Neo4j集成，你现在已经具备了创建智能、上下文感知应用程序所需的基础技能。接下来，我们将探讨一些增强知识图的方法。我们在这里只是介绍这些概念，将在接下来的章节中更详细地探讨它们，以构建智能应用程序。
- en: Enhancing knowledge graphs
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强知识图
- en: 'We looked at building a graph and GraphRAG flow in the previous section. What
    we have looked at is a simple graph. There are a few approaches we can follow
    to make knowledge graphs more effective. Let us take a look at these approaches.
    We will be using these approaches to enhance our knowledge graphs in the upcoming
    chapters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了构建图和GraphRAG流程。我们所探讨的是一个简单的图。我们可以遵循一些方法来使知识图更有效。让我们来看看这些方法。我们将在接下来的章节中使用这些方法来增强我们的知识图：
- en: '**Ontology development**: An ontology can define the structure and the content
    of the graph. By having the ontology persisted in the graph, we might be able
    to explain the data and its connectivity in a more intuitive way. This ensures
    that the graph follows best practices and aligns with your domain-specific needs.
    Ontologies also help in maintaining uniformity across different datasets and in
    extending the graph over time. In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor038),
    we would be enhancing the simple movie knowledge graph we created in this chapter   If
    you want to learn more about ontologies, you can take a look at [https://neo4j.com/blog/ontologies-in-neo4j-semantics-and-knowledge-graphs/](https://neo4j.com/blog/ontologies-in-neo4j-semantics-and-knowledge-graphs/).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本体开发**：本体可以定义图的结构和内容。通过将本体持久化在图中，我们可能能够以更直观的方式解释数据和其连通性。这确保了图遵循最佳实践并与您的特定领域需求保持一致。本体还有助于在不同数据集之间保持一致性，并在随时间扩展图。在[第5章](Chapter_05.xhtml#_idTextAnchor038)中，我们将增强本章中创建的简单电影知识图。如果您想了解更多关于本体，可以查看[https://neo4j.com/blog/ontologies-in-neo4j-semantics-and-knowledge-graphs/](https://neo4j.com/blog/ontologies-in-neo4j-semantics-and-knowledge-graphs/)。'
- en: '**Graph Data Science (GDS)**: While data loaded as a graph can be effective
    as a knowledge graph, there are a few other approaches that can make this graph
    much more effective. For example, we can perform some link prediction or perform
    community detection to create additional relationships between nodes that are
    inferred based on the existing data in the graph. This can help us enhance the
    intelligence stored in the graph to give us better answers when querying. We will
    be leveraging the KNN similarity and community detection algorithms in [*Chapter
    10*](Chapter_10.xhtml#_idTextAnchor066) to enhance the graph to get more intelligence.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据科学（GDS）**：虽然作为图加载数据可以作为一个有效的知识图，但还有一些其他方法可以使这个图更加有效。例如，我们可以执行一些链接预测或进行社区检测，以在图中基于现有数据推断出节点之间的额外关系。这可以帮助我们增强图中存储的智能，以便在查询时提供更好的答案。我们将在[第10章](Chapter_10.xhtml#_idTextAnchor066)中利用KNN相似性和社区检测算法来增强图，以获得更多的智能。'
- en: We have looked at a few approaches to enhance knowledge graphs. Let us now summarize
    our understanding of the concepts we have looked at.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了增强知识图的一些方法。现在，让我们总结一下我们对所探讨的概念的理解。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explored the foundational aspects of building a knowledge
    graph for RAG integration using Neo4j. We began by understanding the importance
    of Neo4j knowledge graphs and their role in GraphRAG. We also set up a Neo4j database,
    created nodes and relationships, and performed queries to retrieve relevant information.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用Neo4j构建知识图以实现RAG集成的基本方面。我们首先理解了Neo4j知识图的重要性及其在GraphRAG中的作用。我们还设置了Neo4j数据库，创建了节点和关系，并执行查询以检索相关信息。
- en: 'We also covered the integration workflow of RAG models with Neo4j. You are
    now ready to move on to *Part 2*, *Integrating Haystack with Neo4j: A Practical
    Guide to Building AI-Powered Search*. In the next part, we will build on the foundation
    laid in this chapter and explore how to integrate Haystack with Neo4j to create
    powerful, AI-driven search capabilities. This next step will naturally extend
    your knowledge and skills, enabling you to develop sophisticated search applications
    that leverage the strengths of both Haystack and Neo4j.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了 RAG 模型与 Neo4j 的集成工作流程。你现在可以继续进入 *第二部分*，*将 Haystack 与 Neo4j 集成：构建 AI 驱动搜索的实用指南*。在下一部分，我们将在此基础上构建，探讨如何将
    Haystack 与 Neo4j 集成以创建强大、AI 驱动的搜索功能。这一步将自然而然地扩展你的知识和技能，使你能够开发利用 Haystack 和 Neo4j
    双方优势的复杂搜索应用。
