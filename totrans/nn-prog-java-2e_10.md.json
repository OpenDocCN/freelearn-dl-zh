["```py\npublic class ConvolutionalLayer extends NeuralLayer{\n  int height,width, depth;\n//…\n  ArrayList<ArrayList<ArrayList<Neuron>>> neurons;\n  Map<Neuron,Neuron> connections;\n  ConvolutionalLayer previousLayer;\n\n  //the method call should take into account the mapping \n  // between neurons from different layers\n  @Override\n  public void calc(){\n    ArrayList<ArrayList<ArrayList<double>>> inputs;\n    foreach(Neuron n:neurons){\n      foreach(Neuron m:connections.keySet()){ \n  // here we get only the inputs that are connected to the neuron\n\n      }\n    }\n  }\n\n}\n\npublic class CNN : NeuralNet{\n  int depth;\n  ArrayList<ConvolutionalLayer> layers;\n//…\n  @Override\n  public void calc(){\n    //here we perform the calculation for each layer, \n    //taking into account the connections between layers\n  }\n}\n```", "```py\nNeuro-fuzzy\n```", "```py\npublic class Gaussian implements ActivationFunction{\n  double A=1.0,B=0.0,C=1.0;\n  public Gaussian(double A){ ///…\n  }\n  public double calc(double x){\n    return this.A*Math.exp(-Math.pow(x-this.B,2.0) / 2*Math.pow(this.C,2.0));\n  }\n}\n```", "```py\nint[] setsPerVariable = {3,3,3};\nint[][] rules = {{0,0,0},{0,1,0},{1,0,1},{1,1,0},{2,0,2},{2,1,1}, {2,2,2}}; \n```", "```py\nActivationFunction[] fuzzyMembership = {new Gausian(1.0),//… \n}};\n```", "```py\npublic class NeuroFuzzyLayer extends NeuralLayer{\n  double[] inputs;\n  ArrayList<Neuron> neurons;\n  Double[] outputs;\n  NeuroFuzzyLayer previousLayer;\n///…\n}\n\npublic class InputFuzzyLayer extends NeuroFuzzyLayer{\n\n  int[] setsPerVariable;\n  ActivationFunction[] fuzzyMembership;\n  //…\n}\n\npublic class RuleLayer extends NeuroFuzzyLayer{\n  int[][] rules;\n//…\n}\n```", "```py\npublic class NeuroFuzzy extends NeuralNet{\n  InputFuzzyLayer inputLayer;\n  RuleLayer ruleLayer;\n  NeuroFuzzyLayer outputLayer;\n//…\n}\n```", "```py\npublic class NeuroGenetic{\n  // each element ArrayList<double> is a solution, i.e. \n  // a set of weights\n  ArrayList<ArrayList<double>> population;\n  ArrayList<double> score;\n\n  NeuralNet neuralNet;\n  NeuralDataSet trainingDataSet;\n  NeuralDataSet testDataSet;\n\n  public ArrayList<ArrayList<double>> reproduction(ArrayList<ArrayList<double>> solutions){\n    // a set of weights is passed as an argument\n    // the weights are just swapped between them in groups of two\n  }\n\n  public ArrayList<ArrayList<double>> mutation(ArrayList<ArrayList<double>> solutions){\n    // a random weight can suddenly change its value\n  }\n\n}\n```", "```py\npublic double evaluation(ArrayList<double> solution){\n  neuralNet.setAllWeights(solution);\n  LearningAlgorithm la = new LearningAlgorithm(neuralNet,trainingDataSet);\n  la.forward();\n  return la.getOverallGeneralError();\n}\n```", "```py\npublic void run{\n  generatePopulation();\n  int generation=0;\n  while(generation<MaxGenerations && bestMSError>MinMSError){ \n    //evaluate all\n    foreach(ArrayList<double> solution:population){\n      score.set(i,evaluation(solution));\n    }\n    //make a rank\n    int[] rank = rankAll(score);\n    //check the best MSE\n    if(ArrayOperations.min(score)<bestMSError){\n      bestMSError = ArrayOperations.min(score);\n      bestSolution = population.get(ArrayOperations.indexMin(score));\n    }\n    //perform a selection for reproduction\n    ArrayList<ArrayList<double>> newSolutions = reproduction(\n      selectionForReproduction(rank,score,population));\n    //perform selection for mutation\n    ArrayList<ArrayList<double>> mutated = mutation(selectionForMutation(rank,score,population));\n    //perform selection for elimintation\n    if(generation>5)\n      eliminateWorst(rank,score,population);\n    //add the new elements\n    population.append(newSolutions);\n    population.append(mutated);\n  }\n  System.out.println(\"Best MSE found:\"+bestMSError);\n\n}\n```"]