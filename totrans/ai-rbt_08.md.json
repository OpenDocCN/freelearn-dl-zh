["```py\npip install –U scikit-learn\n```", "```py\n    # decision tree classifier\n    # author: Francis X Govers III #\n    # example from book \"Artificial Intelligence for Robotics\" #\n    ```", "```py\n    pandas package, which provides a lot of data table-handling tools:\n\n    ```", "```py\n\n    ```", "```py\n    toyData = pd.read_csv(\"toy_classifier_tree.csv\")\n    print (\"Data length \",len(toyData))\n    print (\"Data Shape \",toyData.shape)\n    ```", "```py\ndTree = tree.DecisionTreeClassifier(criterion =\"gini\")\n```", "```py\n    dataValues=toyData.values[:,1:10]\n    classValues = toyData.values[:,0]\n    ```", "```py\nlencoder = preproc.LabelEncoder() lencoder.fit(classValues)\nclasses = lencoder.transform(classValues)\nclassValues = list(sorted(set(classValues)))\n```", "```py\n    newData = []\n    for ii in range(len(dataValues[0]))\n    line = dataValues[:,ii]\n    if type(line[0])==str:\n         lencoder.fit(line)\n      line = lencoder.transform(line)\n    ```", "```py\n    newData.append(line)\n    newDataArray = np.asarray(newData)\n    newDataArray = np.transpose(newDataArray)\n    ```", "```py\ndTree = dTree.fit(newDataArray,classes)\n```", "```py\nDecisionTreeClassifier(class_weight=None, criterion='gini', max_depth=None, max_features=None, max_leaf_nodes=None,\nmin_impurity_split=1e-07, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter='best')\n```", "```py\n    c_data=tree.export_graphviz(dTree,out_file=None,feature_names=toyData.colum ns, class_names=classValues, filled = True, rounded=True,special_characters=True)\n    graph = graphviz.Source(c_data)\n    graph.render(\"toy_graph_gini\")\n    ```", "```py\ndTree = tree.DecisionTreeClassifier(criterion =\"entropy\")\n```", "```py\n    # decision tree classifier\n    # with One Hot Encoding and Gini criteria #\n    # Author: Francis X Govers III #\n    # Example from book \"Artificial Intelligence for Robotics\" #\n    from sklearn import tree\n    import numpy as np\n    import pandas as pd\n    import sklearn.preprocessing as preproc\n    import graphviz\n    ```", "```py\n    toyData = pd.read_csv(\"toy_classifier_tree.csv\")\n    del toyData[\"Toy Name\"]   # we don't need this for now\n    ```", "```py\n    textCols = ['Color','Soft','Material']\n    toyData = pd.get_dummies(toyData,columns=textCols)\n    ```", "```py\n    print toyData\n    ```", "```py\n    dTree = tree.DecisionTreeClassifier(criterion =\"gini\")\n    dataValues=toyData.values[:,1:]\n    classValues = toyData.values[:,0]\n    ```", "```py\n    lencoder = preproc.LabelEncoder()\n    lencoder.fit(classValues)\n    classes = lencoder.transform(classValues)\n    ```", "```py\n    classValues = list(sorted(set(classValues)))\n    ```", "```py\n    print \"\"\n    dTree = dTree.fit(dataValues,classes)\n    c_data=tree.export_graphviz(dTree,out_file=None,feature_names=toyData.columns,\n    class_names=classValues, filled = True, rounded=True,special_characters=True)\n    graph = graphviz.Source(c_data) graph.render(\"toy_decision_tree_graph_oneHot_gini\")\n    ```", "```py\n    # globals\n    mapLength = 1280\n    mapWidth = 1200\n    mapSize = mapLength*mapWidth\n    map = []\n    ```", "```py\n    for ii in range(0, mapWidth):\n        for jj in range(0,mapLength):\n            mapSq = mapGridSquare()#defined later\n            mapSq.position = [ii,jj]\n            mapSq.sType =EMPTY\n    ```", "```py\n    # create obstacles\n    obstacles = [[1,1],[1,2],[1,3],[45,18],[32,15] …..[1000,233]]\n    # iterate through obstacles and mark on the map\n    for pos in obstacles:\n        map[pos]. sType = OBSTACLE\n    pathGrid = []\n    ```", "```py\n    START = [322, 128]\n    GOAL = [938,523]\n    exploredMap = []\n    A_Star_navigation(start, goal, exploredMap, map)\n    ```", "```py\n    def mapGridSquare():\n        def __init__(self):\n            self.F_value = 0.0  #total of G and H\n            self.G_value = 0.0  # distance to start\n            self.H_value = 0.0  # distance to goal\n            self.position=[0,0]   # grid location x and y\n            self. predecessor =None   # pointer to previous square\n            self.sType = PATH\n        def compute(self, goal, start):\n            self.G_value = distance(goal.position,self.position)\n            self.H_value = distance(start.position,self.position\n            self.F_value = self.G_value + self.H_value\n            return self.F_value\n    ```", "```py\n    def reconstructPath(current):\n        totalPath=[current]\n        done=False\n        while not done:\n            a_square = current.predecessor\n            if a_square == None:  # at start position?\n                done = True\n            totalPath.append(a_square)\n            current = a_square\n        return totalPath\n    ```", "```py\n    def findMin(map):\n        minmap = []\n        for square in map:\n            if minmap == []:\n                minmap = square\n                continue\n            if square.F_value < minmap.F_value:\n                minmap = square\n        return minmap\n    ```", "```py\n    def A_Star_navigation(start, goal, exploredMap, map):\n        while len(exploredMap>0):\n            current = findMin(exploredMap)\n            if current.position == goal.position:\n                # we are done – we are at the goal\n                return reconstructPath(current)\n            neighbors = getNeighbors(current)\n    ```", "```py\n            for a_square in neighbors:\n                if a_square.predecessor == None:\n    ```", "```py\n                    old_score = a_square.F_value\n        score = a_square.compute(GOAL, START)\n    ```", "```py\n        if a_square.G_value < current.G_value:\n            a_square.predecessor = current\n            current = a_square\n            current.compute(GOAL, START)\n            exploredMap.append(current)\n    ```"]