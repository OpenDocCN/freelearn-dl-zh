<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-146">
    <a id="_idTextAnchor148">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-147">
    <a id="_idTextAnchor149">
    </a>
    
     Setting Up a Behavior Tree
    
   </h1>
   <p>
    
     Understanding how to properly set up a behavior tree is crucial for developing effective AI systems in your games.
    
    
     As you have seen from the previous chapter, behavior trees serve as a powerful tool to define the logic and decision-making processes of AI characters, allowing developers to create complex behaviors in a structured and manageable manner.
    
    
     This chapter will provide valuable insights into the fundamentals of behavior trees’ implementation and their inner workings in
    
    
     
      Unreal Engine.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Extending the Unreal
     
     
      
       Agility Arena
      
     
    </li>
    <li>
     
      Creating a
     
     
      
       behavior tree
      
     
    </li>
    <li>
     
      Implementing behavior tree tasks
     
     
      
       and services
      
     
    </li>
    <li>
     
      Setting up a behavior tree on
     
     
      
       an agent
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-148">
    <a id="_idTextAnchor150">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow along with this chapter, you’ll need to use the starter content available in this book’s companion repository, located at
    
    <a href="https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5">
     
      https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5
     
    </a>
    
     .
    
    
     Through this link, locate the section for this chapter and download the
    
    <strong class="source-inline">
     
      Unreal Agility Arena – Starter Content
     
    </strong>
    
     
      ZIP file.
     
    
   </p>
   <p>
    
     If you somehow get lost during the progress of this chapter, in the repository, you will also find the up-to-date project files at
    
    <strong class="source-inline">
     
      Unreal Agility Arena –
     
    </strong>
    
     <strong class="source-inline">
      
       Chapter
      
     </strong>
    
    
     <strong class="source-inline">
      
       08
      
     </strong>
    
    
     <strong class="source-inline">
      
       End
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Also, to fully understand this chapter, it is necessary to have some basic knowledge about Blueprint visual scripting and C++; as an extra piece of advice, you may want to take a peek at
    
    <em class="italic">
     
      Appendix A
     
    </em>
    
     ,
    
    <em class="italic">
     
      Understanding C++ in Unreal Engine
     
    </em>
    
     , for a gentle introduction (or a refresher) on the C++ syntax in
    
    
     
      Unreal Engine.
     
    
   </p>
   <h1 id="_idParaDest-149">
    <a id="_idTextAnchor151">
    </a>
    
     Extending the Unreal Agility Arena
    
   </h1>
   <p>
    
     To get started, let’s continue exploring the short novel we introduced in
    
    <a href="B31016_04.xhtml#_idTextAnchor073">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a
     
    </em>
    
     <em class="italic">
      
       Navigation Mesh
      
     </em>
    
    
     
      :
     
    
   </p>
   <p>
    <em class="italic">
     
      As Dr.
     
     
      Markus and his trusty assistant Professor Viktoria continued to refine their AI dummy puppets, they stumbled upon an intriguing challenge: the limited power supply of the puppets’ batteries.
     
     
      It seemed that the advanced AI technology consumed energy at an alarming rate, causing the puppets to shut
     
    </em>
    
     <em class="italic">
      
       down unexpectedly.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      Undeterred by this setback, Dr.
     
     
      Markus saw an opportunity to turn this limitation into a unique aspect of the puppets’ behavior.
     
     
      He theorized that the puppets’ interactions, when powered by dwindling battery life, would mimic human fatigue and exhaustion.
     
     
      With great excitement, Dr.
     
     
      Markus and Professor Viktoria devised a plan to create a new series of experiments centered around the puppets’ limited
     
    </em>
    
     <em class="italic">
      
       power supply.
      
     </em>
    
   </p>
   <p>
    
     After learning all that information in the last chapter, it’s time to dive in and begin crafting your own AI agents, equipped with fully functional behavior trees.
    
    
     To keep things simple and clean, I will start with a brand-new project, but you are free to continue developing the work you started in the
    
    
     
      previous chapters.
     
    
   </p>
   <p>
    
     To start, I will give you some short information on what will
    
    
     
      be created.
     
    
   </p>
   <h2 id="_idParaDest-150">
    <a id="_idTextAnchor152">
    </a>
    
     Updating the project brief
    
   </h2>
   <p>
    
     As a starting point, you will need to create a new dummy character (the one from previous chapters is too limited) that will need to implement some base logic.
    
    
     This will let you extend its basic functionality once we start creating more
    
    
     
      advanced characters.
     
    
   </p>
   <p>
    
     The main requisites are listed
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     
      The AI agent will be implemented
     
     
      
       in C++
      
     
    </li>
    <li>
     
      It will have the ability to move at two different speeds – walking
     
     
      
       and running
      
     
    </li>
    <li>
     
      It will be provided with a battery system that will consume energy when walking and recharge when
     
     
      
       standing still
      
     
    </li>
    <li>
     
      It will need to be controlled by a custom
     
     <strong class="source-inline">
      
       AIController
      
     </strong>
     
      class that will use
     
     
      
       behavior trees
      
     
    </li>
   </ul>
   <p>
    
     Once the character has been created, we will be able to start creating new gym levels to create and test new AI agent behaviors.
    
    
     So, let’s start by creating
    
    
     
      the project.
     
    
   </p>
   <h2 id="_idParaDest-151">
    <a id="_idTextAnchor153">
    </a>
    
     Creating the project
    
   </h2>
   <p>
    
     The project creation process is basically the same as the one we covered in
    
    <a href="B31016_04.xhtml#_idTextAnchor073">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a Navigation Mesh
     
    </em>
    
     , so I won’t go much into detail about it; the distinction we will make (which is certainly not trivial) is the inclusion of
    
    
     
      C++ classes.
     
    
   </p>
   <p>
    
     Luckily, this is going to be a seamless transition, as when you create a new C++ class for the first time, Unreal Engine sets up the whole system for you.
    
    
     Once the C++ project files have been generated, you should see the
    
    <strong class="source-inline">
     
      C++ Classes
     
    </strong>
    
     folder in your
    
    <strong class="bold">
     
      Content Browser
     
    </strong>
    
     window, along with the
    
    
     <strong class="source-inline">
      
       Content
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <div><div><img alt="Figure 8.1 – The C++ folder" src="img/B31016_figure_08.01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.1 – The C++ folder
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     If the
    
    <strong class="source-inline">
     
      C++ Classes
     
    </strong>
    
     folder does not appear in your
    
    <strong class="bold">
     
      Content Browser
     
    </strong>
    
     window, you will probably need to open the
    
    <strong class="bold">
     
      Settings
     
    </strong>
    
     window and tick the
    
    <strong class="bold">
     
      Show C++ Classes
     
    </strong>
    
     option, as shown in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="img" role="presentation" src="img/B31016_figure_08.02.jpg"/>
     
    </div>
   </div>
   <p class="callout">
    
     
      Figure 8
     
    
    
     .2 – Enabling the
    
    
     
      C++ folder
     
    
   </p>
   <p>
    
     Let’s start creating the
    
    
     
      character class.
     
    
   </p>
   <h2 id="_idParaDest-152">
    <a id="_idTextAnchor154">
    </a>
    
     Creating the character
    
   </h2>
   <p>
    
     The first thing we are going to
    
    <a id="_idIndexMarker318">
    </a>
    
     do is to create the base character class for our prospective AI dummies.
    
    
     To do so, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      From the main menu of the Unreal Engine Editor, select
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New
      
     </strong>
     
      <strong class="bold">
       
        C++ Class
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.3 – Creating a C++ class" src="img/B31016_figure_08.03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.3 – Creating a C++ class
    
   </p>
   <ol>
    <li value="2">
     
      From the
     
     <strong class="bold">
      
       Add C++ Class
      
     </strong>
     
      pop-up window, select the
     
     <strong class="bold">
      
       Character
      
     </strong>
     
      option and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.4 – Class selection" src="img/B31016_figure_08.04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.4 – Class selection
    
   </p>
   <ol>
    <li value="3">
     
      In the following window, insert
     
     <strong class="source-inline">
      
       BaseDummyCharacter
      
     </strong>
     
      into the
     
     <strong class="bold">
      
       Name
      
     </strong>
     
      field and leave the rest as
     
     
      
       it is.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.5 – Class creation" src="img/B31016_figure_08.05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.5 – Class creation
    
   </p>
   <ol>
    <li value="4">
     
      Click the
     
     <strong class="bold">
      
       Create Class
      
     </strong>
     
      button to
     
     <a id="_idIndexMarker319">
     </a>
     
      start the class
     
     
      
       creation process.
      
     
    </li>
   </ol>
   <p>
    
     As this is the very first class you have created, Unreal will start generating the C++ project; after that, your IDE – most probably Visual Studio or Rider – will open, and you will be able to start developing
    
    
     
      your class.
     
    
   </p>
   <h2 id="_idParaDest-153">
    <a id="_idTextAnchor155">
    </a>
    
     Handling the battery status
    
   </h2>
   <p>
    
     Before
    
    <a id="_idIndexMarker320">
    </a>
    
     implementing the character, we need to define how its battery status will be tracked; that’s why we are going to create a simple enumeration class that will list how much the battery is charged.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Inside your IDE, locate the
     
     
      <strong class="source-inline">
       
        UnrealAgilityArena/Source/UnrealAgilityArena
       
      </strong>
     
     
      
       folder.
      
     
    </li>
    <li>
     
      Inside this folder, create a new text file and call
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        BatteryStatus.h
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open the file to
     
     
      
       edit it.
      
     
    </li>
   </ol>
   <p>
    
     Inside the file, add this piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
#pragma once
UENUM(BlueprintType)
enum class EBatteryStatus : uint8
{
    EBS_Empty = 0 UMETA(DisplayName = "Empty"),
    EBS_Low = 1 UMETA(DisplayName = "Low"),
    EBS_Medium = 2 UMETA(DisplayName = "Medium"),
    EBS_Full = 3 UMETA(DisplayName = "Full")
};</pre>
   <p>
    
     I guess you are already familiar with what an enumeration does, but a short explanation here is mandatory; we are defining an
    
    <strong class="source-inline">
     
      enum
     
    </strong>
    
     class, which in Unreal Engine needs to be of type
    
    <strong class="source-inline">
     
      uint8
     
    </strong>
    
     , and we are listing four levels of battery charging –
    
    <strong class="source-inline">
     
      Empty
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Low
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Medium
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Full
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      UENUM()
     
    </strong>
    
     macro defines an
    
    <strong class="source-inline">
     
      enum
     
    </strong>
    
     class for the Unreal Engine framework, and the
    
    <strong class="source-inline">
     
      BlueprintType
     
    </strong>
    
     specifier will expose it to the Blueprint system, making it usable for variables.
    
    
     The
    
    <strong class="source-inline">
     
      DisplayName
     
    </strong>
    
     metadata defines how the value will be shown in the Blueprint system; you can use your own convention here if you
    
    
     
      so desire.
     
    
   </p>
   <p>
    
     Finally, pay
    
    <a id="_idIndexMarker321">
    </a>
    
     attention to the
    
    <em class="italic">
     
      E
     
    </em>
    
     prefix in the name definition; this is the Unreal Engine naming convention for
    
    <strong class="source-inline">
     
      enum
     
    </strong>
    
     types, and it
    
    
     
      is mandatory.
     
    
   </p>
   <p>
    
     With the battery status defined, we are ready to start implementing the
    
    
     
      dummy character.
     
    
   </p>
   <h2 id="_idParaDest-154">
    <a id="_idTextAnchor156">
    </a>
    
     Implementing the character
    
   </h2>
   <p>
    
     To start implementing the
    
    <a id="_idIndexMarker322">
    </a>
    
     AI agent, open the
    
    <strong class="source-inline">
     
      BaseDummyCharacter.h
     
    </strong>
    
     file – that is, the header for the agent class – and start adding the
    
    
     
      class definitions.
     
    
   </p>
   <p>
    
     As a first step, add the battery status definition at the top of the file, where all the
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     definitions
    
    
     
      are set:
     
    
   </p>
   <pre class="source-code">
#include "BatteryStatus.h"</pre>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     All the
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations you’ll be adding always need to be put before the
    
    <strong class="source-inline">
     
      .generated.h
     
    </strong>
    
     definition – in this case,
    
    <strong class="source-inline">
     
      BaseDummyCharacter.generated.h
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      .generated.h
     
    </strong>
    
     definition always needs to be the last in the declaration list; this convention ensures that all the necessary dependencies are properly set at
    
    
     
      compilation time.
     
    
   </p>
   <h3>
    
     Declaring properties
    
   </h3>
   <p>
    
     The second step is to add all the
    
    <a id="_idIndexMarker323">
    </a>
    
     properties that will be exposed in the extending Blueprint classes.
    
    
     To do so, under the
    
    <strong class="source-inline">
     
      public
     
    </strong>
    
     section of the file, add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Dummy Character")
float MaxBatteryLevel = 100.f;
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Dummy Character")
float BatteryCostPerTick = 5.f;
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Dummy Character")
float BatteryRechargePerTick = 1.f;
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Dummy Character")
float RunSpeed = 650.f;
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Dummy Character")
float WalkSpeed = 500.f;
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Dummy Character")
float MovementRandomDeviation = 5.f;</pre>
   <p>
    
     Here, we have declared a list of variables to handle
    
    
     
      the agent:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       MaxBatteryLevel
      
     </strong>
     
      : Represents the maximum value reachable by the
     
     
      
       agent battery
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       BatteryCostPerTick
      
     </strong>
     
      : Represents how much battery power is spent by the agent while it
     
     
      
       is moving
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       BatteryRechargePerTick
      
     </strong>
     
      : Represents how much battery power is recovered when the agent
     
     
      
       is resting
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       RunSpeed
      
     </strong>
     
      : Represents the maximum speed reachable
     
     
      
       when running
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       WalkSpeed
      
     </strong>
     
      : Represents the maximum speed reachable
     
     
      
       when walking
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       MovementRandomDeviation
      
     </strong>
     
      : A value that will be randomly added or subtracted to the
     
     <a id="_idIndexMarker324">
     </a>
     
      agent speed in order to make the movement pace
     
     
      
       less predictable
      
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      UPROPERTY()
     
    </strong>
    
     macro is used to declare class properties with additional functionality and metadata.
    
    
     It allows for easy integration with the Unreal Engine Editor, providing a visual interface to modify and configure these properties.
    
    
     The
    
    <strong class="source-inline">
     
      EditAnywhere
     
    </strong>
    
     property specifier indicates that the property can be edited in property windows from the Unreal Engine Editor, while
    
    <strong class="source-inline">
     
      BlueprintReadWrite
     
    </strong>
    
     specifies that the property will be accessible from the extending Blueprint classes in read and write mode.
    
    
     Finally, we want all the properties to be in the same category – that is,
    
    <strong class="bold">
     
      Dummy Character
     
    </strong>
    
     – and that’s why we have set the
    
    <strong class="source-inline">
     
      Category
     
    </strong>
    
     
      property specifier.
     
    
   </p>
   <p>
    
     We need just one more variable, but this need not be public because it will be used for the actor’s inner logic.
    
    
     In the
    
    <strong class="source-inline">
     
      protected
     
    </strong>
    
     section, let’s add the
    
    
     
      following declaration:
     
    
   </p>
   <pre class="source-code">
UPROPERTY()
float BatteryLevel;</pre>
   <p>
    
     This self-explanatory
    
    <a id="_idIndexMarker325">
    </a>
    
     attribute will be used to keep track of the actual battery level of
    
    
     
      the agent.
     
    
   </p>
   <h3>
    
     Adding delegates
    
   </h3>
   <p>
    
     We now need to create an
    
    <a id="_idIndexMarker326">
    </a>
    
     event dispatcher for battery status change
    
    <a id="_idIndexMarker327">
    </a>
    
     notification; the best method in C++ is to use
    
    
     
      a
     
    
    
     <strong class="bold">
      
       delegate
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     If you are unfamiliar with delegates, my advice is to take a peek at
    
    <em class="italic">
     
      Appendix A
     
    </em>
    
     ,
    
    <strong class="source-inline">
    </strong>
    <em class="italic">
     
      Understanding C++ in Unreal Engine
     
    </em>
    
     , at the end of
    
    
     
      this book.
     
    
   </p>
   <p>
    
     Locate the
    
    <strong class="source-inline">
     
      public
     
    </strong>
    
     section and add the following piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnBatteryStatusChanged, EBatteryStatus, NewBatteryStatus);
UPROPERTY(BlueprintAssignable, Category = "Dummy Character")
FOnBatteryStatusChanged OnBatteryStatusChanged;</pre>
   <p>
    
     We have declared a dynamic multicast delegate with a single parameter – the battery new status – that will be dispatched every time the battery changes its
    
    
     
      charge level.
     
    
   </p>
   <h3>
    
     Declaring functions
    
   </h3>
   <p>
    
     The last thing we need to
    
    <a id="_idIndexMarker328">
    </a>
    
     add to the header is the function declarations.
    
    
     As a first step, delete the following line of code that is found at the end of
    
    
     
      the file:
     
    
   </p>
   <pre class="source-code">
virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;</pre>
   <p>
    
     This character will be controlled by AI, so we don’t need to set up the player input.
    
    
     Next, just after the
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     declaration, add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
UFUNCTION(BlueprintCallable, Category="Dummy Character")
void SetWalkSpeed();
UFUNCTION(BlueprintCallable, Category="Dummy Character")
void SetRunSpeed();
UFUNCTION(BlueprintCallable, BlueprintGetter, Category="Dummy Character")
EBatteryStatus GetBatteryStatus() const;</pre>
   <p>
    
     We have just declared two functions –
    
    <strong class="source-inline">
     
      SetWalkSpeed()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      SetRunSpeed()
     
    </strong>
    
     – that will let us change the character speed at runtime.
    
    
     Additionally, we have added a getter function for the agent
    
    
     
      battery status.
     
    
   </p>
   <p>
    
     In Unreal Engine, the
    
    <strong class="source-inline">
     
      UFUNCTION()
     
    </strong>
    
     macro is used to declare functions that are recognized by the Unreal Engine reflection system; this means the function becomes accessible and usable within the Unreal Engine framework.
    
    
     All three functions have the
    
    <strong class="source-inline">
     
      BlueprintCallable
     
    </strong>
    
     specifier added, meaning that these functions will be accessible in a Blueprint graph.
    
    
     Additionally, the
    
    <strong class="source-inline">
     
      GetBatteryStatus()
     
    </strong>
    
     function has the
    
    <strong class="source-inline">
     
      const
     
    </strong>
    
     keyword added; this will remove the execution pin in the corresponding Blueprint node, as we
    
    <a id="_idIndexMarker329">
    </a>
    
     need this function to just be a getter and not change any data
    
    
     
      during execution.
     
    
   </p>
   <h3>
    
     Implementing functions
    
   </h3>
   <p>
    
     Now that all the class declarations
    
    <a id="_idIndexMarker330">
    </a>
    
     have been done, we can start implementing the functions.
    
    
     To do so, the first thing you need to do is to open the
    
    
     <strong class="source-inline">
      
       BaseDummyCharacter.cpp
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     The first thing you’ll need to do is to remove the
    
    <strong class="source-inline">
     
      SetPlayerInputComponent()
     
    </strong>
    
     function, as the corresponding declaration in the header file was
    
    
     
      previously removed.
     
    
   </p>
   <p>
    
     Next, we need to add the
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations at the very beginning of the file.
    
    
     Simply add these three lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
#include "Components/CapsuleComponent.h"
#include "Components/SkeletalMeshComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "BatteryStatus.h"</pre>
   <p>
    
     As always, remember to add these
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations before the
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       generated.h
      
     </strong>
    
    
     
      declaration.
     
    
   </p>
   <p>
    
     Next, locate the
    
    <strong class="source-inline">
     
      ABaseDummyCharacter()
     
    </strong>
    
     constructor function, as we will need to set up some character attributes and components.
    
    
     This function should have already a line of code that sets the
    
    <strong class="source-inline">
     
      bCanEverTick
     
    </strong>
    
     property to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     .
    
    
     Add the following line of code just
    
    
     
      after it:
     
    
   </p>
   <pre class="source-code">
PrimaryActorTick.TickInterval = .25f;</pre>
   <p>
    
     As we will use the
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     event just for updating the battery status, we don’t need it to be executed every frame; we have set a time interval of a quarter of a second – this will be more than enough to suit our
    
    
     
      own needs.
     
    
   </p>
   <p>
    
     Next, add the following lines of code that set up the yaw, pitch, and roll behavior of
    
    
     
      the character:
     
    
   </p>
   <pre class="source-code">
bUseControllerRotationPitch = false;
bUseControllerRotationYaw = false;
bUseControllerRotationRoll = false;</pre>
   <p>
    
     Next, we need to
    
    <a id="_idIndexMarker331">
    </a>
    
     initialize the skeletal mesh component in order to show the dummy puppet model.
    
    
     Add these lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
GetMesh()-&gt;SetRelativeLocation(FVector(0.f, 0.f, -120.f));
GetMesh()-&gt;SetRelativeRotation(FRotator(0.f, -90.f, 0.f));
static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt;
SkeletalMeshAsset(TEXT("/Game/KayKit/PrototypeBits/Character/Dummy.Dummy"));
if (SkeletalMeshAsset.Succeeded())
{
    GetMesh()-&gt;SetSkeletalMesh(SkeletalMeshAsset.Object);
}
GetMesh()-&gt;SetAnimationMode(EAnimationMode::AnimationBlueprint);
static ConstructorHelpers::FObjectFinder&lt;UAnimBlueprint&gt;
AnimBlueprintAsset(TEXT("/Game/KayKit/PrototypeBits/Character/ABP_Dummy.ABP_Dummy"));
if (AnimBlueprintAsset.Succeeded())
{
    GetMesh()-&gt;SetAnimClass(AnimBlueprintAsset.Object-&gt;GeneratedClass);
}</pre>
   <p>
    
     Here, we set the
    
    <a id="_idIndexMarker332">
    </a>
    
     mesh location and rotation in order to suit the dummy puppet model.
    
    
     After that, we assign the dummy puppet skeletal mesh asset by hardcoding the asset path; we will use just this asset, so there is no need to assign it from the extending Blueprint classes.
    
    
     We will do the same with the animation Blueprint asset; I have provided one such asset for you in the project files in the
    
    
     
      declared path.
     
    
   </p>
   <p>
    
     Now, we are going to set the capsule component size in order to match the dummy puppet model.
    
    
     To do this, add this line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
GetCapsuleComponent()-&gt;InitCapsuleSize(50.f, 120.0f);</pre>
   <p>
    
     Finally, set up the movement component by adding the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
GetCharacterMovement()-&gt;bOrientRotationToMovement = true;
GetCharacterMovement()-&gt;MaxWalkSpeed = 500.f;
GetCharacterMovement()-&gt;RotationRate = FRotator(0.f, 640.f, 0.f);
GetCharacterMovement()-&gt;bConstrainToPlane = true;
GetCharacterMovement()-&gt;bSnapToPlaneAtStart = true;
GetCharacterMovement()-&gt;AvoidanceConsiderationRadius = 2000.f;
GetCharacterMovement()-&gt;bUseRVOAvoidance = true;</pre>
   <p>
    
     Note the use of
    
    <strong class="source-inline">
     
      bUseRVOAvoidance
     
    </strong>
    
     , set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     ; we will use several agents at the same time, so a basic avoidance system is almost mandatory to make things
    
    
     
      work properly.
     
    
   </p>
   <p>
    
     The constructor method is complete, so we can now start implementing all the
    
    
     
      other functions.
     
    
   </p>
   <p>
    
     Locate the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     method, and just after the
    
    <strong class="source-inline">
     
      Super::BeginPlay()
     
    </strong>
    
     declaration, add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
BatteryLevel = MaxBatteryLevel * FMath::RandRange(0.f, 1.f);
OnBatteryStatusChanged.Broadcast(GetBatteryStatus());</pre>
   <p>
    
     When the
    
    <a id="_idIndexMarker333">
    </a>
    
     game starts, we set the AI agent to have a random battery level to make things a bit more interesting, and next, we broadcast this status to all
    
    
     
      registered listeners.
     
    
   </p>
   <p>
    
     After that, just after the closing bracket of the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     function, add the following piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
void ABaseDummyCharacter::SetWalkSpeed()
{
    const auto Deviation = FMath::RandRange(-1.f * MovementRandomDeviation, MovementRandomDeviation);
   GetCharacterMovement()-&gt;MaxWalkSpeed = WalkSpeed + Deviation;
}
void ABaseDummyCharacter::SetRunSpeed()
{
    const auto Deviation = FMath::RandRange(-1.f * MovementRandomDeviation, MovementRandomDeviation);
    GetCharacterMovement()-&gt;MaxWalkSpeed = RunSpeed + MovementRandomDeviation;
}</pre>
   <p>
    
     There’s nothing fancy here; we just implement the two functions to change the movement speed of the agent, making it walk
    
    
     
      or run.
     
    
   </p>
   <p>
    
     We now need to
    
    <a id="_idIndexMarker334">
    </a>
    
     implement the battery status getter function, so add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
EBatteryStatus ABaseDummyCharacter::GetBatteryStatus() const
{
    const auto Value = BatteryLevel / MaxBatteryLevel;
    if (Value &lt; 0.05f)
    {
       return EBatteryStatus::EBS_Empty;
    }
    if (Value &lt; 0.35f)
    {
       return EBatteryStatus::EBS_Low;
    }
    if (Value &lt; 0.95f)
    {
       return EBatteryStatus::EBS_Medium;
    }
    return EBatteryStatus::EBS_Full;
}</pre>
   <p>
    
     As you can see, we simply check the battery level and return the corresponding
    
    
     
      status enumeration.
     
    
   </p>
   <p>
    
     The last thing
    
    <a id="_idIndexMarker335">
    </a>
    
     we need to implement is the
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     function, where we will constantly check how much battery power is consumed, depending on the character movement speed.
    
    
     Locate the
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     function, and just after
    
    <strong class="source-inline">
     
      Super::Tick(DeltaTime);
     
    </strong>
    
     , add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
const auto CurrentStatus = GetBatteryStatus();
if(GetMovementComponent()-&gt;Velocity.Size() &gt; .1f)
{
    BatteryLevel -= BatteryCostPerTick;
}
else
{
    BatteryLevel += BatteryRechargePerTick;
}
BatteryLevel = FMath::Clamp&lt;float&gt;(BatteryLevel, 0.f, MaxBatteryLevel);
if (const auto NewStatus = GetBatteryStatus();
  CurrentStatus != NewStatus)0
  {
    OnBatteryStatusChanged.Broadcast(NewStatus);
  }</pre>
   <p>
    
     In this piece of code, we compute the current battery status using the
    
    <strong class="source-inline">
     
      GetBatteryStatus()
     
    </strong>
    
     function.
    
    
     Then, if the velocity of the character’s movement is greater than a tiny number – that is,
    
    <strong class="source-inline">
     
      0.1
     
    </strong>
    
     – it means the agent is moving, so we decrease the battery level by the
    
    <strong class="source-inline">
     
      BatteryCostPerTick
     
    </strong>
    
     value.
    
    
     Otherwise, the agent is standing still – therefore, recharging – so we increase the battery level by
    
    <strong class="source-inline">
     
      BatteryRechargePerTick
     
    </strong>
    
     .
    
    
     After that, we clamp the battery level between a value of zero and
    
    <strong class="source-inline">
     
      MaxBatteryLevel
     
    </strong>
    
     .
    
    
     Finally, we check whether the starting battery status is different from the new battery status, and we eventually broadcast the new battery status using the
    
    
     <strong class="source-inline">
      
       OnBatteryStatusChanged
      
     </strong>
    
    
     
      delegate.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      BaseDummyCharacter
     
    </strong>
    
     class has
    
    <a id="_idIndexMarker336">
    </a>
    
     been completed.
    
    
     It is evident that we have not yet incorporated any AI agent behavior; this is intentional, as we plan to manage everything through an
    
    <strong class="source-inline">
     
      AIController
     
    </strong>
    
     class, a task we will undertake in the
    
    
     
      following section.
     
    
   </p>
   <h1 id="_idParaDest-155">
    <a id="_idTextAnchor157">
    </a>
    
     Creating a behavior tree
    
   </h1>
   <p>
    
     In this section, we will create a fully functional behavior tree for the agent we previously created.
    
    
     The steps we will follow are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     
      Creating the
     
     
      
       AI controller
      
     
    </li>
    <li>
     
      Creating
     
     
      
       the Blackboard
      
     
    </li>
    <li>
     
      Creating the
     
     
      
       behavior tree
      
     
    </li>
   </ul>
   <p>
    
     Let’s start by creating a subclass of the
    
    <strong class="source-inline">
     
      AIController
     
    </strong>
    
     class to control our
    
    
     
      dummy puppet.
     
    
   </p>
   <h2 id="_idParaDest-156">
    <a id="_idTextAnchor158">
    </a>
    
     Creating the AI controller
    
   </h2>
   <p>
    
     We will be now creating
    
    <a id="_idIndexMarker337">
    </a>
    
     a class extending
    
    <strong class="source-inline">
     
      AIController
     
    </strong>
    
     that will be used as a starting point for the behavior tree.
    
    
     To get started, open the Unreal Engine Editor and do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      From the main menu, select
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New
      
     </strong>
     
      <strong class="bold">
       
        C++ Class
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click on the
     
     <strong class="bold">
      
       All Classes
      
     </strong>
     
      tab section and look
     
     
      
       for
      
     
     
      <strong class="bold">
       
        AIController
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.6 – AI controller class creation" src="img/B31016_figure_08.06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.6 – AI controller class creation
    
   </p>
   <ol>
    <li value="3">
     
      Click the
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      Name the
     
     <a id="_idIndexMarker338">
     </a>
     
      class
     
     <strong class="source-inline">
      
       BaseDummyAIController
      
     </strong>
     
      and click the
     
     <strong class="bold">
      
       Create
      
     </strong>
     
      <strong class="bold">
       
        Class
       
      </strong>
     
     
      
       button.
      
     
    </li>
   </ol>
   <p>
    
     Once the class files have been created and your IDE has been opened, look for the
    
    <strong class="source-inline">
     
      BaseDummyAIController.h
     
    </strong>
    
     header file and
    
    
     
      open it.
     
    
   </p>
   <h3>
    
     Editing the header file
    
   </h3>
   <p>
    
     As a first step, add a
    
    <a id="_idIndexMarker339">
    </a>
    
     forward declaration for the
    
    <strong class="source-inline">
     
      BehaviorTree
     
    </strong>
    
     class, just after the
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     <strong class="source-inline">
      
       include
      
     </strong>
    
    
     
      declarations:
     
    
   </p>
   <pre class="source-code">
class UBehaviorTree;</pre>
   <p>
    
     Then, in the
    
    <strong class="source-inline">
     
      protected
     
    </strong>
    
     section of the header file, add these lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadOnly,
  Category = "Dummy AI Controller")
TObjectPtr&lt;UBehaviorTree&gt; BehaviorTree;</pre>
   <p>
    
     This property declares a pointer to the behavior tree, so that it will be assignable from the
    
    <strong class="bold">
     
      Class Defaults
     
    </strong>
    
     Blueprints panel – using the
    
    <strong class="source-inline">
     
      EditAnywhere
     
    </strong>
    
     specifier – and it will be readable from any
    
    
     
      extending Blueprints.
     
    
   </p>
   <p>
    
     Now, just after these lines of code,
    
    
     
      add this:
     
    
   </p>
   <pre class="source-code">
virtual void OnPossess(APawn* InPawn) override;</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      OnPossess()
     
    </strong>
    
     function is called when the controller possesses a
    
    <strong class="source-inline">
     
      Pawn
     
    </strong>
    
     instance – and our dummy character extends it – and it is a good place to run
    
    
     
      behavior trees.
     
    
   </p>
   <h3>
    
     Implementing the controller
    
   </h3>
   <p>
    
     The controller is quite
    
    <a id="_idIndexMarker340">
    </a>
    
     easy to implement; we just need to run the behavior tree when the AI agent is possessed.
    
    
     To do so, open the
    
    <strong class="source-inline">
     
      BaseDummyAIController.cpp
     
    </strong>
    
     file and add these lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
void ABaseDummyAIController::OnPossess(APawn* InPawn)
{
    Super::OnPossess(InPawn);
    if (ensureMsgf(BehaviorTree, TEXT("Behavior Tree is nullptr! Please assign BehaviorTree in your AI Controller.")))
    {
       RunBehaviorTree(BehaviorTree);
    }
}</pre>
   <p>
    
     In this function, the
    
    <strong class="source-inline">
     
      Super::OnPossess()
     
    </strong>
    
     base class is called first.
    
    
     Then, we use the
    
    <strong class="source-inline">
     
      ensureMsgf()
     
    </strong>
    
     macro to ensure that the
    
    <strong class="source-inline">
     
      BehaviorTree
     
    </strong>
    
     variable is not a null pointer.
    
    
     If a behavior tree has been set, we run it using the
    
    
     <strong class="source-inline">
      
       RunBehaviorTree()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     With the AI controller set, we can start implementing the actual AI behaviors, starting from
    
    
     
      the Blackboard.
     
    
   </p>
   <h2 id="_idParaDest-157">
    <a id="_idTextAnchor159">
    </a>
    
     Creating the Blackboard
    
   </h2>
   <p>
    
     Creating a
    
    <a id="_idIndexMarker341">
    </a>
    
     Blackboard asset is a straightforward task once you know what keys you will be tracking.
    
    
     In our case, we want to make the following values available to the
    
    
     
      behavior tree:
     
    
   </p>
   <ul>
    <li>
     
      A target location vector that will be used by the agent to walk around
     
     
      
       the level
      
     
    </li>
    <li>
     
      A Boolean flag that will warn the agent once the battery charge is
     
     
      
       dangerously low
      
     
    </li>
    <li>
     
      A Boolean flag that will indicate that the battery has
     
     
      
       been depleted
      
     
    </li>
   </ul>
   <p>
    
     To get started, we need to create a
    
    <a id="_idIndexMarker342">
    </a>
    
     Blackboard asset.
    
    
     To do so, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      and create a new folder, naming
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        AI
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open the folder and right-click on
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      , selecting
     
     <strong class="bold">
      
       Artificial Intelligence
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Blackboard
      
     </strong>
     
      to create a
     
     
      
       Blackboard asset.
      
     
    </li>
    <li>
     
      Name the asset
     
     <strong class="source-inline">
      
       BB_Dummy
      
     </strong>
     
      and double-click on it to
     
     
      
       open it.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.7 – The Blackboard panel" src="img/B31016_figure_08.07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.7 – The Blackboard panel
    
   </p>
   <p>
    
     Once the Blackboard is opened, you will see that there’s already a key named
    
    <strong class="bold">
     
      SelfActor
     
    </strong>
    
     ; we won’t be using it during this chapter, but we will leave it as it is, since it is usually used to store a reference to the
    
    
     
      owning actor.
     
    
   </p>
   <p>
    
     We need to create three keys, as stated at the beginning of this subsection, so we’ll start by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Click the
     
     <strong class="bold">
      
       New Key
      
     </strong>
     
      button, and from the dropdown list, select the
     
     <strong class="bold">
      
       Vector
      
     </strong>
     
      type, as shown in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .8
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.8 – Key creation" src="img/B31016_figure_08.08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.8 – Key creation
    
   </p>
   <ol>
    <li value="2">
     
      Name the new
     
     
      
       key
      
     
     
      <strong class="source-inline">
       
        TargetLocation
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click the
     
     <strong class="bold">
      
       New Key
      
     </strong>
     
      button again, select the
     
     <strong class="bold">
      
       Bool
      
     </strong>
     
      type, and name the new
     
     
      
       key
      
     
     
      <strong class="source-inline">
       
        IsLowOnBattery
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click the
     
     <strong class="bold">
      
       New Key
      
     </strong>
     
      button once more, select the
     
     <strong class="bold">
      
       Bool
      
     </strong>
     
      type, and name the new
     
     
      
       key
      
     
     
      <strong class="source-inline">
       
        IsBatteryDepleted
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Once these steps are finished, your
    
    <a id="_idIndexMarker343">
    </a>
    
     Blackboard should be pretty similar to the one depicted in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .9
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.9 – The finished Blackboard" src="img/B31016_figure_08.09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.9 – The finished Blackboard
    
   </p>
   <p>
    
     The Blackboard is finished, and we can now start working on the behavior tree for our
    
    
     
      AI agent.
     
    
   </p>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor160">
    </a>
    
     Creating the behavior tree
    
   </h2>
   <p>
    
     Like the Blackboard, a
    
    <a id="_idIndexMarker344">
    </a>
    
     behavior tree is created as a project asset.
    
    
     Let’s start by performing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      , open the
     
     
      <strong class="source-inline">
       
        AI
       
      </strong>
     
     
      
       folder.
      
     
    </li>
    <li>
     
      Right-click on
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      and select
     
     <strong class="bold">
      
       Artificial Intelligence
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        Behavior Tree
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the newly created asset
     
     <strong class="source-inline">
      
       BT_RoamerDummy
      
     </strong>
     
      and double-click on it to
     
     
      
       open it.
      
     
    </li>
   </ol>
   <p>
    
     Once opened, you
    
    <a id="_idIndexMarker345">
    </a>
    
     should see a graph pretty similar to the one shown in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .10
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.10 – Behavior tree creation" src="img/B31016_figure_08.10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.10 – Behavior tree creation
    
   </p>
   <p>
    
     Note that the
    
    <strong class="bold">
     
      Root
     
    </strong>
    
     node is already included in the graph.
    
    
     As mentioned in the previous chapter, there can only be one such node in the graph.
    
    
     Furthermore, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, you should see that the
    
    <strong class="bold">
     
      BB_Dummy
     
    </strong>
    
     Blackboard asset has already been assigned to the Blackboard asset.
    
    
     If you don’t see it assigned, simply click the
    
    <strong class="bold">
     
      Blackboard
     
    </strong>
    
     property dropdown and select the
    
    <strong class="bold">
     
      BB_Dummy
     
    </strong>
    
     asset; it should be the only asset of that type present in
    
    
     
      your project.
     
    
   </p>
   <p>
    
     In this section, we went through a step-by-step guide on creating a character that will utilize a behavior tree to implement AI logic.
    
    
     We have also successfully created a Blackboard asset and a behavior tree asset, which serve as the foundation to implement our character’s AI behaviors.
    
    
     As the process of implementing all the AI logic for our character is quite extensive, we will tackle it in the upcoming section.
    
    
     Stay tuned for a detailed walk-through on how to effectively implement AI behaviors for
    
    
     
      our character.
     
    
   </p>
   <h1 id="_idParaDest-159">
    <a id="_idTextAnchor161">
    </a>
    
     Implementing behavior tree tasks and services
    
   </h1>
   <p>
    
     Before creating the
    
    <a id="_idIndexMarker346">
    </a>
    
     behavior tree, it is crucial to have a clear understanding of the intended implementation.
    
    
     The AI agent will need to manage the
    
    
     
      following behaviors:
     
    
   </p>
   <ul>
    <li>
     
      Wander around the level looking for
     
     
      
       target locations
      
     
    </li>
    <li>
     
      The default movement speed is running, but if the battery level is low, the movement speed should switch
     
     
      
       to walking
      
     
    </li>
    <li>
     
      Once the battery is depleted, it should
     
     
      
       stop moving
      
     
    </li>
    <li>
     
      Once the battery is fully charged, it should return to the
     
     
      
       movement pattern
      
     
    </li>
   </ul>
   <p>
    
     It is worth noting that the battery depletion and recharging logic has already been implemented in the
    
    <strong class="source-inline">
     
      BaseDummyCharacter
     
    </strong>
    
     class, so we won’t need to worry about it – we will just need to listen to the events dispatched by the character and
    
    
     
      behave accordingly.
     
    
   </p>
   <p>
    
     As I mentioned in the previous chapter, the Unreal Engine AI system provides a comprehensive collection of tasks, services, and decorators for our AIs.
    
    
     However, it’s worth noting that these built-in components may not cover all the specific requirements of your game.
    
    
     After all, as developers, we enjoy the creative process of building new things that suit our unique needs and add to the overall fun of
    
    
     
      game development!
     
    
   </p>
   <p>
    
     That’s why, before adding nodes to our graph, we will need to implement a set of tasks and services that will make our dummy puppet life easier.
    
    
     In particular, we will create
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      A task that will find a random
     
     
      
       reachable location
      
     
    </li>
    <li>
     
      A service that will control the agent speed, depending on the
     
     
      
       battery level
      
     
    </li>
    <li>
     
      A service that will listen for battery
     
     
      
       status changes
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Behavior tree nodes can be implemented both in C++ and in Blueprint; for the purpose of this book, I will be sticking to the C++ option, but in
    
    <a href="B31016_09.xhtml#_idTextAnchor170">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Extending Behavior Trees
     
    </em>
    
     , I will give you some useful hints on how to work also with
    
    
     
      Blueprint classes.
     
    
   </p>
   <p>
    
     So, let’s start implementing new features for our
    
    
     
      dummy puppets!
     
    
   </p>
   <h2 id="_idParaDest-160">
    <a id="_idTextAnchor162">
    </a>
    
     Implementing the FindRandomLocation task
    
   </h2>
   <p>
    
     We will begin by
    
    <a id="_idIndexMarker347">
    </a>
    
     implementing the first node, which will enable the AI agent to search for a random actor in the level that has a specific tag.
    
    
     This functionality
    
    <a id="_idIndexMarker348">
    </a>
    
     will allow the agent to have a specific point to navigate toward, enhancing its precision in reaching
    
    
     
      its destination.
     
    
   </p>
   <p>
    
     To start implementing this node, from the Unreal Engine Editor, create a new C++ class that extends
    
    <strong class="bold">
     
      BTTaskNode
     
    </strong>
    
     , and name
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       BTTask_FindRandomLocation
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Open the
    
    <strong class="source-inline">
     
      BTTask_FindRandomLocation.h
     
    </strong>
    
     header file and add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
public:
UPROPERTY(EditAnywhere, Category="Blackboard")
FBlackboardKeySelector BlackboardKey;
UPROPERTY(EditAnywhere, Category="Dummy Task")
FName TargetTag;
virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp;   OwnerComp, uint8* NodeMemory) override;</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      BlackboardKey
     
    </strong>
    
     property will be used to declare which key should be used to store the random location once it has been found, while the
    
    <strong class="source-inline">
     
      TargetTag
     
    </strong>
    
     property will be used to find all available actors in the level in order to randomize a selection.
    
    
     Finally, the
    
    <strong class="source-inline">
     
      ExecuteTask()
     
    </strong>
    
     function will be called when the task node needs to be executed and will contain all the logic to randomize a target location.
    
    
     This function will need to return whether the task was successful
    
    
     
      or failed.
     
    
   </p>
   <p>
    
     Now, open
    
    <a id="_idIndexMarker349">
    </a>
    
     the
    
    <strong class="source-inline">
     
      BTTask_FindRandomLocation.cpp
     
    </strong>
    
     file, and as a first step, add the needed
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations at the top of the
    
    
     
      file itself:
     
    
   </p>
   <pre class="source-code">
#include "BehaviorTree/BlackboardComponent.h"
#include "Kismet/GameplayStatics.h"</pre>
   <p>
    
     Next, add
    
    <a id="_idIndexMarker350">
    </a>
    
     the
    
    <strong class="source-inline">
     
      ExecuteTask()
     
    </strong>
    
     
      function implementation:
     
    
   </p>
   <pre class="source-code">
EBTNodeResult::Type UBTTask_FindRandomLocation::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp,   uint8* NodeMemory)
{
    const auto BlackboardComp = OwnerComp.GetBlackboardComponent();
    if (BlackboardComp == nullptr) { return EBTNodeResult::Failed; }
    TArray&lt;AActor*&gt; TargetList;
    UGameplayStatics::GetAllActorsWithTag(GetWorld(), TargetTag,       TargetList);
    if(TargetList.Num() == 0) { return EBTNodeResult::Failed; }
    const auto RandomTarget = TargetList[FMath::RandRange       (0, TargetList.Num() - 1)];
    BlackboardComp-&gt;SetValueAsVector(BlackboardKey.SelectedKeyName,       RandomTarget-&gt;GetActorLocation());
    return EBTNodeResult::Succeeded;
}</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker351">
    </a>
    
     code gets the
    
    <strong class="source-inline">
     
      Blackboard
     
    </strong>
    
     component from
    
    <strong class="source-inline">
     
      OwnerComp
     
    </strong>
    
     and checks its validity.
    
    
     Then, it retrieves a list of actors with a specific tag, selecting a random element from that list.
    
    
     Then, it updates the Blackboard with the selected target’s location by using the
    
    <strong class="source-inline">
     
      SetValueAsVector()
     
    </strong>
    
     method.
    
    
     Note the use of
    
    <strong class="source-inline">
     
      EBTNodeResult::Succeeded
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      EBTNodeResult::Failed
     
    </strong>
    
     to return the result of all these operations; this is a requirement in
    
    <a id="_idIndexMarker352">
    </a>
    
     order to indicate to the behavior tree whether a task was successful
    
    
     
      or not.
     
    
   </p>
   <p>
    
     Now that we have completed this task node, we can move on to the next step, which involves creating
    
    
     
      a service.
     
    
   </p>
   <h2 id="_idParaDest-161">
    <a id="_idTextAnchor163">
    </a>
    
     Implementing the SpeedControl service
    
   </h2>
   <p>
    
     We
    
    <a id="_idIndexMarker353">
    </a>
    
     are now prepared to create our first custom service, which will monitor the character’s speed based on the battery charge.
    
    
     As you may remember from the previous chapter, a service is usually run at fixed intervals, and that’s exactly what we will do for the speed control service class – we will check the battery status and change
    
    <a id="_idIndexMarker354">
    </a>
    
     the character
    
    
     
      speed accordingly.
     
    
   </p>
   <p>
    
     To start implementing this class, from the Unreal Engine Editor, create a new C++ class that extends
    
    <strong class="bold">
     
      BTService
     
    </strong>
    
     , and name
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       BTService_SpeedControl
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Open the
    
    <strong class="source-inline">
     
      BTTask_SpeedControl.h
     
    </strong>
    
     header file, and in the
    
    <strong class="source-inline">
     
      public
     
    </strong>
    
     section, add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
protected:
  virtual void TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8*     NodeMemory, float DeltaSeconds) override;</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      TickNode()
     
    </strong>
    
     function that we are overriding will be executed on every node tick interval that this service is attached to.
    
    
     In order to call this function, the
    
    <strong class="source-inline">
     
      bNotifyTick
     
    </strong>
    
     needs to be set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     ; this value is already set by default, but it’s good to know if you need to disable it – something we’ll implement in the
    
    
     
      next service.
     
    
   </p>
   <p>
    
     We are ready to implement the service, so open the
    
    <strong class="source-inline">
     
      BT_Service_SpeedControl.cpp
     
    </strong>
    
     file and add the following
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations at
    
    
     
      the top:
     
    
   </p>
   <pre class="source-code">
#include "BaseDummyAIController.h"
#include "BaseDummyCharacter.h"</pre>
   <p>
    
     After
    
    <a id="_idIndexMarker355">
    </a>
    
     that, add
    
    <a id="_idIndexMarker356">
    </a>
    
     the
    
    
     <strong class="source-inline">
      
       TickNode()
      
     </strong>
    
    
     
      implementation:
     
    
   </p>
   <pre class="source-code">
void UBTService_SpeedControl::TickNode(UBehaviorTreeComponent&amp;   OwnerComp, uint8* NodeMemory, float DeltaSeconds)
{
    Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);
    const auto AIController = Cast&lt;ABaseDummyAIController&gt;(OwnerComp.      GetAIOwner());
    if (!AIController) return;
    const auto ControlledCharacter = Cast&lt;ABaseDummyCharacter&gt;      (AIController-&gt;GetPawn());
    if (!ControlledCharacter) return;
    switch (ControlledCharacter-&gt;GetBatteryStatus())
    {
      case EBatteryStatus::EBS_Empty:
          break;
      case EBatteryStatus::EBS_Low:
          ControlledCharacter-&gt;SetWalkSpeed();
          break;
      case EBatteryStatus::EBS_Medium:
      case EBatteryStatus::EBS_Full:
          ControlledCharacter-&gt;SetRunSpeed();
          break;
    }
}</pre>
   <p>
    
     This function is quite straightforward; all it does is update the speed of the controlled character based on the character’s
    
    
     
      battery status.
     
    
   </p>
   <p>
    
     At this stage, you might be wondering why we retrieve the AI controller and character reference at every tick instead of storing them.
    
    
     It may seem inefficient in terms of computational power, but it’s important to remember that the behavior tree is a shared asset.
    
    
     This means that a single instance of the behavior tree – and its nodes – will be executed for all AI agents that use it.
    
    
     Hence, storing a class reference would not yield any
    
    <a id="_idIndexMarker357">
    </a>
    
     advantages and
    
    <a id="_idIndexMarker358">
    </a>
    
     could result in
    
    
     
      unpredictable behaviors.
     
    
   </p>
   <p>
    
     If there is a genuine need to store a reference, you would need to create a node instance, which is precisely what we will do with the
    
    
     
      upcoming service.
     
    
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor164">
    </a>
    
     Implementing the BatteryCheck service
    
   </h2>
   <p>
    
     The second service we
    
    <a id="_idIndexMarker359">
    </a>
    
     are about to create is going to be a bit more challenging than the previous one.
    
    
     We need to continuously monitor any changes in the battery
    
    <a id="_idIndexMarker360">
    </a>
    
     status; the most straightforward approach would be to use the node tick to constantly check the character’s battery status, similar to how the
    
    <strong class="source-inline">
     
      UBTService_SpeedControl
     
    </strong>
    
     class operates.
    
    
     However, as we learned earlier in this chapter, the dummy character dispatches battery status events.
    
    
     So, why not leverage this feature and make use
    
    
     
      of it?
     
    
   </p>
   <p>
    
     Let’s start implementing this service; from the Unreal Engine Editor, create a new C++ class that extends
    
    <strong class="bold">
     
      BTService
     
    </strong>
    
     and name
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       BTService_BetteryCheck
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Once the files have been created, open the
    
    <strong class="source-inline">
     
      BTService_BatteryCheck.h
     
    </strong>
    
     file, and just after the
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     section, add the following
    
    
     
      forward declarations:
     
    
   </p>
   <pre class="source-code">
class ABaseDummyCharacter;
enum class EBatteryStatus : uint8;</pre>
   <p>
    
     Then, add the
    
    <strong class="source-inline">
     
      public
     
    </strong>
    
     section and the
    
    
     
      constructor declaration:
     
    
   </p>
   <pre class="source-code">
public:
UBTService_BatteryCheck();</pre>
   <p>
    
     Just after that, declare the
    
    <strong class="source-inline">
     
      protected
     
    </strong>
    
     section, along with all the
    
    
     
      necessary properties:
     
    
   </p>
   <pre class="source-code">
protected:
UPROPERTY()
UBlackboardComponent* BlackboardComponent = nullptr;
UPROPERTY()
ABaseDummyCharacter* ControlledCharacter = nullptr;
UPROPERTY(BlueprintReadOnly, EditAnywhere, Category="Blackboard")
FBlackboardKeySelector IsLowOnBatteryKey;
UPROPERTY(BlueprintReadOnly, EditAnywhere, Category="Blackboard")
FBlackboardKeySelector IsBatteryDepletedKey;</pre>
   <p>
    
     As you can see, we are
    
    <a id="_idIndexMarker361">
    </a>
    
     doing something
    
    <a id="_idIndexMarker362">
    </a>
    
     slightly different from the previous service; we are declaring a reference to the
    
    <strong class="source-inline">
     
      Blackboard
     
    </strong>
    
     component and the character.
    
    
     In this case, we will work with node instances, so each AI agent will have its own separate instance of the node decorated by this service.
    
    
     We also declare two Blackboard keys to assign the proper values to
    
    
     
      the Blackboard.
     
    
   </p>
   <p>
    
     Just after that, add the
    
    <a id="_idIndexMarker363">
    </a>
    
     
      following functions:
     
    
   </p>
   <pre class="source-code">
virtual void OnBecomeRelevant(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;
virtual void OnCeaseRelevant(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;
UFUNCTION()
void OnBatteryStatusChange(EBatteryStatus NewBatteryStatus);</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      OnBecomeRelevant()
     
    </strong>
    
     function will be called when the decorated node becomes active, while the
    
    <strong class="source-inline">
     
      OnCeaseRelevant()
     
    </strong>
    
     function is no longer active.
    
    
     We will use these two functions to register the battery status events and react accordingly by using the
    
    
     <strong class="source-inline">
      
       OnBatteryStatusChange()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     You can now open
    
    <a id="_idIndexMarker364">
    </a>
    
     the
    
    <strong class="source-inline">
     
      BTService_BatteryCheck.cpp
     
    </strong>
    
     file to start implementing the functions.
    
    
     As
    
    <a id="_idIndexMarker365">
    </a>
    
     a first step, add the needed
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations at the top of
    
    
     
      the file:
     
    
   </p>
   <pre class="source-code">
#include "BaseDummyAIController.h"
#include "BaseDummyCharacter.h"
#include "BatteryStatus.h"
#include "BehaviorTree/BlackboardComponent.h"</pre>
   <p>
    
     Immediately after that, add the
    
    
     
      constructor implementation:
     
    
   </p>
   <pre class="source-code">
UBTService_BatteryCheck::UBTService_BatteryCheck()
{
    bCreateNodeInstance = true;
    bNotifyBecomeRelevant = true;
    bNotifyCeaseRelevant = true;
    bNotifyTick = false;
}</pre>
   <p>
    
     Although it may appear that we are simply setting some flags, we are actually making a significant change to the behavior of this service.
    
    
     First, we create a node instance; each AI agent will have its own instance of this service.
    
    
     Next, we disable the service tick, as we won’t be needing it, and we activate the
    
    
     
      relevancy behavior.
     
    
   </p>
   <p>
    
     Next, let’s
    
    <a id="_idIndexMarker366">
    </a>
    
     implement
    
    <a id="_idIndexMarker367">
    </a>
    
     the
    
    
     <strong class="source-inline">
      
       OnBatteryStatusChange()
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <pre class="source-code">
void UBTService_BatteryCheck::OnBatteryStatusChange(const EBatteryStatus NewBatteryStatus)
{
    switch (NewBatteryStatus)
    {
    case EBatteryStatus::EBS_Empty:
       BlackboardComponent-&gt;SetValueAsBool(IsBatteryDepletedKey.         SelectedKeyName, true);
       break;
    case EBatteryStatus::EBS_Low:
       BlackboardComponent-&gt;SetValueAsBool(IsLowOnBatteryKey.         SelectedKeyName, true);
       BlackboardComponent-&gt;SetValueAsBool(IsBatteryDepletedKey.         SelectedKeyName, false);
       break;
    case EBatteryStatus::EBS_Medium:
       break;
    case EBatteryStatus::EBS_Full:
       BlackboardComponent-&gt;SetValueAsBool(IsLowOnBatteryKey.         SelectedKeyName, false);
       break;
    }
}</pre>
   <p>
    
     There is nothing
    
    <a id="_idIndexMarker368">
    </a>
    
     fancy here; we just set the Blackboard keys based on the new battery status.
    
    
     After that, we implement the two
    
    
     
      remaining
     
    
    
     <a id="_idIndexMarker369">
     </a>
    
    
     
      functions:
     
    
   </p>
   <pre class="source-code">
void UBTService_BatteryCheck::OnBecomeRelevant(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)
{
    Super::OnBecomeRelevant(OwnerComp, NodeMemory);
    BlackboardComponent = OwnerComp.GetBlackboardComponent();
   const ABaseDummyAIController* AIController =      Cast&lt;ABaseDummyAIController&gt;(OwnerComp.GetAIOwner());
    if (!AIController) return;
    APawn* ControlledPawn = AIController-&gt;GetPawn();
    if (!ControlledPawn) return;
    ControlledCharacter = Cast&lt;ABaseDummyCharacter&gt;(ControlledPawn);
    if (!ControlledCharacter) return;
    ControlledCharacter-&gt;OnBatteryStatusChanged.AddDynamic       (this, &amp;UBTService_BatteryCheck::OnBatteryStatusChange);
}
void UBTService_BatteryCheck::OnCeaseRelevant(UBehaviorTreeComponent&amp;   OwnerComp, uint8* NodeMemory)
{
    Super::OnCeaseRelevant(OwnerComp, NodeMemory);
    ControlledCharacter-&gt;OnBatteryStatusChanged.RemoveDynamic       (this, &amp;UBTService_BatteryCheck::OnBatteryStatusChange);
}</pre>
   <p>
    
     These two
    
    <a id="_idIndexMarker370">
    </a>
    
     functions register and unregister the
    
    <strong class="source-inline">
     
      OnBatteryStatusChanged
     
    </strong>
    
     delegate; additionally,
    
    <strong class="source-inline">
     
      OnBecomeRelevantFunction()
     
    </strong>
    
     saves a reference to the Blackboard component and the AI controller – something
    
    <a id="_idIndexMarker371">
    </a>
    
     we can do because we use an instanced node for
    
    
     
      this service.
     
    
   </p>
   <p>
    
     In this extensive section, you acquired the knowledge to create custom tasks and services in C++.
    
    
     Often, the pre-built classes provided by Unreal Engine may not suffice to create engaging AI behaviors.
    
    
     Hence, it becomes essential to develop your own distinctive nodes.
    
    
     In the forthcoming section, we will create such new classes to construct a fully operational
    
    
     
      AI agent.
     
    
   </p>
   <h1 id="_idParaDest-163">
    <a id="_idTextAnchor165">
    </a>
    
     Setting up a behavior tree on an agent
    
   </h1>
   <p>
    
     To begin delving into the AI agent behavior tree, the first step is to compile the entire project.
    
    
     Once the process is finished, your custom tasks and services will be available as an option in the
    
    
     
      behavior tree.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     If you are unfamiliar with the Unreal Engine compilation process, my advice is to take a peek at
    
    <em class="italic">
     
      Appendix A
     
    </em>
    
     ,
    
    <em class="italic">
     
      Understanding C++ in Unreal Engine
     
    </em>
    
     , and then return to
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Once the compilation phase is finished, we can start editing the
    
    
     
      behavior tree.
     
    
   </p>
   <h2 id="_idParaDest-164">
    <a id="_idTextAnchor166">
    </a>
    
     Editing the behavior tree
    
   </h2>
   <p>
    
     Open the
    
    <strong class="bold">
     
      BT_RoamerDummy
     
    </strong>
    
     asset we
    
    <a id="_idIndexMarker372">
    </a>
    
     previously created and locate the only element – the
    
    <strong class="bold">
     
      ROOT
     
    </strong>
    
     node – present in the graph; you will see that it has a darker area at
    
    
     
      the bottom.
     
    
   </p>
   <div><div><img alt="Figure 8.11 – The ROOT node" src="img/B31016_figure_08.11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.11 – The ROOT node
    
   </p>
   <p>
    
     Clicking and dragging from this area will make all the nodes that can be connected to the
    
    <strong class="bold">
     
      ROOT
     
    </strong>
    
     
      node available.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Moving forward, whenever I mention the task of adding a node, I will be requesting that you perform the aforementioned action.
    
    
     One such case is depicted in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .12
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="img" role="presentation" src="img/B31016_figure_08.12.jpg"/>
     
    </div>
   </div>
   <p class="callout">
    
     
      Figure 8
     
    
    
     
      .12 – Adding
     
    
    
     
      a node
     
    
   </p>
   <p>
    
     To get started, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Composites
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Sequence
      
     </strong>
     
      node to the
     
     <strong class="bold">
      
       Root
      
     </strong>
     
      node, and in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, rename it
     
     
      <strong class="source-inline">
       
        Root Sequence
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Root Sequence
      
     </strong>
     
      node, add a
     
     <strong class="bold">
      
       Tasks
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        FindRandomLocation
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      With the newly created node selected, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      dropdown value
     
     
      
       to
      
     
     
      <strong class="bold">
       
        TargetLocation
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Root Sequence
      
     </strong>
     
      node, add a
     
     <strong class="bold">
      
       Composites
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Selector
      
     </strong>
     
      node at the right of the
     
     
      <strong class="bold">
       
        FindRandomLocation
       
      </strong>
     
     
      
       node.
      
     
     <p class="list-inset">
      
       Your graph
      
      <a id="_idIndexMarker373">
      </a>
      
       should now be similar to the one depicted in
      
      
       <em class="italic">
        
         Figure 8
        
       </em>
      
      
       <em class="italic">
        
         .13
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 8.13 – The initial behavior tree" src="img/B31016_figure_08.13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.13 – The initial behavior tree
    
   </p>
   <p class="list-inset">
    
     We now need to decorate the
    
    <strong class="bold">
     
      Selector
     
    </strong>
    
     node to give it extra abilities.
    
    
     To do so, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li value="5">
     
      Right-click on the
     
     <strong class="bold">
      
       Selector
      
     </strong>
     
      node and select
     
     <strong class="bold">
      
       Add Decorator
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        Conditional Loop
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click one more time and select
     
     <strong class="bold">
      
       Add Service
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        Battery Check
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click on the
     
     <strong class="bold">
      
       Conditional Loop
      
     </strong>
     
      decorator, and in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      attribute dropdown to
     
     <strong class="bold">
      
       TargetLocation
      
     </strong>
     
      .
     
     
      The
     
     <strong class="bold">
      
       Key Query
      
     </strong>
     
      attribute should be left to
     
     
      <strong class="bold">
       
        Is Set
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click on the
     
     <strong class="bold">
      
       BatteryCheck
      
     </strong>
     
      service, and in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Is Low on Battery Key
        
       </strong>
       
        dropdown value
       
       
        
         to
        
       
       
        <strong class="bold">
         
          IsLowOnBattery
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Is Battery Depleted Key
        
       </strong>
       
        dropdown value
       
       
        
         to
        
       
       
        <strong class="bold">
         
          IsBatteryDepleted
         
        </strong>
       
       
        
         .
        
       
      </li>
     </ul>
     <p class="list-inset">
      
       The
      
      <strong class="bold">
       
        Selector
       
      </strong>
      
       node should now look similar to
      
      
       <em class="italic">
        
         Figure 8
        
       </em>
      
      
       <em class="italic">
        
         .14
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 8.14 – The decorated Selector node" src="img/B31016_figure_08.14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.14 – The decorated Selector node
    
   </p>
   <p class="list-inset">
    
     Note that the
    
    <strong class="bold">
     
      BatteryCheck
     
    </strong>
    
     service should show a
    
    <strong class="bold">
     
      never ticks
     
    </strong>
    
     comment; this is what we set when we implemented the
    
    
     
      C++ class.
     
    
   </p>
   <p class="list-inset">
    
     What we
    
    <a id="_idIndexMarker374">
    </a>
    
     have done so far is basically the main loop of the AI agent behavior; we start by finding a target location for the AI agent, and then we execute a
    
    <strong class="bold">
     
      Selector
     
    </strong>
    
     node that will be waiting for battery status notifications.
    
    
     The
    
    <strong class="bold">
     
      Conditional Loop
     
    </strong>
    
     decorator will keep on repeating the child nodes (still to be added) while the
    
    <strong class="bold">
     
      TargetLocation
     
    </strong>
    
     key
    
    
     
      is set.
     
    
   </p>
   <p class="list-inset">
    
     Now, we will focus on the
    
    <strong class="bold">
     
      Selector
     
    </strong>
    
     node and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li value="9">
     
      Add a
     
     <strong class="bold">
      
       Composite
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Sequence
      
     </strong>
     
      child node and rename it
     
     
      <strong class="source-inline">
       
        Roam Sequence
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Task
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      child node, and in its
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Wait Time
        
       </strong>
       
        value
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          8.0
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Random Deviation
        
       </strong>
       
        value
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          2.0
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Node Name
        
       </strong>
       
        as
       
       
        <strong class="source-inline">
         
          Recharge Battery
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       We need to decorate the
      
      <strong class="bold">
       
        Roam Sequence
       
      </strong>
      
       node with extra capabilities, so we do
      
      
       
        the following:
       
      
     </p>
    </li>
    <li>
     
      Right-click on the
     
     <strong class="bold">
      
       Roam Sequence
      
     </strong>
     
      node and select
     
     <strong class="bold">
      
       Add Decorator
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        Blackboard
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      With the decorator selected, do the following in the
     
     
      <strong class="bold">
       
        Details
       
      </strong>
     
     
      
       panel:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Notify Observers
        
       </strong>
       
        dropdown value to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          Value Change
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Observer aborts
        
       </strong>
       
        dropdown value
       
       
        
         to
        
       
       
        <strong class="bold">
         
          Self
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Key Query
        
       </strong>
       
        dropdown value to
       
       <strong class="bold">
        
         Is
        
       </strong>
       
        <strong class="bold">
         
          Not Set
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Blackboard Key
        
       </strong>
       
        dropdown value
       
       
        
         to
        
       
       
        <strong class="bold">
         
          IsBatteryDepleted
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       This portion of the graph should now look like
      
      
       <em class="italic">
        
         Figure 8
        
       </em>
      
      
       <em class="italic">
        
         .15
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 8.15 – The roam loop" src="img/B31016_figure_08.15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.15 – The roam loop
    
   </p>
   <p class="list-inset">
    
     This portion of the graph will constantly loop between two phases – a roam sequence and a
    
    <strong class="bold">
     
      Wait
     
    </strong>
    
     node.
    
    
     The AI agent will stay in the roam sequence until the battery has been depleted.
    
    
     After that, it will stay still for between 6 and 10 seconds (so that the battery will recharge) and then revert
    
    
     
      to roaming.
     
    
   </p>
   <p class="list-inset">
    
     The last step we need to
    
    <a id="_idIndexMarker375">
    </a>
    
     take is to implement the roaming nodes.
    
    
     To do this, from the
    
    <strong class="bold">
     
      Roam Sequence
     
    </strong>
    
     node, do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li value="13">
     
      Add a
     
     <strong class="bold">
      
       Tasks
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Move To
      
     </strong>
     
      node, and in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      dropdown value
     
     
      
       to
      
     
     
      <strong class="bold">
       
        TargetLocation
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Tasks
      
     </strong>
     
      |
     
     <strong class="bold">
      
       FindRandomLocation
      
     </strong>
     
      node and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Target Tag
      
     </strong>
     
      value
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        TargetPoint
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Tasks
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      node, leaving its properties to their
     
     
      
       default values.
      
     
    </li>
    <li>
     
      We need to add extra functionality to the
     
     <strong class="bold">
      
       Move To
      
     </strong>
     
      node, so right-click on it and select
     
     <strong class="bold">
      
       Add Service
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Speed Control
      
     </strong>
     
      .
     
     
      This portion of the graph should look like
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .16
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.16 – The roam sequence" src="img/B31016_figure_08.16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.16 – The roam sequence
    
   </p>
   <p>
    
     What we are doing
    
    <a id="_idIndexMarker376">
    </a>
    
     here is pretty straightforward; we try to reach the target point and, once reached, search for another one, and then get some well-deserved rest by waiting a random time interval.
    
    
     While moving, we constantly check the battery status, changing the speed of the AI
    
    
     
      agent accordingly.
     
    
   </p>
   <p>
    
     Great news!
    
    
     The behavior tree graph has been completed.
    
    
     Now, we can attach it to our dummy puppet and witness its behavior.
    
    
     However, before we proceed, we need to create some suitable Blueprints to ensure that everything
    
    
     
      functions smoothly.
     
    
   </p>
   <h2 id="_idParaDest-165">
    <a id="_idTextAnchor167">
    </a>
    
     Creating the AI agent Blueprints
    
   </h2>
   <p>
    
     When working with Unreal
    
    <a id="_idIndexMarker377">
    </a>
    
     Engine, it is considered good practice to create a Blueprint from a C++ class.
    
    
     This approach offers several advantages, such as flexibility and extensibility, that contribute to a more efficient development process.
    
    
     That’s why we are going to create some Blueprints from our previously
    
    
     
      created classes.
     
    
   </p>
   <h3>
    
     Creating the controller Blueprint
    
   </h3>
   <p>
    
     Let’s start by
    
    <a id="_idIndexMarker378">
    </a>
    
     extending the
    
    <strong class="source-inline">
     
      BaseDummyAIController
     
    </strong>
    
     class into a Blueprint.
    
    
     To do so, in your
    
    <strong class="bold">
     
      Content Browser
     
    </strong>
    
     , create a new folder, name it
    
    <strong class="source-inline">
     
      Blueprints
     
    </strong>
    
     , and then follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new Blueprint class deriving from
     
     <strong class="bold">
      
       BaseDummyAIController
      
     </strong>
     
      , and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        AIRoamerDummyController
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open it, and in the
     
     <strong class="bold">
      
       Class Defaults
      
     </strong>
     
      panel, look for the
     
     <strong class="bold">
      
       Dummy AI Controller
      
     </strong>
     
      category and set the
     
     <strong class="bold">
      
       Behavior Tree
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        BT_RoamerDummy
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.17 – Assigning the behavior tree" src="img/B31016_figure_08.17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.17 – Assigning the behavior tree
    
   </p>
   <p>
    
     This is all you
    
    <a id="_idIndexMarker379">
    </a>
    
     need to do to set up the AI controller for the roamer dummy character; we will now create the
    
    
     
      dedicated character.
     
    
   </p>
   <h3>
    
     Creating the character Blueprint
    
   </h3>
   <p>
    
     To create a
    
    <a id="_idIndexMarker380">
    </a>
    
     character Blueprint, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder of your
     
     <strong class="bold">
      
       Content Browser
      
     </strong>
     
      create a new Blueprint class deriving from
     
     <strong class="bold">
      
       BaseDummyCharacter
      
     </strong>
     
      , and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        BP_RoamerDummyCharacter
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open it, and in the
     
     <strong class="bold">
      
       Class Defaults
      
     </strong>
     
      panel, look for the
     
     <strong class="bold">
      
       AI Controller Class
      
     </strong>
     
      attribute located in the
     
     <strong class="bold">
      
       Pawn
      
     </strong>
     
      category.
     
     
      From the dropdown menu,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        AIRoamerDummyController
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Congratulations on creating your very own roamer agent!
    
    
     Now, we just need to add one final touch to make it even better – a
    
    
     
      battery indicator.
     
    
   </p>
   <h3>
    
     Adding cosmetics
    
   </h3>
   <p>
    
     To provide
    
    <a id="_idIndexMarker381">
    </a>
    
     visual feedback on the AI agent’s status, we will create a component that displays the battery charge level through a light.
    
    
     This visual indicator will adjust the intensity of the light based on the current charge level.
    
    
     The higher the charge, the more intense the light will be.
    
    
     This will allow users to easily gauge the agent’s battery status at a glance, enhancing the overall user experience and ensuring they are aware of the agent’s
    
    
     
      power level.
     
    
   </p>
   <p>
    
     Let’s start by creating a new C++ class that inherits from the
    
    <strong class="source-inline">
     
      StaticMeshComponent
     
    </strong>
    
     class, calling it
    
    <strong class="source-inline">
     
      BatteryInjdicatorComponent
     
    </strong>
    
     .
    
    
     Once the class has been created, open the
    
    <strong class="source-inline">
     
      BatteryIndicatorComponent.h
     
    </strong>
    
     file and replace the
    
    <strong class="source-inline">
     
      UCLASS()
     
    </strong>
    
     line with the
    
    
     
      following one:
     
    
   </p>
   <pre class="source-code">
UCLASS(BlueprintType, Blueprintable, ClassGroup="Unreal Agility Arena", meta=(BlueprintSpawnableComponent))</pre>
   <p>
    
     This will make the component accessible to Blueprints.
    
    
     Then, after the
    
    <strong class="source-inline">
     
      GENERATED_BODY()
     
    </strong>
    
     line of code, add the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
public:
UBatteryIndicatorComponent();
protected:
UPROPERTY()
UMaterialInstanceDynamic* DynamicMaterialInstance;
virtual void BeginPlay() override;
UFUNCTION()
void OnBatteryStatusChange(EBatteryStatus NewBatteryStatus);</pre>
   <p>
    
     The only
    
    <a id="_idIndexMarker382">
    </a>
    
     things that need an explanation here are the
    
    <strong class="source-inline">
     
      DynamicMaterialInstance
     
    </strong>
    
     property, which will be used to change the material intensity property to make it more or less bright, and the
    
    <strong class="source-inline">
     
      OnBatteryStatusChange()
     
    </strong>
    
     function, which will be used to handle battery status
    
    
     
      change events.
     
    
   </p>
   <p>
    
     Now, to start implementing the component, open the
    
    <strong class="source-inline">
     
      BatteryIndicatorComponent.cpp
     
    </strong>
    
     file, and add the following declaration at the top
    
    
     
      of it:
     
    
   </p>
   <pre class="source-code">
#include "BaseDummyCharacter.h"</pre>
   <p>
    
     The constructor just needs to set the static mesh asset, so add this piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
UBatteryIndicatorComponent::UBatteryIndicatorComponent()
{
    static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;       StaticMeshAsset(
       TEXT("/Game/_GENERATED/MarcoSecchi/SM_HeadLight.SM_         Headlight"));
    if (StaticMeshAsset.Succeeded())
    {
       UStaticMeshComponent::SetStaticMesh(StaticMeshAsset.Object);
    }
}</pre>
   <p>
    
     Next, implement
    
    <a id="_idIndexMarker383">
    </a>
    
     the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     function by adding this block
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
void UBatteryIndicatorComponent::BeginPlay()
{
    Super::BeginPlay();
    ABaseDummyCharacter* Owner =       Cast&lt;ABaseDummyCharacter&gt;(GetOwner());
    if(Owner == nullptr) return;
    AttachToComponent(Owner-&gt;GetMesh(),       FAttachmentTransformRules::SnapToTargetIncludingScale, "helmet");
    DynamicMaterialInstance = this-&gt;CreateDynamicMaterialInstance       (1, GetMaterial(1));
   Owner-&gt;OnBatteryStatusChanged.AddDynamic      (this, &amp;UBatteryIndicatorComponent::OnBatteryStatusChange);
}</pre>
   <p>
    
     In this function, we check whether the owner of this component is an instance of the
    
    <strong class="source-inline">
     
      BaseDummyCharacter
     
    </strong>
    
     class.
    
    
     Next, we attach this component to the owner’s mesh component on
    
    <a id="_idIndexMarker384">
    </a>
    
     a socket named
    
    <strong class="bold">
     
      helmet
     
    </strong>
    
     – a socket I already provided for you in the dummy skeletal mesh, as you can see in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .18
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.18 – The helmet socket" src="img/B31016_figure_08.18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.18 – The helmet socket
    
   </p>
   <p>
    
     After that, we create a dynamic material instance for this component – this will let us modify the material properties at runtime.
    
    
     Finally, we add an event handler to the
    
    <strong class="source-inline">
     
      OnBatteryStatusChanged
     
    </strong>
    
     event of the owner character, which calls the
    
    <strong class="source-inline">
     
      OnBatteryStatusChange
     
    </strong>
    
     function of this component whenever the battery status of the owner
    
    
     
      character changes.
     
    
   </p>
   <p>
    
     With this function complete, we just need to add the event handler to
    
    
     
      our code:
     
    
   </p>
   <pre class="source-code">
void UBatteryIndicatorComponent::OnBatteryStatusChange(EBatteryStatus NewBatteryStatus)
{
    const auto BatteryValue = StaticCast&lt;float&gt;(NewBatteryStatus);
    const auto Intensity = (BatteryValue - 1.f) * 25.f;
    DynamicMaterialInstance-&gt;SetScalarParameterValue(FName       ("Intensity"), Intensity);
}</pre>
   <p>
    
     Here, we
    
    <a id="_idIndexMarker385">
    </a>
    
     convert the
    
    <strong class="source-inline">
     
      NewBatteryStatus
     
    </strong>
    
     enum to a
    
    <strong class="source-inline">
     
      float
     
    </strong>
    
     value, calculate the light intensity, and then set a scalar parameter,
    
    <strong class="source-inline">
     
      Intensity
     
    </strong>
    
     , in the dynamic
    
    
     
      material instance.
     
    
   </p>
   <p>
    
     We can finally compile the project to make this component available to the character.
    
    
     Once the compilation process is finished, open the
    
    <strong class="bold">
     
      BP_RoamerDummy
     
    </strong>
    
     Blueprint and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="bold">
      
       Components
      
     </strong>
     
      panel, click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      <strong class="bold">
       
        Add
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      Select
     
     <strong class="bold">
      
       UnrealAgilityArena
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Battery Indicator
      
     </strong>
     
      to add this component to
     
     
      
       the character.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.19 – Adding a component" src="img/B31016_figure_08.19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.19 – Adding a component
    
   </p>
   <p>
    
     Your dummy character is all set and eagerly awaiting to be tested at a suitable
    
    
     
      gym level.
     
    
   </p>
   <h2 id="_idParaDest-166">
    <a id="_idTextAnchor168">
    </a>
    
     Testing an agent in a gym
    
   </h2>
   <p>
    
     We are now
    
    <a id="_idIndexMarker386">
    </a>
    
     ready to create a gym for our AI agent and see how it behaves.
    
    
     As you already know from
    
    <a href="B31016_04.xhtml#_idTextAnchor073">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a Navigation Mesh
     
    </em>
    
     , how to properly set up a gym with a nav mesh, I won’t dive into the creation details.
    
    
     Instead, I will give you some generic info about the level creation.
    
    
     Here is what you
    
    
     
      should do:
     
    
   </p>
   <ol>
    <li>
     
      Create a level of your choice, starting from the Level Instances and Packed Level Actors I provided in the
     
     
      
       project template
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       NavMeshBoundsVolume
      
     </strong>
     
      actor so that it will cover all the
     
     
      
       walkable areas
      
     
    </li>
    <li>
     
      Add some obstacles to make things
     
     
      
       more interesting
      
     
    </li>
    <li>
     
      Add one or more
     
     
      <strong class="bold">
       
        BP_RoamerDummyCharacter
       
      </strong>
     
     
      
       instances
      
     
    </li>
    <li>
     
      Add some
     
     <strong class="bold">
      
       NS_Target
      
     </strong>
     
      Niagara actors that will work as
     
     
      
       target points
      
     
    </li>
   </ol>
   <p>
    
     The only thing worth noting is that your AI agent will look for target points with the
    
    <strong class="bold">
     
      TargetPoint
     
    </strong>
    
     tag.
    
    
     If you are unfamiliar with the tag system, here’s how to tag
    
    
     
      your actors:
     
    
   </p>
   <ol>
    <li>
     
      For each
     
     <strong class="bold">
      
       NS_Target
      
     </strong>
     
      Niagara system, search for the
     
     <strong class="bold">
      
       Tags
      
     </strong>
     
      attribute located in the
     
     
      <strong class="bold">
       
        Details
       
      </strong>
     
     
      
       panel.
      
     
    </li>
    <li>
     
      Click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to add a
     
     
      
       new tag.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Index [0]
      
     </strong>
     
      field that will be created, insert
     
     <strong class="source-inline">
      
       TargetPoint
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 8
       
      </em>
     
     
      <em class="italic">
       
        .20
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.20 – The actor tag" src="img/B31016_figure_08.20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.20 – The actor tag
    
   </p>
   <p>
    
     Once your level is finished, you are ready to start testing it; mine is shown in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .21
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 8.21 – The finished level" src="img/B31016_figure_08.21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.21 – The finished level
    
   </p>
   <p>
    
     Upon starting
    
    <a id="_idIndexMarker387">
    </a>
    
     the simulation, you should see the following
    
    
     
      things happen:
     
    
   </p>
   <ul>
    <li>
     
      Depending on the starting battery charge (which is randomized), your AI agents will start to run, walk, or
     
     
      
       stand still
      
     
    </li>
    <li>
     
      They will try to reach a target point, and once reached, they will rest for about a second and then look for
     
     
      
       another one
      
     
    </li>
    <li>
     
      If the battery charge is low, they will start walking instead
     
     
      
       of running
      
     
    </li>
    <li>
     
      If the battery charge is depleted, they will stop, start recharging, and then start
     
     
      
       running again
      
     
    </li>
    <li>
     
      The headlight should be brighter when the AI agent is fully charged and turn off when
     
     <a id="_idIndexMarker388">
     </a>
     
      the battery
     
     
      
       is low
      
     
    </li>
   </ul>
   <p>
    
     That ends this section, where you have learned how to build a fully working behavior tree, including creating your customized tasks
    
    
     
      and services.
     
    
   </p>
   <h1 id="_idParaDest-167">
    <a id="_idTextAnchor169">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this quite lengthy chapter, you were introduced to the basics of creating a behavior tree in Unreal Engine.
    
    
     As you have learned, creating a fully working AI agent is a mixture of out-of-the-box features, custom classes, and a bit
    
    
     
      of ingenuity.
     
    
   </p>
   <p>
    
     We’re just getting started on a fascinating journey that will unfold in the upcoming chapters, starting with the next one, where we’ll dive into the intricate workings of tasks, services, and decorators.
    
    
     Get ready for a significant overhaul to your beloved
    
    
     
      dummy puppets!
     
    
   </p>
  </div>
 </body></html>