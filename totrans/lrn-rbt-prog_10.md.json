["```py\n$ pip3 install RPi.GPIO gpiozero\n```", "```py\n    import time\n    from gpiozero import DistanceSensor\n    ```", "```py\n    queue_len parameter. The GPIOZero library tries to collect 30 sensor readings before giving an output, which makes it smoother, but less responsive. And what we'll need for our robot is responsive, so we take it down to 2 readings. A tiny bit of smoothing, but totally responsive.\n    ```", "```py\n    while True:\n    ```", "```py\n        print(\"Left: {l}, Right: {r}\".format(\n    l=sensor_l.distance * 100, \n            r=sensor_r.distance * 100))\n    ```", "```py\n        time.sleep(0.1)\n    ```", "```py\n    pi@myrobot:~ $ python3 test_distance_sensors.py \n    Prepare GPIO Pins\n    Left: 6.565688483970461, Right: 10.483658125707734\n    Left: 5.200715097982538, Right: 11.58136928065528\n    ```", "```py\n    :.2f changes the way text is output, to state that there are always two decimal places. Because debug output can be essential to see what is going on in the robot, knowing how to refine it is a valuable skill.\n    ```", "```py\npi@myrobot:~ $ python3 test_distance_sensors.py \nPrepare GPIO Pins\nLeft: 6.56, Right: 10.48\nLeft: 5.20, Right: 11.58\n```", "```py\n    from Raspi_MotorHAT import Raspi_MotorHAT\n    from gpiozero import DistanceSensor\n    ```", "```py\n    class Robot:\n        def __init__(self, motorhat_addr=0x6f):\n            # Setup the motorhat with the passed in address\n            self._mh = Raspi_MotorHAT(addr=motorhat_addr)\n            # get local variable for each motor\n            self.left_motor = self._mh.getMotor(1)\n            self.right_motor = self._mh.getMotor(2)\n            # Setup The Distance Sensors\n            self.left_distance_sensor = DistanceSensor(echo=17, trigger=27, queue_len=2)\n            self.right_distance_sensor = DistanceSensor(echo=5, trigger=6, queue_len=2)\n            # ensure the motors get stopped when the code exits\n            atexit.register(self.stop_all)\n    ```", "```py\n    from robot import Robot\n    from time import sleep\n    ...\n    ```", "```py\n    ...\n    class ObstacleAvoidingBehavior:\n        \"\"\"Simple obstacle avoiding\"\"\"\n        def __init__(self, the_robot):\n            self.robot = the_robot\n            self.speed = 60\n            ...\n    ```", "```py\n        ...\n        def get_motor_speed(self, distance):\n            \"\"\"This method chooses a speed for a motor based on the distance from a sensor\"\"\"\n            if distance < 0.2:\n                return -self.speed\n            else:\n                return self.speed\n        ...\n    ```", "```py\n        ...\n        def run(self):\n            self.robot.set_pan(0)\n            self.robot.set_tilt(0)\n    ```", "```py\n            while True:\n                # Get the sensor readings in meters\n                left_distance = self.robot.left_distance_sensor.distance\n                right_distance = self.robot.right_distance_sensor.distance\n                ...\n    ```", "```py\n                ...\n                print(\"Left: {l:.2f}, Right: {r:.2f}\".format(l=left_distance, r=right_distance))\n                ...\n    ```", "```py\n                ...\n                # Get speeds for motors from distances\n                left_speed = self.get_motor_speed(left_distance)\n                self.robot.set_left(left_speed)\n                right_speed = self.get_motor_speed(right_distance)\n                self.robot.set_right(right_speed)\n    ```", "```py\n                ...\n                # Wait a little\n                sleep(0.05)\n    bot = Robot()\n    behavior = ObstacleAvoidingBehavior(bot)\n    behavior.run()\n    ```", "```py\n    ...\n        def get_speeds(self, nearest_distance):\n            if nearest_distance >= 1.0:\n                nearest_speed = self.speed\n                furthest_speed = self.speed\n                delay = 100\n            elif nearest_distance > 0.5:\n                nearest_speed = self.speed\n                furthest_speed = self.speed * 0.8\n                delay = 100\n            elif nearest_distance > 0.2:\n                nearest_speed = self.speed\n                furthest_speed = self.speed * 0.6\n                delay = 100\n            elif nearest_distance > 0.1:\n                nearest_speed = -self.speed * 0.4\n                furthest_speed = -self.speed\n                delay = 100\n            else: # collison\n                nearest_speed = -self.speed\n                furthest_speed = -self.speed\n                delay = 250\n            return nearest_speed, furthest_speed, delay\n    ...\n    ```", "```py\n        ...\n        def run(self):\n            # Drive forward\n            self.robot.set_pan(0)\n            self.robot.set_tilt(0)\n            while True:\n                # Get the sensor readings in meters\n                left_distance = self.robot.left_distance_sensor.distance\n                right_distance = self.robot.right_distance_sensor.distance            # Display this\n                self.display_state(left_distance, right_distance)\n                ...\n    ```", "```py\n    .format (which we used previously). Putting the letter prefix f in front of a string allows us to use local variables in curly brackets in the string. We are still able to use .2f to control the number of decimal places.\n    ```", "```py\n                ...\n                # Send this to the motors\n                if left_distance < right_distance:\n                    self.robot.set_left(nearest_speed)\n                    self.robot.set_right(furthest_speed)\n                else:\n                    self.robot.set_right(nearest_speed)\n                    self.robot.set_left(furthest_speed)\n                ...\n    ```", "```py\n                ...\n                # Wait our delay time\n                sleep(delay * 0.001)\n    ...\n    ```"]