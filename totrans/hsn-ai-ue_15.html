<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Debugging Methods for AI - Navigation, EQS, and Profiling</h1>
                </header>
            
            <article>
                
<p>  Welcome to <a href="a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml">Chapter 12</a>, <em>Debugging Methods for AI – Navigation, EQS, and Profiling</em>.</p>
<p>Here, we are going to explore some more specific tools for the AI systems that are built-in within Unreal Engine. We will focus on <strong>Navigation</strong> and <strong>EQS</strong>, covering what we have left out (because it was debugging and/or visualization related) respectively from <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em> and <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environment Querying System</em>.</p>
<p>At the end of the chapter, we will see some more tools for analyzing performance related to AI code. In the next chapter, we will complete the discussion by exploring the <strong>Gameplay Debugger</strong> as a way to have a quick real-time feedback for our AI.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Checking the execution of a behavior tree</li>
<li>Visualizing environmental queries with the EQS testing pawn and exploring how its settings can help to better understand the query</li>
<li>How to use the EQS profiler to spot queries that have performance issues and how to dive deeper to understand what causes the bad performance</li>
<li>Visualizing the navigation mesh and how it works under the hood</li>
<li>Using the navigation test actor to check the path between two points of the navigation mesh</li>
<li>Profiling by using <strong>AI Stat Groups</strong> to gather useful information regarding the performance of the AI systems</li>
<li>Creating a <strong>Custom Stat Group</strong>, to be able to analyze performance of your customized AI systems</li>
</ul>
<p>So, let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging behavior trees</h1>
                </header>
            
            <article>
                
<p>Before jumping into the rest of the chapter, we should learn how to debug behavior trees. Actually, there are many methods, and some we will explore later in this chapter (with stats) and in the next one (such as the gameplay debugger).</p>
<p>However, I wanted to point out that it is possible to see the execution of a behavior tree. If you leave the behavior tree editor open while you play the game, you will see highlighted the current branch being executed on the behavior tree, and which decorators are blocked. Also, in the blackboard panel, it is possible to check the current values for each of the blackboard values. Here is an example from the designing behavior trees project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42ab7ec3-d0c3-401a-8896-78021f9433e7.png"/></p>
<p>Also, if you have more than one <strong>enemy</strong> running a behavior tree, you can change which one to view from the top menu, as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/040c6342-c15c-4a20-978e-067a8eb6c95f.png"/></p>
<div class="packt_infobox">In the same way, it is possible to see the execution of blueprints as well. This is not strictly related to AI, but it was worthwhile mentioning it in an infobox.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profiling and visualizing environmental queries</h1>
                </header>
            
            <article>
                
<p>In this section, we will explore how to visualize and profile <strong>Environmental Queries</strong>. In fact, we will gain a better understanding of how the EQS testing pawn can visualize an <strong>Environment Query</strong>,<span> </span><span>and we will explore the <strong>Profiler</strong> tool, which allows us to check the performance for each query.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing environmental queries with the EQS testing pawn</h1>
                </header>
            
            <article>
                
<p>As anticipated back in <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environment Querying System</em>, there is a simple built-in way to visualize<span> e</span>nvironment queries<span> </span>within the game world, directly from the viewport; the game doesn't even have to be running. In fact, there is a special pawn that it is able to do that. However, this pawn cannot be brought directly into the level, because, to ensure that it is not misused, it has been declared virtual within the code base. This means that in order to use it, we need to create our own<span> b</span>lueprint pawn<span> </span>that inherits directly from this special pawn.</p>
<p>Thankfully, after this step, the pawn is fully featured, and it doesn't need any more code, just the parameters to work with (for example, the<span> e</span>nvironmental query<span> </span>you want to visualize).</p>
<div class="packt_infobox">You will need the environment-querying system to be enabled, check <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, Environment Querying System, to see how to do this.</div>
<p>If you already have created the EQS testing pawn back in <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environment Querying System</em>, feel free to skip the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the EQS testing pawn</h1>
                </header>
            
            <article>
                
<p>To start, create a new blueprint; the class to inherit from is<span> </span><strong>EQSTestingPawn</strong>, as shown in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1685 image-border" src="assets/19340aa3-643f-44ec-99ca-70510d0c24aa.png" style="width:37.92em;height:39.92em;"/></p>
<p>Then, you can rename it<span> </span><strong>MyEQSTestingPawn</strong>, or if you already have done this in <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environment Querying System</em>, you can either skip this part, or give it another name.</p>
<p>If you just drag it into the map from the<span> </span><strong>Details</strong> panel,<span> </span>you can change the<span> </span>EQS<span> </span>settings, as shown in the next screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1687 image-border" src="assets/daed137f-9ebd-460d-b793-8d9d69e2d505.png" style="width:33.50em;height:33.75em;"/></p>
<p>In <a href="1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml">Chapter 4</a>, <em>Environment Querying System</em>, we got this far, but now that we have some more time for debugging, let's dive in deeper.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a test environmental query</h1>
                </header>
            
            <article>
                
<p>We need an <strong>Environmental Query</strong> to perform, in order to visualize what's going on with the different settings. As such, we need to prepare a simple query that generates points in a grid, and then score them based on the distance from the <strong>Querier</strong>. So, let's build the environmental query, as<span> shown in the following screenshot (within the EQS editor):</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1688 image-border" src="assets/767467e2-d6c6-4bf9-bf33-a33f67fefdfa.png" style="width:23.50em;height:22.75em;"/></p>
<p><span>We are going to leave the default settings, but for your convenience, this is how a simple grid generator looks in the <strong>Details</strong><em> </em>panel:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1689 image-border" src="assets/b5ef130e-95d6-4f36-8660-3d6435f8ad1e.png" style="width:33.42em;height:17.33em;"/></p>
<p>For the <strong>Distance Test</strong>, instead, we are going to leave mainly the default values, but for showcase purposes, we can change the <strong>Filter </strong>settings, so that <strong>Float Value Min</strong> and <strong>Float Value Max</strong> are respectively 200 and 1,000. As a result, we will be able to filter out the points that are too close to the querier, and see how the EQS testing pawn visualizes these points:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Settings of the EQS testing pawn to visualize environmental queries</h1>
                </header>
            
            <article>
                
<p>Now let's explore the settings we have seen in the <strong>Details</strong><em> </em>panel of our <strong>MyEQSTestingPawn</strong><span>. For your convenience, here is the screenshot of the settings:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1690 image-border" src="assets/acb1aad9-0eb8-4a63-b4c6-2a235497b4b9.png" style="width:30.67em;height:30.08em;"/></p>
<div class="packt_infobox">Remember that you need to select the testing pawn in the level in order to visualize the query (and also a query template must be set).</div>
<ul>
<li><strong>Query Template</strong>: As the name suggests, it is the <strong>Environmental Query</strong> that we want to visualize.</li>
<li><strong>QueryParams_DEPRECATED</strong>: (<em>don't use this</em><span class="underline">)</span> This was the old way to set parameters for the environmental query; now please use <strong>Query Config</strong>.</li>
<li><strong>Query Config</strong>: It is an array that allows you to quickly change the settings of the <strong>Environmental Query</strong> for rapidly testing and debugging.</li>
<li><strong>Highlight Mode</strong>: It determines which locations (or items) should have a visual representation that is highlighted, which means having a big sphere, instead of a small one. The possible values that can assume are the following:
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>All</strong>: This means that all the locations or items are highlighted, and it is the default option; so it appears exactly as shown in the following screenshot, which is also how it appears by default once we set the <strong>Query Template</strong>: </li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1693 image-border" src="assets/2cb8774a-4889-4385-ae15-703afeaa9609.png" style="width:65.33em;height:44.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is an image of the viewport. The other (overlapped) information is not important here</div>
<ul>
<li style="list-style-type: none">
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Best 5%</strong>: As the name suggests, it shows just the points that have a score so that it is within the best 5% score of all the points. All the other points will have a smaller sphere:</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1694 image-border" src="assets/e2e05b1f-7b2d-4c97-bbe1-8c9552936257.png" style="width:63.00em;height:43.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is an image of the viewport. The other (overlapped) information is not important here</div>
<ul>
<li style="list-style-type: none">
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Best 25%</strong>: As the previous option does, it shows <span>just the points that have a score so that it is within the best 25% scores of all the points. All the other points will have a smaller sphere:</span></li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1695 image-border" src="assets/643ab23a-c080-4d09-96b7-103976a2babc.png" style="width:52.50em;height:35.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is an image of the viewport. The other (overlapped) information is not important here</div>
<ul>
<li><strong>Draw Labels</strong>: If checked, it shows next to the point its score. If a point has been filtered out instead, it shows which test has filtered that point out. In our example, the points closer to the querier have been filtered out by the <strong>Distance Test</strong>. This option is enabled by default; if we turn it off.</li>
</ul>
<ul>
<li><strong>Draw Failed Items</strong>: If checked, it shows also the points that have been filtered out. It is enabled by default, and if we turn it off, in our example, we would see the following:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1697 image-border" src="assets/a33ec4d8-10a2-4eb8-a824-915b17e0ec84.png" style="width:68.92em;height:47.17em;"/></p>
<ul>
<li><strong>Rerun Query Only on Finished Move</strong>: If checked, it will perform the query only when this testing pawn stops moving, and not all the time. It is enabled by default, and for performance reasons, you should keep this on, unless you need to visualize the query also when the testing pawn moves:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1699 image-border" src="assets/d836529e-48c5-47f0-8d11-da79274e0913.png" style="width:54.58em;height:37.42em;"/></p>
<ul>
<li><strong>Should Be Visible In Game</strong>: if checked, it will show the testing pawn as a small icon in the game, as in this screenshot; it is disabled by default:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1700 image-border" src="assets/bf91cc9b-7c30-447c-9265-323ef6daa805.png" style="width:11.42em;height:11.83em;"/></p>
<ul>
<li><strong>Tick During Game</strong>: As the name suggests, if it is checked, it allows ticking during the execution of the game.</li>
<li><strong>Querying Mode</strong>: Determines which is the final result of the query, and it has many possible options:
<ul>
<li><strong>All Matching</strong>: This is the default option; it shows all the points that match the query (the ones in blue have been filtered out). Moreover, the points are color-coded from orange to green based on the score, with green being the highest score of 1:</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1701 image-border" src="assets/5e31d31c-0e5a-443b-93d0-07da2c9c51bd.png" style="width:49.83em;height:34.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is an image of the viewport. The other (overlapped) information is not important here</div>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Single Best Item</strong>: Shows the point that has the highest score (hence the best one) in green, and all the others in a darker shade of green (the ones that have been filtered out are still in blue):</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1703 image-border" src="assets/4666fd57-8cb2-4f83-a53b-18cec5c794cb.png" style="width:44.75em;height:30.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is an image of the viewport. The other (overlapped) information is not important here</div>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Single Random Item from Best 5%</strong>: It shows (or returns) a random point among the best 5% of the points that have scored the highest. In the next example, a random one has been picked:</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1704 image-border" src="assets/beffb16f-3f05-4f6b-b996-558eec866529.png" style="width:48.92em;height:33.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is an image of the viewport. The other (overlapped) information is not important here</div>
<ul>
<li style="list-style-type: none">
<ul>
<li><span><strong>Single Random Item from Best 25%</strong>: It shows (or returns) a random point among the best 25% of the points that have scored the highest. In the next example, a random one has been picked:</span></li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1706 image-border" src="assets/e91ebb2f-1b07-49b5-9642-d3fb8bb856d5.png" style="width:48.50em;height:33.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is an image of the viewport. The other (overlapped) information is not important here</div>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Nav Agent Properties</strong>: Since some <strong>Environmental Queries</strong> depend on the navigation system, as we have seen, then this set of options let you tweak how the agent that performs the query appears to the navigation system. We are not going into detail regarding those, but here are the possible options:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1707 image-border" src="assets/916d3bd3-03ec-4fab-bd50-a5abe5621277.png" style="width:32.25em;height:19.83em;"/></p>
<p>And that concludes our discussion about visualizing environmental queries with the testing pawn. However, there is more about EQS in the next section, where we will see how we can profile an environmental query to check its performance, and in the next chapter, we will see how to visualize an environmental query at run time with the gameplay debugger.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profiling environmental queries</h1>
                </header>
            
            <article>
                
<p>In this section, we will learn how we can quickly profile environmental queries.</p>
<p>You may have noticed that in the EQS editor, next to the <strong>Details</strong> panel, there is a <strong>Profile</strong> tab, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1708 image-border" src="assets/37808d96-dcc5-41f0-b091-bf6bf0ba457a.png" style="width:23.08em;height:3.33em;"/></p>
<p>If we click on it, we will have a whole new section in which we will be able to quickly profile environmental queries. At the moment, it is empty, because the game is not running, and no environmental query is performed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1709 image-border" src="assets/2002efa5-2284-4dad-8b88-eec81cafcdaa.png" style="width:36.75em;height:7.42em;"/></p>
<p>If we have already have some queries running in the game, we could just press <strong>Play</strong> and come back to this menu with all the queries that are currently running. However, if you don't have any in your game, we could quickly create a behavior tree to run some queries, making this behavior tree run on an AI controller and finally assign this AI controller to some AI agent in the game. Since we have done this many times in the book, I'm not going to guide you step by step. However, the next section will provide an overview of the process, if you want to follow along. Otherwise, feel free to skip the next section, and go directly to the <em>Environmental query profiler</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the test assets for EQS profiling</h1>
                </header>
            
            <article>
                
<p>First, we need to create the environmental queries; you should already have these in the game since you would have been using them, but if you just want to test this profiling tool, create a couple of queries, for instance, <strong>EnvQueryA</strong> and <strong>EnvQueryB</strong>. I made the first query heavier than usual (many points generated) so that it stood out in the Profiler later on:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1710 image-border" src="assets/df3b2491-299e-4253-bcff-a63d2369b80e.png" style="width:28.08em;height:12.83em;"/></p>
<p>Then, we need to create a blackboard asset for the behavior tree; we can name it <strong>BB_EQSTesting</strong> and we just need a vector key inside it:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1711 image-border" src="assets/7eef7c9a-bc24-41b1-a952-b06f9bd3f7b4.png" style="width:19.50em;height:18.25em;"/></p>
<p>Next, we can create the behavior tree that runs the queries. Name it <kbd>BT_EQSTesting</kbd>, and assign within it the blackboard. Then, we can run the two queries one after another with a sequence node (along with a little delay). Remember to assign the query to the <kbd>Run Query</kbd> node, and use the vector key from the blackboard (so the query doesn't fail). The run mode should be by default set to <kbd>Single Best Item</kbd>; be sure that it is the option you have. Here is the behavior tree:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1712 image-border" src="assets/76c1f3d4-9dae-4798-9bfa-753a2926f473.png" style="width:41.50em;height:25.08em;"/></p>
<p>Now we need an AI controller; for simplicity, we can create it in Blueprint and name it <strong>B</strong><span><em>P_EQSTestingAIController</em></span><span>. Override the</span> <strong>On Possess</strong> <span>function, and run the</span> <span>b</span><em>ehavior tree</em><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1713 image-border" src="assets/dd15afe8-1463-42ef-baa0-9748355642d7.png" style="width:34.58em;height:11.58em;"/></p>
<p>Finally, create an AI agent in the level (you can duplicate the player if you start form the <strong>Third-Person</strong> <strong>Example Map</strong>) and assign the freshly created AI controller:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1714 image-border" src="assets/fe4edd70-3fa6-4e88-bcaa-a695837da3d9.png" style="width:28.75em;height:14.00em;"/></p>
<p>Now we are ready to see the profiler in action!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The environmental query profiler</h1>
                </header>
            
            <article>
                
<p>If you reach this far, you should press Play and have an environmental query running in your game. If so, when the game is running, the Profiler tab of the EQS editor will get filled with all the environmental query<span> </span> <span>running</span>, and it shows stats for them:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1715 image-border" src="assets/029c04ca-1423-48f6-8d7d-8a0eaa212241.png" style="width:33.33em;height:20.42em;"/></p>
<p>For each query type, the profiler shows the number of times it got executed, the maximum time taken from the worst of these queries, and their average time.</p>
<div class="packt_infobox"><span>As you can see, </span><strong>EnvQueryA<span> </span></strong><span>is very heavy (because I designed it so), and the profiler helps you understand which one needs to be changed/improved or even removed. Also, we will see red because it's run time is very bad. For <strong>EnvQueryB</strong>, we would see any of these things.</span></div>
<p>Moreover, the profiler divides the queries based also on the run mode. In the following screenshot, <strong>EnvQueryB</strong> has two entries, based on whether the run mode was <strong>Single Result</strong> or <strong>All Matching</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1717 image-border" src="assets/537d7993-557e-4691-bdf2-6160b603cf37.png" style="width:33.08em;height:20.83em;"/></p>
<p>Of course, when you see the Profiler tab, you have the EQS editor opened on a specific query. Thus, at the bottom of the profiler, there is some more information about the query whose EQS editor is currently opened. In fact, we can see a graph showing the <strong>Load of EQS tick budget</strong> (how heavy was its tick) for the query.</p>
<p>Finally, at the top, there is the number of how many types of queries have been recorded so far and a checkbox named <strong>Show details for current query</strong>. If we check this box, we will be able to see directly on the environmental query tree the worst and<strong> </strong>the average time for each generator (and its pick rate), and for each test, we have the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1718 image-border" src="assets/5887d2de-4d32-4599-a7b1-d5a4aa0f08f0.png" style="width:28.92em;height:24.58em;"/></p>
<p><span>It is color-coded here as well:</span></p>
<ul>
<li><span><strong>Red</strong> means a very bad performance.</span></li>
<li><span><strong>Yellow</strong> means an intermediate performance.</span></li>
<li><span><strong>Green</strong> means that the performance is good.</span></li>
</ul>
<p><span>Again, the </span><strong>EnvQueryA<span> </span></strong><span>has been designed to perform badly to showcase the p</span>rofiler<em>.</em> If we pick <strong>EnvQueryB</strong>, we see that it performs much better:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1719 image-border" src="assets/8fcdf660-d092-41ed-b118-86128ffcd1c5.png" style="width:36.58em;height:25.17em;"/></p>
<p>As a result, this peak into each single generator and each test allows you to dive deeper into which part of your environmental query is actually performing badly. So, you can use the profiler to identify which queries have problems, and then dive deeper into those that need to be optimized.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving and loading EQS stats</h1>
                </header>
            
            <article>
                
<p>Another cool feature of profiling environmental queries is that you can save your stats and load them again. This gives you powerful and flexible tools to share your findings with the rest of your team.</p>
<p>In order to save an EQS stat, you just need to press the <strong>Save Stats</strong> button in the top menu, as shown in the following screenshot:</p>
<p> </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/478ac278-3c34-43e6-a7a4-f7b6c93cb47a.png" style="width:17.17em;height:5.83em;"/></p>
<p>You will be prompted to choose a location to save the file containing your stats.</p>
<p>Loading is easy as well. Just press the <strong>Load Stats</strong> button in the top menu, as shown in the next screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/df3d41fc-2b3e-4280-b688-2dfc43d43ebe.png" style="width:17.25em;height:5.83em;"/></p>
<p>You will be prompted to choose a file containing your EQS stats, and after that, all your stats will be loaded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing and visualizing the navigation mesh</h1>
                </header>
            
            <article>
                
<p>In this section, we will explore some built-in tools to test and visualize the <strong>Navigation Mesh</strong>.</p>
<p>In particular, we will see how it is possible to visualize the navigation mesh under the hood and how the navigation test actor can quickly show us "the way" (the path generated by the pathfinding algorithm).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing the navigation mesh</h1>
                </header>
            
            <article>
                
<p>As we mentioned back in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>, when we generated a <strong>Navigation Mesh</strong>, for instance, by bringing into the map the <strong>Nav Mesh Bounds Volume</strong>, we also created a <strong>RecastNavMesh-Default</strong> actor in the level. If we select it, we can see many options there are to generate the navigation mesh, and some of them we already explored. However, we have a whole section about <strong>Display Settings</strong> that back in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>, we didn't have the time to explore properly. Thus, let's quickly go through these settings; here, for your convenience, is a screenshot of the display settings in the <strong>Details </strong>panel:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1720 image-border" src="assets/dc289894-ff12-4a2f-b1ba-503b765764b0.png" style="width:23.67em;height:34.75em;"/></p>
<p>With the default settings, this is how it looks like (in our example map):</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1722 image-border" src="assets/ea96938b-bbf6-4bc8-87c6-2e5f14011bd2.png" style="width:100.08em;height:56.83em;"/></p>
<p>We have a lot of them, so without going too much into the details, let's dive in:</p>
<div class="packt_infobox">To fully understand all of the options, you should be familiar with how the navigation mesh is generated. However, covering this is outside the scope of this book. In any case, you can still play with the settings and learn some more about the navigation system.</div>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Triangle Edge</strong>: Shows the triangles of which the nav mesh is made. Ultimately, the connections of these triangles will generate a graph on which <strong>Pathfinding</strong> algorithms will run (actually, it is more complicated than that, since the system needs to scale for bigger worlds, and a hierarchical pathfinding is used on different graphs at different levels). By enabling this option, you can actually see the nodes of this graph:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1723 image-border" src="assets/0368e37f-5dca-4204-b91e-ba92b472cdf6.png" style="width:100.33em;height:56.83em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Poly Edges</strong>: Shows the edges of the polygons. In fact, the nav mesh is generated starting from sectioning the level in polygons, and if a polygon contains complex geometry (for example, there are static meshes), the algorithm subdivides the polygon into smaller polygons based on the geometry. Then, these polygons get divided into triangles (the one we have seen before). With this option enabled, you are able to see which are the polygons for this static mesh, and if you leave the previous option on, you can see clearly see how all of these polygons have been divided into triangles:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1724 image-border" src="assets/20598dbc-d040-4005-bb0c-e58d4593a1d9.png" style="width:71.00em;height:40.17em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Filled Polys</strong>: If checked, it shows the polygon filled with the usual green we have already seen; in fact, this option is on by default. However, if we disable it, we can have a clearer look at the <em>bare bones</em> of the nav mesh:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1726 image-border" src="assets/98e9b333-1c82-46d4-a3cc-3a321e9b7d3b.png" style="width:61.25em;height:34.83em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Nav Mesh Edges</strong>: If checked (and it is by default), it shows the edge of the nav mesh. In the following screenshot, this is how it looks with this option turned off:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1727 image-border" src="assets/50567abc-8024-4577-ae41-badaef44103e.png" style="width:63.17em;height:35.83em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Tile Bound</strong>: If enabled, it shows the bounds of the tiles of the navigation mesh:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1729 image-border" src="assets/817941b1-de44-43c3-a49e-4bc339738950.png" style="width:59.33em;height:33.50em;"/></p>
<ul>
<li><strong>Draw Path-Colliding Geometry</strong>: By enabling this option, it is possible to visualize the geometry that has been passed as input to the<strong> Navigation Mesh Generator</strong>, so it is basically all the geometry that the navigation system "is aware of." This is useful to check whether something is considered by the navigation system, so you can include or exclude what you don't want (remember that there is an option for actors and objects to influence the navigation mesh, and this option allows you to spot the one that is currently being considered by the navigation system). By checking this option, this is what it is possible to see:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1730 image-border" src="assets/7b5c80db-ab02-4475-8c6c-2ac09f2d1b55.png" style="width:60.92em;height:34.58em;"/></p>
<ul>
<li>However, keep in mind that Unreal renders this geometry independently from the rest. So, you can also use other views in the engine to isolate this geometry to better check what it is like. For instance, you can turn on the Wireframe View<em>,</em> and it is still possible to see the geometry passed to the navigation mesh generator, and this is how it looks:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1294 image-border" src="assets/64878787-d708-4418-bfb8-dc296dbe9145.png" style="width:53.25em;height:30.25em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Tile Labels</strong>: If enabled, these options show the label (expressed as a coordinate) of each tile of the navigation mesh:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1734 image-border" src="assets/83fd4f02-d462-4a79-ae78-1508d05167eb.png" style="width:64.33em;height:36.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Viewport. This is a screenshot of the viewport. The other (blurred out) information is not important here</div>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Polygon Labels</strong>: If enabled, this option shows a label (that also express how many iterations that polygon went through before being generated) for each polygon generated in the navigation mesh:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1735 image-border" src="assets/5e4c53c6-d0cf-4a51-a5f2-1ec3d02457b4.png" style="width:60.08em;height:34.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Viewport. This is a screenshot of the viewport. The other (blurred out) information is not important here</span></div>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Default Polygon Cost</strong>: If this option is enabled, it shows all the costs for the different parts of the navigation mesh. This is very useful for checking which parts are more expensive to traverse. By enabling it in our example, this is how it looks:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1736 image-border" src="assets/e5afe432-0b64-432c-b8f6-65fa2b94a072.png" style="width:69.50em;height:39.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Viewport. This is a screenshot of the viewport. The other (blurred out) information is not important here</span></div>
<ul>
<li class="CDPAlignLeft CDPAlign">As you can see, all the costs are just 1, and this is because we don't have any other type of nav areas than the default ones. If we bring a nav modifier and we set a custom nav area (different than null), for instance, the <strong>Desert</strong> (or <strong>Jungle</strong>) <strong>Area</strong>, as we did back in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>, this would be the result (you will notice a change in how the navigation mesh is generated, and how in the desert area the cost is higher):</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1737 image-border" src="assets/8bee4bb2-67c9-456f-a191-78561e1af250.png" style="width:50.08em;height:28.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Viewport. This is a screenshot of the viewport. The other (blurred out) information is not important here</span></div>
<ul>
<li><strong>Draw Labels on Path Nodes</strong>: If this option is on, it will draw labels on the path nodes.</li>
</ul>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Nav Links</strong>: As the name suggests, if the option is on, it will draw nav links. It is enabled by default, since usually, you want to be able to see the nav links. If we disable it, this is how it would look in our example:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1739 image-border" src="assets/a8981c28-b286-47bb-8941-d38eafd5091b.png" style="width:67.25em;height:38.25em;"/></p>
<ul>
<li><strong>Draw Failed Nav Links</strong>: This is the same as the previous option, but on <strong>Failed Nav Links</strong>, it is disabled by default.</li>
</ul>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Clusters</strong>: If enabled, it allows you to see the clusters. I'm not going into detail, but as we mentioned earlier, the pathfinding needs to be optimized to scale on large worlds (for example, <strong>Hierarchical Pathfinding</strong>); thus, with this option, you can see which regions of the navigation mesh are connected (meaning that it is guaranteed that between those two regions a path exists in some way), and so the pathfinding can first find the connected region, before refining the search of the path. If this option is enabled, here is how it looks:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1740 image-border" src="assets/c9eb6fab-0aed-4344-ad92-ed124f0cdf71.png" style="width:61.33em;height:34.92em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Octree and Draw Octree Details</strong>: I<span>f enabled, it allows you to see the </span><strong>Octrees</strong><span>. Octrees are mathematical structures (trees with eight children) used to partition a 3D space. In fact, the navigation mesh is only on the same surface, but it lives in (and needs to work with) a 3D space. Just as in our example map, we have some stairs and some regions of the navigation mesh that are not at the same level; and also <strong>Nav Links</strong> connects regions from above the stairs to down below. If we enable it, here is how it should look (you will be able to notice that the octrees are mainly in the parts of the navigation mesh that needs to develop in height):</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1741 image-border" src="assets/cd4d33b9-fa61-4be3-b308-2f2fb9974c5d.png" style="width:73.08em;height:41.67em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong>Draw Offset</strong>: As you may have already noticed, the navigation mesh is not drawn at the same level of the geometry of the level, but there is a small offset. The <strong>Draw Offset</strong> parameter controls this offset from the ground where the navigation mesh is drawn. The default value is 10 (which means 10 centimeters if we keep the convention with the Unreal units). If we change this value (I also enabled <strong>Draw Filled Polys</strong> to better see the offset), for example, to a higher value, this is what we would end up with:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1743 image-border" src="assets/2ecfd667-b4ce-4428-a881-84daea0a1086.png" style="width:51.00em;height:29.00em;"/></p>
<ul>
<li><strong>Enabling Drawing</strong>: As the name suggests, if this is enabled, it is possible to see the navigation mesh along with all the previous settings.</li>
</ul>
<div class="packt_infobox">Of course, all of these options are better combined when we start playing with the other settings that determine how the navigation mesh is generated. In fact, by tweaking the display settings, you can better understand how the generation settings work, and actually "see" how they affect the generation of the navigation mesh.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigation test actor</h1>
                </header>
            
            <article>
                
<p>As we have seen for the <strong>EQS Testing Pawn</strong>, there is a built-in <strong>Navigation Test Actor</strong> that we can use.</p>
<p>This actor is not declared virtual (as the EQS counterpart is), so it can be directly placed in the map. Actually, we can access it from the <strong>Modes</strong> panel, as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1744 image-border" src="assets/2780f85c-e050-4aa8-9493-7acb4e7a5374.png" style="width:19.17em;height:28.00em;"/></p>
<p>Once placed in the level, this is how it looks:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1745 image-border" src="assets/4e1a5afa-37c6-4be2-bcb5-7da8eae869c6.png" style="width:55.83em;height:29.00em;"/></p>
<p>If we place another one in the level, then in the <strong>Details</strong> panel, we can assign under the Pathfind section the as shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1747 image-border" src="assets/aea8c754-f98c-4302-8bed-9899fb8bb16b.png" style="width:36.83em;height:15.75em;"/></p>
<p>This will result in a preview of the path between the two navigation test actors:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1749 image-border" src="assets/85dbf698-7a97-4fdc-af97-919236733e74.png" style="width:51.92em;height:27.00em;"/></p>
<p>Here is a different example from a different viewpoint:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1750 image-border" src="assets/6db189b4-dabf-474a-b724-a5083205803c.png" style="width:55.08em;height:28.75em;"/></p>
<p>Also, you can "smooth" the edges of the path if we modify the <strong>Offset From Corner Distance</strong>, always in the pathfinding section of the navigation test actor. For instance, a value of 150 will produce this path:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1751 image-border" src="assets/720d6b8b-9d62-4f9f-95f0-2d227f37210a.png" style="width:53.50em;height:29.00em;"/></p>
<p>Of course, this pathfinding test can be used with <strong>Nav Areas</strong> as well. If we drop a <strong>Desert Area</strong> (created back in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>) in the level, the pathfinder will try to avoid it, since it has a higher cost. In the following example (the highlighted volume is the desert area), the desert area is small, and passing through it is still the shortest path:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1753 image-border" src="assets/66da78af-1dec-4f86-9dd5-2e1882764d58.png" style="width:58.17em;height:31.42em;"/></p>
<p>However, if we expand the area, then going from the other side has a cheaper cost:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1755 image-border" src="assets/bbb96cb6-0745-47d7-ba9c-29fdd1a48f05.png" style="width:60.58em;height:32.67em;"/></p>
<p>Finally, it's worthwhile mentioning that we can also use nav filters within the navigation test actor, always in the pathfinding section in its <strong>Details</strong> panel. For instance, we can place the <strong>NavFilter_DesertAnimal</strong> (that we created in <a href="fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml">Chapter 3</a>, <em>Navigation</em>,), then the desert area is even preferred, producing this other path:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1757 image-border" src="assets/91194937-b1b5-4ad5-bd54-07e89fa5d809.png" style="width:54.25em;height:29.33em;"/></p>
<p>This navigation test actor has more functionalities, as you can see from its <strong>Details</strong> panel, but, unfortunately, they are outside the scope of this book. However, we have seen its basic use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profiling AI</h1>
                </header>
            
            <article>
                
<p>When it comes to profiling, Unreal offers many solutions and tools. This section explores some that are related to AI.</p>
<p>In particular, we will see how it is possible to visualize stats directly from the console and how to create a custom stat group. At the end of this section, we will mention the <strong>Session Frontend</strong> tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profiling with the console</h1>
                </header>
            
            <article>
                
<p>The most used profiling tool is activating stats through the console, because it is very quick and <span>you can track performance </span>in real time. In fact, just typing <kbd>stats game</kbd> into the console makes <span>a whole page of stats </span>appear on the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1758 image-border" src="assets/f180301e-7a83-47ad-bb20-232562dec587.png" style="width:28.67em;height:6.08em;"/></p>
<p>Here are all the stats that appear:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1760 image-border" src="assets/20902974-2273-4d27-b2f2-2c53205cc3ca.png" style="width:53.33em;height:31.58em;"/></p>
<p>As you can see, there's a lot of information, but it is quite general, since it tracks the general performance of your game. This is a perfect starting point to start optimizing your game; however, as an AI Developer, you will need more specific tools.</p>
<p>If we start typing just <kbd>Stat</kbd>, a series of options (as a suggestion) appears on the screen (86!):</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1762 image-border" src="assets/17f4dddd-3df4-47ce-b441-981f128a7fca.png" style="width:34.92em;height:29.92em;"/></p>
<p>But we can refine our search <span>even more </span>by typing <kbd>Stat AI</kbd>, and we can have the <span>AI-related</span> stats (after all, these options were the first ones on the list, since they are in alphabetical order):</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1763 image-border" src="assets/ce976ad8-7120-4460-ab8a-8a569cc532af.png" style="width:12.17em;height:8.58em;"/></p>
<p>These are very useful when it comes down to quickly tracking the performance of your AI.</p>
<div class="packt_infobox">In order to close the stats, just retype the same command as you did when closing those specific stats.</div>
<p>If we type <kbd>Stat AI</kbd>, we get a generic AI performance track (it depends also on which AI systems you have active). On the right, you are also able to check how many AIs there are in the level, and how many are currently rendered:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1764 image-border" src="assets/ab6620d3-a996-43af-8a71-2c1758b937cc.png" style="width:64.83em;height:38.17em;"/></p>
<p>Typing <kbd>Stat AI_EQS</kbd> gives us more information about EQS. Of course, by using a level that has five AIs performing the <kbd>EnvQueryA</kbd> and <kbd>EnvQueryB</kbd> that we have created before, this has a huge impact on how EQS performs in this specific example:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1767 image-border" src="assets/6959453f-f7a4-423a-833a-0a98468d410c.png" style="width:56.42em;height:33.33em;"/></p>
<p>Typing <kbd>Stat AIBehaviorTree</kbd> gives us informational about the behavior trees that are running. Currently, in our example, we have very simple behavior trees, so performance- and memory-wise they are very easy:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1768 image-border" src="assets/7536304e-eab7-48c0-825c-d282a0badc38.png" style="width:53.42em;height:31.67em;"/></p>
<p>Finally, typing <kbd>Stat AICrowd</kbd> gives us information about the crowd that is handled at the current stage. Since we are not using a crowd in this example, the category is empty:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1769 image-border" src="assets/70d5f585-581b-47b0-b01e-5c044c8ca169.png" style="width:53.50em;height:31.58em;"/></p>
<p class="mce-root"/>
<p>Of course, if you need to keep track of more than one category at the time, you can do it, just by inserting console commands, and they will stack up together, as shown in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1770 image-border" src="assets/1bf970f0-ce65-4566-a3ec-6c5b44e21693.png" style="width:60.33em;height:35.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom stat group</h1>
                </header>
            
            <article>
                
<p>If you are programming a complex AI, you might want to keep track of more specific functions and how they perform. Of course, this can be useful not only for AI programming, but for any part of your game. Unreal offers some simple Macros to add to your C++ code to quickly start outputting stats for those functions to check their performance.</p>
<p>To create a <strong>Custom Stat Group</strong>, you need to declare this within a header file (or if your system uses inheritance, you can declare it at the highest level of the headers file, so the same stat group is available for all the classes that inherit from this):</p>
<pre>DECLARE_STATS_GROUP(TEXT("CustomStatGroupName"), STATGROUP_CustomStatGroupName, STATCAT_Advanced);</pre>
<p>Then, inside the header (<kbd>.h</kbd>) file of the class that contains the function you want to track, we need to add this macro (one for each function we need to track):</p>
<pre>DECLARE_CYCLE_STAT(TEXT("Name of how you want to display this function"), STAT_NameOfTheFunction, STATGROUP_CustomStatGroupName);</pre>
<p>Finally, in the implementation (<kbd>.cpp</kbd>) file, you need to add this macro at the beginning of the function we want to track:</p>
<pre>SCOPE_CYCLE_COUNTER(STAT_NameOfTheFunction);</pre>
<p>Let's start with a practical example, so that you can have a better idea of how it works. I'm going to create a simple actor, create the stat group within this actor, and start tracking the performance of its <kbd>tick</kbd> function.</p>
<p>Let's create a new C++ class that inherits from <strong>Actor</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1771 image-border" src="assets/74d2173e-9157-4d1e-8a34-7f6d321acf07.png" style="width:38.17em;height:29.50em;"/></p>
<p>We can rename it <strong><em>TestingStatActor</em></strong> and place it within the <kbd>Chapter12 </kbd>folder:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1772 image-border" src="assets/9fc6faf9-a9ad-4748-9b41-47b11c63dab6.png" style="width:78.00em;height:33.25em;"/></p>
<p>Next, in its header (<kbd>.h</kbd>) file, we need to declare the stat group (just below the include statements):</p>
<pre>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "TestingStatActor.generated.h"<br/><br/><strong>DECLARE_STATS_GROUP(TEXT("AI_MyCustomGroup"), STATGROUP_AI_MyCustomGroup, STATCAT_Advanced);</strong></pre>
<p>Then, since we want to track a function in this very class, we can declare the intention to track a function just below the previous line:</p>
<pre>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "TestingStatActor.generated.h"<br/><br/>DECLARE_STATS_GROUP(TEXT("AI_MyCustomGroup"), STATGROUP_AI_MyCustomGroup, STATCAT_Advanced);<br/><strong>DECLARE_CYCLE_STAT(TEXT("StatTestActor ~ PerformTick"), STAT_PerformTick, STATGROUP_AI_MyCustomGroup);</strong></pre>
<p>Finally, in the C++ file, we can add the following macro at the beginning of the <kbd>Tick</kbd> function (even before <kbd>Super::Tick()</kbd> if you want to track that part as well), and maybe we can add a log (which is a heavy task, especially for a <kbd>Tick</kbd> function, so we can better see its spike in performance):</p>
<pre>void ATestingStatActor::Tick(float DeltaTime)<br/>{<br/><strong>  SCOPE_CYCLE_COUNTER(STAT_PerformTick);</strong><br/>  Super::Tick(DeltaTime);<br/><br/>  UE_LOG(LogTemp, Warning, TEXT("Test Message on Tick"));<br/>}</pre>
<p>Now you can compile your code, and when it is finished, you can drag the <strong>TestingStatActor</strong> directly into the level (remember that it doesn't have a scene component, so it exists in the level, but it cannot be positioned).</p>
<p>If we type in the console, we are now able to access our <strong>AI_MyCustomGroup</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1773 image-border" src="assets/9b06379f-dc5d-43ef-a53e-973609fda064.png" style="width:14.33em;height:9.67em;"/></p>
<p>If we enable it, we are able to check on screen the performance of our <kbd>Tick</kbd> function for each TestingStatActor in the game (in this case, just one):</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1774 image-border" src="assets/149de11b-c5a7-476e-97b3-b2b8f2eebc4a.png" style="width:54.08em;height:32.33em;"/></p>
<p>This concludes how to create a custom stat group. This is indeed a very powerful tool that allows you to quickly start profiling your C++ functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Session frontend</h1>
                </header>
            
            <article>
                
<p><strong>Session frontend</strong> is a very powerful profiling tool within Unreal. It allows you to check the performance of specific parts of the game, record and save profiling sessions, and much, much more (including automatic tests! We will not touch those in this book).</p>
<p>You can activate it by navigating from the top menu <strong>Window | Developer Tools | Session Frontend</strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1775 image-border" src="assets/349b4b2e-7507-42ad-89dd-fa7cc8aeef81.png" style="width:25.58em;height:50.42em;"/></p>
<p>Once opened, this is how it looks (it should be in the <strong>Console</strong> tab):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/de93d471-f75e-4d49-8933-2598fbfa5118.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Console tab. </span><span>This is an image of Console tab. The other (blurred out) information is not important here</span></div>
<p>In the <strong>Profiler</strong> tab, you will find all of what you need to dive deeper into profiling.</p>
<p>When you start profiling, here, you will find even more information about AI performance (actually, you can find the performance of every part of your game). For instance, in the next screenshot, you can see that I'm profiling some AI systems:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7cfd4696-fb1c-48ef-8b0a-2353ee5f8662.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Profiler tab. </span><span>This is an image of Profiler tab. The other (blurred out) information is not important here</span></div>
<div class="packt_tip">If you have created a custom stat group <span>before</span>, you will be able to profile that as well in the session frontend! So, keep in mind that creating a stat group is very important, as later on, you will need to check the performance of your system.</div>
<p>Unfortunately, we don't have the time to explore the <strong>Session Frontend</strong> tool, since it would require a whole chapter and it is outside the scope of this book (since it would require digging really deeply into performance profiling). However, I mentioned this tool not just because it is very important, but because you should definitely be aware of its existence, and it is worthwhile exploring it more on your own. In fact, you can find more information about this tool in the official documentation here: <a href="https://docs.unrealengine.com/en-us/Engine/Performance/Profiler">https://docs.unrealengine.com/en-us/Engine/Performance/Profiler</a>, which provides a good starting point for learning more about this tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have explored some debugging tools for our AI. Of course, this was not comprehensive, and there is much more that we haven't covered. However, we learned about the most important ones and how to use them.</p>
<p>In particular, we have further explored the options available to an EQS testing pawn, and how they can help us visualize an environmental query running. We also learned about using EQS Profiler as a way to identify how our environmental queries perform, and we dived deeper into those that need optimization.</p>
<p>We also looked at the display settings for the navigation system in more detail, to have a better idea of how our navigation mesh is generated. Also, we discussed the navigation-testing actor, which is really useful to visually query the navigation system and quickly receive feedback regarding how the Pathfinder performs; but we didn't have the time to go into detail about the available options.</p>
<p>Finally, we learned more about profiling our game AI, especially with the use of <kbd>stat</kbd> commands in the console. In fact, we have explored what the built-in stat groups are and how to create a customized one. We also mentioned the session frontend, a powerful tool for profiling our game.</p>
<p>In the next chapter, we will cover the gameplay debugger, which is another important tool for debugging AI.</p>


            </article>

            
        </section>
    </body></html>