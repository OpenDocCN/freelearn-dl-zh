- en: '*Chapter 6*: Path Following and Steering Behaviors'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：路径跟随和导航行为'
- en: In this short chapter, we will implement two Unity3D demos to explore steering
    behaviors. In the first demo, we will implement a script to make an entity follow
    a simple path. In the second demo, we will set up a scene with a couple of obstacles
    and program an entity to reach a target while avoiding the obstacles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短章节中，我们将实现两个Unity3D演示来探索导航行为。在第一个演示中，我们将实现一个脚本，使实体遵循简单的路径。在第二个演示中，我们将设置一个带有几个障碍的场景，并编程一个实体在避开障碍的同时到达目标。
- en: Obstacle avoidance is a fundamental behavior for game characters when moving
    around and interacting with the game world. However, obstacle avoidance is generally
    used with other navigation systems (such as pathfinding or crowd simulations).
    In this chapter, we will use the systems to make sure that we avoid the other
    agents and reach the target. We will not talk about how fast the character will
    reach a destination, and we will not calculate the shortest path to the target,
    as we'll talk about these in the next chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 避障是游戏角色在移动和与游戏世界交互时的基本行为。然而，避障通常与其他导航系统（如路径查找或人群模拟）一起使用。在本章中，我们将使用这些系统确保我们避开其他代理并到达目标。我们不会讨论角色到达目的地有多快，也不会计算到达目标的最短路径，因为我们将这些内容留到下一章讨论。
- en: 'In this chapter, we''ll look at the following two fundamental aspects of movement:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下两个基本方面的运动：
- en: Following a path
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着路径
- en: Avoiding obstacles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免障碍
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 6` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter06).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要Unity3D 2022。你可以在本书仓库中的`第6章`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter06)。
- en: Following a path
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿着路径
- en: A `Path.cs` script that takes a list of game objects as waypoints and create
    a path out of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Path.cs`脚本，它接受一个游戏对象列表作为航点，并从中创建路径。
- en: Path script
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径脚本
- en: 'Let''s look at the path script responsible for managing the path for our objects.
    Consider the following code in the `Path.cs` file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看负责管理我们对象路径的路径脚本。考虑以下在`Path.cs`文件中的代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, that is a straightforward script. It has a `Length` property
    that returns the number of waypoints. The `GetPoint` method returns the position
    of a particular waypoint at a specified index in the array. Then, we have the
    `OnDrawGizmos` method called by the Unity3D frame to draw components in the editor
    environment. The drawing here won't be rendered in the game view unless the gizmos
    flag, located in the top right corner, is turned on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的脚本。它有一个`Length`属性，返回航点的数量。`GetPoint`方法返回数组中指定索引的特定航点的位置。然后，我们有`OnDrawGizmos`方法，由Unity3D帧调用，在编辑器环境中绘制组件。除非在右上角的小工具标志打开，否则这里的绘制不会在游戏视图中渲染。
- en: '![Figure 6.1 – The gizmos visibility option in the Editor view'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 编辑器视图中的小工具可见性选项'
- en: '](img/B17984_06_1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_1.jpg)'
- en: Figure 6.1 – The gizmos visibility option in the Editor view
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 编辑器视图中的小工具可见性选项
- en: Now let's create the scene. Create an empty **Path** game object and attach
    to it the **Path** script. Then, let's add to it some empty game objects as children.
    They will be the waypoints markers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建场景。创建一个空的**路径**游戏对象，并将其**路径**脚本附加到它上。然后，让我们添加一些空的子游戏对象。它们将是航点标记。
- en: '![Figure 6.2 – Here is how we organize the Hierarchy'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 这是如何组织层级'
- en: '](img/B17984_06_2.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_2.jpg)'
- en: Figure 6.2 – Here is how we organize the Hierarchy
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 这是如何组织层级
- en: Select the **Path** object. We now have to fill the **Waypoints** array in the
    Inspector with the actual waypoint markers. As usual, we can do this by dragging
    and dropping the game objects from the Hierarchy to the Inspector.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**路径**对象。现在我们需要在检查器中填充**航点**数组，使用实际的航点标记。像往常一样，我们可以通过将游戏对象从层级拖放到检查器中来实现这一点。
- en: '![Figure 6.3 – The Path script configuration in the Inspector'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 检查器中的路径脚本配置'
- en: '](img/B17984_06_3.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_3.jpg)'
- en: Figure 6.3 – The Path script configuration in the Inspector
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 检查器中的路径脚本配置
- en: The preceding list shows the **Waypoints** in the example project. However,
    you can move the waypoints around in the editor, use the same waypoint multiple
    times, or whatever else you like.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表显示了示例项目中的**航点**。然而，你可以在编辑器中移动航点，多次使用相同的航点，或者做任何你喜欢的事情。
- en: The other property is a checkbox to enable the **debug** mode and the waypoint
    radius. If we enable the **debug** mode property, Unity draws the path formed
    by connecting the waypoints as a gizmo in the editor view as shown in *Figure
    6.4*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个属性是一个复选框，用于启用**调试**模式和航点半径。如果我们启用**调试**模式属性，Unity将在编辑器视图中以gizmo的形式绘制由航点连接而成的路径，如图*图6.4*所示。
- en: '![Figure 6.4 – The path''s gizmo is drawn in the editor view'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 在编辑器视图中绘制路径的gizmo'
- en: '](img/B17984_06_4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_4.jpg)'
- en: Figure 6.4 – The path's gizmo is drawn in the editor view
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 在编辑器视图中绘制路径的gizmo
- en: Now that we have a path, we need to design a character that can follow it. We
    do that in the following section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了路径，我们需要设计一个可以跟随它的角色。我们将在下一节中这样做。
- en: Path-following agents
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟随路径的代理
- en: For this demo, the main character is represented by a brave and valiant cube.
    But, of course, the same script applies to whatever 3D models you want.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，主要角色由一个勇敢而英勇的立方体表示。但当然，相同的脚本也适用于你想要的任何3D模型。
- en: 'Let''s start by creating a `VehicleFollowing` script. The script takes a couple
    of parameters: the first is the reference to the path object it needs to follow
    (the **Path** variable); then, we have the **Speed** and **Mass** properties,
    which we need to calculate the character''s velocity over time. Finally, if checked,
    the **Is Looping** flag instructs the entity to follow the path continuously in
    a closed loop.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个`VehicleFollowing`脚本。该脚本接受几个参数：第一个是需要跟随的路径对象的引用（**Path**变量）；然后，我们有**Speed**和**Mass**属性，我们需要计算角色的速度随时间的变化。最后，如果选中，**Is
    Looping**标志指示实体以闭合循环连续跟随路径。
- en: 'Let''s take a look at the following code in the `VehicleFollowing.cs` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`VehicleFollowing.cs`文件中的以下代码：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we specify all the script properties. Then, we initialize the properties
    and set up the starting direction of our velocity vector using the entity''s forward
    vector. We do this in the `Start` method, as shown in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定所有脚本属性。然后，我们初始化属性并使用实体的前向向量设置速度向量的起始方向。我们在`Start`方法中这样做，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this script, there are only two methods that are really important: the `Update`
    and `Steer` methods. Let''s take a look at the first one:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，只有两个方法真正重要：`Update`和`Steer`方法。让我们看看第一个：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `Update` method, we check whether the entity has reached a particular
    waypoint by calculating if the distance between its current position and the target
    waypoint is smaller than the waypoint's radius. If it is, we increase the index,
    setting in this way the target position to the next waypoint in the waypoints
    array. If it was the last waypoint, we check the `isLooping` flag.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`方法中，我们通过计算实体当前位置与目标航点之间的距离是否小于航点的半径来检查实体是否到达了特定的航点。如果是，我们增加索引，这样就将目标位置设置为航点数组中的下一个航点。如果它是最后一个航点，我们检查`isLooping`标志。
- en: If it is active, we set the destination to the starting waypoint; otherwise,
    we stop. An alternative solution is to program it so that our object turns around
    and goes back the way it came. Implementing this behavior is not a difficult task,
    so we leave this to the reader as a helpful practice exercise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是活动的，我们将目的地设置为起始航点；否则，我们停止。另一种解决方案是编程它，使我们的物体转身并返回它来的路。实现这种行为并不困难，所以我们将其留给读者作为有益的练习练习。
- en: 'Now, we calculate the acceleration and rotation of the entity using the `Steer`
    method. In this method, we rotate and update the entity''s position according
    to the speed and direction of the velocity vector:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`Steer`方法来计算实体的加速度和旋转。在这个方法中，我们根据速度向量的速度和方向旋转并更新实体的位置：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Steer` method takes two parameters: the target position and a boolean,
    which tells us whether this is the final waypoint in the path. As first, we calculate
    the remaining distance from the current position to the target position. Then
    we subtract the current position vector from the target position vector to get
    a vector pointing toward the target position. We are not interested in the vector''s
    size, just in its direction, so we normalize it.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Steer`方法接受两个参数：目标位置和一个布尔值，它告诉我们这是路径中的最终航点。首先，我们计算从当前位置到目标位置剩余的距离。然后我们从目标位置向量中减去当前位置向量以得到指向目标位置的向量。我们对其大小不感兴趣，只关心其方向，因此我们对其进行归一化。'
- en: Now, suppose we are moving to the final waypoint, and its distance from us is
    less than the waypoint radius. In that case, we want to slow down gradually until
    the velocity becomes zero precisely at the waypoint position so that the character
    correctly stops in place. Otherwise, we update the target velocity with the desired
    maximum speed value. Then, in the same way as before, we can calculate the new
    steering vector by subtracting the current velocity vector from this target velocity
    vector. Finally, by dividing this vector by the steering inertia value of our
    entity, we get a smooth steering (note that the minimal value for the steering
    inertia is `1`, corresponding to instantaneous steering).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们正在移动到最终航点，并且它与我们之间的距离小于航点半径。在这种情况下，我们希望逐渐减速，直到速度在航点位置恰好变为零，以便角色能够正确地停在原地。否则，我们使用期望的最大速度值更新目标速度。然后，与之前相同，我们可以通过从目标速度向量中减去当前速度向量来计算新的转向向量。最后，通过将此向量除以我们的实体转向惯性值，我们得到一个平滑的转向（请注意，转向惯性的最小值为`1`，对应于瞬时转向）。
- en: 'Now that we have a script, we can create an empty `Cube` object and put it
    at the beginning of the path. Then, we add the `VehicleFollowing` script component
    to it, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了脚本，我们可以创建一个空的`Cube`对象并将其放置在路径的起点。然后，我们向其中添加`VehicleFollowing`脚本组件，如下面的截图所示：
- en: '![Figure 6.5 – The properties of the VehicleFollowing script'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – VehicleFollowing脚本的属性]'
- en: '](img/B17984_06_5.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_06_5.jpg]'
- en: Figure 6.5 – The properties of the VehicleFollowing script
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – VehicleFollowing脚本的属性
- en: You should see our cubic character follow the path if you run the scene. You
    can also see the path in the editor view. Play around with the speed and steering
    inertia values of the cube and radius values of the path, and see how they affect
    the system's overall behavior.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行场景，你应该看到我们的立方体角色沿着路径移动。你还可以在编辑器视图中看到路径。尝试调整立方体的速度和转向惯性值以及路径的半径值，看看它们如何影响系统的整体行为。
- en: Avoiding obstacles
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免障碍物
- en: 'In this section, we explore obstacle avoidance. As a first step, we need, of
    course, obstacles. So, we set up a scene similar to the one shown in *Figure 6.6*.
    Then, we create a script for the main character to avoid obstacles while trying
    to reach the target point. The algorithm presented here uses the raycasting method,
    which is very straightforward. However, this means it can only avoid obstacles
    that are blocking its path directly in front of it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨障碍物避让。首先，当然需要障碍物。因此，我们设置了一个类似于*图6.6*所示的场景。然后，我们为主角编写了一个脚本，使其在尝试到达目标点的同时避开障碍物。这里提出的算法使用了射线投射法，这种方法非常直接。然而，这意味着它只能避开直接阻挡其路径前方的障碍物：
- en: '![Figure 6.6 – A sample scene setup'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 – 一个示例场景设置]'
- en: '](img/B17984_06_6.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_06_6.jpg]'
- en: Figure 6.6 – A sample scene setup
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 一个示例场景设置
- en: We make a few cube entities and group them under an empty game object called
    `Obstacles` to create the environment. We also create another cube object called
    `Vehicle` and give it the obstacle avoidance script. Finally, we create a plane
    object representing the ground.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一些立方体实体，并将它们组合在一个名为`Obstacles`的空游戏对象下，以创建环境。我们还创建了一个名为`Vehicle`的另一个立方体对象，并给它添加了障碍物避让脚本。最后，我们创建了一个代表地面的平面对象。
- en: '![Figure 6.7 – Here is the structure of the scene''s Hierarchy'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – 场景的层次结构结构]'
- en: '](img/B17984_06_7.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_06_7.jpg]'
- en: Figure 6.7 – Here is the structure of the scene's Hierarchy
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 场景的层次结构结构
- en: 'It is worth noting that the **Vehicle** object does not perform pathfinding,
    that is, the active search for a path to the destination. Instead, it only avoids
    obstacles locally as it follows the path. Roughly speaking, it is the difference
    between you planning a path from your home to the mall, and avoiding the possible
    people and obstacles you may find along the path. As such, if we set too many
    walls up, the **Vehicle** might have a hard time finding the target: for instance,
    if the Agent ends up facing a dead-end in a U-shaped object, it may not be able
    to get out. Try a few different wall setups and see how your agent performs.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，**Vehicle**对象不执行路径查找，即不是在目的地进行路径的主动搜索。相反，它只是在跟随路径时局部避开障碍物。简而言之，这就像你从家计划去购物中心的路，以及避开你可能在路上遇到的可能的人和障碍物。因此，如果我们设置太多的墙壁，**Vehicle**可能很难找到目标：例如，如果Agent最终面对一个U形物体的死胡同，它可能无法出来。尝试几种不同的墙壁设置，看看你的代理表现如何。
- en: Adding a custom layer
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义层
- en: 'We now add a custom layer to the Obstacles object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将自定义层添加到Obstacles对象中：
- en: 'To add a new layer, navigate to **Edit** | **Project Settings**:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加新层，请转到**编辑** | **项目设置**：
- en: '![Figure 6.8 – The Project Settings'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – 项目设置'
- en: '](img/B17984_06_8.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_8.jpg)'
- en: Figure 6.8 – The Project Settings
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 项目设置
- en: Go to the **Tags and Layer** section.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**标签和层**部分。
- en: Assign the name `Obstacles` to **User Layer 8**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称`Obstacles`分配给**用户层8**。
- en: 'We then go back to our cube entity and set its `Obstacles`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们回到我们的立方体实体，并设置其`Obstacles`：
- en: '![Figure 6.9 – Creating a new layer'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 – 创建新层'
- en: '](img/B17984_06_9.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_9.jpg)'
- en: Figure 6.9 – Creating a new layer
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 创建新层
- en: 'When we use raycasting to detect obstacles, we check for those entities, but
    only on this layer. This way, the physics system can ignore objects hit by a ray
    that are not an obstacle, such as bushes or vegetation:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用射线投射来检测障碍物时，我们检查这些实体，但仅在这个层上。这样，物理系统可以忽略被射线击中的不是障碍物的对象，例如灌木丛或植被：
- en: '![Figure 6.10 – Assigning our new layer'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10 – 分配我们的新层'
- en: '](img/B17984_06_10.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_10.jpg)'
- en: Figure 6.10 – Assigning our new layer
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 分配我们的新层
- en: For larger projects, our game objects probably already have a layer assigned
    to them. As such, instead of changing the object's layer to **Obstacles**, we
    would instead make a list of layers for our cube entity to use when detecting
    obstacles. We will talk more about this in the next section.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于较大的项目，我们的游戏对象可能已经分配了层。因此，我们不会更改对象的层为**Obstacles**，而是为我们的立方体实体创建一个层列表，用于检测障碍物。我们将在下一节中详细介绍这一点。
- en: Info
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: In games, we use layers to let cameras render only a part of the scene or have
    lights illuminate only a subset of the objects. However, layers can also be used
    by raycasting to ignore colliders selectively or to create collisions. You can
    learn more about this at [https://docs.unity3d.com/Manual/Layers.html](https://docs.unity3d.com/Manual/Layers.html).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在游戏中，我们使用层让相机仅渲染场景的一部分，或者让灯光仅照亮对象的一个子集。然而，层也可以通过射线投射来选择性地忽略碰撞体或创建碰撞。您可以在[https://docs.unity3d.com/Manual/Layers.html](https://docs.unity3d.com/Manual/Layers.html)了解更多信息。
- en: Obstacle avoidance
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避障
- en: 'Now, it is time to code the script that makes the cube entity avoid the walls.
    As usual, we first initialize our entity script with the default properties. Here,
    we also draw GUI text in our `OnGUI` method. Let''s take a look at the following
    code in the `VehicleAvoidance.cs` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编写使立方体实体避免墙壁的脚本了。像往常一样，我们首先使用默认属性初始化我们的实体脚本。在这里，我们还在`OnGUI`方法中绘制GUI文本。让我们看看`VehicleAvoidance.cs`文件中的以下代码：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, in the `Update` method, we update the Agent entity''s position and rotation
    based on the direction vector returned by the `AvoidObstacles` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Update`方法中，我们根据`AvoidObstacles`方法返回的方向向量更新Agent实体的位置和旋转：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing we do in the `Update` method is to retrieve the position of
    the mouse-click. Then, we use this position to determine the desired target position
    of our character. To get the mouse-click position, we shoot a ray from the camera
    in the direction it's facing. Then, we take the point where the ray hits the ground
    plane as the target position.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`方法中，我们首先获取鼠标点击的位置。然后，我们使用这个位置来确定我们角色的期望目标位置。为了获取鼠标点击位置，我们从相机面向的方向发射一条射线。然后，我们将射线击中地面平面的点作为目标位置。
- en: 'Once we get the target position, we can calculate the direction vector by subtracting
    the current position vector from the target position vector. Then, we call the
    `AvoidObstacles` method passing this direction to it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到目标位置，我们可以通过从目标位置向量减去当前位置向量来计算方向向量。然后，我们调用`AvoidObstacles`方法，并将这个方向传递给它：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `AvoidObstacles` method is also quite simple. Note that we use another
    very useful Unity physics utility: a **SphereCast**. A SphereCast is similar to
    the Raycast but, instead of detecting a collider by firing a dimensionless ray,
    it fires a chunky sphere. In practice, a SphereCast gives width to the Raycast
    ray.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`AvoidObstacles`方法也很简单。注意，我们使用了另一个非常实用的Unity物理工具：**SphereCast**。SphereCast与Raycast类似，但它不是通过发射一个无尺寸的射线来检测碰撞器，而是发射一个粗壮的球体。在实践中，SphereCast给Raycast射线增加了宽度。'
- en: Why is this important? Because our character is not dimensionless. We want to
    be sure that the entire body of the character can avoid the collision.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要？因为我们的角色不是无尺寸的。我们想确保角色的整个身体可以避免碰撞。
- en: Another thing to note is that the SphereCast interacts selectively with the
    `SphereCast` method accepts a layer mask parameter to determine which layers to
    ignore and consider during raycasting. Now, if you look at how many layers you
    can specify in **Tag Manager**, you'll find a total of 32 layers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，SphereCast会选择性地与`SphereCast`方法交互，它接受一个图层遮罩参数以确定在射线投射期间忽略和考虑哪些图层。现在，如果你看看在**标签管理器**中可以指定多少层，你会发现总共有32层。
- en: 'Therefore, Unity3D uses a 32-bit integer number to represent this layer mask
    parameter. For example, the following would represent a zero in 32 bits:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Unity3D使用32位整数来表示这个图层遮罩参数。例如，以下表示32位中的零：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By default, Unity3D uses the first eight layers as built-in layers. So, when
    you use a Raycast or a SphereCast without using a layer mask parameter, it detects
    every object in those eight layers. We can represent this interaction mask with
    a bitmask, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity3D使用前八个图层作为内置图层。所以，当你使用Raycast或SphereCast而不使用图层遮罩参数时，它会检测那些八个图层中的每一个对象。我们可以用位掩码表示这种交互掩码，如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this demo, we set the **Obstacles** layer as layer 8 (9th index). Because
    we only want to detect obstacles in this layer, we want to set up the bitmask
    in the following way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将**障碍物**图层设置为图层8（第9个索引）。因为我们只想检测这个图层中的障碍物，所以我们需要按以下方式设置位掩码：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The easiest way to set up this bitmask is by using the bit shift operators.
    We only need to place the on bit, `1`, at the 9th index, which means we can just
    move that bit eight places to the left. So, we use the left shift operator to
    move the bit eight places to the left, as shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这个位掩码的最简单方法是使用位移运算符。我们只需要将位，`1`，放置在第9个索引上，这意味着我们只需将这个位向左移动八位。所以，我们使用左移运算符将位向左移动八位，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we wanted to use multiple layer masks, say, layer 8 and layer 9, an easy
    way would be to use the bitwise **OR** operator, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用多个图层遮罩，比如说图层8和图层9，一个简单的方法是使用位或运算符，如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Info
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Info
- en: You can also find a good discussion on using layer masks on Unity3D's online
    resources. The question and answer site can be found at [http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html](http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在Unity3D的在线资源中找到关于使用图层遮罩的良好讨论。问答网站可以在[http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html](http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html)找到。
- en: Once we have the layer mask, we call the `Physics.SphereCast` method from the
    current entity's position and in the forward direction. We use a sphere of radius
    `vehicleRadius` (make sure that is big enough to contain the cubic vehicle in
    its entirety) and a detection distance defined by the `minimumDistToAvoid` variable.
    In fact, we want to detect only the objects that are close enough to affect our
    movement.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了图层遮罩，我们就会从当前实体的位置和前方方向调用`Physics.SphereCast`方法。我们使用半径为`vehicleRadius`的球体（确保足够大，可以完全包含立方车辆）以及由`minimumDistToAvoid`变量定义的检测距离。实际上，我们只想检测足够接近以影响我们移动的对象。
- en: 'Then, we take the normal vector of the hit ray, multiply it with the force
    vector, and add it to the current direction of the entity to get the new resultant
    direction vector, which we return from this method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们取被击中射线的法向量，将其与力向量相乘，并将其加到实体的当前方向上，以获得新的结果向量，然后我们从该方法返回这个向量：
- en: '![Figure 6.11 – How our cube entity avoids a wall'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11 – 我们的立方实体如何避开墙壁'
- en: '](img/B17984_06_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_06_11.jpg)'
- en: Figure 6.11 – How our cube entity avoids a wall
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 我们的立方体实体如何避开墙壁
- en: 'Then, in the `Update` method, we use this new direction to rotate the AI entity
    and update the position according to the speed value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Update`方法中，我们使用这个新的方向来旋转AI实体，并根据速度值更新位置：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we only need to attach this new script to the Vehicle object (this can
    be a simple cube as in the previous example). Remember that this new script needs
    to replace the `VehicleFollowing` script we implemented in the previous section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将这个新的脚本附加到车辆对象上（这可以是一个简单的立方体，就像上一个例子中那样）。记住，这个新的脚本需要替换我们在上一节中实现的`VehicleFollowing`脚本。
- en: '![Figure 6.12 – Properties of our Vehicle Avoidance script'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 – 我们车辆避障脚本的属性](img/B17984_06_12.jpg)'
- en: '](img/B17984_06_12.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 – 我们车辆避障脚本的属性](img/B17984_06_12.jpg)'
- en: Figure 6.12 – Properties of our Vehicle Avoidance script
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 我们车辆避障脚本的属性
- en: If everything is correct, you should be able to see the vehicle navigate across
    the plane around the obstacles without any trouble. As usual, play with the Inspector
    parameters to tweak the vehicle behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，你应该能够看到车辆在没有任何麻烦的情况下绕过障碍物在平面上导航。像往常一样，通过Inspector参数调整车辆行为。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up two scenes and studied how to build path-following
    agents with obstacle avoidance behavior. We learned about the Unity3D layer feature
    and how to use Raycasts and SphereCasts against a particular layer selectively.
    Although these examples were simple, we can apply these simple techniques to various
    scenarios. For instance, we can set up a path along a road. We can easily set
    up a decent traffic simulation using some vehicle models combined with obstacle
    avoidance behavior. Alternatively, you could just replace them with biped characters
    and build a crowd simulation. You can also combine them with some finite state
    machines to add more behaviors and make them more intelligent.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了两个场景，并研究了如何构建具有避障行为的路径跟随代理。我们了解了Unity3D层功能以及如何有选择性地使用Raycasts和SphereCasts对特定层进行操作。尽管这些例子很简单，但我们可以将这些简单技术应用于各种场景。例如，我们可以在道路上设置路径。我们可以轻松地使用一些车辆模型结合避障行为设置一个不错的交通模拟。或者，你也可以用两足人物来替换它们，构建一个人群模拟。你还可以将它们与一些有限状态机结合，以添加更多行为并使其更加智能。
- en: The simple obstacle avoidance behavior that we implemented in this chapter doesn't
    consider the optimal path to reach the target position. Instead, it just goes
    straight to that target, and only if an obstacle is seen within a certain distance
    does it try to avoid it. For this reason, it's supposed to be used among moving
    or dynamic objects and obstacles.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们实现的简单避障行为没有考虑到达目标位置的最佳路径。相反，它只是直接前往那个目标，只有当在特定距离内看到障碍物时，它才会尝试避开它。因此，它应该在移动或动态对象和障碍物之间使用。
- en: In the following chapter, we'll study how to implement a pathfinding algorithm,
    called **A***, to determine the optimal path before moving, while still avoiding
    static obstacles.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究如何实现一个名为**A**的路径查找算法，在移动之前确定最佳路径，同时避开静态障碍物。
