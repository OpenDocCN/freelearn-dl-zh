<html><head></head><body><div><div><p>&#13;
    <h1 class="chapterNumber"><a id="_idTextAnchor059"/>9</h1>&#13;
    <h1 id="_idParaDest-133" class="chapterTitle">Integrating LangChain4j and Spring AI with Neo4j</h1>&#13;
    <p class="normal">Now that we have loaded the data into a graph, in this chapter, we will look at how we can use LangChain4j or Spring AI to augment the graph to enhance its capabilities and build a knowledge graph. We will look into integrating the graph with LLMs to generate a summary of customer purchases and create an embedding of that summary to represent the customer purchase history. These embeddings are crucial for enabling machine learning and graph algorithms to understand and process graph data. These embeddings can help us build a knowledge graph to provide more personal recommendations for customers by understanding purchase behaviors. We will also look at how to create embeddings of the detailed description of each article present in the dataset.</p>&#13;
    <p class="normal">In this chapter, we are going to cover the following main topics:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Setting up LangChain4j and Spring AI</li>&#13;
      <li class="bulletList">Building your recommendation engine with LangChain4j</li>&#13;
      <li class="bulletList">Building your recommendation engine with Spring AI</li>&#13;
      <li class="bulletList">Fine-tuning your recommendation system</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-134" class="heading-1">Technical requirements</h1>&#13;
    <p class="normal">We will be using a Java IDE environment to work with the LangChain4j and Spring AI projects. You need to have these installed and know how to work with them. You will need the following to get started:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Maven will be used to build a project and manage dependencies. If you are going to use the IntelliJ IDE (or IntelliJ IDEA), then Maven will be installed along with it, and you need not install it separately. If you are new to Maven, you can read more about it at <a href="https://maven.apache.org/">https://maven.apache.org/</a>.</li>&#13;
      <li class="bulletList">Java 17.</li>&#13;
      <li class="bulletList">IntelliJ – These examples are built and tested with the IntelliJ IDE. You can use your preferred IDE, however. We will be using the IntelliJ IDEA tool to build and run our projects. You can download the tool from <a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a>. You can download the Community Edition to run the examples in this chapter. You can read more about using this IDE to build Spring applications at <a href="https://www.jetbrains.com/idea/spring/">https://www.jetbrains.com/idea/spring/</a>.</li>&#13;
      <li class="bulletList">Spring Boot – If you are new to Spring Boot, you can go to <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a> to learn more about it.</li>&#13;
      <li class="bulletList">Neo4j Desktop with the following plugins installed. We will be starting from the graph database we built in the last chapter. You can download Neo4j Desktop from <a href="https://neo4j.com/download/">https://neo4j.com/download/</a>. If you are new to Neo4j Desktop, you can learn more about it at <a href="https://neo4j.com/docs/desktop-manual/current/">https://neo4j.com/docs/desktop-manual/current/</a>. The code is tested with the 5.21.2 version of the database. The following are the plugins required:<ul>&#13;
          <li class="bulletList">APOC plugin – 5.21.2</li>&#13;
          <li class="bulletList">Graph Data Science library – 2.9.0</li>&#13;
        </ul>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="normal">The following figure shows how to install these plugins for a DBMS.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_09_01.png" alt="Figure 9.1 — Install plugins on Neo4j Desktop" width="1181" height="880"/></figure>&#13;
    <p class="packt_figref">Figure 9.1 — Install plugins on Neo4j Desktop</p>&#13;
    <p class="normal">When you select the DBMS on Neo4j Desktop, on the right side, it shows its details. Click on the <strong class="screenText">Plugins</strong> tab and select the plugins you require. On the details pane, click on the <strong class="screenText">Install and Restart</strong> button.</p>&#13;
    <div>&#13;
      <p class="normal"> <strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">You can find all the code you need at <a href="https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9">https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9</a>. These are complete projects and ready to run in an IDE. We will only show snippets of the code in this chapter to showcase the usage. So, it might be a good idea to download the code to follow the steps in this chapter.</p>&#13;
    </p>&#13;
    <p class="normal">We will start with setting up the LangChain4j and Spring AI projects.</p>&#13;
    <h1 id="_idParaDest-135" class="heading-1">Setting up LangChain4j and Spring AI</h1>&#13;
    <p class="normal">We will<a id="_idIndexMarker385"/> take a look at setting <a id="_idIndexMarker386"/>up the Spring AI and LangChain4j projects using<a id="_idIndexMarker387"/> the <strong class="screenText">spring initializr </strong>website (<a href="https://start.spring.io/">https://start.spring.io/</a>).</p>&#13;
    <p class="normal">We will look at each of these technologies independently. LangChain4j and Spring AI are both options to perform the same tasks. We need only one of these frameworks to build GenAI projects. LangChain4j has been available for a bit longer than Spring AI. Both of them work pretty similarly in terms of the API and integrations. We will build the same application with both frameworks and see how similar they are. We will also identify the differences.</p>&#13;
    <p class="normal">The following are the steps we need to follow to create the starter projects:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Setting up the LangChain4j project:<ol>&#13;
          <li class="alphabeticList" value="1">Go to the website, <a href="https://start.spring.io/">https://start.spring.io/</a>.</li>&#13;
          <li class="alphabeticList">Select <strong class="screenText">Maven</strong> under the <strong class="screenText">Project</strong> section.</li>&#13;
          <li class="alphabeticList">Select <strong class="screenText">Java</strong> under the <strong class="screenText">Language</strong> section.</li>&#13;
          <li class="alphabeticList">In the <strong class="screenText">Project Metadata</strong> section, fill in the following values:<ul>&#13;
              <li class="bulletList"><strong class="screenText">Group</strong>: <code class="inlineCode">com.packt.genai.hnm.springai</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Artifact</strong>: <code class="inlineCode">springai _graphaugment</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Name</strong>: <code class="inlineCode">springai _graphaugment</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Description</strong>: <code class="inlineCode">Graph Augmenting with Spring AI</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Package Name</strong>: <code class="inlineCode">com.packt.genai.hnm.springai.graphaugment</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Packaging</strong>: <code class="inlineCode">Jar</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Java</strong>: <code class="inlineCode">17</code></li>&#13;
            </ul>&#13;
          </li>&#13;
          <li class="alphabeticList">In the <strong class="screenText">Dependencies</strong> section, click on the <strong class="screenText">Add Dependencies</strong> button and select the <strong class="screenText">Spring Web</strong> dependency.<ul>&#13;
              <li class="bulletList">There are no other dependencies that are currently listed by the initializer to add to the project. We will add LangChain4j dependencies manually to the project.</li>&#13;
            </ul>&#13;
          </li>&#13;
          <li class="alphabeticList">Download and save the ZIP file that is generated.</li>&#13;
        </ol>&#13;
      </li>&#13;
      <li class="numberedList">Setting<a id="_idIndexMarker388"/> up the<a id="_idIndexMarker389"/> Spring AI project:<ol>&#13;
          <li class="alphabeticList" value="1">Go to the website, <a href="https://start.spring.io/">https://start.spring.io/</a>.</li>&#13;
          <li class="alphabeticList">Select <strong class="screenText">Maven</strong> under the <strong class="screenText">Project</strong> section.</li>&#13;
          <li class="alphabeticList">Select <strong class="screenText">Java</strong> under the <strong class="screenText">Language</strong> section.</li>&#13;
          <li class="alphabeticList">In the <strong class="screenText">Project Metadata</strong> section, fill in the following values:<ul>&#13;
              <li class="bulletList"><strong class="screenText">Group</strong>: <code class="inlineCode">com.packt.genai.hnm.langchain</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Artifact</strong>: <code class="inlineCode">langchain_graphaugment</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Name</strong>: <code class="inlineCode">langchain_graphaugment</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Description</strong>: <code class="inlineCode">Graph Augmenting with Langchain4J</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Package Name</strong>: <code class="inlineCode">com.packt.genai.hnm.langchain.graphaugment</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Packaging</strong>: <code class="inlineCode">Jar</code></li>&#13;
              <li class="bulletList"><strong class="screenText">Java</strong>: <code class="inlineCode">17</code></li>&#13;
            </ul>&#13;
          </li>&#13;
          <li class="alphabeticList">In the <strong class="screenText">Dependencies</strong> section, click on the <strong class="screenText">Add Dependencies</strong> button to select the following dependencies:<ul>&#13;
              <li class="bulletList"><strong class="screenText">Spring Web</strong></li>&#13;
              <li class="bulletList"><strong class="screenText">OpenAI</strong></li>&#13;
              <li class="bulletList"><strong class="screenText">Neo4j Vector Database</strong></li>&#13;
            </ul>&#13;
          </li>&#13;
          <li class="alphabeticList">Download and save the ZIP file that is generated.</li>&#13;
        </ol>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">This will only<a id="_idIndexMarker390"/> give us a skeleton project with which we will build the application. The <a id="_idIndexMarker391"/>skeleton project gives us a basic structure upon which we can add more logic.</p>&#13;
    <p class="normal">Let us look at what we want out of our application before we go ahead and build it. We loaded the H&amp;M transaction data into the graph database in the previous chapter. Currently, it holds the customers, articles, and transactions along with some helper relationships that mark the first transaction in a given season and year. As we want to build a personal recommendation system, we want to enhance the graph to understand customer behavior and provide recommendations. For this purpose, we will be taking the following approach:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Select a season for which to understand the purchase behavior. For example, say we want to find the customers who made purchases in summer 2019 and fall 2019 and use the transactions between those seasons to understand customer behavior. Note that there might be some customers who did not make any transactions in the fall of 2019, even though they might have made transactions in the summer of 2019. We are ignoring those customers for this exercise, to make things a bit simpler.</li>&#13;
      <li class="numberedList">Retrieve the articles purchased during these transactions. The articles should match the condition (purchases made in the summer and fall of 2019) in the order they are purchased. We will then use an LLM to summarize these purchases. This summarization preserves the order of the articles purchased.</li>&#13;
      <li class="numberedList">Use the LLM to generate embedding for this summary text. We will be leveraging an OpenAI LLM for this part.</li>&#13;
      <li class="numberedList">Store these embeddings. We will be storing them on the season relationship for which these embeddings are generated. For <a id="_idIndexMarker392"/>example, if we are generating a summary for the summer of <a id="_idIndexMarker393"/>2019, we will store the resulting embeddings on the <code class="inlineCode">SUMMER_2019</code> relationship. An OpenAI LLM is used to generate the embeddings.</li>&#13;
    </ol>&#13;
    <p class="normal">In the next section, we will take a look at building an application that performs the functions we described previously using LangChain4j.</p>&#13;
    <h1 id="_idParaDest-136" class="heading-1">Building your recommendation engine with LangChain4j</h1>&#13;
    <p class="normal">In this<a id="_idIndexMarker394"/> section, we will look at building a graph augmentation application that leverages LangChain4j. In this project, we will be using the GraphRAG approach to generate embeddings for a transaction chain that meets our requirements. We will be using the Neo4j graph retriever to retrieve the transaction chain that meets our requirements, as well as an LLM to generate a summary of those transactions to describe the customer purchase behavior and generate an embedding. The embedding generated will be a vector representation that describes the text summary in a manner that can be leveraged by machine learning or Graph Data Science algorithms. It can also be leveraged for vector search purposes. This <a id="_idIndexMarker395"/>article explains embeddings in the context of LLMs well: <a href="https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/">https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/</a>. We will start with the ZIP file downloaded in the last section. We need to unzip the file we have downloaded. Once it is unzipped, we will load the project into the IntelliJ platform using these steps:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Launch the IntelliJ IDE.</li>&#13;
      <li class="numberedList">Click on <strong class="screenText">File</strong> | <strong class="screenText">New</strong> | <strong class="screenText">Project from Existing Sources…</strong>.</li>&#13;
    </ol>&#13;
    <figure class="mediaobject"><img src="img/B31107_09_02.png" alt="Figure 9.2 — Create a new project" width="1133" height="204"/></figure>&#13;
    <p class="packt_figref">Figure 9.2 — Create a new project</p>&#13;
    <p class="numberedList"><a id="_idTextAnchor060"/>3. Select the <code class="inlineCode">pom.xml</code> file from the directory we unzipped.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_09_03.png" alt="Figure 9.3 — Select pom.xml" width="1193" height="344"/></figure>&#13;
    <p class="packt_figref">Figure 9.3 — Select pom.xml</p>&#13;
    <p class="numberedList"><a id="_idTextAnchor061"/>4. Click <a id="_idIndexMarker396"/>on <strong class="screenText">Trust Project</strong> to load the project.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_09_04.png" alt="Figure 9.4 — Trust Project" width="1207" height="333"/></figure>&#13;
    <p class="packt_figref">Figure 9.4 — Trust Project</p>&#13;
    <p class="numberedList"><a id="_idTextAnchor062"/>5. Select <strong class="screenText">New Window</strong> when prompted.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_09_05.png" alt="Figure 9.5 — Select New Window" width="810" height="308"/></figure>&#13;
    <p class="packt_figref">Figure 9.5 — Select New Window</p>&#13;
    <p class="numberedList"><a id="_idTextAnchor063"/>6. Once <a id="_idIndexMarker397"/>the project is loaded, you can continue to the next section.</p>&#13;
    <p class="normal">In the next section, we will update the project dependencies.</p>&#13;
    <h2 id="_idParaDest-137" class="heading-2">LangChain4j: updating the project dependencies</h2>&#13;
    <p class="normal">When<a id="_idIndexMarker398"/> we used the Spring starter to prepare the starter project, we could only add the dependencies identified by that tool. We need to edit the <code class="inlineCode">pom.xml</code> file to add the dependencies.</p>&#13;
    <p class="normal">The following are the dependencies we need to add to the project:</p>&#13;
    <ul>&#13;
      <li class="bulletList">LangChain4j Spring Boot starter – This dependency provides the Spring Boot integration of LangChain4j:&#13;
        <pre class="programlisting code"><code class="hljs-code">&lt;!-- Langchain Springboot integration --&gt;&#13;
&lt;dependency&gt;&#13;
    &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;&#13;
    &lt;artifactId&gt;langchain4j-spring-boot-starter&lt;/artifactId&gt;&#13;
    &lt;version&gt;0.36.0&lt;/version&gt;&#13;
&lt;/dependency&gt;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">LangChain4j OpenAI integration – This dependency provides the OpenAI integration:&#13;
        <pre class="programlisting code"><code class="hljs-code">&lt;!-- Open AI integration --&gt;&#13;
&lt;dependency&gt;&#13;
    &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;&#13;
    &lt;artifactId&gt;langchain4j-open-ai-spring-boot-starter&lt;/artifactId&gt;&#13;
    &lt;version&gt;0.36.0&lt;/version&gt;&#13;
&lt;/dependency&gt;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">LangChain4j <a id="_idIndexMarker399"/>Neo4j integration – This dependency provides the Neo4j integration:&#13;
        <pre class="programlisting code"><code class="hljs-code">&lt;!-- Neo4j Vector Store integration --&gt;&#13;
&lt;dependency&gt;&#13;
    &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;&#13;
    &lt;artifactId&gt;langchain4j-neo4j&lt;/artifactId&gt;&#13;
    &lt;version&gt;0.35.0&lt;/version&gt;&#13;
&lt;/dependency&gt;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">LangChain4j LLM embeddings integration – This dependency provides the LLM embeddings API:&#13;
        <pre class="programlisting code"><code class="hljs-code">&lt;dependency&gt;&#13;
    &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;&#13;
    &lt;artifactId&gt;langchain4j-embeddings-all-minilm-l6-v2&lt;/artifactId&gt;&#13;
    &lt;version&gt;0.35.0&lt;/version&gt;&#13;
&lt;/dependency&gt;&#13;
</code></pre>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="normal">The latest integration options and details can be found at <a href="https://docs.langchain4j.dev/category/integrations">https://docs.langchain4j.dev/category/integrations</a>.</p>&#13;
    <p class="normal">Now that we have added the project dependencies, we need to update the configuration properties that are <a id="_idIndexMarker400"/>required for the application. In the next section, we will be looking at updating the application properties.</p>&#13;
    <p>&#13;
      <p class="normal"> <strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">When you have made changes to the <code class="inlineCode">pom.xml</code> file, you might have to reload the <br/>project for the IDE to update all the dependencies correctly. You can learn more about how to work with Maven projects with IntelliJ IDEA at <a href="https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport">https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport</a>.</p>&#13;
    </p>&#13;
    <h2 id="_idParaDest-138" class="heading-2">LangChain4j: updating the application properties</h2>&#13;
    <p class="normal">In <a id="_idIndexMarker401"/>this section, we need to update the application properties for the dependencies we added in the last section to be able to leverage the APIs. We need to add this configuration to the <code class="inlineCode">application.properties</code> file in the project. Since we will be using the OpenAI LLM for the chat model and embeddings, we need to acquire an API key for this purpose. We need to visit the following website to acquire an API key for this purpose: <a href="https://platform.openai.com/docs/overview">https://platform.openai.com/docs/overview</a>.</p>&#13;
    <p class="normal">These are the configuration properties we need to add:</p>&#13;
    <ul>&#13;
      <li class="bulletList">OpenAI chat model integration – We need to add this configuration to <code class="inlineCode">application.properties</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code"># Open AI LLM Integration for Generating Summary using Chat Model.&#13;
langchain4j.open-ai.chat-model.api-key=&lt;<code style="font-weight: bold;" class="codeHighlighted">OPEN_AI_KEY</code>&gt;&#13;
langchain4j.open-ai.chat-model.model-name=gpt-4o-mini&#13;
langchain4j.open-ai.chat-model.log-requests=true&#13;
langchain4j.open-ai.chat-model.log-responses=true&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">OpenAI embeddings integration – We need to add this configuration to <code class="inlineCode">application.properties</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code"># Open AI LLM Integration for Generating Embeddings&#13;
langchain4j.open-ai.embedding-model.api-key=&lt;<code style="font-weight: bold;" class="codeHighlighted">OPEN_AI_KEY</code>&gt;&#13;
langchain4j.open-ai.embedding-model.model-name=text-embedding-3-large&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">Neo4j <a id="_idIndexMarker402"/>integration – We will add basic Neo4j integration this time, not the Neo4j vector database-related integration:&#13;
        <pre class="programlisting code"><code class="hljs-code"># Neo4j Integration&#13;
neo4j.uri=bolt://localhost:7687&#13;
neo4j.user=neo4j&#13;
neo4j.password=test1234&#13;
neo4j.database=hmreco&#13;
config.batchSize=5&#13;
</code></pre>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="normal">Now that we have looked at the configuration properties, let us start building the application. We will start with Neo4j database integration, and then add chat model integration to summarize the transactions and generate embeddings for the summary. Finally, we will take a look at building a REST endpoint to invoke those request<a id="_idTextAnchor064"/>s as needed.</p>&#13;
    <h2 id="_idParaDest-139" class="heading-2">LangChain4j: Neo4j integration</h2>&#13;
    <p class="normal">We will take a look at Neo4j<a id="_idIndexMarker403"/> integration first. We will look at this first as we need a means to integrate with the database to perform these tasks:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Set up connectivity to be able to perform read and write transactions.</li>&#13;
      <li class="numberedList">Read the articles for the transactions that occurred for the specified season.</li>&#13;
      <li class="numberedList">Persist (save) the embeddings once they are generated.</li>&#13;
    </ol>&#13;
    <p class="normal">Before we can build this logic, we need to create a <strong class="keyWord">configuration bean</strong> for Neo4j connectivity. We can define that bean like this to read from <code class="inlineCode">application.properties</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">@ConfigurationProperties(prefix = "neo4j")&#13;
public class Neo4jConfiguration { &#13;
    private String uri; &#13;
    private String user ; &#13;
    private String password ; &#13;
    private String database ; &#13;
   <em class="italic">/** Getter/Setters **/</em>&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">ConfigurationProperties</code> annotation on top of the class definition will read <code class="inlineCode">application.properties</code> and initialize the properties in the bean. The <code class="inlineCode">prefix</code> option tells us to read only the properties that start with that prefix. For example, if we want the <code class="inlineCode">uri</code> field to be populated, then we need to add the <code class="inlineCode">neo4j.uri</code> property to the configuration. We have not included all the getter and setter code that is required to read the properties from this bean here.</p>&#13;
    <p class="normal">Now, we will define a service to provide integration with the Neo4j database to read the articles and customer transactions data and update the embeddings as needed:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Define the service class using <code class="inlineCode">@Service</code> annotation. We also need to inject <code class="inlineCode">Neo4JConfiguration</code> here:&#13;
        <pre class="programlisting code"><code class="hljs-code">@Service&#13;
@Configuration&#13;
@EnableConfigurationProperties(Neo4jConfiguration.class)&#13;
public class Neo4jService {&#13;
    @Autowired&#13;
    private Neo4jConfiguration configuration ;&#13;
    private Driver driver ;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add the <code class="inlineCode">setup</code> method to initialize the connection to the Neo4j database:&#13;
        <pre class="programlisting code"><code class="hljs-code">    public synchronized void setup() {&#13;
        if( driver == null ) {&#13;
            driver = GraphDatabase.driver(&#13;
                    configuration.getUri(),&#13;
                    AuthTokens.basic(&#13;
                            configuration.getUser(),&#13;
                            configuration.getPassword()));&#13;
            driver.verifyConnectivity();&#13;
        }&#13;
    }&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add the<a id="_idIndexMarker404"/> method to get the customer transactions data for given start- and end-of-season values. Based on the start- and end-of-season values provided, it retrieves the <code class="inlineCode">elementId</code> value of the start-of-season value and the article description in the sequence they are purchased. We need this <code class="inlineCode">elementId</code> value to save the embeddings later. We can see that we are trying to get more related data from the article attributes instead of just the description. This way, we can include more attributes, such as color, as part of the summary, so that we can represent them as embeddings more accurately:&#13;
        <pre class="programlisting code"><code class="hljs-code">public List&lt;EncodeRequest&gt; getDataFromDB(String startSeason, String endSeason) {&#13;
    setup();&#13;
    String cypherTemplate = """&#13;
        --- Cypher query to get the transactions&#13;
    """;&#13;
    String cypher = String.format(cypherTemplate, startSeason, endSeason);&#13;
    SessionConfig config = SessionConfig.builder()&#13;
        .withDatabase(configuration.getDatabase())&#13;
        .build();&#13;
    try (Session session = driver.session(config)) {&#13;
        List&lt;EncodeRequest&gt; data = session.executeRead(tx -&gt; {&#13;
            List&lt;EncodeRequest&gt; out = new ArrayList&lt;&gt;();&#13;
            var records = tx.run(cypher);&#13;
            while (records.hasNext()) {&#13;
                var record = records.next();&#13;
                String id = record.get("elementId").asString();&#13;
                String articles = record.get("articles").asString();&#13;
                out.add(new EncodeRequest(articles, id));&#13;
            }&#13;
            return out;&#13;
        });&#13;
        return data;&#13;
    } catch (Exception e) {&#13;
        e.printStackTrace();&#13;
    }&#13;
    return null;&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add the <a id="_idIndexMarker405"/>method to get the articles from the database:&#13;
        <pre class="programlisting code"><code class="hljs-code">public List&lt;EncodeRequest&gt; getArticlesFromDB() {&#13;
    setup();&#13;
    String cypherTemplate = """&#13;
        -- Cypher query to get the articles.&#13;
    """;&#13;
    SessionConfig config = SessionConfig.builder()&#13;
        .withDatabase(configuration.getDatabase())&#13;
        .build();&#13;
    try (Session session = driver.session(config)) {&#13;
        List&lt;EncodeRequest&gt; data = session.executeRead(tx -&gt; {&#13;
            List&lt;EncodeRequest&gt; out = new ArrayList&lt;&gt;();&#13;
            var records = tx.run(cypherTemplate);&#13;
            while (records.hasNext()) {&#13;
                var record = records.next();&#13;
                String id = record.get("elementId").asString();&#13;
                String article = record.get("article").asString();&#13;
                out.add(new EncodeRequest(article, id));&#13;
            }&#13;
            return out;&#13;
        });&#13;
        return data;&#13;
    } catch (Exception e) {&#13;
        e.printStackTrace();&#13;
    }&#13;
    return null;&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add a method to save the embeddings for the selected season of a customer. We are keeping the summary in the graph to understand what the embedding represents. Once<a id="_idIndexMarker406"/> we understand this aspect, we don’t need to store the summary in the database:&#13;
        <pre class="programlisting code"><code class="hljs-code">public void saveEmbeddings(List&lt;Map&lt;String, Object&gt;&gt; embeddings) {&#13;
    setup();&#13;
    String cypher = """&#13;
        UNWIND $data as row&#13;
        WITH row&#13;
        MATCH ()-[r]-&gt;()&#13;
        WHERE elementId(r) = row.id&#13;
        SET r.summary = row.summary&#13;
        WITH row, r&#13;
        CALL db.create.setRelationshipVectorProperty(r, 'embedding', row.embedding)&#13;
    """;&#13;
    SessionConfig config = SessionConfig.builder()&#13;
        .withDatabase(configuration.getDatabase())&#13;
        .build();&#13;
    try (Session session = driver.session(config)) {&#13;
        session.executeWriteWithoutResult(tx -&gt; {&#13;
            tx.run(cypher, Map.of("data", embeddings));&#13;
        });&#13;
    } catch (Exception e) {&#13;
        e.printStackTrace();&#13;
    }&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add a <a id="_idIndexMarker407"/>method to save the embeddings for the <code class="inlineCode">Article</code> text on an <code class="inlineCode">Article</code> node:&#13;
        <pre class="programlisting code"><code class="hljs-code">public void saveArticleEmbeddings(List&lt;Map&lt;String, Object&gt;&gt; embeddings) {&#13;
    setup();&#13;
    String cypher = """&#13;
        UNWIND $data as row&#13;
        WITH row&#13;
        MATCH (a:Article)&#13;
        WHERE elementId(a) = row.id&#13;
        CALL db.create.setNodeVectorProperty(a, 'embedding', row.embedding)&#13;
    """;&#13;
    SessionConfig config = SessionConfig.builder()&#13;
        .withDatabase(configuration.getDatabase())&#13;
        .build();&#13;
    try (Session session = driver.session(config)) {&#13;
        session.executeWriteWithoutResult(tx -&gt; {&#13;
            tx.run(cypher, Map.of("data", embeddings));&#13;
        });&#13;
    } catch (Exception e) {&#13;
        e.printStackTrace();&#13;
    }&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">From the code, we can see that this service depends on <code class="inlineCode">Neo4jConfiguration</code> and provides these methods.</p>&#13;
    <p class="normal">The code flow here is simple<a id="_idIndexMarker408"/> and provides utility methods to interact with a Neo4j database. The methods to get and save data have Cypher queries embedded into the code here.</p>&#13;
    <p class="normal">Next, we will take a look at an OpenAI chat model integration that can generate a summary for the list of articles.</p>&#13;
    <h2 id="_idParaDest-140" class="heading-2">LangChain4j: OpenAI chat integration</h2>&#13;
    <p class="normal">To integrate the chat, we need to <a id="_idIndexMarker409"/>define <code class="inlineCode">AiService</code>. This is the API exposed by Langchain4J to build Java applications.</p>&#13;
    <p class="normal">Let’s see how we can do this:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">When we define <code class="inlineCode">AiService</code>, the LangChain4j Spring Framework provides the implementation under the covers to make it very easy to invoke the chat service. Let’s look at how this can be defined:&#13;
        <pre class="programlisting code"><code class="hljs-code">@AiService&#13;
public interface ChatAssistant {&#13;
    @SystemMessage("""&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">We set a role for the LLM chat engine. This sets the context for the engine on what guidelines to use to handle the data:&#13;
        <pre class="programlisting code"><code class="hljs-code">             ---Role---&#13;
           &#13;
             You are an helpful assistant with expertise in fashion for a clothing company.&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">We set a<a id="_idIndexMarker410"/> goal for the LLM engine here on how it should process the data. This describes what the input data is and how it is structured:&#13;
        <pre class="programlisting code"><code class="hljs-code">           &#13;
             ---Goal---&#13;
           &#13;
            Your goal is to generate a summary of the products purchased by the customers and descriptions of each of the products.\s&#13;
            Your summary should contain two sections -\s&#13;
            Section 1 - Overall summary outlining the fashion preferences of the customer based on the purchases. Limit the summary to 3 sentences&#13;
            Section 2 - highlight 3-5 individual purchases.&#13;
          &#13;
            You should use the data provided in the section below as the primary context for generating the response.\s&#13;
            If you don't know the answer or if the input data tables do not contain sufficient information to provide an answer, just say so.\s&#13;
            Do not make anything up.&#13;
          &#13;
            Data Description:&#13;
            - Each Customer has an ID. Customer ID is a numeric value.&#13;
            - Each Customer has purchased more than one clothing articles (products). Products have descriptions.&#13;
            - The order of the purchases is very important. You should take into account the order when generating the summary.&#13;
          &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">The response directive for the LLM gives directions on how the response should be structured:&#13;
        <pre class="programlisting code"><code class="hljs-code">            Response:&#13;
            ---&#13;
            # Overall Fashion Summary:&#13;
          &#13;
            \\n\\n&#13;
          &#13;
            # Individual Purchase Details:&#13;
          &#13;
            --&#13;
          &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">The <code class="inlineCode">Data</code> section has the <code class="inlineCode">{text}</code> variable defined, which is substituted with the input the method receives:&#13;
        <pre class="programlisting code"><code class="hljs-code">            Data:&#13;
            {text}&#13;
    """)&#13;
    String chat(String text);&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Here, we are <a id="_idIndexMarker411"/>defining an interface with an <code class="inlineCode">@AiService</code> annotation. In this service, we need to define a chat method. We will be using a simple AI chat service with a <code class="inlineCode">System Message</code> option here. To read about the common operations and advanced operations that <code class="inlineCode">AIServices</code> offers, please read the documentation at <a href="https://docs.langchain4j.dev/tutorials/ai-services/">https://docs.langchain4j.dev/tutorials/ai-services/</a>. Here, we are asking the LLM to act like a fashion expert and give us a summary of customer fashion preferences and highlight the top purchases, keeping the order of purchases in mind. The <code class="inlineCode">input</code> parameter from the text is used as input data to the chat assistant.</p>&#13;
    <p class="normal">Now we will take a look at how we can invoke this chat request:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">@Service&#13;
public class OpenAIChatService&#13;
    private ChatAssistant assistant ;&#13;
    public OpenAIChatService(ChatAssistant assistant) {&#13;
        this.assistant = assistant;&#13;
    }&#13;
    public String getSummaryText(String input) {&#13;
        String out = assistant.chat(input) ;&#13;
        return out ;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <pre>getSummaryText</code> method invokes the chat request. It is as simple as that to integrate the chat services into the application.</pre>&#13;
    <p class="normal">We will take a look at embedding model integration next.</p>&#13;
    <h2 id="_idParaDest-141" class="heading-2">LangChain4j: OpenAI embedding model integration</h2>&#13;
    <p class="normal">Embedding model integration is <a id="_idIndexMarker413"/>pretty simple since we have already enabled <code class="inlineCode">AiService</code> for the chat service. The embedding model usage looks as shown in the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">@Service&#13;
public class OpenAIEmbeddingModelService {&#13;
    EmbeddingModel embeddingModel ;&#13;
    public OpenAIEmbeddingModelService(EmbeddingModel embeddingModel) {&#13;
        this.embeddingModel = embeddingModel;&#13;
    }&#13;
    Embedding generateEmbedding(String text) {&#13;
        Response&lt;Embedding&gt; response = embeddingModel.embed(text) ;&#13;
        return  response.content() ;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">We can see <a id="_idIndexMarker414"/>from the code that it is as simple as adding <code class="inlineCode">EmbeddingModel</code> to the class and initializing it using a constructor. When the Spring Boot application starts, the appropriate embedding model implementation based on properties is instantiated and assigned to this variable. This service provides a method to generate the embedding for a given text.</p>&#13;
    <p class="normal">Now that we have looked at all the services defined, let us look at how we can use all of these to build the application to augment a cust<a id="_idTextAnchor065"/>omer transactions graph.</p>&#13;
    <h2 id="_idParaDest-142" class="heading-2">LangChain4j: final application</h2>&#13;
    <p class="normal">For the final application, we will build a REST<a id="_idIndexMarker415"/> endpoint to issue the request to perform the augmentation. Since the process itself can take time, it is split into two parts:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Issue a request to start the augmentation process. This returns a request ID.</li>&#13;
      <li class="numberedList">We can use the request ID returned in step 1 to check the progress of the request.</li>&#13;
    </ol>&#13;
    <p class="normal">Let us look at the REST controller first to issue requests:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">We need to create a REST controller to handle the HTTP requests:&#13;
        <pre class="programlisting code"><code class="hljs-code">@Configuration&#13;
@EnableConfigurationProperties(RunConfiguration.class)&#13;
@RestController&#13;
public class LangchainGraphAugmentController {&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Inject the<a id="_idIndexMarker416"/> individual services defined using the <code class="inlineCode">Autowired</code> directive:&#13;
        <pre class="programlisting code"><code class="hljs-code">    @Autowired&#13;
    private OpenAIEmbeddingModelService embeddingModelService ;&#13;
    @Autowired&#13;
    private Neo4jService neo4jService ;&#13;
    @Autowired&#13;
    private OpenAIChatService chatService ;&#13;
    @Autowired&#13;
    private RunConfiguration configuration ;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Define the global variable to hold the current processing requests:&#13;
        <pre class="programlisting code"><code class="hljs-code">    private HashMap&lt;String, IRequest&gt; currentRequests = new HashMap&lt;&gt;() ;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add the method to start the customer transactions augmenting process. This method takes the start- and end-of-season values and creates a <code class="inlineCode">ProcessRequest</code> object. It starts a process thread that requests and returns a <code class="inlineCode">UUID</code> for this request. We keep the <code class="inlineCode">UUID</code> and <code class="inlineCode">ProcessRequest</code> mapping so that we can provide the status when requested:&#13;
        <pre class="programlisting code"><code class="hljs-code">    @GetMapping("/augment/{startSeason}/{endSeason}")&#13;
    public String processAugment(&#13;
            @PathVariable (value="startSeason") String startSeason,&#13;
            @PathVariable (value="endSeason") String endSeason&#13;
    ) {&#13;
        String uuid = UUID.randomUUID().toString() ;&#13;
        ProcessRequest request = new ProcessRequest(&#13;
                chatService,&#13;
                embeddingModelService,&#13;
                neo4jService,&#13;
                configuration,&#13;
                startSeason,&#13;
                endSeason&#13;
        ) ;&#13;
        currentRequests.put(uuid, request) ;&#13;
        Thread t = new Thread(request) ;&#13;
        t.start();&#13;
        return uuid ;&#13;
    }&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add the <a id="_idIndexMarker417"/>method to start the article text augmentation process:&#13;
        <pre class="programlisting code"><code class="hljs-code">    @GetMapping("/augmentArticles")&#13;
    public String processAugmentArticles() {&#13;
        String uuid = UUID.randomUUID().toString() ;&#13;
        ProcessArticles request = new ProcessArticles(&#13;
                embeddingModelService,&#13;
                neo4jService,&#13;
                configuration&#13;
        ) ;&#13;
        currentRequests.put(uuid, request) ;&#13;
        Thread t = new Thread(request) ;&#13;
        t.start();&#13;
        return uuid ;&#13;
    }&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Add a<a id="_idIndexMarker418"/> method to get the status of the specified request ID:&#13;
        <pre class="programlisting code"><code class="hljs-code">    @GetMapping("/augment/status/{requestId}")&#13;
    public String getStatus(&#13;
            @PathVariable (value="requestId") String requestId) {&#13;
        IRequest request = currentRequests.get(requestId) ;&#13;
        if( request != null ) {&#13;
            if( request.isComplete() ) {&#13;
                currentRequests.remove(requestId) ;&#13;
            }&#13;
            return request.getCurStatus() ;&#13;
        } else {&#13;
            return "Request Not Found." ;&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
        <p>&#13;
          <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
          <p class="normal">The graph augmenting process can take a lot of time. In particular, the summary generation part using the LLM chat API can be time-consuming and it can take quite a lot of time to augment all the customers that match the requirements, say, the summer of 2019 purchases. For that reason, the database dump that has the complete augmentation only covers around 10,000 customers.</p>&#13;
        </p>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Now, let us look at the process request implementation. This is where we tie in all the various APIs to perform the required process:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">We need to define a class <code class="inlineCode">ProcessRequest</code> that implements the <code class="inlineCode">Runnable</code> interface. We will start a thread as these requests are long-running ones. The chat service, embedding model service, Neo4j service, and other parameters are passed as input when we create this<a id="_idIndexMarker419"/> request. This class keeps track of the current processing status:&#13;
        <pre class="programlisting code"><code class="hljs-code">public class ProcessRequest implements Runnable, IRequest {&#13;
    private OpenAIChatService chatService ;&#13;
    private OpenAIEmbeddingModelService embeddingModelService ;&#13;
    private Neo4jService neo4jService ;&#13;
    private RunConfiguration configuration ;&#13;
    private String startSeson ;&#13;
    private String endSeason ;&#13;
    private String curStatus = "0 %" ;&#13;
    private boolean isComplete = false ;&#13;
    public ProcessRequest(&#13;
            OpenAIChatService chatService,&#13;
            OpenAIEmbeddingModelService embeddingModelService,&#13;
            Neo4jService neo4jService,&#13;
            RunConfiguration configuration,&#13;
            String startSeson,&#13;
            String endSeason) {&#13;
        this.chatService = chatService;&#13;
        this.embeddingModelService = embeddingModelService;&#13;
        this.neo4jService = neo4jService;&#13;
        this.configuration = configuration ;&#13;
        this.startSeson = startSeson ;&#13;
        this.endSeason = endSeason ;&#13;
    }&#13;
    public String getCurStatus() {&#13;
        return curStatus ;&#13;
    }&#13;
    public boolean isComplete() {&#13;
        return isComplete;&#13;
    }&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">The <code class="inlineCode">run</code> method implements the actual process:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    @Override&#13;
    public void run() {&#13;
        try {&#13;
</code></pre>&#13;
    <ol>&#13;
      <li class="numberedList" value="2">Retrieve the <a id="_idIndexMarker420"/>customer transactions data from the Neo4j database. The output is a list, where each record contains the relationship ID for the start season as the context and the description of the articles in the order in which they were purchased:&#13;
        <pre class="programlisting code"><code class="hljs-code">            System.out.println("Retrieving Data from Graph");&#13;
            List&lt;EncodeRequest&gt; dbData = neo4jService.getDataFromDB(startSeson, endSeason);&#13;
            System.out.println("Retrieved Data from Graph");&#13;
            int i = 0;&#13;
            int processingSize = dbData.size();&#13;
            List&lt;Map&lt;String, Object&gt;&gt; embeddings = new ArrayList&lt;&gt;();&#13;
            for( EncodeRequest request: dbData ) {&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Once you reach the required batch size of results collected, save the data to the Neo4j database:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">                if (i &gt; 0 &amp;&amp; i % configuration.getBatchSize() == 0) {&#13;
                    System.out.println("Saving Embeddings to Graph : " + i);&#13;
                    neo4jService.saveEmbeddings(embeddings);&#13;
                    embeddings.clear();&#13;
                    curStatus = ( ( i * 100.0 ) / processingSize ) + " %";&#13;
                }&#13;
                i++;&#13;
                Map&lt;String, Object&gt; embedMap = new HashMap&lt;&gt;();&#13;
</code></pre>&#13;
    <ol>&#13;
      <li class="numberedList" value="3">Retrieve the customer purchase summary from the LLM chat service by passing the list of transactions retrieved from the graph:&#13;
        <pre class="programlisting code"><code class="hljs-code">                String id = request.getId();&#13;
                System.out.println("Retrieving Summary");&#13;
                String summary = chatService.getSummaryText(request.getText());&#13;
                System.out.println("Retrieving embedding");&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">For the summary we get from the LLM chat service, create an embedding by leveraging the embedding service:&#13;
        <pre class="programlisting code"><code class="hljs-code">                Embedding embedding = embeddingModelService.generateEmbedding(summary);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">Save the summary and embedding along with the relationship context ID into a record and then save it into a batch:&#13;
        <pre class="programlisting code"><code class="hljs-code">                embedMap.put("id", id);&#13;
                embedMap.put("embedding", embedding.vector());&#13;
                embedMap.put("summary", summary);&#13;
                embeddings.add(embedMap);&#13;
            }&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">If any data is left in the batch, save that data to the Neo4j database:&#13;
        <pre class="programlisting code"><code class="hljs-code">            if( embeddings.size() &gt; 0 ) {&#13;
                System.out.println("Saving Embeddings to Graph");&#13;
                neo4jService.saveEmbeddings(embeddings);&#13;
                embeddings.clear();&#13;
            }&#13;
            curStatus = "100 %";&#13;
        }catch (Exception e) {&#13;
            e.printStackTrace();&#13;
        }&#13;
        isComplete = true;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">With this<a id="_idIndexMarker421"/> approach, we can augment the graph to perform the next steps to understand customer purchase behavior to be able to provide them with better recommendations.</p>&#13;
    <p class="normal">The following code can process the article augmentation. The code is pretty much similar to the <code class="inlineCode">ProcessRequest</code> class. We will look at only the differences here:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public class ProcessArticles implements Runnable, IRequest {  &#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">run</code> method reads the data from Neo4j and splits it into batches before invoking the batch embedding request:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    @Override&#13;
    public void run() {&#13;
      &#13;
            List&lt;EncodeRequest&gt; dbData = neo4jService.getArticlesFromDB();&#13;
          &#13;
            for( EncodeRequest request: dbData ) {&#13;
                if (i &gt; 0 &amp;&amp; i % batchSize == 0) {&#13;
</code></pre>&#13;
    <p class="normal">Once the <a id="_idIndexMarker422"/>batch of article texts is collected, we will pass that batch to the embedding service to get the embeddings. We will save the embeddings generated to the Neo4j database:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">                                       List&lt;Embedding&gt; embedList = embeddingModelService.generateEmbeddingBatch(inputData);&#13;
                                                            neo4jService.saveArticleEmbeddings(embeddings);&#13;
                                    }&#13;
                                i++;&#13;
            }&#13;
</code></pre>&#13;
    <p class="normal">Generate the embeddings for any of the remaining article texts and save them to the Neo4j database:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">            if( inputData.size() &gt; 0 ) {&#13;
                                List&lt;Embedding&gt; embedList = embeddingModelService.generateEmbeddingBatch(inputData);&#13;
                 neo4jService.saveArticleEmbeddings(embeddings);&#13;
                            }&#13;
            curStatus = "100 %";&#13;
        }catch (Exception e) {&#13;
            e.printStackTrace();&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The flow of the operation is similar to the one in the <code class="inlineCode">ProcessRequest</code> class. While we used a single request mode for season purchase embeddings, for article embeddings, we are using the <em class="italic">batch mode</em>. With the single request mode (using the API), we could generate only one summary at a time. However, with the batch mode, it is much faster to generate embeddings.</p>&#13;
    <p class="normal">You can download the latest project from <a href="https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment">https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment</a> instead of building it from scratch if you would like to play with it.</p>&#13;
    <p class="normal">To run the project, you<a id="_idIndexMarker423"/> can right-click on the <code class="inlineCode">LangchainGraphaugmentApplication.java</code> file and select the <strong class="screenText">Run</strong> menu option.</p>&#13;
    <p>&#13;
      <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">If you are interested in customizing the run options and other aspects, then you can use the <strong class="screenText">Run</strong>/<strong class="screenText">Debug</strong> configurations provided by the IDE. To learn more about these aspects, please visit <a href="https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html">https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html</a>.</p>&#13;
    </p>&#13;
    <p class="normal">In the next section, we will take a look at how we can build the same recommendation engine using Spring AI.</p>&#13;
    <h1 id="_idParaDest-143" class="heading-1">Building your recommendation engine with Spring AI</h1>&#13;
    <p class="normal">In this section, we will <a id="_idIndexMarker424"/>look at building the graph augmentation application leveraging Spring AI. This project approach is similar to what we built using LangChain4j. We will be leveraging the GraphRAG approach to generate embeddings for a transaction chain that meets our requirements. We will start with the ZIP file downloaded in the last section. We need to unzip the file we have downloaded. Once it is unzipped, we will load the project into the IntelliJ platform using these steps. This is similar to what we did in the previous section. Please follow the steps listed at the start of the <em class="italic">Building your recommendation engine with LangChain4j</em> section to import the project.</p>&#13;
    <p class="normal">In contrast to <a id="_idIndexMarker425"/>LangChain4j, there are no significant steps to update Spring AI project dependencies. Let’s see why.</p>&#13;
    <h2 id="_idParaDest-144" class="heading-2">Spring AI: updating the project dependencies</h2>&#13;
    <p class="normal">Unlike the <a id="_idIndexMarker426"/>LangChain4j project, we don’t need to update any dependencies. We were able to add all the required dependencies from the Spring starter project. We will take a look next at updating the application properties.</p>&#13;
    <h2 id="_idParaDest-145" class="heading-2">Spring AI: updating the application properties</h2>&#13;
    <p class="normal">In this section, we need to<a id="_idIndexMarker427"/> update the application properties to be able to leverage the APIs. We need to add this configuration to the <code class="inlineCode">application.properties</code> file in the project. Since we will be using an OpenAI LLM for the chat model and embeddings, we need to acquire an API key for this purpose, which we can do by visiting <a href="https://platform.openai.com/docs/overview">https://platform.openai.com/docs/overview</a>.</p>&#13;
    <p class="normal">These are the configuration properties we need to add:</p>&#13;
    <ul>&#13;
      <li class="bulletList">OpenAI chat model integration – We need to add this configuration to <code class="inlineCode">application.properties</code>. We only need to add the OpenAI API key:&#13;
        <pre class="programlisting code"><code class="hljs-code"># Open AI LLM Integration for Generating Summary using Chat Model.&#13;
spring.ai.openai.api-key=<code style="font-weight: bold;" class="codeHighlighted">&lt;OPEN_AI_KEY&gt;</code>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">OpenAI embeddings integration – We need to add this configuration to <code class="inlineCode">application.properties</code>. We don’t need to add the OpenAI API key again, as it uses the same configuration as the LLM chat configuration:&#13;
        <pre class="programlisting code"><code class="hljs-code"># Open AI LLM Integration for Generating Embeddings&#13;
spring.ai.openai.embedding.options.model=text-embedding-3-large&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="bulletList">Neo4j integration – We will add basic Neo4j integration, not the <a id="_idIndexMarker428"/>Neo4j vector database-related integration:&#13;
        <pre class="programlisting code"><code class="hljs-code"># Neo4j Integration&#13;
neo4j.uri=bolt://localhost:7687&#13;
neo4j.user=neo4j&#13;
neo4j.password=test1234&#13;
neo4j.database=hmreco&#13;
config.batchSize=5&#13;
</code></pre>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="normal">Now that we have looked at the configuration properties, let us start building the application. We will start with Neo4j database integration first, then add chat model integration for summarizing the transactions and generating embeddings for the summary. Finally, we will take a look at building a REST endpoint to invoke those requests as needed.</p>&#13;
    <h2 id="_idParaDest-146" class="heading-2">Spring AI: Neo4j integration</h2>&#13;
    <p class="normal">We are looking at Neo4j <a id="_idIndexMarker429"/>integration first as we need a means to integrate with the database to perform the following tasks:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Set up connectivity to be able to perform read and write transactions.</li>&#13;
      <li class="numberedList">See the articles for the transactions that occurred for the specified period.</li>&#13;
      <li class="numberedList">Persist the embeddings once they are generated.</li>&#13;
    </ol>&#13;
    <p class="normal">The implementation here is exactly the same as the LangChain4j project discussed in the <em class="italic">Langchain4J – Neo4j integration</em> part of the previous section. We will take a look at an OpenAI chat model integration that can generate a summary for the list of articles.</p>&#13;
    <h2 id="_idParaDest-147" class="heading-2">Spring AI: OpenAI chat integration</h2>&#13;
    <p class="normal">To integrate the chat, it is a bit<a id="_idIndexMarker430"/> different from LangChain4j. We need to define <code class="inlineCode">Service</code> and initialize <code class="inlineCode">ChatClient</code>. We need to leverage this client and use chat APIs to make the request. It is not abstracted as it is with LangChain4j. Let us take a look at this service:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">@Service&#13;
public class OpenAIChatService {&#13;
    private final ChatClient chatClient;&#13;
</code></pre>&#13;
    <p class="normal">Let’s now look at the steps to integrate OpenAI chat:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">We have to provide the prompts for the LLM slightly differently in the Spring AI framework. In the LangChain4j framework, we had a single system message that defined the role the LLM is playing, the goal for the response, and data as a parameter in a single message. Here, we have to split the role and goal into a system prompt template, while the <code class="inlineCode">data</code> parameter is passed into the user message. The outcome is the same in both cases:&#13;
        <pre class="programlisting code"><code class="hljs-code">    private final String SYSTEM_PROMPT_TEMPLATE = """&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">We are setting a role for the LLM chat engine. This sets the context for the engine on what guidelines to use to handle the data:&#13;
        <pre class="programlisting code"><code class="hljs-code">             ---Role---&#13;
           &#13;
             You are an helpful assistant with expertise in fashion for a clothing company.&#13;
           &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">We are setting<a id="_idIndexMarker431"/> a goal for the LLM engine here on how it should process the data. This describes what the input data is and how it is structured:&#13;
        <pre class="programlisting code"><code class="hljs-code">             ---Goal---&#13;
           &#13;
            Your goal is to generate a summary of the products purchased by the customers and descriptions of each of the products.\s&#13;
            Your summary should contain two sections -\s&#13;
            Section 1 - Overall summary outlining the fashion preferences of the customer based on the purchases. Limit the summary to 3 sentences&#13;
            Section 2 - highlight 3-5 individual purchases.&#13;
          &#13;
            You should use the data provided in the section below as the primary context for generating the response.\s&#13;
            If you don't know the answer or if the input data tables do not contain sufficient information to provide an answer, just say so.\s&#13;
            Do not make anything up.&#13;
          &#13;
             Data Description:&#13;
            - Each Customer has an ID. Customer ID is a numeric value.&#13;
            - Each Customer has purchased more than one clothing articles (products). Products have descriptions.&#13;
            - The order of the purchases is very important. You should take into account the order when generating the summary.&#13;
      &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">The response directive for the LLM gives directions on how the response should be structured:&#13;
        <pre class="programlisting code"><code class="hljs-code">            Response:&#13;
            ---&#13;
            # Overall Fashion Summary:&#13;
      &#13;
            \\n\\n&#13;
      &#13;
            # Individual Purchase Details:&#13;
    --&#13;
    """ ;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">The data is passed as a user message here. It has the <code class="inlineCode">{text}</code> variable defined, which is the property that is substituted with the input the method receives:&#13;
        <pre class="programlisting code"><code class="hljs-code">    private final String userMessage = """&#13;
            Data:&#13;
            {text}&#13;
            """ ;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">We need to<a id="_idIndexMarker432"/> initialize the chat client using <code class="inlineCode">ChatClient.Builder</code>, which is injected by the Spring Framework into the constructor:&#13;
        <pre class="programlisting code"><code class="hljs-code">    public OpenAIChatService(ChatClient.Builder chatClientBuilder) {&#13;
        this.chatClient = chatClientBuilder.build();&#13;
    }&#13;
    public String getSummaryText(String input)&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numberedList">We can <a id="_idIndexMarker433"/>see that the usage is different from the LangChain4j framework. Here, we need to create a prompt with a system template, pass the user message with data replacement, and invoke the <code class="inlineCode">chatResponse</code> method:&#13;
        <pre class="programlisting code"><code class="hljs-code">        ChatResponse response = chatClient&#13;
                .prompt()&#13;
                .system(SYSTEM_PROMPT_TEMPLATE)&#13;
                .user(p -&gt; p.text(userMessage).param("data", input))&#13;
                .call()&#13;
                .chatResponse() ;&#13;
        return response.getResult().getOutput().getContent() ;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">We will take a look at embedding model integration next.</p>&#13;
    <h2 id="_idParaDest-148" class="heading-2">Spring AI: OpenAI embedding model integration</h2>&#13;
    <p class="normal">Embedding model integration <a id="_idIndexMarker434"/>is pretty simple. We can use <code class="inlineCode">Autowired</code> to initialize the embedding model instance. The embedding model usage looks as shown in the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">@Service&#13;
public class OpenAIEmbeddingModelService {&#13;
    private EmbeddingModel embeddingModel ;&#13;
    @Autowired&#13;
    public OpenAIEmbeddingModelService(EmbeddingModel embeddingModel) {&#13;
        this.embeddingModel = embeddingModel;&#13;
    }&#13;
    float[] generateEmbedding(String text) {&#13;
        float[] response = embeddingModel.embed(text) ;&#13;
        return  response ;&#13;
    }&#13;
    List&lt;float[]&gt; generateEmbeddingBatch(List&lt;String&gt; textList) {&#13;
        List&lt;float[]&gt; responses = embeddingModel.embed(textList) ;&#13;
        return responses ;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">From the code, we<a id="_idIndexMarker435"/> can see it is as simple as adding <code class="inlineCode">EmbeddingModel</code> to the class and initializing it using a constructor. When the Spring Boot application starts, the appropriate embedding model implementation based on properties is instantiated and assigned to this variable. This service provides a method to generate the embedding for a given text.</p>&#13;
    <p class="normal">Now that we have looked at all the services defined, let us look at how we can use all of these to build a graph augment application.</p>&#13;
    <h2 id="_idParaDest-149" class="heading-2">Spring AI: final application</h2>&#13;
    <p class="normal">The application flow<a id="_idIndexMarker436"/> is pretty much the same as the LangChain4j application we discussed in the <em class="italic">LangChain4j – final application</em> section. The code is similar, so we will not be adding that code here. The only difference would be the Java package names. For posterity, let us take a look at the application flow.</p>&#13;
    <p class="normal">The REST endpoint is built to issue the request to perform the augmentation. Since the process itself can take time, this process is split into two parts:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Issue a request to start the augmentation process. This returns a request ID.</li>&#13;
      <li class="numberedList">Use the request ID returned in step 1 to check the progress of the request.</li>&#13;
    </ol>&#13;
    <p class="normal">The first step starts a thread and initiates processing the whole data. The request process follows these steps:</p>&#13;
    <ol>&#13;
      <li class="numberedList" value="1">Retrieve the relationship ID for the start season as the context, and the description of the articles in the order in which they were purchased. We return a list of records as a response.</li>&#13;
      <li class="numberedList">For each record we retrieved from Neo4j, we perform the following steps:<ol>&#13;
          <li class="numberedList" value="1">Execute the chat request to generate the summary.</li>&#13;
          <li class="numberedList">For the summary returned from the chat request, generate an embedding using an LLM embedding API.</li>&#13;
          <li class="numberedList">Save the relationship ID, summary, and embedding to a map to build a batch.</li>&#13;
          <li class="numberedList">Once the batch size reaches the size specified in the configuration, write the summary and embedding to the relationship identified by the relationship ID.</li>&#13;
        </ol>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">With this <a id="_idIndexMarker437"/>approach, we can augment the graph to perform the next steps to understand customer purchase behavior to be able to provide customers with better recommendations.</p>&#13;
    <p class="normal">You can download the latest project from <a href="https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment">https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment</a> instead of building it from scratch if you would like to play with it.</p>&#13;
    <p class="normal">To run the project, you can right-click on the <code class="inlineCode">SpringaiGraphAugmentApplication.java</code> file and select the <strong class="screenText">Run</strong> menu option.</p>&#13;
    <p>&#13;
      <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">If you are interested in customizing the run options and other aspects, then you can use the <strong class="screenText">Run</strong>/<strong class="screenText">Debug</strong> configurations provided by the IDE. To learn more about these aspects, please visit <a href="https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html">https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html</a>.</p>&#13;
    </p>&#13;
    <p class="normal">Let’s now see how we can use this application we built to augment the graph and take a look at how we can provide recommendations from this.</p>&#13;
    <h1 id="_idParaDest-150" class="heading-1">Fine-tuning your recommendation system</h1>&#13;
    <p class="normal">Now that<a id="_idIndexMarker438"/> the project is ready, we can either run the application in the IDE or build a runnable JAR file. Here, we will run it from the IDE directly. We will be using a LangChain4j application for testing here. A Spring AI application would follow the same principles. We will be starting from the database we created in the previous chapter. If you do not want to start from scratch, you can download the database dump from <a href="https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip">https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip</a> and create a database from it.</p>&#13;
    <p class="normal">You can double-click on the <code class="inlineCode">LangchainGraphaugmentApplication</code>.<code class="inlineCode">j</code><code class="inlineCode">ava</code> file to load it into the IDE. Once it is loaded, you can right-click on the class name to run the application. <em class="italic">Figure 9.6</em> shows how we can do this.</p>&#13;
    <figure class="mediaobject"><img src="img/B31107_09_06.png" alt="Figure 9.6 — Run the application from the IDE" width="885" height="707"/></figure>&#13;
    <p class="packt_figref">Figure 9.6 — Run the application from the IDE</p>&#13;
    <p class="normal">Once you’ve <a id="_idIndexMarker439"/>right-clicked on the class name, click on the <strong class="screenText">Run</strong> menu item to start the application. Once the application is ready, you should see this in the IDE console:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">2024-12-12T14:52:30.075+05:30  INFO 5296 --- [langchain_graphaugment] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1271 ms&#13;
2024-12-12T14:52:31.347+05:30  INFO 5296 --- [langchain_graphaugment] [           main] o.neo4j.driver.internal.DriverFactory    : Direct driver instance 1567253519 created for server address localhost:7687&#13;
2024-12-12T14:52:31.388+05:30  INFO 5296 --- [langchain_graphaugment] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'&#13;
2024-12-12T14:52:31.398+05:30  INFO 5296 --- [langchain_graphaugment] [           main] g.h.l.g.LangchainGraphaugmentApplication : Started LangchainGraphaugmentApplication in 3.146 seconds (process running for 3.746)&#13;
</code></pre>&#13;
    <p class="normal">Once the application is up and running, we can open a browser and enter the URL <code class="inlineCode">http://localhost:8080/augment/SUMMER_2019/FALL_2019</code> to start the augmentation process for the <code class="inlineCode">SUMMER_2019</code> purchases of customers. When we issue this request, we get a UUID such as <code class="inlineCode">aff867bd-08fb-42fb-8a27-3917e0ce83d1</code> as a response. While the process is running, we can inquire about the current completion percentage by entering the URL <code class="inlineCode">http://localhost:8080/augment/status/aff867bd-08fb-42fb-8a27-3917e0ce83d1</code> in the browser.</p>&#13;
    <p>&#13;
      <p class="normal"><strong class="keyWord">Note</strong></p>&#13;
      <p class="normal">Note that the <code class="inlineCode">UUID</code> value of  <code class="inlineCode">aff867bd-08fb-42fb-8a27-3917e0ce83d1</code> mentioned previously is a dynamic one. It is not guaranteed that you will get the same UUID as shown in the preceding text. This <code class="inlineCode">UUID</code> is specific to the run in this example. You would need to take a look at the <code class="inlineCode">UUID</code> returned by the request for your run and use it to check the status.</p>&#13;
    </p>&#13;
    <p class="normal">Generating a <a id="_idIndexMarker440"/>summary and embedding will take time. Once this process is complete, we should create embeddings on articles next. The process is similar to the previous step. We need to enter the URL <code class="inlineCode">http://localhost:8080/augmentArticles</code> in the browser. It will also provide us with a <code class="inlineCode">UUID</code> as a response. We need to keep checking the completion percentage until it is complete.</p>&#13;
    <p class="normal">If you do not want to wait for this whole process to complete, you can download the database from <a href="https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip">https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip</a>.</p>&#13;
    <p class="normal">Now, that we have <a id="_idIndexMarker441"/>performed the augmentation, let us take a look at how good these embeddings are and how they can help us provide recommendations. For this purpose, we can further enhance the graph by creating vector indexes for the embeddings we created.</p>&#13;
    <p class="normal">You can execute this Cypher query to create a vector index for embeddings on articles:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CREATE VECTOR INDEX `article-embeddings` IF NOT EXISTS&#13;
FOR (a:Article)&#13;
ON a.embedding&#13;
OPTIONS { indexConfig: {&#13;
 `vector.dimensions`: 3072,&#13;
 `vector.similarity_function`: 'cosine'&#13;
}}&#13;
</code></pre>&#13;
    <p class="normal">This creates a vector index on <code class="inlineCode">Article</code> nodes named <code class="inlineCode">article-embeddings</code>.</p>&#13;
    <p class="normal">The following Cypher code can be used to create a vector index on the summer 2019 purchases embedding:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CREATE VECTOR INDEX `summer-2019-embeddings` IF NOT EXISTS&#13;
FOR ()-[r:SUMMER_2019]-&gt;() ON (r.embedding)&#13;
OPTIONS { indexConfig: {&#13;
 `vector.dimensions`: 3072,&#13;
 `vector.similarity_function`: 'cosine'&#13;
}}&#13;
</code></pre>&#13;
    <p class="normal">This creates a vector index on the <code class="inlineCode">SUMMER_2019</code> relationship named <code class="inlineCode">summer-2019-embeddings</code>.</p>&#13;
    <p class="normal">Let us take a look at using the <code class="inlineCode">Article</code> vector index first. This Cypher tries to find the top five matches for an article with an ID of <code class="inlineCode">0748579001</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (a:Article {id:'0748579001'})&#13;
WITH a&#13;
CALL db.index.vector.queryNodes('article-embeddings', 5, a.embedding)&#13;
YIELD node, score&#13;
RETURN score, node.id as id, node.desc as desc&#13;
</code></pre>&#13;
    <p class="normal">From the results (<em class="italic">Figure 9.7</em>), we<a id="_idIndexMarker442"/> can see that the first match is the best match and it is the <code class="inlineCode">Article</code> node we looked for:</p>&#13;
    <table id="table001" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Score</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Id</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Desc</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">1.0</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0748579001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Ankle-length, A-line beach dress in an airy, patterned weave with a deep V-neck with gold-coloured studs, and long dolman sleeves with elastication and a decorative drawstring at the cuffs. Unlined.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.882</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0748033001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Long beach dress in airy, crinkled chiffon with narrow, tie-top shoulder straps and an opening at the back of the neck. Unlined.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.873</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0748582008”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Short beach dress in an airy cotton weave with broderie anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled straps at the back of the neck, dropped shoulders and short sleeves. Seam at the waist and a gently flared skirt. Unlined.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.866</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0748025004”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Kaftan in an airy weave with buttons down the front and high slits in the sides.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.866</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0747737004”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Sarong in an airy weave. Size 130x150 cm.”</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="packt_figref">Figure 9.7 — Similar articles for a given article</p>&#13;
    <p class="normal">Also, we can see that the articles that are less similar to each other have lower score values. From this result, let us take <code class="inlineCode">Article</code> with an ID of <code class="inlineCode">0748582008</code> and see what we can find:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (a:Article {id:'0748582008'})&#13;
WITH a&#13;
CALL db.index.vector.queryNodes('article-embeddings', 5, a.embedding)&#13;
YIELD node, score&#13;
RETURN score, node.id as id, node.desc as desc&#13;
</code></pre>&#13;
    <p class="normal">When we run the Cypher, we <a id="_idIndexMarker443"/>can see these results:</p>&#13;
    <table id="table002" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Score</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Id</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Desc</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">1.0</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0748582008”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Short beach dress in an airy cotton weave with broderie anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled straps at the back of the neck, dropped shoulders and short sleeves. Seam at the waist and a gently flared skirt. Unlined.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.969</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0748582001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Short beach dress in an airy cotton weave with broderie anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled straps at the back of the neck, dropped shoulders and short sleeves. Seam at the waist and a gently flared skirt. Unlined.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.893</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0848082001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Short beach kaftan in an airy weave with lace trims. Short, wide sleeves, and a drawstring at the waist.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.884</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0854784001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Short beach dress in an airy cotton weave containing glittery threads. Round neckline with a V-neck opening and narrow ties at the front, dropped shoulders and long balloon sleeves with narrow, buttoned cuffs. Gathered tiers at the hem for added width.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.884</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0850893001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Calf-length lace kaftan with a crocheted trim around the opening, a drawstring and twisted ties at the waist, and long sleeves. Scalloped trim around the cuffs and hem.”</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="packt_figref">Figure 9.8 — Similar articles for a given article</p>&#13;
    <p class="normal">From the results, we can see that when the score is closer to <code class="inlineCode">0.9</code>, the articles are pretty similar. We can use this information to provide similar articles as recommendations, based on the articles customers have already purchased.</p>&#13;
    <p class="normal">Now, let us look at the<a id="_idIndexMarker444"/> customer summer purchase behaviors for a customer whose ID ends in <code class="inlineCode">92f0</code>. Let’s call this customer, A:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (c:Customer)-[r:SUMMER_2019]-&gt;() WHERE c.id='0002b7a7ab270a638fcb2eb5899c58696db24d9d954ddb43683dd6b0ffa292f0'&#13;
WITH r&#13;
CALL db.index.vector.queryRelationships('summer-2019-embeddings', 5, r.embedding)&#13;
YIELD relationship, score&#13;
MATCH (oc)-[relationship]-&gt;()&#13;
WITH oc, score, relationship&#13;
WITH oc, score, split(relationship.summary, '\n') as s&#13;
WITH oc, score, CASE when s[2] &lt;&gt; '' THEN s[2] ELSE s[3] end as desc&#13;
WITH score, oc.id as id, desc&#13;
RETURN round(score,3) as score, substring(id,0,4)+".."+substring(id,size(id)-4) as id, desc&#13;
</code></pre>&#13;
    <p class="normal">When we run this Cypher, we can see these results:</p>&#13;
    <table id="table003" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Score</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Id</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Desc</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">1.0</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0002..92f0”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer exhibits a strong preference for vibrant colors and comfortable, casual styles, particularly in swimwear and denim. Their purchases suggest a love for playful yet practical clothing, suitable for both beach outings and everyday wear. The mix of swimwear, shorts, and casual tops indicates a versatile wardrobe focused on both style and comfort.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.968</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“044d..d47e”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer exhibits a strong preference for swimwear, particularly in vibrant colors like light orange and dark red, indicating a fun and playful style. Their choices also reflect an inclination towards high-waisted designs and supportive tops, suggesting a desire for both comfort and fashion. Additionally, the purchase of a versatile playsuit and tailored jacket indicates an appreciation for stylish yet practical everyday wear.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.967</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“07fe..a87f”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer exhibits a strong preference for swimwear, particularly in vibrant colors like orange and black, indicating a love for beach and poolside activities. There is also a notable inclination towards basic wardrobe staples, such as tank tops and shorts, suggesting a desire for comfortable yet stylish casual wear. The blend of swimwear and basic clothing reflects a versatile fashion sense suitable for both leisure and everyday wear.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.966</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0247..74b3”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer demonstrates a preference for vibrant colors and versatile clothing items suitable for various occasions, including casual wear and swimwear. The repeated purchases of swimwear suggest a keen interest in beach or poolside activities. Additionally, the inclusion of dresses and accessories indicates a desire for stylish yet comfortable outfits.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.965</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0686..5220”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer displays a strong preference for vibrant colors, particularly orange and white, as seen in their selection of swimwear and casual attire. Their purchases indicate a blend of comfort and style, with a focus on versatile pieces that can be worn for various occasions. The inclusion of both swimwear and everyday clothing suggests a lifestyle that appreciates both leisure and fashion.”</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="packt_figref">Figure 9.9 — Purchase summaries for other customers similar to the given customer</p>&#13;
    <p class="normal">From the basic summary, we can <a id="_idIndexMarker445"/>see that the customer purchase behaviors are pretty similar. Let us pick another customer (say, customer B) from this list to see whether the same customers are returned when we run the same query. We will pick the customer ID ending in <code class="inlineCode">74b3</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (c:Customer)-[r:SUMMER_2019]-&gt;() WHERE c.id=' 0247b7b564909181b2e552fe3d5cec01056ebc1b3d61d38f1ff0658db69174b3'&#13;
WITH r&#13;
CALL db.index.vector.queryRelationships('summer-2019-embeddings', 5, r.embedding)&#13;
YIELD relationship, score&#13;
MATCH (oc)-[relationship]-&gt;()&#13;
WITH oc, score, relationship&#13;
WITH oc, score, split(relationship.summary, '\n') as s&#13;
WITH oc, score, CASE when s[2] &lt;&gt; '' THEN s[2] ELSE s[3] end as desc&#13;
WITH score, oc.id as id, desc&#13;
RETURN round(score,3) as score, substring(id,0,4)+".."+substring(id,size(id)-4) as id, desc&#13;
</code></pre>&#13;
    <p class="normal">Let us look at the results when we run this query:</p>&#13;
    <table id="table004" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Score</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Id</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Desc</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">1.0</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0247..74b3”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer demonstrates a preference for vibrant colors and versatile clothing items suitable for various occasions, including casual wear and swimwear. The repeated purchases of swimwear suggest a keen interest in beach or poolside activities. Additionally, the inclusion of dresses and accessories indicates a desire for stylish yet comfortable outfits.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.968</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“05de..29df”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer’s fashion preferences indicate a strong inclination towards swimwear and dresses, particularly in vibrant and playful colors such as pink, orange, and blue. The selection of both swimwear and dresses suggests a versatile style that embraces both casual beachwear and stylish everyday attire. Additionally, the repeated purchases of high-waisted bikini bottoms showcase a preference for flattering and functional swimwear options.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.967</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0322..3e92”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer exhibits a strong preference for swimwear, as evidenced by multiple purchases of bikini tops and bottoms, showcasing a desire for stylish beach attire. Additionally, the selection of dresses and blouses reflects an inclination towards fashionable yet comfortable everyday wear. The use of vibrant colors and unique design elements indicates a taste for contemporary and eye-catching pieces.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.966</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0002..92f0”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer exhibits a strong preference for vibrant colors and comfortable, casual styles, particularly in swimwear and denim. Their purchases suggest a love for playful yet practical clothing, suitable for both beach outings and everyday wear. The mix of swimwear, shorts, and casual tops indicates a versatile wardrobe focused on both style and comfort.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">0.965</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0863..c454”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“The customer displays a strong preference for swimwear, particularly in vibrant colors like dark red and orange, indicating a fondness for beachwear and summer styles. Additionally, their choices in everyday clothing, such as airy dresses and denim skirts, suggest an inclination towards comfortable yet stylish casual wear. The repetition of specific items also reflects a desire for consistency and reliability in their fashion selections.”</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="packt_figref">Figure 9.10 — Purchase summaries for other customers similar to the given customer</p>&#13;
    <p class="normal">We can see that the top five matches for customer B are very different from those of customer A, even though customer B’s purchase summary was in the top five similar customer purchases of customer A.</p>&#13;
    <p class="normal">We can use this approach <a id="_idIndexMarker446"/>to recommend articles to purchase based on customer purchase behavior. We are capturing the order of the purchases, but how the summary of these purchases is captured by an embedding defines who will be considered a similar customer. Let us see what this query would look like:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">MATCH (c:Customer)-[r:SUMMER_2019]-&gt;() WHERE c.id='0247b7b564909181b2e552fe3d5cec01056ebc1b3d61d38f1ff0658db69174b3'&#13;
WITH c, r&#13;
</code></pre>&#13;
    <p class="normal">We want to find other customers similar to this customer based on purchases. We will use the vector index to get the top five similar customers:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CALL db.index.vector.queryRelationships('summer-2019-embeddings', 5, r.embedding)&#13;
YIELD relationship, score&#13;
MATCH (oc)-[relationship]-&gt;()&#13;
WITH c, collect(oc) as others&#13;
CALL {&#13;
</code></pre>&#13;
    <p class="normal">Collect the articles purchased by the customer:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    WITH c&#13;
    MATCH (c)-[:SUMMER_2019]-&gt;(start)&#13;
    MATCH (c)-[:FALL_2019]-&gt;(end)&#13;
    WITH start, end&#13;
    MATCH p=(start)-[:NEXT*]-&gt;(end)&#13;
    WITH p&#13;
    WITH nodes(p) as txns&#13;
    UNWIND txns as tx&#13;
    MATCH (tx)-[:HAS_ARTICLE]-&gt;(a)&#13;
    RETURN collect(a) as customerPurchases&#13;
}&#13;
WITH others, customerPurchases&#13;
CALL {&#13;
</code></pre>&#13;
    <p class="normal">Collect the articles purchased by the other customers who are similar to the first customer:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    WITH others&#13;
    UNWIND others as a&#13;
    MATCH (a:Customer)-[:SUMMER_2019]-&gt;(start)&#13;
    MATCH (a)-[:FALL_2019]-&gt;(end)&#13;
    WITH start, end&#13;
    MATCH p=(start)-[:NEXT*]-&gt;(end)&#13;
    WITH nodes(p) as txns&#13;
    UNWIND txns as tx&#13;
    MATCH (tx)-[:HAS_ARTICLE]-&gt;(a)&#13;
    WITH DISTINCT a&#13;
    RETURN collect(a) as otherPurchases&#13;
}&#13;
WITH customerPurchases, otherPurchases&#13;
</code></pre>&#13;
    <p class="normal">Remove the articles purchased by the original customer from the articles purchased by similar customers:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">WITH apoc.coll.subtract(otherPurchases, customerPurchases) as others&#13;
UNWIND others as other&#13;
RETURN other.id as id, other.desc as desc&#13;
LIMIT 10&#13;
</code></pre>&#13;
    <p class="normal">This Cypher first<a id="_idIndexMarker447"/> collects the purchases made by the customer, finds other customers who have similar purchase behavior, retrieves the purchases made by those customers, and recommends 10 articles to the original customer that they haven’t previously purchased. The output of this query looks like this:</p>&#13;
    <table id="table005" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Id</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Desc</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0471714036”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Knee-length shorts in a cotton weave with a button fly, side pockets and a welt back pocket with a button.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0699923078”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“T-shirt in soft, printed cotton jersey.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0786663001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Short, off-the-shoulder dress in an airy, plumeti weave with elastication and a small frill trim at the top. Long sleeves with elastication at the cuffs, an elasticated seam at the waist and a flounce at the hem. Jersey lining.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0728473001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Triangle bikini top with laser-cut scalloped edges and lightly padded cups with removable inserts. Narrow, adjustable shoulder straps that can be fastened in different ways and an adjustable metal hook fastening at the back.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0689040001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Fully lined bikini bottoms with a mid waist, wide sides, a wide tie at one side and medium coverage at the back.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0736046001”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Metal hoop earrings in different sizes, three with charms in various designs. Diameter 1-2 cm.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0713200006”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Fully lined, waist-high bikini bottoms with wide sides and medium coverage at the back.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0674606026”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Short, A-line skirt with a high waist and buttons down the front.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0562245064”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“5-pocket jeans in washed, superstretch denim with a regular waist, zip fly and button, and skinny legs.”</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“0557247005”</p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">“Oversized top in sturdy sweatshirt fabric with dropped shoulders and ribbing around the neckline, cuffs and hem. Soft brushed inside.”</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="packt_figref">Figure 9.11 — Recommendations for a customer based on purchases made by similar customers</p>&#13;
    <p class="normal">By following the <a id="_idIndexMarker448"/>steps explained to fine-tune your graph, we can now provide recommendations based on customer purchase behavior by finding similar customers and their purchases or similar articles based on what customers bought. This approach is simple and works well. But we are determining who similar customers are, and so on. We might want to use <strong class="screenText">Graph Data Science</strong> algorithms or machine learning to group customers better so that we can provide better recommendations. We will take a look at that aspect in the next chapter.</p>&#13;
    <h1 id="_idParaDest-151" class="heading-1">Summary</h1>&#13;
    <p class="normal">In this chapter, we looked at how to build intelligent applications by leveraging LangChain4j and Spring AI. We used these applications to augment the H&amp;M transactions graph we loaded in the previous chapter, by leveraging LLM chat and embedding capabilities. Once the graph was augmented, we further enhanced the graph by leveraging vector indexes and saw how these indexes help us find similar articles or customers based on their purchases.</p>&#13;
    <p class="normal">In the next chapter, we will step into <strong class="screenText">Graph Data Science</strong> algorithms to see how we can further enhance these recommendations.</p>&#13;
  </div>&#13;
</div></div></body></html>