<html><head></head><body>
		<div id="_idContainer081">
			<h1 id="_idParaDest-107"><em class="italic"><a id="_idTextAnchor116"/>Chapter <a id="_idTextAnchor117"/>6</em>: <a id="_idTextAnchor118"/>Powering Your API with a No Code Database</h1>
			<p>In this chapter, you will learn to work with no code databases for data storage. You will learn about no code databases, selecting a database for your project, and reading and writing to <strong class="bold">Airtable</strong>. You will also learn about some of the best practices when working with these databases. The concepts learned in this chapter will help you to use a data store for your projects to store user-generated data and build a complete product.</p>
			<p>This chapter will cover the following main topics:</p>
			<ul>
				<li>Learning about no code databases</li>
				<li>Selecting a database for your project</li>
				<li>Using <strong class="bold">Airtable</strong> for reading and writing data</li>
				<li>Best practices for working with databases</li>
				<li>Optimizing your <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) for production</li>
			</ul>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor119"/>Technical requirements</h1>
			<p>Here is a list of technical requirements that you'll need to prepare before continuing with the chapter:</p>
			<ul>
				<li>You have created an account on <strong class="bold">Airtable</strong></li>
				<li>n8n is running and the Editor <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) is open</li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor120"/>Learning about no code databases</h1>
			<p>Databases often form the backbone of products. Databases are generally systems that store large amounts of data. The user can add, delete, or modify data while also viewing and performing calculations on that data.</p>
			<p>Databases come in many different forms, such as <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) databases, NoSQL databases, and time series databases. Depending<a id="_idIndexMarker308"/> on the use cases, it often makes sense to choose one over the other. A lot of these databases<a id="_idIndexMarker309"/> use query languages to be able to interact with the database to conduct basic queries such as inserting, reading, updating, and deleting data. You can see some database examples in the following screenshot:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_6.01_B17493.jpg" alt="Figure 6.1 – Historical trend chart from db-engines.com&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Historical trend chart from db-engines.com</p>
			<p>Since we are focusing on building a product with no code tools and we don't have the time to learn these query languages quickly, we'll have to look for some alternatives. Luckily, there are already a number of great alternatives that we can choose from. Two of the most popular ones are <strong class="bold">Airtable</strong> and <strong class="bold">Google Sheets</strong>. These tools are easier to use as compared to traditional databases as they employ a familiar spreadsheet-like design that is easier to comprehend than database models. Since these tools are rather robust as well, more and more people have started using them in their projects.</p>
			<p>Both <strong class="bold">Airtable</strong> and <strong class="bold">Google Sheets</strong> have an n8n node, and we<a id="_idIndexMarker310"/> can use these nodes to perform <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) actions to power<a id="_idIndexMarker311"/> our API and application. Now that we have an idea about what no code databases are, let's think about how we can choose one that we can use during the duration of this book.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor121"/>Selecting a database for your project</h1>
			<p>Apart from <strong class="bold">Google Sheets</strong> and <strong class="bold">Airtable</strong>, there are a number of really cool no code databases such as <strong class="bold">Baserow</strong>, <strong class="bold">Supabase</strong>, <strong class="bold">SeaTable</strong>, and <strong class="bold">NocoDB</strong>. How do we select the right database<a id="_idIndexMarker312"/> for our product? There are a couple of questions that you can ask yourself that might help in making this decision easier:</p>
			<ul>
				<li>What do I want the database to do for my project?</li>
				<li>Does this tool have an n8n node or at least an API?</li>
				<li>How active is the community and support ecosystem for this tool?</li>
				<li>What's the level of maturity of the product? Is it stable? Has it been in the market long enough to be battle-tested by users?</li>
				<li>Are educational resources about the tool widely available? What's the learning curve like?</li>
			</ul>
			<p>While choosing the no code database to include in this book, we asked ourselves the same questions. We decided<a id="_idIndexMarker313"/> to go with <strong class="bold">Airtable</strong> because of the following reasons:</p>
			<ul>
				<li><strong class="bold">Airtable</strong> has a large community and an incredible support system.</li>
				<li><strong class="bold">Airtable</strong> has a decent API with an easy authentication system. n8n has a well-documented <strong class="bold">Airtable</strong> node too!</li>
				<li><strong class="bold">Airtable</strong> has been around for a bit, and a lot of makers use it to build their projects.</li>
				<li><strong class="bold">Airtable</strong> puts out a lot of educational <a id="_idIndexMarker314"/>content regularly and it's straightforward to get started with. </li>
			</ul>
			<p>The following screenshot provides an overview of the <strong class="bold">Airtable</strong> database:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_6.02_B17493.jpg" alt="Figure 6.2 – Airtable has a lot of educational resources and a strong community&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Airtable has a lot of educational resources and a strong community</p>
			<p>While you are asking yourselves these questions, it is quite possible that your answers might be different depending on the project that you are planning to work on. That's okay! Each tool<a id="_idIndexMarker315"/> has its own niche and superpowers that might make it more suitable for a certain type of project.</p>
			<p>Now that we've made sure that <strong class="bold">Airtable</strong> is the correct choice for us right now, let's take a look at how we can use it from n8n workflows.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor122"/>Using Airtable for reading and writing data</h1>
			<p>Let's start off by creating a new<a id="_idIndexMarker316"/> base from scratch in <strong class="bold">Airtable</strong>. I am going<a id="_idIndexMarker317"/> to name it <strong class="source-inline">The n8n book</strong>. Edit all the existing fields so that we have the following four fields with the single-line text field type:</p>
			<ul>
				<li><strong class="bold">UserID</strong></li>
				<li><strong class="bold">First Name</strong></li>
				<li><strong class="bold">Last Name</strong></li>
				<li><strong class="bold">Email</strong></li>
			</ul>
			<p>This is very similar to the table into which data was being inserted in the previous chapter. For the sake of brevity, we have taken out the <strong class="bold">Password Hash</strong> field. Your table should now look like this:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_6.03_B17493.jpg" alt="Figure 6.3 – This is what your Airtable table should look like&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – This is what your Airtable table should look like</p>
			<p>Now that we have prepared<a id="_idIndexMarker318"/> our table, let's pop over to n8n's Editor UI<a id="_idIndexMarker319"/> and follow these next steps:</p>
			<p>Create a new workflow and add a <strong class="bold">Set</strong> node to it. We'll need the <strong class="bold">Set</strong> node to make sure that we send well-formatted data to the <strong class="bold">Airtable</strong> node.</p>
			<p>Open the <strong class="bold">Set</strong> node and add four values of the <strong class="source-inline">String type</strong>. For each of these four values, do the following. In the <strong class="bold">Name</strong> field, enter the same as the name of the columns in the <strong class="bold">Airtable</strong> table. Toggle the <strong class="bold">Keep Only Set</strong> button to <strong class="source-inline">true</strong> (green). In the <strong class="bold">Value</strong> field, enter anything you like. </p>
			<p>Click on the <strong class="bold">Execute Node</strong> button, and your <strong class="bold">Set</strong> node should look like this: </p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_6.04_B17493.jpg" alt="Figure 6.4 – Output from the Set node after following the aforementioned steps &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Output from the Set node after following the aforementioned steps </p>
			<p>Now that we have structured<a id="_idIndexMarker320"/> the data in a way that would correspond to the<a id="_idIndexMarker321"/> columns in <strong class="bold">Airtable</strong>, let's add the <strong class="bold">Airtable</strong> node and connect it with the <strong class="bold">Set</strong> node. Here's what your Editor UI should look like at this point:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_6.05_B17493.jpg" alt="Figure 6.5 – The workflow should look like this at this point&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – The workflow should look like this at this point</p>
			<p>Open the <strong class="bold">Airtable</strong> node and enter your credentials. You can<a id="_idIndexMarker322"/> find the API key by following the steps mentioned on this page: <a href="https://docs.n8n.io/credentials/airtable/">https://docs.n8n.io/credentials/airtable/</a>.</p>
			<p>Change the <strong class="bold">Operation</strong> field to <strong class="source-inline">Append</strong>, since<a id="_idIndexMarker323"/> we want to insert the data<a id="_idIndexMarker324"/> from the <strong class="bold">Set</strong> node to our <strong class="bold">Airtable</strong> table. We now<a id="_idIndexMarker325"/> need to acquire the <strong class="bold">Base ID</strong> value. Head over to the API page in <strong class="bold">Airtable</strong> (<a href="https://airtable.com/api">https://airtable.com/api</a>) and select the base that you created. You'll find the <strong class="bold">Base ID</strong> value there. Paste it in the <strong class="bold">Base ID</strong> field in n8n. Enter <strong class="source-inline">Table 1</strong> in the <strong class="bold">Table</strong> field and click on the <strong class="bold">Execute Node</strong> button. It should now look like this:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_6.06_B17493.jpg" alt="Figure 6.6 – Output from the Airtable node after following the aforementioned steps &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Output from the Airtable node after following the aforementioned steps </p>
			<p>If you go back to your <strong class="bold">Airtable</strong> base, you'll notice that the record has been added to the table<a id="_idIndexMarker326"/> by this n8n workflow. Congratulations—you've just added<a id="_idIndexMarker327"/> your first record to <strong class="bold">Airtable</strong> using n8n! Here's a screenshot that showcases how your <strong class="bold">Airtable</strong> table should look at this point and how it relates to the data that we structured in the <strong class="bold">Set</strong> node:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_6.07_B17493.jpg" alt="Figure 6.7 – Record inserted into the Airtable table and how it related to the data from the Set node&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Record inserted into the Airtable table and how it related to the data from the Set node</p>
			<p>You can replace the <strong class="bold">Start</strong> node with other nodes to source the data that you want to add to <strong class="bold">Airtable</strong> and make the appropriate changes to the <strong class="bold">Set</strong> node. You might remember from the last chapter that we got the data from the API that we created using the <strong class="bold">Webhook</strong> node.</p>
			<p>This combination of the <strong class="bold">Set</strong> node (to structure the data in a form expected by the database) and the <strong class="bold">Airtable</strong> node (to insert the data into <strong class="bold">Airtable</strong>) will remain the same across workflows. In case you want<a id="_idIndexMarker328"/> to use another database for some other<a id="_idIndexMarker329"/> project, you'd replace the <strong class="bold">Airtable</strong> node with that node.</p>
			<p>Here are some key things to keep in mind about inserting data into databases:</p>
			<ul>
				<li>Spreadsheets and databases have columns, such as <strong class="bold">First Name</strong> and <strong class="bold">Last Name</strong>. The data you send to a database node needs to match these column names for each row of data that you want to insert.</li>
				<li>A lot of times, you might not get data from APIs in a form that works best for you. In those cases, the <strong class="bold">Set</strong> node can help you remodel the data that you need according to your database's columns and discard the data that you don't need.</li>
				<li>Spreadsheet and database nodes in n8n perform their configured action (such as <strong class="source-inline">Append</strong>) on each item of input data. </li>
			</ul>
			<p>Reading data from an <strong class="bold">Airtable</strong> table is relatively straightforward. To do that, create a new workflow and connect the <strong class="bold">Airtable</strong> node to the <strong class="bold">Start</strong> node. Select <strong class="source-inline">List</strong> as the operation and enter the same credentials and <strong class="bold">Base ID</strong> value as the previous workflow. </p>
			<p>Click on the <strong class="bold">Execute Node</strong> button, and the output should look like this:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_6.08_B17493.jpg" alt="Figure 6.8 – Output of the List operation of the Airtable node&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Output of the List operation of the Airtable node</p>
			<p>Now that we have listing data from <strong class="bold">Airtable</strong> out of the way, let's learn how to update a record that already exists in <strong class="bold">Airtable</strong>. You might have noticed that<a id="_idIndexMarker330"/> the <strong class="source-inline">List</strong> operation of the <strong class="bold">Airtable</strong> node returns an <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) as well. Each record in <strong class="bold">Airtable</strong> has a unique ID as well as a timestamp of when it was created. The ID is especially useful for operations such as <strong class="source-inline">Update</strong> and <strong class="source-inline">Delete</strong>.</p>
			<p>Consider this scenario: You need<a id="_idIndexMarker331"/> to find a record where the first name is <strong class="source-inline">Nathan</strong> and update<a id="_idIndexMarker332"/> the last name of the person to <strong class="source-inline">Automaton</strong>.</p>
			<p>You can then build a workflow like the one shown in the following screenshot to update the particular record in the <strong class="bold">Airtable</strong> table:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_6.09_B17493.jpg" alt="Figure 6.9 – Updating a particular record in Airtable using an n8n workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Updating a particular record in Airtable using an n8n workflow</p>
			<p>The first <strong class="bold">Airtable</strong> node lists all the records that are present in the table. The <strong class="bold">IF</strong> node checks whether the first name<a id="_idIndexMarker333"/> of the record is <strong class="source-inline">Nathan</strong>. If it isn't, n8n goes<a id="_idIndexMarker334"/> to the <strong class="bold">NoOp</strong> node, and nothing happens. If the first name is found to be <strong class="source-inline">Nathan</strong>, we use a <strong class="bold">Set</strong> node to add the new value for the <strong class="bold">Last Name</strong> field. Here's what the <strong class="bold">Set</strong> node looks like after configuration and execution:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_6.10_B17493.jpg" alt="Figure 6.10 – Configuring the Last Name field for updating the record with Nathan as the first name&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Configuring the Last Name field for updating the record with Nathan as the first name</p>
			<p>And finally, we have the <strong class="bold">Airtable1</strong> node, which will update the<a id="_idIndexMarker335"/> record. We have used the ID of the record<a id="_idIndexMarker336"/> to be updated from the first <strong class="bold">Set</strong> node (we originally got it from the <strong class="bold">Airtable</strong> node) as well as specifying that only the <strong class="bold">Last Name</strong> field should be updated. You can see the <strong class="bold">Airtable1</strong> node here:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_6.11_B17493.jpg" alt="Figure 6.11 – Configuring the Airtable1 node for updating the Last Name field of the record&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – Configuring the Airtable1 node for updating the Last Name field of the record</p>
			<p>And voilà! The workflow has updated the <strong class="bold">Last Name</strong> column for the specified record in <strong class="bold">Airtable</strong>. You can use a similar workflow to delete records as well.</p>
			<p>When using this workflow as part of an API, you can get values such as the text for which to perform a lookup and which column to look in, as well as the updated record using the <strong class="bold">Webhook</strong> node. You can then use expressions to make sure that the API endpoint with this workflow<a id="_idIndexMarker337"/> can handle dynamic requests without having to create specific<a id="_idIndexMarker338"/> workflows for different columns. Now that we know how to work with no code databases using n8n, let's learn about some best practices for working with databases.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor123"/>Best practices for working with databases</h1>
			<p>There are a lot of different aspects that go into working with databases that you will generally use in an enterprise environment, but things can be a bit different with no code databases. Because of how these databases are designed, built, and hosted, we need to think a bit differently when we use them.</p>
			<p>Let's take a look at some of the best practices around working with databases and how you can use them in a way that is both effective and efficient.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor124"/>Minimizing bandwidth</h2>
			<p>While it is not always the case, no code databases are generally hosted somewhere on the internet. This means<a id="_idIndexMarker339"/> that you do not have as much bandwidth available between you and the database that you would use if the database were hosted on the same network, which is the case for traditional databases.</p>
			<p>Because this bandwidth is now at a premium (and, depending upon how your database is hosted/priced, you may literally be paying for every byte that you send and/or receive from the database), it is very important that you make sure you use it wisely.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor125"/>Compressing data</h2>
			<p>Often, the data that is stored in databases is text-based. Text data has a very high compression ratio, which reduces how much information needs to be sent or received between you and your database.</p>
			<p>If you have the ability<a id="_idIndexMarker340"/> to compress data between the two systems, this will increase the speed of your transactions and reduce your bandwidth.</p>
			<p>However, keep in mind that this will also increase the <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) utilization on both n8n and your database as the compression needs to be calculated on both sides.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor126"/>Minimizing API calls</h2>
			<p>API calls to your database, such<a id="_idIndexMarker341"/> as bandwidth, can be expensive (literally, if you are paying per API request). They take up resources, slow down your application (as the application needs to wait for the call to complete or time out), and increase dependencies on the database.</p>
			<p>If you do everything you can to reduce API calls, these issues can be minimized or, in some cases, avoided altogether.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor127"/>Minimizing database queries</h2>
			<p>Because databases generally work very quickly, it is easy for us as developers to become lazy when accessing a database. Why bother modifying the code to write three records to the database with a single query when it is easier to write each record on its own in three separate queries?</p>
			<p>This type of programming may<a id="_idIndexMarker342"/> work with large databases that are sitting on the same network as you, but when they can be located on the other side of the planet over a fluctuating internet connection, these queries must be optimized and minimized.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor128"/>Minimizing database writes</h2>
			<p>While it is one thing to read data from a database, it is a completely different thing to write data to a database. Write operations<a id="_idIndexMarker343"/> tend to consume significantly more resources than read operations on a database. Plus, they take longer to execute, often because data needs to move around in memory, or even sometimes on disk.</p>
			<p>Because the cost of writing to your database is relatively expensive, only write data when you absolutely have to and write as much data as possible each time you do write. This will give you the most bang for your buck for each database write.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor129"/>Enabling data caching</h2>
			<p>If we are truly serious<a id="_idIndexMarker344"/> about minimizing the amount of data we read and write between n8n and the database, a great strategy is to store a copy of select database tables locally in n8n, either<a id="_idIndexMarker345"/> in memory or in a local <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) file.</p>
			<p>Then, each time a request needs to be made to the database, you can first ask whether the database has changed since the last time the cache was updated. If it has, then n8n should pull down just the changes that were made to the database and write those to the cached data. If there were no changes, then updating the cache can be skipped and the query can be executed locally.</p>
			<p>This can be a significantly more efficient way of looking at the data in a database than querying the database each time. It not only speeds up your database lookups but also reduces the number of calls to the database in the long run as well.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor130"/>Backing up the database</h2>
			<p>Your database<a id="_idIndexMarker346"/> is the core of your application. The database must be available as much as possible and, if the database is lost, you have a way to recover it. </p>
			<p>Your best line of defense is to back up your database as often as possible. This way, you will minimize the amount of data loss and reduce the amount of time it takes to recover.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor131"/>Recording transactions</h2>
			<p>Another way to ensure that you can recover from not only data loss but also data overwrite is to record every<a id="_idIndexMarker347"/> transaction that occurs on the database to a separate transaction table. This way, if there is a gap between the time your database became unavailable and the time of the last backup, you can recreate those transactions.</p>
			<p>Also, if your database backup is completely lost, you can still recover from the data loss by executing the transactions again. This is significantly slower than recovering from backup but infinitely better than losing all of the data.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor132"/>Using record references and table views</h2>
			<p>When you are using data that needs to be entered several times, it is more efficient to create a separate record<a id="_idIndexMarker348"/> in a different database table<a id="_idIndexMarker349"/> with a unique record ID rather than repeatedly writing the same data each time.</p>
			<p>For example, if I was creating a database that needed to refer to user information such as first name, last name, and address, I could just write all this information to the database table each time it was needed. But if we were to write this information to a user table, we could then just reference the <strong class="bold">UserID</strong> value stored in the table and write that rather than the entire record.</p>
			<p>This allows you to reduce the amount of information that gets transferred and minimizes the size of the write.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor133"/>Securing your database</h2>
			<p>Because these databases are hosted on the internet and can generally be accessed from anywhere on the internet, it is extremely<a id="_idIndexMarker350"/> important that they be properly secured. Ensure that all credentials and API keys are stored securely and are not hardcoded into your applications.</p>
			<p>Also, make sure<a id="_idIndexMarker351"/> all transactions are over an encrypted (<strong class="bold">HyperText Transfer Protocol Secure</strong>, or <strong class="bold">HTTPS</strong> for short) connection and, if possible, only allow<a id="_idIndexMarker352"/> specific <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) addresses to talk with the database.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor134"/>Performing calculations on the database</h2>
			<p>Your database will most likely be a lot more powerful than the system you are using to host n8n. Because of that, if it is<a id="_idIndexMarker353"/> possible, get the database to perform calculations, especially if the goal is to provide summary statistics of the data that is already on the database.</p>
			<p>Rather than sending all of the data to n8n for processing, perform the processing on the database using query functions such as <strong class="source-inline">COUNT</strong>, <strong class="source-inline">MIN</strong>, and <strong class="source-inline">MAX</strong>. This moves the calculations (that is, CPU load) over to the database and reduces the amount of information that needs to be transmitted between the database and your application.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor135"/>Load testing the database</h2>
			<p>It is not uncommon for developers to build an application and it runs just fine in both development and testing, but once it goes into production, the database cannot handle the load due to<a id="_idIndexMarker354"/> resource constraints (for example, CPU maxed out; storage too slow; bandwidth constraints).</p>
			<p>Make sure that you have a way of load testing the database before it goes into production. This way, you will be able to ensure that the database has all of the necessary resources before<a id="_idIndexMarker355"/> it becomes a problem.</p>
			<p>Now that our database is ready to go, let's take a look at how we can design and build the API to provide the best performance to users.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor136"/>Optimizing your API for production</h1>
			<p>Your API<a id="_idIndexMarker356"/> can be one of the most important parts of your application since it is one of the primary ways that your clients read and write data. Because of this importance, it is vital that your API is ready for production right from the start.</p>
			<p>Here are some of the ways you can make sure your API is production-ready.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor137"/>Reducing database calls</h2>
			<p>Very much in line with the best practices for databases, the fewer times you need to read and write<a id="_idIndexMarker357"/> to the database, the better your application will perform. Use many of the strategies mentioned in the previous section to accomplish this.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor138"/>Caching data before the API</h2>
			<p>If you have relatively static data behind your API, one of the tricks you can use is to put a caching system<a id="_idIndexMarker358"/> in front of your API, which will allow you to give out the information requested by the users without actually touching the API itself. The caching system updates itself with information from the API on a regular basis, and if it determines that there has been no change in the data given out by that API based on the same call being made to the API, the caching system will just send back the data that it has stored locally without bothering the API.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor139"/>Minimizing API calls</h2>
			<p>Some APIs require you to have information that is in the database to make another query to the database. A good example<a id="_idIndexMarker359"/> of this is user accounts. Generally, you would use the API to query the user table to find the user that you need. Then, you would query the API again, looking for specific information for that user.</p>
			<p>What you could do instead is to keep a local copy of the user table in your application and use that to look up user IDs. Then, with that information already in hand, you can query your API only once<a id="_idIndexMarker360"/> to get the information you need.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor140"/>Requiring authentication</h2>
			<p>While there are a lot of open<a id="_idIndexMarker361"/> APIs out there on the internet, it is very important to require authentication, even if you are giving the API service away for free. This increases the level of responsibility that the user has and reduces the likelihood that the API will be abused.</p>
			<p>In the event that someone is abusing your API, authentication can make it easier to track down that individual and resolve the issue with their system or stop them from interfering with your API.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor141"/>Encrypting API data on the wire</h2>
			<p>Unless your data is encrypted on the wire (that is, when it is being transmitted between the application and the database), API keys, credentials, and sensitive data are susceptible to being<a id="_idIndexMarker362"/> eavesdropped upon.</p>
			<p>The easiest way<a id="_idIndexMarker363"/> to secure this data while in transit is to have a <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificate installed on the server that is providing the API. This encrypts the data and greatly reduces the possibility of someone listening to your API's conversations.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor142"/>Tracking API requests</h2>
			<p>It is guaranteed that if you make an API available on the internet, there will be someone out there who is looking to abuse<a id="_idIndexMarker364"/> that API. This is why it is critical to keep a log of all API transactions in the event that you need to deal with one of these abusers.</p>
			<p>Ensure you track, at a minimum, the following information:</p>
			<ul>
				<li>Timestamp</li>
				<li>API call</li>
				<li>Parameters</li>
				<li>IP address</li>
				<li>Authentication key</li>
			</ul>
			<p>This will provide you with the base information to perform some analytics on the data and determine who<a id="_idIndexMarker365"/> the abuser is and where they may be working from.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor143"/>Tying API users to IP addresses</h2>
			<p>In line with the previous item, if you can get your API to only allow a user to access it from a specific<a id="_idIndexMarker366"/> IP or IP range, this can reduce the likelihood that your API will be abused and will allow you to help your users in the event that their information has been compromised.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor144"/>Limiting the number of API calls per user per second</h2>
			<p>If you put limits<a id="_idIndexMarker367"/> on how quickly users can access the API, this will help to distribute resources more evenly to all your users, along<a id="_idIndexMarker368"/> with reducing the likelihood that a user will inadvertently perform a <strong class="bold">denial-of-service</strong> (<strong class="bold">DoS</strong>) attack on your API.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor145"/>Properly documenting the API</h2>
			<p>If you have proper API<a id="_idIndexMarker369"/> documentation available for your users and developers, it will be easier for them to use your API properly and keep your error logs clean. This will increase customer satisfaction and reduce the stress on your support team, who need to help these people.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor146"/>Summary</h1>
			<p>In this chapter, we learned about no code databases, choosing a no code database for your project, reading and writing to <strong class="bold">Airtable</strong>, as well as some best practices when it comes to working with databases and optimizing APIs for production. The concepts learned in this chapter will help you to use a data store for your projects to store user-generated data and build a complete product.</p>
			<p>In the next chapter, we examine how you can transform your data inside n8n workflows. We will do some hands-on exercises on sharing data between different n8n workflows, merge datasets from different tables, and also perform some analytics and calculations on these datasets.</p>
		</div>
	</body></html>