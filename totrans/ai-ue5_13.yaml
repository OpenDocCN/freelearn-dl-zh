- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Data-Oriented Calculations with Mass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Mass** framework is a relatively new system in Unreal Engine that allows
    developers to efficiently manage and manipulate large numbers of objects within
    a game environment together. It provides tools and functionalities to handle them
    effectively, optimize performance, and implement behaviors for AI and gameplay
    mechanics. The Mass framework is becoming an essential tool for creating game
    levels that require large numbers of NPCs while maintaining optimal performance
    levels in projects. Taking advantage of the Mass framework is essential for game
    developers to create immersive and engaging experiences while maintaining optimal
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be presenting the basics of Mass and showing you how
    to create your own Mass systems. In particular, we will be covering the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Mass framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Mass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning Blueprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in the project
    repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)'
  prefs: []
  type: TYPE_NORMAL
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 12** **-** **End** link.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Mass framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Mass framework is a data-oriented system created for managing high-performance
    computations on extensive collections of entities. As you already know, in Unreal
    Engine, the traditional approach involves using actors and components to create
    level objects. This approach offers great flexibility for combining logic within
    actors, but as the project grows larger, it often results in data inconsistencies
    that lead to performance issues. For example, consider a large online multiplayer
    game where different AI agents can perform various actions based on complex logic.
    Initially, this flexibility allows developers to easily implement features such
    as character interactions and item trading with minimal constraints. However,
    as more characters and interactions are added, inconsistencies with data updates
    across the network can arise.
  prefs: []
  type: TYPE_NORMAL
- en: Mass, on the other hand, employs a data-oriented design framework that offers
    an alternative data storage method to separate data from processing logic. This
    allows for easy management of big – or even huge – numbers of entities in the
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will often use the term **level of detail** ( **LOD** ).
    In case you are unfamiliar with this term, it is a crucial concept in game development
    that refers to the technique of managing the complexity of 3D models based on
    their distance from the camera. The primary goal of LOD is to optimize rendering
    performance while maintaining visual fidelity. When a player is close to a static
    mesh, the engine uses a high-detail version of that mesh to ensure it looks sharp
    and detailed. However, as the player moves further away, the engine can switch
    to less detailed versions of the mesh, which require fewer resources to render.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming subsections, I will give you a quick introduction to the main
    definitions and elements that make up the Mass framework.
  prefs: []
  type: TYPE_NORMAL
- en: Mass framework plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mass relies on four main plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MassEntity** : The framework core plugin that is required to make Mass work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MassGameplay** : This plugin manages situations such as interaction within
    the world, movement, object visualization, LOD, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MassAI** : This plugin manages features such as state trees, world navigation,
    and avoidance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MassCrowd** : This plugin is specialized in handling crowds and has its own
    specialized visualization and navigation systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, **MassEntity** is in beta and considered production-ready.
    On the other hand, **MassGameplay** , **MassAI** , and **MassCrowd** are still
    experimental; this means you should handle them with care as things may change
    as time goes by.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Mass elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary data structure within **MassEntity** is the **fragment** – an atomic
    unit of data used in computations – that can be represented for example by transform,
    velocity, or LOD index. Fragments can be organized into sets, with a specific
    set instance linked to an ID, forming an **entity** .
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entity resembles class instantiation in object-oriented programming.
    However, instead of rigidly defining a class and its functionalities, entities
    are constructed through fragment composition. These composition assemblies are
    modifiable at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Fragments and entities are data-only elements and do not contain any logic.
  prefs: []
  type: TYPE_NORMAL
- en: A set of entities with the same composition is called an **archetype** ; each
    archetype comprises various types of fragments arranged in a specific manner.
    For instance, an archetype might feature a fragment composition with transform
    and velocity, indicating that all entities linked to this archetype share the
    same fragment structure.
  prefs: []
  type: TYPE_NORMAL
- en: Entities within an archetype are grouped into memory **chunks** , optimizing
    the retrieval of fragments belonging to entities of the corresponding archetype
    from memory for enhanced performance.
  prefs: []
  type: TYPE_NORMAL
- en: A **ChunkFragment** is a fragment connected to a chunk rather than an entity
    and is used to store chunk-specific data that is utilized in processing. ChunkFragments
    are an integral part of an entity’s composition.
  prefs: []
  type: TYPE_NORMAL
- en: A **tag** is a simple fragment that does not contain any data; tags are included
    in an entity’s composition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Processors** are stateless classes that provide the processing logic for
    fragments; by using **EntityQueries** , they specify the types of fragments they
    require for their operations. Processors can add or remove an entity’s fragments
    or tags, effectively changing the composition.'
  prefs: []
  type: TYPE_NORMAL
- en: Fragments and processors delivering specific functionalities are named **traits**
    ; multiple instances of traits can be incorporated into an entity. Each instance
    of a trait is tasked with integrating and setting up fragments to ensure that
    the entity displays the behavior associated with that trait. Typical traits include
    state tree management, avoidance, or debug visualization.
  prefs: []
  type: TYPE_NORMAL
- en: As **MassGameplay** is probably the most important of the Mass plugins, we will
    focus on it. Let’s get into detail on its main features.
  prefs: []
  type: TYPE_NORMAL
- en: MassGameplay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, one of the plugins that compose the Mass framework is the **MassGameplay**
    plugin, which is derived directly from the **MassEntity** plugin. The **MassGameplay**
    plugin includes a list of powerful subsystems that are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mass Representation** : This subsystem is responsible for managing different
    visual aspects of entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass Spawner** : This subsystem manages the entities’ spawning process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass LOD** : This subsystem manages the LOD of each mass entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass State Tree** : This subsystem will let you integrate state trees inside
    **MassEntity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass Signals** : This subsystem manages messages to entities in a similar
    way to event dispatching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass Movement** : This subsystem manages movement for Mass agents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass SmartObject** : This system is responsible for integrating smart objects
    – a feature I will be presenting in the next chapter – inside **MassEntity** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass Replication** : This subsystem is responsible for replicating Entities
    over the network in multiplayer games; at the time of writing this book, it is
    still in the experimental stages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the availability of all these subsystems, Mass has become an incredibly
    powerful tool for efficiently managing a vast number of entities.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced the Mass framework and its main elements. In
    the next section, we will be creating our first level using Mass, leveraging some
    of its main features.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The story goes on…
  prefs: []
  type: TYPE_NORMAL
- en: '*As Dr. Markus and Professor Victoria delved deeper into their groundbreaking
    research on AI, they found themselves faced with a new challenge; the laboratory
    was now filled with a large number of AI dummy puppets, each designed to mimic
    human behavior and responses. However, managing and synchronizing these puppets
    proved to be a* *daunting task.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In order to overcome this obstacle, Dr. Markus and Professor Victoria started
    by developing a sophisticated set of algorithms that would act as the core system
    for managing the puppets. This system would allow them to sync and coordinate
    the movements and actions of the AI puppets, making them work* *seamlessly together.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will show which plugins are needed to use Mass and how to
    enable them. Also, we will be working on a new level to get a first peek at the
    spawning system.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make Mass fully functional, you will need to enable the following
    plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MassEntity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MassGameplay**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MassAI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MassCrowd**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ZoneGraph**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StateTree**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ZoneGraph** and **StateTree** are not part of the Mass framework but need
    to be included because of some dependencies in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: You are already familiar with the **Plugin** window, so open it up and enable
    the aforementioned plugins. You will get a warning about the experimental features
    you will be using and then you will be prompted to reload the Unreal Engine Editor
    in order to register the plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Once this process is finished, you will be ready to get on with Mass.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MassEntityConfigAsset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Mass, configuring entities is achieved through an Unreal Engine **data asset**
    .
  prefs: []
  type: TYPE_NORMAL
- en: In case you are unfamiliar with a data asset, it is a type of asset that stores
    data in a structured format. It is typically used to store various types of data,
    such as configuration settings, game parameters, localization text, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In Mass, you will be using a **MassEntityConfigAsset** data type, which will
    store trait information and fragments. As a starting point, we will be creating
    a config asset that will just let us debug information on where an object has
    been spawned in the level. This will let us visualize the current state of the
    system we are developing and analyze it at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, in **Content Drawer** , create a new folder named **DataAssets**
    and open it up. Then, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on **Content Drawer** and select **Miscellaneous** | **Data Asset**
    ; name the newly created asset **ME_DebugVisualizationConfig** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Config** section, you should see a **Traits** array; hit the **+**
    button to create a new item in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the array item dropdown menu, select **Debug Visualization** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the array item by clicking on the arrow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Debug Shape** attribute too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Mesh** attribute, search for **Dummy_Base** and select it, as shown
    in *Figure 13* *.1* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1 – ME_DebugVisualizationConfig](img/Figure_13.1_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – ME_DebugVisualizationConfig
  prefs: []
  type: TYPE_NORMAL
- en: What we have done here is quite simple. We created a **MassEntity** configuration
    file with a single trait responsible for displaying a debug mesh at the location
    where an object has been spawned in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you need to check that everything is fine, you can click the **Validate Entity
    Config** button that is located inside the **Data Asset** window. You should get
    a message stating that there are no errors in this asset.
  prefs: []
  type: TYPE_NORMAL
- en: We will now proceed with the object spawn implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a spawn EQS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To take advantage of the Mass Spawner subsystem, we will need an EQS that will
    return a set of locations that will tell the subsystem where to spawn objects.
    If you need a refresher about EQS, my advice is to check [*Chapter 11*](B31016_11.xhtml#_idTextAnchor218)
    , *Understanding the Environment Query System* , and then get back to this chapter
    when you are ready. We will be now creating an environment query that will just
    generate some points on a grid. In order to do so, open the **AI** folder and
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and select **Artificial Intelligence** | **Environment Query** .
    Name the newly created asset **EQS_SpawnEntitiesOnGrid** . Double-click on the
    asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **ROOT** node, click and drag to create a **Points: Grid** node from
    the **Generators** category.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the node and, in the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **GridHalfSize** attribute to **1500.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Projection Data** section, set the **Trace Mode** attribute to **Geometry**
    **by Channel**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Environment query](img/Figure_13.2_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Environment query
  prefs: []
  type: TYPE_NORMAL
- en: The environment query we have just implemented will create a grid sized 3,000
    by 3,000 – as we have set the **GridHalfSize** property with a value of **1500.0**
    units – and will use a **Geometry by Channel** trace method to set the location
    of each item.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with what traces are and how Unreal Engine uses them,
    my advice is to take a peek at the official documentation by visiting this page
    from the official documentation at [https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview](https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to use the Mass Spawner subsystem inside a level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the spawning feature, we are going to create a simple gym. To get started,
    create a level of your choice, starting from the Level Instances and Packed Level
    Actors I provided in the project template. If you wish, add some obstacles; my
    level is shown in *Figure 13* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Gym](img/Figure_13.3_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Gym
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On the **Editor** toolbar, click on the **Quickly add to the project** button
    and search for **Mass Spawner** . Select it to add an instance of it in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the **MassSpawner** object at the center of your level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you have placed the **MassSpawner** object in the level, select it.
    In the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Count** property to **20**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the **+** button on the **Entity Types** attribute to add an item to the
    array
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand the item marked as **Index[0]** and set the **Entity Config** property
    to **ME_DebugVisualizationConfig**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Entry types](img/Figure_13.4_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Entry types
  prefs: []
  type: TYPE_NORMAL
- en: 'We just set the **MassSpawner** property so that it spawns 20 entities that
    will use the data asset we previously created as the configuration asset. We now
    need to tell the **MassSpawner** property where to spawn them. To do this, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Details** panel, add an element to the **Spawn Data Generator** array
    and expand the **Index[0]** element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Generator Instance** property to **EQS** **SpawnPoints Generator**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand **Generator Instance** and its **Query** child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Query Template** to **EQS_SpawnEntitiesOnGrid** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Spawn point generator](img/Figure_13.5_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Spawn point generator
  prefs: []
  type: TYPE_NORMAL
- en: In the previous steps, we have set the generator logic to the entity query we
    had previously created. It’s now time to test the gym.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the gym, all you need to do is to simulate – or play – the level; you
    will see 20 debug models spawned on a grid, as shown in *Figure 13* *.6* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Gym](img/Figure_13.6_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Gym
  prefs: []
  type: TYPE_NORMAL
- en: Please note that models will be correctly placed on objects; this is happening
    because we used the **Geometry by Channel** trace mode inside our environment
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'By enabling the debugging tools, you will have some insightful information
    about what’s happening inside the level along with a plethora of options, as depicted
    in *Figure 13* *.7* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Debugging tools](img/Figure_13.7_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Debugging tools
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly encourage you to explore the various debugging tool options, as they
    can greatly enhance your efficiency in identifying and resolving your game issues.
    As an example, *Figure 13* *.8* shows the archetype information that was enabled
    by using the *Shift* + *A* key combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Archetype information](img/Figure_13.8_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Archetype information
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we got a glimpse of what’s possible to create with Mass; in
    particular, we saw how to create a spawn area through the **MassSpawner** subsystem.
    In the next section, we will go into more detail by spawning a set of Blueprints
    instead of some debugging models.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be taking a step further with the **MassSpawner** subsystem
    as we will be generating a set of Blueprint instances instead of simply showing
    debug meshes; this will let us transition from a simple debugging gym to a real
    case environment. Additionally, we will learn how to handle the LOD for spawned
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that we want to create a concert where the audience is automatically
    generated, and it is managed as a whole by Mass. We will be creating such a scenario
    using the Mass framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the audience Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a first step, we will be creating a Blueprint that will serve us as the
    audience for an imaginary concert; entities will be cheering, sitting, or simply
    staying still. Additionally, we will be using the Mass LOD management system.
    Instead of creating just one Blueprint, we will be creating two: one that will
    be activated by the management system when near the camera and the other that
    will be activated when far away. This will let us manage and show more complex
    entities only when near the camera and fall back to less complex entities when
    far away. For the sake of demonstration, we will be using a Blueprint that will
    just stay still and won’t be animated – the one that will be visualized when far
    away – and one that will show random animations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the first Blueprint by doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint class inheriting from **BaseDummyCharacter** and call
    it **BP_AudienceLow** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Blueprint, and in the **Animation Mode** property, select **Use** **Animation
    Asset** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **Looping** and **Playing** checkboxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Initial Position** attribute to **0.4** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once visualized in the level, this character will just stand still and show
    a cheering position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second Blueprint is going to be slightly more complex. To implement it,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint class inheriting from **BaseDummyCharacter** and call
    it **BP_AudienceHigh** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new variable of the **Anim Montage Object Reference** type, call it
    **MontageList** , and make it an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two variables of the **float** type and name them **MinInterval** and
    **MaxInterval** , respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the Blueprint to expose the **Default Value** properties and set the
    **MinInterval** value to **3.0** and **MaxInterval** to **6.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three items in **MontageList** **Default Value** and set them, respectively,
    to **AM_Cheer** , **AM_Interact** , and **AM_Sit** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Event Graph, connect the **Event Begin Play** execution pin to a **Delay**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Duration** pin of the **Delay** node to a **Random Float in**
    **Range** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** section, drag a **MinInterval** getter node and connect
    it to the **Min** pin of the **Random Float in** **Range** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Variables** section, drag a **MaxInterval** getter node and connect
    it to the **Max** pin of the **Random Float in Range** node. This portion of the
    graph is depicted in *Figure 13* *.8* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![ Figure 13.9 – Delay logic](img/Figure_13.9_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Delay logic
  prefs: []
  type: TYPE_NORMAL
- en: 'This portion of the graph is nothing fancy and is just adding a random delay
    to the code logic. Let’s get on with the code by doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Delay** node to a **Play** **Montage**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Components** panel, drag a **Mesh** reference in the Event Graph
    and connect it to the **In Skeletal Mesh Component** pin of the **Play** **Montage**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **MontageList** getter in the Event Graph and connect its pin to a **Random
    Array** **Item** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **Out Item** pin of the **Random** node to the **Montage to Play**
    pin of the **Play Montage** node. This part of the graph is shown in *Figure 13*
    *.10* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Play Montage logic](img/Figure_13.10_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Play Montage logic
  prefs: []
  type: TYPE_NORMAL
- en: Here we are doing something pretty straightforward; we are getting a random
    animation montage from the array and then we play it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is to create an infinite loop that will keep on playing
    an animation montage after a delay. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **On Completed** outgoing execution pin of the **Play Montage**
    node to the incoming execution pin of the **Delay** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a couple of reroute nodes, in order to make the graph clearer. The code
    is shown in *Figure 13* *.11* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Loop](img/Figure_13.11_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Loop
  prefs: []
  type: TYPE_NORMAL
- en: Our character is now ready and, once instantiated in a level, will keep on playing
    random animations. We will now create the **MassEntityConfigAsset** for the **MassSpawner**
    that will be placed in the gym.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MassEntityConfigAsset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **MassEntityConfigAsset** we will be creating is going to be more complex
    than the previous one. In this case, we will need to spawn characters in the level,
    and we will need to handle what is instantiated depending on the distance from
    the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, open the **DataAssets** folder, create a new **Data Asset**
    of the **Mass Entity Config Asset** type, and name it **ME_AudienceConfig** .
    Then, open it and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Traits** section, add three array elements by clicking the **+** button
    three times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From each of the items’ dropdown menus, select **Mass Stationary Distance Visualization
    Trait** , **Assorted Fragments** , and **LODCollector** , respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Audience Config data asset](img/Figure_13.12_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Audience Config data asset
  prefs: []
  type: TYPE_NORMAL
- en: We will now be checking each of them to get some information on how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Mass Stationary Distance Visualization Trait
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This trait is responsible for the visualization of the entity in the world
    and will need to be properly set in order to correctly show the actor in the level.
    So, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **Trait** item to show all settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **High Res Template Actor** property to **BP_AudienceHigh** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Low Res Template Actor** property to **BP_AudienceLow** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Params** section and set the **High** and **Medium** properties
    to **High Res Spawned Actor** and the **Low** property to **Low Res** **Spawned
    Actor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Keep Actor Extra** **Frame** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Mass Stationary Distance Visualization settings](img/Figure_13.13_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Mass Stationary Distance Visualization settings
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, we defined a high- and low-resolution template from the
    previously created Blueprints. Then we used these definitions to set the LOD representation
    for the entity. Checking the **Keep Actor Extra Frame** flag will help with rendering
    when transitioning between different LODs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Assorted Fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Assorted Fragments** trait enables you to define an array of fragments
    that may be required by other traits. To achieve this, open the **Assorted Fragments**
    trait section and then the **Fragments** section and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add two fragments to the array by clicking the **+** button twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the first item of the list to **Transform Fragment** and the second one
    to **Mass** **Actor Fragment** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Assorted Fragments settings](img/Figure_13.14_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – Assorted Fragments settings
  prefs: []
  type: TYPE_NORMAL
- en: '**Transform** **Fragment** is responsible for storing the entity world transform,
    while **Mass Actor Fragment** will hold a pointer to the actor that will be used
    by the visualization trait.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring LODCollector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The entity configuration will need the **LODCollector** trait to facilitate
    the adjustment between LOD levels. The **LODCollector** processor assesses the
    appropriate LOD for each entity by considering its proximity to viewers and its
    relationship to the camera frustum.
  prefs: []
  type: TYPE_NORMAL
- en: It does not require any configuration, so you can leave it as it is.
  prefs: []
  type: TYPE_NORMAL
- en: With the data asset properly configured, we can go on with setting up our system.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the automatic processor registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before creating and testing the gym, we will need to take one more step. At
    the time of writing this book, the current version of Mass needs some properties
    to have the **Auto Register with Processing Phases** flag enabled in the Mass
    settings; this is due to Mass still being in beta status and not yet a final release.
    Not setting this flag will result in the Mass entities not being visible in the
    game. This is due to some conflicts with the **MassCrowd** plugin that will be
    addressed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this issue, from the main menu, select **Edit** | **Project Settings**
    and open the **Engine** | **Mass** section. After that, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **Module** **Settings** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Mass** **Entity** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Processor** **CDOs** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search through the array of processors for **MassLODCollectorProcessor** , **MassRepresentationProcessor**
    , and **MassVisualizationLODProcessor** . Expand the processors and check the
    **Auto Register with Processing Phases** flag for each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Auto Register with Processor Phases settings](img/Figure_13.15_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – Auto Register with Processor Phases settings
  prefs: []
  type: TYPE_NORMAL
- en: With these settings enabled, we can go on and create a testing gym.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we will be working with a lot of actors, I think it would be fun to take
    our beloved dummy puppets outside for some fresh air! That’s why, instead of using
    the usual enclosed gym, we will be setting up an open-air environment. Let’s start
    by doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new level by using the **Open** **World** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **MassSpawner** actor in the level and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Settings** panel, set the **Count** property to **50** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Entity Types** array, add a new item and expand it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Entity Config** property to **ME_AudienceConfig** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new item in the **Spawn Data Generators** array and expand it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Generator Instance** property to **EQS SpawnPoints Generator** and
    expand its **Query** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **EQSRequest** section and set the **Query Template** attribute to
    **EQS_SpawnEntitiesOnGrid** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Mass Spawner Details panel](img/Figure_13.16_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – Mass Spawner Details panel
  prefs: []
  type: TYPE_NORMAL
- en: Simulate the level and you should get... something weird!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Wrong position](img/Figure_13.17_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.17 – Wrong position
  prefs: []
  type: TYPE_NORMAL
- en: It seems all the characters are positioned halfway under the floor. This occurs
    because the **Capsule** component of a character is computed to be centered around
    the local coordinates of **(0.0, 0.0, 0.0)** . Fixing this issue is trivial and
    you’ll need to adjust a single property of the environment query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by duplicating **EQS_SpawnEntitiesOnGrid** and calling it **EQS_SpawnEntitiesOnGrid_ZOffset**
    . Then, do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the newly created asset and select the **SimpleGrid** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, expand the **Projection Data** section and set **Post
    Projection Vertical Offset** to **120.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your level, select the **MassSpawner** actor and change **Query Template**
    to **EQS_SpawnEntitiesOnGrid_ZOffset** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you test the level right now, your characters should be correctly positioned,
    as shown in *Figure 13* *.18* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Right position](img/Figure_13.18_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.18 – Right position
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you should notice that the characters near the camera will be
    animated, while the ones that are at a distance will be stuck in a cheering position,
    as shown in *Figure 13* *.19* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Non-animated characters](img/Figure_13.19_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.19 – Non-animated characters
  prefs: []
  type: TYPE_NORMAL
- en: This is happening because of the configuration setting we defined in the **Mass
    Stationary Distance Visualization** trait. I highly encourage you to open the
    **ME_AudienceConfig** asset back up and tweak the **LODDistance** values – **High**
    , **Medium** , **Low** , and **Off** – to see how your entities behave.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I showed you some more advanced traits that compose the Mass
    framework. We created a new configuration data asset whose task is to manage the
    LOD of the spawned entities. Then we created a dedicated Mass Spawner that creates
    high numbers of actors in the level leveraging an environment query.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced you to the experimental yet highly powerful
    Mass framework. Starting from the basics, we presented the plugins that make up
    the whole system. After that, we created a couple of working examples that take
    advantage of Mass: a simple debug scenario for checking Mass Spawner and a more
    complex one to get a strong grip on how traits can be combined to handle high
    numbers of entities.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this framework is particularly beneficial in scenarios that require the
    simulation of crowds, physics interactions, and dynamic entity management. So,
    if your game needs these types of features, you will highly benefit from using
    Mass.
  prefs: []
  type: TYPE_NORMAL
- en: In the next – and last – chapter, we will show you another feature that will
    provide a way to handle and manage various activities and interactions for both
    AI characters and players. Get ready for an intriguing exploration as things are
    about to get even more interesting!
  prefs: []
  type: TYPE_NORMAL
