- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Implementing Data-Oriented Calculations with Mass
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mass 实现面向数据的计算
- en: The **Mass** framework is a relatively new system in Unreal Engine that allows
    developers to efficiently manage and manipulate large numbers of objects within
    a game environment together. It provides tools and functionalities to handle them
    effectively, optimize performance, and implement behaviors for AI and gameplay
    mechanics. The Mass framework is becoming an essential tool for creating game
    levels that require large numbers of NPCs while maintaining optimal performance
    levels in projects. Taking advantage of the Mass framework is essential for game
    developers to create immersive and engaging experiences while maintaining optimal
    performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mass** 框架是 Unreal Engine 中相对较新的系统，允许开发者高效地管理和操作游戏环境中的大量对象。它提供了处理这些对象、优化性能以及实现
    AI 和游戏机制行为的工具和功能。Mass 框架正成为创建需要大量 NPC 的游戏关卡并保持项目性能水平的必备工具。利用 Mass 框架对于游戏开发者来说至关重要，他们需要在保持最佳性能的同时，创建沉浸式和引人入胜的游戏体验。'
- en: 'In this chapter, we will be presenting the basics of Mass and showing you how
    to create your own Mass systems. In particular, we will be covering the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Mass 的基础知识，并展示如何创建自己的 Mass 系统。特别是，我们将涵盖以下主题：
- en: Introducing the Mass framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Mass 框架
- en: Setting up Mass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Mass
- en: Spawning Blueprints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建蓝图
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章介绍的主题，您应该已经完成了前面的章节，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in the project
    repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您希望从本书的配套仓库开始编写代码，您可以下载项目仓库中提供的 **.zip** 项目文件：[https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 12** **-** **End** link.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载最后一章末尾的文件，请点击 **Unreal Agility Arena –** **第 12 章** **-** **末尾** 链接。
- en: Introducing the Mass framework
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Mass 框架
- en: The Mass framework is a data-oriented system created for managing high-performance
    computations on extensive collections of entities. As you already know, in Unreal
    Engine, the traditional approach involves using actors and components to create
    level objects. This approach offers great flexibility for combining logic within
    actors, but as the project grows larger, it often results in data inconsistencies
    that lead to performance issues. For example, consider a large online multiplayer
    game where different AI agents can perform various actions based on complex logic.
    Initially, this flexibility allows developers to easily implement features such
    as character interactions and item trading with minimal constraints. However,
    as more characters and interactions are added, inconsistencies with data updates
    across the network can arise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Mass 框架是一个面向数据系统的框架，旨在管理大量实体上的高性能计算。正如您已经知道的，在 Unreal Engine 中，传统的做法是使用演员和组件来创建关卡对象。这种方法在演员内部组合逻辑方面提供了极大的灵活性，但随着项目的扩大，它通常会导致数据不一致，从而引发性能问题。例如，考虑一个大型在线多人游戏，其中不同的
    AI 代理可以根据复杂的逻辑执行各种动作。最初，这种灵活性允许开发者轻松实现诸如角色交互和物品交易等功能，同时受到的最小限制。然而，随着更多角色和交互的添加，数据更新在网络中的不一致性可能会出现。
- en: Mass, on the other hand, employs a data-oriented design framework that offers
    an alternative data storage method to separate data from processing logic. This
    allows for easy management of big – or even huge – numbers of entities in the
    level.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Mass 采用面向数据的设计框架，提供了一种替代的数据存储方法，将数据与处理逻辑分离。这允许轻松管理关卡中的大量 – 或甚至巨大的 – 实体数量。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, I will often use the term **level of detail** ( **LOD** ).
    In case you are unfamiliar with this term, it is a crucial concept in game development
    that refers to the technique of managing the complexity of 3D models based on
    their distance from the camera. The primary goal of LOD is to optimize rendering
    performance while maintaining visual fidelity. When a player is close to a static
    mesh, the engine uses a high-detail version of that mesh to ensure it looks sharp
    and detailed. However, as the player moves further away, the engine can switch
    to less detailed versions of the mesh, which require fewer resources to render.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我经常会使用术语 **细节级别**（**LOD**）。如果您不熟悉这个术语，它是在游戏开发中一个关键概念，指的是根据它们与摄像机的距离来管理3D模型复杂性的技术。LOD
    的主要目标是优化渲染性能，同时保持视觉保真度。当玩家靠近静态网格时，引擎使用该网格的高细节版本以确保其看起来清晰和详细。然而，当玩家远离时，引擎可以切换到更少细节的网格版本，这些版本需要更少的资源来渲染。
- en: In the upcoming subsections, I will give you a quick introduction to the main
    definitions and elements that make up the Mass framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我将为您快速介绍构成质量框架的主要定义和元素。
- en: Mass framework plugins
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量框架插件
- en: 'Mass relies on four main plugins:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 质量框架依赖于四个主要插件：
- en: '**MassEntity** : The framework core plugin that is required to make Mass work'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassEntity**：使质量框架工作所需的核心插件'
- en: '**MassGameplay** : This plugin manages situations such as interaction within
    the world, movement, object visualization, LOD, and so on'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassGameplay**：此插件管理世界内的交互、移动、对象可视化、LOD 等情况'
- en: '**MassAI** : This plugin manages features such as state trees, world navigation,
    and avoidance'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassAI**：此插件管理状态树、世界导航和规避等功能'
- en: '**MassCrowd** : This plugin is specialized in handling crowds and has its own
    specialized visualization and navigation systems'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassCrowd**：此插件专门用于处理人群，并拥有自己的专用可视化和导航系统'
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, **MassEntity** is in beta and considered production-ready.
    On the other hand, **MassGameplay** , **MassAI** , and **MassCrowd** are still
    experimental; this means you should handle them with care as things may change
    as time goes by.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，**MassEntity** 处于测试版，被认为是生产就绪的。另一方面，**MassGameplay**、**MassAI** 和 **MassCrowd**
    仍然是实验性的；这意味着您应该小心处理它们，因为随着时间的推移，事情可能会发生变化。
- en: Understanding Mass elements
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解质量元素
- en: The primary data structure within **MassEntity** is the **fragment** – an atomic
    unit of data used in computations – that can be represented for example by transform,
    velocity, or LOD index. Fragments can be organized into sets, with a specific
    set instance linked to an ID, forming an **entity** .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**MassEntity** 中的主要数据结构是 **片段**——用于计算的数据的原子单元，例如可以表示变换、速度或LOD索引。片段可以组织成集合，其中特定的集合实例与一个ID相关联，形成一个
    **实体**。'
- en: Creating an entity resembles class instantiation in object-oriented programming.
    However, instead of rigidly defining a class and its functionalities, entities
    are constructed through fragment composition. These composition assemblies are
    modifiable at runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实体类似于面向对象编程中的类实例化。然而，实体是通过片段组合构建的，而不是严格定义一个类及其功能。这些组合组件在运行时是可修改的。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Fragments and entities are data-only elements and do not contain any logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 片段和实体是仅包含数据的元素，不包含任何逻辑。
- en: A set of entities with the same composition is called an **archetype** ; each
    archetype comprises various types of fragments arranged in a specific manner.
    For instance, an archetype might feature a fragment composition with transform
    and velocity, indicating that all entities linked to this archetype share the
    same fragment structure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同组成的实体集合称为 **架构**；每个架构都包含以特定方式排列的各种类型的片段。例如，一个架构可能具有具有变换和速度的片段组合，这表明与该架构相关联的所有实体共享相同的片段结构。
- en: Entities within an archetype are grouped into memory **chunks** , optimizing
    the retrieval of fragments belonging to entities of the corresponding archetype
    from memory for enhanced performance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 架构内的实体被分组到内存 **块** 中，优化了从内存中检索属于相应架构的实体的片段，以增强性能。
- en: A **ChunkFragment** is a fragment connected to a chunk rather than an entity
    and is used to store chunk-specific data that is utilized in processing. ChunkFragments
    are an integral part of an entity’s composition.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**ChunkFragment** 是连接到块而不是实体的片段，用于存储在处理中使用的特定于块的数据。ChunkFragments 是实体组成的一个组成部分。'
- en: A **tag** is a simple fragment that does not contain any data; tags are included
    in an entity’s composition.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签**是一个不包含任何数据的简单片段；标签包含在实体的组成中。'
- en: '**Processors** are stateless classes that provide the processing logic for
    fragments; by using **EntityQueries** , they specify the types of fragments they
    require for their operations. Processors can add or remove an entity’s fragments
    or tags, effectively changing the composition.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理器**是无状态的类，为片段提供处理逻辑；通过使用**实体查询**，它们指定它们操作所需的片段类型。处理器可以添加或删除实体的片段或标签，从而有效地改变组成。'
- en: Fragments and processors delivering specific functionalities are named **traits**
    ; multiple instances of traits can be incorporated into an entity. Each instance
    of a trait is tasked with integrating and setting up fragments to ensure that
    the entity displays the behavior associated with that trait. Typical traits include
    state tree management, avoidance, or debug visualization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供特定功能的片段和处理器被称为**特性**；可以将多个特性的实例合并到实体中。每个特性的实例负责集成和设置片段，以确保实体显示与该特性相关的行为。典型的特性包括状态树管理、规避或调试可视化。
- en: As **MassGameplay** is probably the most important of the Mass plugins, we will
    focus on it. Let’s get into detail on its main features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**MassGameplay**可能是Mass插件中最重要的一项，我们将重点关注它。让我们深入了解其主要功能。
- en: MassGameplay
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MassGameplay
- en: 'As mentioned, one of the plugins that compose the Mass framework is the **MassGameplay**
    plugin, which is derived directly from the **MassEntity** plugin. The **MassGameplay**
    plugin includes a list of powerful subsystems that are listed here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组成Mass框架的插件之一是**MassGameplay**插件，它直接源自**MassEntity**插件。**MassGameplay**插件包含一系列强大的子系统，如下所示：
- en: '**Mass Representation** : This subsystem is responsible for managing different
    visual aspects of entities'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量表示**：此子系统负责管理实体的不同视觉方面。'
- en: '**Mass Spawner** : This subsystem manages the entities’ spawning process'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量生成器**：此子系统管理实体的生成过程。'
- en: '**Mass LOD** : This subsystem manages the LOD of each mass entity'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量LOD**：此子系统管理每个质量实体的LOD。'
- en: '**Mass State Tree** : This subsystem will let you integrate state trees inside
    **MassEntity**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量状态树**：此子系统将允许您在**MassEntity**中集成状态树。'
- en: '**Mass Signals** : This subsystem manages messages to entities in a similar
    way to event dispatching'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量信号**：此子系统以类似事件分派的方式管理实体之间的消息。'
- en: '**Mass Movement** : This subsystem manages movement for Mass agents'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量移动**：此子系统管理Mass代理的移动。'
- en: '**Mass SmartObject** : This system is responsible for integrating smart objects
    – a feature I will be presenting in the next chapter – inside **MassEntity** .'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量智能对象**：此系统负责将智能对象（我将在下一章中介绍的功能）集成到**MassEntity**中。'
- en: '**Mass Replication** : This subsystem is responsible for replicating Entities
    over the network in multiplayer games; at the time of writing this book, it is
    still in the experimental stages'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量复制**：此子系统负责在多人游戏中通过网络复制实体；在撰写本书时，它仍处于实验阶段。'
- en: With the availability of all these subsystems, Mass has become an incredibly
    powerful tool for efficiently managing a vast number of entities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着所有这些子系统的可用性，Mass已成为一个极其强大的工具，可以有效地管理大量实体。
- en: In this section, we introduced the Mass framework and its main elements. In
    the next section, we will be creating our first level using Mass, leveraging some
    of its main features.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Mass框架及其主要元素。在下一节中，我们将使用Mass创建我们的第一个关卡，利用其一些主要功能。
- en: Setting up Mass
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Mass
- en: The story goes on…
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 故事还在继续……
- en: '*As Dr. Markus and Professor Victoria delved deeper into their groundbreaking
    research on AI, they found themselves faced with a new challenge; the laboratory
    was now filled with a large number of AI dummy puppets, each designed to mimic
    human behavior and responses. However, managing and synchronizing these puppets
    proved to be a* *daunting task.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 马库斯博士和维多利亚教授在深入研究他们关于人工智能的开创性研究时，发现自己面临着一个新的挑战；实验室现在充满了大量的人工智能木偶，每个木偶都设计用来模仿人类的行为和反应。然而，管理和同步这些木偶证明是一项艰巨的任务。
- en: '*In order to overcome this obstacle, Dr. Markus and Professor Victoria started
    by developing a sophisticated set of algorithms that would act as the core system
    for managing the puppets. This system would allow them to sync and coordinate
    the movements and actions of the AI puppets, making them work* *seamlessly together.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了克服这个障碍，马克斯博士和维多利亚教授首先开发了一套复杂的算法，这些算法将作为管理木偶的核心系统。这个系统将使他们能够同步和协调AI木偶的运动和动作，使它们无缝协作。*'
- en: In this section, we will show which plugins are needed to use Mass and how to
    enable them. Also, we will be working on a new level to get a first peek at the
    spawning system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示使用Mass所需的插件以及如何启用它们。此外，我们还将创建一个新的关卡以初步了解生成系统。
- en: Enabling plugins
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用插件
- en: 'In order to make Mass fully functional, you will need to enable the following
    plugins:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Mass完全功能化，您需要启用以下插件：
- en: '**MassEntity**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassEntity**'
- en: '**MassGameplay**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassGameplay**'
- en: '**MassAI**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassAI**'
- en: '**MassCrowd**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MassCrowd**'
- en: '**ZoneGraph**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ZoneGraph**'
- en: '**StateTree**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StateTree**'
- en: '**ZoneGraph** and **StateTree** are not part of the Mass framework but need
    to be included because of some dependencies in the code.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**ZoneGraph**和**StateTree**不是Mass框架的一部分，但需要包含在内，因为代码中存在一些依赖关系。'
- en: You are already familiar with the **Plugin** window, so open it up and enable
    the aforementioned plugins. You will get a warning about the experimental features
    you will be using and then you will be prompted to reload the Unreal Engine Editor
    in order to register the plugins.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉**插件**窗口，所以打开它并启用上述插件。您将收到有关您将使用的实验性功能的警告，然后您将被提示重新加载Unreal Engine编辑器以注册插件。
- en: Once this process is finished, you will be ready to get on with Mass.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此过程完成，您就可以开始使用Mass了。
- en: Creating a MassEntityConfigAsset
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建MassEntityConfigAsset
- en: In Mass, configuring entities is achieved through an Unreal Engine **data asset**
    .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mass中，配置实体是通过Unreal Engine **数据资产**实现的。
- en: In case you are unfamiliar with a data asset, it is a type of asset that stores
    data in a structured format. It is typically used to store various types of data,
    such as configuration settings, game parameters, localization text, and more.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉数据资产，它是一种以结构化格式存储数据的资产类型。它通常用于存储各种类型的数据，例如配置设置、游戏参数、本地化文本等。
- en: In Mass, you will be using a **MassEntityConfigAsset** data type, which will
    store trait information and fragments. As a starting point, we will be creating
    a config asset that will just let us debug information on where an object has
    been spawned in the level. This will let us visualize the current state of the
    system we are developing and analyze it at runtime.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mass中，您将使用**MassEntityConfigAsset**数据类型，该类型将存储特性和片段信息。作为一个起点，我们将创建一个配置资产，它将使我们能够在关卡中调试对象生成位置的信息。这将使我们能够可视化我们正在开发的系统的当前状态，并在运行时进行分析。
- en: 'To get started, in **Content Drawer** , create a new folder named **DataAssets**
    and open it up. Then, do the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，在**内容抽屉**中，创建一个名为**DataAssets**的新文件夹并打开它。然后，执行以下步骤：
- en: Right-click on **Content Drawer** and select **Miscellaneous** | **Data Asset**
    ; name the newly created asset **ME_DebugVisualizationConfig** .
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**内容抽屉**并选择**杂项** | **数据资产**；为新创建的资产命名为**ME_DebugVisualizationConfig**。
- en: In the **Config** section, you should see a **Traits** array; hit the **+**
    button to create a new item in the array.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置**部分，您应该看到一个**特性**数组；点击**+**按钮在数组中创建一个新项。
- en: From the array item dropdown menu, select **Debug Visualization** .
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组项下拉菜单中选择**调试可视化**。
- en: Expand the array item by clicking on the arrow.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击箭头展开数组项。
- en: Expand the **Debug Shape** attribute too.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**调试形状**属性。
- en: 'In the **Mesh** attribute, search for **Dummy_Base** and select it, as shown
    in *Figure 13* *.1* :'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**网格**属性中，搜索**Dummy_Base**并选择它，如图*图13* *.1* 所示：
- en: '![Figure 13.1 – ME_DebugVisualizationConfig](img/Figure_13.1_B31016.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – ME_DebugVisualizationConfig](img/Figure_13.1_B31016.jpg)'
- en: Figure 13.1 – ME_DebugVisualizationConfig
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – ME_DebugVisualizationConfig
- en: What we have done here is quite simple. We created a **MassEntity** configuration
    file with a single trait responsible for displaying a debug mesh at the location
    where an object has been spawned in the level.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是相当简单的。我们创建了一个**MassEntity**配置文件，其中包含一个负责在关卡中对象生成位置显示调试网格的单个特性。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to check that everything is fine, you can click the **Validate Entity
    Config** button that is located inside the **Data Asset** window. You should get
    a message stating that there are no errors in this asset.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要检查一切是否正常，你可以点击位于**数据资产**窗口中的**验证实体配置**按钮。你应该会收到一条消息，表明此资产没有错误。
- en: We will now proceed with the object spawn implementation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进行对象生成实现。
- en: Creating a spawn EQS
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个生成EQS
- en: 'To take advantage of the Mass Spawner subsystem, we will need an EQS that will
    return a set of locations that will tell the subsystem where to spawn objects.
    If you need a refresher about EQS, my advice is to check [*Chapter 11*](B31016_11.xhtml#_idTextAnchor218)
    , *Understanding the Environment Query System* , and then get back to this chapter
    when you are ready. We will be now creating an environment query that will just
    generate some points on a grid. In order to do so, open the **AI** folder and
    follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用Mass Spawner子系统，我们需要一个EQS，它将返回一组位置，告诉子系统在哪里生成对象。如果你需要关于EQS的复习，我的建议是查看[*第11章*](B31016_11.xhtml#_idTextAnchor218)，*理解环境查询系统*，然后在你准备好时回到这一章。我们现在将创建一个环境查询，它将在网格上生成一些点。为了做到这一点，打开**AI**文件夹并按照以下步骤操作：
- en: Right-click and select **Artificial Intelligence** | **Environment Query** .
    Name the newly created asset **EQS_SpawnEntitiesOnGrid** . Double-click on the
    asset to open it.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**人工智能** | **环境查询**。将新创建的资产命名为**EQS_SpawnEntitiesOnGrid**。双击资产以打开它。
- en: 'From the **ROOT** node, click and drag to create a **Points: Grid** node from
    the **Generators** category.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**根节点**开始，点击并拖动以从**生成器**类别创建一个**点：网格**节点。
- en: 'Click on the node and, in the **Details** panel, do the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击节点，在**详细信息**面板中，执行以下操作：
- en: Set the **GridHalfSize** attribute to **1500.0**
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**GridHalfSize**属性设置为**1500.0**
- en: In the **Projection Data** section, set the **Trace Mode** attribute to **Geometry**
    **by Channel**
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**投影数据**部分，将**轨迹模式**属性设置为**几何** **通过通道**
- en: '![Figure 13.2 – Environment query](img/Figure_13.2_B31016.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 环境查询](img/Figure_13.2_B31016.jpg)'
- en: Figure 13.2 – Environment query
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 环境查询
- en: The environment query we have just implemented will create a grid sized 3,000
    by 3,000 – as we have set the **GridHalfSize** property with a value of **1500.0**
    units – and will use a **Geometry by Channel** trace method to set the location
    of each item.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现的场景查询将创建一个3,000 x 3,000大小的网格——因为我们已将**GridHalfSize**属性设置为**1500.0**单位——并且将使用**通过通道的几何**轨迹方法来设置每个项目的位置。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with what traces are and how Unreal Engine uses them,
    my advice is to take a peek at the official documentation by visiting this page
    from the official documentation at [https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview](https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview)
    .
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道轨迹是什么以及虚幻引擎如何使用它们，我的建议是浏览官方文档，通过访问此页面来查看：[https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview](https://dev.epicgames.com/documentation/en-us/unreal-engine/traces-in-unreal-engine---overview)。
- en: We are now ready to use the Mass Spawner subsystem inside a level.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好在关卡中使用Mass Spawner子系统。
- en: Creating the gym
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建健身房
- en: 'To test the spawning feature, we are going to create a simple gym. To get started,
    create a level of your choice, starting from the Level Instances and Packed Level
    Actors I provided in the project template. If you wish, add some obstacles; my
    level is shown in *Figure 13* *.3* :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试生成功能，我们将创建一个简单的健身房。要开始，创建一个你选择的关卡，从我在项目模板中提供的Level Instances和Packed Level
    Actors开始。如果你愿意，可以添加一些障碍物；我的关卡如*图13* *.3* 所示：
- en: '![Figure 13.3 – Gym](img/Figure_13.3_B31016.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 健身房](img/Figure_13.3_B31016.jpg)'
- en: Figure 13.3 – Gym
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 健身房
- en: 'Now, follow these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤操作：
- en: On the **Editor** toolbar, click on the **Quickly add to the project** button
    and search for **Mass Spawner** . Select it to add an instance of it in the level.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**编辑器**工具栏上，点击**快速添加到项目**按钮，搜索**Mass Spawner**。选择它以在关卡中添加其实例。
- en: Place the **MassSpawner** object at the center of your level.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**MassSpawner**对象放置在关卡中心。
- en: 'Now that you have placed the **MassSpawner** object in the level, select it.
    In the **Details** panel, do the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经将**MassSpawner**对象放置在关卡中，请选择它。在**详细信息**面板中，执行以下操作：
- en: Set the **Count** property to **20**
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**计数**属性设置为**20**
- en: Click the **+** button on the **Entity Types** attribute to add an item to the
    array
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**实体类型**属性上的**+**按钮，向数组中添加一个项目
- en: Expand the item marked as **Index[0]** and set the **Entity Config** property
    to **ME_DebugVisualizationConfig**
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开标记为**Index[0]**的项目，并将**实体配置**属性设置为**ME_DebugVisualizationConfig**。
- en: '![Figure 13.4 – Entry types](img/Figure_13.4_B31016.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 条目类型](img/Figure_13.4_B31016.jpg)'
- en: Figure 13.4 – Entry types
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 条目类型
- en: 'We just set the **MassSpawner** property so that it spawns 20 entities that
    will use the data asset we previously created as the configuration asset. We now
    need to tell the **MassSpawner** property where to spawn them. To do this, follow
    these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了**MassSpawner**属性，使其生成20个实体，这些实体将使用我们之前创建的数据资产作为配置资产。现在我们需要告诉**MassSpawner**属性在哪里生成它们。为此，请按照以下步骤操作：
- en: In the **Details** panel, add an element to the **Spawn Data Generator** array
    and expand the **Index[0]** element.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，向**生成数据生成器**数组添加一个元素，并展开**Index[0]**元素。
- en: Set the **Generator Instance** property to **EQS** **SpawnPoints Generator**
    .
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**生成器实例**属性设置为**EQS** **SpawnPoints 生成器**。
- en: Expand **Generator Instance** and its **Query** child.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**生成器实例**及其**查询**子项。
- en: Set **Query Template** to **EQS_SpawnEntitiesOnGrid** .
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**查询模板**设置为**EQS_SpawnEntitiesOnGrid**。
- en: '![Figure 13.5 – Spawn point generator](img/Figure_13.5_B31016.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 生成点生成器](img/Figure_13.5_B31016.jpg)'
- en: Figure 13.5 – Spawn point generator
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 生成点生成器
- en: In the previous steps, we have set the generator logic to the entity query we
    had previously created. It’s now time to test the gym.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们已经将生成器逻辑设置为我们之前创建的实体查询。现在是时候测试健身房了。
- en: Testing the gym
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试健身房
- en: 'To test the gym, all you need to do is to simulate – or play – the level; you
    will see 20 debug models spawned on a grid, as shown in *Figure 13* *.6* :'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试健身房，你只需要模拟或玩游戏；你将看到20个调试模型在一个网格上生成，如图*图13* *.6* 所示：
- en: '![Figure 13.6 – Gym](img/Figure_13.6_B31016.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 健身房](img/Figure_13.6_B31016.jpg)'
- en: Figure 13.6 – Gym
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 健身房
- en: Please note that models will be correctly placed on objects; this is happening
    because we used the **Geometry by Channel** trace mode inside our environment
    query.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模型将被正确地放置在对象上；这是因为我们在环境查询中使用了**按通道几何**跟踪模式。
- en: 'By enabling the debugging tools, you will have some insightful information
    about what’s happening inside the level along with a plethora of options, as depicted
    in *Figure 13* *.7* :'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用调试工具，你将获得有关级别内部发生情况的一些有见地的信息，以及大量选项，如图*图13* *.7* 所示：
- en: '![Figure 13.7 – Debugging tools](img/Figure_13.7_B31016.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 调试工具](img/Figure_13.7_B31016.jpg)'
- en: Figure 13.7 – Debugging tools
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 调试工具
- en: 'I highly encourage you to explore the various debugging tool options, as they
    can greatly enhance your efficiency in identifying and resolving your game issues.
    As an example, *Figure 13* *.8* shows the archetype information that was enabled
    by using the *Shift* + *A* key combination:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你探索各种调试工具选项，因为它们可以极大地提高你识别和解决游戏问题的效率。例如，*图13* *.8* 显示了通过使用*Shift* + *A*键组合启用的架构信息：
- en: '![Figure 13.8 – Archetype information](img/Figure_13.8_B31016.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8 – 架构信息](img/Figure_13.8_B31016.jpg)'
- en: Figure 13.8 – Archetype information
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 架构信息
- en: In this section, we got a glimpse of what’s possible to create with Mass; in
    particular, we saw how to create a spawn area through the **MassSpawner** subsystem.
    In the next section, we will go into more detail by spawning a set of Blueprints
    instead of some debugging models.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们瞥见了使用Mass可以创建的内容；特别是，我们看到了如何通过**MassSpawner**子系统创建出生区域。在下一节中，我们将通过创建一组蓝图而不是一些调试模型来更详细地介绍。
- en: Spawning Blueprints
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成蓝图
- en: In this section, we will be taking a step further with the **MassSpawner** subsystem
    as we will be generating a set of Blueprint instances instead of simply showing
    debug meshes; this will let us transition from a simple debugging gym to a real
    case environment. Additionally, we will learn how to handle the LOD for spawned
    entities.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过**MassSpawner**子系统进一步深入，因为我们将生成一组蓝图实例而不是简单地显示调试网格；这将使我们从简单的调试健身房过渡到真实案例环境。此外，我们将学习如何处理生成实体的LOD。
- en: Let’s imagine that we want to create a concert where the audience is automatically
    generated, and it is managed as a whole by Mass. We will be creating such a scenario
    using the Mass framework.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们想要创建一个音乐会，观众会自动生成，并且由Mass整体管理。我们将使用Mass框架创建这样的场景。
- en: Creating the audience Blueprints
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建观众蓝图
- en: 'As a first step, we will be creating a Blueprint that will serve us as the
    audience for an imaginary concert; entities will be cheering, sitting, or simply
    staying still. Additionally, we will be using the Mass LOD management system.
    Instead of creating just one Blueprint, we will be creating two: one that will
    be activated by the management system when near the camera and the other that
    will be activated when far away. This will let us manage and show more complex
    entities only when near the camera and fall back to less complex entities when
    far away. For the sake of demonstration, we will be using a Blueprint that will
    just stay still and won’t be animated – the one that will be visualized when far
    away – and one that will show random animations.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们将创建一个蓝图，它将作为一场想象中的音乐会的观众；实体将欢呼、坐下或简单地保持静止。此外，我们还将使用质量LOD管理系统。我们不会只创建一个蓝图，而是创建两个：一个将在靠近相机时由管理系统激活，另一个将在远离相机时激活。这将使我们能够在靠近相机时管理和显示更复杂的实体，而在远离相机时退回到较简单的实体。为了演示，我们将使用一个将保持静止且不会动画化的蓝图——当远离相机时可视化的那个，以及一个将显示随机动画的蓝图。
- en: 'Let’s start with the first Blueprint by doing the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个蓝图开始，按照以下步骤操作：
- en: Create a new Blueprint class inheriting from **BaseDummyCharacter** and call
    it **BP_AudienceLow** .
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图类，从**BaseDummyCharacter**继承，命名为**BP_AudienceLow**。
- en: Open the Blueprint, and in the **Animation Mode** property, select **Use** **Animation
    Asset** .
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图，在**动画模式**属性中，选择**使用****动画资产**。
- en: Uncheck the **Looping** and **Playing** checkboxes.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**Looping**和**Playing**复选框。
- en: Set the **Initial Position** attribute to **0.4** .
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**初始位置**属性设置为**0.4**。
- en: Once visualized in the level, this character will just stand still and show
    a cheering position.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在级别中可视化，这个角色将只是站立并展示欢呼的姿态。
- en: 'The second Blueprint is going to be slightly more complex. To implement it,
    follow these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个蓝图将稍微复杂一些。要实现它，请按照以下步骤操作：
- en: Create a new Blueprint class inheriting from **BaseDummyCharacter** and call
    it **BP_AudienceHigh** .
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图类，从**BaseDummyCharacter**继承，命名为**BP_AudienceHigh**。
- en: Create a new variable of the **Anim Montage Object Reference** type, call it
    **MontageList** , and make it an array.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**Anim Montage Object Reference**类型变量，命名为**MontageList**，并将其设置为数组。
- en: Create two variables of the **float** type and name them **MinInterval** and
    **MaxInterval** , respectively.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个**浮点型**变量，分别命名为**MinInterval**和**MaxInterval**。
- en: Compile the Blueprint to expose the **Default Value** properties and set the
    **MinInterval** value to **3.0** and **MaxInterval** to **6.0** .
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图以暴露**默认值**属性，并将**MinInterval**值设置为**3.0**，**MaxInterval**设置为**6.0**。
- en: Add three items in **MontageList** **Default Value** and set them, respectively,
    to **AM_Cheer** , **AM_Interact** , and **AM_Sit** .
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**MontageList** **默认值**中添加三个项目，分别设置为**AM_Cheer**、**AM_Interact**和**AM_Sit**。
- en: In the Event Graph, connect the **Event Begin Play** execution pin to a **Delay**
    node.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中，将**Event Begin Play**执行引脚连接到一个**Delay**节点。
- en: Connect the **Duration** pin of the **Delay** node to a **Random Float in**
    **Range** node.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Delay**节点的**Duration**引脚连接到一个**Random Float in Range**节点。
- en: From the **Variables** section, drag a **MinInterval** getter node and connect
    it to the **Min** pin of the **Random Float in** **Range** node.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分，拖动一个**MinInterval**获取节点并将其连接到**Random Float in Range**节点的**Min**引脚。
- en: 'From the **Variables** section, drag a **MaxInterval** getter node and connect
    it to the **Max** pin of the **Random Float in Range** node. This portion of the
    graph is depicted in *Figure 13* *.8* :'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分，拖动一个**MaxInterval**获取节点并将其连接到**Random Float in Range**节点的**Max**引脚。这部分图表在*图13.8*中描述：
- en: '![ Figure 13.9 – Delay logic](img/Figure_13.9_B31016.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – 延迟逻辑](img/Figure_13.9_B31016.jpg)'
- en: Figure 13.9 – Delay logic
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 延迟逻辑
- en: 'This portion of the graph is nothing fancy and is just adding a random delay
    to the code logic. Let’s get on with the code by doing the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分图表并没有什么特别之处，只是给代码逻辑添加了一个随机延迟。让我们继续编写代码，按照以下步骤操作：
- en: Connect the outgoing execution pin of the **Delay** node to a **Play** **Montage**
    node.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Delay**节点的输出执行引脚连接到一个**Play Montage**节点。
- en: From the **Components** panel, drag a **Mesh** reference in the Event Graph
    and connect it to the **In Skeletal Mesh Component** pin of the **Play** **Montage**
    node.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**组件**面板，将一个**网格**引用拖动到事件图中，并将其连接到**Play Montage**节点的**In Skeletal Mesh Component**引脚。
- en: Drag a **MontageList** getter in the Event Graph and connect its pin to a **Random
    Array** **Item** node.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中拖动一个**MontageList**获取器，并将其引脚连接到**Random Array** **Item**节点。
- en: 'Connect the **Out Item** pin of the **Random** node to the **Montage to Play**
    pin of the **Play Montage** node. This part of the graph is shown in *Figure 13*
    *.10* :'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Random**节点的**Out Item**引脚连接到**Play Montage**节点的**Montage to Play**引脚。此部分图表显示在*图13*
    *.10*中：
- en: '![Figure 13.10 – Play Montage logic](img/Figure_13.10_B31016.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 播放蒙太奇逻辑](img/Figure_13.10_B31016.jpg)'
- en: Figure 13.10 – Play Montage logic
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 播放蒙太奇逻辑
- en: Here we are doing something pretty straightforward; we are getting a random
    animation montage from the array and then we play it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们正在做一件相当直接的事情；我们从数组中获取一个随机的动画蒙太奇，然后播放它。
- en: 'The last thing to do is to create an infinite loop that will keep on playing
    an animation montage after a delay. To do this, follow these steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是创建一个无限循环，在延迟后持续播放动画蒙太奇。为此，请按照以下步骤操作：
- en: Connect the **On Completed** outgoing execution pin of the **Play Montage**
    node to the incoming execution pin of the **Delay** node.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Play Montage**节点的**On Completed**输出执行引脚连接到**Delay**节点的输入执行引脚。
- en: 'Add a couple of reroute nodes, in order to make the graph clearer. The code
    is shown in *Figure 13* *.11* :'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加几个重定向节点，以便使图表更清晰。代码显示在*图13* *.11*中：
- en: '![Figure 13.11 – Loop](img/Figure_13.11_B31016.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11 – 循环](img/Figure_13.11_B31016.jpg)'
- en: Figure 13.11 – Loop
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 循环
- en: Our character is now ready and, once instantiated in a level, will keep on playing
    random animations. We will now create the **MassEntityConfigAsset** for the **MassSpawner**
    that will be placed in the gym.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色现在已准备就绪，一旦在级别中实例化，将不断播放随机动画。我们现在将创建放置在健身房中的**MassSpawner**的**MassEntityConfigAsset**。
- en: Creating a MassEntityConfigAsset
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个MassEntityConfigAsset
- en: The **MassEntityConfigAsset** we will be creating is going to be more complex
    than the previous one. In this case, we will need to spawn characters in the level,
    and we will need to handle what is instantiated depending on the distance from
    the camera.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的**MassEntityConfigAsset**将比之前的更复杂。在这种情况下，我们需要在级别中生成角色，并且我们需要根据与摄像机的距离处理实例化内容。
- en: 'To get started, open the **DataAssets** folder, create a new **Data Asset**
    of the **Mass Entity Config Asset** type, and name it **ME_AudienceConfig** .
    Then, open it and perform the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开**DataAssets**文件夹，创建一个新的**Mass Entity Config Asset**类型的**Data Asset**，并将其命名为**ME_AudienceConfig**。然后，打开它并执行以下步骤：
- en: In the **Traits** section, add three array elements by clicking the **+** button
    three times.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**特性**部分，通过点击**+**按钮三次添加三个数组元素。
- en: From each of the items’ dropdown menus, select **Mass Stationary Distance Visualization
    Trait** , **Assorted Fragments** , and **LODCollector** , respectively.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个项目的下拉菜单中，分别选择**Mass Stationary Distance Visualization Trait**、**Assorted
    Fragments**和**LODCollector**。
- en: '![Figure 13.12 – Audience Config data asset](img/Figure_13.12_B31016.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12 – 观众配置数据资产](img/Figure_13.12_B31016.jpg)'
- en: Figure 13.12 – Audience Config data asset
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 观众配置数据资产
- en: We will now be checking each of them to get some information on how they work.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查它们中的每一个，以获取它们如何工作的信息。
- en: Configuring Mass Stationary Distance Visualization Trait
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置大众站距可视化特性
- en: 'This trait is responsible for the visualization of the entity in the world
    and will need to be properly set in order to correctly show the actor in the level.
    So, follow these steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此特性负责在世界上可视化实体，并且需要正确设置，以便正确显示演员在级别中。因此，请按照以下步骤操作：
- en: Expand the **Trait** item to show all settings.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开特性项以显示所有设置。
- en: Set the **High Res Template Actor** property to **BP_AudienceHigh** .
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**High Res Template Actor**属性设置为**BP_AudienceHigh**。
- en: Set the **Low Res Template Actor** property to **BP_AudienceLow** .
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Low Res Template Actor**属性设置为**BP_AudienceLow**。
- en: Expand the **Params** section and set the **High** and **Medium** properties
    to **High Res Spawned Actor** and the **Low** property to **Low Res** **Spawned
    Actor** .
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开参数部分，将**High**和**Medium**属性设置为**High Res Spawned Actor**，将**Low**属性设置为**Low
    Res** **Spawned Actor**。
- en: Check the **Keep Actor Extra** **Frame** property.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查**Keep Actor Extra** **Frame**属性。
- en: '![Figure 13.13 – Mass Stationary Distance Visualization settings](img/Figure_13.13_B31016.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13 – 大众站距可视化设置](img/Figure_13.13_B31016.jpg)'
- en: Figure 13.13 – Mass Stationary Distance Visualization settings
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 – 大众站距可视化设置
- en: As you can see here, we defined a high- and low-resolution template from the
    previously created Blueprints. Then we used these definitions to set the LOD representation
    for the entity. Checking the **Keep Actor Extra Frame** flag will help with rendering
    when transitioning between different LODs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，我们根据之前创建的蓝图定义了一个高分辨率和低分辨率模板。然后我们使用这些定义来设置实体的LOD表示。检查**保留演员额外帧**标志将有助于在不同LOD之间切换时的渲染。
- en: Configuring Assorted Fragments
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置各种片段
- en: 'The **Assorted Fragments** trait enables you to define an array of fragments
    that may be required by other traits. To achieve this, open the **Assorted Fragments**
    trait section and then the **Fragments** section and do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**各种片段**特性使您能够定义一个可能由其他特性所需的片段数组。为了实现这一点，打开**各种片段**特性部分，然后是**片段**部分，并执行以下操作：'
- en: Add two fragments to the array by clicking the **+** button twice.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**+**按钮两次添加两个片段到数组中。
- en: Set the first item of the list to **Transform Fragment** and the second one
    to **Mass** **Actor Fragment** .
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表的第一项设置为**变换片段**，第二项设置为**Mass** **演员片段**。
- en: '![Figure 13.14 – Assorted Fragments settings](img/Figure_13.14_B31016.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14 – 各种片段设置](img/Figure_13.14_B31016.jpg)'
- en: Figure 13.14 – Assorted Fragments settings
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – 各种片段设置
- en: '**Transform** **Fragment** is responsible for storing the entity world transform,
    while **Mass Actor Fragment** will hold a pointer to the actor that will be used
    by the visualization trait.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换** **片段**负责存储实体世界变换，而**Mass演员片段**将保留一个指向将被可视化特性使用的演员的指针。'
- en: Configuring LODCollector
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置LODCollector
- en: The entity configuration will need the **LODCollector** trait to facilitate
    the adjustment between LOD levels. The **LODCollector** processor assesses the
    appropriate LOD for each entity by considering its proximity to viewers and its
    relationship to the camera frustum.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实体配置需要**LODCollector**特性来促进LOD级别之间的调整。**LODCollector**处理器通过考虑实体与观众的距离及其与摄像机视锥体的关系来评估每个实体的适当LOD。
- en: It does not require any configuration, so you can leave it as it is.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要任何配置，所以您可以保持原样。
- en: With the data asset properly configured, we can go on with setting up our system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据资产正确配置后，我们可以继续设置我们的系统。
- en: Enabling the automatic processor registration
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用自动处理器注册
- en: Before creating and testing the gym, we will need to take one more step. At
    the time of writing this book, the current version of Mass needs some properties
    to have the **Auto Register with Processing Phases** flag enabled in the Mass
    settings; this is due to Mass still being in beta status and not yet a final release.
    Not setting this flag will result in the Mass entities not being visible in the
    game. This is due to some conflicts with the **MassCrowd** plugin that will be
    addressed in the future.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和测试健身房之前，我们还需要再走一步。在撰写本书时，Mass的当前版本需要一些属性在Mass设置中启用**自动与处理阶段注册**标志；这是由于Mass仍然处于测试版状态，尚未是最终版本。不设置此标志将导致Mass实体在游戏中不可见。这是由于与即将解决的**MassCrowd**插件存在一些冲突。
- en: 'To fix this issue, from the main menu, select **Edit** | **Project Settings**
    and open the **Engine** | **Mass** section. After that, do the following steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，从主菜单中选择**编辑** | **项目设置**并打开**引擎** | **Mass**部分。之后，执行以下步骤：
- en: Expand the **Module** **Settings** section.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**模块** **设置**部分。
- en: Expand the **Mass** **Entity** section.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**Mass** **实体**部分。
- en: Expand the **Processor** **CDOs** section.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**处理器** **CDOs**部分。
- en: Search through the array of processors for **MassLODCollectorProcessor** , **MassRepresentationProcessor**
    , and **MassVisualizationLODProcessor** . Expand the processors and check the
    **Auto Register with Processing Phases** flag for each of them.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理器数组中搜索**MassLODCollectorProcessor**、**MassRepresentationProcessor**和**MassVisualizationLODProcessor**。展开处理器并检查每个的**自动与处理阶段注册**标志。
- en: '![Figure 13.15 – Auto Register with Processor Phases settings](img/Figure_13.15_B31016.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图13.15 – 与处理器阶段自动注册设置](img/Figure_13.15_B31016.jpg)'
- en: Figure 13.15 – Auto Register with Processor Phases settings
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 – 与处理器阶段自动注册设置
- en: With these settings enabled, we can go on and create a testing gym.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 启用这些设置后，我们可以继续创建测试健身房。
- en: Creating the gym
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建健身房
- en: 'Since we will be working with a lot of actors, I think it would be fun to take
    our beloved dummy puppets outside for some fresh air! That’s why, instead of using
    the usual enclosed gym, we will be setting up an open-air environment. Let’s start
    by doing the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将与许多演员一起工作，我认为带我们心爱的木偶到户外呼吸新鲜空气会很有趣！这就是为什么，我们不会使用通常的封闭健身房，而会设置一个露天环境。让我们从以下步骤开始：
- en: Create a new level by using the **Open** **World** template.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用**打开** **世界**模板创建一个新的关卡。
- en: Add a **MassSpawner** actor in the level and select it.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中添加一个**MassSpawner**演员并选择它。
- en: In the **Settings** panel, set the **Count** property to **50** .
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**面板中，将**计数**属性设置为**50**。
- en: In the **Entity Types** array, add a new item and expand it.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**实体类型**数组中添加一个新项目并展开它。
- en: Set the **Entity Config** property to **ME_AudienceConfig** .
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**实体配置**属性设置为**ME_AudienceConfig**。
- en: Add a new item in the **Spawn Data Generators** array and expand it.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**生成数据生成器**数组中添加一个新项目并展开它。
- en: Set the **Generator Instance** property to **EQS SpawnPoints Generator** and
    expand its **Query** section.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**生成器实例**属性设置为**EQS SpawnPoints Generator**并展开其**查询**部分。
- en: Expand the **EQSRequest** section and set the **Query Template** attribute to
    **EQS_SpawnEntitiesOnGrid** .
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**EQSRequest**部分，并将**查询模板**属性设置为**EQS_SpawnEntitiesOnGrid**。
- en: '![Figure 13.16 – Mass Spawner Details panel](img/Figure_13.16_B31016.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图13.16 – 大量生成器详细信息面板](img/Figure_13.16_B31016.jpg)'
- en: Figure 13.16 – Mass Spawner Details panel
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 – 大量生成器详细信息面板
- en: Simulate the level and you should get... something weird!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟关卡，您应该得到...一些奇怪的东西！
- en: '![Figure 13.17 – Wrong position](img/Figure_13.17_B31016.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图13.17 – 错误位置](img/Figure_13.17_B31016.jpg)'
- en: Figure 13.17 – Wrong position
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17 – 错误位置
- en: It seems all the characters are positioned halfway under the floor. This occurs
    because the **Capsule** component of a character is computed to be centered around
    the local coordinates of **(0.0, 0.0, 0.0)** . Fixing this issue is trivial and
    you’ll need to adjust a single property of the environment query.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来所有角色都位于地板一半以下。这是因为角色的**胶囊**组件被计算为中心在局部坐标**(0.0, 0.0, 0.0)**。修复这个问题很简单，您只需要调整环境查询的单个属性。
- en: 'Let’s start by duplicating **EQS_SpawnEntitiesOnGrid** and calling it **EQS_SpawnEntitiesOnGrid_ZOffset**
    . Then, do the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从复制**EQS_SpawnEntitiesOnGrid**并将其命名为**EQS_SpawnEntitiesOnGrid_ZOffset**开始。然后，执行以下步骤：
- en: Open the newly created asset and select the **SimpleGrid** node.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的资产并选择**SimpleGrid**节点。
- en: In the **Details** panel, expand the **Projection Data** section and set **Post
    Projection Vertical Offset** to **120.0** .
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，展开**投影数据**部分，并将**投影后垂直偏移**设置为**120.0**。
- en: In your level, select the **MassSpawner** actor and change **Query Template**
    to **EQS_SpawnEntitiesOnGrid_ZOffset** .
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的关卡中，选择**MassSpawner**演员并将**查询模板**更改为**EQS_SpawnEntitiesOnGrid_ZOffset**。
- en: 'If you test the level right now, your characters should be correctly positioned,
    as shown in *Figure 13* *.18* :'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在测试关卡，您的角色应该被正确定位，如图*图13* *.18* 所示：
- en: '![Figure 13.18 – Right position](img/Figure_13.18_B31016.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图13.18 – 正确位置](img/Figure_13.18_B31016.jpg)'
- en: Figure 13.18 – Right position
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 – 正确位置
- en: 'Additionally, you should notice that the characters near the camera will be
    animated, while the ones that are at a distance will be stuck in a cheering position,
    as shown in *Figure 13* *.19* :'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该注意到靠近摄像机的角色将会被动画化，而那些在远处的角色将保持在欢呼的位置，如图*图13* *.19* 所示：
- en: '![Figure 13.19 – Non-animated characters](img/Figure_13.19_B31016.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图13.19 – 非动画角色](img/Figure_13.19_B31016.jpg)'
- en: Figure 13.19 – Non-animated characters
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 – 非动画角色
- en: This is happening because of the configuration setting we defined in the **Mass
    Stationary Distance Visualization** trait. I highly encourage you to open the
    **ME_AudienceConfig** asset back up and tweak the **LODDistance** values – **High**
    , **Medium** , **Low** , and **Off** – to see how your entities behave.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在**质量静止距离可视化**特性中定义的配置设置导致的。我强烈建议您重新打开**ME_AudienceConfig**资产，并调整**LODDistance**值——**高**、**中**、**低**和**关闭**——以查看您的实体行为。
- en: In this section, I showed you some more advanced traits that compose the Mass
    framework. We created a new configuration data asset whose task is to manage the
    LOD of the spawned entities. Then we created a dedicated Mass Spawner that creates
    high numbers of actors in the level leveraging an environment query.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我向您展示了构成质量框架的一些更高级的特性。我们创建了一个新的配置数据资产，其任务是管理生成的实体的LOD（细节层次）。然后我们创建了一个专门的Mass
    Spawner，它通过利用环境查询在级别中创建大量演员。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we introduced you to the experimental yet highly powerful
    Mass framework. Starting from the basics, we presented the plugins that make up
    the whole system. After that, we created a couple of working examples that take
    advantage of Mass: a simple debug scenario for checking Mass Spawner and a more
    complex one to get a strong grip on how traits can be combined to handle high
    numbers of entities.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了实验性但功能强大的Mass框架。从基础知识开始，我们介绍了构成整个系统的插件。之后，我们创建了一些利用Mass的工作示例：一个简单的调试场景用于检查Mass
    Spawner，以及一个更复杂的示例，以深入了解如何将特性组合起来处理大量实体。
- en: Using this framework is particularly beneficial in scenarios that require the
    simulation of crowds, physics interactions, and dynamic entity management. So,
    if your game needs these types of features, you will highly benefit from using
    Mass.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要模拟人群、物理交互和动态实体管理的场景中，使用此框架特别有益。因此，如果您的游戏需要这些类型的功能，您将极大地从使用Mass中受益。
- en: In the next – and last – chapter, we will show you another feature that will
    provide a way to handle and manage various activities and interactions for both
    AI characters and players. Get ready for an intriguing exploration as things are
    about to get even more interesting!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章——也是最后一章中，我们将向您展示另一个功能，它将提供一种处理和管理AI角色和玩家各种活动和交互的方法。准备好进行一次引人入胜的探索，因为事情即将变得更加有趣！
