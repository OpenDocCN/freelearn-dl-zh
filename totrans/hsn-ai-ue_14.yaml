- en: Debugging Methods for AI - Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI调试方法 - 日志记录
- en: In this chapter, we will look at a series of methods that we can use to debug
    our AI systems. Of course, they can be used in general, and not only for AI. However,
    since AI can be tricky sometimes, mastering how to do proper logging in Unreal
    can be a time-saver when you need to find and fix a bug related to AI. In fact,
    often, due to variables that haven't been properly set, maybe with wrong values,
    we end up not executing a portion of code, or make a miscalculation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一系列我们可以用来调试我们的AI系统的方法。当然，它们可以通用，而不仅仅是用于AI。然而，由于AI有时可能很棘手，掌握如何在Unreal中进行适当的日志记录可以在你需要找到和修复与AI相关的错误时节省时间。实际上，由于某些变量设置不当，可能值错误，我们最终没有执行代码的一部分，或者做出了错误计算。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Console Logging and on-screen messages in Blueprint
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图中的控制台日志和屏幕消息
- en: On-screen messages in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的屏幕消息
- en: Console Logging in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的控制台日志记录
- en: Creating a Custom Logging Category (C++)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义日志类别（C++）
- en: By mastering the art of logging, you will be able to easily keep track of your
    values and which part of the code you are executing. Moreover, creating a Custom
    Logging Category allows you to define different levels of logging, and change
    the quantity of logging you want to see (even at runtime) based on what you are
    debugging. Furthermore, it is possible to easily strip away all the debugging
    code (at compilation time) by changing a variable, so that your shipped game can
    run as smoothly as possible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握日志记录的艺术，你将能够轻松地跟踪你的值和正在执行的代码部分。此外，创建自定义日志类别允许你定义不同的日志级别，并根据你正在调试的内容（甚至是在运行时）更改你想要看到的日志数量。此外，通过更改一个变量，可以轻松地在编译时移除所有调试代码，从而使你的发布游戏尽可能流畅地运行。
- en: With this being said, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们开始吧！
- en: Basic Logging
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本日志记录
- en: In the previous chapters we already looked at how to make logs. For example,
    in [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml), *Agent Awareness*,
    we saw how to print the information we needed both on the Console and on-screen.
    However, in this section, we will explore those concepts in more detail, and learn
    how to master logging within Unreal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经了解了如何创建日志。例如，在[第五章](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml)“代理意识”中，我们看到了如何同时在控制台和屏幕上打印所需的信息。然而，在本节中，我们将更详细地探讨这些概念，并学习如何在Unreal中掌握日志记录。
- en: '**On-Screen messages**: Often, during the Debugging phase, you and your team
    will need to be aware of certain variable values while playing the game. Thus,
    the easiest way to continuously test the value of the variable is by printing
    its value on the screen. We can achieve this in different ways, both in Blueprint
    and C++.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕消息**：在调试阶段，你和你团队需要了解某些变量值，以便在玩游戏时进行持续测试。因此，最简单的方法是在屏幕上打印变量的值。我们可以在蓝图和C++中以不同的方式实现这一点。'
- en: '**Console Messages**: These are printed on the Console (actually, there is
    more than one) and into Log files (so that even when the game is not running,
    you can analyze the log files to understand what happened (or what went wrong)).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台消息**：这些消息会打印在控制台（实际上，不止一个）和日志文件中（这样即使游戏没有运行，你也可以分析日志文件来了解发生了什么（或出了什么问题））。'
- en: While in Blueprint we have a unique function to print both on-screen and into
    the Console, in C++, we have separate functions. In fact, the Logging System in
    Unreal is very powerful, and C++ unlocks its full power.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在蓝图中有独特的函数可以同时在屏幕上打印和打印到控制台，但在C++中，我们有单独的函数。实际上，Unreal的日志系统非常强大，C++可以解锁其全部功能。
- en: Console Logging and on-screen messages in Blueprint
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图中的控制台日志和屏幕消息
- en: 'When it comes to Blueprint, we have simple and easy debug nodes that we can
    use. The most common one is Print String, but its counterpart, Print Text, also
    exists. The following is a screenshot showing Print String and Print Text:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到蓝图时，我们有简单易用的调试节点可以使用。最常见的一个是打印字符串，但它的对应物，打印文本，也存在。以下是一个显示打印字符串和打印文本的截图：
- en: '![](img/ca5d2f4b-756a-4291-b15d-4b3ce18a6d9f.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ca5d2f4b-756a-4291-b15d-4b3ce18a6d9f.png)'
- en: Both of them are marked as ***Development Only***, which means that they will
    not working in shipping builds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都标记为***仅限开发使用***，这意味着它们将不会在发布构建中工作。
- en: Their simple usage is straightforward. You just need to plug a *String* (or
    *Text*) into the homonym variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的简单用法很简单。你只需要将一个*字符串*（或*文本*）连接到同名的变量。
- en: 'However, if we expand them and look at their more advanced options, we can
    find a full list of parameters, as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们展开它们并查看它们的更高级选项，我们可以找到一个完整的参数列表，如下面的截图所示：
- en: '![](img/aaaf0817-d0e3-40eb-a535-b7d88326aed9.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aaaf0817-d0e3-40eb-a535-b7d88326aed9.png)'
- en: 'Let''s look at them in detail:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看它们：
- en: '**String / Text**: This is the String or Text that will be displayed on-screen.
    Thus, any information that needs to be displayed has to be within this String
    or Text.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串/文本**：这是将在屏幕上显示的字符串或文本。因此，需要显示的任何信息都必须在这个字符串或文本中。'
- en: '**Print to Screen**: If true, the node will actually print the message on-screen
    (by default, it is true).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印到屏幕**：如果为真，节点实际上将在屏幕上打印消息（默认为真）。'
- en: '**Print to Console**: If true, the node will print the message in the Console
    as well (by default, it is true).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印到控制台**：如果为真，节点将在控制台打印消息（默认为真）。'
- en: '**Text Color**: This is the color in which the String/Text will be displayed
    (by default, it is a light blue). This is useful when you need to visually distinguish
    different information. Colors help a lot in these kinds of situations.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本颜色**：这是字符串/文本将显示的颜色（默认为浅蓝色）。当你需要从视觉上区分不同的信息时，这很有用。在这种情况下，颜色非常有帮助。'
- en: '**Duration**: This is how long the message will be displayed on the screen.
    Make sure that you have enough time to read/assimilate the information. Of course,
    longer messages need a longer duration to be read.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续时间**：这是消息将在屏幕上显示的时间。确保你有足够的时间阅读/吸收信息。当然，较长的消息需要更长的持续时间来阅读。'
- en: 'This is how they should appear in-game:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它们在游戏中的显示方式：
- en: '![](img/7cf50498-61df-4eaa-93c3-a1498dbfcf67.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cf50498-61df-4eaa-93c3-a1498dbfcf67.png)'
- en: 'The same log also appears in the console if "***Print to Console***" is set
    to true, and looks as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“***打印到控制台***”设置为真，相同的日志也会出现在控制台，如下所示：
- en: '![](img/013b17b6-e8e5-4069-af67-ffceaa419596.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/013b17b6-e8e5-4069-af67-ffceaa419596.png)'
- en: On-screen messages in C++
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的屏幕消息
- en: 'In C++, we have an handy function to print messages on-screen. We do this within
    the `UEngine` class. The easiest way to have access to it is by using the GEngine
    variable, which is a global variable that''s available everywhere and contains
    the instance of the *UEngine* class. Keep in mind that this variable might be
    empty (e.g. the game is running on a shipping build). Thus, it is very good practice
    to check the variable before you use it, like in the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们有一个方便的函数可以打印屏幕上的消息。我们在`UEngine`类中这样做。获取它的最简单方法是通过使用GEngine变量，这是一个在所有地方都可用且包含*UEngine*类实例的全局变量。请记住，这个变量可能为空（例如，游戏正在运行在发布构建上）。因此，在使用它之前检查变量是一个非常好的做法，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within the `if` statement, we can use the **GEngine** variable to call the
    `AddOnScreenDebugMessage()` function. As you would have guessed from the name,
    it prints a message on-screen. This is its full declaration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句中，我们可以使用**GEngine**变量来调用`AddOnScreenDebugMessage()`函数。正如你所猜测的，它会在屏幕上打印一条消息。这是它的完整声明：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s go through the different parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍不同的参数：
- en: '**Key**: This is a unique key that''s given to a "slot" on the screen. When
    a new message needs to be written, but there is already one with the same key
    displayed, then the new one will replace the old one. This is particularly useful
    when you have a variable that updates often and you don''t want to flood the screen
    with a lot of debug messages, especially when only the last one is relevant. Remember
    to use the same key when you print the same information, just updated.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键**：这是一个唯一键，它被赋予屏幕上的“槽位”。当需要写入新消息，但已经有一个具有相同键的消息显示时，新消息将替换旧消息。这在你有经常更新的变量且不想在屏幕上显示大量调试消息时特别有用，尤其是当只有最后一个是相关的时候。记住，在打印相同信息但更新时使用相同的键。'
- en: In the definition, the Key parameter is a **uint64**. However, there is wrapper
    that works with **int32**. Don't worry if you define your keys as **int32**, as
    they will work anyway.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义中，键参数是一个**uint64**。然而，有一个与**int32**一起工作的包装器。如果你将键定义为**int32**，不要担心，因为它们仍然可以正常工作。
- en: '**TimeToDisplay**: This is the duration, expressed in seconds, of how long
    the message needs to remain displayed on-screen. Make sure that you have enough
    time to read/assimilate the information. Of course, longer messages need longer
    durations to be read.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示时间**：这是消息需要在屏幕上显示的持续时间，以秒为单位。确保你有足够的时间阅读/吸收信息。当然，较长的消息需要更长的持续时间来阅读。'
- en: '**DisplayColor**: This is the color in which the debug message will be displayed.
    This is useful when you need to visually distinguish different information. Colors
    help a lot in these kinds of situations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DisplayColor**: 这是调试消息将显示的颜色。当您需要从视觉上区分不同的信息时，这很有用。在这种情况下，颜色非常有帮助。'
- en: '**DebugMessage**: This is the string that will be displayed on-screen. Thus,
    any information that needs to be displayed has to be packed into an ***FString***.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DebugMessage**: 这是将在屏幕上显示的字符串。因此，需要显示的任何信息都必须打包到**FString**中。'
- en: '**bNewerOnTop**: iThis s a boolean that it is used only when the key is equal
    to **INDEX_NONE** (which means a value of -1). If true, every new message will
    be displayed on top of the others. Otherwise, every new message will be placed
    below the others (like in a normal console). This is an option parameter, which
    is set to true by default. In fact, unlike a normal console, the text doesn''t
    scroll down, so placing the most recent information on top guarantees that it
    is always available to developers.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bNewerOnTop**: 这是一个布尔值，仅在键值等于**INDEX_NONE**（表示-1的值）时使用。如果为真，每条新消息都将显示在其他消息的顶部。否则，每条新消息都将放置在其他消息的下方（就像在正常控制台一样）。这是一个可选参数，默认设置为true。实际上，与正常控制台不同，文本不会向下滚动，因此将最新信息放置在顶部可以保证它始终可供开发者使用。'
- en: '**TextScale**: This is the scale of the text, expressed as an ***FVector2D***.
    This is useful when the text needs to be bigger or smaller than others for visualization
    reasons. This is an optional parameter, which is set to be the unitary vector
    (no scaling) by default.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TextScale**: 这是文本的缩放比例，以**FVector2D**表示。当文本需要比其他文本更大或更小时，这对于可视化很有用。这是一个可选参数，默认设置为单元向量（无缩放）。'
- en: 'Now that we''ve covered these parameters, its usage is pretty straightforward.
    You can use the following snippet to quickly print some text:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了这些参数，其用法相当直接。您可以使用以下代码片段快速打印一些文本：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In case you want to check if a **Key** already exists before printing your
    message (to avoid overriding already displayed information), you can use the `OnScreenDebugMessageExists()`
    function, which takes the Key as a parameter (only *uint64*, since there''s no
    wrapper for *int32*) and returns a bool. It will be true if already it exists.
    Here is an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在打印消息之前想检查**键**是否已经存在（以避免覆盖已显示的信息），可以使用`OnScreenDebugMessageExists()`函数，该函数接受键作为参数（仅*uint64*，因为没有为*int32*提供包装器）并返回一个布尔值。如果它已经存在，则为真。以下是一个示例：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you wish to completely clear the screen of any displayed message, you can
    do so by using the `ClearOnScreenDebugMessages()` function – no parameters, no
    return value. Here is an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望完全清除屏幕上的任何显示消息，可以使用`ClearOnScreenDebugMessages()`函数——没有参数，没有返回值。以下是一个示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In case you want to temporarily suppress any on-screen messages, you can do
    so by changing the `bEnableOnScreenDebugMessages` boolean. The advantage of this
    variable is that changing its value in real-time allows you to suspend debugging
    on-screen *on-the-fly*. Its usage is very simple:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想暂时抑制任何屏幕上的消息，可以通过更改`bEnableOnScreenDebugMessages`布尔值来实现。这个变量的优点是实时更改其值允许您在飞行中暂停屏幕调试。其用法非常简单：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To test this code, we can create a new C++ class of type `Actor`, as shown
    in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此代码，我们可以创建一个新的C++类，类型为`Actor`，如下面的截图所示：
- en: '![](img/612d3017-4d97-4102-afde-991c80dbd13f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/612d3017-4d97-4102-afde-991c80dbd13f.png)'
- en: 'Then, we can rename it as ***LoggingActor***, and place it within a folder
    named "***Chapter11***":'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其重命名为**LoggingActor**，并将其放置在名为**Chapter11**的文件夹中：
- en: '![](img/6f75f663-ccd9-4333-8952-8f0a91c6a500.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f75f663-ccd9-4333-8952-8f0a91c6a500.png)'
- en: 'Next, we need to add the `BeginPlay()` function override in the header (`.h`)
    file if it is not already present (depending on which version of the Engine you
    are using, or if you have created the class in Visual Studio). In case you don''t
    have it, this is the code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在头文件（`.h`）中添加`BeginPlay()`函数覆盖，如果它尚未存在（取决于您使用的引擎版本，或者如果您在Visual Studio中创建了该类）。如果没有，这是代码：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, in the implementation (`.cpp`) file, we can write the function to log
    the message on the screen within the `BeginPlay()` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在实现文件（`.cpp`）中，我们可以在`BeginPlay()`函数中编写将消息记录在屏幕上的函数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile this code and place the actor in the level (remove the blueprint one,
    in case you already have that, or keep it, if you prefer).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码并将演员放置在级别中（如果已经存在蓝图，则移除它，或者如果您更喜欢，则保留它）。
- en: Keep in mind that we didn't create a Scene Component for this Actor, since we
    were focusing on the logic. As a result, you are able to place it in the level,
    but not in a specific location. For our purposes, this is fine, but remember that
    when you create a C++ Actor, you might want a Scene Component (at least), or some
    other component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们没有为这个 Actor 创建场景组件，因为我们专注于逻辑。因此，你能够将其放置在关卡中，但不能放置在特定位置。就我们的目的而言，这没问题，但请记住，当你创建
    C++ Actor 时，你可能需要一个场景组件（至少），或者一些其他组件。
- en: 'Once you hit play, you will be able to see the following message:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你按下播放，你将能够看到以下消息：
- en: '![](img/137f8632-e0cc-4ceb-bd56-d6ca87db1124.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/137f8632-e0cc-4ceb-bd56-d6ca87db1124.png)'
- en: Console Logging in C++
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 控制台日志
- en: When it comes to print on the console using C++, the possibilities are much
    vaster than Blueprint. In fact, logging in Unreal is a complex beast that does
    many things.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用 C++ 在控制台打印时，可能性比蓝图要广泛得多。事实上，在 Unreal 中，日志记录是一个复杂的野兽，可以做很多事情。
- en: 'If you are searching just for a quick shortcut to print something into the
    console using C++, you can just use the following line of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想快速地在控制台打印一些内容使用 C++，你只需使用以下代码行：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is how it appears in the Output Log (I have place this line of code in
    the `LoggingActor`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在输出日志中的显示方式（我已经将此代码行放置在 `LoggingActor` 中）：
- en: '![](img/ee6dd748-1a59-46bf-864c-72a54c2f8351.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee6dd748-1a59-46bf-864c-72a54c2f8351.png)'
- en: However, if you want to learn about the potential of the *Unreal Logging system*,
    than keep reading.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想了解 *Unreal 日志系统* 的潜力，那么请继续阅读。
- en: A good logging system doesn't just display information – it needs to display
    the right information.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的日志系统不仅仅显示信息——它需要显示正确的信息。
- en: 'So, to get started and look at serious logging in Unreal, we need to understand
    two concepts: ***Log Category*** and ***Log Verbosity***:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要开始了解 Unreal 的严肃日志记录，我们需要了解两个概念：***日志类别*** 和 ***日志详细程度***：
- en: '**Log Category**: Log Categories are like labels that are given to the debug
    messages: they classify the kind of information that these messages convey into
    a category. For instance, you can have a category for AI, another for UI, and
    a third for Gameplay. As a result, when a message appears on the console, it is
    possible to know which category the message belongs to.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志类别**：日志类别就像标签，用于给调试消息分类：它们将这些消息传达的信息分类到不同的类别中。例如，你可以有一个 AI 类别，另一个 UI 类别，还有一个游戏玩法类别。因此，当消息出现在控制台时，可以知道该消息属于哪个类别。'
- en: However, the usefulness of category doesn't stop here. Imagine that you are
    debugging your AI, but when you play the game, you are flooded with Gameplay debugging
    messages that your teammate (or you, in another time-slice) is using for testing.
    In this case, it would be nice to have only your debug messages. If all the messages
    are in different Log Categories, it is possible to filter them. As a result, you
    can completely suppress debug messages that are coming from a specific Log Category.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，类别的有用性并不仅限于此。想象一下，你正在调试你的 AI，但当你玩游戏时，你会被你的队友（或你，在另一个时间切片）用于测试的游戏玩法调试消息淹没。在这种情况下，只看到你的调试消息会很好。如果所有消息都在不同的日志类别中，你可以过滤它们。因此，你可以完全抑制来自特定日志类别的调试消息。
- en: It is possible to go a step further with ***Log Verbosity***.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 ***日志详细程度*** 可以更进一步。
- en: '**Log Verbosity**: Log Verbosity is another label that''s given to the debug
    message that indicates how "*verbose*" the message is. In other words, how detailed
    the debug message is.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志详细程度**：日志详细程度是另一个标签，用于指示调试消息的 "*详细程度*"。换句话说，调试消息的详细程度。'
- en: For example, a message saying "*Error occurred in the AI Controller*" and another
    saying "*Error occurred in the AI controller when executing the AttackPlayer Task
    in the Behavior Tree*" convey the same error, but the second is more detailed.
    A Gameplay programmer might need to be aware that there is an error in the AI
    controller, so if the game doesn't behave as it should, it might not due to his/her
    code, but rather because of an error in the AI programming. The AI programmer,
    instead, while trying to fix what might have caused the error, needs to know more
    details regarding the error.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，一条显示 "*AI 控制器发生错误*" 的消息和另一条显示 "*在行为树中执行 AttackPlayer 任务时 AI 控制器发生错误*" 的消息传达了相同的错误，但后者更为详细。游戏玩法程序员可能需要意识到
    AI 控制器中存在错误，所以如果游戏表现不符合预期，可能并不是由于他的/她的代码，而是由于 AI 编程中的错误。相反，AI 程序员在尝试修复可能引起错误的问题时，需要了解更多关于错误的具体细节。
- en: There are seven ordered verbosity levels for logging. Once a verbosity level
    is selected, then every verbosity level equal or less than the selected one will
    be displayed/logged into files.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于日志记录，有七个有序的详细程度级别。一旦选择了详细程度级别，那么所有等于或低于所选详细程度的详细程度级别都将显示/记录到文件中。
- en: 'These are the different verbosity levels that are available in Unreal. They
    are ordered from least verbose to the most:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在 Unreal 中可用的不同详细程度。它们按从最不详细到最详细的顺序排列：
- en: '**Fatal**: This verbosity level is always printed both to the console and into
    log files, and it always crashes the system, even if logging is disabled. This
    means that every time you use this level of logging, it will crash your game/application.
    You may want to use this in very rare and special cases in which if the runtime
    execution reaches a "fatal" no-returning point, then it crashes the game by giving
    some useful information on how to avoid it in the future.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fatal**：这种详细程度总是会在控制台和日志文件中打印，并且它总是会崩溃系统，即使日志被禁用。这意味着每次你使用这个级别的日志时，它都会让你的游戏/应用程序崩溃。你可能只想在非常罕见和特殊的情况下使用它，如果运行时执行达到一个“致命”的无法返回的点，那么它将通过提供一些有用的信息来避免未来再次发生崩溃。'
- en: '**Error**: This verbosity level is printed both into the console and into log
    files. They appear in red by default.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Error**：这种详细程度既会在控制台打印，也会在日志文件中打印。它们默认以红色显示。'
- en: '**Warning**: This verbosity level is printed both into the console and into
    log files. They appear in yellow by default.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Warning**：这种详细程度既会在控制台打印，也会在日志文件中打印。它们默认以黄色显示。'
- en: '**Display**: This verbosity level is printed both into the console and into
    log files.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Display**：这种详细程度既会在控制台打印，也会在日志文件中打印。'
- en: '**Log**: This verbosity level is printed only into log files, not into the
    console. However, they can still be viewed in the Editor inside the Output Log
    Window. This is also the most common level to use, since it doesn''t spam the
    console, and you receive all the information in the Output Log Window.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Log**：这种详细程度只会在日志文件中打印，不会在控制台打印。然而，它们仍然可以在编辑器中的输出日志窗口中查看。这也是最常用的级别，因为它不会垃圾邮件式地填充控制台，你可以在输出日志窗口中接收所有信息。'
- en: '**Verbose**: This verbosity level is printed only into log files, not in the
    console. This is usually used for detailed logging, especially when you print
    the values of many variables..'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Verbose**：这种详细程度只会在日志文件中打印，不会在控制台打印。这通常用于详细的日志记录，尤其是在打印许多变量的值时。'
- en: '**VeryVerbose**: This verbosity level is printed only into log files, not in
    the console. This is the most detailed log level, and it is usually used for very
    detailed messages, giving the full view of the situation (e.g. every single value
    of each variable involved in the process). These kind of logs are so detailed
    that they are almost spam in the output log, and so they are used when such a
    level of detail is really needed.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VeryVerbose**：这种详细程度只会在日志文件中打印，不会在控制台打印。这是最详细的日志级别，通常用于非常详细的日志消息，提供对情况的全面了解（例如，每个变量在过程中的每个值）。这类日志非常详细，几乎在输出日志中像垃圾邮件一样，因此只在真正需要这种详细程度时使用。'
- en: With the power of the Unreal Logging system, it is possible to decide on the
    level of verbosity for each logging category. In this way, if you are an AI programmer,
    you can set your AI logging to *VeryVerbose*, whereas the other categories (e.g.
    Gameplay-related stuff) is just set to a *Log* level.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Unreal 日志系统的力量，你可以为每个日志分类决定详细程度级别。这样，如果你是一个 AI 程序员，你可以将你的 AI 日志设置为 *VeryVerbose*，而其他分类（例如，与游戏玩法相关的内容）则只设置为
    *Log* 级别。
- en: Creating a Custom Logging Category (C++)
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义日志分类（C++）
- en: So far, we have seen how a log category that's been set to a certain verbosity
    level is able to log the right amount of information regarding a system. However,
    the true power comes when you are able to create your own Logging Category. The
    process is quite straightforward, since it relies on the use of a couple of macros.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一个被设置为特定详细程度的日志分类是如何能够记录关于系统的正确数量的信息的。然而，真正的力量在于你能够创建自己的日志分类。这个过程相当直接，因为它依赖于几个宏的使用。
- en: The best spot to define your category is in the `*YOUR_PROJECT_NAME.h*` and
    `*YOUR_PROJECT_NAME.cpp*` files, which in my case is in the `UnrealAIBook.h` and
    `UnrealAIBook.cpp` files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义你分类的最佳位置是在 `*YOUR_PROJECT_NAME.h*` 和 `*YOUR_PROJECT_NAME.cpp*` 文件中，在我的情况下是在
    `UnrealAIBook.h` 和 `UnrealAIBook.cpp` 文件中。
- en: 'In the header (`.h`) file, we need to declare the following macro:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件（`.h`）中，我们需要声明以下宏：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These are the parameters we need to insert:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要插入的参数：
- en: '**CategoryName**: This is the name of the new category that you want to define.
    Try to provide a meaningful name, which is not too long, but descriptive enough.
    The choice depends on your game/application as well. In fact, if you have just
    a simple AI system, you can log everything into the same *LogAI* category. However,
    if you have a very large and complex AI system that it is composed of many subsystems,
    then dividing into different log categories might be a winning choice.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别名称**: 这是你要定义的新类别的名称。尽量提供一个有意义的名称，不要太长，但要足够描述性。选择取决于你的游戏/应用程序。实际上，如果你只有一个简单的AI系统，你可以将所有日志记录到同一个*LogAI*类别中。然而，如果你有一个非常大且复杂的AI系统，它由许多子系统组成，那么将它们分为不同的日志类别可能是一个明智的选择。'
- en: '**DefaultVerbosity**: This is the default verbosity level that''s used if another
    part of it is not specified (either in a configuration file, or directly from
    the command line). Everything that it is above this level will not be displayed.
    For example, if you set this level to be just "*Log*", then neither Verbose or
    *VeryVerbose* will be logged.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认详细程度**: 这是如果没有指定其他部分（无论是在配置文件中还是在命令行中）时使用的默认详细程度。所有高于这个级别的信息都不会被显示。例如，如果你将这个级别设置为仅仅是"*Log*"，那么详细或*非常详细*的日志都不会被记录。'
- en: '**CompileTimeVerbosity**: This is the maximum verbosity level at which the
    compiler will include the log instruction. Anything that is defined more verbose
    than this level will not be compiled, which means that it will not be available,
    not even if the verbosity level is changed. For example, once you have finished
    working on a system, you probably don''t want to keep many log instructions that
    are *VeryVerbose* inside a *Tick* function in your code base. By stripping them
    away from the compiled code, you can ensure that those instructions will never
    impact your performance, especially if the system is consolidated and those are
    logs that will never be read. Another use might be in shipping games, in which
    you don''t want a certain level of verbosity for specific log categories to be
    present in the game.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时详细程度**: 这是编译器将包含日志指令的最大详细程度。任何比这个级别更详细的定义都不会被编译，这意味着它将不可用，即使详细程度被更改也是如此。例如，一旦你完成对一个系统的操作，你可能不想在代码库中的*Tick*函数内保留许多*非常详细*的日志指令。通过从编译后的代码中移除它们，你可以确保这些指令永远不会影响你的性能，特别是如果系统已经整合并且这些日志永远不会被读取。另一个用途可能是在发布游戏时，你不想在游戏中存在特定日志类别的某个详细程度。'
- en: 'For example''s sake, we can add this to our project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例，我们可以将以下内容添加到我们的项目中：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `.cpp` file, we need to have the following macro instead:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中，我们需要有以下宏：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The only parameter that you need to insert is the name of the category, and
    it must match the name you inserted in the header file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要插入的唯一参数是类别的名称，并且它必须与你在头文件中插入的名称匹配。
- en: 'So, in our case, we can use the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，我们可以使用以下内容：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you have done this, you are ready to use your brand new logging category
    so that you can add your C++ code in the following way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你就可以使用你全新的日志类别了，这样你就可以以下述方式添加你的C++代码：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you get a compile error, it might be due to the fact that the C++ code in
    which you place the log doesn't have access to the definition of the category.
    For instance, in my case, I had to include my general project(/module) header
    file for it to work; I added `#include "UnrealAIBook.h"`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到编译错误，可能是因为你放置日志的C++代码没有访问类别定义的权限。例如，在我的情况下，我必须包含我的通用项目(/模块)头文件才能使其工作；我添加了`#include
    "UnrealAIBook.h"`。
- en: 'This is how it appears in the *Output Log*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在*输出日志*中的显示方式：
- en: '![](img/7096589b-ca87-4d3d-a99e-ca2921722863.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7096589b-ca87-4d3d-a99e-ca2921722863.png)'
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how to log both in C++ and Blueprint. This allows
    us to easily spot portions of our code that are wrong, or variables that contain
    wrong values.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在C++和蓝图中进行日志记录。这使我们能够轻松地发现代码中错误的部分，或者包含错误值的变量。
- en: It was particularly useful to learn about Custom Categories, since this is a
    very powerful part of the logging system within Unreal. In fact, it allows us
    to create a specific category for each part of our game, and increase or decrease
    the quantity of messages (based on importance) for each category, potentially
    even at runtime. Furthermore, it allows us to easily strip away debugging code
    once we need to ship the game, which we can do by simply changing the values of
    the `DECLARE_LOG_CATEGORY_EXTERN()` macro.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 了解自定义分类特别有用，因为这是 Unreal 中日志系统的一个非常强大的部分。实际上，它允许我们为游戏中的每个部分创建一个特定的分类，并根据重要性增加或减少每个分类的消息数量（甚至可以在运行时进行），此外，它还允许我们在需要发布游戏时轻松移除调试代码，这可以通过简单地更改
    `DECLARE_LOG_CATEGORY_EXTERN()` 宏的值来实现。
- en: In the next chapter, we will explore more specific tools for performing debugging
    on the AI tools we have encountered during this book, from the *Navigation System*
    to *EQS*. Mastering these is important when it comes to becoming an AI Programmer
    in Unreal, and they will be very useful when you create complex AI systems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在本书中遇到的 AI 工具进行调试的更多具体工具，从 *导航系统* 到 *EQS*。掌握这些工具对于成为 Unreal 的 AI
    程序员至关重要，并且当您创建复杂的 AI 系统时，它们将非常有用。
