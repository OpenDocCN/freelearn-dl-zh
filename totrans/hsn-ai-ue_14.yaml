- en: Debugging Methods for AI - Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at a series of methods that we can use to debug
    our AI systems. Of course, they can be used in general, and not only for AI. However,
    since AI can be tricky sometimes, mastering how to do proper logging in Unreal
    can be a time-saver when you need to find and fix a bug related to AI. In fact,
    often, due to variables that haven't been properly set, maybe with wrong values,
    we end up not executing a portion of code, or make a miscalculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Console Logging and on-screen messages in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On-screen messages in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console Logging in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Custom Logging Category (C++)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By mastering the art of logging, you will be able to easily keep track of your
    values and which part of the code you are executing. Moreover, creating a Custom
    Logging Category allows you to define different levels of logging, and change
    the quantity of logging you want to see (even at runtime) based on what you are
    debugging. Furthermore, it is possible to easily strip away all the debugging
    code (at compilation time) by changing a variable, so that your shipped game can
    run as smoothly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With this being said, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Basic Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters we already looked at how to make logs. For example,
    in [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml), *Agent Awareness*,
    we saw how to print the information we needed both on the Console and on-screen.
    However, in this section, we will explore those concepts in more detail, and learn
    how to master logging within Unreal.
  prefs: []
  type: TYPE_NORMAL
- en: '**On-Screen messages**: Often, during the Debugging phase, you and your team
    will need to be aware of certain variable values while playing the game. Thus,
    the easiest way to continuously test the value of the variable is by printing
    its value on the screen. We can achieve this in different ways, both in Blueprint
    and C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Console Messages**: These are printed on the Console (actually, there is
    more than one) and into Log files (so that even when the game is not running,
    you can analyze the log files to understand what happened (or what went wrong)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in Blueprint we have a unique function to print both on-screen and into
    the Console, in C++, we have separate functions. In fact, the Logging System in
    Unreal is very powerful, and C++ unlocks its full power.
  prefs: []
  type: TYPE_NORMAL
- en: Console Logging and on-screen messages in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to Blueprint, we have simple and easy debug nodes that we can
    use. The most common one is Print String, but its counterpart, Print Text, also
    exists. The following is a screenshot showing Print String and Print Text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca5d2f4b-756a-4291-b15d-4b3ce18a6d9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Both of them are marked as ***Development Only***, which means that they will
    not working in shipping builds.
  prefs: []
  type: TYPE_NORMAL
- en: Their simple usage is straightforward. You just need to plug a *String* (or
    *Text*) into the homonym variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we expand them and look at their more advanced options, we can
    find a full list of parameters, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaaf0817-d0e3-40eb-a535-b7d88326aed9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**String / Text**: This is the String or Text that will be displayed on-screen.
    Thus, any information that needs to be displayed has to be within this String
    or Text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Print to Screen**: If true, the node will actually print the message on-screen
    (by default, it is true).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Print to Console**: If true, the node will print the message in the Console
    as well (by default, it is true).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text Color**: This is the color in which the String/Text will be displayed
    (by default, it is a light blue). This is useful when you need to visually distinguish
    different information. Colors help a lot in these kinds of situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duration**: This is how long the message will be displayed on the screen.
    Make sure that you have enough time to read/assimilate the information. Of course,
    longer messages need a longer duration to be read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how they should appear in-game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cf50498-61df-4eaa-93c3-a1498dbfcf67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same log also appears in the console if "***Print to Console***" is set
    to true, and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/013b17b6-e8e5-4069-af67-ffceaa419596.png)'
  prefs: []
  type: TYPE_IMG
- en: On-screen messages in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, we have an handy function to print messages on-screen. We do this within
    the `UEngine` class. The easiest way to have access to it is by using the GEngine
    variable, which is a global variable that''s available everywhere and contains
    the instance of the *UEngine* class. Keep in mind that this variable might be
    empty (e.g. the game is running on a shipping build). Thus, it is very good practice
    to check the variable before you use it, like in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `if` statement, we can use the **GEngine** variable to call the
    `AddOnScreenDebugMessage()` function. As you would have guessed from the name,
    it prints a message on-screen. This is its full declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key**: This is a unique key that''s given to a "slot" on the screen. When
    a new message needs to be written, but there is already one with the same key
    displayed, then the new one will replace the old one. This is particularly useful
    when you have a variable that updates often and you don''t want to flood the screen
    with a lot of debug messages, especially when only the last one is relevant. Remember
    to use the same key when you print the same information, just updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the definition, the Key parameter is a **uint64**. However, there is wrapper
    that works with **int32**. Don't worry if you define your keys as **int32**, as
    they will work anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '**TimeToDisplay**: This is the duration, expressed in seconds, of how long
    the message needs to remain displayed on-screen. Make sure that you have enough
    time to read/assimilate the information. Of course, longer messages need longer
    durations to be read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DisplayColor**: This is the color in which the debug message will be displayed.
    This is useful when you need to visually distinguish different information. Colors
    help a lot in these kinds of situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DebugMessage**: This is the string that will be displayed on-screen. Thus,
    any information that needs to be displayed has to be packed into an ***FString***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bNewerOnTop**: iThis s a boolean that it is used only when the key is equal
    to **INDEX_NONE** (which means a value of -1). If true, every new message will
    be displayed on top of the others. Otherwise, every new message will be placed
    below the others (like in a normal console). This is an option parameter, which
    is set to true by default. In fact, unlike a normal console, the text doesn''t
    scroll down, so placing the most recent information on top guarantees that it
    is always available to developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TextScale**: This is the scale of the text, expressed as an ***FVector2D***.
    This is useful when the text needs to be bigger or smaller than others for visualization
    reasons. This is an optional parameter, which is set to be the unitary vector
    (no scaling) by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve covered these parameters, its usage is pretty straightforward.
    You can use the following snippet to quickly print some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you want to check if a **Key** already exists before printing your
    message (to avoid overriding already displayed information), you can use the `OnScreenDebugMessageExists()`
    function, which takes the Key as a parameter (only *uint64*, since there''s no
    wrapper for *int32*) and returns a bool. It will be true if already it exists.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to completely clear the screen of any displayed message, you can
    do so by using the `ClearOnScreenDebugMessages()` function – no parameters, no
    return value. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you want to temporarily suppress any on-screen messages, you can do
    so by changing the `bEnableOnScreenDebugMessages` boolean. The advantage of this
    variable is that changing its value in real-time allows you to suspend debugging
    on-screen *on-the-fly*. Its usage is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this code, we can create a new C++ class of type `Actor`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/612d3017-4d97-4102-afde-991c80dbd13f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can rename it as ***LoggingActor***, and place it within a folder
    named "***Chapter11***":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f75f663-ccd9-4333-8952-8f0a91c6a500.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to add the `BeginPlay()` function override in the header (`.h`)
    file if it is not already present (depending on which version of the Engine you
    are using, or if you have created the class in Visual Studio). In case you don''t
    have it, this is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the implementation (`.cpp`) file, we can write the function to log
    the message on the screen within the `BeginPlay()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compile this code and place the actor in the level (remove the blueprint one,
    in case you already have that, or keep it, if you prefer).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we didn't create a Scene Component for this Actor, since we
    were focusing on the logic. As a result, you are able to place it in the level,
    but not in a specific location. For our purposes, this is fine, but remember that
    when you create a C++ Actor, you might want a Scene Component (at least), or some
    other component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you hit play, you will be able to see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/137f8632-e0cc-4ceb-bd56-d6ca87db1124.png)'
  prefs: []
  type: TYPE_IMG
- en: Console Logging in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to print on the console using C++, the possibilities are much
    vaster than Blueprint. In fact, logging in Unreal is a complex beast that does
    many things.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are searching just for a quick shortcut to print something into the
    console using C++, you can just use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it appears in the Output Log (I have place this line of code in
    the `LoggingActor`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee6dd748-1a59-46bf-864c-72a54c2f8351.png)'
  prefs: []
  type: TYPE_IMG
- en: However, if you want to learn about the potential of the *Unreal Logging system*,
    than keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: A good logging system doesn't just display information – it needs to display
    the right information.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get started and look at serious logging in Unreal, we need to understand
    two concepts: ***Log Category*** and ***Log Verbosity***:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Log Category**: Log Categories are like labels that are given to the debug
    messages: they classify the kind of information that these messages convey into
    a category. For instance, you can have a category for AI, another for UI, and
    a third for Gameplay. As a result, when a message appears on the console, it is
    possible to know which category the message belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the usefulness of category doesn't stop here. Imagine that you are
    debugging your AI, but when you play the game, you are flooded with Gameplay debugging
    messages that your teammate (or you, in another time-slice) is using for testing.
    In this case, it would be nice to have only your debug messages. If all the messages
    are in different Log Categories, it is possible to filter them. As a result, you
    can completely suppress debug messages that are coming from a specific Log Category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is possible to go a step further with ***Log Verbosity***.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Log Verbosity**: Log Verbosity is another label that''s given to the debug
    message that indicates how "*verbose*" the message is. In other words, how detailed
    the debug message is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, a message saying "*Error occurred in the AI Controller*" and another
    saying "*Error occurred in the AI controller when executing the AttackPlayer Task
    in the Behavior Tree*" convey the same error, but the second is more detailed.
    A Gameplay programmer might need to be aware that there is an error in the AI
    controller, so if the game doesn't behave as it should, it might not due to his/her
    code, but rather because of an error in the AI programming. The AI programmer,
    instead, while trying to fix what might have caused the error, needs to know more
    details regarding the error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are seven ordered verbosity levels for logging. Once a verbosity level
    is selected, then every verbosity level equal or less than the selected one will
    be displayed/logged into files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These are the different verbosity levels that are available in Unreal. They
    are ordered from least verbose to the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fatal**: This verbosity level is always printed both to the console and into
    log files, and it always crashes the system, even if logging is disabled. This
    means that every time you use this level of logging, it will crash your game/application.
    You may want to use this in very rare and special cases in which if the runtime
    execution reaches a "fatal" no-returning point, then it crashes the game by giving
    some useful information on how to avoid it in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error**: This verbosity level is printed both into the console and into log
    files. They appear in red by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning**: This verbosity level is printed both into the console and into
    log files. They appear in yellow by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display**: This verbosity level is printed both into the console and into
    log files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log**: This verbosity level is printed only into log files, not into the
    console. However, they can still be viewed in the Editor inside the Output Log
    Window. This is also the most common level to use, since it doesn''t spam the
    console, and you receive all the information in the Output Log Window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verbose**: This verbosity level is printed only into log files, not in the
    console. This is usually used for detailed logging, especially when you print
    the values of many variables..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VeryVerbose**: This verbosity level is printed only into log files, not in
    the console. This is the most detailed log level, and it is usually used for very
    detailed messages, giving the full view of the situation (e.g. every single value
    of each variable involved in the process). These kind of logs are so detailed
    that they are almost spam in the output log, and so they are used when such a
    level of detail is really needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the power of the Unreal Logging system, it is possible to decide on the
    level of verbosity for each logging category. In this way, if you are an AI programmer,
    you can set your AI logging to *VeryVerbose*, whereas the other categories (e.g.
    Gameplay-related stuff) is just set to a *Log* level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Custom Logging Category (C++)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how a log category that's been set to a certain verbosity
    level is able to log the right amount of information regarding a system. However,
    the true power comes when you are able to create your own Logging Category. The
    process is quite straightforward, since it relies on the use of a couple of macros.
  prefs: []
  type: TYPE_NORMAL
- en: The best spot to define your category is in the `*YOUR_PROJECT_NAME.h*` and
    `*YOUR_PROJECT_NAME.cpp*` files, which in my case is in the `UnrealAIBook.h` and
    `UnrealAIBook.cpp` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header (`.h`) file, we need to declare the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the parameters we need to insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CategoryName**: This is the name of the new category that you want to define.
    Try to provide a meaningful name, which is not too long, but descriptive enough.
    The choice depends on your game/application as well. In fact, if you have just
    a simple AI system, you can log everything into the same *LogAI* category. However,
    if you have a very large and complex AI system that it is composed of many subsystems,
    then dividing into different log categories might be a winning choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DefaultVerbosity**: This is the default verbosity level that''s used if another
    part of it is not specified (either in a configuration file, or directly from
    the command line). Everything that it is above this level will not be displayed.
    For example, if you set this level to be just "*Log*", then neither Verbose or
    *VeryVerbose* will be logged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CompileTimeVerbosity**: This is the maximum verbosity level at which the
    compiler will include the log instruction. Anything that is defined more verbose
    than this level will not be compiled, which means that it will not be available,
    not even if the verbosity level is changed. For example, once you have finished
    working on a system, you probably don''t want to keep many log instructions that
    are *VeryVerbose* inside a *Tick* function in your code base. By stripping them
    away from the compiled code, you can ensure that those instructions will never
    impact your performance, especially if the system is consolidated and those are
    logs that will never be read. Another use might be in shipping games, in which
    you don''t want a certain level of verbosity for specific log categories to be
    present in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example''s sake, we can add this to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `.cpp` file, we need to have the following macro instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The only parameter that you need to insert is the name of the category, and
    it must match the name you inserted in the header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our case, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have done this, you are ready to use your brand new logging category
    so that you can add your C++ code in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you get a compile error, it might be due to the fact that the C++ code in
    which you place the log doesn't have access to the definition of the category.
    For instance, in my case, I had to include my general project(/module) header
    file for it to work; I added `#include "UnrealAIBook.h"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it appears in the *Output Log*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7096589b-ca87-4d3d-a99e-ca2921722863.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to log both in C++ and Blueprint. This allows
    us to easily spot portions of our code that are wrong, or variables that contain
    wrong values.
  prefs: []
  type: TYPE_NORMAL
- en: It was particularly useful to learn about Custom Categories, since this is a
    very powerful part of the logging system within Unreal. In fact, it allows us
    to create a specific category for each part of our game, and increase or decrease
    the quantity of messages (based on importance) for each category, potentially
    even at runtime. Furthermore, it allows us to easily strip away debugging code
    once we need to ship the game, which we can do by simply changing the values of
    the `DECLARE_LOG_CATEGORY_EXTERN()` macro.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore more specific tools for performing debugging
    on the AI tools we have encountered during this book, from the *Navigation System*
    to *EQS*. Mastering these is important when it comes to becoming an AI Programmer
    in Unreal, and they will be very useful when you create complex AI systems.
  prefs: []
  type: TYPE_NORMAL
