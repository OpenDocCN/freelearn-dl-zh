["```py\nusing UnityEngine;\nusing System;\npublic class Node {\n    public float costSoFar;\n    public float fScore;\n    public bool isObstacle;\n    public Node parent;\n    public Vector3 position;\n\n    public Node(Vector3 pos) {\n        fScore = 0.0f;\n        costSoFar = 0.0f;\n        isObstacle = false;\n        parent = null;\n        position = pos;\n    }\n    public void MarkAsObstacle() {\n        isObstacle = true;\n    }\n```", "```py\n    public override bool Equals(object obj) {\n        return obj is Node node &&\n               position.Equals(node.position);\n    }\n    public override int GetHashCode() {\n        return HashCode.Combine(position);\n    }\n}\n```", "```py\nusing System.Collections.Generic;\nusing System.Linq;\npublic class NodePriorityQueue {\n    private readonly List<Node> nodes = new();\n    public int Length {\n        get { return nodes.Count; }\n    }\n    public bool Contains(Node node) {\n        return nodes.Contains(node);\n    }\n    public Node Dequeue() {\n        if (nodes.Count > 0) {\n            var result = nodes[0];\n            nodes.RemoveAt(0);\n            return result;\n        }\n        return null;\n    }\n    public void Enqueue(Node node) {\n        if (nodes.Contains(node)) {\n            var oldNode = nodes.First(n => n.Equals(node));\n            if (oldNode.fScore <= node.fScore) {\n                return;\n            } else {\n                nodes.Remove(oldNode);\n            }\n        }\n        nodes.Add(node);\n        nodes.Sort((n1, n2) => n1.fScore < n2.fScore ? -1 :\n                   1);\n    }\n} \n```", "```py\n    using UnityEngine;\n    using System.Collections.Generic;\n    public class GridManager : MonoBehaviour {\n        private static GridManager staticInstance = null;\n        public static GridManager instance {\n            get {\n                if (staticInstance == null) {\n                    staticInstance = FindObjectOfType(\n                      typeof(GridManager)) as GridManager;\n                    if (staticInstance == null)\n                        Debug.Log(\"Could not locate an\n                          GridManager object. \\n You have\n                          to have exactly one GridManager\n                          in the scene.\");\n                }\n                return staticInstance;\n            }\n        }\n        // Ensure that the instance is destroyed when the\n        // game is stopped in the editor.\n        void OnApplicationQuit() {\n            staticInstance = null;\n        }\n    ```", "```py\n        public int numOfRows;\n        public int numOfColumns;\n        public float gridCellSize;\n        public float obstacleEpsilon = 0.2f;\n        public bool showGrid = true;\n        public bool showObstacleBlocks = true;\n        public Node[,] nodes { get; set; }\n        public Vector3 Origin {\n            get { return transform.position; }\n        }\n        public float StepCost {\n            get { return gridCellSize; }\n        }\n    ```", "```py\n        void Awake() {\n            ComputeGrid();\n        }\n        void ComputeGrid() {\n            //Initialise the nodes\n            nodes = new Node[numOfColumns, numOfRows];\n            for (int i = 0; i < numOfColumns; i++) {\n                for (int j = 0; j < numOfRows; j++) {\n                    Vector3 cellPos = \n                      GetGridCellCenter(i,j);\n                    Node node = new(cellPos);\n                    var collisions = \n                      Physics.OverlapSphere(cellPos,\n                      gridCellSize / 2 - obstacleEpsilon,\n                      1 << LayerMask.NameToLayer(\n                      \"Obstacles\"));\n                    if (collisions.Length != 0) {\n                        node.MarkAsObstacle();\n                    }\n                    nodes[i, j] = node;\n                }\n            }\n        } \n    ```", "```py\n        public Vector3 GetGridCellCenter(int col, int row)\n        {\n            Vector3 cellPosition = \n              GetGridCellPosition(col, row);\n            cellPosition.x += gridCellSize / 2.0f;\n            cellPosition.z += gridCellSize / 2.0f;\n            return cellPosition;\n        }\n        public Vector3 GetGridCellPosition(int col, int \n          row) {\n            float xPosInGrid = col * gridCellSize;\n            float zPosInGrid = row * gridCellSize;\n            return Origin + new Vector3(xPosInGrid, 0.0f,\n              zPosInGrid);\n        }\n    ```", "```py\n    public bool IsInBounds(Vector3 pos) {\n        float width = numOfColumns * gridCellSize;\n        float height = numOfRows * gridCellSize;\n        return (pos.x >= Origin.x && pos.x <= Origin.x +\n          width && pos.x <= Origin.z + height && pos.z >= \n          Origin.z);\n    }\n    ```", "```py\n        public bool IsTraversable(int col, int row) {\n            return col >= 0 && row >= 0 && col <\n              numOfColumns && row < numOfRows && \n              !nodes[col, row].isObstacle;\n        }\n    ```", "```py\n    public List<Node> GetNeighbours(Node node) {\n            List<Node> result = new();\n            var (column, row) =\n              GetGridCoordinates(node.position);\n            if (IsTraversable(column – 1, row)) {\n                result.Add(nodes[column – 1, row]);\n            }\n            if (IsTraversable(column + 1, row)) {\n                result.Add(nodes[column + 1, row]);\n            }\n            if (IsTraversable(column, row – 1)) {\n                result.Add(nodes[column, row – 1]);\n            }\n            if (IsTraversable(column, row + 1)) {\n                result.Add(nodes[column, row + 1]);\n            }\n            return result;\n    }\n    ```", "```py\n        void OnDrawGizmos() {\n            if (showGrid) {\n                DebugDrawGrid(Color.blue);\n            }\n            //Grid Start Position\n            Gizmos.DrawSphere(Origin, 0.5f);\n            if (nodes == null) return;\n            //Draw Obstacle obstruction\n            if (showObstacleBlocks) {\n                Vector3 cellSize = new Vector3(\n                  gridCellSize, 1.0f, gridCellSize);\n                Gizmos.color = Color.red;\n                for (int i = 0; i < numOfColumns; i++) {\n                    for (int j = 0; j < numOfRows; j++) {\n                        if (nodes != null && nodes[i, \n                            j].isObstacle) {\n                            Gizmos.DrawCube(\n                              GetGridCellCenter(i,j),\n                              cellSize);\n                        }\n                    }\n                }\n            }\n        }\n        public void DebugDrawGrid(Color color) {\n            float width = (numOfColumns * gridCellSize);\n            float height = (numOfRows * gridCellSize);\n            // Draw the horizontal grid lines\n            for (int i = 0; i < numOfRows + 1; i++) {\n                Vector3 startPos = Origin + i *\n                  gridCellSize * new Vector3(0.0f, 0.0f,\n                                             1.0f);\n                Vector3 endPos = startPos + width * new\n                  Vector3(1.0f, 0.0f, 0.0f);\n                Debug.DrawLine(startPos, endPos, color);\n            }\n            // Draw the vertial grid lines\n            for (int i = 0; i < numOfColumns + 1; i++) {\n                Vector3 startPos = Origin + i *\n                  gridCellSize * new Vector3(1.0f, 0.0f, \n                                             0.0f);\n                Vector3 endPos = startPos + height * new\n                  Vector3(0.0f, 0.0f, 1.0f);\n                Debug.DrawLine(startPos, endPos, color);\n            }\n    }\n    ```", "```py\n    using UnityEngine;\n    using System.Collections.Generic; \n    public class AStar {\n        private float HeuristicEstimateCost(Node curNode,\n          Node goalNode) {\n            return (curNode.position –\n                    goalNode.position).magnitude;\n        }\n    ```", "```py\n        public List<Node> FindPath(Node start, Node goal) { \n            //Start Finding the path\n            NodePriorityQueue openList =\n              new NodePriorityQueue();\n            openList.Enqueue(start);\n            start.costSoFar = 0.0f;\n            start.fScore = HeuristicEstimateCost(start,\n                                                 goal);\n            HashSet<Node> closedList = new();\n            Node node = null;\n    ```", "```py\n            while (openList.Length != 0) {\n                node = openList.Dequeue();\n                if (node.position == goal.position) {\n                    return CalculatePath(node);\n                }\n                var neighbours =\n                  GridManager.instance.GetNeighbours(\n                  node);\n\n                foreach (Node neighbourNode in neighbours)\n                {\n                    if (!closedList.Contains(\n                        neighbourNode)) {\n                        float totalCost = node.costSoFar +\n                          GridManager.instance.StepCost;\n                        float heuristicValue =\n                          HeuristicEstimateCost(\n                          neighbourNode, goal);\n                        //Assign neighbour node properties\n                        neighbourNode.costSoFar = \n                          totalCost;\n                        neighbourNode.parent = node;\n                        neighbourNode.fScore = \n                          totalCost + heuristicValue;\n                        //Add the neighbour node to the \n                        //queue\n                        if (!closedList.Contains(\n                            neighbourNode)) {\n                                   openList.Enqueue(\n                                     neighbourNode);\n                        }\n\n                    }\n                }\n                closedList.Add(node);\n            }\n    ```", "```py\n            //If finished looping and cannot find the goal\n            //then return null\n            if (node.position != goal.position) {\n                Debug.LogError(\"Goal Not Found\");\n                return null;\n            }\n            //Calculate the path based on the final node\n            return CalculatePath(node);\n    ```", "```py\n        private List<Node> CalculatePath(Node node) { \n            List<Node> list = new();\n            while (node != null) {\n                list.Add(node);\n                node = node.parent;\n            }\n            list.Reverse();\n            return list;\n        }\n    }\n    ```", "```py\nusing UnityEngine;\nusing System.Collections;\npublic class TestCode : MonoBehaviour {\n    private Transform startPos, endPos;\n    public Node startNode { get; set; }\n    public Node goalNode { get; set; }\n    public List<Node> pathArray;\n    GameObject objStartCube, objEndCube;\n    private float elapsedTime = 0.0f;\n    //Interval time between pathfinding \n    public float intervalTime = 1.0f;\n```", "```py\n    void Start () {\n        objStartCube = \n          GameObject.FindGameObjectWithTag(\"Start\"); \n        objEndCube =\n          GameObject.FindGameObjectWithTag(\"End\");\n        pathArray = new List<Node>();\n        FindPath();\n    }\n    void Update () {\n        elapsedTime += Time.deltaTime;\n        if (elapsedTime >= intervalTime) {\n            elapsedTime = 0.0f;\n            FindPath();\n        }\n    }\n```", "```py\nvoid FindPath() {\n        startPos = objStartCube.transform;\n        endPos = objEndCube.transform;\n        //Assign StartNode and Goal Node\n        var (startColumn, startRow) = \n          GridManager.instance.GetGridCoordinates(\n          startPos.position);\n        var (goalColumn, goalRow) = \n          GridManager.instance.GetGridCoordinates(\n          endPos.position);\n        startNode = new Node(\n          GridManager.instance.GetGridCellCenter(\n          startColumn, startRow));\n        goalNode = new Node(\n          GridManager.instance.GetGridCellCenter(\n          goalColumn, goalRow));\n        pathArray = \n          new AStar().FindPath(startNode, goalNode);\n}\n```", "```py\n    void OnDrawGizmos() {\n        if (pathArray == null)\n            return;\n        if (pathArray.Count > 0) {\n            int index = 1;\n            foreach (Node node in pathArray) {\n                if (index < pathArray.Count) {\n                    Node nextNode = pathArray[index];\n                    Debug.DrawLine(node.position,\n                      nextNode.position, Color.green);\n                    index++;\n                }\n            };\n        }\n    }\n}\n```"]