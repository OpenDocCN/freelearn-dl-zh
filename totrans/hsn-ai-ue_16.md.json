["```py\n        //Code added for a Custom Category of Gameplay Debugger\n        if (Target.bBuildDeveloperTools || (Target.Configuration != UnrealTargetConfiguration.Shipping && Target.Configuration != UnrealTargetConfiguration.Test)) {\n            PrivateDependencyModuleNames.Add(\"GameplayDebugger\");\n            Definitions.Add(\"WITH_GAMEPLAY_DEBUGGER=1\");\n        } else {\n            Definitions.Add(\"WITH_GAMEPLAY_DEBUGGER=0\");\n        }\n```", "```py\n#if WITH_GAMEPLAY_DEBUGGER\n    //[CODE]\n#endif\n```", "```py\n#pragma once\n\n#include \"CoreMinimal.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER\n\n#include \"GameplayDebuggerCategory.h\"\n\n*//[REST OF THE CODE]*\n\n#endif\n```", "```py\nclass FGameplayDebuggerCategory_Locator : public FGameplayDebuggerCategory\n{\n *//[REST OF THE CODE]*\n};\n```", "```py\nprotected:\n  struct FRepData\n  {\n    FString ActorLocationString;\n\n    void Serialize(FArchive& Ar);\n  };\n\n  FRepData DataPack;\n```", "```py\npublic:\n\n  FGameplayDebuggerCategory_Locator();\n\n  static TSharedRef<FGameplayDebuggerCategory> MakeInstance();\n\n  virtual void CollectData(APlayerController* OwnerPC, AActor* DebugActor) override;\n\n  virtual void DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext) override;\n```", "```py\n#pragma once\n#include \"CoreMinimal.h\"\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"GameplayDebuggerCategory.h\"\nclass FGameplayDebuggerCategory_Locator : public FGameplayDebuggerCategory\n{\nprotected:\n  struct FRepData\n  {\n    FString ActorLocationString;\n    void Serialize(FArchive& Ar);\n  };\n  FRepData DataPack;\npublic:\n  FGameplayDebuggerCategory_Locator();\n  static TSharedRef<FGameplayDebuggerCategory> MakeInstance();\n  virtual void CollectData(APlayerController* OwnerPC, AActor* DebugActor) override;\n  virtual void DrawData(APlayerController* OwnerPC, FGameplayDebuggerCanvasContext& CanvasContext) override;\n};\n#endif\n```", "```py\n#include \"GameplayDebuggerCategory_Locator.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"GameFramework/Actor.h\"\n\n*//[REST OF THE CODE]*\n\n#endif\n```", "```py\nFGameplayDebuggerCategory_Locator::FGameplayDebuggerCategory_Locator()\n{\n  bShowOnlyWithDebugActor = false;\n  SetDataPackReplication<FRepData>(&DataPack);\n}\n```", "```py\nvoid FGameplayDebuggerCategory_Locator::FRepData::Serialize(FArchive& Ar) {\n  Ar << ActorLocationString;\n}\n```", "```py\nTSharedRef<FGameplayDebuggerCategory> FGameplayDebuggerCategory_Locator::MakeInstance()\n{\n  return MakeShareable(new FGameplayDebuggerCategory_Locator());\n}\n```", "```py\nvoid FGameplayDebuggerCategory_Locator::CollectData(APlayerController * OwnerPC, AActor * DebugActor)\n{\n  if (DebugActor) {\n    DataPack.ActorLocationString = DebugActor->GetActorLocation().ToString();\n  }\n}\n```", "```py\nvoid FGameplayDebuggerCategory_Locator::DrawData(APlayerController * OwnerPC, FGameplayDebuggerCanvasContext & CanvasContext)\n{\n  CanvasContext.Printf(TEXT(\"If a DebugActor is selected, here below is its location:\"));\n  CanvasContext.Printf(TEXT(\"{cyan}Location: {yellow}%s\"), *DataPack.ActorLocationString);\n}\n```", "```py\n#include \"GameplayDebuggerCategory_Locator.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"GameFramework/Actor.h\"\n\nFGameplayDebuggerCategory_Locator::FGameplayDebuggerCategory_Locator()\n{\n  bShowOnlyWithDebugActor = false;\n  SetDataPackReplication<FRepData>(&DataPack);\n}\n\nvoid FGameplayDebuggerCategory_Locator::FRepData::Serialize(FArchive& Ar) {\n  Ar << ActorLocationString;\n}\n\nTSharedRef<FGameplayDebuggerCategory> FGameplayDebuggerCategory_Locator::MakeInstance()\n{\n  return MakeShareable(new FGameplayDebuggerCategory_Locator());\n}\n\nvoid FGameplayDebuggerCategory_Locator::CollectData(APlayerController * OwnerPC, AActor * DebugActor)\n{\n  if (DebugActor) {\n    DataPack.ActorLocationString = DebugActor->GetActorLocation().ToString();\n  }\n}\n\nvoid FGameplayDebuggerCategory_Locator::DrawData(APlayerController * OwnerPC, FGameplayDebuggerCanvasContext & CanvasContext)\n{\n  CanvasContext.Printf(TEXT(\"If a DebugActor is selected, here below is its location:\"));\n  CanvasContext.Printf(TEXT(\"{cyan}Location: {yellow}%s\"), *DataPack.ActorLocationString);\n}\n\n#endif\n```", "```py\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"GameplayDebugger.h\"\n#include \"GameplayDebuggerCategory_Locator.h\"\n#endif\n```", "```py\nvoid FGameplayDebugger_LocatorModule::StartupModule()\n{\n\n#if WITH_GAMEPLAY_DEBUGGER\n\n  if (IGameplayDebugger::IsAvailable())\n  {\n    IGameplayDebugger& GameplayDebugger = IGameplayDebugger::Get();\n\n    GameplayDebugger.RegisterCategory(\"Locator\", IGameplayDebugger::FOnGetCategory::CreateStatic(&FGameplayDebuggerCategory_Locator::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate);\n\n    GameplayDebugger.NotifyCategoriesChanged();\n  }\n\n#endif\n}\n```", "```py\nvoid FGameplayDebugger_LocatorModule::ShutdownModule()\n{\n\n#if WITH_GAMEPLAY_DEBUGGER\n\n  if (IGameplayDebugger::IsAvailable())\n  {\n    IGameplayDebugger& GameplayDebugger = IGameplayDebugger::Get();\n\n    GameplayDebugger.UnregisterCategory(\"Locator\");\n\n    GameplayDebugger.NotifyCategoriesChanged();\n  }\n#endif\n}\n```", "```py\n#include \"GameplayDebugger_Locator.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"GameplayDebugger.h\"\n#include \"GameplayDebuggerCategory_Locator.h\"\n#endif\n\n#define LOCTEXT_NAMESPACE \"FGameplayDebugger_LocatorModule\"\n\nvoid FGameplayDebugger_LocatorModule::StartupModule()\n{\n\n#if WITH_GAMEPLAY_DEBUGGER\n\n  if (IGameplayDebugger::IsAvailable())\n  {\n    IGameplayDebugger& GameplayDebugger = IGameplayDebugger::Get();\n\n    GameplayDebugger.RegisterCategory(\"Locator\", IGameplayDebugger::FOnGetCategory::CreateStatic(&FGameplayDebuggerCategory_Locator::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate);\n\n    GameplayDebugger.NotifyCategoriesChanged();\n  }\n\n#endif\n}\n\nvoid FGameplayDebugger_LocatorModule::ShutdownModule()\n{\n\n#if WITH_GAMEPLAY_DEBUGGER\n\n  if (IGameplayDebugger::IsAvailable())\n  {\n    IGameplayDebugger& GameplayDebugger = IGameplayDebugger::Get();\n\n    GameplayDebugger.UnregisterCategory(\"Locator\");\n\n    GameplayDebugger.NotifyCategoriesChanged();\n  }\n#endif\n}\n\n#undef LOCTEXT_NAMESPACE\n\nIMPLEMENT_MODULE(FGameplayDebugger_LocatorModule, GameplayDebugger_Locator)\n```", "```py\npublic:\n  GameplayDebuggerExtension_Player();\n\n  //virtual void OnDeactivated() override;\n  virtual FString GetDescription() const override;\n\n  static TSharedRef<FGameplayDebuggerExtension> MakeInstance();\n```", "```py\nprotected:\n\n  void PrintPlayerLocation();\n```", "```py\nprotected:\n  uint32 bHasInputBinding : 1;\n  mutable uint32 bIsCachedDescriptionValid : 1;\n  mutable FString CachedDescription;\n```", "```py\n#include \"CoreMinimal.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"GameplayDebuggerExtension.h\"\n\n/**\n * \n */\nclass GAMEPLAYDEBUGGER_LOCATOR_API GameplayDebuggerExtension_Player : public FGameplayDebuggerExtension\n{\npublic:\n  GameplayDebuggerExtension_Player();\n\n  //virtual void OnDeactivated() override;\n  virtual FString GetDescription() const override;\n\n  static TSharedRef<FGameplayDebuggerExtension> MakeInstance();\n\nprotected:\n\n  void PrintPlayerLocation();\n\n  uint32 bHasInputBinding : 1;\n  mutable uint32 bIsCachedDescriptionValid : 1;\n  mutable FString CachedDescription;\n\n};\n\n#endif\n```", "```py\n#include \"InputCoreTypes.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Pawn.h\"\n```", "```py\nGameplayDebuggerExtension_Player::GameplayDebuggerExtension_Player()\n{\n  const FGameplayDebuggerInputHandlerConfig KeyConfig(TEXT(\"PrintPlayer\"), EKeys::NumLock.GetFName());\n  bHasInputBinding = BindKeyPress(KeyConfig, this, &GameplayDebuggerExtension_Player::PrintPlayerLocation);\n}\n```", "```py\nFString GameplayDebuggerExtension_Player::GetDescription() const\n{\n  if (!bIsCachedDescriptionValid)\n  {\n    CachedDescription = *[SOME CODE HERE TO RETRIEVE THE DESCRIPTION]*\n\n    bIsCachedDescriptionValid = true;\n  }\n\n  return CachedDescription;\n}\n```", "```py\nFString GameplayDebuggerExtension_Player::GetDescription() const\n{\n  if (!bIsCachedDescriptionValid)\n  {\n    CachedDescription = !bHasInputBinding ? FString() :\n      FString::Printf(TEXT(\"{%s}%s:{%s}Player\"),\n        *FGameplayDebuggerCanvasStrings::ColorNameInput,\n        *GetInputHandlerDescription(0),\n        *FGameplayDebuggerCanvasStrings::ColorNameEnabled);\n\n    bIsCachedDescriptionValid = true;\n  }\n\n  return CachedDescription;\n}\n```", "```py\nTSharedRef<FGameplayDebuggerExtension> GameplayDebuggerExtension_Player::MakeInstance()\n{\n  return MakeShareable(new GameplayDebuggerExtension_Player());\n}\n```", "```py\nvoid GameplayDebuggerExtension_Player::PrintPlayerLocation()\n{\n  UE_LOG(LogTemp, Warning, TEXT(\"Player's Location: %s\"), *GetPlayerController()->GetPawn()->GetActorLocation().ToString());\n}\n```", "```py\n#include \"GameplayDebuggerExtension_Player.h\"\n\n#if WITH_GAMEPLAY_DEBUGGER\n#include \"InputCoreTypes.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/Pawn.h\"\n//#include \"GameplayDebuggerPlayerManager.h\"\n//#include \"Engine/Engine.h\"\n\nGameplayDebuggerExtension_Player::GameplayDebuggerExtension_Player()\n{\n  const FGameplayDebuggerInputHandlerConfig KeyConfig(TEXT(\"PrintPlayer\"), EKeys::NumLock.GetFName());\n  bHasInputBinding = BindKeyPress(KeyConfig, this, &GameplayDebuggerExtension_Player::PrintPlayerLocation);\n}\n\nFString GameplayDebuggerExtension_Player::GetDescription() const\n{\n  if (!bIsCachedDescriptionValid)\n  {\n    CachedDescription = !bHasInputBinding ? FString() :\n      FString::Printf(TEXT(\"{%s}%s:{%s}Player\"),\n        *FGameplayDebuggerCanvasStrings::ColorNameInput,\n        *GetInputHandlerDescription(0),\n        *FGameplayDebuggerCanvasStrings::ColorNameEnabled);\n\n    bIsCachedDescriptionValid = true;\n  }\n\n  return CachedDescription;\n}\n\nTSharedRef<FGameplayDebuggerExtension> GameplayDebuggerExtension_Player::MakeInstance()\n{\n  return MakeShareable(new GameplayDebuggerExtension_Player());\n}\n\nvoid GameplayDebuggerExtension_Player::PrintPlayerLocation()\n{\n  UE_LOG(LogTemp, Warning, TEXT(\"Player's Location: %s\"), *GetPlayerController()->GetPawn()->GetActorLocation().ToString());\n}\n\n#endif\n```", "```py\nPrivateDependencyModuleNames.Add(\"InputCore\");\n```", "```py\n        if (Target.bBuildDeveloperTools || (Target.Configuration != UnrealTargetConfiguration.Shipping && Target.Configuration != UnrealTargetConfiguration.Test)) {\n            PrivateDependencyModuleNames.Add(\"GameplayDebugger\");\n PrivateDependencyModuleNames.Add(\"InputCore\");\n            Definitions.Add(\"WITH_GAMEPLAY_DEBUGGER=1\");\n        } else {\n            Definitions.Add(\"WITH_GAMEPLAY_DEBUGGER=0\");\n        }\n```", "```py\n void FGameplayDebugger_LocatorModule::StartupModule()\n{\n\n#if WITH_GAMEPLAY_DEBUGGER\n\n  UE_LOG(LogTemp, Warning, TEXT(\"Locator Module Loaded\"));\n\n  if (IGameplayDebugger::IsAvailable())\n  {\n    IGameplayDebugger& GameplayDebugger = IGameplayDebugger::Get();\n\n GameplayDebugger.RegisterExtension(\"Player\", IGameplayDebugger::FOnGetExtension::CreateStatic(&GameplayDebuggerExtension_Player::MakeInstance));\n\n GameplayDebugger.NotifyExtensionsChanged();\n\n    GameplayDebugger.RegisterCategory(\"Locator\", IGameplayDebugger::FOnGetCategory::CreateStatic(&FGameplayDebuggerCategory_Locator::MakeInstance), EGameplayDebuggerCategoryState::EnabledInGameAndSimulate);\n\n    GameplayDebugger.NotifyCategoriesChanged();\n\n    UE_LOG(LogTemp, Warning, TEXT(\"GameplayDebugger Registered\"));\n  }\n\n#endif\n}\n```", "```py\nvoid FGameplayDebugger_LocatorModule::ShutdownModule()\n{\n\n#if WITH_GAMEPLAY_DEBUGGER\n\n  if (IGameplayDebugger::IsAvailable())\n  {\n    IGameplayDebugger& GameplayDebugger = IGameplayDebugger::Get();\n\n GameplayDebugger.UnregisterExtension(\"Player\");\n\n GameplayDebugger.NotifyExtensionsChanged();\n\n    GameplayDebugger.UnregisterCategory(\"Locator\");\n\n    GameplayDebugger.NotifyCategoriesChanged();\n\n  }\n#endif\n}\n```"]