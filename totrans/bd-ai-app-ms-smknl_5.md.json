["```py\ndotnet add package Microsoft.SemanticKernel.Planners.Handlebars –-prerelease\n```", "```py\ndotnet add package Microsoft.SemanticKernel.Planners.OpenAI --prerelease\n```", "```py\n#pragma warning disable SKEXP0060\n```", "```py\nvar plannerOptions = new HandlebarsPlannerOptions()\n    {\n        ExecutionSettings = new OpenAIPromptExecutionSettings()\n        {\n            Temperature = 0.0,\n            TopP = 0.1,\n            MaxTokens = 4000\n        },\n        AllowLoops = true\n    };\nvar planner = new HandlebarsPlanner(plannerOptions);\n```", "```py\nfrom semantic_kernel.planners import FunctionCallingStepwisePlanner, FunctionCallingStepwisePlannerOptions\nimport semantic_kernel as sk\n```", "```py\nplanner_options = FunctionCallingStepwisePlannerOptions(\n        max_tokens=4000,\n    )\nplanner = FunctionCallingStepwisePlanner(service_id=\"gpt4\", options=planner_options)\n```", "```py\nvar plan = await planner.CreatePlanAsync(kernel, ask);\nvar result = await plan.InvokeAsync(kernel);\nConsole.Write ($\"Results: {result}\");\n```", "```py\nresult = await planner.invoke(kernel, ask)\nprint(result.final_answer)\n```", "```py\n#pragma warning disable SKEXP0060\nusing Microsoft.SemanticKernel;\nusing Microsoft.SemanticKernel.Planning.Handlebars;\nusing Microsoft.SemanticKernel.Connectors.OpenAI;\nvar (apiKey, orgId) = Settings.LoadFromFile();\nvar builder = Kernel.CreateBuilder();\nbuilder.AddOpenAIChatCompletion(\"gpt-4\", apiKey, orgId);\nvar kernel = builder.Build();\nvar pluginsDirectory = Path.Combine(System.IO.Directory.GetCurrentDirectory(),\n        \"..\", \"..\", \"..\", \"plugins\", \"jokes\");\nkernel.ImportPluginFromPromptDirectory(pluginsDirectory);\nvar plannerOptions = new HandlebarsPlannerOptions()\n    {\n        ExecutionSettings = new OpenAIPromptExecutionSettings()\n        {\n            Temperature = 0.0,\n            TopP = 0.1,\n            MaxTokens = 4000\n        },\n        AllowLoops = true\n    };\nvar planner = new HandlebarsPlanner(plannerOptions);\nvar ask = \"Tell four knock-knock jokes: two about dogs, one about cats and one about ducks\";\nvar plan = await planner.CreatePlanAsync(kernel, ask);\nvar result = await plan.InvokeAsync(kernel);\nConsole.Write ($\"Results: {result}\");\n```", "```py\nimport asyncio\nfrom semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion\nfrom semantic_kernel.planners import FunctionCallingStepwisePlanner, FunctionCallingStepwisePlannerOptions\nfrom semantic_kernel.utils.settings import openai_settings_from_dot_env\nimport semantic_kernel as sk\nfrom dotenv import load_dotenv\nasync def main():\n    kernel = sk.Kernel()\n    api_key, org_id = openai_settings_from_dot_env()\n    gpt35 = OpenAIChatCompletion(\"gpt-3.5-turbo\", api_key, org_id, service_id = \"gpt35\")\n    gpt4 = OpenAIChatCompletion(\"gpt-4\", api_key, org_id, service_id = \"gpt4\")\n    kernel.add_service(gpt35)\n    kernel.add_service(gpt4)\n    kernel.add_plugin(None, plugin_name=\"jokes\", parent_directory=\"../../plugins/\")\n    planner_options = FunctionCallingStepwisePlannerOptions(\n        max_tokens=4000,\n    )\n    planner = FunctionCallingStepwisePlanner(service_id=\"gpt4\", options=planner_options)\n    prompt = \"Create four knock-knock jokes: two about dogs, one about cats and one about ducks\"\n    result = await planner.invoke(kernel, prompt)\n    print(result.final_answer)\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```", "```py\n1st Joke: Knock, knock!\nWho's there?\nDog!\nDog who?\nDog who hasn't barked yet because he doesn't want to interrupt this hilarious joke!\n2nd Joke: Knock, knock!\nWho's there?\nDog!\nDog who?\nDog who forgot his keys, let me in!\n3rd Joke: Knock, knock!\nWho's there?\ncat!\ncat who?\nCat-ch me if you can, I'm the gingerbread man!\n4th Joke: Knock, knock!\nWho's there?\nDuck!\nDuck who?\nDuck down, I'm throwing a pie!\n```", "```py\n## Start\nNow take a deep breath and accomplish the task:\n1\\. Keep the template short and sweet. Be as efficient as possible.\n2\\. Do not make up helpers or functions that were not provided to you, and be especially careful to NOT assume or use any helpers or operations that were not explicitly defined already.\n3\\. If you can't fully accomplish the goal with the available helpers, just print \"{{insufficientFunctionsErrorMessage}}\".\n4\\. Always start by identifying any important values in the goal. Then, use the `\\{{set}}` helper to create variables for each of these values.\n5\\. The template should use the \\{{json}} helper at least once to output the result of the final step.\n6\\. Don't forget to use the tips and tricks otherwise the template will not work.\n7\\. Don't close the ```", "```py\n\nThe preceding steps define the set of rules that the planner uses to generate a plan using Handlebars.\n\nAlso, inside the prompt is what we call the **function manual** – that is, the instructions that the LLM will use to convert functions loaded into the kernel into text descriptions that are suitable for an LLM prompt:\n\n```", "```py\n\nIn summary, the planner is just a plugin that uses an AI service to translate a user request into a series of callable function steps, and then it generates the code that calls these functions, returning the result.\n\nTo decide which functions to call and how to call them, planners rely on the descriptions you wrote for the plugin. For native functions, the descriptions are in function decorators, while for semantic functions, they are in the `config.json` file.\n\nPlanners will send your descriptions to an AI service as part of a prompt, with instructions that tell the AI service how to combine your descriptions into a plan. Writing good descriptions can help the AI service to create better plans.\n\nHere are some things you should do:\n\n*   `required=true` so that the model knows to provide an input. If you don’t do that, the created plan may not include a required parameter and will fail when executing.\n*   **Provide examples**: Your description can provide examples of how to use the function and what the acceptable inputs and outputs are. For example, if you have a function that turns lights on in a location with the description “*Location where the lights should be turned on*,” and the location must be the kitchen or the garage, you can add “*The location must be either ‘kitchen’ or ‘garage’*” to the description. With that extra description, the planner will know not to call that function if the user asks to “*turn everything on in* *the bedroom*.”\n\nHere are some things to avoid:\n\n*   **Short descriptions**: If your function, inputs, or output descriptions are very short, it’s possible that they are not going to convey enough information to the planner about the context where they would be used. For example, it’s better to say that the output of a function is “*a knock-knock joke that follows a theme*” than “*joke*.”\n*   **Very long descriptions**: Remember that the descriptions will be submitted as part of a prompt that will incur costs. If your description is very long (for example, you provide three examples for every function), you will pay for it. Make sure that what you write in the descriptions is close to what’s necessary.\n*   **Conflicting descriptions**: If many of your functions have similar or the same description, the planner can get confused. For example, imagine that you create a jokes plugin that can create different types of jokes (knock-knock jokes, puns, absurdist jokes, etc.) but the description of all the functions is simply “*creates a joke*.” The planner will not know which function to call because the description tells it that all functions do the same thing.\n\nIf you are not getting the results that you expect when you use the planner, the first place you should look is in the descriptions you wrote for the functions, their inputs, and their outputs. Usually, just improving the descriptions a little helps the planner a lot. Another solution is to use a newer model. For example, if the plans are failing when you use GPT-3.5 and you already checked the descriptions, you may consider testing GPT-4 and seeing whether the results improve substantially.\n\nLet’s see a comprehensive example.\n\n# Controlling home automation with the planner\n\nTo get a better idea of what the planner can do, we will create a home automation application. We will not actually write functions that really control home automation, but assuming those exist, we will write their wrappers as native functions. We will also add a semantic function to our kernel and incorporate it into the planner.\n\nWe assume that we have a house with four rooms – a garage, kitchen, living room, and bedroom. We have automations to operate our garage door, operate the lights in all rooms, open the windows in the living room and in the bedroom, and operate the TV.\n\nSince our objective is to learn about Semantic Kernel and not about home automation, these functions will be very simple. We want our user to be able to say something such as “*turn on the lights of the bedroom*,” and the result will be that our native function will say “*bedroom lights* *turned on*.”\n\nThe power of using the planner is shown when a user makes requests that require multiple steps, such as “*turn off the bedroom light and open the window*,” or even something more complex, such as “*turn off the living room lights and put on a highly rated horror movie on* *the TV*.”\n\n## Creating the native functions\n\nWe will start by creating four native functions for home automation, one to operate the lights, one to operate the windows, one to operate the TV, and one to operate the garage door:\n\nC#\n\n```", "```py\n\nThe most important parts of the function are the `Description` decorators for the function itself and the parameters. They are the ones that the planner will read to learn how to use the function. Note that the descriptions specify what the valid parameters are. This helps the planner decide what to do when it receives an instruction for all locations.\n\nThe function just verifies that the location is valid and prints the action that the home automation would have taken if it were real.\n\nThe other functions simply repeat the same preceding template for their objects (the window, TV, and garage door);\n\n```", "```py\n\nPython\n\n```", "```py\n\nThe preceding function is straightforward, checking that the location passed as a parameter is valid and printing what the automation would have done.\n\nThe most important parts of the function are the descriptions for inside the `kernel_function` and for each of the `Annotated` parameters, as the descriptions are what the planner will use to decide what to do.\n\nNote that the descriptions specify what the valid parameters are. This helps the planner decide what to do when it receives a request to perform an action for all locations.\n\nNow, let’s create the other functions, following a similar structure:\n\n```", "```py\n\nNow that we’re done with native functions, let’s add a semantic function.\n\n## Adding a semantic function to suggest movies\n\nIn addition to creating the preceding native functions that control different components of the house, we are also going to create a semantic function to suggest movies based on what the user requests. Semantic functions allow the user to make requests that require the use of an AI service – for example, to find the name of a movie based on a description or the name of an actor. You’ll see that planners can seamlessly combine semantic and native functions.\n\nAs is always the case, the semantic function is the same for both C# and Python, but we need to carefully configure the `skprompt.txt` and `config.json` files to help the planner find the function and understand how to use it.\n\nWe start by creating a prompt:\n\nskprompt.txt\n\nThe prompt is very simple, and it simply asks for a suggestion for a movie. To make things easier for the planner, the prompt specifies that GPT should only respond with the title of the movie, as well as what to do if the user already knows the movie they want to watch:\n\n```", "```py\n\nNow, let’s see the configuration file:\n\nconfig.json\n\nHere, it’s again very important to fill in the `description` fields with as much detail as possible, as they are what the planner will use to decide which functions to call:\n\n```", "```py\n\nNow that all the native and semantic functions are configured, let’s call the planner and see what it can do.\n\n## Invoking the planner\n\nOnce you load the kernel with all these functions, all you need to do is invoke the planner and pass the user request to it.\n\nWe are going to make four requests to the planner:\n\n*   *Turn on the lights in* *the kitchen*\n*   *Open the windows of the bedroom, turn the lights off, and put on The Shawshank Redemption on* *the TV*\n*   *Close the garage door and turn off the lights in all* *the rooms*\n*   *Turn off the lights in all rooms and play a movie in which Tom Cruise is a lawyer, in the* *living room*\n\nUsing the existing plugins, the planner will take care of everything that is needed to fulfill these requests. For example, to fulfill the last request, the planner needs to call the `OperateLight` native function for each of the four rooms and ask GPT for a recommendation of a movie in which Tom Cruise is a lawyer, which will likely be *A Few Good Men* or *The Firm*. The planner will automatically call the functions and simply provide the results.\n\nPython\n\nThe core part of the code is to create and execute the plan, using `create_plan` and `invoke_async`, and then print the results:\n\n```", "```py\n\nThen, in the main function, we load the native functions and the semantic function in the kernel. This will make them available to the planner:\n\n```", "```py\n\nAfter loading the function, we simply call `fulfill_request`, which will create and execute a plan for each `ask`:\n\n```", "```py\n\nC#\n\nWe start by creating a kernel and adding all the native functions and the semantic function we created for it. This will make these functions available to the planner:\n\n```", "```py\n\nWe then create a function that receives a `planner` and an `ask`, creating and executing a plan to fulfill that request:\n\n```", "```py\n\nThe last step is to create the planner and call the `FulfillRequest` function we created for each `ask`:\n\n```", "```py\n\nNote that the code that uses the planner was very short. Let’s see the results:\n\n```"]