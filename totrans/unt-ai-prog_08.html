<html><head></head><body>
		<div><h1 id="_idParaDest-93"><a id="_idTextAnchor374"/><a id="_idTextAnchor375"/><em class="italic">Chapter 6</em>: Path Following and Steering Behaviors</h1>
			<p>In this short chapter, we will implement two Unity3D demos to explore steering behaviors. In the first demo, we will implement a script to make an entity follow a simple path. In the second demo, we will set up a scene with a couple of obstacles and program an entity to reach a target while avoiding the obstacles.</p>
			<p>Obstacle avoidance is a fundamental <a id="_idIndexMarker299"/>behavior for game characters when moving around and interacting with the game world. However, obstacle avoidance is generally used with other navigation systems (such as pathfinding or crowd simulations). In this chapter, we will use the systems to make sure that we avoid the other agents and reach the target. We will not talk about how fast the character will reach a destination, and we will not calculate the shortest path to the target, as we'll talk about these in the next chapter.</p>
			<p>In this chapter, we'll look at the following two fundamental aspects of movement:</p>
			<ul>
				<li>Following a path</li>
				<li>Avoiding obstacles</li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor376"/><a id="_idTextAnchor377"/><a id="_idTextAnchor378"/>Technical requirements</h1>
			<p><a id="_idTextAnchor379"/><a id="_idTextAnchor380"/>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <code>Chapter 6</code> folder in the book repository: <a id="_idTextAnchor381"/><a id="_idTextAnchor382"/><a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter06</a>.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor383"/>Following a path</h1>
			<p>A <code>Path.cs</code> script that takes a list of game objects as waypoints and create a path out of them.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor384"/>Path script</h2>
			<p>Let's look at the <a id="_idIndexMarker302"/>path script responsible for managing the path for our objects. Consider the following code in the <code>Path.cs</code> file:</p>
			<pre>using UnityEngine;
public class Path : MonoBehaviour {
    public bool isDebug = true;
    public Transform[] waypoints;
    public float Length {
        get {
            return waypoints.Length;
        }
    }
    public Vector3 GetPoint(int index) {
        return waypoints[index].position;
    }
    void OnDrawGizmos() {
        if (!isDebug)
            return;
        for (int i = 1; i &lt; waypoints.Length; i++) {
            Debug.DrawLine(waypoints[i-1].position,
            waypoints[i].position, Color.red);
        }
    }
}</pre>
			<p>As you can see, that is a straightforward script. It has a <code>Length</code> property that returns the number of waypoints. The <code>GetPoint</code> method returns the position of a particular waypoint at a specified index in the array. Then, we have the <code>OnDrawGizmos</code> method called by the Unity3D frame to draw components in the editor environment. The drawing here won't be rendered in the game <a id="_idIndexMarker303"/>view unless the gizmos flag, located in the top right corner, is turned on.</p>
			<div><div><img src="img/B17984_06_1.jpg" alt="Figure 6.1 – The gizmos visibility option in the Editor view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The gizmos visibility option in the Editor view</p>
			<p>Now let's create the scene. Create an empty <strong class="bold">Path</strong> game object and attach to it the <strong class="bold">Path</strong> script. Then, let's add to it some empty game objects as children. They will be the waypoints markers.</p>
			<div><div><img src="img/B17984_06_2.jpg" alt="Figure 6.2 – Here is how we organize the Hierarchy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.2 – Here is how we organize the Hierarchy</p>
			<p>Select the <strong class="bold">Path</strong> object. We now have to fill the <strong class="bold">Waypoints</strong> array in the Inspector with the actual waypoint markers. As usual, we can do this by dragging and dropping the game objects from the Hierarchy to the Inspector.</p>
			<div><div><img src="img/B17984_06_3.jpg" alt="Figure 6.3 – The Path script configuration in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The Path script configuration in the Inspector</p>
			<p>The preceding list shows<a id="_idIndexMarker304"/> the <strong class="bold">Waypoints</strong> in the example project. However, you can move the waypoints around in the editor, use the same waypoint multiple times, or whatever else you like.</p>
			<p>The other property is a checkbox to enable the <strong class="bold">debug</strong> mode and the waypoint radius. If we enable the <strong class="bold">debug</strong> mode property, Unity draws the path formed by connecting the waypoints as a gizmo in the editor view as shown in <em class="italic">Figure 6.4</em>.</p>
			<div><div><img src="img/B17984_06_4.jpg" alt="Figure 6.4 – The path's gizmo is drawn in the editor view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The path's gizmo is drawn in the editor view</p>
			<p>Now that we have a path, we need to design a character that can follow it. We do that in the following section.</p>
			<h2 id="_idParaDest-97">Path<a id="_idTextAnchor385"/><a id="_idTextAnchor386"/>-following agents</h2>
			<p>For this demo, the <a id="_idIndexMarker305"/>main character is represented by a brave and valiant cube. But, of course, the same script applies to whatever 3D models you want.</p>
			<p>Let's start by creating a <code>VehicleFollowing</code> script. The script takes a couple of parameters: the first is the reference to the path object it needs to follow (the <strong class="bold">Path</strong> variable); then, we have the <strong class="bold">Speed</strong> and <strong class="bold">Mass</strong> properties, which we need to calculate the character's velocity over time. Finally, if checked, the <strong class="bold">Is Looping</strong> flag instructs the entity to follow the path continuously in a closed loop.</p>
			<p>Let's take a look at the following code in the <code>VehicleFollowing.cs</code> file:</p>
			<pre>using UnityEngine;
public class VehicleFollowing : MonoBehaviour {
    public Path path;
    public float speed = 10.0f;
    [Range(1.0f, 1000.0f)]
    public float steeringInertia = 100.0f;
    public bool isLooping = true;
    public float waypointRadius = 1.0f;
    //Actual speed of the vehicle 
    private float curSpeed;
    private int curPathIndex = 0;
    private float pathLength;
    private Vector3 targetPoint;
    Vector3 velocity;</pre>
			<p>First, we specify all the script properties. Then, we initialize the properties and set up the starting direction of our velocity vector using the entity's forward vector. We do this in the <code>Start</code> method, as shown in the following code:</p>
			<pre>void Start () {
    pathLength = path.Length;
    velocity = transform.forward;
}</pre>
			<p>In this script, there are only two methods that are really important: the <code>Update</code> and <code>Steer</code> methods. Let's<a id="_idIndexMarker306"/> take a look at the first one:</p>
			<pre>    void Update() {
        //Unify the speed
        curSpeed = speed * Time.deltaTime;
        targetPoint = path.GetPoint(curPathIndex);
        //If reach the radius of the waypoint then move to
        //next point in the path
        if (Vector3.Distance(transform.position,
            targetPoint) &lt; waypointRadius) {
            //Don't move the vehicle if path is finished 
            if (curPathIndex &lt; pathLength - 1)
                curPathIndex++;
            else if (isLooping)
                curPathIndex = 0;
            else
                return;
        }
        //Move the vehicle until the end point is reached 
        //in the path
        if (curPathIndex &gt;= pathLength)
            return;
        //Calculate the next Velocity towards the path
        if (curPathIndex &gt;= pathLength - 1 &amp;&amp; !isLooping)
            velocity += Steer(targetPoint, true);
        else
            velocity += Steer(targetPoint);
        //Move the vehicle according to the velocity
        transform.position += velocity;
        //Rotate the vehicle towards the desired Velocity 
        transform.rotation =
          Quaternion.LookRotation(velocity); 
    }</pre>
			<p>In the <code>Update</code> method, we check whether the entity has reached a particular waypoint by calculating if the distance between its current position and the target waypoint is smaller than the waypoint's radius. If it is, we increase the index, setting in this way the target position to the next waypoint in the waypoints array. If it was the last waypoint, we check the <code>isLooping</code> flag.</p>
			<p>If it is active, we set the destination to the starting waypoint; otherwise, we stop. An alternative solution is to <a id="_idIndexMarker307"/>program it so that our object turns around and goes back the way it came. Implementing this behavior is not a difficult task, so we leave this to the reader as a helpful practice exercise.</p>
			<p>Now, we calculate the acceleration and rotation of the entity using the <code>Steer</code> method. In this method, we rotate and update the entity's position according to the speed and direction of the velocity vector:</p>
			<pre>    public Vector3 Steer(Vector3 target, bool bFinalPoint = 
      false) {
        //Calculate the directional vector from the current
        //position towards the target point
        Vector3 desiredVelocity = 
          (target - transform.position);
        float dist = desiredVelocity.magnitude;
        //Normalize the desired Velocity
        desiredVelocity.Normalize();
        // 
        if (bFinalPoint &amp;&amp; dist &lt; waypointRadius)
            desiredVelocity *= 
              curSpeed * (dist / waypointRadius);
        else
            desiredVelocity *= curSpeed;
        //Calculate the force Vector
        Vector3 steeringForce = desiredVelocity - velocity;
        return steeringForce / steeringInertia;
    }
}</pre>
			<p>The <code>Steer</code> method takes two parameters: the target position and a boolean, which tells us whether this is the final waypoint in the path. As first, we calculate the remaining distance from the current position to the target position. Then we subtract the current position vector from the target position vector to get a vector pointing toward the target position. We are not interested in the vector's size, just in its direction, so we normalize it.</p>
			<p>Now, suppose we are moving to the final waypoint, and its distance from us is less than the waypoint radius. In that case, we want to slow down gradually until the velocity becomes zero precisely at the waypoint position so that the character correctly stops in place. Otherwise, we update the target velocity with the desired maximum speed value. Then, in the same way as before, we can calculate the new steering vector by subtracting the current velocity <a id="_idIndexMarker308"/>vector from this target velocity vector. Finally, by dividing this vector by the steering inertia value of our entity, we get a smooth steering (note that the minimal value for the steering inertia is <code>1</code>, corresponding to instantaneous steering).</p>
			<p>Now that we have a script, we can create an empty <code>Cube</code> object and put it at the beginning of the path. Then, we add the <code>VehicleFollowing</code> script component to it, as shown in the following screenshot:</p>
			<div><div><img src="img/B17984_06_5.jpg" alt="Figure 6.5 – The properties of the VehicleFollowing script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – The properties of the VehicleFollowing script</p>
			<p>You should see our cubic character follow the path if you run the scene. You can also see the path in the editor view. Play around with the speed and steering inertia values of the cube and r<a id="_idTextAnchor387"/>adius values of<a id="_idIndexMarker309"/> the path, and see how they affect the system's overall behavior.</p>
			<h1 id="_idParaDest-98">Avoid<a id="_idTextAnchor388"/>ing obstacles</h1>
			<p>In this section, we <a id="_idIndexMarker310"/>explore obstacle avoidance. As a first step, we need, of course, obstacles. So, we set up a scene similar to the one shown in <em class="italic">Figure 6.6</em>. Then, we create a script for the main character to avoid obstacles while trying to reach the target point. The algorithm presented here uses the raycasting method, which is very straightforward. However, this means it can only avoid obstacles that are blocking its path directly in front of it:</p>
			<div><div><img src="img/B17984_06_6.jpg" alt="Figure 6.6 – A sample scene setup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – A sample scene setup</p>
			<p>We make a few cube entities and group them under an empty game object called <code>Obstacles</code> to create the environment. We also create another cube object called <code>Vehicle</code> and give it the obstacle avoidance script. Finally, we create a plane object representing the ground.</p>
			<div><div><img src="img/B17984_06_7.jpg" alt="Figure 6.7 – Here is the structure of the scene's Hierarchy &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Here is the structure of the scene's Hierarchy </p>
			<p>It is worth noting<a id="_idIndexMarker311"/> that the <strong class="bold">Vehicle</strong> object does not perform pathfinding, that is, the active search for a path to the destination. Instead, it only avoids obstacles locally as it follows the path. Roughly speaking, it is the difference between you planning a path from your home to the mall, and avoiding the possible people and obstacles you may find along the path. As such, if we set too many walls up, the <strong class="bold">Vehicle</strong> might have a hard time finding the target: for instance, if the Agent ends up facing a dead-end in a U-shaped object, it may not be able to get out. Try a few different wall setups and see how your agent performs.</p>
			<h2 id="_idParaDest-99">Ad<a id="_idTextAnchor389"/><a id="_idTextAnchor390"/>ding a custom layer</h2>
			<p>We now add a <a id="_idIndexMarker312"/>custom<a id="_idIndexMarker313"/> layer to the Obstacles object:</p>
			<ol>
				<li>To add a new layer, navigate to <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong>:</li>
			</ol>
			<div><div><img src="img/B17984_06_8.jpg" alt="Figure 6.8 – The Project Settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The Project Settings</p>
			<ol>
				<li value="2">Go to the <strong class="bold">Tags and Layer</strong> section.</li>
				<li>Assign the name <code>Obstacles</code> to <strong class="bold">User Layer 8</strong>.</li>
				<li>We then go back to our cube entity and set its <code>Obstacles</code>:</li>
			</ol>
			<div><div><img src="img/B17984_06_9.jpg" alt="Figure 6.9 – Creating a new layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Creating a new layer</p>
			<ol>
				<li value="5">When we use<a id="_idIndexMarker314"/> raycasting<a id="_idIndexMarker315"/> to detect obstacles, we check for those entities, but only on this layer. This way, the physics system can ignore objects hit by a ray that are not an obstacle, such as bushes or vegetation:</li>
			</ol>
			<div><div><img src="img/B17984_06_10.jpg" alt="Figure 6.10 – Assigning our new layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Assigning our new layer</p>
			<ol>
				<li value="6">For larger projects, our game objects probably already have a layer assigned to them. As such, instead of changing the object's layer to <strong class="bold">Obstacles</strong>, we would instead make a list of layers for our cube entity to use when detecting obstacles. We will talk more about this in the next section.<p class="callout-heading">Info</p><p class="callout">In games, we use layers to let cameras render only a part of the scene or have lights illuminate <a id="_idIndexMarker316"/>only a <a id="_idIndexMarker317"/>subset of the objects. However, layers can also be used by raycasting to ignore colliders selectively or to create collisions. You can learn more about this at <a href="https://docs.unity3d.com/Manual/Layers.html">https://docs.unity3d.com/Manual/Layers.html</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-100">Obsta<a id="_idTextAnchor391"/><a id="_idTextAnchor392"/><a id="_idTextAnchor393"/>cle avoidance</h2>
			<p>Now, it is time to code <a id="_idIndexMarker318"/>the script that makes the cube entity avoid the walls. As usual, we first initialize our entity script with the default properties. Here, we also draw GUI text in our <code>OnGUI</code> method. Let's take a look at the following code in the <code>VehicleAvoidance.cs</code> file:</p>
			<pre>using UnityEngine;
public class VehicleAvoidance : MonoBehaviour {
    public float vehic<a id="_idTextAnchor394"/><a id="_idTextAnchor395"/>leRadius = 1.2f;
    public float speed = 10.0f;
    public float force = 50.0f;
    public float minimumDistToAvoid = 10.0f;
    public float targetReachedRadius = 3.0f;
    //Actual speed of the vehicle 
    private float curSpeed;
    private Vector3 targetPoint;
    // Use this for initialization
    void Start() {
        targetPoint = Vector3.zero;
    }
    void OnGUI() {
        GUILayout.Label("Click anywhere to move the vehicle
                         to the clicked point");
    }</pre>
			<p>Then, in the <code>Update</code> method, we update the Agent entity's position and rotation based on the direction vector returned by the <code>AvoidObstacles</code> method:</p>
			<pre>    void Update() {
        //Vehicle move by mouse click
        var ray = Camera.main.ScreenPointToRay(
          Input.mousePosition);
        if (Input.GetMouseButtonDown(0) &amp;&amp;
            Physics.Raycast(ray, out var hit, 100.0f)) {
            targetPoint = hit.point;
        }
        //Directional vector to the target position
        Vector3 dir = (targetPoint - transform.position);
        dir.Normalize();
        //Apply obstacle avoidance
        AvoidObstacles(ref dir);
      
       . . . .
}</pre>
			<p>The first thing we do<a id="_idIndexMarker319"/> in the <code>Update</code> method is to retrieve the position of the mouse-click. Then, we use this position to determine the desired target position of our character. To get the mouse-click position, we shoot a ray from the camera in the direction it's facing. Then, we take the point where the ray hits the ground plane as the target position.</p>
			<p>Once we get the target position, we can calculate the direction vector by subtracting the current position vector from the target position vector. Then, we call the <code>AvoidObstacles</code> method passing this direction to it:</p>
			<pre>    public void AvoidObstacles(ref Vector3 dir) {
        //Only detect layer 8 (Obstacles)
        int layerMask = 1 &lt;&lt; 8;
        //Check that the vehicle hit with the obstacles
        //within it's minimum distance to avoid
        if (Physics.SphereCast(transform.position,
            vehicleRadius, transform.forward, out var hit,
            minimumDistToAvoid, layerMask)) {
            //Get the normal of the hit point to calculate
            //the new direction
            Vector3 hitNormal = hit.normal;
            //Don't want to move in Y-Space
            hitNormal.y = 0.0f; 
            //Get the new directional vector by adding
           //force to vehicle's current forward vector
            dir = transform.forward + hitNormal * force;
        }
    }</pre>
			<p>The <code>AvoidObstacles</code> method is also quite simple. Note that we use another very useful Unity physics utility: a <strong class="bold">SphereCast</strong>. A SphereCast is similar to the Raycast but, instead of detecting a collider by firing a dimensionless ray, it fires a chunky sphere. In practice, a SphereCast gives width to the Raycast ray.</p>
			<p>Why is this important? Because our<a id="_idIndexMarker320"/> character is not dimensionless. We want to be sure that the entire body of the character can avoid the collision.</p>
			<p>Another thing to note is that the SphereCast interacts selectively with the <code>SphereCast</code> method accepts a layer mask parameter to determine which layers to ignore and consider during raycasting. Now, if you look at how many layers you can specify in <strong class="bold">Tag Manager</strong>, you'll find a total of 32 layers.</p>
			<p>Therefore, Unity3D uses a 32-bit integer number to represent this layer mask parameter. For example, the following would represent a zero in 32 bits:</p>
			<pre>0000 0000 0000 0000 0000 0000 0000 0000</pre>
			<p>By default, Unity3D uses the first eight layers as built-in layers. So, when you use a Raycast or a SphereCast without using a layer mask parameter, it detects every object in those eight layers. We can represent this interaction mask with a bitmask, as follows:</p>
			<pre>0000 0000 0000 0000 0000 0000 1111 1111</pre>
			<p>In this demo, we set the <strong class="bold">Obstacles</strong> layer as layer 8 (9th index). Because we only want to detect obstacles in this layer, we want to set up the bitmask in the following way:</p>
			<pre>0000 0000 0000 0000 0000 0001 0000 0000</pre>
			<p>The easiest way to set up this bitmask is by using the bit shift operators. We only need to place the on bit, <code>1</code>, at the 9th index, which means we can just move that bit eight places to the left. So, we use the left shift operator to move the bit eight places to the left, as shown in the following code:</p>
			<pre>int layerMask = 1&lt;&lt;8;</pre>
			<p>If we wanted to use multiple layer masks, say, layer 8 and layer 9, an easy way would be to use the bitwise <strong class="bold">OR</strong> operator, as follows:</p>
			<pre>int layerMask = (1&lt;&lt;8) | (1&lt;&lt;9);</pre>
			<p class="callout-heading">Info</p>
			<p class="callout"><a id="_idTextAnchor396"/>You can also find a good discussion on using layer masks on Unity3D's online resources. The question and answer site can be found at <a href="http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html">http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html</a>.</p>
			<p>Once we have the<a id="_idIndexMarker321"/> layer mask, we call the <code>Physics.SphereCast</code> method from the current entity's position and in the forward direction. We use a sphere of radius <code>vehicleRadius</code> (make sure that is big enough to contain the cubic vehicle in its entirety) and a detection distance defined by the <code>minimumDistToAvoid</code> variable. In fact, we want to detect only the objects that are close enough to affect our movement.</p>
			<p>Then, we take the normal vector of the hit ray, multiply it with the force vector, and add it to the current direction of the entity to get the new resultant direction vector, which we return from this method:</p>
			<div><div><img src="img/B17984_06_11.jpg" alt="Figure 6.11 – How our cube entity avoids a wall&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – How our cube entity avoids a wall</p>
			<p>Then, in the <code>Update</code> method, we use <a id="_idIndexMarker322"/>this new direction to rotate the AI entity and update the position according to the speed value:</p>
			<pre>    void Update () {
        //...
        //Don't move the vehicle when the target point is
        //reached
        if (Vector3.Distance(targetPoint,
            transform.position) &lt; targetReachedRadius)
            return;
        //Assign the speed with delta time
        curSpeed = speed * Time.deltaTime;
        //Rotate the vehicle to its target directional
        //vector
        var rot = Quaternion.LookRotation(dir);
        transform.rotation = 
          Quaternion.Slerp(transform.rotation, rot, 5.0f *
                           Time.deltaTime);
        //Move the vehicle towards
        transform.position += transform.forward * curSpeed;
        transform.position = new Vector3(
          transform.position.x, 0, transform.position.z);
    }</pre>
			<p>Now, we only need to attach this new script to the Vehicle object (this can be a simple cube as in the previous example). Remember that this new script needs to replace the <code>VehicleFollowing</code> script we<a id="_idIndexMarker323"/> implemented in the previous section.</p>
			<div><div><img src="img/B17984_06_12.jpg" alt="Figure 6.12 – Properties of our Vehicle Avoidance script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Properties of our Vehicle Avoidance script</p>
			<p>If everything is correct, you should be able to see the vehicle navigate across the plane around the obstacles without any trouble. As usual, play with the Inspector parameters to tweak the vehicle behavior.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor397"/>Summary</h1>
			<p>In this chapter, we set up two scenes and studied how to build path-following agents with obstacle avoidance behavior. We learned about the Unity3D layer feature and how to use Raycasts and SphereCasts against a particular layer selectively. Although these examples were simple, we can apply these simple techniques to various scenarios. For instance, we can set up a path along a road. We can easily set up a decent traffic simulation using some vehicle models combined with obstacle avoidance behavior. Alternatively, you could just replace them with biped characters and build a crowd simulation. You can also combine them with some finite state machines to add more behaviors and make them more intelligent.</p>
			<p>The simple obstacle avoidance behavior that we implemented in this chapter doesn't consider the optimal path to reach the target position. Instead, it just goes straight to that target, and only if an obstacle is seen within a certain distance does it try to avoid it. For this reason, it's supposed to be used among moving or dynamic objects and obstacles.</p>
			<p>In the following chapter, we'll study how to implement a pathfinding algorithm, called <strong class="bold">A*</strong>, to determine the optimal path before moving, while still avoiding static obstacles.</p>
		</div>
	</body></html>