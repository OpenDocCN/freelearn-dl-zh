<html><head></head><body>
		<div><p><a id="_idTextAnchor222"/></p>
			<h1 id="_idParaDest-50"><em class="italic"><a id="_idTextAnchor223"/>Chapter 3</em>: Randomness and Probability</h1>
			<p>In this chapter, we will look at how we can apply the concepts of probability and randomness to game AI. Because we will talk more about the use of randomness in game AI and less about Unity3D, we can apply the concepts of this chapter to any game development middleware or technology framework. We'll be using Mono C# in Unity3D for the demos, but we won't address much on the specific features of the Unity3D engine and the editor itself.</p>
			<p>Game developers use probability to add a little uncertainty to the behaviors of AI characters and the wider game world. Randomness makes artificial intelligence look more realistic and natural, and it is the perfect "spice" for all those cases in which we do not need <em class="italic">intentional</em> predictability.</p>
			<p>In this chapter, we will look at the following topics:</p>
			<ul>
				<li>Introducing randomness in Unity</li>
				<li>Learning the basics of probability</li>
				<li>Exploring more examples of probability in games</li>
				<li><a id="_idTextAnchor224"/><a id="_idTextAnchor225"/>Creating a slot machine</li>
			</ul>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor226"/>Technical requirements</h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <code>Chapter 3</code> folder in the book repository: <a id="_idTextAnchor227"/><a id="_idTextAnchor228"/><a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor229"/>Introducing randomness in Unity</h1>
			<p>Game <a id="_idIndexMarker150"/>designers <a id="_idIndexMarker151"/>and developers use randomness in game AI to make a game and its characters more realistic by altering the outcomes of characters' decisions.</p>
			<p>Let's take an example of a typical soccer game. One of the rules of a soccer game is to award a direct free kick to a team if one opposing team player commits a foul while trying to retake control of the ball. However, instead of giving a free kick whenever that foul happens, the game developer can apply a probability to reward only 98% of all the fouls with a direct free kick.</p>
			<p>After all, in reality, referees make mistakes sometimes. As a result of this simple change, the player usually gets a direct free kick as expected. Still, when that remaining two percent happens, the game provides more emotional feedback to both teams (assuming that you are playing against another human, one player will be happy while the other will complain with the virtual referee).</p>
			<p>Of course, randomness is not always a desirable perk of AI. As we anticipated in the introduction, some level of predictability allows players to learn the AI patterns, and understanding the AI patterns is often the main component of gameplay. For example, in a stealth game, learning the enemy guards' paths is necessary to allow the player to find a sneaking route. Or imagine you need to design a boss for a game such as <em class="italic">Dark Souls</em>.</p>
			<p>Learning the big boss attack patterns is the player's primary weapon and the only proper way to achieve mastery for boss fights. As always, you have to follow the polar star of game design: do only what it is fun for the player. If adding randomness adds only frustration for the players, then you should remove it without exceptions<a id="_idTextAnchor230"/><a id="_idTextAnchor231"/>.</p>
			<p>However, in some cases, a bit of randomness is useful, and for some games, such as gambling minigames, it is a necessary prerequisite. In those cases, how can a computer produce random values? And more importantly, how can we use random numbers in Unity?</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor232"/>Randomness in computer science</h2>
			<p>Computers <a id="_idIndexMarker152"/>are <a id="_idIndexMarker153"/>deterministic machines: by design, if we give a computer the same input multiple times, in the form of program code and data, it always returns the same output. Therefore, how can we have a program return unpredictable and random output?</p>
			<p>If we need genuinely random numbers, then we need to take this randomness from somewhere else. That's why many advanced applications try to combine different external sources of randomness into a random value: they may look at the movement of the mouse during a specific interval, to the noise of the internet connection, or even ask the user to smash the keyboard randomly, and so on. There is even dedicated hardware for random number generation!</p>
			<p>Fortunately, in games, we do not need such genuinely random numbers, and we can use simpler algorithms that can generate sequences that look like a sequence of random numbers. Such <a id="_idIndexMarker154"/>algorithms are called <strong class="bold">Pseudorandom Number Generators</strong> (<strong class="bold">PRNGs</strong>). Using an initial seed, they can generate, in a deterministic way, a sequence of numbers that statistically approximate the properties of a sequence of truly random numbers. The catch is that if we start from the same seed, we always get the same sequence of numbers.</p>
			<p>For this reason, we usually initialize the seed value from something that we imagine is always different every time the user opens the application, such as, for instance, the elapsed time in milliseconds since the computer started running, or the number of milliseconds since 1970 (the <em class="italic">Unix timestamp</em>). Note, however, that having the possibility to obtain the same random sequence every time is truly beneficial when debugging!</p>
			<p>Finally, note <a id="_idIndexMarker155"/>that some PRNGs are more random than others. If we<a id="_idIndexMarker156"/> were creating an encryption program, we <a id="_idIndexMarker157"/>would want to look into less predictable PRNGs, called <strong class="bold">Cryptographically Secure Pseudorandom Number Generators</strong> (<strong class="bold">CSPRNGs</strong>). Fortunately, for <a id="_idIndexMarker158"/>games, the simple <strong class="bold">Random Number Generation</strong> (<strong class="bold">RNG</strong>) that comes with Unity is good<a id="_idTextAnchor233"/> enough.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor234"/>The Unity Random class</h2>
			<p>The Unity3D<a id="_idIndexMarker159"/> script has a <code>Random</code> class to generate random data. You can set the generator seed using the <code>InitState(int seed)</code> function. Usually, we wouldn't want to repeatedly seed the same value, as this generates the same predictable sequence of random numbers at each execution. </p>
			<p>However, there are some cases in which we want to give the user control over the seed – for instance, when we test the game or want the players to generate a procedural map/level with a specific seed. Then, you can read the <code>Random.value</code> property to get a random number between 0.0 and 1.0. This generator is inclusive, and therefore, this property can return both 0.0 and 1.0. </p>
			<p>For example, in the following snippet, we generate a random color by choosing a random value between 0 and 1 for the red, green, and blue components:</p>
			<pre>Color randomColor = new Color(Random.value, Random.value, Random.value); </pre>
			<p>Another class method that can be quite handy is the <code>Range</code> method:</p>
			<pre>static function Range (min : float, max : float) : float</pre>
			<p>We can use the <code>Range</code> method to generate a random number from a range. When given an integer value, it returns a random integer number between <code>min</code> (inclusive) and <code>max</code> (exclusive). Therefore, if we set <code>min</code> to 1 and <code>max</code> to 4, we can get 1, 2, or 3, but never 4. Instead, if we use the <code>Range</code> function for float values, both <code>min</code> and <code>max</code> are inclusive, meaning we can get 1.0, or 4.0, or all the floats in between. Take note whenever a <a id="_idIndexMarker160"/>parameter is exclusive or inclusive because it is a common source of bugs (and confusion) when using the Unity <code>Ran<a id="_idTextAnchor235"/>dom</code> class.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor236"/>A simple random dice game</h2>
			<p>Let's set up<a id="_idIndexMarker161"/> a straightforward dice game in a new scene where we need to guess the output of a six-sided dice (simulated by generating a random integer between one and six). The player wins if the input value matches the dice result generated randomly, as shown in the following <code>DiceGame.cs</code> file:</p>
			<pre>using UnityEngine;
using TMPro;
using UnityEngine.UI;
public class DiceGame : MonoBehaviour {
    public string inputValue = "1";
    public TMP_Text outputText;
    public TMP_InputField inputField;
    public Button button;
    int throwDice() {
        Debug.Log("Throwing dice...");
        Debug.Log("Finding random between 1 to 6...");
        int diceResult = Random.Range(1,7);
        Debug.Log($"Result: {diceResult}");
        return diceResult;
    }
    public void processGame() {
        inputValue = inputField.text;
        try {
            int inputInteger = int.Parse(inputValue);
            int totalSix = 0;
            for (var i = 0; i &lt; 10; i++) {
                var diceResult = throwDice();
                if (diceResult == 6) { totalSix++; }
                if (diceResult == inputInteger) {
                    outputText.text = $"DICE RESULT:
                      {diceResult} \r\nYOU WIN!";
                } else {
                    outputText.text = $"DICE RESULT:
                      {diceResult} \r\nYOU LOSE!";
                }
            }
            Debug.Log($"Total of six: {totalSix}");
        } catch {
            outputText.text = "Input is not a number!";
            Debug.LogError("Input is not a number!");
        }
    }
}</pre>
			<p>In the previous<a id="_idIndexMarker162"/> code, we saw the <code>DiceGame</code> class that implements the whole game. However, we still need to set up the scene with the appropriate UI object to accept the player's inputs and display the results: </p>
			<ol>
				<li>First, we need to create <code>guiText</code> to show the resu<a id="_idTextAnchor237"/><a id="_idTextAnchor238"/>lt. Click on <code>New Text</code> text to the game scene. </li>
				<li>Center it at the top of the canvas.</li>
				<li>Then, in the same way, create a button <a id="_idTextAnchor239"/><a id="_idTextAnchor240"/>by selecting <strong class="bold">Game Object</strong> | <strong class="bold">UI</strong> | <strong class="bold">Button – TextMeshPro</strong> and an input field by selecting <strong class="bold">Game Object</strong> | <strong class="bold">UI</strong> | <strong class="bold">Input Field – TextMeshPro</strong>.</li>
				<li>Arrange them vertically on the screen.</li>
				<li>Create an empty game object and call it <code>DiceGame</code>. At this point, you should have something similar to <em class="italic">Figure 3.1</em>:</li>
			</ol>
			<div><div><img src="img/B17984_03_1.jpg" alt="Figure 3.1 – Our simple Unity interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Our simple Unity interface</p>
			<ol>
				<li value="6">Select the text <a id="_idIndexMarker163"/>inside the button and replace <code>Button</code> with <code>Play!</code> in the <strong class="bold">TextMeshPro</strong> component.</li>
				<li>Select the <code>New Text</code> text and replace it with <code>Result:</code> in the <strong class="bold">TextMeshPro</strong> component:</li>
			</ol>
			<div><div><img src="img/B17984_03_2.jpg" alt="Figure 3.2 – The TextMeshPro component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – The TextMeshPro component</p>
			<ol>
				<li value="8">Now, attach the <code>DiceGame</code> component to the <code>DiceGame</code> object, and connect into the <code>DiceGame</code> component the tree UI elements that we created before:</li>
			</ol>
			<div><div><img src="img/B17984_03_3.jpg" alt="Figure 3.3 – The DiceGame component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – The DiceGame component</p>
			<ol>
				<li value="9">Finally, select <code>Button</code> and look for the <code>onClick()</code> section in the <code>Button</code> component. Drag and drop the <code>DiceGame</code> object into the field with <code>None (GameObject)</code> and select <code>processGame</code> function to the click event for the button:</li>
			</ol>
			<div><div><img src="img/B17984_03_4.jpg" alt="Figure 3.4 – The On Click event configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – The On Click event configuration</p>
			<p>At this point, the game should be ready. Click Unity's play button and give it a go.</p>
			<p>To successfully <a id="_idIndexMarker164"/>manage random numbers, we need to have a basic understanding of the laws of probability. So, that's what we are going to learn in the nex<a id="_idTextAnchor241"/>t section.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor242"/>Learning the basics of probability</h1>
			<p>There are many ways<a id="_idIndexMarker165"/> to define probability. The most intuitive definition of probability is called <strong class="bold">frequentism</strong>. According<a id="_idIndexMarker166"/> to frequentism, the probability of an event is the frequency with which the event occurs when we repeat the observation an infinite amount of times. In other words, if we throw a die 100 times, we expect to see a six, on average, 1/6th of the times, and we should get closer and closer to 1/6th with 1,000, 10,000, and 1 million throws.</p>
			<p>We can write the probability of event A occurring as <em class="italic">P(A)</em>. To calculate <em class="italic">P(A)</em>, we need to know all the possible outcomes (<em class="italic">N</em>) for the observation and the total number of times in which the desired event occurs (<em class="italic">n</em>).</p>
			<p>We can calculate the probability of event <em class="italic">A</em> as follows:</p>
			<p class="figure-caption"><img src="img/Formula_01.png" alt=""/></p>
			<p>If <em class="italic">P(A)</em> is the probability of event <em class="italic">A</em> happening, then the probability of event <em class="italic">A</em> not happening is equal to the following:</p>
			<p class="figure-caption"><img src="img/Formula_2.png" alt=""/></p>
			<p>The probability<a id="_idIndexMarker167"/> must be a real number between zero and one. Having a probability of zero means that there's no chance of the desired event happening; on the other hand, having a probability of one means that the event will occur for sure. As a consequence, the following must equal to one:</p>
			<p class="figure-caption"><img src="img/Formula_3.png" alt=""/></p>
			<p>However, not all events are alike. One of the most critical concepts in probability calculus is the concept of <em class="italic">independent and non-independent events</em>. That's the topic of the nex<a id="_idTextAnchor243"/>t section.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor244"/>Independent and correlated events</h2>
			<p>Another <a id="_idIndexMarker168"/>important<a id="_idIndexMarker169"/> concept in probability is whether the chance of a particular event occurring depends on any other event somehow. For example, consider throwing a six-sided die twice and getting a double six. Each die throw can be viewed as an independent event. Each time you throw a die, the probability of each side turning up is one in six, and the outcome of the second die roll does not change depending on the result of the first roll. On the other hand, in drawing two aces from the same deck, each draw is not independent of the others. If you drew an ace in the first event, the probability of getting another ace the second time is different because there is now one less ace in the deck (and one less card in the deck).</p>
			<p>The independence of events is crucial because it significantly simplifies some calculations. For instance, imagine that we want to know the probability of either event <em class="italic">A</em> or event <em class="italic">B</em> happening. If <em class="italic">A </em>and <em class="italic">B</em> are two independent events, then we can add the probabilities of <em class="italic">A</em> and <em class="italic">B</em>:</p>
			<p class="figure-caption"><img src="img/Formula_04.png" alt=""/></p>
			<p>In the same way, if we want to know the probability that both <em class="italic">A</em> and <em class="italic">B</em> occur, then we can multiply the individual probabilities together:</p>
			<p class="figure-caption"><img src="img/Formula_5.png" alt=""/></p>
			<p>For<a id="_idIndexMarker170"/> instance, if we want to know the probability of getting two <a id="_idIndexMarker171"/>sixes by throwing two dice, we can multiply 1/6 by 1/6 to get the correct probab<a id="_idTextAnchor245"/>ility: 1/36.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor246"/>Conditional probability</h2>
			<p>Now, let's consider <a id="_idIndexMarker172"/>another example. We are still throwing two dice, but this time, we are interested in the probability that the sum of the numbers showing up on two dice is equal to two. Since there's only one way to get this sum, one plus one, the probability is the same as getting the same number on both dice. In that case, it would still be 1/36.</p>
			<p>But how about getting the sum of the numbers that show up on the two dice to seven? As you can see, there are a total of six possible ways of getting a total of seven, outlined in the following table:</p>
			<div><div><img src="img/B17984_03_5.jpg" alt="Figure 3.5 – The possible outcomes of two dice&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – The possible outcomes of two dice</p>
			<p>In this case, we need to use the general probability formula. From the preceding table, we can see <a id="_idIndexMarker173"/>that we have six outcomes that give us a total sum of seven. Because we know that there are 36 total possible outcomes for 2 dice, we can quickly compute the final probability as 6/36 or, simplifying, one-sixth (16.7%).<a id="_idTextAnchor247"/></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor248"/>Loaded dice</h2>
			<p>Now, let's assume <a id="_idIndexMarker174"/>that we haven't been all too honest, and our dice are loaded so that the side of the number six has a double chance of landing facing upward. Since we doubled the chance of getting six, we need to double the probability of getting six – let's say, up to roughly one-third (0.34) – and as a consequence, the rest is equally spread over the remaining five sides (0.132 each).</p>
			<p>We can implement a loaded dice algorithm this way: first, we generate a random value between 1 and 100. Then, we check whether the random value falls between 1 and 35. If so, our algorithm returns six; otherwise, we get a random dice value between one and five (since these values have the same probability).</p>
			<p>For this, we create a new class called <code>DiceGameLoaded</code>. The game is identical to <code>DiceGame</code> but with an important difference: the <code>throwDice</code> function is changed, as follows:</p>
			<pre>    int throwDice() {
        Debug.Log("Throwing dice...");
        int randomProbability = Random.Range(0, 100);
        int diceResult = 0;
        if (randomProbability &lt; 35) {
            diceResult = 6;
        } else {
            diceResult = Random.Range(1, 5);
        }
        Debug.Log("Result: " + diceResult);
        return diceResult;
    }</pre>
			<p>To try this new<a id="_idIndexMarker175"/> version of the game, swap the <code>DiceGame</code> component with the <code>DiceGame</code> component in the <code>DiceGame</code> object and rebind the <code>onClick</code> button event as we did before. If we test our new loaded dice algorithm by throwing the dice multiple times, you'll notice that the <code>6</code> value yields more than usual. </p>
			<p>As you can see, the code is very similar to the non-loaded dice. However, this time, we are throwing an unfair dice that returns six much more than it should: we first select a random number between <code>0</code> and <code>100</code>; if the number is less than <code>35</code>, we return <code>6</code>. Otherwise, we choose a random number between <code>1</code> and <code>5</code>. Therefore, we get a <code>6</code> 35% of the time and every other number roughly 15% of the time (we divide the remaining 75% by <code>5</code>).</p>
			<p>Remember that, in g<a id="_idTextAnchor249"/><a id="_idTextAnchor250"/>ames, it's not cheating if the goal is to give the player a more exciting and<a id="_idIndexMarker176"/> fun experience!</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor251"/>Exploring more examples of probability in games</h1>
			<p>In this section, we<a id="_idIndexMarker177"/> will explore some of the most common applications of probability and randomness in video games.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor252"/>Character personalities</h2>
			<p>Probability and<a id="_idIndexMarker178"/> randomness are not only about dice. We can also use a probability distribution to specify an in-game character's specialties. For example, let's pretend we designed a game proposal for a population management game for the local government. We need to address and simulate issues such as taxation versus global talent attraction, and immigration versus social cohesion. We have three types of characters in our proposal – namely, workers, scientists, and professionals. Their efficiencies in performing their particular tasks are defined in the following table:</p>
			<div><div><img src="img/B17984_03_6.jpg" alt="Figure 3.6 – The efficiency of every character in performing each task&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The efficiency of every character in performing each task</p>
			<p>Let's take a look at how we can implement this scenario. Let's say the player needs to build new houses to accommodate the increased population. A house construction would require 1,000 units of workload to finish. We use the earlier value as the workload that can be done per second per unit type for a particular task.</p>
			<p>So, if you're building a house with one worker, it'll only take about 10 seconds to finish the construction (1000/95), whereas it'll take more than 3 minutes if you are trying to build with the scientists (1000/5 = 200 seconds). The same is true for other tasks, such as research and development and corporate jobs. Of course, these factors can be adjusted or enhanced later as the game progresses, making some entry-level tasks simpler and taking less time.</p>
			<p>Then, we introduce special items that the particular unit type can discover. We don't want to give out these items every time a particular unit has done its tasks. Instead, we want to reward the player as a surprise. So, we associate the probability of finding such items according to the unit type, as described in the following table:</p>
			<div><div><img src="img/B17984_03_7.jpg" alt="Figure 3.7 – The probability of finding specific objects for each unit type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The probability of finding specific objects for each unit type</p>
			<p>The preceding table shows a 30% chance of a worker finding some raw materials and a 10% chance of <a id="_idIndexMarker179"/>earning bonus income whenever they have built a factory or a house. This allows the players to anticipate possible upcoming rewards once they've done some tasks and make the game more fun because they do not know the event's outcome.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor253"/>Perceived randomness</h2>
			<p>One critical <a id="_idIndexMarker180"/>aspect of randomness is that humans are terrible at understanding true randomness. Instead, when us humans talk about <em class="italic">random results</em>, we think of <em class="italic">equally distributed results</em>. For example, imagine <a id="_idIndexMarker181"/>a <strong class="bold">Massive Online Battle Arena</strong> (<strong class="bold">MOBA</strong>) game such as <em class="italic">League of Legends</em>. Imagine that we have a hero with an ability that does colossal damage but only hits 50% of the time. The player starts a game with such a hero, but the hero misses that ability five times in a row due to bad luck. Put yourself in the shoes of that player – you would think that the computer is cheating or that there is something wrong, right?</p>
			<p>However, getting 5 consecutive misses has a probability of 1 over 32. That is about 3.1%, more than getting three of a kind in a five-card deal of poker (which is about 2.1%) – unlikely but possible. If our game uses a perfectly random number generator, we may get this scenario relatively often.</p>
			<p>Let's put it another way. Given a sequence of misses (<em class="italic">M</em>) and hits (<em class="italic">H</em>), which sequence do you find more <em class="italic">random</em> between <em class="italic">HHHHHMMM</em> and <em class="italic">HMHMHHMH</em>? I bet the second one, where we interleave misses and hits. It feels more random than the first one (where hits and misses are nicely grouped in strikes), even if they have the exact same chance of occurring naturally.</p>
			<p>The point is that, sometimes, for the sake of player engagements, games need to tweak their randomness to get something that feels more random than true randomness. Video games do that in several ways. The most common one is keeping track of the number of occurrences of a value that should be perceived as random.</p>
			<p>So, for instance, we may keep track of the number of hits and misses of our hero's ability, and <a id="_idIndexMarker182"/>when we see that the ratio between the two get too far away from the theoretical one of 50% – for example, when we have 75% misses (or hits) – we rebalance the ratio by forcing a hit (or vice vers<a id="_idTextAnchor254"/>a).</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor255"/>FSM with probability</h2>
			<p>In <em class="italic">Chapter 2</em>, <em class="italic">Finite State Machines</em>, we<a id="_idIndexMarker183"/> saw <a id="_idIndexMarker184"/>how <a id="_idIndexMarker185"/>to implement an FSM using simple switch statements or the FSM framework. We based the decision on choosing which state to execute purely on a given condition's true or false value. Let's go back for a moment to the FSM of our AI-controlled tank entity:</p>
			<div><div><img src="img/B17984_03_8.jpg" alt="Figure 3.8 – The tank AI FSM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – The tank AI FSM</p>
			<p>For the sake of the example, we can give our tank entities some options to choose from instead of doing the same thing whenever it meets a specific condition. For example, in our earlier FSM, our AI tank would always chase the player tank once the player was in its line of<a id="_idIndexMarker186"/> sight. Instead, we can split <a id="_idIndexMarker187"/>the <strong class="bold">player on sight </strong>transaction<a id="_idIndexMarker188"/> and connect it to an additional new state, <strong class="bold">Flee</strong>. How can the AI decide which state to move to? Randomly, of course: </p>
			<div><div><img src="img/B17984_03_9.jpg" alt="Figure 3.9 – FSM using probability&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – FSM using probability</p>
			<p>As shown in the preceding diagram, instead of chasing every time, now, when the AI tank spots the player, there's a 50% chance that it'll flee the scene (maybe to report the attack to the headquarters or something else). We can implement this mechanism the same way we did with our previous dice example. First, we must randomly get a value between 1 and 100 and see whether the value lies between 1 and 50, or 51 and 100. If it's the former, the tank will flee; otherwise, it will chase the player.</p>
			<p>Another way to implement a random selection is by using the <strong class="bold">roulette wheel selection algorithm</strong>. This <a id="_idIndexMarker189"/>algorithm is advantageous when we do not have exact probabilities or know all the possible options at compile time (for instance, because we load the FSM rules from a file).</p>
			<p>As the name suggests, the idea is to imagine a roulette wheel with one sector for each event. However, the more probable an event is, the larger the sector is. Then, we mathematically spin the<a id="_idIndexMarker190"/> wheel and choose the event corresponding to the <a id="_idIndexMarker191"/>sector where we <a id="_idIndexMarker192"/>ended up:</p>
			<div><div><img src="img/B17984_03_10.jpg" alt="Figure 3.10 – The roulette wheel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – The roulette wheel</p>
			<p>In our example, we have three states: <strong class="bold">Chase</strong>, <strong class="bold">Flee</strong>, and <strong class="bold">SelfDestruct</strong>. We assign a weight to each state, representing how probable they are with respect to each other. For instance, in the figure, you can see that I set <strong class="bold">Chase</strong> with weight <strong class="bold">80</strong>, <strong class="bold">Flee</strong> with weight <strong class="bold">19</strong>, and <strong class="bold">SelfDestruct</strong> with weight <strong class="bold">1</strong>. Note that weights do not need to sum to 1 like probabilities, nor 100, nor anything in particular.</p>
			<p>In this case, however, I made them add to 100 because it is easier to translate weights into probabilities: we can imagine <strong class="bold">Chase</strong> happening 80% of the time, <strong class="bold">Flee</strong> 19% of the time, and in 1% of the cases, the tank self-destructing. However, in general, you can imagine the weight of event <em class="italic">X</em> as the number of balls with <em class="italic">X</em> written on them and put inside a lottery box.</p>
			<p>Let's see the result in the <code>FSM.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
using System;
using System.Linq;
public class FSM : MonoBehaviour {
    [Serializable]
    public enum FSMState {
        Chase,
        Flee,
        SelfDestruct,
    }
    [Serializable]
    public struct FSMProbability {
        public FSMState state;
        public int weight;
    }
    public FSMProbability[] states;
    FSMState selectState() {
        // Sum the weights of every state.
        var weightSum = states.Sum(state =&gt; state.weight);
        var randomNumber = UnityEngine.Random.Range(0,
          weightSum);
        var i = 0;
        while (randomNumber &gt;= 0) {
            var state = states[i];
            randomNumber -= state.weight;
            if (randomNumber &lt;= 0) {
                return state.state;
            }
            i++;
        }
        // It is not possible to reach this point!
        throw new Exception("Something is wrong in the
          selectState algorithm!");
    }
    
    // Update is called once per frame
    void Update () {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            FSMState randomState = selectState();
            Debug.Log(randomState.ToString());
        }
    }
}</pre>
			<p>The mechanism is straightforward. First, we sum all the weights to know the size of the imaginary wheel. Then, we pick a number between <code>0</code> and this sum. Finally, we subtract from this number the weights of each state (starting from the first one) until the number gets negative. Then, as you can see in the <code>Update()</code> method, every time we press the<a id="_idIndexMarker193"/> <em class="italic">Spacebar</em>, the algorithm <a id="_idIndexMarker194"/>chooses <a id="_idIndexMarker195"/>one random item from our <code>s<a id="_idTextAnchor256"/>tates</code> array. </p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor257"/>Dynamically adapting AI skills</h2>
			<p>We can also<a id="_idIndexMarker196"/> use probability to<a id="_idIndexMarker197"/> specify the intelligence levels of AI characters or the global game settings, affecting, in turn, a game's overall difficulty level to keep it challenging and exciting for the players. As described in the book <em class="italic">The Art of Game Design</em> by Jesse Schell, players only continue to play a game if the game keeps them in the flow channel (a concept adapted to games from the psychological works on flow state of Mihály Csíkszentmihályi):</p>
			<div><div><img src="img/B17984_03_11.jpg" alt="Figure 3.11 – The player's ﬂow channel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The player's ﬂow channel</p>
			<p>If we present too tricky challenges to the players before they have the necessary skills, they will feel anxious and disappointed. On the other hand, once they've mastered the game, they will get bored if we keep it at the same pace. The area in which the players remain engaged for a long time is between these two hard and easy extremes, which the original author referred to as the flow channel. To keep the players in the flow channel, the game designers need to feed challenges and missions that match the increasing skills that the players acquire over time. However, it is not easy to find a value that works for all players, since the pace of learning and expectations can differ from individual to individual.</p>
			<p>One way to tackle this problem is to collect the player's attempts and results during the gameplay sessions and to adjust the difficulty of the opponent's AI accordingly. So, how can we<a id="_idIndexMarker198"/> change<a id="_idIndexMarker199"/> the AI's difficulty – for instance, by making the AI more aggressive, increasing the probability of landing a perfect shot, or decreasing the probability of erratic b<a id="_idTextAnchor258"/>ehavior?</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor259"/>Creating a slot machine</h1>
			<p>In this demo, we <a id="_idIndexMarker200"/>will design and implement a slot machine game with 10 symbols and 3 reels. To make it simple, we'll use the numbers from zero to nine as our symbols. Many slot machines use fruit and other simple shapes, such as bells, stars, and letters. Some other slot machines use a specific theme based on popular movies or TV franchises. Since there are 10 symbols and 3 reels, that's a total of 1,000 (10^3) possible comb<a id="_idTextAnchor260"/>inations.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor261"/>A random slot machine</h2>
			<p>This random slot <a id="_idIndexMarker201"/>machine demo is similar to our previous dice example. This time, we are going to generate three random numbers for three reels. The only payout will be when we get three of the same symbols on the pay line. To make it simpler, we'll only have one line to play against in this demo. If the player wins, the game will return 500 times the bet amount.</p>
			<p>We'll set up our scene with all our UI elements: three texts for the reels, another text element for the <code>betResult</code> object), one text element for the player's credits (<code>Credits</code>), an input field for the bet (<code>InputField</code>), and a button to pull the lever (<code>Button</code>):</p>
			<div><div><img src="img/B17984_03_12.jpg" alt="Figure 3.12 – Our GUI text objects&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Our GUI text objects</p>
			<p>This is how our new<a id="_idIndexMarker202"/> script looks, as shown in the following <code>SlotMachine.cs</code> file:</p>
			<pre>using UnityEngine;
using UnityEngine.UI;
public class SlotMachine : MonoBehaviour { 
    public float spinDuration = 2.0f;
    public int numberOfSym = 10;
    public Text firstReel;
    public Text secondReel;
    public Text thirdReel;
    public Text betResult;
    public Text totalCredits;
    public InputField inputBet;
    private bool startSpin = false;
    private bool firstReelSpinned = false;
    private bool secondReelSpinned = false;
    private bool thirdReelSpinned = false;
    private int betAmount;
    private int credits = 1000;
    private int firstReelResult = 0;
    private int secondReelResult = 0;
    private int thirdReelResult = 0;
    private float elapsedTime = 0.0f;</pre>
			<p>First, we start by listing all the class attributes we need. Again, note that it is a good programming practice to avoid public fields unless strictly necessary. Therefore, you should use the <code>[SerializeField]</code> attribute instead. Here, however, we will use the <code>public</code> attribute<a id="_idIndexMarker203"/> to avoid making the code listing too long. </p>
			<p>Now, let's continue by adding three new functions: <code>Spin</code>, which starts the spinning of the slot machine; <code>OnGui</code>, which we will use to update the user interface; and <code>checkBet</code>, a function that checks the result of the spin and informs the players if they win or lose:</p>
			<pre>public void Spin() {
    if (betAmount &gt; 0) {
        startSpin = true;
    } else {
        betResult.text = "Insert a valid bet!";
    }
}
private void OnGUI() {
    try {
        betAmount = int.Parse(inputBet.text);
    } catch {
        betAmount = 0;
    }
    totalCredits.text = credits.ToString();
}
void checkBet() {
    if (firstReelResult == secondReelResult &amp;&amp; 
        secondReelResult == thirdReelResult) {
        betResult.text = 
          "YOU WIN!"; credits += 500*betAmount;
    } else {
        betResult.text = "YOU LOSE!"; credits -= betAmount;
    }
}</pre>
			<p>Next, we implement<a id="_idIndexMarker204"/> the main loop of the script. In the <code>FixedUpdate</code> function, we run the slot machine by spinning each reel in turn. In the beginning, <code>firstReelSpinned</code>, <code>secondReelSpinned</code>, and <code>thirdReelSpinned</code> are all false. Therefore, we enter in the first <code>if</code> block. Here, we set the reel to a random value, and we end the function. We repeat that until a certain amount of time has passed.</p>
			<p>After that, we set the reel to the final value, and we set <code>firstReelSpinned</code> to <code>true</code>. Then, the function will move to the second reel, where we repeat these steps. Finally, after the third reel is finally set to its final value, we check the results with <code>checkBet</code>:</p>
			<pre>void FixedUpdate () { 
    if (startSpin) {
        elapsedTime += Time.deltaTime;
        int randomSpinResult =
          Random.Range(0, numberOfSym);
        if (!firstReelSpinned) {
            firstReel.text = randomSpinResult.ToString();
            if (elapsedTime &gt;= spinDuration) {
                firstReelResult = randomSpinResult;
                firstReelSpinned = true;
                elapsedTime = 0;
            }
        } else if (!secondReelSpinned) {
            secondReel.text = randomSpinResult.ToString();
            if (elapsedTime &gt;= spinDuration) {
                secondReelResult = randomSpinResult;
                secondReelSpinned = true;
                elapsedTime = 0;
            }
        } else if (!thirdReelSpinned) {
            thirdReel.text = randomSpinResult.ToString();
            if (elapsedTime &gt;= spinDuration) {
                thirdReelResult = randomSpinResult;
                startSpin = false; 
                elapsedTime = 0;
                firstReelSpinned = false;
                secondReelSpinned = false;
                checkBet();
            }
        }
    }
}</pre>
			<p>Attach the script to an empty <code>GameController</code> object and then fill in the referenced object in the Inspector. Then, we need to connect <code>Button</code> to the <code>Spin()</code> method. To do that, select <code>Button</code> and fill the <strong class="bold">On Click ()</strong> event handler in the Inspector, as shown in <a id="_idIndexMarker205"/>the following screenshot:</p>
			<div><div><img src="img/B17984_03_13.jpg" alt="Figure 3.13 – The On Click() event handler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – The On Click() event handler</p>
			<p>When we click the button, we set the <code>startSpin</code> flag to <code>true</code>. Once spinning, in the <code>FixedUpdate()</code> method, we generate a random value for each reel. Finally, once we've got the value for the third reel, we reset the <code>startSpin</code> flag to <code>false</code>. While we are getting the random value for each reel, we also track how much time has elapsed since the player pulled the lever.</p>
			<p>Usually, each reel would take 3 to 5 seconds before landing the result in real-world slot machines. Hence, we also take some time, as specified in <code>spinDuration</code>, before showing the final random value. If you play the scene and click on the <strong class="bold">Pull Lever</strong> button, you should see the final result, as shown in the following screenshot:</p>
			<div><div><img src="img/B17984_03_14.jpg" alt="Figure 3.14 – Our random slot game in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Our random slot game in action</p>
			<p>Since your chance of winning is 1 out of 100, it quickly becomes tedious, as you lose several times consecutively. However, if you've ever played a slot machine, this is not how it works, or at least not anymore. Usually, you can have several wins during your play. Even though these small wins don't recoup your principal bet (and in the long run, most players go broke), the slot machines still occasionally render winning graphics and exciting sounds, which<a id="_idIndexMarker206"/> researchers refer to as losses disguised as wins.</p>
			<p>So, instead of just one single way to win the jackpot, we want to modify the rules a bit so that the slot machine pays out smaller returns during the pla<a id="_idTextAnchor262"/>y session.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor263"/>Weighted probability</h2>
			<p>Real slot<a id="_idIndexMarker207"/> machines have something called a <strong class="bold">Paytable and Reel Strips</strong> (<strong class="bold">PARS</strong>) sheet, which is the complete design document of the <a id="_idIndexMarker208"/>machine. The PARS sheet is used to specify the payout percentage, the winning patterns, their payouts, and so on.</p>
			<p>The number of payout prizes and the frequencies of such wins must be carefully selected so that the house (the slot machine) always wins in the long run while making sure to return something to the players from time to time to make the machine attractive to play. This is known as payback <a id="_idIndexMarker209"/>percentage or <strong class="bold">Return to Player</strong> (<strong class="bold">RTP</strong>). For example, a slot machine with a 90% RTP means that, over time, the machine returns an average of 90% of all bets to the players.</p>
			<p>In this demo, we will not focus on choosing the house's optimal value to yield specific wins over time, nor maintaining a particular payback percentage. Instead, we will demonstrate how to weight probability for specific symbols showing up more times than usual. So, let's say we want to make the 0 symbols appear 20% more than usual on the first and third reel and return half of the bet as a payout.</p>
			<p>In other words, a player only loses half of their bet if they got zero symbols on the first and third reels, essentially disguising a loss as a small win. Currently, the zero symbols have a probability of 1/10th (0.1), or a 10% probability. We'll change this now to a 30% chance of zero landing on the first and third reels, as shown in the following <code>SlotMachineWeighted.cs</code> file (remember to switch to the <code>SlotMachineWeighted</code> component<a id="_idIndexMarker210"/> in the example code!):</p>
			<pre>using UnityEngine;
using System.Collections;
using UnityEngine.UI;
public class SlotMachineWeighted : MonoBehaviour { 
    public float spinDuration = 2.0f;
    // Number of symbols on the slot machine reels
    public int numberOfSym = 10;
    public Text firstReel;
    public Text secondReel;
    public Text thirdReel;
    public Text betResult;
    public Text totalCredits;
    public InputField inputBet;
    private bool startSpin = false;
    private bool firstReelSpinned = false;
    private bool secondReelSpinned = false;
    private bool thirdReelSpinned = false;
    private int betAmount = 100;
    private int credits = 1000;
    [Serializable]
    public struct WeightedProbability {
        public int number;
        public int weight;
    }
    private List&lt;WeightedProbability&gt; weightedReelPoll =
      new List&lt;WeightedProbability&gt;();
    private int zeroProbability = 30;
    private int firstReelResult = 0;
    private int secondReelResult = 0;
    private int thirdReelResult = 0;
    private float elapsedTime = 0.0f;</pre>
			<p>New variable <a id="_idIndexMarker211"/>declarations are added, such as <code>zeroProbability</code>, to specify the probability percentage of the zero symbols landing on the first and third reels. For example, if <code>zeroProbability</code> is 30, the third reel will show 0 30% of the time. The <code>weightedReelPoll</code> array list is used to fill the weighted symbols, as we did in our earlier FSM example.</p>
			<p>Then, we initialize this list in the <code>Start()</code> method, as shown in the following code:</p>
			<pre>void Start () {
    weightedReelPoll.Add(new WeightedProbability {
        number = 0,
        weight = zeroProbability
    });
    int remainingValuesProb = (100 - zeroProbability)/9;
    for (int i = 1; i &lt; 10; i++) {
        weightedReelPoll.Add(new WeightedProbability {
        number = i,
        weight = remainingValuesProb
    });
}}</pre>
			<p>In practice, we <a id="_idIndexMarker212"/>set the value for 0 to 30, and we split the remaining 70 percentage points between the remaining 9 numbers.</p>
			<p>We are also writing a revised and improved <code>checkBet()</code> method. Instead of just one jackpot win option, we are now considering five conditions of jackpot: loss disguised as a win, a near miss, any two symbols matched on the first and third row, and of course, the <code>lose</code> condition:</p>
			<pre>void checkBet() {
    if (firstReelResult == secondReelResult &amp;&amp; 
        secondReelResult == thirdReelResult) {
        betResult.text = "JACKPOT!";
        credits += betAmount * 50;
    } else if (firstReelResult == 0 &amp;&amp; 
               thirdReelResult == 0) {
        betResult.text = 
          "YOU WIN " + (betAmount/2).ToString();
        credits -= (betAmount/2);
    } else if (firstReelResult == secondReelResult) {
        betResult.text = "AWW... ALMOST JACKPOT!";
    } else if (firstReelResult == thirdReelResult) {
        betResult.text = 
          "YOU WIN " + (betAmount*2).ToString();
        credits -= (betAmount*2);
    } else {
        betResult.text = "YOU LOSE!";
        credits -= betAmount;
    }
}</pre>
			<p>In the <code>checkBet()</code> method, we <a id="_idIndexMarker213"/>designed our slot machine to return 50 times the bet if they hit the jackpot, to lose 50% of their bet if the first and third reels are 0, and to win twice if the first and third reels match with any other symbol. </p>
			<p>Then, as in the previous example, we generate values for the three reels in the <code>FixedUpdate()</code> method, as shown in the following code:</p>
			<pre>private int PickNumber() {
    // Sum the weights of every state.
    var weightSum = 
      weightedReelPoll.Sum(state =&gt; state.weight);
    var randomNumber = 
      UnityEngine.Random.Range(0, weightSum);
    var i = 0;
    while (randomNumber &gt;= 0) {
        var candidate = weightedReelPoll[i];<a id="_idTextAnchor264"/><a id="_idTextAnchor265"/>
        randomNumber -= candidate.weight;
        if (randomNumber &lt;= 0) {
            return candidate.number;
        }
        i++;
    }
    // It should not be possible to reach this point!
    throw new Exception("Something is wrong in the 
                         selectState algorithm!");
}
void FixedUpdate () { 
    if (startSpin) {
        elapsedTime += Time.deltaTime;
        int randomSpinResult = 
          Random.Range(0, numberOfSym);
        if (!firstReelSpinned) {
            firstReel.text = randomSpinResult.ToString();
            if (elapsedTime &gt;= spinDuration) {
                int weightedRandom = PickNumber();
                firstReel.text = weightedRandom.ToString();
                firstReelResult = weightedRandom;
                firstReelSpinned = true;
                elapsedTime = 0;
            }
        } else if (!secondReelSpinned) {
            secondReel.text = randomSpinResult.ToString();
            if (elapsedTime &gt;= spinDuration) {
                secondReelResult = randomSpinResult;
                secondReelSpinned = true;
                elapsedTime = 0;
            }
        }
...</pre>
			<p>For the first reel, we show the real random values as they occur during the spinning period. Once the time is up, we choose the value from the poll that is already populated with symbols according to the probability distribution. So, our zero symbols will have a 30% better chance of occurring than the rest.</p>
			<p>In reality, the <a id="_idIndexMarker214"/>player is losing on their bets if they get two zero symbols on the first and third reel; however, we make it seem like a win. It's just a lame message here, but this can work if we combine it with nice graphics, maybe even fireworks, and nice winning sound effects<a id="_idTextAnchor266"/>.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor267"/>A near miss</h2>
			<p>If the first and <a id="_idIndexMarker215"/>second reels return the same symbol, we have to provide the near-miss effect to the players by returning the random value to the third reel close to the second one. We can do this by checking the third random spin result first. If the random value is the same as the first and second results, this is a jackpot, and we shouldn't alter the result.</p>
			<p>But if it's not, then we should modify the result so that it is close enough to the other two. Check the<a id="_idIndexMarker216"/> comments in the following code:</p>
			<pre>        else if (!thirdReelSpinned) {
            thirdReel.text = randomSpinResult.ToString();
            if (elapsedTime &gt;= spinDuration) {
                if ((firstReelResult == secondReelResult)
                  &amp;&amp; randomSpinResult != firstReelResult) {
                    // the first two reels have resulted
                    // the same symbol
                    // but unfortunately the third reel
                    // missed
                    // so instead of giving a random number
                    // we'll return a symbol which is one 
                    // less than the other 2
                    randomSpinResult = firstReelResult - 1;
                    if (randomSpinResult &lt; firstReelResult)
                      randomSpinResult =
                        firstReelResult - 1;
                    if (randomSpinResult &gt; firstReelResult)
                     randomSpinResult = 
                       firstReelResult + 1;
                    if (randomSpinResult &lt; 0) 
                      randomSpinResult = 0;
                    if (randomSpinResult &gt; 9) 
                      randomSpinResult = 9;
                    thirdReel.text = 
                      randomSpinResult.ToString();
                    thirdReelResult = randomSpinResult;
                } else {
                    int weightedRandom = PickNumber();
                    thirdReel.text = 
                      weightedRandom.ToString();
                    thirdReelResult = weightedRandom;
                }
                startSpin = false;
                elapsedTime = 0;
                firstReelSpinned = false;
                secondReelSpinned = false;
                checkBet();
            }
        }
    }
}</pre>
			<p>And if that <a id="_idIndexMarker217"/>near miss happens, you should see it, as shown in the following screenshot:</p>
			<div><div><img src="img/B17984_03_15.jpg" alt="Figure 3.15 – A near miss&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – A near miss</p>
			<p>We can go even further by adjusting the probability in real time, based on the bet amount (but that'd be too shady). Finally, we can add a <strong class="bold">Game Over</strong> message that appears when the player has bet all their money.</p>
			<p>This demo shows you the basic implementation of a slot machine game. You can start from this <a id="_idIndexMarker218"/>skeleton and improve it with nicer graphics, animations, and sound effects. The important takeaway, though, is understanding that you can already create a game with randomness and probability alone.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor268"/>Summary</h1>
			<p>In this chapter, we learned about the applications of probability in AI game design. We experimented with some of the techniques by implementing them in Unity3D. As a bonus, we also learned about how a slot machine works and implemented a simple slot machine game using Unity3D. Probability in games is about making the game, and the characters, seem more realistic by adding uncertainty to their behavior so that players cannot predict the outcome.</p>
			<p>In the next chapter, we will look at implementing sensors and how they can make our AI aware of its surroundings.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor269"/>Further reading</h1>
			<p>To further study the advanced techniques on probability in games, such as decision making under uncertainty using Bayesian techniques, I recommend reading <em class="italic">AI for Game Developers</em> by David M. Bourg and Glenn Seeman. <em class="italic">Rules of Play</em> by Katie Salen is another suggested book on game design.</p>
		</div>
	</body></html>