- en: <st c="0">6</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">6</st>
- en: <st c="2">Interfacing with RAG and Gradio</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">与 RAG 和 Gradio 交互</st>
- en: <st c="33">In almost all cases,</st> **<st c="55">retrieval-augmented generation</st>**
    <st c="85">(</st>**<st c="87">RAG</st>**<st c="90">) development involves the
    creation of one or more applications, or</st> *<st c="159">apps</st>* <st c="163">for
    short.</st> <st c="175">When coding RAG apps initially, you will often create
    a variable in your code that represents a prompt or some other type of input that
    in turn represents what the RAG pipeline will work off of.</st> <st c="370">But
    is that how future users will use the app you are building?</st> <st c="434">How
    do you test this with these users using your code?</st> <st c="489">You need</st>
    <st c="498">an interface!</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33">在几乎所有情况下，**<st c="55">检索增强生成**</st> <st c="85">(**<st c="87">RAG</st>**)
    开发涉及创建一个或多个应用程序，或**<st c="159">应用**</st> <st c="163">（简称 apps）。</st> <st c="175">在最初编码
    RAG 应用程序时，你通常会创建一个变量，在代码中表示提示或其他类型的输入，这些输入反过来又表示 RAG 管道将基于其进行操作。</st> <st c="370">但未来的用户会怎样使用你正在构建的应用程序呢？</st>
    <st c="434">你如何使用你的代码与这些用户进行测试？</st> <st c="489">你需要一个界面！</st>
- en: <st c="511">In this chapter, we will provide a practical guide to making your
    application interactive with RAG using</st> **<st c="617">Gradio</st>** <st c="623">as
    a</st> **<st c="629">user interface</st>** <st c="643">(</st>**<st c="645">UI</st>**<st
    c="647">).</st> <st c="651">It covers setting up the Gradio environment, integrating
    RAG models, creating a user-friendly interface that allows users to use your RAG
    system like a typical web application, and hosting it online in a permanent and
    free space.</st> <st c="881">You will learn how to quickly prototype and deploy
    RAG-powered applications, enabling end users to interact with AI models in</st>
    <st c="1007">real time.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="511">在本章中，我们将提供使用 Gradio 作为用户界面（**<st c="617">Gradio</st>**）的实用指南，以使您的应用程序通过
    RAG 交互。</st> <st c="651">它涵盖了设置 Gradio 环境、集成 RAG 模型、创建用户友好的界面，使用户能够像使用典型的网络应用程序一样使用您的
    RAG 系统，并在永久且免费的在线空间中托管它。</st> <st c="881">您将学习如何快速原型设计和部署 RAG 驱动的应用程序，使最终用户能够实时与
    AI 模型交互。</st>
- en: <st c="1017">There are entire books written on how to build an interface, and
    there are many places you can provide an interface, such as in a web browser or
    through a mobile app.</st> <st c="1185">But luckily, using Gradio, we can provide
    you with an easy way to offer an interface for your RAG-based app, without having
    to do extensive web or mobile development.</st> <st c="1352">This makes it easier
    to share and</st> <st c="1386">demo models.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1017">关于如何构建界面的书籍已经有很多，你可以在很多地方提供界面，例如在网页浏览器或通过移动应用。</st> <st c="1185">但幸运的是，使用
    Gradio，我们可以为您提供一种简单的方法来为您的基于 RAG 的应用程序提供界面，而无需进行大量的网页或移动开发。</st> <st c="1352">这使得共享和演示模型变得更加容易。</st>
    <st c="1386">模型。</st>
- en: <st c="1398">In the chapter, we will specifically cover the</st> <st c="1446">following
    topics:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1398">在本章中，我们将具体介绍以下主题：</st> <st c="1446">以下主题：</st>
- en: <st c="1463">Why Gradio?</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1463">为什么选择 Gradio？</st>
- en: <st c="1475">Benefits of</st> <st c="1488">using Gradio</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1475">使用 Gradio 的好处</st>
- en: <st c="1500">Limitations to</st> <st c="1516">using Gradio</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1500">使用 Gradio 的局限性</st>
- en: <st c="1528">Code lab – Adding a</st> <st c="1549">Gradio interface</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1528">代码实验室 – 添加一个</st> <st c="1549">Gradio 界面</st>
- en: <st c="1565">Let’s first discuss why Gradio is an important part of your RAG</st>
    <st c="1630">development efforts.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1565">让我们首先讨论为什么 Gradio 是您 RAG 开发工作的重要组成部分。</st> <st c="1630">努力。</st>
- en: <st c="1650">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1650">技术要求</st>
- en: <st c="1673">The code for this chapter is</st> <st c="1703">here:</st> [<st
    c="1709">https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_06</st>](https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_06
    )
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1673">本章的代码在此：</st> <st c="1703">这里：</st> [<st c="1709">https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_06</st>](https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_06
    )
- en: <st c="1806">Why Gradio?</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1488">为什么选择 Gradio？</st>
- en: <st c="1818">Up until this point, we have</st> <st c="1847">focused on topics
    that are typically relegated to the</st> <st c="1902">world of data science.</st>
    **<st c="1925">Machine learning</st>**<st c="1941">,</st> **<st c="1943">natural
    language processing</st>** <st c="1970">(</st>**<st c="1972">NLP</st>**<st c="1975">),</st>
    **<st c="1979">generative artificial intelligence</st>** <st c="2013">(</st>**<st
    c="2015">generative AI</st>**<st c="2028">),</st> **<st c="2032">large language
    models</st>** <st c="2053">(</st>**<st c="2055">LLMs</st>**<st c="2059">), and
    RAG are technologies that require significant</st> <st c="2113">expertise and
    often take up enough</st> <st c="2148">time that we are not able to build expertise
    in other technical areas, such as working with web technologies and building web
    frontends.</st> **<st c="2285">Web development</st>** <st c="2300">is a highly
    technical field in its own right, and requires significant experience</st> <st
    c="2382">and expertise to</st> <st c="2400">implement successfully.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1818">到目前为止，我们一直</st> <st c="1847">关注的是通常被归入</st> <st c="1902">数据科学领域的主题。</st>
    **<st c="1925">机器学习</st>**<st c="1941">、**<st c="1943">自然语言处理</st>** <st c="1970">(**<st
    c="1972">NLP</st>**<st c="1975">)、**<st c="1979">生成式人工智能</st>** <st c="2013">(**<st
    c="2015">生成式AI</st>**<st c="2028">)、**<st c="2032">大型语言模型</st>** <st c="2053">(**<st
    c="2055">LLMs</st>**<st c="2059">)和RAG都是需要大量**<st c="2113">专业知识**的技术，通常需要投入足够多的**<st
    c="2148">时间**，以至于我们无法在其他技术领域，如使用网络技术和构建网络前端，建立专业知识。</st> **<st c="2285">Web开发</st>**
    <st c="2300">本身是一个高度技术化的领域，需要大量的**<st c="2382">经验和专业知识**才能**<st c="2400">成功实施**。</st>
- en: <st c="2423">However, with RAG, it can be very helpful to have a UI, especially
    if you want to test it or demonstrate it to potential users.</st> <st c="2552">How
    can we provide that if we do not have the time to learn</st> <st c="2612">web
    development?</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3050">然而，对于RAG来说，拥有一个UI非常有帮助，特别是如果你想测试它或向潜在用户展示它。</st> <st c="3205">如果我们没有时间学习**<st
    c="2552">网络开发</st>**，我们该如何提供这样的UI呢？</st>
- en: <st c="2628">That is the primary reason why many data scientists, including
    myself, use</st> <st c="2703">Gradio.</st> <st c="2712">It allows you to get a
    UI up and running very quickly (relative to building a web frontend) in a sharable
    format and even with some basic authentication features.</st> <st c="2875">This
    is not going to put any web developers out of a job, as Gradio would not be a
    great choice if you wanted to turn your RAG application into a full-fledged robust
    website.</st> <st c="3050">But what it will do is allow you, as someone with very
    limited time to build a website, to get a UI that is well suited to RAG applications
    up and running</st> <st c="3205">within minutes!</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2628">这就是为什么许多数据科学家，包括我自己，都使用**<st c="2703">Gradio</st>**的原因。它允许你非常快速地（相对于构建网络前端）以可共享的格式启动一个用户界面，甚至还有一些基本的身份验证功能。</st>
    <st c="2712">这不会让任何网络开发者失业，因为如果你想要将你的RAG应用变成一个完整的、健壮的网站，Gradio可能不是一个很好的选择。</st>
    <st c="2875">但它将允许你，作为一个时间非常有限来构建网站的人，在几分钟内就启动一个非常适合RAG应用的UI！</st>
- en: <st c="3220">Because the idea here is to allow you to keep most of your focus
    on RAG development, rather than web development, we are going to streamline our
    discussion about Gradio to just the components that will help you get your RAG
    application on the web and shareable.</st> <st c="3483">However, as your RAG development
    continues, we encourage you to further investigate the capabilities of Gradio
    to see if there is anything else that it can do for your</st> <st c="3651">specific
    efforts!</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3220">因为这里的想法是让你将大部分精力集中在RAG开发上，而不是网络开发上，我们将简化我们对Gradio的讨论，只讨论那些能帮助你将RAG应用部署到网络并使其可共享的组件。</st>
    <st c="3483">然而，随着你的RAG开发继续进行，我们鼓励你进一步调查Gradio的功能，看看是否还有其他什么可以帮助你**<st c="3651">特定努力**的地方！</st>
- en: <st c="3668">With that in mind, let’s talk about the main benefits of Gradio
    when building a</st> <st c="3749">RAG application.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3668">考虑到这一点，让我们来谈谈使用Gradio构建**<st c="3749">RAG应用**的主要好处。</st>
- en: <st c="3765">Benefits of using Gradio</st>
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3765">使用Gradio的好处</st>
- en: <st c="3790">Besides</st> <st c="3799">being just really easy to use for non-web
    developers, Gradio has many advantages.</st> <st c="3881">Gradio’s core library
    is open source, which means developers can freely use, modify, and contribute
    to the project.</st> <st c="3997">Gradio integrates well with widely used machine
    learning frameworks, such</st> <st c="4071">as</st> **<st c="4074">TensorFlow</st>**<st
    c="4084">,</st> **<st c="4086">PyTorch</st>**<st c="4093">, and</st> **<st c="4099">Keras</st>**<st
    c="4104">. In</st> <st c="4109">addition to the open source library, Gradio offers
    a hosted</st> <st c="4168">platform where developers can deploy their model interfaces
    and manage access.</st> <st c="4248">Gradio includes features that facilitate
    collaboration among teams working on machine learning projects, such as sharing
    interfaces and</st> <st c="4384">collecting feedback.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对非网页开发者来说非常容易使用之外，Gradio还有很多优点。<st c="3790">除了</st> <st c="3799">仅仅对非网页开发者来说非常容易使用之外，Gradio还有很多优点。</st>
    <st c="3881">Gradio的核心库是开源的，这意味着开发者可以自由地使用、修改并为项目做出贡献。</st> <st c="3997">Gradio与广泛使用的机器学习框架集成良好，例如</st>
    <st c="4071">如下</st> **<st c="4074">TensorFlow</st>**<st c="4084">，**<st c="4086">PyTorch</st>**<st
    c="4093">，和</st> **<st c="4099">Keras</st>**<st c="4104">。除了开源库之外，Gradio还提供了一个托管平台，开发者可以在该平台上部署他们的模型接口并管理访问权限。</st>
    <st c="4109">此外，Gradio还包含一些有助于机器学习项目团队协作的功能，例如共享接口和</st> <st c="4384">收集反馈。</st>
- en: <st c="4404">Another exciting feature of Gradio is that it integrates well</st>
    <st c="4466">with</st> **<st c="4472">Hugging Face</st>**<st c="4484">. Founded
    by former employees of OpenAI, Hugging Face has a lot of resources meant to support
    the generative AI community, such as model sharing and dataset hosting.</st> <st
    c="4650">One of the resources is the ability to set up a permanent link to your
    Gradio demo on the internet, using</st> **<st c="4756">Hugging Face Spaces</st>**<st
    c="4775">. Hugging Face Spaces provides the infrastructure to</st> <st c="4828">permanently
    host your machine learning model for free!</st> <st c="4883">Take a look at the
    Hugging Face website to find out more about</st> <st c="4946">their Spaces.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4404">Gradio的另一个令人兴奋的功能是它与**<st c="4472">Hugging Face</st>**<st c="4484">集成得很好。</st>
    由OpenAI的前员工创立的Hugging Face拥有许多旨在支持生成式AI社区的资源，例如模型共享和数据集托管。</st> <st c="4650">这些资源之一是能够使用**<st
    c="4756">Hugging Face Spaces</st>**<st c="4775">在互联网上设置指向您的Gradio演示的永久链接。</st>
    Hugging Face Spaces提供了免费永久托管您的机器学习模型的必要基础设施！<st c="4828">查看Hugging Face网站以了解更多关于</st>
    <st c="4946">他们的Spaces的信息。</st>
- en: <st c="4959">There are also some limitations to using Gradio when it comes to
    using it for your RAG application and it is important to know what</st> <st c="5092">those
    are.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4959">当使用Gradio为您的RAG应用程序时，也存在一些限制，了解这些限制是很重要的。</st>
- en: <st c="5102">Limitations to using Gradio</st>
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="5102">使用Gradio的限制</st>
- en: <st c="5130">Probably the most important thing to</st> <st c="5168">keep in
    mind with Gradio is that it does not provide adequate support for building a production-level
    app that will be interfacing with hundreds, thousands, or even millions of users.</st>
    <st c="5352">In this case, you probably want to hire someone with expertise in
    building frontends for large-scale production-level applications.</st> <st c="5484">But
    for what we call</st> <st c="5504">a</st> **<st c="5507">proof-of-concept</st>**
    <st c="5523">(</st>**<st c="5525">POC</st>**<st c="5528">) type of app, or to
    build something that allows you to test out your app with users with basic interactivity
    and functionality, Gradio does a</st> <st c="5672">fantastic job.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5130">在使用Gradio时，最重要的是要记住的是，它并不提供足够的支持来构建一个将与其他数百、数千甚至数百万用户交互的生产级应用程序。</st>
    <st c="5352">在这种情况下，您可能需要雇佣一位在构建大规模生产级应用程序前端方面有专业知识的人。</st> <st c="5484">但对我们所说的**<st
    c="5507">概念验证</st>** <st c="5523">(</st>**<st c="5525">POC</st>**<st c="5528">)类型的应用程序，或者构建允许您测试具有基本交互性和功能的应用程序，Gradio做得非常出色。</st>
    <st c="5672">Gradio做得非常出色。</st>
- en: <st c="5686">Another limitation that you may come across when using Gradio for
    RAG applications is the lack of flexibility in what you can build.</st> <st c="5820">For
    many RAG applications, especially when building a POC, this will not be an issue.</st>
    <st c="5906">But if you or your users start demanding more sophisticated UI features,
    Gradio is going to be much more limiting than a full web development framework.</st>
    <st c="6059">Not only is it good for you to understand this, but it is good to
    set these expectations with your users, helping them to understand that this is
    only meant for a simple</st> <st c="6229">demo</st> <st c="6233">application.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5686">当你使用 Gradio 进行 RAG 应用时可能会遇到的一个限制是，你所能构建的内容缺乏灵活性。</st> <st c="5820">对于许多
    RAG 应用，尤其是在构建原型时，这不会成为问题。</st> <st c="5906">但如果你或你的用户开始要求更复杂的 UI 功能，Gradio 将比完整的
    Web 开发框架限制得多。</st> <st c="6059">不仅了解这一点对你很重要，而且与你的用户设定这些期望也很重要，帮助他们理解这只是一个简单的</st>
    <st c="6229">演示</st> <st c="6233">应用程序。</st>
- en: <st c="6246">Let’s dive right into the code and walk through how Gradio can
    give your RAG application the interface</st> <st c="6350">it deserves.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6246">让我们直接进入代码，了解 Gradio 如何为你的 RAG 应用程序提供它应得的界面。</st> <st c="6350">它应得的。</st>
- en: <st c="6362">Code lab – Adding a Gradio interface</st>
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="6362">代码实验室 – 添加 Gradio 接口</st>
- en: <st c="6399">This code picks up right where we</st> <st c="6434">left off in</st>
    [*<st c="6446">Chapter 5</st>*](B22475_05.xhtml#_idTextAnchor095)<st c="6455">,
    except for the last set of lines representing the prompt probe attack.</st> <st
    c="6528">As we have at the beginning of all of our code labs, we are going to
    start with installing a new package, which is, of course, Gradio!</st> <st c="6663">We
    are also going to uninstall</st> `<st c="6694">uvloop</st>`<st c="6700">, because
    of a conflict with our</st> <st c="6733">other packages:</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6399">此代码从我们</st> <st c="6434">在</st> [*<st c="6446">第五章</st>*](B22475_05.xhtml#_idTextAnchor095)<st
    c="6455">停止的地方继续，除了最后一组代表提示探针攻击的行。</st> <st c="6528">正如我们在所有代码实验室的开始一样，我们将从安装一个新的包开始，当然是
    Gradio！</st> <st c="6663">我们还将卸载</st> `<st c="6694">uvloop</st>`<st c="6700">，因为它与我们的</st>
    <st c="6733">其他包</st>存在冲突：</st>
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="6793">This installs the</st> `<st c="6812">gradio</st>` <st c="6818">package
    and removes the conflicting</st> `<st c="6855">uvloop</st>` <st c="6861">package.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6793">这会安装</st> `<st c="6812">gradio</st>` <st c="6818">包并移除冲突的</st>
    `<st c="6855">uvloop</st>` <st c="6861">包。</st>
- en: <st c="6870">Next, we will add multiple packages to the list</st> <st c="6919">of
    imports:</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6870">接下来，我们将向导入列表中添加多个包：</st> <st c="6919">导入：</st>
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="7070">These lines import the</st> `<st c="7094">asyncio</st>` <st c="7101">and</st>
    `<st c="7106">nest_asyncio</st>` <st c="7118">libraries and set up the event loop
    policy.</st> `<st c="7163">asyncio</st>` <st c="7170">is a library for writing
    concurrent code using coroutines and event loops.</st> `<st c="7246">nest_asyncio</st>`
    <st c="7258">is a library that allows nested event loops in Jupyter notebook.</st>
    <st c="7324">The</st> `<st c="7328">asyncio.set_event_loop_policy(asyncio.DefaultEventLoopPolicy())</st>`
    <st c="7391">line sets the event loop policy to the default policy.</st> `<st
    c="7447">nest_asyncio.apply()</st>` <st c="7467">applies the necessary patches
    to enable nested event loops.</st> <st c="7528">Then, lastly, we import the</st>
    `<st c="7556">gradio</st>` <st c="7562">package and assign it the</st> `<st c="7589">gr</st>`
    <st c="7591">alias</st> <st c="7598">for convenience.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7070">这些行导入</st> `<st c="7094">asyncio</st>` <st c="7101">和</st> `<st
    c="7106">nest_asyncio</st>` <st c="7118">库，并设置事件循环策略。</st> `<st c="7163">asyncio</st>`
    <st c="7170">是一个用于使用协程和事件循环编写并发代码的库。</st> `<st c="7246">nest_asyncio</st>` <st
    c="7258">是一个允许 Jupyter 笔记本中嵌套事件循环的库。</st> <st c="7324">`<st c="7328">asyncio.set_event_loop_policy(asyncio.DefaultEventLoopPolicy())</st>`
    <st c="7391">行将事件循环策略设置为默认策略。</st> `<st c="7447">nest_asyncio.apply()</st>` <st
    c="7467">应用必要的补丁以启用嵌套事件循环。</st> <st c="7528">然后，最后，我们导入</st> `<st c="7556">gradio</st>`
    <st c="7562">包，并将其分配给</st> `<st c="7589">gr</st>` <st c="7591">别名</st> <st c="7598">以方便使用。</st>
- en: <st c="7614">After adding the imports, we</st> <st c="7644">only need to add
    this code at the end of the existing code to set up our</st> <st c="7717">Gradio
    interface:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7614">在添加导入之后，我们</st> <st c="7644">只需要在现有代码的末尾添加此代码来设置我们的</st> <st c="7717">Gradio
    接口：</st>
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="8063">The</st> `<st c="8068">process_question</st>` <st c="8084">function
    is the function that is invoked when you hit that</st> `<st c="8198">gr.Interface</st>`
    <st c="8210">code, but this is the function that is called and processed.</st>
    <st c="8272">The</st> `<st c="8276">process_question</st>` <st c="8292">function
    takes the question you submit as a user as input and processes it using our RAG
    pipeline.</st> <st c="8392">It invokes the</st> `<st c="8407">rag_chain_with_source</st>`
    <st c="8428">object with the given question and retrieves the relevance score,
    final answer, and sources from the result.</st> <st c="8538">The function then
    joins the sources into a comma-separated string and returns the relevance score,
    final answer, and</st> <st c="8655">source list.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8063">该</st> `<st c="8068">process_question</st>` <st c="8084">函数是在你点击那个</st>
    `<st c="8198">gr.Interface</st>` <st c="8210">代码时被调用的函数，但这是被调用并处理的函数。</st> <st
    c="8272">该</st> `<st c="8276">process_question</st>` <st c="8292">函数接收用户提交的问题作为输入，并使用我们的
    RAG 管道进行处理。</st> <st c="8392">它调用</st> `<st c="8407">rag_chain_with_source</st>`
    <st c="8428">对象，并使用给定的问题检索相关性得分、最终答案和来源。</st> <st c="8538">然后该函数将来源合并成一个以逗号分隔的字符串，并返回相关性得分、最终答案和</st>
    <st c="8655">来源列表。</st>
- en: <st c="8667">Next, we will set up an instance of the</st> <st c="8708">Gradio
    interface:</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8667">接下来，我们将设置一个</st> <st c="8708">Gradio 界面</st>的实例：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="9101">The</st> `<st c="9105">demo = gr.Interface(...)</st>` <st c="9129">line
    is where the Gradio magic happens.</st> <st c="9170">It creates a Gradio interface
    using</st> <st c="9205">the</st> `<st c="9210">gr.Interface</st>` <st c="9222">function.</st>
    <st c="9233">The</st> `<st c="9237">fn</st>` <st c="9239">parameter specifies
    the function to be called when the user interacts with the interface, which is
    what we mentioned in the last paragraph, calling</st> `<st c="9388">process_question</st>`
    <st c="9404">and kicking off the RAG pipeline.</st> <st c="9439">The</st> `<st
    c="9443">inputs</st>` <st c="9449">parameter defines the input component of the
    interface, which is</st> `<st c="9515">gr.Textbox</st>` <st c="9525">for entering
    the question.</st> <st c="9553">The</st> `<st c="9557">outputs</st>` <st c="9564">parameter
    defines the output components of the interface, which are three</st> `<st c="9639">gr.Textbox</st>`
    <st c="9649">components for displaying the relevance score, final answer, and
    sources.</st> <st c="9724">The</st> `<st c="9728">title</st>` <st c="9733">and</st>
    `<st c="9738">description</st>` <st c="9749">parameters set the title and description
    of</st> <st c="9794">the interface.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9101">该</st> `<st c="9105">demo = gr.Interface(...)</st>` <st c="9129">行是
    Gradio 魔法发生的地方。</st> <st c="9170">它使用</st> `<st c="9210">gr.Interface</st>` <st
    c="9222">函数创建一个 Gradio 界面。</st> <st c="9233">该</st> `<st c="9237">fn</st>` <st
    c="9239">参数指定当用户与界面交互时调用的函数，这正是我们在上一段中提到的，调用</st> `<st c="9388">process_question</st>`
    <st c="9404">并启动 RAG 管道。</st> <st c="9439">该</st> `<st c="9443">inputs</st>` <st
    c="9449">参数定义了界面的输入组件，用于输入问题的是</st> `<st c="9515">gr.Textbox</st>` <st c="9525">。</st>
    <st c="9553">该</st> `<st c="9557">outputs</st>` <st c="9564">参数定义了界面的输出组件，有三个</st>
    `<st c="9639">gr.Textbox</st>` <st c="9649">组件用于显示相关性得分、最终答案和来源。</st> <st c="9724">该</st>
    `<st c="9728">title</st>` <st c="9733">和</st> `<st c="9738">description</st>`
    <st c="9749">参数设置了界面的标题和描述。</st>
- en: <st c="9808">The only action left to take is to launch</st> <st c="9851">the
    interface:</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9808">剩下的唯一行动就是启动</st> <st c="9851">界面：</st>
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="9901">The</st> `<st c="9906">demo.launch(share=True, debug=True)</st>`
    <st c="9941">line launches the Gradio interface.</st> <st c="9978">The</st> `<st
    c="9982">share=True</st>` <st c="9992">parameter enables the sharing feature of
    Gradio, generating a publicly accessible URL that you can share with others to
    access your interface.</st> <st c="10136">Gradio uses a tunneling service to provide
    this functionality, allowing anyone with the URL to interact with your interface
    without needing to run the code locally.</st> <st c="10301">The</st> `<st c="10305">debug=True</st>`
    <st c="10315">parameter enables debug mode, providing additional information and
    tools for debugging and development.</st> <st c="10420">In debug mode, Gradio
    displays detailed error messages in the browser console if any errors occur during
    the execution of the</st> `<st c="10546">process_question</st>` <st c="10562">function.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9901">这条</st> `<st c="9906">demo.launch(share=True, debug=True)</st>`
    <st c="9941">行启动了Gradio界面。</st> <st c="9978">这个</st> `<st c="9982">share=True</st>`
    <st c="9992">参数启用了Gradio的共享功能，生成一个公开可访问的URL，你可以与他人分享以访问你的界面。</st> <st c="10136">Gradio使用隧道服务来提供此功能，允许任何拥有URL的人与你的界面交互，而无需在本地运行代码。</st>
    <st c="10301">这个</st> `<st c="10305">debug=True</st>` <st c="10315">参数启用了调试模式，提供了额外的信息和工具，用于调试和开发。</st>
    <st c="10420">在调试模式下，如果执行过程中发生错误，Gradio会在浏览器控制台中显示详细的错误消息。</st>
- en: <st c="10572">I consider</st> `<st c="10584">demo.launch(share=True, debug=True)</st>`
    <st c="10619">to be a special line of code compared to all of the other code you’ve
    written in this book.</st> <st c="10712">This is because it does something you
    haven’t seen before; it calls on Gradio to start a local web server to host the
    interface defined by</st> `<st c="10851">gr.Interface(...)</st>`<st c="10868">.
    When you run the cell, you will notice that it continues to run in perpetuity
    until you stop it.</st> <st c="10967">You will also notice that you cannot run
    any other cells without</st> <st c="11032">stopping it.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10572">我认为</st> `<st c="10584">demo.launch(share=True, debug=True)</st>`
    <st c="10619">是这本书中所有其他代码中的一条特殊代码行。</st> <st c="10712">这是因为它做了一些你以前没有看到的事情；它调用Gradio来启动一个本地Web服务器来托管由</st>
    `<st c="10851">gr.Interface(...)</st>`<st c="10868">定义的界面。当你运行这个单元格时，你会注意到它会持续运行，直到你停止它。</st>
    <st c="10967">你还会注意到，除非停止它，否则你不能运行任何其他单元格。</st>
- en: '<st c="11044">There is one more optional parameter we want to make you aware
    of: the auth parameter.</st> <st c="11132">You add it to the</st> `<st c="11150">demo.launch</st>`
    <st c="11161">function</st> <st c="11171">like this:</st>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11044">还有一个我们想要让你注意的附加参数：auth参数。</st> <st c="11132">你可以像这样将其添加到</st>
    `<st c="11150">demo.launch</st>` <st c="11161">函数</st> <st c="11171">中：</st>
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="11245">This will add a simple level of authentication, in case you are
    sharing your application publicly.</st> <st c="11345">It generates an extra interface
    that requires the username (</st>`<st c="11405">admin</st>`<st c="11411">) and
    password (</st>`<st c="11428">pass1234</st>`<st c="11437">) that you add to it.</st>
    <st c="11460">Change</st> `<st c="11467">admin/pass1234</st>` <st c="11481">to
    whatever you want, but definitely change it!</st> <st c="11530">Share those credentials
    with only the users you want to have access to your RAG application.</st> <st
    c="11623">Keep in mind that this is not highly secure, but it does serve at least
    a baseline purpose to limit</st> <st c="11723">user access.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11245">这将添加一个简单的认证级别，以防你公开分享你的应用程序。</st> <st c="11345">它生成一个额外的界面，需要你添加的用户名（</st>`<st
    c="11405">admin</st>`<st c="11411">）和密码（</st>`<st c="11428">pass1234</st>`<st
    c="11437">）。</st> <st c="11460">将</st> `<st c="11467">admin/pass1234</st>` <st
    c="11481">改为你想要的任何内容，但绝对要更改它！</st> <st c="11530">仅将这些凭据分享给那些你想让他们访问你的RAG应用程序的用户。</st>
    <st c="11623">请记住，这并不非常安全，但它至少提供了一个基本的目的，以限制</st> <st c="11723">用户访问。</st>
- en: '<st c="11735">Now, you have an active web</st> <st c="11764">server that takes
    input, processes it, and will react and return new interface elements based on
    the code you have written for your Gradio interface.</st> <st c="11914">This is
    something that used to require significant expertise in web development, but now
    you can have it up and running in minutes!</st> <st c="12046">This lets you focus
    on what you want to focus on: writing the code for your</st> <st c="12122">RAG
    application!</st>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11735">现在，你有一个活跃的Web</st> <st c="11764">服务器，它可以接收输入，处理它，并根据你为你的Gradio界面编写的代码来响应和返回新的界面元素。</st>
    <st c="11914">这曾经需要显著的Web开发专业知识，但现在你可以在几分钟内将其设置并运行！</st> <st c="12046">这使得你可以专注于你想要关注的事情：编写你的</st>
    <st c="12122">RAG应用程序的代码！</st>
- en: <st c="12138">Once you have run the Gradio code in this cell, the interface
    becomes interactive, allowing users to enter questions in the input textbox.</st>
    <st c="12278">As we described previously, when a user submits a question, the</st>
    `<st c="12342">process_question</st>` <st c="12358">function is called with the
    user’s question as input.</st> <st c="12413">The function invokes a RAG pipeline,</st>
    `<st c="12450">rag_chain_with_source</st>`<st c="12471">, with the question and
    retrieves the relevance score, final answer, and sources from the result.</st>
    <st c="12569">It then returns the relevance score, final answer, and source list.</st>
    <st c="12637">Gradio updates the output textboxes with the returned values, displaying
    the relevance score, final answer, and sources to</st> <st c="12760">the user.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12138">一旦你在该单元中运行了 Gradio 代码，界面就会变得交互式，允许用户在输入框中输入问题。</st> <st c="12278">正如我们之前所描述的，当用户提交一个问题，</st>
    `<st c="12342">process_question</st>` <st c="12358">函数会以用户的问题作为输入被调用。</st> <st
    c="12413">该函数调用一个 RAG 流程，</st> `<st c="12450">rag_chain_with_source</st>`<st c="12471">，并使用问题检索相关性得分、最终答案和来源。</st>
    <st c="12569">然后它返回相关性得分、最终答案和来源列表。</st> <st c="12637">Gradio 会用返回的值更新输出文本框，向用户显示相关性得分、最终答案和来源。</st>
- en: <st c="12769">The interface remains active and responsive until the cell execution
    completes or until</st> `<st c="12858">gr.close_all()</st>` <st c="12872">is called
    to close all active</st> <st c="12903">Gradio interfaces.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12769">界面保持活跃和响应，直到单元执行完成或直到</st> `<st c="12858">gr.close_all()</st>`
    <st c="12872">被调用以关闭所有活动的</st> <st c="12903">Gradio 界面。</st>
- en: <st c="12921">Ultimately, when you run this notebook cell with Gradio code,
    you will end up with an interface that looks like</st> *<st c="13034">Figure 6</st>**<st
    c="13042">.1</st>*<st c="13044">. You can display the Gradio interface right in
    your notebook, as well as on a full web page from a link that will be provided
    when you run</st> <st c="13184">the cell:</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12921">最终，当你使用 Gradio 代码运行这个笔记本单元时，你将得到一个看起来像</st> *<st c="13034">图 6</st>**<st
    c="13042">.1</st>*<st c="13044">. 的界面。你可以在笔记本中直接显示 Gradio 界面，也可以在运行</st> <st c="13184">单元时提供的链接的完整网页上显示。</st>
- en: '![Figure 6.1 – Gradio interface](img/B22475_06_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – Gradio 界面](img/B22475_06_01.jpg)'
- en: <st c="13341">Figure 6.1 – Gradio interface</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13341">图 6.1 – Gradio 界面</st>
- en: <st c="13370">We have pre-filled this question:</st> `<st c="13405">What are
    the advantages of using RAG?</st>`<st c="13442">. However, you can change that
    question and ask something else.</st> <st c="13506">As we discussed in the last
    chapter, if it is not relevant to the contents of the database, the LLM should
    respond with</st> `<st c="13626">I don't know</st>`<st c="13638">. We encourage
    you to try it out with both relevant and irrelevant questions!</st> <st c="13716">See
    if you can find</st> <st c="13736">a situation that does work as expected to improve
    your</st> <st c="13791">debugging skills.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13370">我们已经预先填充了这个问题：</st> `<st c="13405">使用 RAG 的优点是什么？</st>`<st c="13442">。然而，你可以更改这个问题并询问其他内容。</st>
    <st c="13506">正如我们在上一章所讨论的，如果它与数据库的内容不相关，LLM 应该响应</st> `<st c="13626">我不知道</st>`<st
    c="13638">。我们鼓励你尝试使用相关和不相关的问题来测试它！</st> <st c="13716">看看你是否能找到一个按预期工作的场景来提高你的</st>
    <st c="13791">调试技能。</st>
- en: <st c="13808">Above this interface in your notebook, you will likely see text
    that looks similar</st> <st c="13892">to this:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13808">在你的笔记本中，这个界面上方你可能会看到类似</st> <st c="13892">以下</st> 的文本：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="14135">Clicking on that link should provide you with a view of the interface
    in its own browser window!</st> <st c="14233">It will look just like</st> *<st
    c="14256">Figure 6</st>**<st c="14264">.1</st>*<st c="14266">, but it will take
    up the entire</st> <st c="14299">browser window.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14135">点击该链接应该会在自己的浏览器窗口中提供界面的视图！</st> <st c="14233">它看起来就像</st> *<st
    c="14256">图 6</st>**<st c="14264">.1</st>*<st c="14266">，但它将占据整个</st> <st c="14299">浏览器窗口。</st>
- en: <st c="14314">Hitting the</st> `<st c="14450">result = rag_chain_with_source.invoke(question)</st>`
    <st c="14497">and returning a response after waiting a few moments.</st> <st c="14552">The
    resulting interface should look similar to</st> *<st c="14599">Figure 6</st>**<st
    c="14607">.2</st>*<st c="14609">:</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14314">点击</st> `<st c="14450">result = rag_chain_with_source.invoke(question)</st>`
    <st c="14497">并在等待几秒钟后返回一个响应。</st> <st c="14552">生成的界面应该看起来类似于</st> *<st c="14599">图
    6</st>**<st c="14607">.2</st>*<st c="14609">：</st>
- en: '![Figure 6.2 – Gradio interface with response](img/B22475_06_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Gradio 响应界面](img/B22475_06_02.jpg)'
- en: <st c="15535">Figure 6.2 – Gradio interface with response</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15535">图6.2 – 带有响应的Gradio界面</st>
- en: <st c="15578">Let’s talk about a few things that are happening in this interface
    when the response comes back from the LLM.</st> <st c="15689">It starts with the
    relevancy score, which is what we added in</st> [*<st c="15751">Chapter 5</st>*](B22475_05.xhtml#_idTextAnchor095)
    <st c="15760">when using an LLM to determine the relevancy of the question as
    a security measure to block prompt injections.</st> <st c="15872">In an application
    that you present to your users, this likely will not be displayed, but it is shown
    here as an example of showing additional information alongside your</st> <st c="16040">LLM
    response.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15578">当LLM返回响应时，让我们谈谈在这个界面中发生的一些事情。</st> <st c="15689">它从相关性得分开始，这是我们添加在</st>
    [*<st c="15751">第五章</st>*](B22475_05.xhtml#_idTextAnchor095) <st c="15760">中，当使用LLM来确定问题的相关性作为安全措施以阻止提示注入时。</st>
    <st c="15872">在你向用户展示的应用程序中，这很可能不会显示，但在这里作为展示你LLM响应旁边额外信息的示例。</st> <st c="16040">LLM响应。</st>
- en: <st c="16054">Speaking of the LLM response,</st> **<st c="16085">Final Answer</st>**
    <st c="16097">from ChatGPT 4 was already formatted in a way that it displays with
    markup.</st> <st c="16174">Gradio will automatically use the line breaks from
    that markup and display the text, accordingly, splitting up the paragraphs in</st>
    <st c="16303">this case.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16054">说到LLM响应，</st> **<st c="16085">最终答案</st>** <st c="16097">来自ChatGPT
    4已经格式化为带有标记的方式显示。</st> <st c="16174">Gradio将自动使用该标记的换行符并相应地显示文本，在这种情况下，将段落分割。</st>
    <st c="16303">。</st>
- en: <st c="16313">Lastly, the sources are a list of four sources, indicating there
    were four sources returned in the retriever.</st> <st c="16424">This comes from
    the code we set up in</st> [*<st c="16462">Chapter 3</st>*](B22475_03.xhtml#_idTextAnchor056)
    <st c="16471">when we added the ability to carry the sources of the retrieved
    results forward in the metadata so that we have it available for display in the
    UI.</st> <st c="16620">We are finally seeing the results of this effort here in</st>
    [*<st c="16677">Chapter 6</st>*](B22475_06.xhtml#_idTextAnchor114)<st c="16686">,
    now that we have a UI to show!</st> <st c="16719">You may have noticed that all
    four sources are the same.</st> <st c="16776">This is a result of this being a
    small example, where we only pull in one source</st> <st c="16857">of data.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，来源是一个包含四个来源的列表，表明检索器返回了四个来源。</st> <st c="16424">这来自于我们在</st> [*<st c="16462">第三章</st>*](B22475_03.xhtml#_idTextAnchor056)
    <st c="16471">中设置的代码，当时我们增加了在元数据中携带检索结果来源的能力，以便我们在UI中显示。</st> <st c="16620">现在我们终于在这里看到了这个努力的成果</st>
    [*<st c="16677">第六章</st>*](B22475_06.xhtml#_idTextAnchor114)<st c="16686">，因为我们现在有一个UI可以展示了！</st>
    <st c="16719">你可能已经注意到，所有四个来源都是相同的。</st> <st c="16776">这是由于这是一个小示例，我们只拉入了一个数据来源</st>
    <st c="16857">。</st>
- en: <st c="16865">In most applications, you will likely</st> <st c="16904">pull
    in many more sources of information to your data, and there will be more sources
    listed in that list.</st> <st c="17011">If you add more sources of data to this
    code that are relevant to the question asked, you should see them appear in this
    list</st> <st c="17137">of sources.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16865">在大多数应用程序中，你可能会</st> <st c="16904">将更多的信息来源拉入你的数据中，并且在该列表中会有更多的来源。</st>
    <st c="17011">如果你向此代码添加更多与所提问题相关的数据来源，你应该会看到它们出现在这个来源</st> <st c="17137">列表中。</st>
- en: <st c="17148">Summary</st>
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="17148">摘要</st>
- en: <st c="17156">In this chapter, we went through a practical guide on creating
    interactive applications using RAG and Gradio as the UI.</st> <st c="17277">We
    covered setting up the Gradio environment, integrating RAG models, and creating
    a user-friendly interface that allows users to interact with the RAG system like
    a typical web application.</st> <st c="17468">Developers can quickly prototype
    and deploy RAG-powered applications, enabling end users to interact with RAG pipelines
    in</st> <st c="17591">real time.</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17156">在本章中，我们介绍了一个使用RAG和Gradio作为UI创建交互式应用的实用指南。</st> <st c="17277">我们涵盖了设置Gradio环境、集成RAG模型以及创建一个用户友好的界面，使用户能够像典型Web应用一样与RAG系统交互。</st>
    <st c="17468">开发者可以快速原型设计和部署RAG驱动的应用，使最终用户能够实时与RAG管道交互。</st> <st c="17591">。</st>
- en: <st c="17601">We also discussed the benefits of using Gradio, such as its open
    source nature, integration with popular machine learning frameworks, and collaboration
    features and Gradio’s integration with Hugging Face, which provides resources
    for the generative AI community, including the ability to host Gradio demos permanently
    and for free using Hugging</st> <st c="17947">Face Spaces.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17601">我们还讨论了使用Gradio的好处，例如其开源性质、与流行机器学习框架的集成、协作功能以及Gradio与Hugging Face的集成，后者为生成式AI社区提供资源，包括使用Hugging
    Face Spaces永久和免费托管Gradio演示的能力。</st>
- en: <st c="17959">With the code lab, we learned how to add a Gradio interface to
    a RAG application.</st> <st c="18042">We created the Gradio interface using</st>
    `<st c="18080">gr.Interface</st>`<st c="18092">, specifying the input and output
    components, title, and description.</st> <st c="18162">We launched the interface
    with</st> `<st c="18193">demo.launch()</st>`<st c="18206">, which starts a local
    web server to host the interface.</st> <st c="18263">This involved creating a</st>
    `<st c="18288">process_question</st>` <st c="18304">function that invokes the
    RAG pipeline with the user’s question and retrieves the relevance score, final
    answer, and sources from the result.</st> <st c="18447">This process reflects
    on the Gradio interface, allowing users to enter questions and receive the relevance
    score, final answer, and sources returned by the</st> <st c="18603">RAG system.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17959">通过代码实验室，我们学习了如何将Gradio界面添加到RAG应用中。</st> <st c="18042">我们使用</st>
    `<st c="18080">gr.Interface</st>`<st c="18092">创建Gradio界面，指定输入和输出组件、标题和描述。</st>
    <st c="18162">我们使用</st> `<st c="18193">demo.launch()</st>`<st c="18206">启动界面，该命令启动一个本地Web服务器以托管界面。</st>
    <st c="18263">这涉及到创建一个</st> `<st c="18288">process_question</st>` <st c="18304">函数，该函数调用RAG管道处理用户的问题，并从结果中检索相关性得分、最终答案和来源。</st>
    <st c="18447">这个过程反映了Gradio界面，使用户能够输入问题并接收由RAG系统返回的相关性得分、最终答案和来源。</st>
- en: <st c="18614">The chapter also discussed how the sources are carried forward
    from the retriever and displayed in the UI, showcasing the effort put into adding
    this functionality in</st> <st c="18782">previous chapters.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18614">本章还讨论了如何将来源从检索器传递到UI中显示，展示了在前面章节中添加此功能所付出的努力。</st>
- en: <st c="18800">This was just an introduction to Gradio though.</st> <st c="18849">We
    encourage you to go to the Gradio website (</st>[<st c="18895">https://www.gradio.app/</st>](https://www.gradio.app/)<st
    c="18919">) and walk through their</st> **<st c="18945">Quickstart</st>** <st
    c="18955">guide and their documentation to learn all the other important functionality
    their</st> <st c="19039">platform provides.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18800">这只是对Gradio的一个简单介绍。</st> <st c="18849">我们鼓励您访问Gradio网站（</st>[<st
    c="18895">https://www.gradio.app/</st>](https://www.gradio.app/)<st c="18919">）并浏览他们的</st>
    **<st c="18945">快速入门</st>** <st c="18955">指南和文档，以了解他们平台提供的其他重要功能。</st>
- en: <st c="19057">In the next chapter, we will explore the critical role that vectors
    and vector stores play in enhancing</st> <st c="19162">RAG systems.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19057">在下一章中，我们将探讨向量和向量存储在增强RAG系统中所扮演的关键角色。</st>
