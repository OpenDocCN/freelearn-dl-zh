# *第17章*：使用手机和Python控制机器人

我们一直在编程的机器人有许多行为，但当你运行其中一些时，它们会导致机器人在房间的另一边停止。你可以尝试编写代码将其送回，但这可能很复杂。我们还有一个很棒的摄像头，可以提供一些视觉反馈，显示机器人正在做什么。难道不是很好奇有时可以控制并驾驶机器人吗？

我们一直在通过**Secure Shell**（**SSH**）终端发送命令来驾驶我们的机器人，但如果可以通过菜单启动命令，这将使机器人更加有趣和舒适地进行演示。我们可以在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”中制作的Web**应用程序编程接口**（**API**）代码的基础上进行构建。

在本章中，我们将了解如何创建一个菜单系统来选择为手机设计的操作。然后我们将使用触摸表面构建一个控制系统，摄像头在视野中。你将了解为手机准备的Web应用程序，并控制机器人。

本章我们将涵盖以下主题：

+   当语音控制不起作用时——为什么我们需要驾驶

+   菜单模式——选择你的机器人行为

+   选择控制器——我们将如何驾驶机器人，以及为什么

+   为远程驾驶准备Raspberry Pi——启动基本驾驶系统

+   使机器人完全可通过手机操作

+   使菜单在Pi启动时启动

# 技术要求

对于本章，你需要以下物品：

+   配置好摄像头并从上一章获取代码的Raspberry Pi机器人

+   一种带Wi-Fi的手机等触摸屏设备

+   无线网络

本章的GitHub代码位于[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter17](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter17)。

使用`0_starting_point`文件夹查找上一章的完整代码，以及GitHub上的`full_system`文件夹以获取本章的完整代码。

查看以下视频以查看代码的实际操作：[https://bit.ly/2Kb7rp8](https://bit.ly/2Kb7rp8)

# 当语音控制不起作用时 – 为什么我们需要驾驶

在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”，我们构建了一个Mycroft系统来启动行为。如果你尝试构建意图让机器人及时停止或向左或向右行驶，你可能已经注意到，即使是最清晰的说话也需要一些时间来响应。

语音控制也仅在安静的环境中真正有效。如果你的机器人在外面（你希望将其驶往某处），这就不太有用。

Mycroft完全依赖于能够访问互联网。对于机器人和控制器来说，有一个小型的共享网络是一回事；但总是需要互联网访问则是另一回事，当你不在家、学校或实验室时，这可能会变得很棘手。

使用SSH会话登录到机器人，然后输入命令来启动和停止行为，在测试阶段效果良好，但可能会很慢且繁琐。在演示条件下，误输入命令或只是重新启动SSH会话都会很耗时。

针对手机的目标浏览器应用可以响应，让你能够紧密控制机器人的动作。在有本地网络的情况下，它不需要外部互联网访问。你可以使用它来在行为运行后停止机器人并将其开回你身边，也可以用来停止错误的行为。经过一些思考，它还可以用来提供有用的——或者仅仅是有趣的——关于你的机器人正在做什么的反馈。

# 菜单模式 - 选择你的机器人行为

我们的书介绍了一系列机器人行为，并邀请你创建更多。我们讨论了SSH启动机器人程序可能会很繁琐——甚至只是记住你有的选项或按下*Ctrl* + *C*组合来停止都可能会让人沮丧。

在本节中，我们将创建一个菜单系统来选择它们。一种方便且适合手机的方式是将它提供给手机的浏览器，因此我们采用了这种方法来处理我们的机器人。我们还将使用桌面浏览器来测试此代码。

我们可以在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)中“远程启动行为”部分的系统中扩展，添加**用户界面**（**UI**）。我们将使用模板制作此UI，其中一些占位符将由代码替换。

让我们看一下以下图表，看看这个系统将如何工作：

![](img/B15660_17_01.jpg)

图17.1 – 控制服务器和菜单系统的工作方式

*图17.1*显示了系统的概述。以下是它是如何工作的：

1.  **客户端浏览器**（手机或电脑）通过**Wi-Fi**向机器人上的**网络服务器**发送页面请求以显示页面。

1.  **网络服务器**使用**机器人模式**来获取模式列表：它可以启动的脚本列表。

1.  **网络服务器**将此模式列表发送到**模板**以将其渲染成菜单页面，并将渲染后的菜单页面发送给用户。

1.  在浏览器中，当你触摸或点击页面中的菜单项链接时，它们会向**网络服务器**发送控制请求。

1.  向**机器人模式**系统发送`run`和`stop`命令。

1.  **机器人模式**系统启动/停止行为脚本。

1.  **控制服务器**向**客户端浏览器**发送状态信息，表示它已被处理。

让我们先扩展脚本（模式）列表以及系统如何处理它们。

## 管理机器人模式

我们将重新审视在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”中编写的代码，扩展要运行的模式列表，并添加菜单配置。

让我们扩展我们的模式系统所知道的项目数量，如下所示：

1.  打开名为`robot_modes.py`的文件。

1.  在此文件中找到`mode_config`变量。我们可以通过以下代码片段扩展它，添加更多行为：

    [PRE0]

1.  在`mode_config`变量之后，我们添加一个配置菜单的列表。顺序将与屏幕上的菜单项匹配。每个项目都有一个`mode_name`设置——与`mode_config`变量中的简短缩略名匹配，以及`text`——菜单选项的易读标签，如下面的代码片段所示：

    [PRE1]

    如果我们想在菜单中添加一个行为，我们必须将其添加到`menu_config`和`mode_config`变量中。

1.  为了允许菜单用户在不按下`run`方法的情况下选择新的模式，我们可以通过停止任何现有进程来处理这个问题，如下所示：

    [PRE2]

    此文件将作为配置文件使用，你可以扩展它来运行其他代码。我们现在可以测试一下。

1.  将`robot_modes.py`上传到机器人。你应该已经上传了[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”的`control_server.py`文件。

1.  在Pi上使用`python3 control_server.py`运行此代码。

1.  正如我们在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”中看到的，我们将使用`curl`命令来发送请求，如下所示：

    [PRE3]

    这应该会启动机器人上的**发光二极管**（**LEDs**）闪烁。

1.  让我们改变行为——这将停止当前行为并启动一个新的行为。运行以下代码：

    [PRE4]

    LED应该停止闪烁，假设电机已经打开，头部应该开始移动。

1.  让我们通过运行以下代码来停止机器人：

    [PRE5]

我们在`robot_modes.py`中添加了一些额外的模式和配置来描述这些模式，并进行了测试。让我们检查是否有任何问题。

## 故障排除

当对菜单服务器的请求失败时，它可以在响应中输出错误代码。在我们的系统中，我们只使用了以下三个错误代码：

+   `200`——这意味着服务器认为一切正常。可能仍然存在逻辑问题，但并未导致失败。

+   `404`——当服务器找不到路由时显示。这意味着你可能在你发出的请求或服务器代码中的路由器中有一个拼写错误。检查它们是否匹配并再次尝试。

+   `500`——这意味着服务器以某种方式失败了。这通常伴随着服务器上的回溯/异常。这可以被视为一个正常的Python错误。

现在我们已经准备好了模式配置列表，我们需要网络服务来显示它。

## 网络服务

在 [*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用 Mycroft 与机器人进行语音通信”，我们已经在 `control_server.py` Flask 网络服务器中连接了 `robot_modes.py`。我们在 [*第13章*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283)，“机器人视觉——使用 Pi 摄像头和 OpenCV”，使用了 Flask 来渲染带有视频框的模板。在本节中，我们将创建一个菜单模板以显示用户的选项。

让我们先进行必要的更改以渲染模板，如下所示：

1.  打开 `control_server.py`。

1.  将 Flask 的导入扩展到包括 `render_template`，如下所示：

    [PRE6]

1.  由于我们将更改样式表，我们需要停止持有过时缓存的表单的设备。我们可以通过向所有响应添加标题来实现这一点，如下所示：

    [PRE7]

1.  现在我们需要添加显示我们菜单的路由。我们将创建一个名为 `menu.html` 的模板，它使用 `menu_config` 变量来显示。我们的大部分模式都需要这个。让我们添加渲染模板的代码，如下所示：

    [PRE8]

现在我们已经有了渲染模板的代码，它是基于我们已有的处理 `run` 和 `stop` 请求的代码。然而，在我们能够运行此服务之前，我们需要提供模板，即 `menu.html`。

## 模板

我们的 HTML 模板定义了我们的显示，并让我们将机器人菜单的外观与处理控制系统的方法分开。此模板结合了 [*第13章*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283)，“机器人视觉——使用 Pi 摄像头和 OpenCV” 和 [*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，“Python 中的摄像头跟随线” 中看到的 HTML，以及 [*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用 Mycroft 与机器人进行语音通信” 中的 `templates` 文件夹——我们将在这里添加我们的菜单模板。我们可以进一步美化此模板；现在，我们将保持其简单性。

创建一个名为 `templates`/`menu.html` 的文件，然后按照以下步骤进行：

1.  我们的模板从设置页面标题的标题开始，并使用我们之前看到的相同的 jQuery 工具，如下面的代码片段所示：

    [PRE9]

1.  我们模板的主体有 `My Robot Menu` 标题。你可以随意将其更改为你的机器人名称。代码如下所示：

    [PRE10]

1.  接下来，有一个用于消息的空间；现在它是空的，正如你在这里可以看到的：

    [PRE11]

1.  下一个部分是一个列表——即菜单本身。我们使用 `<ul>` 标签然后是一个 `for` 循环，它为每个菜单项创建一个带有链接的列表项。双大括号 `{{ }}` 用于包围一个占位符，当运行时将被替换。它使用 `mode_name` 设置和 `text` 来创建该链接，将 `/run` 与模式名称结合，如下面的代码片段所示：

    [PRE12]

1.  在关闭我们的列表之前，我们需要添加一个额外的菜单项——**停止**按钮，如下所示：

    [PRE13]

1.  我们在 JavaScript 代码中讨论了处理 `run` 动作。以下代码发送数据到 Web 服务器并从响应中更新消息的 POST 请求。我们需要将其放在 `<script>` 标签中，如下所示：

    [PRE14]

1.  现在，我们可以像这样关闭我们的 HTML 文档：

    [PRE15]

模板如这样的好处是，您可以在浏览器中预览此代码，而无需服务器，并理解它应该如何看起来。以下截图显示了它在预览模式下的样子：

![](img/B15660_17_02.jpg)

图 17.2 – 预览模板

当您查看预览，如图 *图 17.2* 所示，模板占位符会显示，因为浏览器不知道如何渲染它们。

您需要运行应用才能正确渲染。

## 运行它

将 `robot_modes.py` 和 `control_server.py` 文件上传到机器人，然后是 `templates` 文件夹。在 Raspberry Pi 上，通过 SSH，您可以使用以下命令启动它：

[PRE16]

您现在可以将浏览器指向您的机器人（`http://myrobot.local:5000/`）以查看菜单。以下截图显示了它应该看起来是什么样子：

![](img/B15660_17_03.jpg)

图 17.3 – 浏览器中的我的机器人菜单

*图 17.3* 现在显示了渲染的列表。我们现在看到所有菜单项而不是模板占位符。您应该能够点击一个模式并看到机器人启动该行为。点击 `robot_modes.py` 代码将发送相当于 *Ctrl* + *C* 动作到运行的行为脚本，使其停止。

当您点击一个行为或停止时，它会在消息区域显示输出，如图下所示截图：

![](img/B15660_17_04.jpg)

图 17.4 – 停止消息

*图 17.4* 再次显示了菜单。我已经点击了**停止**按钮，因此菜单显示了**停止**响应消息。

注意以下代码片段中行为输出的 `print` 语句出现在 Web 服务器控制台中：

[PRE17]

您需要在 Pi 上按下 *Ctrl* + *C* 来退出此菜单服务器应用。

重要提示

这个微型的机器人 Web 应用没有安全机制、身份验证或密码。这超出了本书的范围，但如果您计划在共享 Wi-Fi 上使用它，这是一个值得进一步研究的严肃考虑。 

有方法可以将脚本的控制台输出放到页面上。我建议查看 *进一步阅读* 部分的附加阅读推荐，以了解 Flask。

## 故障排除

希望这一切都能正常工作，但如果您有任何问题，请尝试以下步骤：

+   输出日志显示了来自 Web 系统的返回代码。您可以使用这些状态代码——如您之前所见——来排除故障。

+   `200`—系统认为一切正常。如果它未能运行某些内容，请检查 `run` 函数。

+   `404`—未找到。您是否匹配了路由？

+   `500`—您也应该看到与此相关的 Python 错误。

+   如果渲染显示 `{ item.text }`，则需要使用双大括号，以便模板系统正常工作。

+   如果你看到像`jinja2.exceptions.TemplateSyntaxError: unexpected '<'`这样的错误，那么你需要验证你是否正确地输出了前面的模板——你很可能会遗漏了一个闭合的大括号（`}`）。

你现在有一个菜单系统来启动不同的机器人行为并停止它们。你可以将手机指向它——尽管它目前还不是特别适合手机。我们只是刚刚触及了这一点，这个系统相当基础。

我们将开始查看一个更有趣的手机界面来控制机器人，但我们可以先看看除了智能手机之外的其他选项。

# 选择控制器——我们将如何驾驶机器人，以及为什么

我们希望能够用手持无线设备来控制我们的机器人。给机器人拖一根线没什么意义。在看过我们的机器人在[*第 7 章*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131)，“使用 Python 驱动和转向 – 移动电机”中的驾驶方式后，我们将需要一个直接影响轮子的控制系统。

实现这一点的办法之一是使用蓝牙手柄。市场上有很多这样的手柄，可能需要专业的驱动程序来读取。蓝牙有时会在不合适的时候断开配对。

一些手柄使用定制的无线扩展器；这些比蓝牙更可靠，但扩展器在机器人上不太合适。

然而，你口袋里已经有一个手持设备了：你的手机。它有一个触摸屏，能够读取手指动作。通过一些正确的代码，你可以在控制器条之间显示视频，创建一种可以驾驶并观察的机器人*潜望镜*（在相机上驾驶相当困难——比从上方驾驶更难）。我们已经为机器人构建了可以通过 Wi-Fi 访问的网页应用，而大多数手机都可以连接到那个应用。因此，我们不会出去买一个新的手柄，而是将制作一个手机可以访问的网页应用来驾驶机器人并看到机器人的视角。

## 设计和概述

要制作一个手机网页应用，我们需要对如何期望它工作有一些设计。这个设计可能只是一个在纸条上用笔画的草图，或者使用绘图工具来获得专业的外观。下一张截图显示了这个的原型：

![](img/B15660_17_05.jpg)

图 17.5 – 驾驶网页应用的屏幕截图

*图 17.5* 中的原型显示了横幅模式下的手机屏幕。屏幕顶部有一个**退出**按钮，我们可以将其设置为在指示应用退出后转到我们的菜单。

屏幕中间有一个来自机器人的视频流，使用了[*第 13 章*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283)，“机器人视觉 – 使用 Pi 相机和 OpenCV”中“构建 Raspberry Pi 相机流应用”的机制。左右两侧有滑块。下一张截图显示了它是如何工作的：

![](img/B15660_17_06.jpg)

图 17.6 – 滑块返回中间行为

*图17.6* 展示了滑动机制。与模拟摇杆类似，您可以通过触摸将滑块拖动到其轨道上的任何位置，并且当松开时，它们会弹回到中间。

注意，它们不会立即回到中间，而是在几帧内动画回到这个位置。我们需要一点数学知识来在我们的代码中实现这一点。

这些滑块让您能够以坦克式（使用摇杆，您可以使用两个模拟摇杆进行此操作）驾驶机器人。每个滑块控制一个电机的速度。虽然这听起来很复杂（不像开车），但通过一点练习，这是一种优雅地驾驶两轮机器人的方式。滑块离中间越远，相关的电机速度越快。我们还将确保如果通信丢失，机器人电机将在一秒后停止。

这种左右速度的控制与您在整本书中一直在使用的相同控制系统，但已经变得交互式。下一张图显示了典型移动所需的一些动作：

![图片](img/B15660_17_07.jpg)

图17.7 – 两个滑块上的常见动作

*图17.7* 中的红色点代表您的拇指触摸屏幕的位置。通过同时向前滑动，机器人将向前行驶，而且您滑得越远，它行驶得越快。向后动作将它们都向后滑动。要旋转机器人，将它们向相反方向滑动。要向前行驶并稍微向左或向右，同时向前滑动，但将右侧滑块稍微抬得比左侧高。您还可以为此方向进行补偿。

我们有一个很好的用户界面设计。为了开始构建这个，我们将规划所需的代码块，并编写使它们在现实世界中工作的代码。

# 为远程驾驶准备Raspberry Pi——启动基本驾驶系统

我们的Raspberry Pi已经能够运行网络服务，使用Flask创建菜单服务器和视频服务器。我们可以使用图像和控制队列使行为与网络服务器交互。我们将重用这些功能。在手机应用中，滑块控制需要智能。下一张图显示了我们的手动驱动系统的各个部分：

![图片](img/B15660_17_08.jpg)

图17.8 – 手动驱动应用系统概述

*图17.8* 中的虚线框显示了代码的运行位置，顶部的虚线框是手机上运行的代码，下方的框是机器人在Raspberry Pi上运行的代码。在虚线框内部，带有实线轮廓的框是代码块或系统，我们的代码将需要它们。在*图17.8* 的底层，**机器人**框接受**停止电机**和**设置电机速度**的调用。这些来自**行为**框，基于超时或来自**Flask Web服务器**的**控制消息队列**。同时，**行为**循环也将从**摄像头**获取**图像帧**，对它们进行编码并将它们推送到**显示帧队列**。

上一个层次是**Flask Web服务器**。该服务器消耗**显示帧队列**，为多部分的**图像流**提供帧。Flask服务器将处理**控制请求**并将它们推送到**控制消息队列**。

**页面脚本**处理**滑块更新**，并使用jQuery库将它们转换为**控制请求**。**滑块小部件**将**触摸**转换为**滑块更新**（它将进行动画转换）。

页面本身使用`img`标签来显示**视频**流，就像之前一样，并放置滑块小部件。**退出**按钮会发出控制请求。

**页面脚本**和**滑块小部件**将需要JavaScript和**层叠样式表**（**CSS**）编程。在我们开始之前，我们需要从[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，*Python中的摄像头跟随线*中获取图像核心，并添加更多功能以将代码发送到浏览器。

## 增强图像应用核心

要构建这个，我们将首先添加一些静态文件链接，并重用我们在[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，*Python中的摄像头跟随线*中使用的图像应用核心。

静态文件不会让机器人做任何事情；系统被动地提供服务。我们将提供JavaScript和CSS，以及jQuery库的本地副本。Flask会自动完成这项工作。

让我们按照以下方式设置静态文件文件夹：

1.  创建一个`static`文件夹。我们将把JavaScript和CSS代码放在这个`static`文件夹中。

1.  我们将制作jQuery库的本地副本。在`static`下创建一个`lib`目录。

1.  从[https://code.jquery.com/jquery-3.5.1.min.js](https://code.jquery.com/jquery-3.5.1.min.js)下载jQuery，按浏览器`lib`文件夹。你应该有一个`static/lib/jquery-3.5.1.min.js`文件。

1.  在`image_app_core.py`文件中，我们还需要使用缓存文件来停止它，以便它重新加载我们的CSS和JavaScript文件，如下所示：

    [PRE18]

应用核心现在有一个可以离线使用的jQuery静态副本，所以我们的手机不需要依赖良好的信号与机器人通信。

## 编写手动驾驶行为

接下来我们需要的是行为。它基于之前代码中看到的[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，*Python中的摄像头跟随线*的概念，通过控制消息改变电机速度和纯视频输出。

这个系统将有一个超时——如果1秒内没有控制消息到达，它将停止驾驶。看到机器人开到远处或桌子上是很令人沮丧的，所以如果没有任何有意义的事情发生，它将恢复停止。

让我们按照以下方式构建它：

1.  以类似以下方式开始一个名为`manual_drive.py`的文件，导入摄像头和控制：

    [PRE19]

1.  我们可以声明我们想要的超时阈值是多少秒，如下面的代码片段所示：

    [PRE20]

1.  我们将创建一个`ManualDriveBehavior`类。在这个类中，我们将存储一个`robot`对象并跟踪时间，如下面的代码片段所示：

    [PRE21]

1.  接下来，构建这个行为的控制部分。它为每个指令重置最后时间。代码可以在下面的代码片段中看到：

    [PRE22]

1.  我们的代码在`handle_instruction`中处理指令。这个指令是一个字典，其中指令名称和参数是其成员。我们可以检查这个命令是否是`set_left`或`set_right`，如下面的代码片段所示：

    [PRE23]

1.  我们还需要处理`exit`命令，如下所示：

    [PRE24]

1.  至少在测试时，知道我们是否有未知的指令会有用。让我们通过抛出异常来处理这种情况，如下所示：

    [PRE25]

1.  我们的应用程序还需要创建一个显示，将帧放在服务器图像队列中，如下所示：

    [PRE26]

1.  该行为有一个`run`方法来执行设置和主循环。我们首先将俯仰设置成直视前方，预热相机，并停止伺服电机，如下所示：

    [PRE27]

1.  然后，我们遍历来自相机的帧并处理控制指令，如下所示：

    [PRE28]

1.  最后，我们根据超时自动停止，如下所示：

    [PRE29]

1.  我们添加顶层代码来创建和启动组件，如下所示：

    [PRE30]

1.  我们仍然想确保在退出或遇到错误时停止服务器，所以我们运行以下代码：

    [PRE31]

行为后端已完成，但需要一个模板来查看它，以及运行在手机上的样式和代码。

## 模板（网页）

模板是我们放置滑块和部分处理它们的代码的地方。

让我们开始，如下所示：

1.  创建一个`templates/manual_drive.html`文件。从HTML前缀开始，如下所示：

    [PRE32]

1.  我们希望显示适应手机屏幕，根据显示大小调整。我们也不希望用户的触摸交互意外地缩放显示。这一行代码告诉浏览器这是我们的意图：

    [PRE33]

1.  我们希望对这个（以及可能的其他界面）进行样式设计。为此，我们使用一个`display.css`样式表，如下面的代码片段所示：

    [PRE34]

1.  我们将使用jQuery库来使事物交互，并构建一个触摸滑块系统。这些是HTML的导入等效：

    [PRE35]

    我们将在这个文件中放置一个非常具体的样式。其余的来自样式表。我们希望这个行为的视图占据整个屏幕，并且不滚动。代码如下所示：

    [PRE36]

1.  头部以一个标题结束，该标题将显示在标签页的顶部，如下所示：

    [PRE37]

1.  我们现在从第一个滑块开始构建主体；我们使用`svg`标签来定义它，我们将用它来制作滑块轨迹，如下面的代码片段所示：

    [PRE38]

1.  在容器内部，我们将画一个圆。这个圆需要一个半径`r`，我们可以用视图框单位给出。中心在两个方向上都是0。这个代码如下所示：

    [PRE39]

    圆的颜色将来自样式表。

1.  接下来，我们需要一个`退出`链接来完成行为。它有一个类和ID来定义其样式，如下面的代码片段所示：

    [PRE40]

1.  接下来，我们有我们的视频块。视频的`img`标签包含在一个`div`标签内，以保持我们的视频在任何尺寸屏幕上的比例，同时允许它调整大小以适应空间，如下面的代码片段所示：

    [PRE41]

1.  右侧的滑块是左侧的重复，只是ID不同。你可以复制并粘贴左侧的代码，更改ID。代码可以在这里看到：

    [PRE42]

1.  我们需要在我们的HTML中添加一些JavaScript代码来处理滑块。页面上的代码将滑块代码与我们的图形和电机链接起来。首先，我们声明JavaScript块，如下所示：

    [PRE43]

1.  添加一个函数来发送电机控制到机器人。它接受一个名称（左或右）和一个速度，如下面的代码片段所示：

    [PRE44]

    我们将这个控制指令POST到服务器。

1.  下面的代码必须在页面完成加载后运行；我们想确保前面的JavaScript库已经完全加载。jQuery有一个特殊函数`$()`，当页面完成加载时，它会运行传递给它的任何函数，如下面的代码片段所示：

    [PRE45]

1.  我们需要将退出按钮链接到一个POST请求，完成后将转发到菜单，如下面的代码片段所示：

    [PRE46]

1.  我们设置了滑块并将它们与它们的`svg`元素ID和`set_motor`链接起来，以便每次它们改变时都会更新，如下面的代码片段所示：

    [PRE47]

1.  现在，我们通过关闭所有标签来结束我们的页面，如下所示：

    [PRE48]

这个页面没有样式；默认情况下，视频和滑块没有形状、大小或颜色——所以，如果你尝试加载这个，它将显示一个空白页面。我们还没有告诉浏览器我们想在页面上放置什么或使用什么颜色。我们还没有滑块的代码。

我们已经编写了发送退出按钮并将滑块与标签链接的代码。在下一节中，我们将添加一个样式表来使事物可见。

## 样式表

我们现在可以给我们的应用添加一些样式。样式表需要时间来调整和精确设置，所以这只是一个展示它能做什么的例子。如果你认为我的颜色选择很糟糕，请随意替换你自己的；我建议使用w3c颜色，在[https://www.w3schools.com/colors/default.asp](https://www.w3schools.com/colors/default.asp)。你可以使用命名或十六进制（`#1ab3c5`）颜色。

CSS的本质是在页面上选择元素并将样式属性与它们关联。CSS样式部分以一个`#`标记开始。要全面了解CSS选择器，请参阅*进一步阅读*部分。每个部分使用花括号`{}`来界定一个样式部分。一个部分的样式由属性名、一个冒号`:`和一个设置组成。一个分号`;`跟在这些设置之后，以结束每个设置。

让我们定义样式，如下所示：

1.  创建一个`static/display.css`文件来保存这些样式信息。

    我们可以将我们的滑块轨道设置为视口宽度的10%——即屏幕大小的10%。CSS有一个特殊的单位`vw`用于此，还有`vh`用于视口高度的百分比。在*进一步阅读*部分查看关于CSS单位的说明。此代码使用`.slider_track` CSS选择器，它适用于具有该类的所有对象。两个滑块都有这个类，所以这里的更改会影响它们两个。代码如下所示：

    [PRE49]

1.  我们将给滑块轨道添加一个实心蓝色边框和浅蓝色背景，以匹配我们的原型，如下所示：

    [PRE50]

1.  为了样式化勾选标记，即我们在滑块上看到的圆圈，我们可以添加一个淡粉色填充色，就像我们的原型一样，如下所示：

    [PRE51]

1.  接下来，我们想要将滑块（通过它们的ID）定位在左侧和右侧。当制作一个与屏幕原型非常接近的显示时，我们可以使用**绝对定位**和视口百分比来确切地说明事物应该在哪里，如下所示：

    [PRE52]

1.  你现在可以通过上传它，停止运行行为，再次启动，然后重新加载来尝试这个。滑块看起来更好，但退出按钮和视频位置不正确。

1.  让我们使退出按钮更像一个按钮。`.button`下的样式将应用于具有相同类的所有按钮。我们将使其成为一个块——一个使用宽度和高度属性的元素。这个块是视口高度的10%。代码如下所示：

    [PRE53]

1.  然后，我们使用`line-height`和`text-align`将文本居中，然后使用`2em`表示正常文本大小的两倍，如下所示：

    [PRE54]

1.  我们想要移除按钮文本的下划线，这通常是链接中出现的样式。我们还会给它添加一些颜色，一个蓝色背景和白色文本，如下所示：

    [PRE55]

1.  我们使用退出按钮的ID来指定更多关于它的样式。我们将设置其宽度和顶部位置，但使用`auto`边距来居中它，如下所示：

    [PRE56]

    尝试这个，你现在应该能看到退出按钮在正确的位置。

1.  接下来，我们样式化视频。我们希望将视频居中在屏幕上。外部视频元素可以为我们做到这一点，如下所示：

    [PRE57]

1.  然后，我们可以指定内部图像块的定位和大小。我们希望它从屏幕顶部20%的位置开始，使用`vh`单位。`vmin`单位是屏幕最小维度的百分比；它确保这个块永远不会太大，以至于会遮挡两个滑块条。我们使高度自动缩放。我们选择`#video img`来将此样式应用于`video`对象中包含的`img`对象，如下面的代码片段所示：

    [PRE58]

我们的页面已经完全样式化。你现在可以尝试一下，看看它看起来如何。将整个文件夹（包括模板）上传到机器人，然后运行`python3 manual_drive.py`。将桌面浏览器指向`http://myrobot.local:5001/`，用你的机器人的主机名或地址替换，以查看它。桌面浏览器非常适合发现HTML或JavaScript代码中的错误。在撰写本文时，Firefox和Chrome支持在浏览器中模拟移动设备和触摸事件。它应该看起来像以下截图所示的带有真实视频的模拟：

![](img/B15660_17_09.jpg)

图17.9 – 手机上运行的应用程序截图

*图17.9*展示了在真实手机上运行的应用程序。滑块栏目前还没有任何功能。请注意，你可能需要强制浏览器重新加载样式表。

现在我们需要添加滑块代码。

## 创建滑块的代码

滑块需要响应用户的触摸事件，将圆圈移动到触摸位置，并发送一个更新消息来显示这次移动距离中间有多远。当触摸事件停止时，滑块将自动返回中心。JavaScript允许我们在浏览器中运行代码，因此我们将创建一个名为`makeSlider`的JavaScript函数。

首先，我们想看看触摸如何转换为滑块位置和电机速度。以下图表展示了这一点：

![](img/B15660_17_10.jpg)

图17.10 – 从触摸事件到电机位置

我们的滑块在位置上有些复杂性，如图17.10所示。当用户触摸屏幕时，位置以屏幕坐标的形式到达。我们首先需要通过减去滑块的上边坐标来找到它在滑块中的位置。我们需要将这个结果除以滑块的高度，乘以200，然后减去100，以得到视图框位置（与绘制SVG使用的相同系统）。在视图框坐标中，顶部是-100，但为了我们的电机向前移动，我们需要+100，因此我们必须取视图框位置的负值以获得电机速度。

我们的脚本将设置移动滑块所需的数据，以及将内部函数映射到滑块事件、管理滑块的运动，并在我们移动滑块时调用`manual_drive.html`代码（或任何其他代码）。让我们编写滑块代码，如下所示：

1.  我们将把这个放在`static/touch-slider.js`中。由于我们处于一个`.js`文件中，不需要`<script>`标签。

1.  我们创建了一个`makeSlider`函数，这是一个工厂函数，用于创建滑块所需的一切，如下所示：

    [PRE59]

1.  我们首先需要一些内部数据。代码需要知道我们是否在触摸滑块，这样它就不会在我们仍然触摸时尝试移动回去。我们需要知道触摸位置是否已改变，并跟踪其位置。最后，我们将通过其ID找到我们的滑块，并保留找到的对象以供使用，如下所示：

    [PRE60]

1.  然后，我们需要一些函数来处理滑块。我们将从一个更新位置的函数开始，确保刻度被更新，我们只使用整数（因为浏览器在这里不接受小数点），并且更新`changed`标志，如下面的代码片段所示：

    [PRE61]

1.  下一步是处理触摸事件。事件处理器是在发生某些事情时被调用的函数（例如退出按钮处理器）。触摸事件有三个事件：`touchstart`——当有人开始触摸屏幕时，`touchmove`——当触摸移动到另一个区域时，和`touchend`——当触摸停止时。我们不会使用`touchstart`，所以我们将从一个匿名的`touchmove`函数开始，如下所示：

    [PRE62]

1.  然后，我们从这个触摸从滑块顶部的相对位置获取，如下所示：

    [PRE63]

1.  我们可以用这个高度将触摸位置转换为从-100到+100的数字，匹配SVG视图框坐标，如下所示：

    [PRE64]

1.  由于代码已经接收到触摸事件，我们应该将`touched`标志设置为`true`。我们还必须防止触摸事件产生任何其他效果，如下面的代码片段所示：

    [PRE65]

1.  由于我们设置了一个标志来表示触摸事件正在发生，因此当触摸事件结束时，我们也应该清除它（将其设置为`false`），如下所示：

    [PRE66]

1.  我们的系统是动态的，因此它需要一个更新周期来返回中间位置。更新应该只在没有触摸滑块时移动刻度，这样它就会停留在你放置拇指的位置。当触摸停止且它仍然不在零位置时，我们应该更新位置，如下所示：

    [PRE67]

1.  下一个部分看起来有点像**比例-积分-微分**（**PID**）控制器的代码，因为这里有一个乘以比例组件的错误。我们将错误乘以0.3，并额外加/减0.5以使其接近1%的最小值。每次更新时，它都会将滑块移动到中间位置。代码可以在以下位置查看：

    [PRE68]

    这段代码也是一个很好的记录位置的地方——当它出错时我们可以使用。

1.  为了频繁运行这个`update`函数，我们可以使用`setInterval`内置函数，它在每个间隔内重复运行一个函数。这个显示更新应该很短，以保持其响应性。时间以毫秒为单位。代码可以在以下位置查看：

    [PRE69]

1.  除了更新图像外，我们还需要调用`when_changed`函数。我们只想在发生变化时这样做，然后重置`changed`标志，这样我们就不在空闲时调用它。我们将调用这个`update_when_changed`。它检查变化，并且比显示更新运行得更频繁，因此不会淹没`when_changed`处理器和机器人上的队列。代码可以在以下位置查看：

    [PRE70]

现在，你应该准备好运行整个系统了。

## 运行这个

现在，你可以将整个文件集上传到你的机器人上的一个文件夹中。和之前一样，你可以使用`python3 manual_drive.py`来运行它。

在尝试在手机上使用之前，你可以在浏览器中使用开发者模式查看网页，如下所示：

1.  将你的浏览器（Chrome或Firefox）指向`http://myrobot.local:5001`（使用你的机器人的主机名或地址）。

1.  右键点击你的页面，然后点击标有**检查或检查元素**的菜单项。

1.  在开发者工具中，将有模拟手机设备和触摸事件的按钮。启用手机模拟。

1.  首先尝试在桌面浏览器中排除任何问题。检查拖动滑块是否得到期望的结果，并点击**控制台**按钮查看是否有JavaScript错误。

    JavaScript和CSS中常见的常见问题是缺少标点符号，如分号、逗号或括号。如果类或ID选择器不匹配（或缺少所需的点/井号语法），将导致样式无法应用或JavaScript中的元素查找没有结果。

1.  要在手机上使用，你需要使用你的机器人的IP地址，因为主要的智能手机品牌不支持`.local`地址。你可以通过桌面上的`ping myrobot.local`找到它，如下面的代码片段所示：

    [PRE71]

1.  使用手机，你应该能够用你的拇指来驾驶机器人。

驾驶机器人需要一些练习。我建议先练习从上往下驾驶，当你熟悉了这一点后，再尝试通过摄像头导航。摄像头的帧率不是很高，这个帧率目前限制了驾驶循环。

## 故障排除

这是一个相当复杂的Python、HTML、JavaScript和CSS的组合。如果你遇到麻烦，可以尝试以下方法：

+   如果看到Python的错误，请对照前面的代码验证代码行。

+   如果网页上的事情不起作用，尝试在浏览器模式中运行手机模拟，如之前建议的，然后选择检查器**控制台**选项卡并再次尝试操作。这将显示JavaScript错误。

+   如果显示出现错误，部分内容位置不正确或颜色错误，请验证CSS/样式表部分和HTML是否正确。

+   如果你收到`404`错误，请确保HTML中的URL与Flask/Python代码中的路由相匹配。

+   如果你的机器人似乎在暂停，然后花一段时间赶上你的事件，你可以将`update_if_changed`间隔时间调整得更长一些。

现在，你有一个可以通过手机远程驾驶的机器人，同时通过其摄像头看到。你已经看到了如何处理触摸事件和使用SVG样式表来创建自定义小部件。你已经使用JavaScript通过动画使小部件生动起来，并发送控制消息回机器人。

在下一节中，我们将使菜单更易于触摸操作，这样我们就可以主要通过手机来控制机器人。

# 使机器人完全手机可操作

此处的目标是实现我们可以完全通过手机来控制机器人。我们需要确保在开启机器人时，机器人已经准备好运行，并确保菜单可以从手机上使用。我们之前制作的菜单看起来不太适合触摸操作。它也无法成功运行使用 Flask 的任何带有显示的行为。我们将使菜单按钮更大，并使其更易于触摸操作，使用与我们手动驾驶行为相似的样式。点击具有服务器（如本例或上一章的视觉跟踪行为）的行为后，菜单还将加载我们的服务器页面。

让我们先修复 Flask 行为。

## 使菜单模式与 Flask 行为兼容

如果您已经在控制服务器中尝试运行基于 Flask 的行为（如带有摄像头的那些），您将注意到一些非常奇怪的行为。您的行为似乎在机器人的传感器上做了正确的事情，但 Web 服务在 `5001` 端口上无法执行任何有用的操作。

Flask 使用子进程来管理其调试模式，这干扰了我们对它们的用法。我们不需要调试模式，所以修复方法是删除调试模式，如下所示：

1.  打开 `control_server.py` 并跳转到最后几行。

1.  通过运行以下代码从 `app.run` 行中移除 `debug=True`：

    [PRE72]

现在，您可以向控制服务器添加手动驾驶、颜色跟踪和面部跟踪行为，并且它们将正常启动。

## 加载视频服务

当我们点击基于视频服务器的行为菜单选项后，在它启动后，我们需要将我们的浏览器发送到机器人的 `5001` 端口以查看其输出。

我们当前的 `menu.html` 文件从 `control_server` 进程获取响应并将其放入消息框中。我们可以升级它，让代码执行其他操作。我们可以从配置 `mode_config` 变量中需要显示服务器页面的项目开始。

`mode_config` 变量中的每个条目只包含模式脚本；我们可以将其更新为包含脚本以及是否需要显示服务器，如下所示：

1.  打开 `robot_modes.py`。

1.  在 `mode_config` 中，我们将用字典替换简单的脚本命名文本（例如 `"avoid_behavior.py"`），允许简单的案例（`{"script": "avoid_behavior.py"}`）或更复杂的案例（`{"script": "manual_drive.py", "server": True}`）。您需要在整个 `mode_config` 中的所有条目上更改这一点。代码如下面的代码片段所示：

    [PRE73]

1.  然后，我们需要使用更复杂的案例更新 `mode_config` 变量中的服务器类型脚本，如下所示：

    [PRE74]

1.  我们需要修改 `run` 方法以从这种更改后的结构中选择脚本，如下所示：

    [PRE75]

1.  接下来，我们需要检查如果模式是服务器并且当前进程处于活动状态，我们是否应该进行重定向。我在以下代码片段中添加了明确的 `is True`，以使其更清晰，表明该值是一个 `True`/`False` 标志。

    [PRE76]

我们已经准备了`robot_modes.py`。`control_server.py`文件向网页发送响应。让我们使用与`mode_config`相同的技巧，返回一个包含数据的字典而不是只是一个字符串，如下所示：

1.  我们将使用`control_server.py`并在Flask导入中添加`jsonify`，如下面的代码片段所示：

    [PRE77]

1.  接下来，我们替换`run`方法，使其创建`response`字典，如下所示：

    [PRE78]

    这个响应是基本消息。

1.  如果我们打算重定向，我们应该在我们的响应中发送`redirect`设置，如下所示：

    [PRE79]

1.  我们需要发送编码为JSON的响应。JSON是将数据从Python发送到JavaScript的一种简单方式——它与字典数据特别好。运行以下代码：

    [PRE80]

1.  由于我们在`stop`命令中也发送了消息，我们应该以相同的方式将其包装起来，如下所示：

    [PRE81]

控制服务器能够发送`response`字典，并在需要时进行重定向。现在，接收JSON对象的那一侧，需要在页面脚本中进行更改以处理新的响应。按照以下步骤进行：

1.  打开`templates/menu.html`，找到`run`函数，如下面的代码片段所示：

    [PRE82]

1.  这里消息处理需要更改。我们需要使用响应中的消息元素设置消息元素的HTML，如下所示：

    [PRE83]

1.  然而，我们也可以检查是否需要重定向。如果是这样，我们使用与之前*模板*部分中手动驾驶行为中的退出按钮相同的技巧，但在超时中进行，如下所示：

    [PRE84]

如果你上传这个并运行`python3 control_server.py`，你会看到菜单现在功能更强大，但看起来相当简单。你应该能够点击跟踪或驾驶行为，3秒后重定向到它们的页面。点击退出按钮应该会带你回到菜单。

是时候给它一些样式了。

## 菜单样式

我们已经在手动驾驶演示中使用了样式表来使退出按钮看起来更好。这个菜单也是一组按钮。我们可以在此基础上构建样式，使菜单更适用于手机。

### 将菜单模板转换为按钮

我们已经在`static/display.css`中有一个现有的样式表。我们可以在菜单中进一步使用这个样式表，也许需要一些调整。我们的菜单模板也可以优化以充分利用这个样式表。按照以下步骤进行：

1.  打开`templates/menu.html`。我们将添加一个链接到样式表。我们还可以添加一个`charset`定义，如下所示：

    [PRE85]

1.  菜单模板使用一个项目列表。给这个列表添加一个`menu`类，给链接添加一个`button`类，这样我们就可以使用它们现有的样式，如下面的代码片段所示：

    [PRE86]

1.  现在，打开`static/display.css`，我们将在这里定义`menu`类的样式，如下所示：

    [PRE87]

    我们使列表容器填充屏幕宽度，没有任何额外的边距（项目外部的空间）或填充（项目内部和其子列表项之间的空间）。

1.  菜单由列表项组成。默认情况下，这些项会带有一个点：一个项目符号。我们希望将其设置为`none`（无形状）以移除项目符号。我们可以使用CSS的`list-style`属性来更改它。这里的选择器适用于`.menu`类对象的子列表项（`li`）。代码可以在下面的代码片段中看到：

    [PRE88]

1.  为了使其触控友好，我们使按钮宽度相同。`60vw`（视口宽度的60%）应该足够宽。我们使用`auto`边距技巧来居中。我们还可以在它们上添加一个1像素的浅蓝色边框，如下面的代码片段所示：

    [PRE89]

上传整个目录并使用`python3 control_server.py`启动菜单服务器。现在这个菜单应该看起来更符合手机。

你现在已经看到了如何使我们的控制服务器在智能手机上运行良好，你应该对JavaScript、HTML和CSS与Python的交互更加熟悉。然而，这个系统有一个缺陷——我们仍然是从SSH终端启动它的。让我们看看如何解决这个问题。

# 让菜单在Pi启动时启动

你现在有一个菜单系统可以启动机器人行为。使用SSH登录是很好的调试方式，可以看到问题并修复它们。然而，当你想展示你的机器人时，SSH会话会变得不方便。

理想的情况是打开机器人，等待灯光亮起，然后将你的手机浏览器指向它来控制它。

我们将做两件事来使这个功能变得有用，如下所示：

+   使用LED指示它已准备好（在菜单模式下），以便在手机连接到页面之前机器人能告诉我们

+   使用`systemd`在机器人开启时自动启动菜单Flask服务器

让我们开始使用灯光。

## 向菜单服务器添加灯光

我们不希望整个机器人类加载到我们的菜单中，但它可以使用灯光来指示我们的机器人现在已准备好。我们将导入LED系统，在服务器启动时将其打开，然后在第一个`/run`请求到达时关闭/释放它。按照以下步骤操作：

1.  打开`control_server.py`文件并导入LED，如下所示：

    [PRE90]

1.  我们需要设置我们的LED并运行以下代码来使一个LED变绿：

    [PRE91]

1.  当我们运行某些内容时，我们知道有人使用了菜单。在我们的`run`方法中，我们可以清除LED。由于我们只想做一次，我们可以将全局LED设置为`None`，然后在下次检查。注意以下代码片段中我们正在将高亮代码插入到现有的`run`函数中：

    [PRE92]

你可以通过上传菜单服务器代码并重新运行它来测试这一点。LED应该在启动时亮起，然后当你选择另一个行为时，它会熄灭。它应该能够正确地从菜单移动到LED测试行为。

## 使用`systemd`自动启动机器人

树莓派中的`systemd`。

通过创建一个单元文件并将其复制到Pi的正确文件夹中来注册一个服务。按照以下步骤操作：

1.  创建一个 `menu_server.service` 文件。用描述来启动它，并告诉 `systemd` 在我们的 Raspberry Pi 上建立网络后启动我们的服务，如下面的代码片段所示：

    [PRE93]

1.  现在，我们告诉 `systemd` 我们希望在 Pi 准备好用户登录时启动它，如下面的代码片段所示：

    [PRE94]

1.  以下代码片段中显示的 `Service` 部分配置了如何运行我们的代码：

    [PRE95]

1.  工作目录是你将机器人文件复制到的位置——例如，`/home/pi`。我们还可以设置我们一直在使用的 `pi` 用户。工作目录是代码找到其其他组件的方式。请查看以下代码片段：

    [PRE96]

1.  `ExecStart` 语句告诉 `systemd` 运行服务的命令。然而，它并不像 shell 那样假设路径，所以请在 `python3` 命令前加上 `/usr/bin/env`，如下所示：

    [PRE97]

1.  你现在需要在 Raspberry Pi 上设置这个。将此文件上传到你的 Raspberry Pi 主目录。

1.  你需要 `sudo` 权限将其复制到系统配置中。请在 Pi 上通过 SSH 输入此命令。注意，如果你遗漏了 `sudo` 命令，你会看到权限错误。代码可以在以下位置查看：

    [PRE98]

1.  我们现在应该要求 `systemd` 加载我们的配置，然后启用我们的服务，如下所示：

    [PRE99]

1.  系统将确认你已经启用它，如下所示的消息：

    [PRE100]

1.  然后，你可以使用以下命令尝试启动你的服务：

    [PRE101]

如果启动此服务器成功，你会看到一个绿灯亮起，表示它已准备好。然后你将能够将浏览器指向机器人并控制它。

让我们检查一下这是否已经成功。

### 故障排除

这里可能会出错——如果发生这种情况，请尝试以下步骤来修复它或了解更多信息：

1.  使用 `systemd` 启动/启用菜单服务器可能会失败，如果你发现 `menu_server.service` 文件有问题，你会看到 `Unit menu_server.service is not loaded properly: Invalid argument`。请验证其内容，将其复制回来，然后重新运行 `sudo` 命令来安装新文件。

1.  如果你想要看到服务器正在做什么的更多信息，你可以使用以下命令：

    [PRE102]

    Pi 将会响应如下：

    [PRE103]

1.  `systemctl` 可以显示一些最近的活动，但你可能想跟踪运行中的行为输出。为此，你需要使用 `journalctl` 命令。使用 `-u` 来指定我们创建的服务，然后使用 `-f` 来跟踪日志，如下面的代码片段所示：

    [PRE104]

    我们将能够看到服务器在运行时的状态——这可能不是调试中最方便的，但对于启动服务来说很方便。使用 *Ctrl* + *C* 来停止查看日志。

你现在可以重新启动机器人，等待绿灯亮起，然后开始驾驶它。绿灯也会意味着你的 Mycroft 语音助手可以向机器人发送请求。

如果你上传了新的代码，你需要重新启动服务。你可以使用以下命令来这样做：

[PRE105]

恭喜——你的机器人现在真正无头了！它甚至不需要 PC 或笔记本电脑来开始做事。

# 摘要

本章为我们的机器人添加了一个小型菜单系统，可以从连接的网页浏览器中启动不同的模式。

你已经看到了如何从手机驾驶机器人，以及如何使用 SVG 和 JavaScript 创建有趣的动画小部件。

你的机器人现在已经获得了手动驾驶的能力。你可能需要一段时间来习惯操作它，手动纠正偏航（电机行为略有不同）比 PID 系统自行纠正更具挑战性。尽管如此，你将学会用手机驾驶它。你可以使用机器人前部的摄像头来获得机器人视角的世界。

你已经将控制服务器变成了菜单服务器，并在打开机器人时自动启动它。你还看到了如何将你的菜单服务器连接到视频服务器应用程序，如手动驾驶、颜色追踪或人脸追踪应用程序。通过使菜单服务器上的按钮更易于触摸，你可以使用手机启动大多数行为。

最后，我们为菜单服务器提供了一个用 LED 指示机器人在机器人上就绪的方法，并将其设置为在打开机器人时自动启动。如果你的机器人和手机可以连接到同一网络（也许你可以在 `wpa_supplicant.conf` 文件中设置你的手机热点），你将能够从实验室外的地方启动行为并向人们展示它们。你已经用手机完全控制了机器人！

在下一章中，我们将探讨如何加入机器人制作社区，并寻找更多的机器人构建和编程技能，以继续构建。

# 练习

你可以通过许多方式增强系统。以下是一些进一步构建的建议：

1.  在 `manual_drive.py` 文件中，`handle_instruction` 函数使用一系列 `if` 语句来处理指令。如果这个命令处理器的列表超过五个，你可以通过使用字典（例如 `menu_modes`）并调用不同的处理方法来改进它。

1.  你能否将触摸界面改为两个圆形垫片——也许这样左边的可以控制电机移动，右边的可以改变相机位置？

1.  关于为其他行为创建手机友好的界面来控制它们的参数，你怎么看？

1.  你可以通过添加圆形按钮或按钮之间的间距来装饰 CSS。

1.  菜单仍然使用文本按钮。你能找到一种方法将每个行为与一个图像关联，并制作一个按钮网格？

1.  添加一个 `sudo poweroff` 命令。

1.  为了桌面兼容性，手动驾驶系统可以通过键盘交互来增强，以驾驶机器人，这不如手机有趣，但是一个方便的备用方案。

1.  对驾驶系统进行一个严重的改进，将电机控制改为每秒计数，每个轮子一个 PID，匹配我们从编码器得到的脉冲计数与我们预期的脉冲计数。这个改进会使机器人直线行驶更直，因此更容易驾驶。

# 进一步阅读

要了解更多关于本章涵盖的主题，以下是一些建议：

+   我强烈推荐Flask API文档（[http://flask.pocoo.org/docs/1.0/api/](http://flask.pocoo.org/docs/1.0/api/)），它不仅可以帮助理解我们使用的Flask函数，还可以学习其他使用这个灵活的网络服务器库的方法。

+   为了更深入地了解Flask网络服务器，我建议阅读*Flask By Example*，作者*加雷思·德耶尔*，*Packt Publishing* ([https://www.packtpub.com/product/flask-by-example/9781785286933](https://www.packtpub.com/product/flask-by-example/9781785286933))，它展示了如何使用Flask构建更复杂的网络应用程序。

+   我还推荐书籍*精通Flask*，作者*杰克·斯托弗*，*Packt Publishing* ([https://www.packtpub.com/web-development/mastering-flask](https://www.packtpub.com/web-development/mastering-flask))。

+   本章使用的HTML是基础的。为了更深入地了解如何增强简单的菜单系统，我推荐观看e-learning视频指南*使用HTML和CSS开始响应式网络开发 [eLearning]*，作者*本·弗莱恩*，*科德·斯莱顿-瓦莱*，*约书亚·米勒*，*Packt Publishing* ([https://www.packtpub.com/web-development/beginning-responsive-web-development-html-and-css-elearning-video](https://www.packtpub.com/web-development/beginning-responsive-web-development-html-and-css-elearning-video))。

+   我们在HTML、CSS和JavaScript应用程序中使用了CSS选择器。你可以在*W3C Schools CSS选择器*网站上找到一个很好的参考和教程的组合（[https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp)）。我建议探索该网站，了解大多数网络应用技术的信息。对于CSS单位，请参阅*W3C Schools CSS单位*（[https://www.w3schools.com/cssref/css_units.asp](https://www.w3schools.com/cssref/css_units.asp)）以练习并找到更多可用的单位类型。*W3C Schools*通常为这些网络技术提供优秀的参考和学习材料。

+   为了更熟悉这里使用的JavaScript、CSS和HTML技术，*freeCodeCamp* ([https://www.freecodecamp.org/](https://www.freecodecamp.org/))是一个有价值的资源，提供了自学模块。

+   Raspberry Pi在其[https://www.raspberrypi.org/documentation/linux/usage/systemd.md](https://www.raspberrypi.org/documentation/linux/usage/systemd.md)上提供了关于用户`systemd`文件的便捷文档。

+   在*精通Linux网络管理*（*Jay LaCroix*，*Packt Publishing*）[https://www.packtpub.com/product/mastering-linux-network-administration/9781784399597](https://www.packtpub.com/product/mastering-linux-network-administration/9781784399597)中有一章关于理解`systemd`，该书于2015年出版。

+   `systemd`服务的完整参考可以在[freedesktop](https://www.freedesktop.org/software/systemd/man/systemd.service.html)手册中找到。
