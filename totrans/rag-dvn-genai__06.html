<html><head></head><body>
  <div id="_idContainer075" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">6</span></h1>
    <h1 id="_idParaDest-149" class="chapterTitle"><span class="koboSpan" id="kobo.2.1">Scaling RAG Bank Customer Data with Pinecone</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.3.1">Scaling up RAG documents, whether text-based or multimodal, isn’t just about piling on and accumulating more data—it fundamentally changes how an application works. </span><span class="koboSpan" id="kobo.3.2">Firstly, scaling is about finding the right amount of data, not just more of it. </span><span class="koboSpan" id="kobo.3.3">Secondly, as you add more data, the demands on an application can change—it might need new features to handle the bigger load. </span><span class="koboSpan" id="kobo.3.4">Finally, cost monitoring and speed performance will constrain our projects when scaling. </span><span class="koboSpan" id="kobo.3.5">Hence, this chapter is designed to equip you with cutting-edge techniques for leveraging AI in solving the real-world scaling challenges you may face in your projects. </span><span class="koboSpan" id="kobo.3.6">For this, we will be building a recommendation system based on pattern-matching using Pinecone to minimize bank customer churn (customers choosing to leave a bank).</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.4.1">We will start with a step-by-step approach to developing the first program of our pipeline. </span><span class="koboSpan" id="kobo.4.2">Here, you will learn how to download a Kaggle bank customer dataset and perform </span><strong class="keyWord"><span class="koboSpan" id="kobo.5.1">exploratory data analysis</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.7.1">EDA</span></strong><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">This foundational step is crucial as it guides and supports you in preparing your dataset and your RAG strategy for the next stages of processing. </span><span class="koboSpan" id="kobo.8.3">The second program of our pipeline introduces you to the powerful combination of Pinecone—a vector database suited for handling large-scale vector search—and OpenAI’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.9.1">text-embedding-3-small</span></code><span class="koboSpan" id="kobo.10.1"> model. </span><span class="koboSpan" id="kobo.10.2">Here, you’ll chunk and embed your data before upserting (updating or inserting records) it into a Pinecone index that we will scale up to 1,000,000+ vectors. </span><span class="koboSpan" id="kobo.10.3">We will ready it for complex query retrieval at a satisfactory speed. </span><span class="koboSpan" id="kobo.10.4">Finally, the third program of our pipeline will show you how to build RAG queries using Pinecone, augment user input, and leverage GPT-4o to generate AI-driven recommendations. </span><span class="koboSpan" id="kobo.10.5">The goal is to reduce churn in banking by offering personalized, insightful recommendations. </span><span class="koboSpan" id="kobo.10.6">By the end of this chapter, you’ll have a good understanding of how to apply the power of Pinecone and OpenAI technologies to your RAG projects.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.11.1">To sum up, this chapter covers the following topics:</span></p>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.12.1">The key aspects of scaling RAG vector stores</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.13.1">EDA for data preparation</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.14.1">Scaling with Pinecone vector storage</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.15.1">Chunking strategy for customer bank information</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.16.1">Embedding data with OpenAI embedding models</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.17.1">Upserting data</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.18.1">Using Pinecone for RAG</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.19.1">Generative AI-driven recommendations with GPT-4o to reduce bank customer churn</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.20.1">Let’s begin by defining how we will scale with Pinecone.</span></p>
    <h1 id="_idParaDest-150" class="heading-1"><span class="koboSpan" id="kobo.21.1">Scaling with Pinecone</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.22.1">We will be implementing Pinecone’s innovative vector database technology with OpenAI’s powerful </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.23.1">embedding capabilities to construct data processing and querying systems. </span><span class="koboSpan" id="kobo.23.2">The goal is to build a recommendation system to </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.24.1">encourage customers to continue their association with a bank. </span><span class="koboSpan" id="kobo.24.2">Once you understand this approach, you will be able to apply it to any domain requiring recommendations (leisure, medical, or legal). </span><span class="koboSpan" id="kobo.24.3">To understand and optimize the complex processes involved, we will build the programs from scratch with a minimal number of components. </span><span class="koboSpan" id="kobo.24.4">In this chapter, we will use the Pinecone vector database and the OpenAI LLM model.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.25.1">Selecting and designing an architecture depends on a project’s specific goals. </span><span class="koboSpan" id="kobo.25.2">Depending on your project’s needs, you can apply this methodology to other platforms. </span><span class="koboSpan" id="kobo.25.3">In this chapter and architecture, the combination of a vector store and a generative AI model is designed to streamline operations and facilitate scalability. </span><span class="koboSpan" id="kobo.25.4">With that context in place, let’s go through the architecture we will be building in Python.</span></p>
    <h2 id="_idParaDest-151" class="heading-2"><span class="koboSpan" id="kobo.26.1">Architecture</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.27.1">In this chapter, we will implement </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.28.1">vector-based similarity search functionality, as we did in </span><em class="chapterRef"><span class="koboSpan" id="kobo.29.1">Chapter 2</span></em><span class="koboSpan" id="kobo.30.1">, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">RAG Embedding Vector Stores with Deep Lake and OpenAI</span></em><span class="koboSpan" id="kobo.32.1">, and </span><em class="chapterRef"><span class="koboSpan" id="kobo.33.1">Chapter 3</span></em><span class="koboSpan" id="kobo.34.1">, </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Building Index-Based RAG with LlamaIndex, Deep Lake, and OpenAI</span></em><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">We will take the structure of the three pipelines we designed in those chapters and apply them to our recommendation system, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Figure 6.1</span></em><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">If necessary, take the time to go through those chapters before implementing the code in this chapter.</span></p>
    <figure class="mediaobject"><span class="koboSpan" id="kobo.39.1"><img src="../Images/B31169_06_01.png" alt="A diagram of a process  Description automatically generated"/></span></figure>
    <p class="packt_figref"><span class="koboSpan" id="kobo.40.1">Figure 6.1: Scaling RAG-driven generative AI pipelines</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.41.1">The key features of the scaled recommendation system we will build can be summarized in the three</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.42.1"> pipelines shown in the preceding figure:</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">Pipeline 1: Collecting and preparing the dataset</span></strong></li>
    </ul>
    <p class="normal-one"><span class="koboSpan" id="kobo.44.1">In this pipeline, we will perform EDA on the dataset with standard queries and k-means clustering.</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">Pipeline 2: Scaling a Pinecone index (vector store)</span></strong></li>
    </ul>
    <p class="normal-one"><span class="koboSpan" id="kobo.46.1">In this pipeline, we will see how to chunk, embed, and upsert 1,000,000+ documents to a Pinecone index (vector store).</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.47.1">Pipeline 3: RAG generative AI</span></strong></li>
    </ul>
    <p class="normal-one"><span class="koboSpan" id="kobo.48.1">This pipeline will take us to fully scaled RAG when we query a 1,000,000+ vector store and augment the input of a GPT-4o model to make targeted recommendations.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.49.1">The main theoretical and practical applications of the three programs we will explore include:</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.50.1">Scalable and serverless infrastructure</span></strong><span class="koboSpan" id="kobo.51.1">: We begin by understanding Pinecone’s serverless architecture, which eliminates the complexities of server management and scaling. </span><span class="koboSpan" id="kobo.51.2">We don’t need to manage storage resources or machine usage. </span><span class="koboSpan" id="kobo.51.3">It’s a pay-as-you-go approach based on serverless indexes</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.52.1"> formed by a cloud and region, for example, </span><strong class="keyWord"><span class="koboSpan" id="kobo.53.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.54.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.55.1">AWS</span></strong><span class="koboSpan" id="kobo.56.1">) in </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">us-east-1</span></code><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">Scaling and billing are thus</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.59.1"> simplified, although we still have to monitor and minimize the costs!</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.60.1">Lightweight and simplified development environment</span></strong><span class="koboSpan" id="kobo.61.1">: Our integration strategy will minimize the use of external libraries, maintaining a lightweight development stack. </span><span class="koboSpan" id="kobo.61.2">Directly using OpenAI to generate embeddings and Pinecone to store and query these embeddings simplifies the data processing pipeline and increases system efficiency. </span><span class="koboSpan" id="kobo.61.3">Although this approach can prove effective, other methods are possible depending on your project, as implemented in other chapters of this book.</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.62.1">Optimized scalability and performance</span></strong><span class="koboSpan" id="kobo.63.1">: Pinecone’s vector database is engineered to handle large-scale datasets effectively, ensuring that application performance remains satisfactory as the data volume grows. </span><span class="koboSpan" id="kobo.63.2">As for all cloud platforms and APIs, examine the privacy and security constraints when implementing Pinecone and OpenAI. </span><span class="koboSpan" id="kobo.63.3">Also, continually monitor the system’s performance and costs, as we will see in the </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Pipeline 2: Scaling a Pinecone index (vector store)</span></em><span class="koboSpan" id="kobo.65.1"> section of this chapter.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.66.1">Let’s now go to our keyboards to collect and process the </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">Bank Customer Churn</span></code><span class="koboSpan" id="kobo.68.1"> dataset.</span></p>
    <h1 id="_idParaDest-152" class="heading-1"><span class="koboSpan" id="kobo.69.1">Pipeline 1: Collecting and preparing the dataset</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.70.1">This section will focus on handling and analyzing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">Bank Customer Churn</span></code><span class="koboSpan" id="kobo.72.1"> dataset. </span><span class="koboSpan" id="kobo.72.2">We will guide you through the steps of </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.73.1">setting up your environment, manipulating</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.74.1"> data, and applying </span><strong class="keyWord"><span class="koboSpan" id="kobo.75.1">machine learning</span></strong><span class="koboSpan" id="kobo.76.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.77.1">ML</span></strong><span class="koboSpan" id="kobo.78.1">) techniques. </span><span class="koboSpan" id="kobo.78.2">It is important to get the “feel” of a dataset with human analysis </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.79.1">before using algorithms as tools. </span><span class="koboSpan" id="kobo.79.2">Human insights will always remain critical because of the flexibility of human creativity. </span><span class="koboSpan" id="kobo.79.3">As such, we will implement data collection and preparation in Python in three main steps:</span></p>
    <ol>
      <li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.80.1">Collecting and processing the dataset</span></strong><span class="koboSpan" id="kobo.81.1">:</span><ul>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.82.1">Setting up the Kaggle environment to authenticate and download datasets</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.83.1">Collecting and unzipping the </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">Bank Customer Churn</span></code><span class="koboSpan" id="kobo.85.1"> dataset</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.86.1">Simplifying the dataset by removing unnecessary columns</span></li>
        </ul>
      </li>
      <li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.87.1">Exploratory data analysis</span></strong><span class="koboSpan" id="kobo.88.1">:</span><ul>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.89.1">Performing initial data inspections to understand the structure and type of data we have</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.90.1">Investigating relationships between customer complaints and churn (closing accounts)</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.91.1">Exploring </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.92.1">how age and salary</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.93.1"> levels relate to customer churn</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.94.1">Generating a heatmap to visualize correlations between numerical features</span></li>
        </ul>
      </li>
      <li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.95.1">Training an ML model</span></strong><span class="koboSpan" id="kobo.96.1">:</span><ul>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.97.1">Preparing the data for ML</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.98.1">Applying clustering techniques to discover patterns in customer behavior</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.99.1">Assessing the effectiveness of different cluster configurations</span></li>
          <li class="bulletList level-2"><span class="koboSpan" id="kobo.100.1">Concluding and moving on to RAG-driven generative AI</span></li>
        </ul>
      </li>
    </ol>
    <p class="normal"><span class="koboSpan" id="kobo.101.1">Our goal is to analyze the dataset and prepare it for </span><em class="italic"><span class="koboSpan" id="kobo.102.1">Pipeline 2: Scaling a Pinecone index (vector store)</span></em><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">To achieve that goal, we need to perform a preliminary EDA of the dataset. </span><span class="koboSpan" id="kobo.103.3">Moreover, each section is designed to be a hands-on walkthrough of the code from scratch, ensuring you gain practical experience and insights into data science workflows. </span><span class="koboSpan" id="kobo.103.4">Let’s get started by collecting the dataset.</span></p>
    <h2 id="_idParaDest-153" class="heading-2"><span class="koboSpan" id="kobo.104.1">1. </span><span class="koboSpan" id="kobo.104.2">Collecting and processing the dataset</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.105.1">Let’s first collect the </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">Bank </span></code><code class="inlineCode"><a id="_idIndexMarker369"/></code><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">Customer Churn</span></code><span class="koboSpan" id="kobo.108.1"> dataset on Kaggle and </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.109.1">process it:</span></p>
    <p class="normal"><a href="https://www.kaggle.com/datasets/radheshyamkollipara/bank-customer-churn"><span class="url"><span class="koboSpan" id="kobo.110.1">https://www.kaggle.com/datasets/radheshyamkollipara/bank-customer-churn</span></span></a></p>
    <p class="normal"><span class="koboSpan" id="kobo.111.1">The file </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">Customer-Churn-Records.csv</span></code><span class="koboSpan" id="kobo.113.1"> contains data on 10,000 records of customers from a bank focusing on various aspects that might influence customer churn. </span><span class="koboSpan" id="kobo.113.2">The dataset was uploaded by Radheshyam Kollipara, who rightly states:</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.114.1">As we know, it is much more expensive to sign in a new client than keeping an existing one. </span><span class="koboSpan" id="kobo.114.2">It is advantageous for banks to know what leads a client towards the decision to leave the company. </span><span class="koboSpan" id="kobo.114.3">Churn prevention allows companies to develop loyalty programs and retention campaigns to keep as many customers as possible.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.115.1">Here are the details of </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.116.1">the columns included in the dataset that</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.117.1"> follow the description on Kaggle:</span></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">RowNumber—corresponds to the record (row) number and has no effect on the output.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">CustomerId—contains random values and has no effect on customers leaving the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">Surname—the surname of a customer has no impact on their decision to leave the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">CreditScore—can have an effect on customer churn since a customer with a higher credit score is less likely to leave the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">Geography—a customer's location can affect their decision to leave the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">Gender—it's interesting to explore whether gender plays a role in a customer leaving the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.124.1">Age—this is certainly relevant since older customers are less likely to leave their bank than younger ones.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">Tenure—refers to the number of years that the customer has been a client of the bank. </span><span class="koboSpan" id="kobo.125.2">Normally, older clients are more loyal and less likely to leave a bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">Balance—is also a very good indicator of customer churn, as people with a higher balance in their accounts are less likely to leave the bank compared to those with lower balances.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">NumOfProducts—refers to the number of products that a customer has purchased through the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">HasCrCard—denotes whether or not a customer has a credit card. </span><span class="koboSpan" id="kobo.128.2">This column is also relevant since people with a credit card are less likely to leave the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">IsActiveMember—active customers are less likely to leave the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">EstimatedSalary—as with balance, people with lower salaries are more likely to leave the bank compared to those with higher salaries.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">Exited—whether or not the customer left the bank.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">Complain—customer has complained or not.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">Satisfaction Score—Score provided by the customer for their complaint resolution.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">Card Type—the type of card held by the customer.</span></code></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">Points Earned—the points earned by the customer for using a credit card.</span></code></p>
    <p class="normal"><span class="koboSpan" id="kobo.136.1">Now that we know </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.137.1">what the dataset contains, we need to collect it</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.138.1"> and process it for EDA. </span><span class="koboSpan" id="kobo.138.2">Let’s install the environment.</span></p>
    <h3 id="_idParaDest-154" class="heading-3"><span class="koboSpan" id="kobo.139.1">Installing the environment for Kaggle</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.140.1">To collect datasets from Kaggle automatically, you will</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.141.1"> need to sign up and create an API key at </span><a href="https://www.kaggle.com/"><span class="url"><span class="koboSpan" id="kobo.142.1">https://www.kaggle.com/</span></span></a><span class="koboSpan" id="kobo.143.1">. </span><span class="koboSpan" id="kobo.143.2">At the time of writing this notebook, downloading datasets is free. </span><span class="koboSpan" id="kobo.143.3">Follow the</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.144.1"> instructions to save and use your Kaggle API key. </span><span class="koboSpan" id="kobo.144.2">Store your key in a safe location. </span><span class="koboSpan" id="kobo.144.3">In this case, the key is in a file on Google Drive that we need to mount:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.145.1">#API Key</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.146.1">#Store your key in a file and read it(you can type it directly in the notebook but it will be visible for somebody next to you)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">from</span></span><span class="koboSpan" id="kobo.148.1"> google.colab </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.149.1">import</span></span><span class="koboSpan" id="kobo.150.1"> drive
drive.mount(</span><span class="hljs-string"><span class="koboSpan" id="kobo.151.1">'/content/drive'</span></span><span class="koboSpan" id="kobo.152.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.153.1">The program now reads the JSON file and sets environment variables for Kaggle authentication using your username and an API key:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.154.1">import</span></span><span class="koboSpan" id="kobo.155.1"> os
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.156.1">import</span></span><span class="koboSpan" id="kobo.157.1"> json
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.158.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.159.1">open</span></span><span class="koboSpan" id="kobo.160.1">(os.path.expanduser(</span><span class="hljs-string"><span class="koboSpan" id="kobo.161.1">"drive/MyDrive/files/kaggle.json"</span></span><span class="koboSpan" id="kobo.162.1">), </span><span class="hljs-string"><span class="koboSpan" id="kobo.163.1">"r"</span></span><span class="koboSpan" id="kobo.164.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.165.1">as</span></span><span class="koboSpan" id="kobo.166.1"> f:
    kaggle_credentials = json.load(f)
kaggle_username = kaggle_credentials[</span><span class="hljs-string"><span class="koboSpan" id="kobo.167.1">"username"</span></span><span class="koboSpan" id="kobo.168.1">]
kaggle_key = kaggle_credentials[</span><span class="hljs-string"><span class="koboSpan" id="kobo.169.1">"key"</span></span><span class="koboSpan" id="kobo.170.1">]
os.environ[</span><span class="hljs-string"><span class="koboSpan" id="kobo.171.1">"KAGGLE_USERNAME"</span></span><span class="koboSpan" id="kobo.172.1">] = kaggle_username
os.environ[</span><span class="hljs-string"><span class="koboSpan" id="kobo.173.1">"KAGGLE_KEY"</span></span><span class="koboSpan" id="kobo.174.1">] = kaggle_key
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.175.1">We are now ready to install Kaggle and authenticate it:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.176.1">try</span></span><span class="koboSpan" id="kobo.177.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.178.1">import</span></span><span class="koboSpan" id="kobo.179.1"> kaggle
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.180.1">except</span></span><span class="koboSpan" id="kobo.181.1">:
  !pip install kaggle
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.182.1">import</span></span><span class="koboSpan" id="kobo.183.1"> kaggle
kaggle.api.authenticate()
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.184.1">And that’s it! </span><span class="koboSpan" id="kobo.184.2">That’s </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.185.1">all we need. </span><span class="koboSpan" id="kobo.185.2">We are now ready to collect the </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">Bank Customer Churn</span></code><span class="koboSpan" id="kobo.187.1"> dataset.</span></p>
    <h3 id="_idParaDest-155" class="heading-3"><span class="koboSpan" id="kobo.188.1">Collecting the dataset</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.189.1">We will now </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.190.1">download the zipped dataset, extract the CSV file, upload it into a pandas DataFrame, drop columns that we will not use, and display the result. </span><span class="koboSpan" id="kobo.190.2">Let’s first download the zipped dataset:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.191.1">!kaggle datasets download -d radheshyamkollipara/bank-customer-churn
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.192.1">The output displays the source of the data:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.193.1">Dataset URL: https://www.kaggle.com/datasets/radheshyamkollipara/bank-customer-churn
License(s): other
bank-customer-churn.zip: Skipping, found more recently modified local copy (use --force to force download)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.194.1">We can now unzip the data:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">import</span></span><span class="koboSpan" id="kobo.196.1"> zipfile
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.197.1">with</span></span><span class="koboSpan" id="kobo.198.1"> zipfile.ZipFile(</span><span class="hljs-string"><span class="koboSpan" id="kobo.199.1">'/content/bank-customer-churn.zip'</span></span><span class="koboSpan" id="kobo.200.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.201.1">'r'</span></span><span class="koboSpan" id="kobo.202.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.203.1">as</span></span><span class="koboSpan" id="kobo.204.1"> zip_ref:
    zip_ref.extractall(</span><span class="hljs-string"><span class="koboSpan" id="kobo.205.1">'/content/'</span></span><span class="koboSpan" id="kobo.206.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.207.1">print</span></span><span class="koboSpan" id="kobo.208.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.209.1">"File Unzipped!"</span></span><span class="koboSpan" id="kobo.210.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.211.1">The output should confirm that the file is unzipped:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.212.1">File Unzipped!
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.213.1">The CSV file is uploaded to a pandas DataFrame named </span><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">data1</span></code><span class="koboSpan" id="kobo.215.1">:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.216.1">import</span></span><span class="koboSpan" id="kobo.217.1"> pandas </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.218.1">as</span></span><span class="koboSpan" id="kobo.219.1"> pd
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.220.1"># Load the CSV file</span></span><span class="koboSpan" id="kobo.221.1">
file_path = </span><span class="hljs-string"><span class="koboSpan" id="kobo.222.1">'/content/Customer-Churn-Records.csv'</span></span><span class="koboSpan" id="kobo.223.1">
data1 = pd.read_csv(file_path)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.224.1">We will now drop the following four columns in this scenario:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.225.1">RowNumber</span></code><span class="koboSpan" id="kobo.226.1">: We don’t need these columns because we will be creating a unique index for each record.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">Surname</span></code><span class="koboSpan" id="kobo.228.1">: The goal in this scenario is to anonymize the data and not display surnames. </span><span class="koboSpan" id="kobo.228.2">We will focus on customer profiles and behaviors, such as complaints and credit card consumption (points earned).</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.229.1">Gender</span></code><span class="koboSpan" id="kobo.230.1">: Consumer perceptions and behavior have evolved in the 2020s. </span><span class="koboSpan" id="kobo.230.2">It is more ethical and just as efficient to leave this information out in the context of a sample project.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.231.1">Geography</span></code><span class="koboSpan" id="kobo.232.1">: This field </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.233.1">might be interesting in some cases. </span><span class="koboSpan" id="kobo.233.2">For this scenario, let’s leave this feature out to avoid overfitting outputs based on cultural clichés. </span><span class="koboSpan" id="kobo.233.3">Furthermore, including this feature would require more information if we wanted to calculate distances for delivery services, for example:</span></li>
    </ul>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.234.1"># Drop columns and update the DataFrame in place</span></span><span class="koboSpan" id="kobo.235.1">
data1.drop(columns=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.236.1">'RowNumber'</span></span><span class="koboSpan" id="kobo.237.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.238.1">'Surname'</span></span><span class="koboSpan" id="kobo.239.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.240.1">'Gender'</span></span><span class="koboSpan" id="kobo.241.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.242.1">'Geography'</span></span><span class="koboSpan" id="kobo.243.1">], inplace=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.244.1">True</span></span><span class="koboSpan" id="kobo.245.1">)
data1
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.246.1">The output triggered by </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">data1</span></code><span class="koboSpan" id="kobo.248.1"> shows a simplified yet sufficient dataset:</span></p>
    <figure class="mediaobject"><span class="koboSpan" id="kobo.249.1"><img src="../Images/B31169_06_02.png" alt="A screenshot of a computer  Description automatically generated"/></span></figure>
    <p class="packt_figref"><span class="koboSpan" id="kobo.250.1">Figure 6.2: Triggered output</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.251.1">This approach’s advantage is that it optimizes the size of the data that will be inserted into the Pinecone index (vector store). </span><span class="koboSpan" id="kobo.251.2">Optimizing the data size before inserting data into Pinecone and reducing the dataset by removing unnecessary fields can be very beneficial. </span><span class="koboSpan" id="kobo.251.3">It reduces the amount of data that needs to be transferred, stored, and processed in the vector store. </span><span class="koboSpan" id="kobo.251.4">When scaling, smaller data sizes can lead to faster query performance and lower costs, as Pinecone pricing can depend on the amount of </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.252.1">data stored and the computational resources used for queries.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.253.1">We can now save the new pandas DataFrame in a safe location:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.254.1">data1.to_csv(</span><span class="hljs-string"><span class="koboSpan" id="kobo.255.1">'data1.csv'</span></span><span class="koboSpan" id="kobo.256.1">, index=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.257.1">False</span></span><span class="koboSpan" id="kobo.258.1">)
!cp /content/data1.csv /content/drive/MyDrive/files/rag_c6/data1.csv
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.259.1">You can save it in the location that is best for you. </span><span class="koboSpan" id="kobo.259.2">Just make sure to save it because we will use it in the </span><em class="italic"><span class="koboSpan" id="kobo.260.1">Pipeline 2: Scaling a Pinecone index (vector store)</span></em><span class="koboSpan" id="kobo.261.1"> section of this chapter. </span><span class="koboSpan" id="kobo.261.2">We will now explore the optimized dataset before deciding how to implement it in a vector store.</span></p>
    <h2 id="_idParaDest-156" class="heading-2"><span class="koboSpan" id="kobo.262.1">2. </span><span class="koboSpan" id="kobo.262.2">Exploratory data analysis</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.263.1">In this section, we will perform EDA using the data that pandas has just defined, which contains customer data from a </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.264.1">bank. </span><span class="koboSpan" id="kobo.264.2">EDA is a critical step before applying any RAG techniques with vector stores, as it helps us understand the underlying patterns and trends within the data.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.265.1">For instance, our preliminary analysis shows a direct correlation between customer complaints and churn rates, indicating that customers who have lodged complaints are more likely to leave the bank. </span><span class="koboSpan" id="kobo.265.2">Additionally, our data reveals that customers aged 50 and above are less likely to churn compared to younger customers. </span><span class="koboSpan" id="kobo.265.3">Interestingly, income levels (particularly the threshold of $100,000) do not appear to significantly influence churn decisions.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.266.1">Through the careful examination of these insights, we’ll demonstrate why jumping straight into complex ML models, especially deep learning, may not always be necessary or efficient for drawing basic conclusions. </span><span class="koboSpan" id="kobo.266.2">In scenarios where the relationships within the data are evident and the patterns straightforward, simpler statistical methods or even basic data analysis techniques might be more appropriate and resource-efficient. </span><span class="koboSpan" id="kobo.266.3">For example, k-means clustering can be effective, and we will implement it in the </span><em class="italic"><span class="koboSpan" id="kobo.267.1">Training an ML model</span></em><span class="koboSpan" id="kobo.268.1"> section of this chapter.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.269.1">However, this is not to understate the power of advanced RAG techniques, which we will explore in the </span><em class="italic"><span class="koboSpan" id="kobo.270.1">Pipeline 2: Scaling a Pinecone index</span></em> <em class="italic"><span class="koboSpan" id="kobo.271.1">(vector store)</span></em><span class="koboSpan" id="kobo.272.1"> section of this chapter. </span><span class="koboSpan" id="kobo.272.2">In that section, we will employ deep learning within vector stores to uncover more subtle patterns and intricate relationships that are not readily apparent through classic EDA.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.273.1">If we display the </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.274.1">columns of the DataFrame, we can see that it is challenging to find patterns:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.275.1">#   Column              Non-Null Count  Dtype
---  ------              --------------  -----
 0   CustomerId          10000 non-null  int64
 1   CreditScore         10000 non-null  int64
</span><span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.276.1"> 2   Age                 10000 non-null  int64</span></strong></span><span class="koboSpan" id="kobo.277.1">
 3   Tenure              10000 non-null  int64
 4   Balance             10000 non-null  float64
 5   NumOfProducts       10000 non-null  int64
 6   HasCrCard           10000 non-null  int64
 7   IsActiveMember      10000 non-null  int64
</span><span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.278.1"> 8   EstimatedSalary     10000 non-null  float64</span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.279.1"> 9   Exited              10000 non-null  int64</span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.280.1"> 10  Complain            10000 non-null  int64</span></strong></span><span class="koboSpan" id="kobo.281.1">
 11  Satisfaction Score  10000 non-null  int64
 12  Card Type           10000 non-null  object
 13  Point Earned        10000 non-null  int64
</span></code></pre>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">Age</span></code><span class="koboSpan" id="kobo.283.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">EstimatedSalary</span></code><span class="koboSpan" id="kobo.285.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">Complain</span></code><span class="koboSpan" id="kobo.287.1"> are possible determining features that could be correlated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">Exited</span></code><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">We can also display the DataFrame to gain insights, as shown in the excerpt of </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">data1</span></code><span class="koboSpan" id="kobo.291.1"> in the following figure:</span></p>
    <figure class="mediaobject"><span class="koboSpan" id="kobo.292.1"><img src="../Images/B31169_06_03.png" alt=""/></span></figure>
    <p class="packt_figref"><span class="koboSpan" id="kobo.293.1">Figure 6.3: Visualizing the strong correlation between customer complaints and bank churning (Exited)</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.294.1">The main feature seems to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">Complain</span></code><span class="koboSpan" id="kobo.296.1">, which leads to </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">Exited</span></code><span class="koboSpan" id="kobo.298.1"> (churn), as shown by running a standard</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.299.1"> calculation on the DataFrame:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.300.1"># Calculate the percentage of complain over exited</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.301.1">if</span></span><span class="koboSpan" id="kobo.302.1"> sum_exited &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.303.1">0</span></span><span class="koboSpan" id="kobo.304.1">:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.305.1"># To avoid division by zero</span></span><span class="koboSpan" id="kobo.306.1">
    percentage_complain_over_exited = (sum_complain/ sum_exited) * </span><span class="hljs-number"><span class="koboSpan" id="kobo.307.1">100</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.308.1">else</span></span><span class="koboSpan" id="kobo.309.1">:
    percentage_complain_over_exited = </span><span class="hljs-number"><span class="koboSpan" id="kobo.310.1">0</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.311.1"># Print results</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.312.1">print</span></span><span class="koboSpan" id="kobo.313.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.314.1">f"Sum of Exited = </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.315.1">{sum_exited}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.316.1">"</span></span><span class="koboSpan" id="kobo.317.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.318.1">print</span></span><span class="koboSpan" id="kobo.319.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.320.1">f"Sum of Complain = </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.321.1">{sum_complain}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.322.1">"</span></span><span class="koboSpan" id="kobo.323.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.324.1">print</span></span><span class="koboSpan" id="kobo.325.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.326.1">f"Percentage of complain over exited = </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.327.1">{percentage_complain_over_exited:</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.328.1">.2</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.329.1">f}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.330.1">%"</span></span><span class="koboSpan" id="kobo.331.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.332.1">The output shows a very high 100.29% ratio between complaints and customers leaving the bank (churning). </span><span class="koboSpan" id="kobo.332.2">This means that customers who complained did in fact leave the bank, which is a natural market trend:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.333.1">Sum of Exited = 2038
Sum of Complain = 2044
Percentage of complain over exited = 100.29%
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.334.1">We can see that only a few exited the bank (six customers) without complaining.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.335.1">Run the following cells from GitHub; these contain Python functions that are variations of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">exited</span></code><span class="koboSpan" id="kobo.337.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">complain</span></code><span class="koboSpan" id="kobo.339.1"> ratios and will produce the following outputs:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">Age</span></code><span class="koboSpan" id="kobo.341.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">Exited</span></code><span class="koboSpan" id="kobo.343.1"> with a threshold of </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">age=50</span></code><span class="koboSpan" id="kobo.345.1"> shows that persons over 50 seem less likely to leave a bank:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.346.1">Sum of Age 50 and Over among Exited = 634
Sum of Exited = 2038
Percentage of Age 50 and Over among Exited = 31.11%
</span></code></pre>
      </li>
    </ul>
    <p class="normal-one"><span class="koboSpan" id="kobo.347.1">Conversely, the output shows that younger customers seem more likely to leave a bank if they are dissatisfied. </span><span class="koboSpan" id="kobo.347.2">You can explore different age thresholds to analyze the dataset further.</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">Salary</span></code><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.349.1">and </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">Exited</span></code><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.351.1">with a threshold of </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">salary_threshold=100000</span></code><span class="koboSpan" id="kobo.353.1"> doesn’t seem to be a significant feature, as shown in this output:
        </span><pre class="programlisting con-one"><code class="hljs-con"><span class="koboSpan" id="kobo.354.1">Sum of Estimated Salary over 100000 among Exited = 1045
Sum of Exited = 2038
Percentage of Estimated Salary over 100000 among Exited = 51.28%
</span></code></pre>
      </li>
    </ul>
    <p class="normal-one"><span class="koboSpan" id="kobo.355.1">Try exploring different thresholds to analyze the dataset to confirm or refute this trend.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.356.1">Let’s create a</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.357.1"> heatmap based on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">data1</span></code><span class="koboSpan" id="kobo.359.1"> pandas DataFrame:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.360.1">import</span></span><span class="koboSpan" id="kobo.361.1"> seaborn </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.362.1">as</span></span><span class="koboSpan" id="kobo.363.1"> sns
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.364.1">import</span></span><span class="koboSpan" id="kobo.365.1"> matplotlib.pyplot </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.366.1">as</span></span><span class="koboSpan" id="kobo.367.1"> plt
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.368.1"># Select only numerical columns for the correlation heatmap</span></span><span class="koboSpan" id="kobo.369.1">
numerical_columns = data1.select_dtypes(include=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.370.1">'float64'</span></span><span class="koboSpan" id="kobo.371.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.372.1">'int64'</span></span><span class="koboSpan" id="kobo.373.1">]).columns
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.374.1"># Correlation heatmap</span></span><span class="koboSpan" id="kobo.375.1">
plt.figure(figsize=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.376.1">12</span></span><span class="koboSpan" id="kobo.377.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.378.1">8</span></span><span class="koboSpan" id="kobo.379.1">))
sns.heatmap(data1[numerical_columns].corr(), annot=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.380.1">True</span></span><span class="koboSpan" id="kobo.381.1">, fmt=</span><span class="hljs-string"><span class="koboSpan" id="kobo.382.1">'.2f'</span></span><span class="koboSpan" id="kobo.383.1">, cmap=</span><span class="hljs-string"><span class="koboSpan" id="kobo.384.1">'coolwarm'</span></span><span class="koboSpan" id="kobo.385.1">)
plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.386.1">'Correlation Heatmap'</span></span><span class="koboSpan" id="kobo.387.1">)
plt.show()
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.388.1">We can see that the highest correlation is between </span><code class="inlineCode"><span class="koboSpan" id="kobo.389.1">Complain</span></code><span class="koboSpan" id="kobo.390.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.391.1">Exited</span></code><span class="koboSpan" id="kobo.392.1">:</span></p>
    <figure class="mediaobject"><span class="koboSpan" id="kobo.393.1"><img src="../Images/B31169_06_04.png" alt="A screenshot of a graph  Description automatically generated"/></span></figure>
    <p class="packt_figref"><span class="koboSpan" id="kobo.394.1">Figure 6.4: Excerpt of the heatmap</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.395.1">The preceding heatmap visualizes the correlation between each pair of features (variables) in the dataset. </span><span class="koboSpan" id="kobo.395.2">It shows the correlation coefficients between each pair of variables, which can range from </span><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">-1</span></code><span class="koboSpan" id="kobo.397.1">(low correlation) to </span><code class="inlineCode"><span class="koboSpan" id="kobo.398.1">1</span></code><span class="koboSpan" id="kobo.399.1">(high correlation), with </span><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">0</span></code><span class="koboSpan" id="kobo.401.1"> indicating no correlation.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.402.1">With that, we have explored several features. </span><span class="koboSpan" id="kobo.402.2">Let’s build an ML model to take this exploration further.</span></p>
    <h2 id="_idParaDest-157" class="heading-2"><span class="koboSpan" id="kobo.403.1">3. </span><span class="koboSpan" id="kobo.403.2">Training an ML model</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.404.1">Let’s continue our EDA and drill into the dataset further with an ML model. </span><span class="koboSpan" id="kobo.404.2">This section implements the training of an ML model using clustering techniques, specifically k-means clustering, to </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.405.1">explore patterns within our dataset. </span><span class="koboSpan" id="kobo.405.2">We’ll prepare and process data for analysis, apply clustering, and then evaluate the results using different metrics. </span><span class="koboSpan" id="kobo.405.3">This approach is valuable for </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.406.1">extracting insights without immediately resorting to more complex deep learning methods.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.407.1">k-means clustering is an unsupervised ML algorithm that partitions a dataset into k distinct, non-overlapping clusters by minimizing the variance within each cluster. </span><span class="koboSpan" id="kobo.407.2">The algorithm iteratively assigns data points to one of the k clusters based on the nearest mean (centroid), which is recalculated after each iteration until convergence.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.408.1">Now, let’s break down the code section by section.</span></p>
    <h3 id="_idParaDest-158" class="heading-3"><span class="koboSpan" id="kobo.409.1">Data preparation and clustering</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.410.1">We will first copy our chapter’s dataset </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">data1</span></code><span class="koboSpan" id="kobo.412.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">data2</span></code><span class="koboSpan" id="kobo.414.1"> to be able to go back to </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">data1</span></code><span class="koboSpan" id="kobo.416.1"> if necessary if we </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.417.1">wish to try other ML models:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.418.1"># Copying data1 to data2</span></span><span class="koboSpan" id="kobo.419.1">
data2 = data1.copy()
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.420.1">You can explore the data with various scenarios of feature sets. </span><span class="koboSpan" id="kobo.420.2">In this case, we will select </span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">'</span></code><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">CreditScore'</span></code><span class="koboSpan" id="kobo.423.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">'Age'</span></code><span class="koboSpan" id="kobo.425.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">'EstimatedSalary'</span></code><span class="koboSpan" id="kobo.427.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">'Exited'</span></code><span class="koboSpan" id="kobo.429.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">'Complain'</span></code><span class="koboSpan" id="kobo.431.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">'Point Earned'</span></code><span class="koboSpan" id="kobo.433.1">:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.434.1"># Import necessary libraries</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.435.1">import</span></span><span class="koboSpan" id="kobo.436.1"> pandas </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.437.1">as</span></span><span class="koboSpan" id="kobo.438.1"> pd
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.439.1">from</span></span><span class="koboSpan" id="kobo.440.1"> sklearn.cluster </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.441.1">import</span></span><span class="koboSpan" id="kobo.442.1"> KMeans
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.443.1">from</span></span><span class="koboSpan" id="kobo.444.1"> sklearn.preprocessing </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.445.1">import</span></span><span class="koboSpan" id="kobo.446.1"> StandardScaler
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">from</span></span><span class="koboSpan" id="kobo.448.1"> sklearn.metrics </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.449.1">import</span></span><span class="koboSpan" id="kobo.450.1"> silhouette_score , davies_bouldin_score
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.451.1"># Assuming you have a dataframe named data1 loaded as described</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.452.1"># Selecting relevant features</span></span><span class="koboSpan" id="kobo.453.1">
features = data2[[</span><span class="hljs-string"><span class="koboSpan" id="kobo.454.1">'CreditScore'</span></span><span class="koboSpan" id="kobo.455.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.456.1">'Age'</span></span><span class="koboSpan" id="kobo.457.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.458.1">'EstimatedSalary'</span></span><span class="koboSpan" id="kobo.459.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.460.1">'Exited'</span></span><span class="koboSpan" id="kobo.461.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.462.1">'Complain'</span></span><span class="koboSpan" id="kobo.463.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.464.1">'Point Earned'</span></span><span class="koboSpan" id="kobo.465.1">]]
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.466.1">As in standard practice, let’s scale the features before running an ML model:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.467.1"># Standardize the features</span></span><span class="koboSpan" id="kobo.468.1">
scaler = StandardScaler()
features_scaled = scaler.fit_transform(features)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.469.1">The credit score, estimated salary, and points earned (reflecting credit card spending) are good indicators of a customer’s financial standing with the bank. </span><span class="koboSpan" id="kobo.469.2">The age factor, combined</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.470.1"> with these other factors, might influence older customers to remain with the bank. </span><span class="koboSpan" id="kobo.470.2">However, the important point to note is that complaints may lead any market segment to consider leaving since complaints and churn are strongly correlated.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.471.1">We will now try to find two to four clusters to find the optimal number of clusters for this set of features:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.472.1"># Experiment with different numbers of clusters</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.473.1">for</span></span><span class="koboSpan" id="kobo.474.1"> n_clusters </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.476.1">range</span></span><span class="koboSpan" id="kobo.477.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.478.1">2</span></span><span class="koboSpan" id="kobo.479.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.480.1">5</span></span><span class="koboSpan" id="kobo.481.1">):  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.482.1"># Example range from 2 to 5</span></span><span class="koboSpan" id="kobo.483.1">
    kmeans = KMeans(n_clusters=n_clusters, n_init=</span><span class="hljs-number"><span class="koboSpan" id="kobo.484.1">20</span></span><span class="koboSpan" id="kobo.485.1">, random_state=</span><span class="hljs-number"><span class="koboSpan" id="kobo.486.1">0</span></span><span class="koboSpan" id="kobo.487.1">)
    cluster_labels = kmeans.fit_predict(features_scaled)
    silhouette_avg = silhouette_score(features_scaled, cluster_labels)
    db_index = davies_bouldin_score(features_scaled, cluster_labels)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.488.1">print</span></span><span class="koboSpan" id="kobo.489.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.490.1">f'For n_clusters=</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.491.1">{n_clusters}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.492.1">, the silhouette score is </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.493.1">{silhouette_avg:</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.494.1">.4</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.495.1">f}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.496.1"> and the Davies-Bouldin Index is </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.497.1">{db_index:</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.498.1">.4</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.499.1">f}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.500.1">'</span></span><span class="koboSpan" id="kobo.501.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.502.1">The output contains an evaluation of clustering performance using two metrics—the silhouette score and the Davies-Bouldin index—across different numbers of clusters (ranging from 2 to 4):</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.503.1">For n_clusters=2, the silhouette score is 0.6129 and the Davies-Bouldin Index is 0.6144
For n_clusters=3, the silhouette score is 0.3391 and the Davies-Bouldin Index is 1.1511
For n_clusters=4, the silhouette score is 0.3243 and the Davies-Bouldin Index is 1.0802
</span></code></pre>
    <div class="note">
      <p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.504.1">Silhouette score</span></strong><span class="koboSpan" id="kobo.505.1">: This metric measures the quality of clustering by calculating the mean intra-cluster </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.506.1">distance (how close each point in one cluster is to points in the same cluster) and the mean nearest cluster distance (how close each point is to points in the next nearest cluster). </span><span class="koboSpan" id="kobo.506.2">The score ranges from -1 to 1, where a high value indicates that clusters are well-separated and internally cohesive. </span><span class="koboSpan" id="kobo.506.3">In this output, the highest silhouette score is 0.6129 for 2 clusters, suggesting better cluster separation and cohesion compared to 3 or 4 clusters.</span></p>
      <p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.507.1">Davies-Bouldin index</span></strong><span class="koboSpan" id="kobo.508.1">: This index evaluates clustering quality by comparing the ratio of within-cluster </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.509.1">distances to between-cluster distances. </span><span class="koboSpan" id="kobo.509.2">Lower values of this index indicate better clustering, as they suggest lower intra-cluster variance and higher separation between clusters. </span><span class="koboSpan" id="kobo.509.3">The smallest Davies-Bouldin index in the output is 0.6144 for 2 clusters, indicating that this configuration likely provides the most effective separation of data points among the evaluated options.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.510.1">For two clusters, the silhouette score and Davies-Bouldin index both suggest relatively good </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.511.1">clustering performance. </span><span class="koboSpan" id="kobo.511.2">But as the number of clusters increases to three and four, both metrics indicate a decline in clustering quality, with lower silhouette scores and higher Davies-Bouldin indices, pointing to less distinct and less cohesive clusters.</span></p>
    <h3 id="_idParaDest-159" class="heading-3"><span class="koboSpan" id="kobo.512.1">Implementation and evaluation of clustering</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.513.1">Since two clusters seem to</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.514.1"> be the best choice for this </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.515.1">dataset and set of features, let’s run the model with </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">n_clusters=2</span></code><span class="koboSpan" id="kobo.517.1">:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.518.1"># Perform K-means clustering with a chosen number of clusters</span></span><span class="koboSpan" id="kobo.519.1">
kmeans = KMeans(n_clusters=</span><span class="hljs-number"><span class="koboSpan" id="kobo.520.1">2</span></span><span class="koboSpan" id="kobo.521.1">, n_init=</span><span class="hljs-number"><span class="koboSpan" id="kobo.522.1">10</span></span><span class="koboSpan" id="kobo.523.1">, random_state=</span><span class="hljs-number"><span class="koboSpan" id="kobo.524.1">0</span></span><span class="koboSpan" id="kobo.525.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.526.1"># Explicitly setting n_init to 10</span></span><span class="koboSpan" id="kobo.527.1">
data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.528.1">'class'</span></span><span class="koboSpan" id="kobo.529.1">] = kmeans.fit_predict(features_scaled)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.530.1"># Display the first few rows of the dataframe to verify the 'class' column</span></span><span class="koboSpan" id="kobo.531.1">
data2
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.532.1">Once again, as shown in the </span><em class="italic"><span class="koboSpan" id="kobo.533.1">2. </span><span class="koboSpan" id="kobo.533.2">Exploratory data analysis</span></em><span class="koboSpan" id="kobo.534.1"> section, the correlation between complaints and exiting is established, as shown in the excerpt of the pandas DataFrame in </span><em class="italic"><span class="koboSpan" id="kobo.535.1">Figure 6.5</span></em><span class="koboSpan" id="kobo.536.1">:</span></p>
    <figure class="mediaobject"><span class="koboSpan" id="kobo.537.1"><img src="../Images/B31169_06_05.png" alt="A screenshot of a game  Description automatically generated"/></span></figure>
    <p class="packt_figref"><span class="koboSpan" id="kobo.538.1">Figure 6.5: Excerpt of the output of k-means clustering</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.539.1">The first cluster is </span><code class="inlineCode"><span class="koboSpan" id="kobo.540.1">class=0</span></code><span class="koboSpan" id="kobo.541.1">, which represents customers who complained (</span><code class="inlineCode"><span class="koboSpan" id="kobo.542.1">Complain</span></code><span class="koboSpan" id="kobo.543.1">) and left (</span><code class="inlineCode"><span class="koboSpan" id="kobo.544.1">Exited</span></code><span class="koboSpan" id="kobo.545.1">) the </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.546.1">bank.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.547.1">If we count the rows</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.548.1"> for which </span><code class="inlineCode"><span class="koboSpan" id="kobo.549.1">Sum where 'class' == 0 and 'Exited' == 1</span></code><span class="koboSpan" id="kobo.550.1">, we will obtain a strong correlation between complaints and customers leaving the bank:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.551.1"># 1. </span><span class="koboSpan" id="kobo.551.2">Sum where 'class' == 0</span></span><span class="koboSpan" id="kobo.552.1">
sum_class_0 = (data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.553.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.554.1">class'</span></span><span class="koboSpan" id="kobo.555.1">] == </span><span class="hljs-number"><span class="koboSpan" id="kobo.556.1">0</span></span><span class="koboSpan" id="kobo.557.1">).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.558.1">sum</span></span><span class="koboSpan" id="kobo.559.1">()
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.560.1"># 2. </span><span class="koboSpan" id="kobo.560.2">Sum where 'class' == 0 and 'Complain' == 1</span></span><span class="koboSpan" id="kobo.561.1">
sum_class_0_complain_1 = data2[(data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.562.1">'class'</span></span><span class="koboSpan" id="kobo.563.1">] == </span><span class="hljs-number"><span class="koboSpan" id="kobo.564.1">0</span></span><span class="koboSpan" id="kobo.565.1">) &amp; (data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.566.1">'Complain'</span></span><span class="koboSpan" id="kobo.567.1">] == </span><span class="hljs-number"><span class="koboSpan" id="kobo.568.1">1</span></span><span class="koboSpan" id="kobo.569.1">)].shape[</span><span class="hljs-number"><span class="koboSpan" id="kobo.570.1">0</span></span><span class="koboSpan" id="kobo.571.1">]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.572.1"># 3. </span><span class="koboSpan" id="kobo.572.2">Sum where 'class' == 0 and 'Exited' == 1</span></span><span class="koboSpan" id="kobo.573.1">
sum_class_0_exited_1 = data2[(data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.574.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.575.1">class'</span></span><span class="koboSpan" id="kobo.576.1">] == </span><span class="hljs-number"><span class="koboSpan" id="kobo.577.1">0</span></span><span class="koboSpan" id="kobo.578.1">) &amp; (data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.579.1">'Exited'</span></span><span class="koboSpan" id="kobo.580.1">] == </span><span class="hljs-number"><span class="koboSpan" id="kobo.581.1">1</span></span><span class="koboSpan" id="kobo.582.1">)].shape[</span><span class="hljs-number"><span class="koboSpan" id="kobo.583.1">0</span></span><span class="koboSpan" id="kobo.584.1">]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.585.1"># Print the results</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.586.1">print</span></span><span class="koboSpan" id="kobo.587.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.588.1">f"Sum of 'class' == 0: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.589.1">{sum_class_0}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.590.1">"</span></span><span class="koboSpan" id="kobo.591.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.592.1">print</span></span><span class="koboSpan" id="kobo.593.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.594.1">f"Sum of 'class' == 0 and 'Complain' == 1: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.595.1">{sum_class_0_complain_1}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.596.1">"</span></span><span class="koboSpan" id="kobo.597.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.598.1">print</span></span><span class="koboSpan" id="kobo.599.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.600.1">f"Sum of 'class' == 0 and 'Exited' == 1: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.601.1">{sum_class_0_exited_1}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.602.1">"</span></span><span class="koboSpan" id="kobo.603.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.604.1">The output confirms that complaints and churn (customers leaving the bank) are closely related:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.605.1">Sum of 'class' == 0: 2039
Sum of 'class' == 0 and 'Complain' == 1: 2036
Sum of 'class' == 0 and 'Exited' == 1: 2037
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.606.1">The following cell for the second class where </span><code class="inlineCode"><span class="koboSpan" id="kobo.607.1">'class' == 1 and 'Complain' == 1</span></code><span class="koboSpan" id="kobo.608.1"> confirms that few </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.609.1">customers that complain stay with the bank:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.610.1"># 2. </span><span class="koboSpan" id="kobo.610.2">Sum where 'class' == 1 and 'Complain' == 1</span></span><span class="koboSpan" id="kobo.611.1">
sum_class_1_complain_1 = data2[(data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.612.1">'class'</span></span><span class="koboSpan" id="kobo.613.1">] == </span><span class="hljs-number"><span class="koboSpan" id="kobo.614.1">1</span></span><span class="koboSpan" id="kobo.615.1">) &amp; (data2[</span><span class="hljs-string"><span class="koboSpan" id="kobo.616.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.617.1">Complain'</span></span><span class="koboSpan" id="kobo.618.1">] == </span><span class="hljs-number"><span class="koboSpan" id="kobo.619.1">1</span></span><span class="koboSpan" id="kobo.620.1">)].shape[</span><span class="hljs-number"><span class="koboSpan" id="kobo.621.1">0</span></span><span class="koboSpan" id="kobo.622.1">]
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.623.1">The output is consistent with</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.624.1"> the correlations we have observed:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.625.1">Sum of 'class' == 1: 7961
Sum of 'class' == 1 and 'Complain' == 1: 8
Sum of 'class' == 1 and 'Exited' == 1: 1
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.626.1">We saw that finding the features that could help us keep customers is challenging with classical methods that can be effective. </span><span class="koboSpan" id="kobo.626.2">However, our strategy will now be to transform the customer records into vectors with OpenAI and query a Pinecone index to find deeper patterns within the dataset with queries that don’t exactly match the dataset.</span></p>
    <h1 id="_idParaDest-160" class="heading-1"><span class="koboSpan" id="kobo.627.1">Pipeline 2: Scaling a Pinecone index (vector store)</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.628.1">The goal of this section is to build a Pinecone index with our dataset and scale it from 10,000 records up to 1,000,000 records. </span><span class="koboSpan" id="kobo.628.2">Although we are building on the knowledge acquired in</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.629.1"> the previous chapters, the essence of scaling is different from managing sample datasets.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.630.1">The clarity of each process of this pipeline is deceptively simple: data preparation, embedding, uploading to a vector store, and querying to retrieve documents. </span><span class="koboSpan" id="kobo.630.2">We have already gone through each of these processes in </span><em class="chapterRef"><span class="koboSpan" id="kobo.631.1">Chapters 2</span></em><span class="koboSpan" id="kobo.632.1"> and </span><em class="chapterRef"><span class="koboSpan" id="kobo.633.1">3</span></em><span class="koboSpan" id="kobo.634.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.635.1">Furthermore, beyond implementing Pinecone instead of Deep Lake and using OpenAI models in a slightly different way, we are performing the same functions as in </span><em class="chapterRef"><span class="koboSpan" id="kobo.636.1">Chapters 2</span></em><span class="koboSpan" id="kobo.637.1">, </span><em class="chapterRef"><span class="koboSpan" id="kobo.638.1">3</span></em><span class="koboSpan" id="kobo.639.1">, and </span><em class="chapterRef"><span class="koboSpan" id="kobo.640.1">4</span></em><span class="koboSpan" id="kobo.641.1"> for the vector store phase:</span></p>
    <ol>
      <li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.642.1">Data preparation</span></strong><span class="koboSpan" id="kobo.643.1">: We will start by preparing our dataset using Python for chunking.</span></li>
      <li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.644.1">Chunking and embedding</span></strong><span class="koboSpan" id="kobo.645.1">: We will chunk the prepared data and then embed the chunked data.</span></li>
      <li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.646.1">Creating the Pinecone index</span></strong><span class="koboSpan" id="kobo.647.1">: We will create a Pinecone index (vector store).</span></li>
      <li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.648.1">Upserting</span></strong><span class="koboSpan" id="kobo.649.1">: We will upload the embedded documents (in this case, customer records) and the text of each record as metadata.</span></li>
      <li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.650.1">Querying the Pinecone index</span></strong><span class="koboSpan" id="kobo.651.1">: Finally, we will run a query to retrieve relevant documents to prepare </span><em class="italic"><span class="koboSpan" id="kobo.652.1">Pipeline 3: RAG generative AI</span></em><span class="koboSpan" id="kobo.653.1">.</span></li>
    </ol>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.654.1">Take all the time you need, if necessary, to go through </span><em class="chapterRef"><span class="koboSpan" id="kobo.655.1">Chapters 2</span></em><span class="koboSpan" id="kobo.656.1">,</span><em class="chapterRef"><span class="koboSpan" id="kobo.657.1">3</span></em><span class="koboSpan" id="kobo.658.1">, and </span><em class="chapterRef"><span class="koboSpan" id="kobo.659.1">4</span></em><span class="koboSpan" id="kobo.660.1"> again for the data preparation, chunking, embedding, and querying functions.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.661.1">We know how to implement each phase because we’ve already done that with Deep Lake, and Pinecone is a type of vector store, too. </span><span class="koboSpan" id="kobo.661.2">So, what’s the issue here? </span><span class="koboSpan" id="kobo.661.3">The real issue is the hidden real-life project challenges on which we will focus, starting with the size, cost, and operations involved.</span></p>
    <h2 id="_idParaDest-161" class="heading-2"><span class="koboSpan" id="kobo.662.1">The challenges of vector store management</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.663.1">Usually, we begin a section by jumping into the code. </span><span class="koboSpan" id="kobo.663.2">That’s fine for small volumes, but scaling requires project management decisions before getting started! </span><span class="koboSpan" id="kobo.663.3">Why? </span><span class="koboSpan" id="kobo.663.4">When we run a program with a bad decision or an error on small datasets, the consequences are limited. </span><span class="koboSpan" id="kobo.663.5">But </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.664.1">scaling is a different story! </span><span class="koboSpan" id="kobo.664.2">The fundamental principle and risk of scaling is that errors are scaled exponentially, too.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.665.1">Let’s list the pain points you must face before running a single line of code. </span><span class="koboSpan" id="kobo.665.2">You can apply this methodology to any platform or model. </span><span class="koboSpan" id="kobo.665.3">However, we have limited the platforms in this chapter to OpenAI and Pinecone to focus on processes, not platform management. </span><span class="koboSpan" id="kobo.665.4">Using other platforms involves careful risk management, which isn’t the objective of this chapter.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.666.1">Let’s begin with OpenAI models:</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.667.1">OpenAI models for embedding</span></strong><span class="koboSpan" id="kobo.668.1">: OpenAI continually improves and offers new models for embedding. </span><span class="koboSpan" id="kobo.668.2">Make</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.669.1"> sure you examine the characteristics of each one before embedding, including speed, cost, input limits, and API call rates, at </span><a href="https://platform.openai.com/docs/models/embeddings"><span class="url"><span class="koboSpan" id="kobo.670.1">https://platform.openai.com/docs/models/embeddings</span></span></a><span class="koboSpan" id="kobo.671.1">.</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.672.1">OpenAI models for generation</span></strong><span class="koboSpan" id="kobo.673.1">:</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.674.1">OpenAI continually releases new models and abandons older ones. </span><span class="koboSpan" id="kobo.674.2">Google does </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.675.1">the same. </span><span class="koboSpan" id="kobo.675.2">Think of these models as racing cars. </span><span class="koboSpan" id="kobo.675.3">Can you win a race today with a 1930 racing car? </span><span class="koboSpan" id="kobo.675.4">When scaling, you need the most efficient models. </span><span class="koboSpan" id="kobo.675.5">Check the speed, cost, input limits, output size, and API call rates at </span><a href="https://platform.openai.com/docs/models"><span class="url"><span class="koboSpan" id="kobo.676.1">https://platform.openai.com/docs/models</span></span></a><span class="koboSpan" id="kobo.677.1">.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.678.1">This means that you must </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.679.1">continually take the evolution of models into account for speed and cost reasons when scaling. </span><span class="koboSpan" id="kobo.679.2">Then, beyond technical considerations, you must have a real-time view of the pay-as-you-go billing perspective and technical constraints, such as:</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.680.1">Billing management</span></strong><span class="koboSpan" id="kobo.681.1">: </span><a href="https://platform.openai.com/settings/organization/billing/overview"><span class="url"><span class="koboSpan" id="kobo.682.1">https://platform.openai.com/settings/organization/billing/overview</span></span></a></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.683.1">Limits including rate limits</span></strong><span class="koboSpan" id="kobo.684.1">: </span><a href="https://platform.openai.com/settings/organization/limits"><span class="url"><span class="koboSpan" id="kobo.685.1">https://platform.openai.com/settings/organization/limits</span></span></a></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.686.1">Now, let’s examine Pinecone constraints once you have created an account:</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.687.1">Cloud and region</span></strong><span class="koboSpan" id="kobo.688.1">: The</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.689.1"> choice of the cloud (AWS, Google, or other) and region (location of the serverless storage) have pricing implications.</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.690.1">Usage</span></strong><span class="koboSpan" id="kobo.691.1">: This includes read units, write units, and storage costs, including cloud backups. </span><span class="koboSpan" id="kobo.691.2">Read more at </span><a href="https://docs.pinecone.io/guides/indexes/back-up-an-index"><span class="url"><span class="koboSpan" id="kobo.692.1">https://docs.pinecone.io/guides/indexes/back-up-an-index</span></span></a><span class="koboSpan" id="kobo.693.1">.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.694.1">You must continually monitor the price and usage of Pinecone as for any other cloud environment. </span><span class="koboSpan" id="kobo.694.2">You can do so using these links: </span><a href="https://www.pinecone.io/pricing/"><span class="url"><span class="koboSpan" id="kobo.695.1">https://www.pinecone.io/pricing/</span></span></a><span class="koboSpan" id="kobo.696.1"> and </span><a href="https://docs.pinecone.io/guides/operations/monitoring"><span class="url"><span class="koboSpan" id="kobo.697.1">https://docs.pinecone.io/guides/operations/monitoring</span></span></a><span class="koboSpan" id="kobo.698.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.699.1">The scenario we are implementing is one of many other ways of achieving the goals in this chapter with other platforms and frameworks. </span><span class="koboSpan" id="kobo.699.2">However, the constraints are invariants, including pricing, usage, speed performances, and limits.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.700.1">Let’s now implement </span><a id="_idIndexMarker404"/><em class="italic"><span class="koboSpan" id="kobo.701.1">Pipeline 2</span></em><span class="koboSpan" id="kobo.702.1"> by focusing on the pain points beyond the functionality we have already explored in previous chapters. </span><span class="koboSpan" id="kobo.702.2">You may open </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">Pipeline_2_Scaling_a_Pinecone_Index.ipynb</span></code><span class="koboSpan" id="kobo.704.1"> in the GitHub repository. </span><span class="koboSpan" id="kobo.704.2">The program begins with installing the environment.</span></p>
    <h2 id="_idParaDest-162" class="heading-2"><span class="koboSpan" id="kobo.705.1">Installing the environment</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.706.1">As mentioned earlier, the</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.707.1"> program is limited to Pinecone and OpenAI, which has the advantage of avoiding any intermediate software, platforms, and constraints. </span><span class="koboSpan" id="kobo.707.2">Store your API keys in a safe location. </span><span class="koboSpan" id="kobo.707.3">In this case, the API keys are stored on Google Drive:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.708.1">#API Key</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.709.1">#Store your key in a file and read it(you can type it directly in the notebook but it will be visible for somebody next to you)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.710.1">from</span></span><span class="koboSpan" id="kobo.711.1"> google.colab </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.712.1">import</span></span><span class="koboSpan" id="kobo.713.1"> drive
drive.mount(</span><span class="hljs-string"><span class="koboSpan" id="kobo.714.1">'/content/drive'</span></span><span class="koboSpan" id="kobo.715.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.716.1">Now, we install OpenAI and Pinecone:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.717.1">!pip install openai==</span><span class="hljs-number"><span class="koboSpan" id="kobo.718.1">1.40.3</span></span><span class="koboSpan" id="kobo.719.1">
!pip install pinecone-client==</span><span class="hljs-number"><span class="koboSpan" id="kobo.720.1">5.0.1</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.721.1">Finally, the program initializes the API keys:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.722.1">f = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.723.1">open</span></span><span class="koboSpan" id="kobo.724.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.725.1">"drive/MyDrive/files/pinecone.txt"</span></span><span class="koboSpan" id="kobo.726.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.727.1">"r"</span></span><span class="koboSpan" id="kobo.728.1">)
PINECONE_API_KEY=f.readline()
f.close()
f = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.729.1">open</span></span><span class="koboSpan" id="kobo.730.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.731.1">"drive/MyDrive/files/api_key.txt"</span></span><span class="koboSpan" id="kobo.732.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.733.1">"r"</span></span><span class="koboSpan" id="kobo.734.1">)
API_KEY=f.readline()
f.close()
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.735.1">#The OpenAI Key</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.736.1">import</span></span><span class="koboSpan" id="kobo.737.1"> os
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.738.1">import</span></span><span class="koboSpan" id="kobo.739.1"> openai
os.environ[</span><span class="hljs-string"><span class="koboSpan" id="kobo.740.1">'OPENAI_API_KEY'</span></span><span class="koboSpan" id="kobo.741.1">] =API_KEY
openai.api_key = os.getenv(</span><span class="hljs-string"><span class="koboSpan" id="kobo.742.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.743.1">OPENAI_API_KEY"</span></span><span class="koboSpan" id="kobo.744.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.745.1">The program now </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.746.1">processes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.747.1">Bank Customer Churn</span></code><span class="koboSpan" id="kobo.748.1"> dataset.</span></p>
    <h2 id="_idParaDest-163" class="heading-2"><span class="koboSpan" id="kobo.749.1">Processing the dataset</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.750.1">This section will focus on </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.751.1">preparing the dataset for chunking, which splits it into optimized chunks of text to embed. </span><span class="koboSpan" id="kobo.751.2">The program first retrieves the </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">data1.csv</span></code><span class="koboSpan" id="kobo.753.1"> dataset that we prepared and saved in the </span><em class="italic"><span class="koboSpan" id="kobo.754.1">Pipeline 1: Collecting and preparing the dataset</span></em><span class="koboSpan" id="kobo.755.1"> section of this chapter:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.756.1">!cp /content/drive/MyDrive/files/rag_c6/data1.csv /content/data1.csv
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.757.1">Then, we load the dataset in a pandas DataFrame:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.758.1">import</span></span><span class="koboSpan" id="kobo.759.1"> pandas </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.760.1">as</span></span><span class="koboSpan" id="kobo.761.1"> pd
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.762.1"># Load the CSV file</span></span><span class="koboSpan" id="kobo.763.1">
file_path = </span><span class="hljs-string"><span class="koboSpan" id="kobo.764.1">'/content/data1.csv'</span></span><span class="koboSpan" id="kobo.765.1">
data1 = pd.read_csv(file_path)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.766.1">We make sure that the 10,000 lines of the dataset are loaded:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.767.1"># Count the chunks</span></span><span class="koboSpan" id="kobo.768.1">
number_of_lines = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.769.1">len</span></span><span class="koboSpan" id="kobo.770.1">(data1)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.771.1">print</span></span><span class="koboSpan" id="kobo.772.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.773.1">"Number of lines: "</span></span><span class="koboSpan" id="kobo.774.1">,number_of_lines)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.775.1">The output confirms that the lines are indeed present:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.776.1">Number of lines:  10000
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.777.1">The following code is important in this scenario. </span><span class="koboSpan" id="kobo.777.2">Each line that represents a customer record will become a line in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">output_lines</span></code><span class="koboSpan" id="kobo.779.1"> list:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">import</span></span><span class="koboSpan" id="kobo.781.1"> pandas </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.782.1">as</span></span><span class="koboSpan" id="kobo.783.1"> pd
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.784.1"># Initialize an empty list to store the lines</span></span><span class="koboSpan" id="kobo.785.1">
output_lines = []
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.786.1"># Iterate over each row in the DataFrame</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.787.1">for</span></span><span class="koboSpan" id="kobo.788.1"> index, row </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">in</span></span><span class="koboSpan" id="kobo.790.1"> data1.iterrows():
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.791.1"># Create a list of "column_name: value" for each column in the row</span></span><span class="koboSpan" id="kobo.792.1">
    row_data = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.793.1">f"</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.794.1">{col}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.795.1">: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.796.1">{row[col]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.797.1">"</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.798.1">for</span></span><span class="koboSpan" id="kobo.799.1"> col </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.800.1">in</span></span><span class="koboSpan" id="kobo.801.1"> data1.columns]
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.802.1"># Join the list into a single string separated by spaces</span></span><span class="koboSpan" id="kobo.803.1">
    line = </span><span class="hljs-string"><span class="koboSpan" id="kobo.804.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.805.1"> '</span></span><span class="koboSpan" id="kobo.806.1">.join(row_data)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.807.1"># Append the line to the output list</span></span><span class="koboSpan" id="kobo.808.1">
    output_lines.append(line)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.809.1"># Display or further process `output_lines` as needed</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.810.1">for</span></span><span class="koboSpan" id="kobo.811.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.812.1">in</span></span><span class="koboSpan" id="kobo.813.1"> output_lines[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.814.1">5</span></span><span class="koboSpan" id="kobo.815.1">]:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.816.1"># Displaying first 5 lines for preview</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.817.1">print</span></span><span class="koboSpan" id="kobo.818.1">(line)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.819.1">The output shows that each line in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.820.1">output_lines</span></code><span class="koboSpan" id="kobo.821.1"> list is a separate customer record text:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.822.1">CustomerId: 15634602 CreditScore: 619 Age: 42 Tenure: 2 Balance: 0.0 NumOfProducts: 1 HasCrCard: 1 IsActiveMember: 1 EstimatedSalary: 101348.88 Exited: 1 Complain: 1 Satisfaction Score: 2 Card Type: DIAMOND Point Earned: 464…
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.823.1">We are sure that </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.824.1">each line is a separate pre-chunk with a clearly defined customer record. </span><span class="koboSpan" id="kobo.824.2">Let’s now copy </span><code class="inlineCode"><span class="koboSpan" id="kobo.825.1">output_lines</span></code><span class="koboSpan" id="kobo.826.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.827.1">lines</span></code><span class="koboSpan" id="kobo.828.1"> for the chunking process:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.829.1">lines = output_lines.copy()
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.830.1">The program runs a quality control on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.831.1">lines</span></code><span class="koboSpan" id="kobo.832.1"> list to make sure we haven’t lost a line in the process:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.833.1"># Count the lines</span></span><span class="koboSpan" id="kobo.834.1">
number_of_lines = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.835.1">len</span></span><span class="koboSpan" id="kobo.836.1">(lines)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.837.1">print</span></span><span class="koboSpan" id="kobo.838.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.839.1">"Number of lines: "</span></span><span class="koboSpan" id="kobo.840.1">,number_of_lines)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.841.1">The output confirms that 10,000 lines are present:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.842.1">Number of lines:  10000
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.843.1">And just like that, the</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.844.1"> data is ready to be chunked.</span></p>
    <h2 id="_idParaDest-164" class="heading-2"><span class="koboSpan" id="kobo.845.1">Chunking and embedding the dataset</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.846.1">In this section, we will chunk and embed the pre-chunks in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.847.1">lines</span></code><span class="koboSpan" id="kobo.848.1"> list. </span><span class="koboSpan" id="kobo.848.2">Building a pre-chunks list with structured data is not possible every time, but when it is, it increases a model’s traceability, clarity, and querying performance. </span><span class="koboSpan" id="kobo.848.3">The chunking process is straightforward.</span></p>
    <h3 id="_idParaDest-165" class="heading-3"><span class="koboSpan" id="kobo.849.1">Chunking</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.850.1">The practice of chunking</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.851.1"> pre-chunks is important for dataset management. </span><span class="koboSpan" id="kobo.851.2">We can create our chunks from a list of pre-chunks stored as lines:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.852.1"># Initialize an empty list for the chunks</span></span><span class="koboSpan" id="kobo.853.1">
chunks = []
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.854.1"># Add each line as a separate chunk to the chunks list</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.855.1">for</span></span><span class="koboSpan" id="kobo.856.1"> line </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.857.1">in</span></span><span class="koboSpan" id="kobo.858.1"> lines:
    chunks.append(line)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.859.1"># Each line becomes its own chunk</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.860.1"># Now, each line is treated as a separate chunk</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.861.1">print</span></span><span class="koboSpan" id="kobo.862.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.863.1">f"Total number of chunks: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.864.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.865.1">len</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.866.1">(chunks)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.867.1">"</span></span><span class="koboSpan" id="kobo.868.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.869.1">The output shows that we have not lost any data during the process:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.870.1">Total number of chunks: 10000
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.871.1">So why bother creating chunks and not just use the lines directly? </span><span class="koboSpan" id="kobo.871.2">In many cases, lines may require additional quality control and processing, such as data errors that somehow slipped through in the previous steps. </span><span class="koboSpan" id="kobo.871.3">We might even have a few chunks that exceed the input limit (which is continually evolving) of an embedding model at a given time.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.872.1">To better understand the structure of the chunked data, you can examine the length and content of the chunks using the following code:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.873.1"># Print the length and content of the first 10 chunks</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.874.1">for</span></span><span class="koboSpan" id="kobo.875.1"> i </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.876.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.877.1">range</span></span><span class="koboSpan" id="kobo.878.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.879.1">3</span></span><span class="koboSpan" id="kobo.880.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.881.1">print</span></span><span class="koboSpan" id="kobo.882.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.883.1">len</span></span><span class="koboSpan" id="kobo.884.1">(chunks[i]))
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.885.1">print</span></span><span class="koboSpan" id="kobo.886.1">(chunks[i])
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.887.1">The output will help a human controller visualize the chunked data, providing a snapshot like so:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.888.1">224
CustomerId: 15634602 CreditScore: 619 Age: 42 Tenure: 2 Balance: 0.0 NumOfProducts: 1 HasCrCard: 1 IsActiveMember: 1 EstimatedSalary: 101348.88 Exited: 1 Complain: 1 Satisfaction Score: 2 Card Type: DIAMOND Point Earned: 464…
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.889.1">The chunks will now be embedded.</span></p>
    <h3 id="_idParaDest-166" class="heading-3"><span class="koboSpan" id="kobo.890.1">Embedding</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.891.1">This section will require careful testing and consideration of the issues. </span><span class="koboSpan" id="kobo.891.2">We will realize that </span><em class="italic"><span class="koboSpan" id="kobo.892.1">scaling requires more thinking than doing</span></em><span class="koboSpan" id="kobo.893.1">. </span><span class="koboSpan" id="kobo.893.2">Each project will require specific amounts of data through design and testing to provide effective responses. </span><span class="koboSpan" id="kobo.893.3">We must also take into account the</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.894.1"> cost and benefit of each component of the pipeline. </span><span class="koboSpan" id="kobo.894.2">For example, initializing the embedding model is no easy task!</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.895.1">At the time of writing, OpenAI offers three embedding models that we can test:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.896.1">import</span></span><span class="koboSpan" id="kobo.897.1"> openai
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.898.1">import</span></span><span class="koboSpan" id="kobo.899.1"> time
embedding_model=</span><span class="hljs-string"><span class="koboSpan" id="kobo.900.1">"text-embedding-3-small"</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.901.1">#embedding_model="text-embedding-3-large"</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.902.1">#embedding_model="text-embedding-ada-002"</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.903.1">In this section, we will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.904.1">text-embedding-3-small</span></code><span class="koboSpan" id="kobo.905.1">. </span><span class="koboSpan" id="kobo.905.2">However, you can evaluate the other models by uncommenting the code. </span><span class="koboSpan" id="kobo.905.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.906.1">embedding</span></code><span class="koboSpan" id="kobo.907.1"> function will accept the model you select:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.908.1"># Initialize the OpenAI client</span></span><span class="koboSpan" id="kobo.909.1">
client = openai.OpenAI()
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.910.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.911.1">get_embedding</span></span><span class="koboSpan" id="kobo.912.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.913.1">text, model=embedding_model</span></span><span class="koboSpan" id="kobo.914.1">):
    text = text.replace(</span><span class="hljs-string"><span class="koboSpan" id="kobo.915.1">"\n"</span></span><span class="koboSpan" id="kobo.916.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.917.1">" "</span></span><span class="koboSpan" id="kobo.918.1">)
    response = client.embeddings.create(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.919.1">input</span></span><span class="koboSpan" id="kobo.920.1">=[text], model=model)
    embedding = response.data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.921.1">0</span></span><span class="koboSpan" id="kobo.922.1">].embedding
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.923.1">return</span></span><span class="koboSpan" id="kobo.924.1"> embedding
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.925.1">Make sure to check the cost and features of each embedding model before running one of your choice: </span><a href="https://platform.openai.com/docs/guides/embeddings/embedding-models"><span class="url"><span class="koboSpan" id="kobo.926.1">https://platform.openai.com/docs/guides/embeddings/embedding-models</span></span></a><span class="koboSpan" id="kobo.927.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.928.1">The program now embeds the chunks, but the embedding process requires strategic choices, particularly to manage large datasets and API rate limits effectively. </span><span class="koboSpan" id="kobo.928.2">In this case, we will create batches of chunks to embed:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.929.1">import</span></span><span class="koboSpan" id="kobo.930.1"> openai
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.931.1">import</span></span><span class="koboSpan" id="kobo.932.1"> time
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.933.1"># Initialize the OpenAI client</span></span><span class="koboSpan" id="kobo.934.1">
client = openai.OpenAI()
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.935.1"># Initialize variables</span></span><span class="koboSpan" id="kobo.936.1">
start_time = time.time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.937.1"># Start timing before the request</span></span><span class="koboSpan" id="kobo.938.1">
chunk_start = </span><span class="hljs-number"><span class="koboSpan" id="kobo.939.1">0</span></span><span class="koboSpan" id="kobo.940.1">
chunk_end = </span><span class="hljs-number"><span class="koboSpan" id="kobo.941.1">1000</span></span><span class="koboSpan" id="kobo.942.1">
pause_time = </span><span class="hljs-number"><span class="koboSpan" id="kobo.943.1">3</span></span><span class="koboSpan" id="kobo.944.1">
embeddings = []
counter = </span><span class="hljs-number"><span class="koboSpan" id="kobo.945.1">1</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.946.1">We will embed 1,000 chunks at a time with </span><code class="inlineCode"><span class="koboSpan" id="kobo.947.1">chunk_start = 0</span></code><span class="koboSpan" id="kobo.948.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">chunk_end = 1000</span></code><span class="koboSpan" id="kobo.950.1">. </span><span class="koboSpan" id="kobo.950.2">To avoid possible OpenAI API rate limits, </span><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">pause_time = 3</span></code><span class="koboSpan" id="kobo.952.1"> was added to pause for 3 seconds between each batch. </span><span class="koboSpan" id="kobo.952.2">We will store the embeddings in </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">embeddings = []</span></code><span class="koboSpan" id="kobo.954.1"> and count the batches starting with </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">counter = 1.</span></code></p>
    <p class="normal"><span class="koboSpan" id="kobo.956.1">The code is divided into</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.957.1"> three main parts, as explained in the following excerpts:</span></p>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.958.1">Iterating through all the chunks with batches:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.959.1">while</span></span><span class="koboSpan" id="kobo.960.1"> chunk_end &lt;= </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.961.1">len</span></span><span class="koboSpan" id="kobo.962.1">(chunks):
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.963.1"># Select the current batch of chunks</span></span><span class="koboSpan" id="kobo.964.1">
    chunks_to_embed = chunks[chunk_start:chunk_end]…
</span></code></pre>
      </li>
      <li class="bulletList"><span class="koboSpan" id="kobo.965.1">Embedding a batch of </span><code class="inlineCode"><span class="koboSpan" id="kobo.966.1">chunks_to_embed</span></code><span class="koboSpan" id="kobo.967.1">:
        </span><pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.968.1">for</span></span><span class="koboSpan" id="kobo.969.1"> chunk </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.970.1">in</span></span><span class="koboSpan" id="kobo.971.1"> chunks_to_embed:
      embedding = get_embedding(chunk, model=embedding_model)
      current_embeddings.append(embedding)…
</span></code></pre>
      </li>
      <li class="bulletList"><span class="koboSpan" id="kobo.972.1">Updating the start and end values of the chunks to embed for the next batch:
        </span><pre class="programlisting code-one"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.973.1"># Update the chunk indices</span></span><span class="koboSpan" id="kobo.974.1">
    chunk_start += </span><span class="hljs-number"><span class="koboSpan" id="kobo.975.1">1000</span></span><span class="koboSpan" id="kobo.976.1">
    chunk_end += </span><span class="hljs-number"><span class="koboSpan" id="kobo.977.1">1000</span></span>
</code></pre>
      </li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.978.1">A function was added in case the batches are not perfect multiples of the batch size:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.979.1"># Process the remaining chunks if any</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.980.1">if</span></span><span class="koboSpan" id="kobo.981.1"> chunk_end &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.982.1">len</span></span><span class="koboSpan" id="kobo.983.1">(chunks):
    remaining_chunks = chunks[chunk_end:]
    remaining_embeddings = [get_embedding(chunk, model=embedding_model) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.984.1">for</span></span><span class="koboSpan" id="kobo.985.1"> chunk </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.986.1">in</span></span><span class="koboSpan" id="kobo.987.1"> remaining_chunks]
    embeddings.extend(remaining_embeddings)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.988.1">The output displays the counter and the processing time:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.989.1">All chunks processed.
</span><span class="koboSpan" id="kobo.989.2">Batch 1 embedded.
</span><span class="koboSpan" id="kobo.989.3">...
</span><span class="koboSpan" id="kobo.989.4">Batch 10 embedded.
</span><span class="koboSpan" id="kobo.989.5">Response Time: 2689.46  seconds
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.990.1">The response time may seem long and may vary for each run, but that is what scaling is all about! </span><span class="koboSpan" id="kobo.990.2">We cannot expect to process large volumes of data in a very short time and not face performance challenges.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.991.1">We can display an </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.992.1">embedding if we wish to check that everything went well:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.993.1">print</span></span><span class="koboSpan" id="kobo.994.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.995.1">"First embedding:"</span></span><span class="koboSpan" id="kobo.996.1">, embeddings[</span><span class="hljs-number"><span class="koboSpan" id="kobo.997.1">0</span></span><span class="koboSpan" id="kobo.998.1">])
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.999.1">The output displays the embedding:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1000.1">First embedding: [-0.024449337273836136, -0.00936567410826683,…
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1001.1">Let’s verify if we have the same number of text chunks (customer records) and vectors (embeddings):</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1002.1"># Check the lengths of the chunks and embeddings</span></span><span class="koboSpan" id="kobo.1003.1">
num_chunks = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1004.1">len</span></span><span class="koboSpan" id="kobo.1005.1">(chunks)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1006.1">print</span></span><span class="koboSpan" id="kobo.1007.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1008.1">f"Number of chunks: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1009.1">{num_chunks}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1010.1">"</span></span><span class="koboSpan" id="kobo.1011.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1012.1">print</span></span><span class="koboSpan" id="kobo.1013.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1014.1">f"Number of embeddings: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1015.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1016.1">len</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1017.1">(embeddings)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1018.1">"</span></span><span class="koboSpan" id="kobo.1019.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1020.1">The output confirms that we are ready to move to Pinecone:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1021.1">Number of chunks: 10000
Number of embeddings: 10000
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1022.1">We have now chunked and embedded the data. </span><span class="koboSpan" id="kobo.1022.2">We will duplicate the data to simulate scaling in this notebook.</span></p>
    <h3 id="_idParaDest-167" class="heading-3"><span class="koboSpan" id="kobo.1023.1">Duplicating data</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.1024.1">We will duplicate the </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.1025.1">chunked and embedded data; this way, you can simulate volumes without paying for the OpenAI embeddings. </span><span class="koboSpan" id="kobo.1025.2">The cost of the embedding data and the time performances are linear. </span><span class="koboSpan" id="kobo.1025.3">So we can simulate scaling with a corpus of 50,000 data points, for example, and extrapolate the response times and cost to any size we need.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1026.1">The code is straightforward. </span><span class="koboSpan" id="kobo.1026.2">We first determine the number of times we want to duplicate the data:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1027.1"># Define the duplication size</span></span><span class="koboSpan" id="kobo.1028.1">
dsize = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1029.1">5</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.1030.1"># You can set this to any value between 1 and n as per your experimentation requirements</span></span><span class="koboSpan" id="kobo.1031.1">
total=dsize * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1032.1">len</span></span><span class="koboSpan" id="kobo.1033.1">(chunks)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1034.1">print</span></span><span class="koboSpan" id="kobo.1035.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1036.1">"Total size"</span></span><span class="koboSpan" id="kobo.1037.1">, total)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1038.1">The program will then duplicate the chunks and the embeddings:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1039.1"># Initialize new lists for duplicated chunks and embeddings</span></span><span class="koboSpan" id="kobo.1040.1">
duplicated_chunks = []
duplicated_embeddings = []
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1041.1"># Loop through the original lists and duplicate each entry</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1042.1">for</span></span><span class="koboSpan" id="kobo.1043.1"> i </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1044.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1045.1">range</span></span><span class="koboSpan" id="kobo.1046.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1047.1">len</span></span><span class="koboSpan" id="kobo.1048.1">(chunks)):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1049.1">for</span></span><span class="koboSpan" id="kobo.1050.1"> _ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1051.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1052.1">range</span></span><span class="koboSpan" id="kobo.1053.1">(dsize):
        duplicated_chunks.append(chunks[i])
        duplicated_embeddings.append(embeddings[i])
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1054.1">The code then checks if the</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.1055.1"> number of chunks fits the number of embeddings:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1056.1"># Checking the lengths of the duplicated lists</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1057.1">print</span></span><span class="koboSpan" id="kobo.1058.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1059.1">f"Number of duplicated chunks: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1060.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1061.1">len</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1062.1">(duplicated_chunks)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1063.1">"</span></span><span class="koboSpan" id="kobo.1064.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1065.1">print</span></span><span class="koboSpan" id="kobo.1066.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1067.1">f"Number of duplicated embeddings: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1068.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1069.1">len</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1070.1">(duplicated_embeddings)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1071.1">"</span></span><span class="koboSpan" id="kobo.1072.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1073.1">Finally, the output confirms that we duplicated the data five times:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1074.1">Total size 50000
Number of duplicated chunks: 50000
Number of duplicated embeddings: 50000
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1075.1">50,000 data points is a good volume to begin with, giving us the necessary data to populate a vector store. </span><span class="koboSpan" id="kobo.1075.2">Let’s now create the Pinecone index.</span></p>
    <h2 id="_idParaDest-168" class="heading-2"><span class="koboSpan" id="kobo.1076.1">Creating the Pinecone index</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.1077.1">The first step is to make </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.1078.1">sure our API key is initialized with the name of the variable we prefer and then create a Pinecone instance:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1079.1">import</span></span><span class="koboSpan" id="kobo.1080.1"> os
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1081.1">from</span></span><span class="koboSpan" id="kobo.1082.1"> pinecone </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1083.1">import</span></span><span class="koboSpan" id="kobo.1084.1"> Pinecone, ServerlessSpec
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1085.1"># initialize connection to pinecone (get API key at app.pinecone.io)</span></span><span class="koboSpan" id="kobo.1086.1">
api_key = os.environ.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1087.1">'PINECONE_API_KEY'</span></span><span class="koboSpan" id="kobo.1088.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1089.1">or</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1090.1">'PINECONE_API_KEY'</span></span><span class="koboSpan" id="kobo.1091.1">
pc = Pinecone(api_key=PINECONE_API_KEY)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1092.1">The Pinecone instance, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">pc</span></code><span class="koboSpan" id="kobo.1094.1">, has been created. </span><span class="koboSpan" id="kobo.1094.2">Now, we will choose the index name, our cloud, and region:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1095.1">from</span></span><span class="koboSpan" id="kobo.1096.1"> pinecone </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1097.1">import</span></span><span class="koboSpan" id="kobo.1098.1"> ServerlessSpec
index_name = [YOUR INDEX NAME] </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1099.1">#'bank-index-900'for example</span></span><span class="koboSpan" id="kobo.1100.1">
cloud = os.environ.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1101.1">'PINECONE_CLOUD'</span></span><span class="koboSpan" id="kobo.1102.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1103.1">or</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1104.1">'aws'</span></span><span class="koboSpan" id="kobo.1105.1">
region = os.environ.get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1106.1">'PINECONE_REGION'</span></span><span class="koboSpan" id="kobo.1107.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1108.1">or</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1109.1">'us-east-1'</span></span><span class="koboSpan" id="kobo.1110.1">
spec = ServerlessSpec(cloud=cloud, region=region)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1111.1">We have now indicated that </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.1112.1">we want a serverless cloud instance (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1113.1">spec</span></code><span class="koboSpan" id="kobo.1114.1">) with AWS in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">'us-east-1'</span></code><span class="koboSpan" id="kobo.1116.1"> location. </span><span class="koboSpan" id="kobo.1116.2">We are ready to create the index (the type of vector store) named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1117.1">'bank-index-50000'</span></code><span class="koboSpan" id="kobo.1118.1"> with the following code:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1119.1">import</span></span><span class="koboSpan" id="kobo.1120.1"> time
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1121.1">import</span></span><span class="koboSpan" id="kobo.1122.1"> pinecone
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1123.1"># check if index already exists (it shouldn't if this is first time)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1124.1">if</span></span><span class="koboSpan" id="kobo.1125.1"> index_name </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1126.1">not</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1127.1">in</span></span><span class="koboSpan" id="kobo.1128.1"> pc.list_indexes().names():
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1129.1"># if does not exist, create index</span></span><span class="koboSpan" id="kobo.1130.1">
    pc.create_index(
        index_name,
        dimension=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1131.1">1536</span></span><span class="koboSpan" id="kobo.1132.1">,  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1133.1">#Dimension of the embedding model</span></span><span class="koboSpan" id="kobo.1134.1">
        metric=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1135.1">'cosine'</span></span><span class="koboSpan" id="kobo.1136.1">,
        spec=spec
    )
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1137.1"># wait for index to be initialized</span></span><span class="koboSpan" id="kobo.1138.1">
    time.sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1139.1">1</span></span><span class="koboSpan" id="kobo.1140.1">)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1141.1"># connect to index</span></span><span class="koboSpan" id="kobo.1142.1">
index = pc.Index(index_name)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1143.1"># view index stats</span></span><span class="koboSpan" id="kobo.1144.1">
index.describe_index_stats()
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1145.1">We added the following two parameters to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">index_name</span></code><span class="koboSpan" id="kobo.1147.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1148.1">spec</span></code><span class="koboSpan" id="kobo.1149.1">:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1150.1">dimension=1536</span></code><span class="koboSpan" id="kobo.1151.1"> represents the length of the embeddings vector that you can adapt to the embedding model of your choice.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1152.1">metric='cosine'</span></code><span class="koboSpan" id="kobo.1153.1"> is the metric we will use for vector similarity between the embedded vectors. </span><span class="koboSpan" id="kobo.1153.2">You can </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.1154.1">also choose other metrics, such as Euclidean distance: </span><a href="https://www.pinecone.io/learn/vector-similarity/"><span class="url"><span class="koboSpan" id="kobo.1155.1">https://www.pinecone.io/learn/vector-similarity/</span></span></a><span class="koboSpan" id="kobo.1156.1">.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.1157.1">When the index is created, the program displays the description of the index:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1158.1">{'dimension': 1536,
 'index_fullness': 0.0,
 'namespaces': {},
 'total_vector_count': 0}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1159.1">The vector count and index fullness are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1160.1">0</span></code><span class="koboSpan" id="kobo.1161.1"> since we haven’t been populating the vector store. </span><span class="koboSpan" id="kobo.1161.2">Great, now</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1162.1"> we are ready to upsert!</span></p>
    <h2 id="_idParaDest-169" class="heading-2"><span class="koboSpan" id="kobo.1163.1">Upserting</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.1164.1">The section’s goal is to</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1165.1"> populate the vector store with our 50,000 embedded vectors and their associated metadata (chunks). </span><span class="koboSpan" id="kobo.1165.2">The objective is to fully understand the scaling process and use synthetic data to reach the 50,000+ vector level. </span><span class="koboSpan" id="kobo.1165.3">You can go back to the previous section and duplicate the data up to any value you wish. </span><span class="koboSpan" id="kobo.1165.4">However, bear in mind that the upserting time to a Pinecone index is linear. </span><span class="koboSpan" id="kobo.1165.5">You simply need to extrapolate the performances to the size you want to evaluate to obtain the approximate time it would take. </span><span class="koboSpan" id="kobo.1165.6">Check the Pinecone pricing </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.1166.1">before running the upserting process: </span><a href="https://www.pinecone.io/pricing/"><span class="url"><span class="koboSpan" id="kobo.1167.1">https://www.pinecone.io/pricing/</span></span></a><span class="koboSpan" id="kobo.1168.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1169.1">We will populate (upsert) the vector store with three fields:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1170.1">ids</span></code><span class="koboSpan" id="kobo.1171.1">: Contains a unique identifier for each chunk, which will be a counter we increment as we upsert the data</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1172.1">embedding</span></code><span class="koboSpan" id="kobo.1173.1">: Contains the vectors (embedded chunks) we created</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1174.1">chunks</span></code><span class="koboSpan" id="kobo.1175.1">: Contains the chunks in plain text, which is the metadata</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.1176.1">The code will populate the data in batches. </span><span class="koboSpan" id="kobo.1176.2">Let’s first define the batch upserting function:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1177.1"># upsert function</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1178.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1179.1">upsert_to_pinecone</span></span><span class="koboSpan" id="kobo.1180.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1181.1">data, batch_size</span></span><span class="koboSpan" id="kobo.1182.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1183.1">for</span></span><span class="koboSpan" id="kobo.1184.1"> i </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1185.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1186.1">range</span></span><span class="koboSpan" id="kobo.1187.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1188.1">0</span></span><span class="koboSpan" id="kobo.1189.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1190.1">len</span></span><span class="koboSpan" id="kobo.1191.1">(data), batch_size):
        batch = data[i:i+batch_size]
        index.upsert(vectors=batch)
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1192.1">#time.sleep(1)  # Optional: add delay to avoid rate limits</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1193.1">We will measure the time it takes to process our corpus:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1194.1">import</span></span><span class="koboSpan" id="kobo.1195.1"> pinecone
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1196.1">import</span></span><span class="koboSpan" id="kobo.1197.1"> time
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1198.1">import</span></span><span class="koboSpan" id="kobo.1199.1"> sys
start_time = time.time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1200.1"># Start timing before the request</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1201.1">Now, we create a function that will calculate the size of the batches and limit them to 4 MB, which is close to the present Pinecone upsert batch size limit:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1202.1"># Function to calculate the size of a batch</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1203.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1204.1">get_batch_size</span></span><span class="koboSpan" id="kobo.1205.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1206.1">data, limit=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1207.1">4000000</span></span><span class="koboSpan" id="kobo.1208.1">):  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1209.1"># limit set slightly below 4MB to be safe</span></span><span class="koboSpan" id="kobo.1210.1">
    total_size = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1211.1">0</span></span><span class="koboSpan" id="kobo.1212.1">
    batch_size = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1213.1">0</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1214.1">for</span></span><span class="koboSpan" id="kobo.1215.1"> item </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1216.1">in</span></span><span class="koboSpan" id="kobo.1217.1"> data:
        item_size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1218.1">sum</span></span><span class="koboSpan" id="kobo.1219.1">([sys.getsizeof(v) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1220.1">for</span></span><span class="koboSpan" id="kobo.1221.1"> v </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1222.1">in</span></span><span class="koboSpan" id="kobo.1223.1"> item.values()])
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1224.1">if</span></span><span class="koboSpan" id="kobo.1225.1"> total_size + item_size &gt; limit:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1226.1">break</span></span><span class="koboSpan" id="kobo.1227.1">
        total_size += item_size
        batch_size += </span><span class="hljs-number"><span class="koboSpan" id="kobo.1228.1">1</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1229.1">return</span></span><span class="koboSpan" id="kobo.1230.1"> batch_size
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1231.1">We can now create our</span><a id="_idIndexMarker422"/> <code class="inlineCode"><span class="koboSpan" id="kobo.1232.1">upsert</span></code><span class="koboSpan" id="kobo.1233.1"> function:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1234.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1235.1">batch_upsert</span></span><span class="koboSpan" id="kobo.1236.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1237.1">data</span></span><span class="koboSpan" id="kobo.1238.1">):
    total = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1239.1">len</span></span><span class="koboSpan" id="kobo.1240.1">(data)
    i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1241.1">0</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1242.1">while</span></span><span class="koboSpan" id="kobo.1243.1"> i &lt; total:
        batch_size = get_batch_size(data[i:])
        batch = data[i:i + batch_size]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1244.1">if</span></span><span class="koboSpan" id="kobo.1245.1"> batch:
            upsert_to_pinecone(batch,batch_size)
            i += batch_size
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1246.1">print</span></span><span class="koboSpan" id="kobo.1247.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1248.1">f"Upserted </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1249.1">{i}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1250.1">/</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1251.1">{total}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1252.1"> items..."</span></span><span class="koboSpan" id="kobo.1253.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1254.1"># Display current progress</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.1255.1">else</span></span><span class="koboSpan" id="kobo.1256.1">:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1257.1">break</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.1258.1">print</span></span><span class="koboSpan" id="kobo.1259.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1260.1">"Upsert complete."</span></span><span class="koboSpan" id="kobo.1261.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1262.1">We need to generate unique IDs for the data we upsert:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1263.1"># Generate IDs for each data item</span></span><span class="koboSpan" id="kobo.1264.1">
ids = [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1265.1">str</span></span><span class="koboSpan" id="kobo.1266.1">(i) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1267.1">for</span></span><span class="koboSpan" id="kobo.1268.1"> i </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1269.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1270.1">range</span></span><span class="koboSpan" id="kobo.1271.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1272.1">1</span></span><span class="koboSpan" id="kobo.1273.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1274.1">len</span></span><span class="koboSpan" id="kobo.1275.1">(duplicated_chunks) + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1276.1">1</span></span><span class="koboSpan" id="kobo.1277.1">)]
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1278.1">We will create the metadata to upsert the dataset to Pinecone:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1279.1"># Prepare data for upsert</span></span><span class="koboSpan" id="kobo.1280.1">
data_for_upsert = [
    {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1281.1">"id"</span></span><span class="koboSpan" id="kobo.1282.1">: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1283.1">str</span></span><span class="koboSpan" id="kobo.1284.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1285.1">id</span></span><span class="koboSpan" id="kobo.1286.1">), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1287.1">"values"</span></span><span class="koboSpan" id="kobo.1288.1">: emb, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1289.1">"metadata"</span></span><span class="koboSpan" id="kobo.1290.1">: {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1291.1">"text"</span></span><span class="koboSpan" id="kobo.1292.1">: chunk}}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1293.1">for</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1294.1">id</span></span><span class="koboSpan" id="kobo.1295.1">, (chunk, emb) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1296.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1297.1">zip</span></span><span class="koboSpan" id="kobo.1298.1">(ids, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1299.1">zip</span></span><span class="koboSpan" id="kobo.1300.1">(duplicated_chunks, duplicated_embeddings))
]
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1301.1">We now have everything we need to upsert in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1302.1">data_for_upsert</span></code><span class="koboSpan" id="kobo.1303.1">:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1304.1">"id": str(ids[i])</span></code><span class="koboSpan" id="kobo.1305.1"> contains the IDs we created with the seed.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1306.1">"values": emb</span></code><span class="koboSpan" id="kobo.1307.1"> contains the chunks we embedded into vectors.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">"metadata": {"text": chunk}</span></code><span class="koboSpan" id="kobo.1309.1"> contains the chunks we embedded.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.1310.1">We now run the batch upsert process:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1311.1"># Upsert data in batches</span></span><span class="koboSpan" id="kobo.1312.1">
batch_upsert(data_for_upsert)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1313.1">Finally, we measure the response time:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1314.1">response_time = time.time() - start_time  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1315.1"># Measure response time</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1316.1">print</span></span><span class="koboSpan" id="kobo.1317.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1318.1">f"Upsertion response time: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1319.1">{response_time:</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1320.1">.2</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1321.1">f}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1322.1"> seconds"</span></span><span class="koboSpan" id="kobo.1323.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1324.1"># Print response time</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1325.1">The output contains</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.1326.1"> useful information that shows the batch progression:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1327.1">Upserted 316/50000 items...
</span><span class="koboSpan" id="kobo.1327.2">Upserted 632/50000 items...
</span><span class="koboSpan" id="kobo.1327.3">Upserted 948/50000 items...
</span><span class="koboSpan" id="kobo.1327.4">…
Upserted 49612/50000 items...
</span><span class="koboSpan" id="kobo.1327.5">Upserted 49928/50000 items...
</span><span class="koboSpan" id="kobo.1327.6">Upserted 50000/50000 items...
</span><span class="koboSpan" id="kobo.1327.7">Upsert complete.
</span><span class="koboSpan" id="kobo.1327.8">Upsertion response time: 560.66 seconds
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1328.1">The time shows that it takes just under one minute (56 seconds) per 10,000 data points. </span><span class="koboSpan" id="kobo.1328.2">You can try a larger corpus. </span><span class="koboSpan" id="kobo.1328.3">The time should remain linear.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1329.1">We can also view the Pinecone index statistics to see how many vectors were uploaded:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1330.1">print</span></span><span class="koboSpan" id="kobo.1331.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1332.1">"Index stats"</span></span><span class="koboSpan" id="kobo.1333.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1334.1">print</span></span><span class="koboSpan" id="kobo.1335.1">(index.describe_index_stats(include_metadata=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1336.1">True</span></span><span class="koboSpan" id="kobo.1337.1">))
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1338.1">The output confirms that the upserting process was successful:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1339.1">Index stats
{'dimension': 1536,
 'index_fullness': 0.0,
 'namespaces': {'': {'vector_count': 50000}},
 'total_vector_count': 50000}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1340.1">The upsert output shows</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.1341.1"> that we upserted 50,000 data points but the output shows less, most probably due to duplicates within the data.</span></p>
    <h2 id="_idParaDest-170" class="heading-2"><span class="koboSpan" id="kobo.1342.1">Querying the Pinecone index</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.1343.1">The task now is to verify the</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.1344.1"> response times with a large Pinecone index. </span><span class="koboSpan" id="kobo.1344.2">Let’s create a function to query the vector store and display the results:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1345.1"># Print the query results along with metadata</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1346.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1347.1">display_results</span></span><span class="koboSpan" id="kobo.1348.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1349.1">query_results</span></span><span class="koboSpan" id="kobo.1350.1">):
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1351.1">for</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1352.1">match</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1353.1">in</span></span><span class="koboSpan" id="kobo.1354.1"> query_results[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1355.1">'matches'</span></span><span class="koboSpan" id="kobo.1356.1">]:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1357.1">print</span></span><span class="koboSpan" id="kobo.1358.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1359.1">f"ID: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1360.1">{</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1361.1">match</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1362.1">[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1363.1">'id'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1364.1">]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1365.1">, Score: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1366.1">{</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1367.1">match</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1368.1">[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1369.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1370.1">score'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1371.1">]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1372.1">"</span></span><span class="koboSpan" id="kobo.1373.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1374.1">if</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1375.1">'metadata'</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1376.1">in</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1377.1">match</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1378.1">and</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1379.1">'text'</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1380.1">in</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1381.1">match</span></span><span class="koboSpan" id="kobo.1382.1">[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1383.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1384.1">metadata'</span></span><span class="koboSpan" id="kobo.1385.1">]:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1386.1">print</span></span><span class="koboSpan" id="kobo.1387.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1388.1">f"Text: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1389.1">{</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1390.1">match</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1391.1">[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1392.1">'metadata'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1393.1">][</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1394.1">'text'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1395.1">]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1396.1">"</span></span><span class="koboSpan" id="kobo.1397.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1398.1">else</span></span><span class="koboSpan" id="kobo.1399.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1400.1">print</span></span><span class="koboSpan" id="kobo.1401.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1402.1">"No metadata available."</span></span><span class="koboSpan" id="kobo.1403.1">)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1404.1">We need an embedding function for the query using the same embedding model as we implemented to embed the chunks of the dataset:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1405.1">embedding_model = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1406.1">"text-embedding-3-small"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1407.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1408.1">get_embedding</span></span><span class="koboSpan" id="kobo.1409.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1410.1">text, model=embedding_model</span></span><span class="koboSpan" id="kobo.1411.1">):
    text = text.replace(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1412.1">"\n"</span></span><span class="koboSpan" id="kobo.1413.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1414.1">" "</span></span><span class="koboSpan" id="kobo.1415.1">)
    response = client.embeddings.create(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1416.1">input</span></span><span class="koboSpan" id="kobo.1417.1">=[text], model=model)
    embedding = response.data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1418.1">0</span></span><span class="koboSpan" id="kobo.1419.1">].embedding
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1420.1">return</span></span><span class="koboSpan" id="kobo.1421.1"> embedding
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1422.1">We can now query the</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.1423.1"> Pinecone vector store to conduct a unit test and display the results and response time. </span><span class="koboSpan" id="kobo.1423.2">We first initialize the OpenAI client and start time:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1424.1">import</span></span><span class="koboSpan" id="kobo.1425.1"> openai
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1426.1"># Initialize the OpenAI client</span></span><span class="koboSpan" id="kobo.1427.1">
client = openai.OpenAI()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1428.1">print</span></span><span class="koboSpan" id="kobo.1429.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1430.1">"Querying vector store"</span></span><span class="koboSpan" id="kobo.1431.1">)
start_time = time.time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1432.1"># Start timing before the request</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1433.1">We then query the vector store with a customer profile that does not exist in the dataset:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1434.1">query_text = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1435.1">"Customer Robertson CreditScore 632Age 21 Tenure 2Balance 0.0NumOfProducts 1HasCrCard 1IsActiveMember 1EstimatedSalary 99000 Exited 1Complain 1Satisfaction Score 2Card Type DIAMONDPoint Earned 399"</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1436.1">The query is embedded with the same model as the one used to embed the dataset:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1437.1">query_embedding = get_embedding(query_text,model=embedding_model)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1438.1">We run the query and display the output:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1439.1">query_results = index.query(vector=query_embedding, top_k=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1440.1">1</span></span><span class="koboSpan" id="kobo.1441.1">, include_metadata=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1442.1">True</span></span><span class="koboSpan" id="kobo.1443.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1444.1"># Request metadata</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1445.1">#print("raw query_results",query_results)</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1446.1">print</span></span><span class="koboSpan" id="kobo.1447.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1448.1">"processed query results"</span></span><span class="koboSpan" id="kobo.1449.1">)
display_results(query_results) </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1450.1">#display results</span></span><span class="koboSpan" id="kobo.1451.1">
response_time = time.time() - start_time              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1452.1"># Measure response time</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1453.1">print</span></span><span class="koboSpan" id="kobo.1454.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1455.1">f"Querying response time: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1456.1">{response_time:</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1457.1">.2</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1458.1">f}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1459.1"> seconds"</span></span><span class="koboSpan" id="kobo.1460.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1461.1"># Print response time</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1462.1">The output displays the query response and time:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1463.1">Querying vector store
Querying vector store
processed query results
ID: 46366, Score: 0.823366046
Text: CustomerId: 15740160 CreditScore: 616 Age: 31 Tenure: 1 Balance: 0.0 NumOfProducts: 2 HasCrCard: 1 IsActiveMember: 1 EstimatedSalary: 54706.75 Exited: 0 Complain: 0 Satisfaction Score: 3 Card Type: DIAMOND Point Earned: 852
Querying response time: 0.74 seconds
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1464.1">We can see that the response quality is satisfactory because it found a similar profile. </span><span class="koboSpan" id="kobo.1464.2">The time is excellent: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1465.1">0.74 seconds</span></code><span class="koboSpan" id="kobo.1466.1">. </span><span class="koboSpan" id="kobo.1466.2">When reaching a 1,000,000 vector count, for example, the</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.1467.1"> response time should still be constant at less than a second. </span><span class="koboSpan" id="kobo.1467.2">That is the magic of the Pinecone index!</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1468.1">If we go to our organization on </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.1469.1">Pinecone, </span><a href="https://app.pinecone.io/organizations/"><span class="url"><span class="koboSpan" id="kobo.1470.1">https://app.pinecone.io/organizations/</span></span></a><span class="koboSpan" id="kobo.1471.1">, and click on our index, we can monitor our statistics, analyze our usage, and more, as illustrated here:</span></p>
    <figure class="mediaobject"> <span class="koboSpan" id="kobo.1472.1"><img src="../Images/B31169_06_06.png" alt="A screenshot of a computer  Description automatically generated"/></span></figure>
    <p class="packt_figref"><span class="koboSpan" id="kobo.1473.1">Figure 6.6: Visualizing the Pinecone index vector count in the Pinecone console</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1474.1">Our Pinecone index is now</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.1475.1"> ready to augment inputs and generate content.</span></p>
    <h1 id="_idParaDest-171" class="heading-1"><span class="koboSpan" id="kobo.1476.1">Pipeline 3: RAG generative AI</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.1477.1">In this section, we will use RAG generative AI to automate a customized and engaging marketing message to the customers of the bank to encourage them to remain loyal. </span><span class="koboSpan" id="kobo.1477.2">We will be building on </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1478.1">our programs on data preparation and Pinecone indexing; we will leverage the Pinecone vector database for advanced search functionalities. </span><span class="koboSpan" id="kobo.1478.2">We will choose a target vector that represents a market segment to query the Pinecone index. </span><span class="koboSpan" id="kobo.1478.3">The response will be processed to extract the top k similar vectors. </span><span class="koboSpan" id="kobo.1478.4">We will then augment the user input with this target market to ask OpenAI to make recommendations to the market segment targeted with customized messages.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1479.1">You may open </span><code class="inlineCode"><span class="koboSpan" id="kobo.1480.1">Pipeline-3_RAG_Generative AI.ipynb</span></code><span class="koboSpan" id="kobo.1481.1"> on GitHub. </span><span class="koboSpan" id="kobo.1481.2">The first code section in this notebook, </span><em class="italic"><span class="koboSpan" id="kobo.1482.1">Installing the environment</span></em><span class="koboSpan" id="kobo.1483.1">, is the same as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1484.1">2-Pincone_vector_store-1M.ipynb</span></code><span class="koboSpan" id="kobo.1485.1">, built in the </span><em class="italic"><span class="koboSpan" id="kobo.1486.1">Pipeline 2: Scaling a Pinecone index (vector store)</span></em><span class="koboSpan" id="kobo.1487.1"> section earlier in this chapter. </span><span class="koboSpan" id="kobo.1487.2">The </span><em class="italic"><span class="koboSpan" id="kobo.1488.1">Pinecone index</span></em><span class="koboSpan" id="kobo.1489.1"> in the second code section is also the same as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1490.1">2-Pincone_vector_store-1M.ipynb</span></code><span class="koboSpan" id="kobo.1491.1">. </span><span class="koboSpan" id="kobo.1491.2">However, this time, the Pinecone index code checks whether a Pinecone index exists and connects to it if it does, rather than creating a new index.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1492.1">Let’s run an example of RAG with GPT-4o.</span></p>
    <h2 id="_idParaDest-172" class="heading-2"><span class="koboSpan" id="kobo.1493.1">RAG with GPT-4o</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.1494.1">In this section of the code, we will </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1495.1">query the Pinecone vector store, augment the</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.1496.1"> user input, and generate a response with GPT-4o. </span><span class="koboSpan" id="kobo.1496.2">It is the same process as with Deep Lake and an OpenAI generative model in </span><em class="italic"><span class="koboSpan" id="kobo.1497.1">Chapter 3</span></em><span class="koboSpan" id="kobo.1498.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1499.1">Building Index-Based RAG with LlamaIndex, Deep Lake, and OpenAI</span></em><span class="koboSpan" id="kobo.1500.1">, for example. </span><span class="koboSpan" id="kobo.1500.2">However, the nature and usage of the Pinecone query is quite different in this case for the following reasons:</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1501.1">Target vector</span></strong><span class="koboSpan" id="kobo.1502.1">: The user input is not a question in the classical sense. </span><span class="koboSpan" id="kobo.1502.2">In this case, it is a target vector representing the profile of a market segment.</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1503.1">Usage</span></strong><span class="koboSpan" id="kobo.1504.1">:</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.1505.1">The usage isn’t to augment the generative AI in the classical dialog sense (questions, summaries). </span><span class="koboSpan" id="kobo.1505.2">In this case, we expect GPT-4o to write an engaging, customized email to offer products and services.</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1506.1">Query time</span></strong><span class="koboSpan" id="kobo.1507.1">:</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.1508.1">Speed is </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.1509.1">critical when scaling an application. </span><span class="koboSpan" id="kobo.1509.2">We will measure the query time on the Pinecone index that contains 1,000,000+ vectors.</span></li>
    </ul>
    <h3 id="_idParaDest-173" class="heading-3"><span class="koboSpan" id="kobo.1510.1">Querying the dataset</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.1511.1">We will need an embedding </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.1512.1">function to embed the input. </span><span class="koboSpan" id="kobo.1512.2">We will simplify and use the same embedding model we used in the </span><em class="italic"><span class="koboSpan" id="kobo.1513.1">Embedding</span></em><span class="koboSpan" id="kobo.1514.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.1515.1">Pipeline 2: Scaling a Pinecone index (vector store)</span></em><span class="koboSpan" id="kobo.1516.1"> for compatibility reasons:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1517.1">import</span></span><span class="koboSpan" id="kobo.1518.1"> openai
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1519.1">import</span></span><span class="koboSpan" id="kobo.1520.1"> time
embedding_model= </span><span class="hljs-string"><span class="koboSpan" id="kobo.1521.1">"text-embedding-3-small"</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1522.1"># Initialize the OpenAI client</span></span><span class="koboSpan" id="kobo.1523.1">
client = openai.OpenAI()
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1524.1">def</span></span><span class="koboSpan" id="kobo.1525.1"> get_embedding(text, model=embedding_model):
    text = text.replace(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1526.1">"\n"</span></span><span class="koboSpan" id="kobo.1527.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1528.1">" "</span></span><span class="koboSpan" id="kobo.1529.1">)
    response = client.embeddings.create(input=[text], model=model)
    embedding = response.data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1530.1">0</span></span><span class="koboSpan" id="kobo.1531.1">].embedding
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1532.1">return</span></span><span class="koboSpan" id="kobo.1533.1"> embedding
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1534.1">We are now ready to query the Pinecone index.</span></p>
    <h3 id="_idParaDest-174" class="heading-3"><span class="koboSpan" id="kobo.1535.1">Querying a target vector</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.1536.1">A target vector represents a </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.1537.1">market segment that a marketing team wants to focus on for recommendations to increase customer loyalty. </span><span class="koboSpan" id="kobo.1537.2">Your imagination and creativity are the only limits! </span><span class="koboSpan" id="kobo.1537.3">Usually, the marketing team will be part of the design team for this pipeline. </span><span class="koboSpan" id="kobo.1537.4">You might want to organize workshops to try various scenarios until the marketing team is satisfied. </span><span class="koboSpan" id="kobo.1537.5">If you are part of the marketing team, then you want to help design target vectors. </span><span class="koboSpan" id="kobo.1537.6">In any case, human insights into our adaptive creativity will lead to many ways of organizing target vectors and queries.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1538.1">In this case, we will target a market segment of customers around the age of 42 (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1539.1">Age 42</span></code><span class="koboSpan" id="kobo.1540.1">). </span><span class="koboSpan" id="kobo.1540.2">We don’t need the age to be strictly 42 or an age bracket. </span><span class="koboSpan" id="kobo.1540.3">We’ll let AI do the work for us. </span><span class="koboSpan" id="kobo.1540.4">We are also targeting a customer that has a 100,000+ (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1541.1">EstimatedSalary 101348.88</span></code><span class="koboSpan" id="kobo.1542.1">) estimated </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.1543.1">salary, which would be a loss for the bank. </span><span class="koboSpan" id="kobo.1543.2">We’re choosing a customer who has complained (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1544.1">Complain 1</span></code><span class="koboSpan" id="kobo.1545.1">) and seems to be exiting (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1546.1">Exited 1</span></code><span class="koboSpan" id="kobo.1547.1">) the bank. </span><span class="koboSpan" id="kobo.1547.2">Let’s suppose that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1548.1">Exited 1</span></code><span class="koboSpan" id="kobo.1549.1">, in this scenario, means that the customer has made a request to close an account but it hasn’t been finalized yet. </span><span class="koboSpan" id="kobo.1549.2">Let’s also consider that the marketing department chose the target vector.</span></p>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1550.1">query_text</span></code><span class="koboSpan" id="kobo.1551.1"> represents the customer profiles we are searching for:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1552.1">import</span></span><span class="koboSpan" id="kobo.1553.1"> time
start_time = time.time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1554.1"># Start timing before the request</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1555.1"># Target vector</span></span><span class="koboSpan" id="kobo.1556.1">
 "
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1557.1"># Target vector</span></span><span class="koboSpan" id="kobo.1558.1">
query_text = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1559.1">"Customer Henderson CreditScore 599</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1560.1"> Age 37Tenure 2Balance 0.0NumOfProducts 1HasCrCard 1IsActiveMember 1EstimatedSalary 107000.88Exited 1Complain 1Satisfaction Score 2Card Type DIAMONDPoint Earned 501"</span></span><span class="koboSpan" id="kobo.1561.1">
query_embedding = get_embedding(text,model=embedding_model)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1562.1">We have embedded the query. </span><span class="koboSpan" id="kobo.1562.2">Let’s now retrieve the top-k customer profiles that fit the target vector and parse the result:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1563.1"># Perform the query using the embedding</span></span><span class="koboSpan" id="kobo.1564.1">
query_results = index.query(
    vector=query_embedding,
    top_k=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1565.1">5</span></span><span class="koboSpan" id="kobo.1566.1">,
    include_metadata=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1567.1">True</span></span><span class="koboSpan" id="kobo.1568.1">,
)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1569.1">We now print the response and the metadata:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1570.1"># Print the query results along with metadata</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1571.1">print</span></span><span class="koboSpan" id="kobo.1572.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1573.1">"Query Results:"</span></span><span class="koboSpan" id="kobo.1574.1">)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1575.1">for</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1576.1">match</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1577.1">in</span></span><span class="koboSpan" id="kobo.1578.1"> query_results[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1579.1">'matches'</span></span><span class="koboSpan" id="kobo.1580.1">]:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1581.1">print</span></span><span class="koboSpan" id="kobo.1582.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1583.1">f"ID: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1584.1">{</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1585.1">match</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1586.1">[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1587.1">'id'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1588.1">]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1589.1">, Score: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1590.1">{</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1591.1">match</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1592.1">[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1593.1">'score'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1594.1">]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1595.1">"</span></span><span class="koboSpan" id="kobo.1596.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1597.1">if</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1598.1">'metadata'</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1599.1">in</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1600.1">match</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1601.1">and</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1602.1">'text'</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1603.1">in</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1604.1">match</span></span><span class="koboSpan" id="kobo.1605.1">[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1606.1">'metadata'</span></span><span class="koboSpan" id="kobo.1607.1">]:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1608.1">print</span></span><span class="koboSpan" id="kobo.1609.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1610.1">f"Text: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1611.1">{</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1612.1">match</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1613.1">[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1614.1">'metadata'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1615.1">][</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1616.1">'text'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1617.1">]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1618.1">"</span></span><span class="koboSpan" id="kobo.1619.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1620.1">else</span></span><span class="koboSpan" id="kobo.1621.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1622.1">print</span></span><span class="koboSpan" id="kobo.1623.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1624.1">"No metadata available."</span></span><span class="koboSpan" id="kobo.1625.1">)
response_time = time.time() - start_time              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1626.1"># Measure response time</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1627.1">print</span></span><span class="koboSpan" id="kobo.1628.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1629.1">f"Querying response time: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1630.1">{response_time:</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1631.1">.2</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1632.1">f}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1633.1"> seconds"</span></span><span class="koboSpan" id="kobo.1634.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1635.1"># Print response time</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1636.1">The result is parsed to find the top-k matches to display their scores and content, as shown in the following output:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1637.1">Query Results:
ID: 46366, Score: 0.854999781
Text: CustomerId: 15740160 CreditScore: 616 Age: 31 Tenure: 1 Balance: 0.0 NumOfProducts: 2 HasCrCard: 1 IsActiveMember: 1 EstimatedSalary: 54706.75 Exited: 0 Complain: 0 Satisfaction Score: 3 Card Type: DIAMOND Point Earned: 852
Querying response time: 0.63 seconds
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1638.1">We have retrieved valuable information:</span></p>
    <ul>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1639.1">Ranking</span></strong><span class="koboSpan" id="kobo.1640.1"> through</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.1641.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1642.1">top-k</span></code><span class="koboSpan" id="kobo.1643.1"> vectors that match the target vector. </span><span class="koboSpan" id="kobo.1643.2">From one to another, depending on the target vector, the ranking will be automatically recalculated by the OpenAI generative AI model.</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1644.1">Score metric </span></strong><span class="koboSpan" id="kobo.1645.1">through the score provided. </span><span class="koboSpan" id="kobo.1645.2">A score is returned providing a metric for the response.</span></li>
      <li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1646.1">Content </span></strong><span class="koboSpan" id="kobo.1647.1">that contains the top-ranked and best scores.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.1648.1">It’s an all-in-one automated process! </span><span class="koboSpan" id="kobo.1648.2">AI is taking us to new heights but we, of course, need human control to confirm the output, as described in the previous chapter on human feedback.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1649.1">We now need to extract the relevant information to augment the input.</span></p>
    <h2 id="_idParaDest-175" class="heading-2"><span class="koboSpan" id="kobo.1650.1">Extracting relevant texts</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.1651.1">The following code goes</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.1652.1"> through the top-ranking vectors, searches for the matching text metadata, and combines the content to prepare the augmentation phase:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1653.1">relevant_texts = [</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1654.1">match</span></span><span class="koboSpan" id="kobo.1655.1">[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1656.1">'metadata'</span></span><span class="koboSpan" id="kobo.1657.1">][</span><span class="hljs-string"><span class="koboSpan" id="kobo.1658.1">'text'</span></span><span class="koboSpan" id="kobo.1659.1">] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1660.1">for</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1661.1">match</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1662.1">in</span></span><span class="koboSpan" id="kobo.1663.1"> query_results[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1664.1">'matches'</span></span><span class="koboSpan" id="kobo.1665.1">] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1666.1">if</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1667.1">'metadata'</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1668.1">in</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1669.1">match</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1670.1">and</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1671.1">'text'</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1672.1">in</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1673.1">match</span></span><span class="koboSpan" id="kobo.1674.1">[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1675.1">'metadata'</span></span><span class="koboSpan" id="kobo.1676.1">]]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1677.1"># Join all items in the list into a single string separated by a specific delimiter (e.g., a newline or space)</span></span><span class="koboSpan" id="kobo.1678.1">
combined_text = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1679.1">'\n'</span></span><span class="koboSpan" id="kobo.1680.1">.join(relevant_texts)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1681.1"># Using newline as a separator for readability</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1682.1">print</span></span><span class="koboSpan" id="kobo.1683.1">(combined_text)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1684.1">The output displays </span><code class="inlineCode"><span class="koboSpan" id="kobo.1685.1">combined_text</span></code><span class="koboSpan" id="kobo.1686.1">, relevant text we need to augment the input:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1687.1">CustomerId: 15740160 CreditScore: 616 Age: 31 Tenure: 1 Balance: 0.0 NumOfProducts: 2 HasCrCard: 1 IsActiveMember: 1 EstimatedSalary: 54706.75 Exited: 0 Complain: 0 Satisfaction Score: 3 Card Type: DIAMOND Point Earned: 852
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1688.1">We are now ready to augment the </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.1689.1">prompt before AI generation.</span></p>
    <h2 id="_idParaDest-176" class="heading-2"><span class="koboSpan" id="kobo.1690.1">Augmented prompt</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.1691.1">We will now engineer our prompt</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.1692.1"> by adding three texts:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1693.1">query_prompt</span></code><span class="koboSpan" id="kobo.1694.1">: The instructions for the generative AI model</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1695.1">query_text</span></code><span class="koboSpan" id="kobo.1696.1">: The target vector containing the target profile chosen by the marketing team</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1697.1">combined_context</span></code><span class="koboSpan" id="kobo.1698.1">: The concentrated metadata text of the similar vectors selected by the query</span></li>
    </ul>
    <p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1699.1">itext</span></code><span class="koboSpan" id="kobo.1700.1"> contains these three variables:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1701.1"># Combine texts into a single string, separated by new lines</span></span><span class="koboSpan" id="kobo.1702.1">
combined_context = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1703.1">"\n"</span></span><span class="koboSpan" id="kobo.1704.1">.join(relevant_texts)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1705.1">#prompt</span></span><span class="koboSpan" id="kobo.1706.1">
query_prompt=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1707.1">"I have this customer bank record with interesting information on age, credit score and more and similar customers. </span><span class="koboSpan" id="kobo.1707.2">What could I suggest to keep them in my bank in an email with an url to get new advantages based on the fields for each Customer ID:"</span></span><span class="koboSpan" id="kobo.1708.1">
itext=query_prompt+ query_text+combined_context
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1709.1"># Augmented input</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1710.1">print</span></span><span class="koboSpan" id="kobo.1711.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1712.1">"Prompt for the Generative AI model:"</span></span><span class="koboSpan" id="kobo.1713.1">, itext)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1714.1">The output is the core input for the generative AI model:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1715.1">Prompt for GPT-4: I have this customer bank record with interesting information on age, credit score and more and similar customers. </span><span class="koboSpan" id="kobo.1715.2">What could I suggest to keep them in my bank in an email with an url to get new advantages based on the fields for each Customer ID:…
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1716.1">We can now prepare the request for the generative AI model.</span></p>
    <h2 id="_idParaDest-177" class="heading-2"><span class="koboSpan" id="kobo.1717.1">Augmented generation</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.1718.1">In this section, we will submit the</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.1719.1"> augmented input to an OpenAI generative AI model. </span><span class="koboSpan" id="kobo.1719.2">The goal is to obtain a customized email to send the customers in the Pinecone index marketing segment we obtained through the target vector.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1720.1">We will first create an OpenAI client and choose GPT-4o as the generative AI model:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1721.1">from</span></span><span class="koboSpan" id="kobo.1722.1"> openai </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1723.1">import</span></span><span class="koboSpan" id="kobo.1724.1"> OpenAI
client = OpenAI()
gpt_model = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1725.1">"gpt-4o</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1726.1">We then introduce a time performance measurement:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1727.1">import</span></span><span class="koboSpan" id="kobo.1728.1"> time
start_time = time.time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1729.1"># Start timing before the request</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1730.1">The response time should be</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.1731.1"> relatively constant since we are only sending one request at a time in this scenario. </span><span class="koboSpan" id="kobo.1731.2">We now begin to create our completion request:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1732.1">response = client.chat.completions.create(
  model=gpt_model,
  messages=[
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1733.1">The system role provides general instructions to the model:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1734.1">    {
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.1735.1">"role"</span></span><span class="koboSpan" id="kobo.1736.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1737.1">"system"</span></span><span class="koboSpan" id="kobo.1738.1">,
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.1739.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1740.1">content"</span></span><span class="koboSpan" id="kobo.1741.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1742.1">"You are the community manager can write engaging email based on the text you have. </span><span class="koboSpan" id="kobo.1742.2">Do not use a surname but simply Dear Valued Customer instead."</span></span><span class="koboSpan" id="kobo.1743.1">
    },
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1744.1">The user role contains the engineered </span><code class="inlineCode"><span class="koboSpan" id="kobo.1745.1">itext</span></code><span class="koboSpan" id="kobo.1746.1"> prompt we designed:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1747.1">    {
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.1748.1">"role"</span></span><span class="koboSpan" id="kobo.1749.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1750.1">"user"</span></span><span class="koboSpan" id="kobo.1751.1">,
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.1752.1">"content"</span></span><span class="koboSpan" id="kobo.1753.1">: itext
    }
  ],
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1754.1">Now, we set the parameters for the request:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1755.1">  temperature=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1756.1">0</span></span><span class="koboSpan" id="kobo.1757.1">,
  max_tokens=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1758.1">300</span></span><span class="koboSpan" id="kobo.1759.1">,
  top_p=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1760.1">1</span></span><span class="koboSpan" id="kobo.1761.1">,
  frequency_penalty=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1762.1">0</span></span><span class="koboSpan" id="kobo.1763.1">,
  presence_penalty=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1764.1">0</span></span><span class="koboSpan" id="kobo.1765.1">
)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1766.1">The parameters are designed to obtain a low random yet “creative” output:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1767.1">temperature=0</span></code><span class="koboSpan" id="kobo.1768.1">: Low randomness in response</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1769.1">max_tokens=300</span></code><span class="koboSpan" id="kobo.1770.1">: Limits response length to 300 tokens</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1771.1">top_p=1</span></code><span class="koboSpan" id="kobo.1772.1">: Considers all possible tokens; full diversity</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1773.1">frequency_penalty=0</span></code><span class="koboSpan" id="kobo.1774.1">: No penalty for frequent word repetition to allow the response to remain open</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1775.1">presence_penalty=0</span></code><span class="koboSpan" id="kobo.1776.1">: No penalty for introducing new topics to allow the response to find ideas for our prompt</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.1777.1">We send the request and </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.1778.1">display the response:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1779.1">print</span></span><span class="koboSpan" id="kobo.1780.1">(response.choices[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1781.1">0</span></span><span class="koboSpan" id="kobo.1782.1">].message.content)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1783.1">The output is satisfactory for this market segment:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1784.1">Subject: Exclusive Benefits Await You at Our Bank!
</span><span class="koboSpan" id="kobo.1784.2">Dear Valued Customer,
We hope this email finds you well. </span><span class="koboSpan" id="kobo.1784.3">At our bank, we are constantly striving to enhance your banking experience and provide you with the best possible services. </span><span class="koboSpan" id="kobo.1784.4">We have noticed that you are a valued customer with a DIAMOND card, and we would like to offer you some exclusive benefits tailored just for you!
</span><span class="koboSpan" id="kobo.1784.5">Based on your profile, we have identified several opportunities that could enhance your banking experience:
1. </span><span class="koboSpan" id="kobo.1784.6">**Personalized Financial Advice**: Our financial advisors are available to help you make the most of your finances. </span><span class="koboSpan" id="kobo.1784.7">Whether it's planning for the future or managing your current assets, we are here to assist you.
</span><span class="koboSpan" id="kobo.1784.8">2. </span><span class="koboSpan" id="kobo.1784.9">**Exclusive Rewards and Offers**: As a DIAMOND cardholder, you are eligible for special rewards and offers. </span><span class="koboSpan" id="kobo.1784.10">Earn more points and enjoy exclusive discounts on various products and services.
</span><span class="koboSpan" id="kobo.1784.11">3. </span><span class="koboSpan" id="kobo.1784.12">**Enhanced Credit Options**: With your current credit score, you may qualify for better credit options. </span><span class="koboSpan" id="kobo.1784.13">We can help you explore these opportunities to improve your financial standing.
</span><span class="koboSpan" id="kobo.1784.14">4. </span><span class="koboSpan" id="kobo.1784.15">**Complimentary Financial Health Check**: We understand the importance of financial well-being. </span><span class="koboSpan" id="kobo.1784.16">Schedule a complimentary financial health check to ensure you are on the right track.
</span><span class="koboSpan" id="kobo.1784.17">5. </span><span class="koboSpan" id="kobo.1784.18">**Loyalty Programs**: Participate in our loyalty programs and earn more points for every transaction. </span><span class="koboSpan" id="kobo.1784.19">Redeem these points for exciting rewards and benefits.
</span><span class="koboSpan" id="kobo.1784.20">To explore these new advantages and more, please visit the following link: [Exclusive Benefits](https://www.yourbank
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1785.1">Since the goal of the marketing team is to convince customers not to leave and to increase their loyalty to </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.1786.1">the bank, I’d say the email we received as output is good enough. </span><span class="koboSpan" id="kobo.1786.2">Let’s display the time it took to obtain a response:</span></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1787.1">response_time = time.time() - start_time              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1788.1"># Measure response time</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1789.1">print</span></span><span class="koboSpan" id="kobo.1790.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1791.1">f"Querying response time: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1792.1">{response_time:</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1793.1">.2</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1794.1">f}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1795.1"> seconds"</span></span><span class="koboSpan" id="kobo.1796.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1797.1"># Print response time</span></span>
</code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1798.1">The response time is displayed:</span></p>
    <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1799.1">Querying response time: 2.83 seconds
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.1800.1">We have successfully produced a customized response based on a target vector. </span><span class="koboSpan" id="kobo.1800.2">This approach might be sufficient for some projects, whatever the domain. </span><span class="koboSpan" id="kobo.1800.3">Let’s summarize the RAG-driven generative recommendation system built in this chapter and continue our journey.</span></p>
    <h1 id="_idParaDest-178" class="heading-1"><span class="koboSpan" id="kobo.1801.1">Summary</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.1802.1">This chapter aimed to develop a scaled RAG-driven generative AI recommendation system using a Pinecone index and OpenAI models tailored to mitigate bank customer churn. </span><span class="koboSpan" id="kobo.1802.2">Using a Kaggle dataset, we demonstrated the process of identifying and addressing factors leading to customer dissatisfaction and account closures. </span><span class="koboSpan" id="kobo.1802.3">Our approach involved three key pipelines.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1803.1">When building </span><em class="italic"><span class="koboSpan" id="kobo.1804.1">Pipeline 1</span></em><span class="koboSpan" id="kobo.1805.1">, we streamlined the dataset by removing non-essential columns, reducing both data complexity and storage costs. </span><span class="koboSpan" id="kobo.1805.2">Through EDA, we discovered a strong correlation between customer complaints and account closures, which a k-means clustering model further validated. </span><span class="koboSpan" id="kobo.1805.3">We then designed </span><em class="italic"><span class="koboSpan" id="kobo.1806.1">Pipeline 2</span></em><span class="koboSpan" id="kobo.1807.1"> to prepare our RAG-driven system to generate personalized recommendations. </span><span class="koboSpan" id="kobo.1807.2">We processed data chunks with an OpenAI model, embedding these into a Pinecone index. </span><span class="koboSpan" id="kobo.1807.3">Pinecone’s consistent upsert capabilities ensured efficient data handling, regardless of volume. </span><span class="koboSpan" id="kobo.1807.4">Finally, we built </span><em class="italic"><span class="koboSpan" id="kobo.1808.1">Pipeline 3</span></em><span class="koboSpan" id="kobo.1809.1"> to leverage over 1,000,000 vectors within Pinecone to target specific market segments with tailored offers, aiming to boost loyalty and reduce attrition. </span><span class="koboSpan" id="kobo.1809.2">Using GPT-4o, we augmented our queries to generate compelling recommendations.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.1810.1">The successful application of a targeted vector representing a key market segment illustrated our system’s potential to craft impactful customer retention strategies. </span><span class="koboSpan" id="kobo.1810.2">However, we can improve the recommendations by expanding the Pinecone index into a multimodal knowledge base, which we will implement in the next chapter.</span></p>
    <h1 id="_idParaDest-179" class="heading-1"><span class="koboSpan" id="kobo.1811.1">Questions</span></h1>
    <ol>
      <li class="numberedList" value="1"><span class="koboSpan" id="kobo.1812.1">Does using a Kaggle dataset typically involve downloading and processing real-world data for analysis?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1813.1">Is Pinecone capable of efficiently managing large-scale vector storage for AI applications?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1814.1">Can k-means clustering help validate relationships between features such as customer complaints and churn?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1815.1">Does leveraging over a million vectors in a database hinder the ability to personalize customer interactions?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1816.1">Is the primary objective of using generative AI in business applications to automate and improve decision-making processes?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1817.1">Are lightweight development environments advantageous for rapid prototyping and application development?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1818.1">Can Pinecone’s architecture automatically scale to accommodate increasing data loads without manual intervention?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1819.1">Is generative AI typically employed to create dynamic content and recommendations based on user data?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1820.1">Does the integration of AI technologies like Pinecone and OpenAI require significant manual configuration and maintenance?</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.1821.1">Are projects that use vector databases and AI expected to effectively handle complex queries and large datasets?</span></li>
    </ol>
    <h1 id="_idParaDest-180" class="heading-1"><span class="koboSpan" id="kobo.1822.1">References</span></h1>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.1823.1">Pinecone documentation: </span><a href="https://docs.pinecone.io/guides/get-started/quickstart"><span class="url"><span class="koboSpan" id="kobo.1824.1">https://docs.pinecone.io/guides/get-started/quickstart</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.1825.1">OpenAI embedding and generative models: </span><a href="https://platform.openai.com/docs/models"><span class="url"><span class="koboSpan" id="kobo.1826.1">https://platform.openai.com/docs/models</span></span></a></li>
    </ul>
    <h1 id="_idParaDest-181" class="heading-1"><span class="koboSpan" id="kobo.1827.1">Further reading</span></h1>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.1828.1">Han, Y., Liu, C., &amp; Wang, P. </span><span class="koboSpan" id="kobo.1828.2">(2023). </span><em class="italic"><span class="koboSpan" id="kobo.1829.1">A comprehensive survey on vector database: Storage and retrieval technique, challenge</span></em><span class="koboSpan" id="kobo.1830.1">.</span></li>
    </ul>
    <h1 id="_idParaDest-182" class="heading-1"><span class="koboSpan" id="kobo.1831.1">Join our community on Discord</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.1832.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
    <p class="normal"><a href="https://www.packt.link/rag"><span class="url"><span class="koboSpan" id="kobo.1833.1">https://www.packt.link/rag</span></span></a></p>
    <p class="normal"><span class="koboSpan" id="kobo.1834.1"><img src="../Images/QR_Code50409000288080484.png" alt=""/></span></p>
  </div>
</body></html>