- en: Using NEAT for XOR Solver Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about one of the classic computer science experiments
    that demonstrates that the NEAT algorithm works and can create a proper network
    topology. In this chapter, you will get first-hand experience of writing an objective
    function to guide the XOR problem solver. You will also learn how to select the
    correct hyperparameters of the NEAT algorithm to assist with solving the XOR problem. This
    chapter aims to introduce you to the basic techniques of how to apply the NEAT
    algorithm to solve classic computer science problems.
  prefs: []
  type: TYPE_NORMAL
- en: After completing the experiment and exercises described in this chapter, you
    will have a solid understanding of the XOR experiment's particulars and get the
    practical skills you need to write the relevant Python source code using the NEAT-Python
    library. You will also gain experience in setting up the hyperparameters of the
    NEAT-Python library and using visualization utilities to visualize the results
    of an experiment. After that, you will be ready to begin experimenting with the
    more complex problems that will be discussed later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The XOR problem basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define the objective function to guide the XOR problem solver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperparameter selection for the XOR experiment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the XOR experiment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following technical requirements should be met to carry out the experiments
    described in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8/10, macOS 10.13 or newer, or modern Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anaconda Distribution version 2019.03 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter3)
  prefs: []
  type: TYPE_NORMAL
- en: XOR problem basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classic **multilayer perceptron** (**MLP**) or **artificial neural network**
    (**ANN**) without any *hidden units* in their topology is only capable of solving
    linearly separable problems correctly. As a result, such ANN configurations cannot
    be used for pattern recognition or control and `optxor_experiment.pyimization`
    tasks. However, with more complex MLP architectures that include some hidden units
    with a kind of non-linear activation function (such as sigmoid), it is possible
    to approximate any function to the given accuracy. Thus, a non-linearly separable
    problem can be used to study whether a neuroevolution process can grow any number
    of hidden units in the ANN of the solver phenotype.
  prefs: []
  type: TYPE_NORMAL
- en: The XOR problem solver is a classic computer science experiment in the field
    of reinforcement learning that cannot be solved without introducing non-linear
    execution to the solver algorithm. The solution search space of the problem has
    a minimum size and can be used to demonstrate that the NEAT algorithm can evolve
    the topology of the ANN, starting from a very straightforward one and gradually
    increasing the complexity to finding an appropriate network structure where all
    the connections are wired correctly. By demonstrating the NEAT algorithm's ability
    to grow an appropriate topology consistently, the XOR experiment also demonstrates
    that NEAT can avoid the local maxima of the fitness values landscape. The local
    maxima is a trap where the solver can get stuck, producing a local champion with
    the wrong connectivity pattern. After that, a local champion may dominate the
    population so much that the solver fails to solve a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a table defining the XOR features:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input 1** | **Input 2** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: XOR is a binary logical operator that only returns true if only one of the two
    inputs is true. The two input signals must be combined by the non-linear hidden
    unit to produce the correct output signal. There is no linear function for the
    combination of XOR inputs that are able to separate them into their correct classes
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The NEAT algorithm starts with the initial population, which encodes a very
    simple phenotype, and gradually evolves the topology of the phenotype until an
    appropriate ANN is created. The initial structure of the phenotype ANN does not
    include any hidden units and consists of two input units, one output unit, and
    one bias unit. The two input nodes and the bias node are connected to the output
    node, that is, the initial genotype has three connection genes and four node genes.
    The bias unit is a particular type of input that is always initialized to a specific
    value greater than 0 (usually, it is 1.0 or 0.5). The bias unit is necessary if
    we wish to set the activation of the neuron unit (output or hidden)—which is calculated
    by the related activation function that's applied to a sum of inputs and bias—to
    a specific non zero value if both inputs have a value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial and the smallest possible XOR phenotypes are shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86915bea-fd14-4a1b-968f-0196f113782b.png)'
  prefs: []
  type: TYPE_IMG
- en: Initial and optimal XOR phenotypes
  prefs: []
  type: TYPE_NORMAL
- en: The ANN of the phenotype becomes more and more complex until the final solution
    is found by including one or more additional hidden nodes. The smallest possible
    solver includes only one hidden node, and the NEAT method demonstrates its power
    by finding an optimal solver configuration among the more complex ones.
  prefs: []
  type: TYPE_NORMAL
- en: The objective function for the XOR experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the XOR experiment, the fitness of the organism in the population is defined
    as the squared distance between the correct answer and the sum of the outputs
    that are generated for all four XOR input patterns. It is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The phenotype ANN is activated against all four XOR input patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output values are subtracted from the correct answers for each pattern,
    and the absolute values of the results are then summed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The error value that was found at the previous step is subtracted from the maximal
    fitness value (*4*) to calculate organism fitness. The highest fitness value means
    better solver performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The calculated fitness is then squared to give proportionally more fitness to
    the organisms, thereby producing solver ANNs that give closer answers to the correct
    solution. This approach makes the evolutionary pressure more intense.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, the objective function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e576dee-454e-4fd3-8690-df4ec58c4f68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The corresponding Python source code that is based on the NEAT-Python library
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no need to normalize the fitness value to fit the `[0,1]`
    range (like there is with backpropagation-based methods) because there are no
    backward gradient calculations involved in the training process. The organisms'
    fitness scores are compared directly based on their absolute values. Thus, the
    range of the values doesn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try different variations of fitness score calculation methods.
    For example, you can implement a function resembling mean squared error and compare
    the performance of the algorithm against the different implementations of the
    objective function. The only requirement is that the objective function should
    produce higher fitness scores for better solvers.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The XOR experiment we will discuss in this chapter uses the NEAT-Python library
    as a framework. The NEAT-Python library defines a set of hyperparameters that
    are used to control the execution and performance of the NEAT algorithm. The configuration
    file is stored in a format similar to Windows .INI files; each section starts
    with a name in square brackets ([*section*]), followed by key-value pairs that
    are delimited by an equals sign (*=*).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss some hyperparameters of the NEAT-Python library
    that can be found in each section of the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: A full list of the hyperparameters in the NEAT-Python library can be found at
    [https://neat-python.readthedocs.io/en/latest/config_file.html](https://neat-python.readthedocs.io/en/latest/config_file.html).
  prefs: []
  type: TYPE_NORMAL
- en: NEAT section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section specifies parameters that are specific to the NEAT algorithm.
    This section includes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fitness_criterion`: The function that computes the termination criterion from
    a set of fitness values of all the genomes in the population. The parameter values
    are the names of standard aggregate functions, such as min, max, and mean. The
    min and max values are used to terminate the evolution process if the minimal
    or maximal fitness of the population exceeds the given `fitness_threshold`. When
    the value is set to mean, the average fitness of the population is used as a termination
    criterion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fitness_threshold`: The threshold value is compared against the fitness and
    calculated by the `fitness_criterion` function to test whether evolution must
    be terminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_fitness_termination`: The flag that disables fitness-based termination
    of the evolutionary process is defined by the preceding parameters. When it''s
    set to `True`, the evolution will be terminated only after the maximum number
    of generations has been evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop_size`: The number of individual organisms in each generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset_on_extinction`: A flag that controls whether a new random population
    should be created when all the species in the current generation become extinct
    due to stagnation. If `False`, `CompleteExtinctionException` will be thrown upon
    complete extinction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DefaultStagnation section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section defines parameters that are specific to the species stagnation
    routines, as implemented by the `DefaultStagnation` class. This section includes
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`species_fitness_func`: The name of a function that''s used to compute species
    fitness, that is, to calculate the aggregate fitness value of all the organisms
    belonging to a particular species. The allowed values are max, min, and mean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_stagnation`: The species that have not shown an improvement in the fitness
    value calculated by `species_fitness_func` in more than `max_stagnation` number
    of generations are considered stagnant and are subject to extinction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`species_elitism`: The number of species to unconditionally protect from stagnation.
    It is intended to prevent the total extinction of the population before new species
    arise. The specified number of species with the highest fitness always survive
    in the population, despite showing no further fitness improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DefaultReproduction section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides configuration for the reproduction routines that are
    implemented by the built-in `DefaultReproduction` class. This section includes
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elitism`: The number of most-fit organisms in each species, which are copied
    without changes to the next generation. This factor allows us to retain any beneficial
    mutations that were found in the previous generations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`survival_threshold`: The fraction of organisms in each species that are allowed
    to be parents of the next generation, that is, eligible for sexual reproduction
    (*crossover*). By adjusting this value, it is possible to define the lowest fitness
    score of the organism that is allowing it to participate in the reproduction process.
    This becomes possible because the `survival_threshold` fraction is taken from
    the sorted list of organisms, ordered by fitness in decreasing order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_species_size`: The minimum number of organisms per species to keep after
    the reproduction cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DefaultSpeciesSet section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides the configuration for the speciation process that''s
    implemented by the built-in `DefaultSpeciesSet` class and includes the following
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compatibility_threshold`: The threshold to control whether organisms belong
    to the same species (genomic distance is less than this value) or to a different
    species. Higher values mean the evolutionary process has less speciation power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DefaultGenome section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section defines the configuration parameters that are used to create and
    maintain the genome, as implemented by the `DefaultGenome` class. This section includes
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activation_default`: The name of the activation function to use in node genes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activation_mutate_rate`: If the genome supports multiple activation functions
    (such as for the CPPN genome), then this is the probability of the mutation replacing
    the activation function of the current node with a new one that''s been taken
    from the list of supported functions (see `activation_options`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activation_options`: A space-separated list of the activation functions that
    can be used by node genes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aggregation_default`: The name of the default aggregate function to be used
    by a network node to any aggregate input signals that are received from other
    nodes before activation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aggregation_mutate_rate`: If multiple aggregate functions are supported by
    the genome, then this parameter defines the probability of mutation that replaces
    the aggregate function of the current node with a new one from the list of aggregate
    functions (see `aggregation_options`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aggregation_options`: A space-separated list of the aggregate functions that
    can be used by node genes. The supported values are sum, min, max, mean, median,
    and maxabs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compatibility_threshold`: The threshold to control whether organisms belong to
    the same species (genomic distance is less than this value) or to different species.
    Higher values mean that the evolutionary process has less speciation power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compatibility_disjoint_coefficient`: The coefficient that''s used during the
    genomic distance calculation to count how disjoint or excess genes contribute
    to the calculation result. Higher values of this parameter amplify the significance
    of the presence of disjoint or excess genes in the genomic distance calculation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compatibility_weight_coefficient`: The coefficient that manages how the genomic
    distance calculation of the difference between the bias and response attributes
    of the node genes and the weight attributes of the connection genes contribute
    to the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conn_add_prob`: The probability of a mutation that introduces a new connection
    gene between existing node genes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conn_delete_prob`: The probability of a mutation that removes an existing
    connection gene from the genome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled_default`: The default value for the enabled attribute of the newly
    created connection genes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled_mutate_rate`: The probability of a mutation that toggles the enabled
    attribute of the connection gene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feed_forward`: Controls the type of phenotype networks to be generated during
    genesis. If set to `True`, then no recurrent connections are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initial_connection`: Specifies the initial connectivity pattern for the newly
    created genomes. The allowed values include `unconnected`, `fs_neat_nohidden`,
    `fs_neat_hidden`, `full_direct`, `full_nodirect`, `partial_direct`, and `partial_nodirect`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_add_prob`: The probability of a mutation that adds a new node gene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_delete_prob`: The probability of a mutation that removes the existing
    node gene from the genome and all the connections to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_hidden`, `num_inputs`, `num_outputs`: The number of hidden, input, and
    output nodes in the genomes of the initial population.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`single_structural_mutation`: If set to `True`, then only the structural mutations
    are allowed in the evolution process, that is, only the addition or removal of
    nodes or connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XOR experiment hyperparameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The XOR experiment starts with a very straightforward initial genome configuration
    that has only two input nodes, one output node, and one special input—the bias
    node. No hidden node is introduced in the initial genome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The activation function of all the network nodes is a sigmoid and the node
    inputs are aggregated by the `sum` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of the encoded network is feed-forward fully connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'During evolution, the new network nodes and connections are added and/or removed
    with a particular probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All the connections are enabled by default, with a very low probability of
    becoming disabled due to mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The genomic distance is highly influenced by the excess/disjoint parts of the
    parent genomes to spur the species'' diversity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Species stagnation is prolonged to `20` generations, and unique species are
    partially prevented from extinction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The survival threshold of organisms within a species is set to a low value
    to narrow the evolutionary process, allowing only the fittest organisms to reproduce
    (the top 20% of the list of organisms, ordered by fitness). At the same time,
    elitism is also introduced to unconditionally copy the two fittest individuals
    to the next generation in each species. The minimal species size also influences
    speciation, and we leave it as the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The species compatibility threshold controls the diversity of species in the
    population. Higher values of this parameter result in a more diverse population.
    Species diversity should be balanced to keep the evolutionary process going in
    the desired direction, avoiding the exploration of too many search vectors, but
    at the same time permitting the exploration of innovation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The population size is set to `150`, which is pretty moderate, but sufficient
    for such a simple problem as XOR. The termination criterion (`fitness_threshold`)
    is set to `15.5` to guarantee that evolution terminates when the solution found
    is maximally close to the goal (the maximal fitness score is `16.0` according
    to our `fitness` function).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this task, we are interested in finding the evolution champion that''s able
    to solve the XOR problem, so our termination function (`fitness_criterion`) is
    the `max` function, which selects the maximal fitness among all the organisms
    in a population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The complete configuration file, `xor_config.ini`, is provided in the `Chapter3` directory in
    the source files repository associated with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have only presented the major hyperparameters that have a high impact on
    the NEAT algorithm's performance. The values of the hyperparameters were tested
    to produce a working XOR solver, but feel free to play around and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Running the XOR experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start working on the XOR experiment, we need to set up our Python
    environment correctly according to the requirements of the NEAT-Python library,
    which we chose as the framework for writing our code. The NEAT-Python library
    is available from PyPI, so we can use the pip command to install it into the virtual
    environment of the XOR experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing the code related to the XOR experiment, the appropriate
    Python environment should be created, and all the dependencies need to be installed
    into it. Follow these steps to set up the work environment properly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python 3.5 virtual environment for the XOR experiment is created using the
    `conda` command from the Anaconda Distribution, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that Anaconda Distribution is installed in your system, as described
    in [Chapter 2](c673e180-4440-4eea-98f8-8800c77162c8.xhtml), *Python Libraries
    and Environment Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the newly created virtual environment, you must activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the NEAT-Python library can be installed into an active environment
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use the specific version (`0.92`) of the NEAT-Python library here, which
    was the most recent at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to install the optional dependencies that are used by the
    visualization utilities. This can be done with the `conda` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to start writing the source code.
  prefs: []
  type: TYPE_NORMAL
- en: XOR experiment source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start the experiment, we need to create a directory named `Chapter3` using
    the `mkdir` command (for Linux and macOS) or `md` (for Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This directory will save all the source files related to the experiment described
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to copy the `xor_config.ini` file from the source code repository
    associated with this chapter into the newly created directory. This file contains
    the complete configuration of the hyperparameters for the XOR experiment, as we
    discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The experiments that will be discussed in this book use various utilities to
    visualize the results to help us understand the internals of the neuroevolution
    process. The XOR experiment also depends on the specific visualization utilities
    that are implemented in the `visualize.py` file in this book's source code repository.
    You need to copy this file into the `Chapter3` directory as well.
  prefs: []
  type: TYPE_NORMAL
- en: The Anaconda Distribution installation includes VS Code, which is a free cross-platform
    code editor. It is reasonably straightforward in terms of functionality but provides
    excellent support for Python and makes it easy to switch between virtual environments.
    You can use it to write the source code for the experiments described in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create `xor_experiment.py` in the `Chapter3` directory and use your
    favorite Python source code editor to write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the imports that will be used later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to write some fitness evaluation code, as we described earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Never miss the opportunity to write comments in the source code that describe
    the purpose of the function, its input parameters, and the results of execution.
    It is also advantageous to comment on some interesting/tricky parts of the source
    code to provide a better understanding of it to the person who will see it later
    (this could be you!).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the fitness evaluation function, you can write a function to evaluate
    all the organisms in the current generation and update the fitness of each genome
    accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have implemented the function to evaluate the fitness of the individual
    genome and the objective function has been defined, it is time to implement the
    function to run the experiment. The `run_experiment` function loads the hyperparameter
    configuration from the configuration file and creates the initial genome population:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are interested in the accumulation of statistics to evaluate the experiment
    and observe the process in real time. It is also essential to save checkpoints,
    which allows you to restore the execution from a given checkpoint in the case
    of failure. Thus, two types of reporters (standard output and statistics collector)
    and a checkpoint collector can be registered as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are ready to run neuroevolution for `300` generations by providing
    the `eval_genome` function, which serves to evaluate the fitness scores of each
    genome in the population of each generation until a solution is found or the process
    reaches the maximum number of generations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the execution of the NEAT algorithm stops due to success or after reaching
    the maximum number of generations, the most fit genome is returned. It is possible
    to check whether this genome is a winner, that is, able to solve the XOR problem
    with a given accuracy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the collected statistics and the best-fit genome can be visualized
    to explore the results of the neuroevolution process and to see how it performed
    from zero to the maximum number of generations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code of the XOR experiment runner can be found in the `xor_experiment.py` file
    at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter3/xor_experiment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter3/xor_experiment.py).
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the preceding code execution, Matplotlib will be used to render
    graphs with the collected statistics. Also, a network graph of the best-fit genome
    will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: Running the experiment and analyzing the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command should be issued in the `Chapter3` directory to start
    the experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to activate the `XOR_neat` virtual environment with `$ conda activate
    XOR_neat`. Otherwise, errors about missing a `neat` package will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the preceding command is entered in your Terminal application of choice,
    the NEAT algorithm starts execution, and the Terminal window starts to show intermediate
    results in real time. For each generation, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The population''s average fitness (`6.01675`) in generation `43`, which is
    quite low compared to the completion criterion set in the configuration file (`fitness_threshold
    =15.5`). However, it looks like we have some potential champion species (`ID:
    2`) that are on their way to reaching the target fitness threshold by evolving
    the champion organism with a fitness score of `14.54383`, which encodes an ANN
    phenotype that consists of four nodes and seven connections (the size is (`4,7`)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The population includes 151 individuals separated into five species with the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` is a species identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age` is the age of the species as the number of generations from their creation
    until now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` is the number of individuals belonging to this species.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fitness` is the species fitness score calculated from its individuals (max,
    in our case).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adj fit` is the fitness of a particular species that''s been adjusted to the
    entire population''s fitness scores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stag` is the stagnation age of a particular species as the number of generations
    since the species'' last fitness improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When an appropriate XOR solver is found by the NEAT algorithm, the following
    output is presented in the Terminal window. It starts with general statistics
    about the final genome population and the winner (the successful XOR solver):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we can see that, in generation `44`, the evolution
    process creates a genome that encodes a phenotype ANN that can solve an XOR problem
    with a given accuracy. This genome belongs to the organism from species with `ID:2`,
    and this species has already championed the evolutionary process over the past
    seven generations. The champion organism (`ID:6531`) of generation `44` is a mutation
    of an individual (`ID:5368`) in the species with `ID:2` from the previous generation
    that has lost one hidden node and now has three nodes with seven connections (`size:
    (3, 7)`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then follows the best genome section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The best genome section represents the performance statistics of a population
    champion, along with its genome configuration. Input nodes have the IDs `-1` and
    `-2` and are not shown because they are relatively simple, providing us with the
    means to input values into the network graph. The output node and two hidden nodes
    have the IDs `0`, `224`, and `612`, respectively. Also, `DefaultNodeGene` holds
    the values for bias, the name of the activation function, and the name of the
    function that's used to aggregate inputs at each node. The connection genes (`DefaultConnectionGene`),
    which will be presented later, provide the IDs of the source and target nodes,
    along with the associated connection weight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the `Output` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `Output` section represents the output values that are produced by the ANN
    of the phenotype of the population champion when receiving four input data pairs.
    As we can see, the output is close to the expected values within the specified
    accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Output` directory also contains a diagram of the ANN graph of the successful
    XOR solver, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e46d445a-5e77-42fb-98f4-9c630bc3ebcf.png)'
  prefs: []
  type: TYPE_IMG
- en: The ANN of the XOR winner phenotype
  prefs: []
  type: TYPE_NORMAL
- en: The ANN of the winner phenotype is close to the optimal configuration we described
    earlier, but it has one additional hidden node (`ID:612`). The bias node is not
    shown in the graph since the NEAT-Python library does not allocate a bias to a
    separate node; instead, it assigns a bias value to each network node as an attribute,
    which can be seen in the output listing (each `DefaultNodeGene` has a bias attribute).
  prefs: []
  type: TYPE_NORMAL
- en: 'A plot with the statistics of fitness change over generations of evolution
    is also saved to the `Output` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1a831ca-8acd-4dd7-a27b-7efeaec0d5ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Population's average and best fitness scores changing over generations
  prefs: []
  type: TYPE_NORMAL
- en: The preceding plot visualizes the changes in the best and average fitness scores
    of the population over generations of evolution. The average fitness of the population
    has increased slightly. However, due to the speciation feature that was introduced
    in the NEAT algorithm, some species have demonstrated outstanding performance
    from the earliest generations (`#10`), and thanks to the preservation of the beneficial
    mutation, they finally managed to produce a champion organism that solves the
    XOR problem with a given accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Output` directory also contains the speciation graph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34f1a205-b1d0-4253-bba7-28fd754060de.png)'
  prefs: []
  type: TYPE_IMG
- en: Speciation of the population over generations of evolution
  prefs: []
  type: TYPE_NORMAL
- en: The speciation graph demonstrates how the speciation process has evolved over
    the generations of the population of organisms. Each separate species is marked
    with a different color. The evolution began with a single species (`ID:1`), which
    includes the entire population. Then, the second species (`ID:2`) sprouted around
    the 10th generation and eventually produced a champion organism. Also, in the
    later stages of evolution, the population branched into three more species in
    generations `23`, `39`, and `42`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the source code of the neuroevolutionary-based XOR solver,
    try to experiment by changing NEAT's hyperparameters, which control the evolutionary
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the parameters of particular interest is `compatibility_threshold`,
    which can be found in the `DefaultSpeciesSet` section of the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to increase its value and monitor the speciation of the population. Compare
    the performance of the algorithm with the new value against the default one (`3.0`).
    Does it get any better?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you decrease the value of this parameter? Compare its performance
    against the default value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another essential parameter that controls the evolutionary process is `min_species_size`,
    which can be found in the `DefaultReproduction` section. By changing the values
    of this parameter, you can directly control the minimum number of individuals
    per species and implicitly control the species'' diversity:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `compatibility_threshold` parameter value to the default (`3.0`) and
    try to increase the value of the `min_species_size` parameter in the range `[2,
    8]`. Compare the performance of the algorithm against the default value. See how
    the species' diversity changes over generations. Go through the algorithm's output
    and check whether any species have stagnated and have been removed from the evolution
    due to exceeding the stagnation age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `min_species_size` parameter value to extremely high for our population
    (32) and look for the explosion of the species diversity near the end of the evolution
    process on the speciation graph. Why does this happen? Check the graph depicting
    the configuration of the ANN phenotype in `Digraph.gv.svg`. Is this optimal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increasing the minimum size of species makes the evolutionary process more elaborate
    and allows it to keep more beneficial mutations. As a result, we have an increase
    in the chances of producing the optimal genome that encodes the ANN of the phenotype
    of the minimal XOR solver.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph of the ANN of the minimal XOR solver is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaac3788-1eff-40bb-bdb8-ea1b6d4dcb2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The optimal ANN phenotype with an increased minimum species size
  prefs: []
  type: TYPE_NORMAL
- en: As we already mentioned, the ANN of the minimal XOR solver has only one hidden
    node, as can be seen in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Try to implement some modified code to solve a three XOR (A xor B xor C) problem.
    Can it be solved with the same hyperparameters that we used in the experiment
    that we described in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced a classic computer science problem related to
    the creation of the optimal XOR solver. We discussed the basics of the XOR problem
    and demonstrated its importance as the first experiment with neuroevolution—it
    allows you to check whether the NEAT algorithm can evolve a more complex ANN topology,
    starting with the most straightforward ANN configuration. Then, we defined the
    objective function for the optimal XOR solver and a detailed description of the
    NEAT hyperparameters. After that, we used the NEAT-Python library to write the
    source code of the XOR solver using a defined objective function, and then we
    experimented.
  prefs: []
  type: TYPE_NORMAL
- en: The results of the experiment we carried out allowed us to conclude the relationship
    between the number of species in the population, the minimum size of each species,
    and the performance of the algorithm, as well as the produced ANN topologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about classic reinforcement learning experiments,
    which are often used as benchmarks for control strategy implementation. You will
    learn how to write accurate simulations of real-life physical apparatuses and
    how to use such simulations to define the objective functions for the NEAT algorithm.
    You will get first-hand experience of writing the control strategies for various
    cart-pole balancing controllers using the NEAT-Python library.
  prefs: []
  type: TYPE_NORMAL
