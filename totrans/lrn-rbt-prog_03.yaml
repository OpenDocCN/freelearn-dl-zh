- en: '*Chapter 2*: Exploring Robot Building Blocks – Code and Electronics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll take a robot apart to see its parts and systems. We'll
    explore the components of a robot, both the software (code, commands, and libraries)
    and the hardware, and how they go together. When starting to make a robot, it's
    valuable to think about the parts you want and how they relate to one another.
    I recommend sketching a plan of your robot—a block diagram as a guide to the connected
    code and parts, which we will explore in this chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at what's inside a robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring types of robot components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring controllers and I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning components and code structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning the physical robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple drawing materials, such as a pen and paper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional – diagram software such as Draw.io (free at [https://app.diagrams.net](https://app.diagrams.net))
    or Inkscape (free at [https://inkscape.org](https://inkscape.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at what's inside a robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can start by looking at a robot as a physical system. In *Figure 2.1*, we
    can see a simple hobby robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – An assembled hobby robot
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.2* shows it in its disassembled form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_02_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – A hobby robot's components laid out
  prefs: []
  type: TYPE_NORMAL
- en: 'The component groups in *Figure 2.2* include nine types of components:'
  prefs: []
  type: TYPE_NORMAL
- en: The chassis or body forms the main structure of the robot; other parts are attached
    here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A castor wheel balances this robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two drive wheels. Other robots may use more wheels or legs here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Motors are essential for the robot to move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A motor controller bridges between a controller and connected motors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A controller, here a Raspberry Pi, runs instructions, takes information from
    the sensors, and processes this information to drive outputs, such as motors,
    through the motor controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All robots must have power, usually one or more sets of batteries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sensors provide information about the robot's environment or the state of its
    physical systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, debug devices are outputs that allow the robot to communicate with
    humans about what its code is doing, and are also useful for looking good.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will examine these components in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize a robot as a block diagram (*Figure 2.3*) of connected parts.
    Block diagrams use simple shapes to show a rough idea of how things may be connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – A robot block diagram
  prefs: []
  type: TYPE_NORMAL
- en: The block diagram in *Figure 2.3* does not use a formal notation. The key I've
    created is off the top of my head, but it should identify sensors, outputs, and
    controllers. It could be as simple as a sketch on some scrap paper. The critical
    factor is that you can see blocks of functionality in the hardware, with the high-level
    flow of data between them.
  prefs: []
  type: TYPE_NORMAL
- en: It is from this diagram that you can develop more detailed plans, plans containing
    details in terms of electrical connections, power requirements, the hardware,
    and how much space is needed. Sketching a block diagram about a robot you'd like
    to create is the first step toward making it.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A block diagram is *not* a schematic, nor a scale drawing of a finished robot.
    It doesn't even try to show the actual electronic connections. The picture ignores
    small details, such as how to signal an ultrasonic distance sensor before it responds.
    The connection lines give a general idea of the data flow. A block diagram is
    the right place to show the type and number of motors and sensors, along with
    additional controllers they may need.
  prefs: []
  type: TYPE_NORMAL
- en: This was a very brief overview of robot components, seeing a robot similar to
    the one you will build, along with it disassembled into parts. We took a look
    at a simple robot block diagram and its intent. In the next section, we will take
    a closer look at each of the robot's components, starting with motors.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring types of robot components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at the types of motors and sensors, let's get a brief understanding
    of what each of them is.
  prefs: []
  type: TYPE_NORMAL
- en: A *motor* is an output device that rotates when power is applied. Motors are
    a subset of a type of machinery called an *actuator*. It is an output device that
    creates motion from electrical power. This power can be modulated with signals
    to control movement. Examples of actuators are solenoids, valves, and pneumatic
    rams.
  prefs: []
  type: TYPE_NORMAL
- en: A *sensor* is a device that provides input to a robot, allowing it to sense
    its environment. There are more sensor types than a single book can list, so we'll
    keep to the commonly available and fun-to-use ones. Displays and indicators are
    debug output devices, for giving feedback on the robot's operation to a human
    user/programmer. A few of these will be covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Types of motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of different kinds of motors that robots commonly use. Let''s
    take a look at what each one does and how we might use them for different types
    of motion:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Torque is a rotating/twisting force, for example, the force a motor will need
    in order to turn a wheel. If the torque increases, a motor will require more power
    (as current), and will slow down while trying to cope. A motor has a limit, the
    **stall torque**, at which point it will stop moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Different motor types – a DC motor, DC gear motor, servo motor,
    and stepper motor
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify what each of these motors do, let''s look at them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DC motor**: This is the most simple type of motor in robotics and forms the
    basis of gear motors. It uses **Direct Current** (**DC**) voltage, which means
    it can be driven simply by voltage running one way through it. The motor speed
    is in proportion to the voltage running through it versus the torque required
    to move. A bare DC motor like the one in *Figure 2.4* can spin too fast to be
    useful. It will not have much torque and stall easily.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DC gear motor**: This is a DC motor fitted with a gearbox. This gearbox provides
    a reduction in speed and increases the torque it can handle. This mechanical advantage
    increases the motor''s ability to move a load. Note that this gear motor is missing
    soldered leads! I recommend these motor types for robot wheels. We will use gear
    motors such as this on our robot in [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*, and [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Servo motor** (or **servomechanism**): This type of motor combines a gear
    motor with a sensor and a built-in controller as shown in *Figure 2.5*. A signal
    to a controller states a motor position, and the controller uses feedback from
    the sensor to try to reach this position. Servo motors are used in pan and tilt
    mechanisms, along with robot arms and limbs. We will look more closely at, and
    program, servo motors in [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors*:![](img/B15660_02_05_NEW.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.5 – Pictorial diagram of a servo motor mechanism
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stepper motor**: These have coils powered in a sequence to let the motor
    step a certain number of degrees. Where exact motions are needed, engineers use
    steppers. Stepper motors tend to be slower and generate a lot of heat compared
    with DC motors or servo motors. You will find these in fine-control applications,
    such as 3D printers and high-end robot arms. They are heavier and more expensive
    than other motors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Brushless motor**: These are not shown in the diagram. They are driven with
    specialized controllers, and can be capable of high speed and torque. They run
    quieter and are popular in drones. There are no gear motor equivalents, so creation
    of a gearbox may be necessary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All but servo motors require hardware for a controller such as the Raspberry
    Pi to drive them. This hardware allows the Pi to control power-hungry devices
    without destroying them. Never connect DC motors, stepper motors, or solenoids
    directly to a Raspberry Pi!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's look at some other types of actuators next.
  prefs: []
  type: TYPE_NORMAL
- en: Other types of actuators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linear actuators, like those shown in *Figure 2.6*, are devices that convert
    electrical signals into motion along a single axis. These can be a stepper motor
    driving a screw in a fixed enclosure, or use arrays of coils and magnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6 – Linear actuators: By Rollon91, [Image credit: https://commons.wikimedia.org/wiki/File:Uniline.jpg?uselang=fr
    [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)]'
  prefs: []
  type: TYPE_NORMAL
- en: A **solenoid** is a simple linear actuator using an electromagnetic coil with
    a metal core that is pulled or pushed away when powered. A common use of this
    type is in hydraulic or pneumatic valves. Hydraulic and pneumatic systems generate
    powerful motions like those seen in excavators.
  prefs: []
  type: TYPE_NORMAL
- en: Status indicators – displays, lights, and sounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another helpful output device is a display. A single LED (a small electronic
    light) can indicate the status of some part of the robot. An array of LEDs could
    show more information and add color. A graphical display can show some text or
    pictures, like those found on a mobile phone. We will be connecting a multicolor
    LED strip to the robot as a display in [*Chapter 9*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171),
    *Programming RGB Strips in Python*.
  prefs: []
  type: TYPE_NORMAL
- en: Speakers and beepers can be used for a robot to communicate with humans by making
    sounds. The sound output from these can range from simple noises through to speech
    or playing music.
  prefs: []
  type: TYPE_NORMAL
- en: Many robots don't have any displays and rely on a connected phone or laptop
    to display their status for them. We will use a phone to control and see the status
    of our robot in [*Chapter 17*](B15660_17_Final_ASB_ePub.xhtml#_idTextAnchor396),
    *Controlling the Robot with a Phone and Python*.
  prefs: []
  type: TYPE_NORMAL
- en: Types of sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 2.7* shows a collection of sensor types used in robotics. They are
    similar to those that we will explore and use in this book. Let''s examine some
    of them and their uses. Note that these may look different from the same sensor
    types seen previously – there is a wide variation in sensors that do the same
    job. When we add them to the robot, we will cover their variants in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7 – A selection of sensors from my robots: 1 - A Raspberry Pi camera,
    2 - an optical distance sensor, 3 - an ultrasonic distance sensor, 4 - line sensors,
    5 - microphones, and 6 - an optical interrupt sensor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand each sensor from *Figure 2.7* in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi camera module**: This module connects to a Raspberry Pi to provide
    it with imaging capabilities. We''ll use it for visual processing programming
    in [*Chapter 13*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283), *Robot Vision
    – Using a Pi Camera and OpenCV*. This module captures images or video sequences.
    It can generate a lot of data quickly, which is one of the problems associated
    with robot vision. It is sensitive to lighting conditions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Optical distance sensor**: The VL53L0X Time of Flight laser ranging sensor
    in *Figure 2.7* is a distance sensor. It uses an infrared laser to bounce off
    objects and detect how far away they are. It can be affected by lighting conditions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The VL53L0X sensors use I2C to send a detected range to the Raspberry Pi and
    can share their two communication pins with many other devices. I2C is useful
    when you have many sensors and outputs and are starting to run out of places to
    connect things. I2C sensors can be a more expensive option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Ultrasonic distance sensor**: The HC-SR04 is another distance/ranging sensor
    that bounces sound pulses off objects to detect distance. It is affected by the
    types of material an object is made from and will fail to detect certain surfaces,
    but is impervious to lighting conditions. Some surfaces, for example, fabrics,
    absorb the sound too much and never send it back, while other surfaces, such as
    grids or meshes, do not interact much with sound waves and will be transparent
    to the sensor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HC-SR04 requires precise timing in the controller to time the echo, which
    we will have to manage in code. It has a longer range than the VL53L0X laser sensor,
    and is cheaper, but is also less sensitive at close distances. We will be programming
    sound-based range sensors in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Line sensors**: These are a set of three line-sensors that use light to detect
    transitions from light to dark. They can be adjusted to sense in different conditions.
    There are a few variations of these modules. These provide an on or off signal,
    depending on light or dark areas beneath it. They are the simplest of the sensors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Microphone**: The fifth sensor is a pair of microphones. These can connect
    directly to the PCM pins on a Pi. Some other microphones need to be connected
    to electronics to process their signal into something the Raspberry Pi uses. We
    will use microphones for voice processing in [*Chapter 15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344),
    *Voice Communication with a Robot Using Mycroft*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Optical interrupt sensor**: This detects infrared light passing through a
    gap between two posts, sensing whether something between the posts is interrupting
    the beam. These are used with notched wheels to detect rotation and speed by counting
    notches. When used with wheels, they are also known as encoders. We use encoders
    in [*Chapter 11*](B15660_11_Final_ASB_ePub.xhtml#_idTextAnchor219), *Programming
    Encoders with Python*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many more sensors, including ones to detect positions of limbs, light,
    smoke, heat sources, and magnetic fields. These can be used to make more advanced
    robots and add more exciting behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered motors, displays, indicators, and sensors, together with examples
    and some details regarding their types. These are the parts that allow our robot
    to interact with the world. Now we will move on to the controllers, the parts
    of a robot that run code and connect sensors and motors together.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring controllers and I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the center of the robot block diagram, as in *Figure 2.3*, are controllers.
    Robots usually have a primary controller, a computer of some kind. They may also
    have some secondary controllers, and some more unusual robots have many controllers.
    This book keeps things simple, with your code running on a conventional central
    controller. The controller connects all the other parts together and forms the
    basis of their interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at controllers, we need to get a better understanding of an important
    component that connects controllers to other components, I/O pins.
  prefs: []
  type: TYPE_NORMAL
- en: I/O pins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I/O pins are used for input and output from the controller. They give the controller
    its ability to connect to real-world sensors and motors.
  prefs: []
  type: TYPE_NORMAL
- en: The number of I/O pins on the controller is a limiting factor in what you can
    connect to a robot without using secondary controllers. You may also see the term
    **General Purpose Input Output** (**GPIO**). Controller I/O pins have different
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest I/O pins are only able to output or read an on/off signal, as
    shown in *Figure 2.8*. These are known as digital I/O pins. They can be programmed
    to perform complicated tasks through signal timing. This is the principle used
    in the HC-SR04 distance sensor. In *Figure 2.8*, this graph represents a voltage
    level over time. So, as we move along the *x* axis, the voltage is on the *y*
    axis. The upper level represents a digital logic high (`1`, `True`, `On`). The
    lower level represents a digital logic low (`0`, `False`, `Off`). The controller
    will attempt to interpret any value as high or low:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – A digital signal
  prefs: []
  type: TYPE_NORMAL
- en: 'Analog input pins can read varying levels, like the signal in *Figure 2.9*,
    which is another voltage-over-time graph. If a sensor produces a changing resistance
    or continuous scale of values, then an analog pin is suitable. There is a resolution
    limit to this, for example, an 8 bit analog input will read 256 possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – An analog signal
  prefs: []
  type: TYPE_NORMAL
- en: '**Pulse Width Modulation** (**PWM**) pins output a cycling digital waveform
    shown in *Figure 2.10*. This diagram also shows voltage over time, although the
    timing of the pulses represents a continuous level, so the dashed line shows the
    continuous level produced by the timing. PWM outputs allow the code to select
    the frequency and how much time they are on for. The length of on-time versus
    off-time in a cycle changes to vary an output signal. This is often used to control
    the speed of motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – A PWM signal in blue, with the dashed line showing its approximate
    value
  prefs: []
  type: TYPE_NORMAL
- en: We will spend more time on PWM pins in [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*, and [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: Some I/O pins can be used to form data transmission lines, such as serial, I2S,
    I2C, and SPI buses. They are known as data buses. Data buses are used to send
    data to or from other controllers and intelligent sensors. We'll use an SPI data
    bus for the RGB LEDs in [*Chapter 9*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171),
    *Programming RGB Strips in Python*.
  prefs: []
  type: TYPE_NORMAL
- en: Microcontroller pins can be used for digital or analog input and output, or
    part of a data bus. Many controllers allow the usage mode of pins to be configured
    in the software you run on them, but some capabilities are restricted to specific
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although it''s possible to use bare microcontroller chips with the right skills
    to create surrounding electronics and your own PCBs, we''ll keep things simple
    in this book by using controller modules. These tend to come in packaged and easy-to-use
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11 – A selection of controller modules: a Raspberry Pi, NodeMCU, Arduino,
    and micro:bit'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.11* shows some of my favorite controllers. They can all be powered
    via a USB connection. All but the Raspberry Pi can also be programmed over a USB.
    They all have connectors for easy access to their I/O pins. For each of the controllers,
    let''s see what they are, along with their pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi**: This is powerful enough for visual processing. It tends to
    consume a little more power and is more expensive, but is similar to a mobile
    phone in capability. It has the most flexible environment for programming. There
    are several models to consider. They have many I/O pins, but none are analog input
    pins.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NodeMCU**: This is based on the ESP8266 controller. This controller has built-in
    Wi-Fi and can be programmed with Arduino C++, MicroPython, or Lua. It has plenty
    of I/O pins, but only one can read analog signals. It supports many data bus types.
    It is somewhat faster and can hold larger programs than the Arduino. It is the
    cheapest controller in this lineup.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Arduino Leonardo**: This is based on the Atmega 328 chip. Arduino controller
    modules formed the basis of most of my robots around 2010-2012\. The Arduino was
    important for the ease with which it could be connected to a PC via a USB and
    programmed to immediately interact with devices attached to its I/O pins.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Arduino is mostly programmed in the C++ language. It has the most flexible
    built-in I/O pins – seven analog pins, many digital pins, PWM output pins, and
    can be set up to handle most data buses. The Arduino's processor is very simple;
    it is not capable of visual or speech processing tasks. The Arduino has the lowest
    power consumption of all the options shown here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**micro:bit**: This was released in 2015 for use in education, and is ideal
    for children. Its use in robotics requires an additional adapter if you need more
    than the 3 I/O pins that it ships with, but it is still a pretty capable robot
    controller and comes with a handy built-in LED matrix. This can be programmed
    in MicroPython, C, JavaScript, and several other languages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An honorable mention should go to the PIC microcontroller, not pictured here.
    These were used for hobby robotics long before any of the others, and have a thriving
    community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a comparison of controllers based on the pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_Table_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where the other controllers may run a simple interpreter or compiled code, the
    Raspberry Pi runs a complete operating system. Current models have Wi-Fi and Bluetooth
    capabilities, which we will use to make a robot headless and connect with game
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 2.12* shows a few current Raspberry Pi models. As new Raspberry Pis
    are released, a robot builder may have to adapt this to the latest version. All
    these models have Wi-Fi and Bluetooth capabilities. The Raspberry Pi I/O pins
    support many of the data bus types and digital I/O. External controllers are needed
    for analog reading and some other I/O functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Raspberry Pi models – 4B, 3A+, and Zero W
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at each of these models in a little detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi 4B**: This is the latest in the Raspberry Pi line at the time
    of writing. As the latest model, it is the fastest and most potent in the lineup.
    It takes up more space, is the most expensive in this group, and uses the most
    power.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Raspberry Pi 3A+**: This is the controller we will use for our robot. It
    provides an excellent compromise on size and power. It is fully capable of visual
    processing through a camera. It''s not quite as fast as the 4B+, but definitely
    quick enough for our purposes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Raspberry Pi Zero W**: This is an inexpensive, lighter alternative to the
    other Raspberry Pi models. Cameras and speakers are still supported. The Zero
    WH model includes headers for I/O too. It performs speech and visual recognition
    slower than on a Raspberry Pi 3 and 4\. Their small size makes them an interesting
    option for a remote-control pad too.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we know each of the models, let''s compare their pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_Table_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Raspberry Pi 4B may be the most powerful, but the 3A+ is powerful enough
    to be responsive to all the activities here.
  prefs: []
  type: TYPE_NORMAL
- en: Planning components and code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've now briefly seen some components you might use in a robot, and you've
    encountered a block diagram to put them together. This is where you may start
    taking the next step and thinking further about how to connect things, and how
    the code you write for them will be structured.
  prefs: []
  type: TYPE_NORMAL
- en: Code is easier to reason about when taken as logical blocks instead of one large
    lump. Arranging code in ways that are similar to a hardware functionality diagram
    will help navigate your way around as it becomes more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's return to the robot block diagram in *Figure 2.3* to think about what
    we'll need to handle in our code for it. That diagram has three sensors and two
    outputs. Each component (sensor, output, and controller board) may need some code
    to deal with it, and then you need some code for the behavior of combined modules.
  prefs: []
  type: TYPE_NORMAL
- en: Motor controllers come in many flavors. They have different ways to output to
    motors, and they may have monitoring for battery levels. Some smart motor controllers
    interface with wheel encoders directly to ensure the wheels have traveled a specified
    amount. When we write behavior for a robot, we may not want to rewrite it if we
    change the motor controller. Mixing the direct motor controller code with the
    behavior code also makes it harder to reason about. For this, I recommend creating
    an interface layer, an *abstraction* between the real motor controller code and
    a standard interface, which will make swapping components possible. We will see
    this in practice in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar for each sensor. They will have some code to manage how they
    get signals and turn them into usable data. All these devices may have setup and
    teardown code that needs to run when starting or stopping behavior that connects
    to them. The camera is a sophisticated example of this, requiring processing to
    get the data values we can use to perform a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – A quick software block diagram, in pen on an envelope, and the
    same diagram using a computer
  prefs: []
  type: TYPE_NORMAL
- en: Just like the hardware, a simple diagram can represent the software. This can
    be made in a drawing program or sketched on any paper you have to hand. In *Figure
    2.13*, I've deliberately chosen a hand-drawn one so you don't feel that you need
    a drawing tool to do this. This won't be tidy, but it's quickly redrawn, and can
    even be done on the back of receipt paper if an idea comes to you while out dining.
    What is relevant here is the fact that if you use a pencil, go back over it in
    a pen or fine liner so that it doesn't fade. To make it clearer to the reader,
    I have made a computer drawing too, but don't feel you need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Scan your hand-drawn documents. If you have a scanner, or just a phone, I recommend
    scanning or getting a photo of your sketches, for later reference. Putting them
    into software such as Evernote or OneNote as images/PDFs with useful tags lets
    you look them up quickly later.
  prefs: []
  type: TYPE_NORMAL
- en: After making a hand-drawn sketch, you can use a software tool. This will take
    longer than a hand-drawn version, and try not to be distracted by the quirks and
    styling of a tool.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the design itself, this is still a very simplistic view. The **Wheels**
    box will be a block of code, dealing with asking the wheel motor controller to
    do things. This may sit on top of code written by the motor controller company,
    or use I/O pins connected to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance sensors** are blocks of code to read distances from the sensors,
    triggering them when necessary. We will look at two different kinds of sensors
    and compare them. By having a block of code like this, changing the sensors at
    this level means the other code won''t have to change.'
  prefs: []
  type: TYPE_NORMAL
- en: There is also a block of code for the **Camera**, doing fiddly stuff like setting
    it up, resolution, white balancing, and other parts that we will cover. On top
    of this is a layer that will use the camera images. That layer could get the position
    of a colored object, returning this position to the layer above.
  prefs: []
  type: TYPE_NORMAL
- en: Across the motors and distance sensors is a behavior layer that allows the robot
    to avoid collisions, perhaps when it is below a threshold on one side. This will
    override other behavior to turn away from that obstacle and drive off a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The top layer is another behavior that takes positional data from the **Get
    Object Position** code. Use this position to choose a direction, and then instruct
    the motors to drive to the object. If this behavior goes through the **Avoid Collisions**
    behavior, there could be a complicated interaction that leads the robot to seek
    the correct object, while avoiding obstacles and going around things. It will
    also not come close enough to the detected object to collide with it.
  prefs: []
  type: TYPE_NORMAL
- en: Each module is relatively simple, perhaps with the lower layers that are closer
    to the hardware being more complex, especially in the case of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the code down into blocks like these means that you can approach a
    single block at a time, test, and tweak its behavior, and then focus on another
    one. When you have written blocks like this, you can reuse them. You will likely
    need the motor code multiple times and now will not need to write it multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Using blocks to describe our software lets us implement the blocks and their
    interactions in different ways. We can consider whether we will use functions,
    classes, or services for these blocks. I will spend more time on this as we start
    writing the code for this and show the different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the physical robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now put all of this to use and plan the layout of the physical parts
    of robot that we are making in this book. While we go through chapters, we will
    be adding new components each time, and keeping an overall map in our minds as
    we go helps us to see where we are. It is quite exciting to start to picture all
    the things a robot will do. Let''s start with a list of what our robot will do
    and be:'
  prefs: []
  type: TYPE_NORMAL
- en: It will have wheels and be able to drive around the floor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a Raspberry Pi 3A+ controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a motor controller for the wheels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be able to indicate its status with a set of multicolored LEDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot will use a pair of servo motors for a pan and tilt mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be able to avoid walls and navigate around obstacles with either ultrasonic
    or laser distance sensors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have an encoder per wheel to know how far it has moved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot will use a camera to sense colored objects or faces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be able to follow lines with the camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot will have a microphone and speaker to work with voice commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a gamepad as a remote control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will need power for all of these things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Phew! That is a lot of functionality. Now, we need to draw the hardware blocks.
    *Figure 2.14* shows our block diagram. While done with Draw.io, a simple back-of-an-envelope
    sketch of a block diagram is an excellent start to robot planning. Most of my
    robots start off that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Block diagram of the robot we will build, created using the draw.io
    web app
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this looks like a daunting amount of robot, we will be focusing on
    an area of functionality in each chapter and building it before moving to other
    areas. The annotation here is not any formal notation, it is just a way of merely
    visualizing all the parts that will need to be connected. Along with this, I usually
    sketch roughly where I would physically place sensors and parts with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – An overview of how the robot could be physically laid out, created
    with Draw.io
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch in *Figure 2.15* is not exhaustive, accurate, or to scale, but just
    an idea of where I want the parts to end up. Note the following things in this
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: Sensors have a clear field of view, and the distance sensors are pointing out
    to the sides. I'll go into more detail in the relevant sensor chapters on why
    this is important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoders are placed over the wheels where they will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heavy items, specifically batteries, should be kept low (below the center of
    gravity) to avoid a robot tipping over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batteries need to be changed, so think about access to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to keep components that are directly connected quite close to one another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a rough plan. It need not be this detailed, and this is *not* the test
    fit. Real dimensions, design compromises, and hitches will mean that this will
    change. This is just a starting point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we work through the book, we will look at the details in these diagrams,
    and start to flesh out the real robot, making some of this less fuzzy. Any diagram
    like this, at the start of a project, should be taken as a bit rough. It is not
    to scale and should not be followed blindly. It is a guide, or a quick map from
    which to start working.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've been able to see a number of the different component
    parts that go into a robot, and through a block diagram as a plan, start to visualize
    how you'd combine those blocks to make a whole robot. You've seen how you can
    quickly sketch your robot ideas on an envelope, and that drawing tools on a computer
    can be used for a neater version of the same diagram. You've had a quick tour
    of motors, sensors, and controllers, along with a few ways, including analog,
    digital, PWM, and data buses, for controllers to communicate with the other devices
    connected to them. Following on from this, you've seen a plan of the robot we
    will build in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at Raspbian, the operating system used on
    the Raspberry Pi in our robot, and start configuring it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try creating a block diagram for a different robot, thinking about inputs, outputs,
    and controllers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are the Raspberry Pi 4B and 3A+ still the most recent versions? Would you use
    another model, and what would be the trade-offs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the drawbacks of the laser ranging sensor versus the ultrasonic distance
    sensor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try drawing an approximate physical layout diagram for a different type of robot
    with a different controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Raspberry Pi Sensors*, *Rushi Gajjar*, *Packt Publishing*: Learn to integrate
    sensors into your Raspberry Pi projects and let your powerful microcomputer interact
    with the physical world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Make Sensors: A Hands-On Primer for Monitoring the Real World with Arduino
    and Raspberry Pi*, *Tero Karvinen*, *Kimmo Karvinen*, *Ville Valtokari*, *Maker
    Media, Inc.*: Learn to use sensors to connect a Raspberry Pi or Arduino controller
    with the real world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Make: Electronics: Learning Through Discovery*, *Charles Platt*, *Make Community,
    LLC*: This is a useful resource if you want to find out more about electronic
    components and dive deeper into the individual components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
