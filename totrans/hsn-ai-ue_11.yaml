- en: Designing Behavior Trees - Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a continuation of the previous one. In particular, we will build
    the last missing piece of the puzzle before we build the final Behavior Tree in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ***Player Character***, along with the ***Chasing Agent***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the ***Navigation System*** within the Level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a ***Custom Service ***(both in Blueprint and C++) to update the
    variables that are needed in the Chasing Behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, we will be implementing everything in both Blueprint and C++ to
    give you a broader idea of what you can use. Alternatively, if you already know
    what you want to use, you can just follow one of the two implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Custom Service is the part that will take the most time since we
    will be going through it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment for testing the Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, let's take a break from coding and create the environment
    that we need to test our Behavior Tree. Preparing a good test environment allows
    you to easily spot bugs and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are not going to do anything fancy, but we will look at
    what is required for testing our AI, step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we need to have a Player on the level, since our AI agent will
    chase the Player. Moreover, in the code we are going to write in this chapter,
    we will need to reference a Player class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we already have the ThirdPersonCharacter in our project (if you
    created the project from the *Third Person Template*). Right-click on it and select
    Create Child Blueprint Class, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07e3114c-dc08-49e3-81d8-a8b48a8d4b02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can rename it ***Player***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb500982-89dc-4a07-99ac-2242e999976e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Double-click on the Player open it in the *Blueprint Editor*. In the Details
    Panel, under the Pawn tab, we need to change the Auto Possess Player to Player
    0 and the Auto Possess AI to Disabled, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d10c570-7f16-43ea-99e6-423779ec9cfa.png)'
  prefs: []
  type: TYPE_IMG
- en: As a result, we will have a class just for the *Player Actor* (and it is a Blueprint
    class, which is important). Once that has been placed in the map, it will be possessed
    by the *Player* (to be precise, by the *Player Controller 0*).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chasing Agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to set up the Chasing Agent.
  prefs: []
  type: TYPE_NORMAL
- en: We created a controller for this in the previous chapter, both in Blueprint
    and C++. However, we need to create the actual Pawn that will be possessed. We
    can achieve this in a very similar manner to how we created the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another child blueprint of the ThirdPersonCharacter, but this time rename
    it AI_ChasingAgent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e42779b8-8779-4d63-a56a-1e182af5b4fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Double-click on this to open the Blueprint Editor. As we anticipated in the
    previous chapter, in the *Using the AI Controller* section, in the Details *Panel*,
    under the Pawn tab, we need to set Auto Possess Player to Disabled, Auto Possess
    AI to Placed in World or Spawned and AI Controller Class to ChasingAIController
    (or `BP_ChasingAIController`, if you prefer the Blueprint version of it), as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf395a2-6a9b-40b1-83a2-02bd8b1ff9d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we are going to have many agents trying to chase the Player they would
    probably get stuck if they were to use the current settings that we have. However,
    in [Chapter 7](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml), *Crowds*, we looked
    at many techniques that we can use to handle these kinds of situations. In particular,
    if we have just a few agents, it might be sufficient to activate ***RVO Avoidance***.
    Hence, select the ***CharacterMovementComponent*** from the Components panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a40927ca-8c9e-4274-932c-82347c4aeeeb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the Character Movement: Avoidance tab, we just need to check Use RVOAvoidance.
    The default settings should be fine, but feel free to adapt them as per your needs
    (check out [Chapter 7](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml), *Crowds*,
    again if you need more assistance):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2888ac2-5685-429d-a1ed-1ed8b6e46062.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the `AI_ChasingAgent`. As a result, our Chasing Agent is ready to be placed
    in the map, and once we have implemented the Behavior Tree and started it, it
    will start chasing the Player.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our *Player* and the *Chasing Agent*. However, we need to set up a Level
    where we can test our Behavior. Therefore, we can duplicate (or directly use it,
    if you prefer) the `ThirdPersonExampleMap` and rename it to something more familiar
    (for example, `TestingChasingBehavior`).
  prefs: []
  type: TYPE_NORMAL
- en: Here, I leave you to your imagination so that you can build a nice test map
    for our character. Once you are done, come back here and continue reading. For
    simplicity's sake, I will not modify the map, but just describe the next steps
    that should be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to erase all the characters that might be in the map (for
    example, the `ThirdPersonCharacter`) since we will replace them with ours. Then,
    we will place (by dragging from the *Content Browser* into the *Viewport*) one,
    and only one, Player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e318c72-aa7b-4ab0-a6ca-6050cd59bf29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can place a couple of Chasing agents, in the same way as we did for
    the Player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d092580-6a62-42c6-9d0c-0b17c456df35.png)'
  prefs: []
  type: TYPE_IMG
- en: We are almost done. The last step is setting up the navigation for the level.
    In fact, our ***Find Random Location Task*** relies on the fact that the Navigation
    Mesh is set for the level. We went into detail about the Navigation System in
    Chapter XX, so revise that chapter if you need further assistance on the navigation.
    This section will just describe how to very quickly set up the navigation for
    our level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the Navigation System, we just need to select the ***Nav Mesh Bounds
    Volume*** from the Modes panel (by selecting the *All Class Tab*) and drag it
    into the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2516446-872b-48b7-8d62-8c1818f035ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you need to extend it to cover the whole map. If you press the *P* key,
    you will be able to preview your *NavMesh*, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db878f26-db8f-409a-8838-d50e3e38efe1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are set to go. Let's continue with the coding part.
  prefs: []
  type: TYPE_NORMAL
- en: Service – Update Chasing Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We didn't describe anything like a service in our ***Expected Behaviour***,
    and that's fine – it means that we don't need anything like a service for our
    Behavior, per-se. However, each Behavior Tree has to update the relevant values
    somehow. One way to do this is by using a service.
  prefs: []
  type: TYPE_NORMAL
- en: The kinds of services that update specific values are often specific (in the
    implementation) and less likely reusable, but sometimes they are needed to run
    the Behavior Tree. Moreover, since we already looked at a practical example on
    how to create a *Task* and a *Decorator*, this is the occasion to learn a bit
    more about ***Services***.
  prefs: []
  type: TYPE_NORMAL
- en: We need to think about the variables contained in the *Blackboard*, and which
    one needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The first variable that we need to assign is the **Player**. In fact, we need
    to have a reference to the Player Pawn so that they can chase when the agent is
    in sight. However, we don't need to update this value every time the Service is
    updated, just when the service starts up.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that this service will be placed at the beginning of the
    tree. Every time the Behavior Tree restarts, the Service is "*rebooted*" again,
    updating the Player reference. This is intended because if the Player dies, and
    another Pawn spawns, this service will update the reference to the new Pawn as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have to update the boolean variable if the *Player* is currently i*n
    Sight* or not. Since this variable will determine which part of the Behavior Tree
    to execute (decorators will cut the tree if the condition is not met in our case,
    as we will see later in this chapter), we must update it at every tick of the
    Service.
  prefs: []
  type: TYPE_NORMAL
- en: The last variable to update is the ***Destination*** (in the case, the Player
    is not in sight). In fact, this variable will contain the ***Last Known Player*** ***Position***
    in the case that the Player has just left the view. Otherwise, the variable will
    contain the random location we assign in our *Task*. Therefore, we need to check
    whether to update this variable or not at every tick of the service (since we
    want the last seen position of the player to be updated only when the player leaves
    the field of view of our agent). At the moment, the Player is no longer in sight,
    and so we update this value once, since the ***Last Known Player*** position will
    not change until the *Player* is in sight again, and the Behavior Tree will keep
    it until it isn't required and overrides it with a *Random Location*. We can achieve
    this behavior by using a local variable within the service that keeps track of
    the last value of the boolean variable (if the player is in sight), and if it
    differs from the current cycle (tick) of the service, then we update the ***Destination*** variable
    with the ***Last Known Player Position***.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it is worth noting that we are going to take the values of this variable
    from the agent controller, making this Service dependent on this specific controller
    (which is why I stated previously that these kinds of services aren't as reusable).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear overview of what our service should do, let's jump
    into how to implement it (both in Blueprint and C++, so that you can choose the
    method that you prefer).
  prefs: []
  type: TYPE_NORMAL
- en: Update Chasing Behavior Blueprint implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create the service and name it `BTService_UpdateChasingBehavior`.
    Then, we need to add some variables. We will call the first ***CanSeePlayerKey***,
    of type *Blackboard Key Selector*, which will hold the reference to the boolean
    variable in the Blackboard that determines if the AI can currently see the player
    or not. Of course, this variable needs to be public so that it can be set from
    the Behavior Tree. The second variable, which always of type *Blackboard Key Selector*,
    named ***PlayerKey***, is a reference to the Player Pawn in the Blackboard; this
    has to be public as well. The third is another public *Blackboard Key Selector*
    named ***LastKnownPositionKey***, but it will be fed with the *Destination* vector
    in the Blackboard, as we discussed in the previous section. The last variable
    is a local private variable of type boolean named ***LastCanSeePlayer***, which
    stores the previous state (during the last tick) of the ***CanSeePlayer*** boolean.
    In this way, it is possible to know whether the state has changed and if an update
    of the Destination is required or not. In the end, this is how our variables should
    appear in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41f1b799-ba75-4df5-b325-8127e5067828.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to *override/create* the ***Receive Activation AI*** event,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08b20073-5b5f-4027-a2ec-d3d1bc5d5e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This event is fired only when the service is activated, which in our case will
    be every time the Behavior Tree restarts. Here, we need to get the reference to
    the *Player*. We can easily achieve this by using a ***Get All Actor of Class*** node.
    We need to provide the class player so that we can just insert the *Player* class
    we choose. In this case, we will be using the Player class we created at the beginning
    of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08870a32-96c4-4b17-b105-62142d024ba4.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to make your service a bit more modular, you can pass the Player
    class as a variable so that you can change it depending on the Behavior Tree.
    In the C++ implementation, we will do this, mainly because it is easier to reference
    Blueprint classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we assume that there is just one Player in the game (otherwise, you should
    have the logic to find the right Player to chase; maybe the closest one?) and
    we get it from the array. Finally, we save it in the **Player Key** *Object Reference *in
    the Blackboard by using the **Set Blackboard Value as Object** node. This is the
    final graph of the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/687ea3e5-8f05-4b17-a422-7c0d430645b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to *override/create* the **Receive Tick AI** event, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aa43632-9faf-4e50-88ca-0ca4fab3071c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we can do is cast the Owner Controller into the Controller
    class we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7178712-c0d6-4282-98c4-ab661faaace5.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use also the `ChasingAIController` (the non-blueprint version written
    in C++). However, if you do, you will not be able to have access to its variables.
    Even if they are declared public, they are invisible to Blueprint if they don't
    have the `***UPROPERTY()***` macro before them. So, if you want to use the C++
    version of the controller, be sure to add the `UPROPERTY()` macro (with the proper
    parameters) before each variable to make them visible to the blueprint as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if the cast succeeds, we can gather the reference to the **CanSeePlayer**
    variable from the `BP_ChasingAIController`. Then, by using the **CanSeePlayerKey**
    variable, we can set its value within the Blackboard by using the **Set Blackboard
    Value as Bool**. This is the graph we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83a6c05b-9b5d-4d72-a9ae-c0370ad127f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to compare this value (the current **CanSeePlayer** boolean)
    with the one stored in the **LastCanSeePlayer** variable (which stores the value
    of the last Tick). We can achieve this by using an **Equal** node along with a
    **Branch**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db96e8e4-d681-4abe-89be-1fd6653ab4a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If these two values are different, then we need to retrieve the **LastKnownPlayerPosition**
    from `BP_ChasingAIController` and set it in the Blackboard through the **LastKnownPlayerPositionKey**
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11bded8e-dbbf-450b-857e-f3bf0ab3bc92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, regardless of whether we have updated this vector or not (in both
    the *True* and *False* branches), we need to update the **LastCanSeePlayer** variable
    with the current value. This is the final part of the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a4956d1-422a-4e39-bdf9-c7ac70698af1.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the *Service*, and we are finally ready to build our *Behavior Tree*!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you drop this service within a *Behavior Tree*, this is what it will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f277db40-ea55-4b50-91db-a9ea3bb90f3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The *Details Panel* of the *Service* (within the Behavior Tree Editor) should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1ddd5eb-1063-42d8-889e-4fb7e3f11636.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we are going to implement this *Service in C++*, and there
    will be many things to take into consideration. Of course, you are welcome to
    repeat this process in C++ as well to improve your skills; otherwise, you can
    skip to the next section, in which we will build our Behavior Tree.
  prefs: []
  type: TYPE_NORMAL
- en: Update Chasing Behavior C++ implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to recreate the *Update Chasing Behavior Service
    in C++*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new class that inherits from **BTService**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2845e1d-0250-46ee-b012-bd000d9c9165.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will rename our class `BTService_UpdateChasing` and place it in the `AI`
    folder, like we did for the other AI classes in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd9512f-2f84-42f2-90b2-d2b0c4a45c83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If, after the creation the code, it doesn''t compile, ensure that you followed
    the previous chapter. In fact, we added both **GameplayTasks** and **AIModule**
    to the Public Dependencies of our Project. For your convenience, here is what
    we did in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to change your `.cs` file (in our case, ***BehaviorTreeDesign.cs***)
    and add **GameplayTasks** and **AIModule** as public dependencies, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able compile without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add some variables to our Service in the header file. We
    can call the first **CanSeePlayerKey** of type Blackboard Key Selector, which
    will hold the reference to the boolean variable in the Blackboard that determines
    whether the AI can currently see the player or not. Of course, this variable needs
    to have the `UPROPERTY()` set so that it can be set from the Behavior Tree. The
    second variable, which is always of type Blackboard Key Selector, named **PlayerKey**,
    is a reference to the Player Pawn in the Blackboard; this needs to have the `UPROPERTY()`
    macro as well. The third is another Blackboard Key Selector named **LastKnownPositionKey**,
    always with the `UPROPERTY()` macro, but it will be fed with the Destination vector
    in the Blackboard, as we discussed previously. The last variable is a local private
    variable of type boolean named "***Last*CanSeePlayer**, which stores the previous
    state (during the last Tick) of the **CanSeePlayer** boolean. In this way, it
    is possible to know whether the state has changed and if an update of the Destination
    is required or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code needs to be inserted in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need another variable – not for the logic of the service, like in the
    previous cases, but one to select the Player class from the Behavior Tree. We
    will name the variable **PlayerClass** of type **TSubclassOf<AActor>** so that
    we can select any class that derives from AActor. Of course, this variable needs
    to have the `UPROPERTY()` macro as well so that it can be sent directly from the
    Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to mirror the blueprint version of the service, in which we find
    all the actors of that class, and assume that there is only one. At the end of
    this chapter, a different approach is proposed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to declare some functions so that we can override/create both
    the C++ versions of the Blueprint **Receive Activation AI** and **Receive Tick
    AI** events. These are called `OnBecomingRelevant()` and `TickNode()`, respectively,
    and the signature to override them is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to declare a constructor for our Service. You will understand
    why shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `.cpp` file, we need to implement these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the constructor. In this function, we need to initialize
    some values for our service; in particular, we want to notify (by setting the
    respective variable to true) that we want to use the `OnBecomeRelevant()` function.
    Even if this is not necessary, because the variable is set to *true* by default,
    it''s very good practice to explicitly set the values of these kinds of variables
    in the constructor. Since we are here, it''s worth turning off the call to the `OnCeaseRelevant()`
    function (the inverse of the `OnBecomeRelevant()`). The following code shows the
    constructor with the names of the boolean variables we need to set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next event to implement is `OnBecomRelevant()`, and it is only fired when
    the service becomes relevant (it gets activated), which in our case will be every
    time the Behavior Tree restarts. Here, we need to get the reference to the Player
    so that we can store it in Blackboard. First of all, we need to retrieve the Blackboard
    Component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to retrieve the Player by using something very similar to the
    Blueprint node called `GetAllActorsOfClass`. In particular, we will create an
    empty `TArray<AActor*>` and use the `UGameplayStatics::GetAllActorsOfClass()`
    function to bypass the world, the Player class, and the empty array. Now, this
    function will fill up our array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we assume that there is just one Player in the game (otherwise, you need
    to find the right player to chase; maybe the closest one?) and check if the first
    element of the Array is valid, and if so, we use the **PlayerKey **variable to
    save it in the Blackboard component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have mirrored the blueprint service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, in C++ we can do an extra step and avoid to Set the *Player* again
    if the *Key* is already s*et* (something we couldn''t do in Blueprint). So we
    can add this *if-statement*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in regards to the implementation of the `TickNode()` function, we first
    retrieve the *Blackboard Component*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to retrieve the AI Controller from the `OwnerComp` and check
    whether it is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the AI Controller, we need to **Cast** it into our `AChasingAIController`
    (the one we created in the previous chapter) and check its validity. As a result,
    this service will work only if the AI agent is controlled by a `ChasingAIController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From `ChasingAIController`, we can retrieve the (current) **CanSeePlayer**
    and save it within the Blackboard by using the `CanSeePlayerKey` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the private `LastCanSeePlayer` variable (which contains the value of the
    `CanSeePlayer` of the last Tick) is different from the current `CanSeePlayer`
    (which means that the Player is either entered or exited from the Sight of our
    Agent), then retrieve the `LastKnownPlayerPosition` from the `ChasingAIController`
    and save it within the Blackboard by using the `LastKnonwPositionKey` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the previous check, we need to update the `LastCanSeePlayer` with the
    current value of it so that in the next Tick we will have the right value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can make a call to the parent `TickNode()` (as per good practice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for our service is now complete. For your convenience, here is the
    code of the `TickNode()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Save and compile the Service. Now, you will be able to use it in the Behavior
    Tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the Service looks like once placed in the Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1befbcf5-8fea-4bec-b6b0-02a5a1b81ee3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The *Details Panel* of the Service (within the *Behavior Tree Editor*) should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/159b74a9-d476-4327-902f-df1e0a2be114.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we move on, as we did for the *Decorator* and the *Task*, it is good
    practice to add a static description to the *Service* so that we can visualize
    which Keys (*Blackboard Key Selector* variables) we assigned, along with the *Player*
    class. Here, we need to add the signature of the function in the header file,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the implementation (in the `.cpp` file), we can just return a formatted *FString*
    with all the information we need to show. We can easily format the string with
    the `Printf()` function. I''m using the `Append()` function here to increase the
    clarity of each line. In particular, we need to show which line is for the `PlayerClass`,
    and which values we have assigned to each *Blackboard Key Selector* variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the Service will look as follows in the Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53cb0759-0498-497e-9f86-f9c6f81ecb63.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our *Service* has been implemented, we are ready to build our *Behavior
    Tree* in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continued our in-depth example of how to create a ***Behavior
    Tree*** and used all of the systems we have encountered so far.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we have seen how we can set up the ***Testing Environment*** and
    create both the ***Player Character*** and the Chasing Agent. This latter needed
    to have the right controller, and also needed to have *RVO Avoidance* activated.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we implemented our ***Update Chasing Behavior Service***, and looked at how
    to do so in both C++ and Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with this example and build the final
    Behavior Tree. By the end of this next chapter, we will have completed this project
    and we will have our ***Chasing Behavior***. So, let's keep going!
  prefs: []
  type: TYPE_NORMAL
