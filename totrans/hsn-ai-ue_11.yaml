- en: Designing Behavior Trees - Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计行为树 - 第二部分
- en: This chapter is a continuation of the previous one. In particular, we will build
    the last missing piece of the puzzle before we build the final Behavior Tree in
    the next chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是上一章的延续。特别是，在我们下一章构建最终的Behavior Tree之前，我们将构建最后缺失的拼图。
- en: 'In particular, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将涵盖以下主题：
- en: Creating the ***Player Character***, along with the ***Chasing Agent***
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**玩家角色**，以及**追逐代理**
- en: Setting up the ***Navigation System*** within the Level
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关卡内设置**导航系统**
- en: Implementing a ***Custom Service ***(both in Blueprint and C++) to update the
    variables that are needed in the Chasing Behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个**自定义服务**（在蓝图和C++中），以更新追逐行为所需的变量
- en: Once again, we will be implementing everything in both Blueprint and C++ to
    give you a broader idea of what you can use. Alternatively, if you already know
    what you want to use, you can just follow one of the two implementations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次在蓝图和C++中实现一切，以给你一个更广泛的想法，了解你可以使用什么。或者，如果你已经知道你想要使用什么，你只需遵循两种实现方法之一。
- en: Making the Custom Service is the part that will take the most time since we
    will be going through it step by step.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 制作自定义服务是耗时最长的部分，因为我们将逐步进行。
- en: Let's get to it!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Setting up the environment for testing the Behavior Tree
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试Behavior Tree设置环境
- en: Before we move on, let's take a break from coding and create the environment
    that we need to test our Behavior Tree. Preparing a good test environment allows
    you to easily spot bugs and fix them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们从编码中休息一下，创建我们需要测试Behavior Tree的环境。准备一个好的测试环境可以让你轻松地发现并修复错误。
- en: In this section, we are not going to do anything fancy, but we will look at
    what is required for testing our AI, step by step.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会做任何花哨的事情，但我们将逐步查看测试我们的AI所需的内容。
- en: Creating the Player
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家
- en: First of all, we need to have a Player on the level, since our AI agent will
    chase the Player. Moreover, in the code we are going to write in this chapter,
    we will need to reference a Player class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在关卡上有一个玩家，因为我们的AI代理将追逐玩家。此外，在本章中我们将编写的代码中，我们需要引用一个玩家类。
- en: 'In this case, we already have the ThirdPersonCharacter in our project (if you
    created the project from the *Third Person Template*). Right-click on it and select
    Create Child Blueprint Class, as shown in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已经在我们的项目中有了ThirdPersonCharacter（如果你是从*第三人称模板*创建的项目）。右键单击它，选择创建子蓝图类，如下面的截图所示：
- en: '![](img/07e3114c-dc08-49e3-81d8-a8b48a8d4b02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/07e3114c-dc08-49e3-81d8-a8b48a8d4b02.png)'
- en: 'Then, we can rename it ***Player***:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其重命名为**玩家**：
- en: '![](img/cb500982-89dc-4a07-99ac-2242e999976e.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/cb500982-89dc-4a07-99ac-2242e999976e.png)'
- en: 'Double-click on the Player open it in the *Blueprint Editor*. In the Details
    Panel, under the Pawn tab, we need to change the Auto Possess Player to Player
    0 and the Auto Possess AI to Disabled, as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 双击玩家，在*蓝图编辑器*中打开它。在详细信息面板中，在Pawn选项卡下，我们需要将自动占据玩家更改为玩家0，并将自动占据AI更改为禁用，如下面的截图所示：
- en: '![](img/8d10c570-7f16-43ea-99e6-423779ec9cfa.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/8d10c570-7f16-43ea-99e6-423779ec9cfa.png)'
- en: As a result, we will have a class just for the *Player Actor* (and it is a Blueprint
    class, which is important). Once that has been placed in the map, it will be possessed
    by the *Player* (to be precise, by the *Player Controller 0*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将有一个专门用于*玩家Actor*的类（它是一个蓝图类，这很重要）。一旦将其放置在地图上，它将被玩家占据（更准确地说，由*玩家控制器0*占据）。
- en: Creating the Chasing Agent
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建追逐代理
- en: The next step is to set up the Chasing Agent.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置追逐代理。
- en: We created a controller for this in the previous chapter, both in Blueprint
    and C++. However, we need to create the actual Pawn that will be possessed. We
    can achieve this in a very similar manner to how we created the player.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中已经为它创建了一个控制器，既有蓝图也有C++。然而，我们需要创建一个将被占据的实际Pawn。我们可以用与创建玩家非常相似的方式来实现这一点。
- en: 'Create another child blueprint of the ThirdPersonCharacter, but this time rename
    it AI_ChasingAgent:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ThirdPersonCharacter的另一个子蓝图，但这次将其重命名为AI_ChasingAgent：
- en: '![](img/e42779b8-8779-4d63-a56a-1e182af5b4fd.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e42779b8-8779-4d63-a56a-1e182af5b4fd.png)'
- en: 'Double-click on this to open the Blueprint Editor. As we anticipated in the
    previous chapter, in the *Using the AI Controller* section, in the Details *Panel*,
    under the Pawn tab, we need to set Auto Possess Player to Disabled, Auto Possess
    AI to Placed in World or Spawned and AI Controller Class to ChasingAIController
    (or `BP_ChasingAIController`, if you prefer the Blueprint version of it), as shown
    in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 双击以打开蓝图编辑器。正如我们在上一章中在*使用AI控制器*部分所预料的，在*细节*面板下，在Pawn选项卡中，我们需要将Auto Possess Player设置为Disabled，Auto
    Possess AI设置为Placed in World or Spawned，并将AI Controller Class设置为ChasingAIController（或者如果你更喜欢蓝图版本，则为`BP_ChasingAIController`），如下面的截图所示：
- en: '![](img/acf395a2-6a9b-40b1-83a2-02bd8b1ff9d1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acf395a2-6a9b-40b1-83a2-02bd8b1ff9d1.png)'
- en: 'Since we are going to have many agents trying to chase the Player they would
    probably get stuck if they were to use the current settings that we have. However,
    in [Chapter 7](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml), *Crowds*, we looked
    at many techniques that we can use to handle these kinds of situations. In particular,
    if we have just a few agents, it might be sufficient to activate ***RVO Avoidance***.
    Hence, select the ***CharacterMovementComponent*** from the Components panel:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将会有许多代理试图追逐玩家，如果他们使用当前的设置，他们可能会卡住。然而，在第7章[人群]中，我们探讨了我们可以用来处理这类情况的技术。特别是，如果我们只有少数几个代理，激活***RVO
    Avoidance***可能就足够了。因此，从组件面板中选择***CharacterMovementComponent***：
- en: '![](img/a40927ca-8c9e-4274-932c-82347c4aeeeb.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a40927ca-8c9e-4274-932c-82347c4aeeeb.png)'
- en: 'Then, in the Character Movement: Avoidance tab, we just need to check Use RVOAvoidance.
    The default settings should be fine, but feel free to adapt them as per your needs
    (check out [Chapter 7](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml), *Crowds*,
    again if you need more assistance):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在角色移动：避免选项卡中，我们只需勾选使用RVOAvoidance。默认设置应该足够好，但如果你需要更多帮助，请随意根据你的需求调整（查看[第7章](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml)，*人群*）：
- en: '![](img/c2888ac2-5685-429d-a1ed-1ed8b6e46062.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2888ac2-5685-429d-a1ed-1ed8b6e46062.png)'
- en: Save the `AI_ChasingAgent`. As a result, our Chasing Agent is ready to be placed
    in the map, and once we have implemented the Behavior Tree and started it, it
    will start chasing the Player.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`AI_ChasingAgent`。因此，我们的追逐代理已经准备好放置在地图中，一旦我们实现了行为树并启动它，它将开始追逐玩家。
- en: Preparing the Level
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备级别
- en: We have our *Player* and the *Chasing Agent*. However, we need to set up a Level
    where we can test our Behavior. Therefore, we can duplicate (or directly use it,
    if you prefer) the `ThirdPersonExampleMap` and rename it to something more familiar
    (for example, `TestingChasingBehavior`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了*玩家*和*追逐代理*。然而，我们需要设置一个可以测试我们行为的级别。因此，我们可以复制（或者如果你更喜欢，可以直接使用）`ThirdPersonExampleMap`并将其重命名为更熟悉的名字（例如，`TestingChasingBehavior`）。
- en: Here, I leave you to your imagination so that you can build a nice test map
    for our character. Once you are done, come back here and continue reading. For
    simplicity's sake, I will not modify the map, but just describe the next steps
    that should be taken.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将留给你的想象力，以便你可以为我们的角色构建一个不错的测试地图。一旦你完成了，请回到这里继续阅读。为了简单起见，我不会修改地图，但将描述应该采取的下一步。
- en: 'The first step is to erase all the characters that might be in the map (for
    example, the `ThirdPersonCharacter`) since we will replace them with ours. Then,
    we will place (by dragging from the *Content Browser* into the *Viewport*) one,
    and only one, Player:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是擦除地图中可能存在的所有字符（例如，`ThirdPersonCharacter`），因为我们将会用我们的来替换它们。然后，我们将放置（通过从*内容浏览器*拖动到*视口*）一个，并且只有一个，玩家：
- en: '![](img/1e318c72-aa7b-4ab0-a6ca-6050cd59bf29.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e318c72-aa7b-4ab0-a6ca-6050cd59bf29.png)'
- en: 'Then, we can place a couple of Chasing agents, in the same way as we did for
    the Player:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以以与玩家相同的方式放置几个追逐代理：
- en: '![](img/3d092580-6a62-42c6-9d0c-0b17c456df35.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d092580-6a62-42c6-9d0c-0b17c456df35.png)'
- en: We are almost done. The last step is setting up the navigation for the level.
    In fact, our ***Find Random Location Task*** relies on the fact that the Navigation
    Mesh is set for the level. We went into detail about the Navigation System in
    Chapter XX, so revise that chapter if you need further assistance on the navigation.
    This section will just describe how to very quickly set up the navigation for
    our level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。最后一步是为该级别设置导航。实际上，我们的***随机位置查找任务***依赖于导航网格已为该级别设置。我们在第XX章详细介绍了导航系统，所以如果你需要进一步的帮助，请修改该章节。本节将仅描述如何快速设置我们级别的导航。
- en: 'To build the Navigation System, we just need to select the ***Nav Mesh Bounds
    Volume*** from the Modes panel (by selecting the *All Class Tab*) and drag it
    into the map:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建导航系统，我们只需从模式面板中选择***导航网格边界体积***（通过选择*所有类标签*）并将其拖入地图中：
- en: '![](img/f2516446-872b-48b7-8d62-8c1818f035ad.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2516446-872b-48b7-8d62-8c1818f035ad.png)'
- en: 'Then, you need to extend it to cover the whole map. If you press the *P* key,
    you will be able to preview your *NavMesh*, as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将其扩展以覆盖整个地图。如果你按下*P*键，你将能够预览你的*NavMesh*，如下面的截图所示：
- en: '![](img/db878f26-db8f-409a-8838-d50e3e38efe1.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db878f26-db8f-409a-8838-d50e3e38efe1.png)'
- en: Now, we are set to go. Let's continue with the coding part.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备出发。让我们继续进行编码部分。
- en: Service – Update Chasing Behavior
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务 - 更新追逐行为
- en: We didn't describe anything like a service in our ***Expected Behaviour***,
    and that's fine – it means that we don't need anything like a service for our
    Behavior, per-se. However, each Behavior Tree has to update the relevant values
    somehow. One way to do this is by using a service.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的***预期行为***中，我们没有描述任何类似服务的内容，这是可以的——这意味着我们本身不需要类似服务来处理我们的行为。然而，每个行为树必须以某种方式更新相关值。一种方法是通过使用服务。
- en: The kinds of services that update specific values are often specific (in the
    implementation) and less likely reusable, but sometimes they are needed to run
    the Behavior Tree. Moreover, since we already looked at a practical example on
    how to create a *Task* and a *Decorator*, this is the occasion to learn a bit
    more about ***Services***.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更新特定值的服务的类型通常（在实现上）是特定的，并且不太可能重用，但有时它们是运行行为树所必需的。此外，因为我们已经查看了一个创建*任务*和*装饰器*的实际示例，这是学习更多关于***服务***的好机会。
- en: We need to think about the variables contained in the *Blackboard*, and which
    one needs to be updated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑包含在*黑板*中的变量，以及哪个需要更新。
- en: The first variable that we need to assign is the **Player**. In fact, we need
    to have a reference to the Player Pawn so that they can chase when the agent is
    in sight. However, we don't need to update this value every time the Service is
    updated, just when the service starts up.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分配的第一个变量是**玩家**。实际上，我们需要有一个对玩家Pawn的引用，以便当代理在视野中时它们可以追逐。然而，我们不需要每次服务更新时都更新这个值，只需在服务启动时更新。
- en: It is worth noting that this service will be placed at the beginning of the
    tree. Every time the Behavior Tree restarts, the Service is "*rebooted*" again,
    updating the Player reference. This is intended because if the Player dies, and
    another Pawn spawns, this service will update the reference to the new Pawn as
    well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个服务将被放置在树的开始处。每次行为树重新启动时，服务都会再次“重启”，更新玩家引用。这是有意为之的，因为如果玩家死亡，并且另一个Pawn生成，这个服务也会更新对新Pawn的引用。
- en: Then, we have to update the boolean variable if the *Player* is currently i*n
    Sight* or not. Since this variable will determine which part of the Behavior Tree
    to execute (decorators will cut the tree if the condition is not met in our case,
    as we will see later in this chapter), we must update it at every tick of the
    Service.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须更新布尔变量，以确定*玩家*当前是否在*视野*中。由于这个变量将决定执行行为树中的哪个部分（在我们的情况下，装饰器如果条件不满足将会剪枝，我们将在本章后面看到），我们必须在服务的每个tick更新它。
- en: The last variable to update is the ***Destination*** (in the case, the Player
    is not in sight). In fact, this variable will contain the ***Last Known Player*** ***Position***
    in the case that the Player has just left the view. Otherwise, the variable will
    contain the random location we assign in our *Task*. Therefore, we need to check
    whether to update this variable or not at every tick of the service (since we
    want the last seen position of the player to be updated only when the player leaves
    the field of view of our agent). At the moment, the Player is no longer in sight,
    and so we update this value once, since the ***Last Known Player*** position will
    not change until the *Player* is in sight again, and the Behavior Tree will keep
    it until it isn't required and overrides it with a *Random Location*. We can achieve
    this behavior by using a local variable within the service that keeps track of
    the last value of the boolean variable (if the player is in sight), and if it
    differs from the current cycle (tick) of the service, then we update the ***Destination*** variable
    with the ***Last Known Player Position***.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要更新的变量是 ***Destination***（在这种情况下，玩家不在视线中）。实际上，这个变量将包含玩家刚刚离开视线的 ***最后已知玩家位置***。否则，该变量将包含我们在
    *Task* 中分配的随机位置。因此，我们需要在服务的每个tick中检查是否更新这个变量（因为我们希望只有在玩家离开我们的代理视野时，才更新玩家最后看到的位置）。目前，玩家不再在视线中，所以我们只更新这个值一次，因为
    ***最后已知玩家*** 位置不会改变，直到 *Player* 再次出现在视线中，行为树将保持它，直到不再需要，并用 *随机位置* 覆盖它。我们可以通过在服务中使用一个局部变量来实现这种行为，该变量跟踪布尔变量的最后一个值（如果玩家在视线中），如果它与服务的当前周期（tick）不同，则我们使用
    ***最后已知玩家位置*** 更新 ***Destination*** 变量。
- en: Moreover, it is worth noting that we are going to take the values of this variable
    from the agent controller, making this Service dependent on this specific controller
    (which is why I stated previously that these kinds of services aren't as reusable).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得注意的是，我们将从这个变量中获取代理控制器的值，这使得这个服务依赖于这个特定的控制器（这就是我之前说这些类型的服务不太可重用的原因）。
- en: Now that we have a clear overview of what our service should do, let's jump
    into how to implement it (both in Blueprint and C++, so that you can choose the
    method that you prefer).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地了解了我们的服务应该做什么，让我们来看看如何实现它（在蓝图和C++中，这样你可以选择你更喜欢的方法）。
- en: Update Chasing Behavior Blueprint implementation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新追逐行为蓝图实现
- en: 'First, we need to create the service and name it `BTService_UpdateChasingBehavior`.
    Then, we need to add some variables. We will call the first ***CanSeePlayerKey***,
    of type *Blackboard Key Selector*, which will hold the reference to the boolean
    variable in the Blackboard that determines if the AI can currently see the player
    or not. Of course, this variable needs to be public so that it can be set from
    the Behavior Tree. The second variable, which always of type *Blackboard Key Selector*,
    named ***PlayerKey***, is a reference to the Player Pawn in the Blackboard; this
    has to be public as well. The third is another public *Blackboard Key Selector*
    named ***LastKnownPositionKey***, but it will be fed with the *Destination* vector
    in the Blackboard, as we discussed in the previous section. The last variable
    is a local private variable of type boolean named ***LastCanSeePlayer***, which
    stores the previous state (during the last tick) of the ***CanSeePlayer*** boolean.
    In this way, it is possible to know whether the state has changed and if an update
    of the Destination is required or not. In the end, this is how our variables should
    appear in the editor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建服务并命名为 `BTService_UpdateChasingBehavior`。然后，我们需要添加一些变量。我们将第一个变量命名为
    ***CanSeePlayerKey***，其类型为 *Blackboard Key Selector*，它将保存Blackboard中确定AI是否可以当前看到玩家的布尔变量的引用。当然，这个变量需要是公共的，这样它就可以从行为树中设置。第二个变量，其类型始终为
    *Blackboard Key Selector*，命名为 ***PlayerKey***，是Blackboard中玩家Pawn的引用；这也必须是公共的。第三个是一个名为
    ***LastKnownPositionKey*** 的公共 *Blackboard Key Selector*，但它将接收我们在上一节中讨论的 *Destination*
    向量。最后一个变量是一个类型为布尔值的局部私有变量，命名为 ***LastCanSeePlayer***，它存储了 ***CanSeePlayer*** 布尔变量的上一个状态（在上一个tick期间）。这样，就可以知道状态是否已更改，以及是否需要更新目的地。最后，这是我们的变量在编辑器中应该出现的方式：
- en: '![](img/41f1b799-ba75-4df5-b325-8127e5067828.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41f1b799-ba75-4df5-b325-8127e5067828.png)'
- en: 'The next step is to *override/create* the ***Receive Activation AI*** event,
    as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是 *覆盖/创建* ***Receive Activation AI*** 事件，如下面的截图所示：
- en: '![](img/08b20073-5b5f-4027-a2ec-d3d1bc5d5e4d.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08b20073-5b5f-4027-a2ec-d3d1bc5d5e4d.png)'
- en: 'This event is fired only when the service is activated, which in our case will
    be every time the Behavior Tree restarts. Here, we need to get the reference to
    the *Player*. We can easily achieve this by using a ***Get All Actor of Class*** node.
    We need to provide the class player so that we can just insert the *Player* class
    we choose. In this case, we will be using the Player class we created at the beginning
    of this chapter:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件仅在服务被激活时触发，在我们的案例中，这将是每次行为树重新启动时。在这里，我们需要获取到*Player*的引用。我们可以通过使用***Get All
    Actor of Class***节点轻松实现这一点。我们需要提供类player，这样我们就可以插入我们选择的*Player*类。在这种情况下，我们将使用本章开头创建的Player类：
- en: '![](img/08870a32-96c4-4b17-b105-62142d024ba4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08870a32-96c4-4b17-b105-62142d024ba4.png)'
- en: If you want to make your service a bit more modular, you can pass the Player
    class as a variable so that you can change it depending on the Behavior Tree.
    In the C++ implementation, we will do this, mainly because it is easier to reference
    Blueprint classes as well.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使你的服务更加模块化，你可以将Player类作为一个变量传递，这样你就可以根据行为树来改变它。在C++实现中，我们会这样做，主要是因为这样更容易引用蓝图类。
- en: 'Then, we assume that there is just one Player in the game (otherwise, you should
    have the logic to find the right Player to chase; maybe the closest one?) and
    we get it from the array. Finally, we save it in the **Player Key** *Object Reference *in
    the Blackboard by using the **Set Blackboard Value as Object** node. This is the
    final graph of the event:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们假设游戏中只有一个玩家（否则，你应该有逻辑来找到正确的玩家去追逐；可能是最近的那个？）并从数组中获取它。最后，我们使用**Set Blackboard
    Value as Object**节点将其保存到黑板的**Player Key** *对象引用*中。这是事件的最终图表：
- en: '![](img/687ea3e5-8f05-4b17-a422-7c0d430645b6.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/687ea3e5-8f05-4b17-a422-7c0d430645b6.png)'
- en: 'Now, we need to *override/create* the **Receive Tick AI** event, as shown in
    the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要**覆盖/创建****Receive Tick AI**事件，如下面的截图所示：
- en: '![](img/9aa43632-9faf-4e50-88ca-0ca4fab3071c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9aa43632-9faf-4e50-88ca-0ca4fab3071c.png)'
- en: 'The first thing we can do is cast the Owner Controller into the Controller
    class we created earlier:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是将所有者控制器转换为我们在前面创建的控制器类：
- en: '![](img/c7178712-c0d6-4282-98c4-ab661faaace5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7178712-c0d6-4282-98c4-ab661faaace5.png)'
- en: You can use also the `ChasingAIController` (the non-blueprint version written
    in C++). However, if you do, you will not be able to have access to its variables.
    Even if they are declared public, they are invisible to Blueprint if they don't
    have the `***UPROPERTY()***` macro before them. So, if you want to use the C++
    version of the controller, be sure to add the `UPROPERTY()` macro (with the proper
    parameters) before each variable to make them visible to the blueprint as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`ChasingAIController`（用C++编写的非蓝图版本）。然而，如果你这样做，你将无法访问它的变量。即使它们被声明为public，如果没有在它们之前使用`***UPROPERTY()***`宏，它们对蓝图来说就是不可见的。所以，如果你想使用控制器的C++版本，确保在每个变量之前添加`UPROPERTY()`宏（带有适当的参数），以便它们对蓝图也是可见的。
- en: 'Now, if the cast succeeds, we can gather the reference to the **CanSeePlayer**
    variable from the `BP_ChasingAIController`. Then, by using the **CanSeePlayerKey**
    variable, we can set its value within the Blackboard by using the **Set Blackboard
    Value as Bool**. This is the graph we have so far:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果转换成功，我们可以从`BP_ChasingAIController`中收集到**CanSeePlayer**变量的引用。然后，通过使用**CanSeePlayerKey**变量，我们可以使用**Set
    Blackboard Value as Bool**在黑板上设置其值。这是我们到目前为止的图表：
- en: '![](img/83a6c05b-9b5d-4d72-a9ae-c0370ad127f3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83a6c05b-9b5d-4d72-a9ae-c0370ad127f3.png)'
- en: 'Next, we need to compare this value (the current **CanSeePlayer** boolean)
    with the one stored in the **LastCanSeePlayer** variable (which stores the value
    of the last Tick). We can achieve this by using an **Equal** node along with a
    **Branch**, as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要比较这个值（当前的**CanSeePlayer**布尔值）与存储在**LastCanSeePlayer**变量中的值（存储上一次Tick的值）。我们可以通过使用**Equal**节点和**Branch**来实现这一点，如下面的截图所示：
- en: '![](img/db96e8e4-d681-4abe-89be-1fd6653ab4a9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db96e8e4-d681-4abe-89be-1fd6653ab4a9.png)'
- en: 'If these two values are different, then we need to retrieve the **LastKnownPlayerPosition**
    from `BP_ChasingAIController` and set it in the Blackboard through the **LastKnownPlayerPositionKey**
    variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个值不同，那么我们需要从`BP_ChasingAIController`中检索**LastKnownPlayerPosition**并将其通过**LastKnownPlayerPositionKey**变量设置在黑板上：
- en: '![](img/11bded8e-dbbf-450b-857e-f3bf0ab3bc92.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11bded8e-dbbf-450b-857e-f3bf0ab3bc92.png)'
- en: 'Finally, regardless of whether we have updated this vector or not (in both
    the *True* and *False* branches), we need to update the **LastCanSeePlayer** variable
    with the current value. This is the final part of the graph:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论我们是否更新了这个向量（在*True*和*False*分支中），我们都需要使用当前值更新**LastCanSeePlayer**变量。这是图的最后一部分：
- en: '![](img/5a4956d1-422a-4e39-bdf9-c7ac70698af1.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a4956d1-422a-4e39-bdf9-c7ac70698af1.png)'
- en: Save the *Service*, and we are finally ready to build our *Behavior Tree*!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 保存*服务*，我们终于准备好构建我们的*行为树*了！
- en: 'If you drop this service within a *Behavior Tree*, this is what it will look
    like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在*行为树*中添加这个服务，它看起来会是这样：
- en: '![](img/f277db40-ea55-4b50-91db-a9ea3bb90f3a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f277db40-ea55-4b50-91db-a9ea3bb90f3a.png)'
- en: 'The *Details Panel* of the *Service* (within the Behavior Tree Editor) should
    look as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务*的*详细信息面板*（在行为树编辑器中）应该如下所示：'
- en: '![](img/d1ddd5eb-1063-42d8-889e-4fb7e3f11636.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1ddd5eb-1063-42d8-889e-4fb7e3f11636.png)'
- en: In the next section, we are going to implement this *Service in C++*, and there
    will be many things to take into consideration. Of course, you are welcome to
    repeat this process in C++ as well to improve your skills; otherwise, you can
    skip to the next section, in which we will build our Behavior Tree.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现这个*服务在C++中*，并将有许多事情需要考虑。当然，您也可以在C++中重复这个过程来提高您的技能；否则，您可以跳到下一节，我们将构建我们的行为树。
- en: Update Chasing Behavior C++ implementation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新追逐行为C++实现
- en: In this section, we are going to recreate the *Update Chasing Behavior Service
    in C++*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新创建*C++中的*更新追逐行为服务*。
- en: 'Let''s start by creating a new class that inherits from **BTService**:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的类开始，该类继承自**BTService**：
- en: '![](img/d2845e1d-0250-46ee-b012-bd000d9c9165.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2845e1d-0250-46ee-b012-bd000d9c9165.png)'
- en: 'We will rename our class `BTService_UpdateChasing` and place it in the `AI`
    folder, like we did for the other AI classes in the previous chapter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重命名我们的类`BTService_UpdateChasing`并将其放置在`AI`文件夹中，就像我们在前面的章节中对其他AI类所做的那样：
- en: '![](img/6dd9512f-2f84-42f2-90b2-d2b0c4a45c83.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dd9512f-2f84-42f2-90b2-d2b0c4a45c83.png)'
- en: 'If, after the creation the code, it doesn''t compile, ensure that you followed
    the previous chapter. In fact, we added both **GameplayTasks** and **AIModule**
    to the Public Dependencies of our Project. For your convenience, here is what
    we did in the previous chapter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码创建之后，如果无法编译，请确保您遵循了前面的章节。实际上，我们已经将**GameplayTasks**和**AIModule**添加到了我们项目的公共依赖中。为了您的方便，以下是我们在前面的章节中所做的工作：
- en: 'You need to change your `.cs` file (in our case, ***BehaviorTreeDesign.cs***)
    and add **GameplayTasks** and **AIModule** as public dependencies, as shown in
    the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更改您的`.cs`文件（在我们的例子中，是***BehaviorTreeDesign.cs****）并添加**GameplayTasks**和**AIModule**作为公共依赖，如下面的代码所示：
- en: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
- en: Now, you should be able compile without any problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够编译而不会出现任何问题。
- en: The next step is to add some variables to our Service in the header file. We
    can call the first **CanSeePlayerKey** of type Blackboard Key Selector, which
    will hold the reference to the boolean variable in the Blackboard that determines
    whether the AI can currently see the player or not. Of course, this variable needs
    to have the `UPROPERTY()` set so that it can be set from the Behavior Tree. The
    second variable, which is always of type Blackboard Key Selector, named **PlayerKey**,
    is a reference to the Player Pawn in the Blackboard; this needs to have the `UPROPERTY()`
    macro as well. The third is another Blackboard Key Selector named **LastKnownPositionKey**,
    always with the `UPROPERTY()` macro, but it will be fed with the Destination vector
    in the Blackboard, as we discussed previously. The last variable is a local private
    variable of type boolean named "***Last*CanSeePlayer**, which stores the previous
    state (during the last Tick) of the **CanSeePlayer** boolean. In this way, it
    is possible to know whether the state has changed and if an update of the Destination
    is required or not.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在头文件中为我们的服务添加一些变量。我们可以调用第一个 **CanSeePlayerKey**，其类型为黑板键选择器（Blackboard Key
    Selector），它将持有黑板上确定 AI 是否可以当前看到玩家的布尔变量的引用。当然，这个变量需要设置 `UPROPERTY()`，以便可以从行为树中设置。第二个变量，总是类型为黑板键选择器（Blackboard
    Key Selector），命名为 **PlayerKey**，是黑板上玩家Pawn的引用；这也需要 `UPROPERTY()` 宏。第三个是一个名为 **LastKnownPositionKey**
    的另一个黑板键选择器，总是带有 `UPROPERTY()` 宏，但它将接收黑板中的目标向量，正如我们之前讨论的那样。最后一个变量是一个类型为布尔值的局部私有变量，命名为
    "***Last*CanSeePlayer**"，它存储了 **CanSeePlayer** 布尔变量的上一个状态（在上一个Tick期间）。这样，就可以知道状态是否已更改，以及是否需要更新目标。
- en: 'The following code needs to be inserted in the header file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码需要插入到头文件中：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need another variable – not for the logic of the service, like in the
    previous cases, but one to select the Player class from the Behavior Tree. We
    will name the variable **PlayerClass** of type **TSubclassOf<AActor>** so that
    we can select any class that derives from AActor. Of course, this variable needs
    to have the `UPROPERTY()` macro as well so that it can be sent directly from the
    Behavior Tree:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要另一个变量——不是用于服务的逻辑，就像之前的案例一样，而是一个用于从行为树中选择玩家类（Player class）的变量。我们将这个变量命名为
    **PlayerClass**，其类型为 **TSubclassOf<AActor>**，这样我们就可以选择任何从 AActor 继承的类。当然，这个变量也需要有
    `UPROPERTY()` 宏，以便它可以直接从行为树中发送：
- en: We are going to mirror the blueprint version of the service, in which we find
    all the actors of that class, and assume that there is only one. At the end of
    this chapter, a different approach is proposed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将镜像服务的蓝图版本，其中我们找到该类的所有演员，并假设只有一个。在本章的结尾，将提出一种不同的方法。
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to declare some functions so that we can override/create both
    the C++ versions of the Blueprint **Receive Activation AI** and **Receive Tick
    AI** events. These are called `OnBecomingRelevant()` and `TickNode()`, respectively,
    and the signature to override them is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是声明一些函数，以便我们可以覆盖/创建蓝图 **Receive Activation AI** 和 **Receive Tick AI** 事件的
    C++ 版本。这些分别称为 `OnBecomingRelevant()` 和 `TickNode()`，覆盖它们的签名如下：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we need to declare a constructor for our Service. You will understand
    why shortly:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为我们的服务声明一个构造函数。您很快就会明白为什么：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, in the `.cpp` file, we need to implement these functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `.cpp` 文件中，我们需要实现这些函数。
- en: 'Let''s start with the constructor. In this function, we need to initialize
    some values for our service; in particular, we want to notify (by setting the
    respective variable to true) that we want to use the `OnBecomeRelevant()` function.
    Even if this is not necessary, because the variable is set to *true* by default,
    it''s very good practice to explicitly set the values of these kinds of variables
    in the constructor. Since we are here, it''s worth turning off the call to the `OnCeaseRelevant()`
    function (the inverse of the `OnBecomeRelevant()`). The following code shows the
    constructor with the names of the boolean variables we need to set:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构造函数开始。在这个函数中，我们需要为我们的服务初始化一些值；特别是，我们想要通知（通过将相应的变量设置为 true）我们想要使用 `OnBecomeRelevant()`
    函数。即使这不是必需的，因为这个变量默认设置为 *true*，但在构造函数中明确设置这类变量的值是一种非常好的做法。既然我们在这里，关闭对 `OnCeaseRelevant()`
    函数（`OnBecomeRelevant()` 的逆函数）的调用也是值得的。以下代码显示了包含我们需要设置的布尔变量名称的构造函数：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next event to implement is `OnBecomRelevant()`, and it is only fired when
    the service becomes relevant (it gets activated), which in our case will be every
    time the Behavior Tree restarts. Here, we need to get the reference to the Player
    so that we can store it in Blackboard. First of all, we need to retrieve the Blackboard
    Component:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要实现的事件是`OnBecomRelevant()`，它仅在服务变得相关（被激活）时触发，在我们的案例中，这将是每次行为树重新启动时。在这里，我们需要获取玩家的引用，以便我们可以在黑板中存储它。首先，我们需要检索黑板组件：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we need to retrieve the Player by using something very similar to the
    Blueprint node called `GetAllActorsOfClass`. In particular, we will create an
    empty `TArray<AActor*>` and use the `UGameplayStatics::GetAllActorsOfClass()`
    function to bypass the world, the Player class, and the empty array. Now, this
    function will fill up our array:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用类似于蓝图节点`GetAllActorsOfClass`的方式来检索玩家。具体来说，我们将创建一个空的`TArray<AActor*>`并使用`UGameplayStatics::GetAllActorsOfClass()`函数绕过世界、玩家类和空数组。现在，这个函数将填充我们的数组：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we assume that there is just one Player in the game (otherwise, you need
    to find the right player to chase; maybe the closest one?) and check if the first
    element of the Array is valid, and if so, we use the **PlayerKey **variable to
    save it in the Blackboard component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们假设游戏中只有一个玩家（否则，你需要找到正确的玩家来追逐；可能是最近的那个？）并检查数组的第一个元素是否有效，如果是，我们使用**PlayerKey**变量将其保存在黑板组件中。
- en: 'Here''s the code for doing so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行此操作的代码：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, we have mirrored the blueprint service.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们已经镜像了蓝图服务。
- en: 'Furthermore, in C++ we can do an extra step and avoid to Set the *Player* again
    if the *Key* is already s*et* (something we couldn''t do in Blueprint). So we
    can add this *if-statement*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在C++中，我们可以进行额外的一步，如果*Key*已经设置（这是在蓝图中所不能做的），则避免再次设置*Player*。因此，我们可以添加这个*if语句*：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, in regards to the implementation of the `TickNode()` function, we first
    retrieve the *Blackboard Component*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于`TickNode()`函数的实现，我们首先检索*黑板组件*：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we need to retrieve the AI Controller from the `OwnerComp` and check
    whether it is valid:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要从`OwnerComp`中检索AI控制器并检查其是否有效：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have the AI Controller, we need to **Cast** it into our `AChasingAIController`
    (the one we created in the previous chapter) and check its validity. As a result,
    this service will work only if the AI agent is controlled by a `ChasingAIController`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了AI控制器，我们需要将其**转换**为我们的`AChasingAIController`（我们在上一章中创建的）并检查其有效性。因此，此服务仅当AI代理由`ChasingAIController`控制时才会工作：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From `ChasingAIController`, we can retrieve the (current) **CanSeePlayer**
    and save it within the Blackboard by using the `CanSeePlayerKey` variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ChasingAIController`中，我们可以通过使用`CanSeePlayerKey`变量检索（当前）**CanSeePlayer**并将其保存在黑板中：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the private `LastCanSeePlayer` variable (which contains the value of the
    `CanSeePlayer` of the last Tick) is different from the current `CanSeePlayer`
    (which means that the Player is either entered or exited from the Sight of our
    Agent), then retrieve the `LastKnownPlayerPosition` from the `ChasingAIController`
    and save it within the Blackboard by using the `LastKnonwPositionKey` variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果私有`LastCanSeePlayer`变量（包含上一次Tick的`CanSeePlayer`的值）与当前的`CanSeePlayer`不同（这意味着玩家要么进入了我们的代理的视线，要么离开了），那么从`ChasingAIController`中检索`LastKnownPlayerPosition`并使用`LastKnonwPositionKey`变量将其保存在黑板中：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the previous check, we need to update the `LastCanSeePlayer` with the
    current value of it so that in the next Tick we will have the right value:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的检查之后，我们需要使用当前的值更新`LastCanSeePlayer`，以便在下一个Tick中我们将有正确的值：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we can make a call to the parent `TickNode()` (as per good practice):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用父`TickNode()`（按照良好实践）：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code for our service is now complete. For your convenience, here is the
    code of the `TickNode()` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的代码现在已完成。为了方便起见，以下是`TickNode()`函数的代码：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save and compile the Service. Now, you will be able to use it in the Behavior
    Tree.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并编译服务。现在，你可以在行为树中使用它了。
- en: 'This is what the Service looks like once placed in the Behavior Tree:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务放置在行为树中的样子：
- en: '![](img/1befbcf5-8fea-4bec-b6b0-02a5a1b81ee3.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1befbcf5-8fea-4bec-b6b0-02a5a1b81ee3.png)'
- en: 'The *Details Panel* of the Service (within the *Behavior Tree Editor*) should
    look as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 服务（在*行为树编辑器*中的*详细信息面板*）应如下所示：
- en: '![](img/159b74a9-d476-4327-902f-df1e0a2be114.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/159b74a9-d476-4327-902f-df1e0a2be114.png)'
- en: 'Before we move on, as we did for the *Decorator* and the *Task*, it is good
    practice to add a static description to the *Service* so that we can visualize
    which Keys (*Blackboard Key Selector* variables) we assigned, along with the *Player*
    class. Here, we need to add the signature of the function in the header file,
    as shown in the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，就像我们对 *Decorator* 和 *Task* 所做的那样，将静态描述添加到 *Service* 中是一种良好的实践，这样我们就可以可视化我们分配了哪些键（*Blackboard
    Key Selector* 变量），以及 *Player* 类。在这里，我们需要在头文件中添加函数的签名，如下所示：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As for the implementation (in the `.cpp` file), we can just return a formatted *FString*
    with all the information we need to show. We can easily format the string with
    the `Printf()` function. I''m using the `Append()` function here to increase the
    clarity of each line. In particular, we need to show which line is for the `PlayerClass`,
    and which values we have assigned to each *Blackboard Key Selector* variable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现（在 `.cpp` 文件中），我们只需返回一个格式化的 *FString*，其中包含我们需要显示的所有信息。我们可以使用 `Printf()`
    函数轻松地格式化字符串。我在这里使用 `Append()` 函数来提高每一行的清晰度。特别是，我们需要显示哪一行是针对 `PlayerClass` 的，以及我们分配给每个
    *Blackboard Key Selector* 变量的哪些值：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, the Service will look as follows in the Behavior Tree:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在行为树中，服务将如下所示：
- en: '![](img/53cb0759-0498-497e-9f86-f9c6f81ecb63.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53cb0759-0498-497e-9f86-f9c6f81ecb63.png)'
- en: Now that our *Service* has been implemented, we are ready to build our *Behavior
    Tree* in the next chapter!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了 *Service*，我们准备在下一章构建我们的 *行为树*！
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we continued our in-depth example of how to create a ***Behavior
    Tree*** and used all of the systems we have encountered so far.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们继续深入探讨了如何创建 **行为树** 的示例，并使用了迄今为止遇到的所有系统。
- en: In particular, we have seen how we can set up the ***Testing Environment*** and
    create both the ***Player Character*** and the Chasing Agent. This latter needed
    to have the right controller, and also needed to have *RVO Avoidance* activated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们可以看到如何设置**测试环境**并创建**玩家角色**和追逐代理。后者需要正确的控制器，并且还需要激活*RVO 避障*。
- en: Then, we implemented our ***Update Chasing Behavior Service***, and looked at how
    to do so in both C++ and Blueprint.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了我们的 **更新追逐行为服务**，并探讨了如何在 C++ 和 Blueprint 中实现。
- en: In the next chapter, we will continue with this example and build the final
    Behavior Tree. By the end of this next chapter, we will have completed this project
    and we will have our ***Chasing Behavior***. So, let's keep going!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续这个示例并构建最终的行为树。到下一章结束时，我们将完成这个项目，并拥有我们的 **追逐行为**。所以，让我们继续前进！
