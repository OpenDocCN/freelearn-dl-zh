- en: The Basics of AI in Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中人工智能的基础
- en: '**Artificial Intelligence** (**AI**) is a rich and complex topic. At first
    glance, it can seem intimidating. The uses for it are diverse, ranging from robotics
    to statistics and to (more relevantly for us) entertainment, more specifically,
    video games. Our goal in this book will be to demystify the subject by breaking
    down the usage of AI into relatable, applicable solutions, and to provide accessible
    examples that illustrate the concepts in ways that cut through the noise and go
    straight for the core ideas. This book will lead you head first into the world
    of AI, and will introduce you to the most important concepts to start you on your
    AI journey.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）是一个丰富且复杂的话题。乍一看，它可能显得令人畏惧。它的用途多种多样，从机器人学到统计学，再到（对我们来说更相关的）娱乐，特别是视频游戏。本书的目标将通过将人工智能的应用分解为相关、实用的解决方案，并提供易于理解的示例，以阐明概念，从而消除噪音并直接针对核心思想，来揭开这个主题的神秘面纱。本书将引领您一头扎入人工智能的世界，并介绍您开始人工智能之旅最重要的概念。'
- en: 'This chapter will give you a little background on AI in academics, traditional
    domains, and game-specific applications. Here are the topics we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您简要介绍学术、传统领域和游戏特定应用中的人工智能背景。以下是我们将要涉及的主题：
- en: Exploring how the application and implementation of AI in games is different
    from other domains
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索游戏应用和实现人工智能的方式与其他领域有何不同
- en: Looking at the special requirements for AI in games
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看游戏中对人工智能的特殊要求
- en: Looking at the basic AI patterns used in games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看游戏中使用的基
- en: This chapter will serve as a reference for later chapters, where we'll implement
    AI patterns in Unity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将作为后续章节的参考，在后续章节中，我们将将在Unity中实现人工智能模式。
- en: Creating the illusion of life
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创造生命的幻觉
- en: Before diving in much deeper, we should stop for a moment and define intelligence.
    Intelligence is simply the ability to learn something then apply that knowledge.
    Artificial intelligence, at least for our purposes, is the illusion of intelligence.
    Our intelligent entities need not necessarily learn things, but must at the very
    least convince the player that they are learning things. I must stress that these
    definitions fit game AI specifically. As we'll discover later in this section,
    there are many applications for AI outside of games, where other definitions are
    more adequate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，我们应该停下来片刻，定义一下智能。智能简单来说就是学习某事物然后应用该知识的能力。至少对我们来说，人工智能是智能的幻觉。我们的智能实体不必一定学习事物，但至少必须让玩家相信它们正在学习。我必须强调，这些定义仅适用于游戏人工智能。正如我们将在本节后面发现的那样，人工智能在游戏之外有许多应用，那里的定义更为恰当。
- en: Intelligent creatures, such as humans and other animals, learn from their environment.
    Whether it's through observing something visually, hearing it, feeling it, and
    so on, our brains convert those stimuli into information that we process and learn
    from. Similarly, our computer-created AI must observe and react to its environment
    to appear smart. While we use our eyes, ears, and other means to perceive, our
    game's AI entities have a different set of sensors at their disposal. Rather than
    using big, complex brains like ours, our code will simulate the processing of
    that data and the behaviors that model a logical and believable reaction to that
    data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 智能生物，如人类和其他动物，从它们的环境中学习。无论是通过视觉观察、听觉、触觉等，我们的大脑将这些刺激转化为我们处理和学习的知识。同样，我们创建的计算机人工智能必须观察并对其环境做出反应，以显得聪明。虽然我们使用眼睛、耳朵和其他方式来感知，但我们的游戏人工智能实体有一套不同的传感器可供使用。我们的代码将模拟数据的处理和那些模拟对数据做出逻辑和可信反应的行为，而不是使用像我们一样的大脑。
- en: AI and its many related studies are dense and varied, but it is important to
    understand the basics of AI being used in different domains before digging deeper
    into the subject. AI is just a general term; its various implementations and applications
    are different for different needs and for solving different sets of problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能及其众多相关研究内容丰富且多样，但在深入探讨该主题之前，了解不同领域中使用的人工智能基础是非常重要的。人工智能只是一个通用术语；其各种实现和应用因不同需求而异，用于解决不同的问题集。
- en: 'Before we move onto game-specific techniques, let''s take a look at the following
    research areas in AI applications that have advanced tremendously over the last
    several decades. Things that used to be considered science fiction are quickly
    becoming science fact, such as autonomous robots and self-driving cars. You need
    not look very far to find great examples of advances in AI—your smartphone most
    likely has a digital assistant feature that relies on some new AI-related technology.
    It probably knows your schedule better than you do! Here are some of the research
    fields driving AI:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向特定于游戏的技巧之前，让我们看看以下在过去几十年中取得了巨大进步的 AI 应用研究领域。曾经被认为是科幻的东西正在迅速成为科学事实，例如自主机器人和自动驾驶汽车。你不需要看得很远就能找到
    AI 进步的绝佳例子——你的智能手机很可能有一个依赖于一些新 AI 相关技术的数字助手功能。它可能比你更了解你的日程！以下是推动 AI 的研究领域：
- en: '**Computer vision**: This is the ability to take visual input from sources,
    such as video and photo cameras, and analyze it to perform particular operations
    such as facial recognition, object recognition, and optical-character recognition.
    Computer vision is at the forefront of advances in autonomous vehicles. Cars with
    even relatively simple systems, such as collision mitigation and adaptive cruise
    control, use an array of sensors to determine depth contextually to help prevent
    collisions.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机视觉**: 这是指从视频和照相机等来源获取视觉输入，并对其进行分析以执行特定操作的能力，例如人脸识别、物体识别和光学字符识别。计算机视觉是自动驾驶汽车进步的前沿。即使是相对简单的系统，如碰撞缓解和自适应巡航控制，也使用一系列传感器来确定深度上下文，以帮助防止碰撞。'
- en: '**Natural language processing (NLP)**: This is the ability that allows a machine
    to read and understand the languages as we normally write and speak. The problem
    is that the languages we use today are difficult for machines to understand. There
    are many different ways to say the same thing, and the same sentence can have
    different meanings according to the context. NLP is an important step for machines
    since they need to understand the languages and expressions we use before they
    can process them and respond accordingly. Fortunately, there''s an enormous number
    of datasets available on the web that can help researchers by doing automatic
    analysis of a language.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自然语言处理 (NLP)**: 这是指机器能够像我们通常书写和说话一样阅读和理解语言的能力。问题是，我们今天使用的语言对机器来说很难理解。表达相同意思的方式有很多种，而且同一个句子根据上下文的不同可以有不同的含义。NLP
    是机器的一个重要步骤，因为它们在处理和相应地做出反应之前，需要理解我们使用的语言和表达方式。幸运的是，网络上可用的数据集数量庞大，可以帮助研究人员通过自动分析语言来进行研究。'
- en: '**Common sense reasoning**: This is a technique that our brains can easily
    use to draw answers even from domains we don''t fully understand. Common sense
    knowledge is a usual and common way for us to attempt certain questions since
    our brains can mix and interplay context, background knowledge, and language proficiency.
    But making machines apply such knowledge is very complex and still a major challenge
    for researchers.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常识推理**: 这是一种我们的大脑可以轻松使用的技巧，即使是从我们不完全理解的领域也能得出答案。常识知识是我们尝试某些问题的通常和常见方式，因为我们的大脑可以混合和相互作用上下文、背景知识和语言能力。但是，让机器应用这种知识非常复杂，并且仍然是研究人员面临的一个主要挑战。'
- en: '**Machine learning**: This may sound like something straight out of a science
    fiction movie, and the reality is not too far off. Computer programs generally
    consist of a static set of instructions, which take input and provide output.
    Machine learning focuses on the science of writing algorithms and programs that
    can learn from the data processed by said program, and apply that for future learning.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习**: 这可能听起来像是直接来自科幻电影的东西，而现实并不太遥远。计算机程序通常由一组静态的指令组成，这些指令接受输入并提供输出。机器学习专注于编写算法和程序的科学，这些算法和程序可以从程序处理的数据中学习，并将其应用于未来的学习。'
- en: Neural Networks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络
- en: After years and years of research and development, AI is a rapidly expanding
    field. As consumer-level computer hardware becomes more and more powerful, developers
    are finding new and exciting ways to implement ever complex forms of AI in all
    kinds of applications. One such AI concept is **Neural Networks**, a subset of
    machine learning that we mentioned in the previous section. Neural Networks enable
    computers to "learn", and through repeated training become more and more efficient
    and effective at solving any number of problems. A very popular exercise for testing
    Neural Network machine learning is teaching an AI how to discern the value of
    a set of handwritten numbers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的研究和开发，人工智能是一个快速发展的领域。随着消费级计算机硬件变得越来越强大，开发者们正在寻找新的和令人兴奋的方法，将越来越复杂的AI形式应用于各种应用中。其中一个这样的AI概念是**神经网络**，这是我们之前章节中提到的机器学习的一个子集。神经网络使计算机能够“学习”，并通过重复训练，在解决各种问题方面变得越来越高效和有效。一个测试神经网络机器学习的非常流行的练习是教人工智能如何辨别一组手写数字的价值。
- en: In what we call **supervised learning**, we provide our Neural Network a set
    of training data. In the handwritten number scenario, we pass in hundreds or thousands
    of images collected from any source containing handwritten numbers. Using a process
    called **back propagation**, the network can adjust itself with the values and
    data it just "learned" to create a more accurate prediction in the next iteration
    of the learning cycle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所说的**监督学习**中，我们为神经网络提供一组训练数据。在手写数字场景中，我们传递数百或数千张从任何包含手写数字的来源收集的图像。使用称为**反向传播**的过程，网络可以通过它刚刚“学习”的值和数据来调整自己，以在下一个学习周期的迭代中创建更准确的预测。
- en: Believe it or not, the concept of Neural Networks has been around since the
    1940s, with the first implementation happening in the early 1950s. The concept
    is fairly straightforward at a high level—a series of nodes, called **neurons**,
    are connected to one another via their **axons**, or connectors. If these terms
    sound familiar, it's because they were borrowed from brain cell structures with
    the same names, and in some ways, similar functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，神经网络的概念自20世纪40年代以来就已经存在，最早的实施发生在20世纪50年代初。从高层次来看，这个概念相当简单——一系列称为**神经元**的节点通过它们的**轴突**或连接器相互连接。如果这些术语听起来熟悉，那是因为它们是从具有相同名称的脑细胞结构中借用的，并且在某些方面具有相似的功能。
- en: 'Layers of these networks are connected to one another. Generally, there is
    an input layer, a hidden layer, and an output layer. This structure is represented
    by the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些网络的层相互连接。通常，有一个输入层、一个隐藏层和一个输出层。这种结构可以用以下图表表示：
- en: '![](img/1dc6bc0e-2205-450e-962b-a7dc8779df9a.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1dc6bc0e-2205-450e-962b-a7dc8779df9a.png)'
- en: A basic neural net structure
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基本神经网络结构
- en: The input, which represents the data the agent is taking in, such as images,
    audio, or anything else, is passed through a hidden layer, which converts the
    data into something the program can use and then sends that data through to the
    output layer for final processing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输入，代表智能体正在接收的数据，例如图像、音频或其他任何东西，会通过一个隐藏层，该层将数据转换为程序可以使用的格式，然后将这些数据发送到输出层进行最终处理。
- en: In neural net machine learning, not all input is equal; at least, it shouldn't
    be. Input is weighed before being passed into the hidden layer. While it's generally
    okay to start with equal weights, the program can then self-adjust those weights
    through each iteration using back propagation. Put simply, weights are how likely
    the input data is to be useful in the prediction.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在神经网络机器学习中，并非所有输入都是平等的；至少，它不应该如此。输入在传递到隐藏层之前会被加权。虽然一开始使用相等的权重通常是可行的，但程序可以通过反向传播在每个迭代中自我调整这些权重。简单来说，权重是输入数据在预测中可能有用性的概率。
- en: After many iterations of training, the AI will then be able to tackle brand
    new data sets, even if it has never encountered them before! While the use for
    machine learning in games is still limited, the field continues to expand and
    is a very popular topic these days. Make sure not to miss the train and check
    out *Machine Learning for Developers *by Rodolfo Bonnin to deep dive into all
    things related to machine learning.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多次训练迭代后，人工智能将能够处理全新的数据集，即使它以前从未遇到过！虽然机器学习在游戏中的应用仍然有限，但这个领域仍在扩展，并且现在是热门话题。确保不要错过这趟列车，并查看Rodolfo
    Bonnin的*开发者机器学习*，深入了解与机器学习相关的一切。
- en: Leveling up your game with AI
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用人工智能提升你的游戏水平
- en: AI in games dates back all the way to the earliest games, even as far back as
    Namco's arcade hit Pac-Man. The AI was rudimentary at best, but even in Pac-Man,
    each of the enemies—Blinky, Pinky, Inky, and Clyde—had unique behaviors that challenged
    the player in different ways. Learning those behaviors and reacting to them adds
    a huge amount of depth to the game and keeps players coming back, even after over
    30 years since its release.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的AI可以追溯到最早的电子游戏，甚至远至南梦宫的街机热门游戏《吃豆人》。当时的AI非常基础，但在《吃豆人》中，每个敌人——Blinky、Pinky、Inky和Clyde——都有独特的行动方式，以不同的方式挑战玩家。学习这些行为并对它们做出反应，为游戏增添了巨大的深度，并使玩家即使在其发布30多年后仍然回来玩。
- en: It's the job of a good game designer to make the game challenging enough to
    be engaging, but not so difficult that a player can never win. To this end, AI
    is a fantastic tool that can help abstract the patterns that entities in games
    follow to make them seem more organic, alive, and real. Much like an animator
    through each frame or an artist through his brush, a designer or programmer can
    breathe life into their creations via clever use of the AI techniques covered
    in this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的游戏设计师的职责是让游戏既有挑战性又吸引人，但难度不能过高，以免玩家永远无法获胜。为此，人工智能是一个神奇的工具，可以帮助抽象化游戏中实体遵循的规律，使它们看起来更加自然、生动和真实。就像动画师通过每一帧或艺术家通过他的画笔一样，设计师或程序员可以通过巧妙地使用本书中涵盖的人工智能技术，为他们的创作注入生命。
- en: The role of AI in games is to make games fun by providing challenging entities
    to compete with, and interesting **non-player characters** (**NPCs**) that behave
    realistically inside the game world. The objective here is not to replicate the
    whole thought process of humans or animals, but merely to sell the illusion of
    life and make NPCs seem intelligent by having them react to the changing situations
    inside the game world in a way that makes sense to the player.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能在游戏中的角色是通过提供具有挑战性的实体来竞争，以及游戏世界中行为真实的**非玩家角色**（NPCs）。这里的目的是不是复制人类或动物的全部思维过程，而是仅仅通过让NPCs以对玩家有意义的方式对游戏世界中的变化情况做出反应，来营造生命的幻觉并使NPCs看起来更聪明。
- en: Technology allows us to design and create intricate patterns and behaviors,
    but we're not yet at the point where AI in games even begins to resemble true
    human behavior. While smaller, more powerful chips, buckets of memory, and even
    distributed computing have given programmers a much higher computational ceiling
    to dedicate to AI, at the end of the day, resources are still shared between other
    operations such as graphics rendering, physics simulation, audio processing, animation,
    and others, all in real time. All these systems have to play nice with each other
    to achieve a steady frame rate throughout the game. Like all the other disciplines
    in game development, optimizing AI calculations remains a huge challenge for AI
    developers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 技术使我们能够设计和创建复杂的模式和行为，但我们还没有达到游戏中的AI甚至开始类似于真正的人类行为的程度。虽然更小、更强大的芯片、大量的内存甚至分布式计算为程序员提供了更高的计算天花板，可以用于AI，但最终，资源仍然与其他操作共享，如图形渲染、物理模拟、音频处理、动画等，所有这些都在实时进行。所有这些系统都必须相互配合，以在整个游戏过程中保持稳定的帧率。就像游戏开发中的所有其他学科一样，优化AI计算对AI开发者来说仍然是一个巨大的挑战。
- en: Using AI in Unity
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中使用AI
- en: In this section, we'll walk you through some of the AI techniques being used
    in different types of games. We'll learn how to implement each of these features
    in Unity in the upcoming chapters. Unity is a flexible engine that provides a
    number of approaches to implement AI patterns. Some are ready to go out of the
    box, so to speak, while others we'll have to build from scratch. In this book,
    we'll focus on implementing the most essential AI patterns within Unity so that
    you can get your game's AI entities up and running quickly. Learning and implementing
    the techniques within this book will serve as a fundamental first step in the
    vast world of AI. Many of the concepts we will cover in this book, such as pathfinding
    and Navigation Meshes, are interconnected and build on top of one another. For
    this reason, it's important to get the fundamentals right first before digging
    into the high-level APIs that Unity provides.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍不同类型游戏中使用的一些人工智能技术。我们将在接下来的章节中学习如何在Unity中实现这些功能。Unity是一个灵活的引擎，提供了多种实现AI模式的方法。其中一些可以直接使用，而另一些则需要从头开始构建。在本书中，我们将专注于在Unity中实现最关键的AI模式，以便您能够快速启动并运行游戏中的AI实体。学习和实现本书中的技术将是进入广阔的AI世界的基本第一步。本书中我们将涉及到的许多概念，如路径查找和导航网格，都是相互关联的，并且建立在彼此之上。因此，在深入研究Unity提供的高级API之前，首先确保掌握基础知识是非常重要的。
- en: Defining the agent
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义代理
- en: Before jumping into our first technique, we should be clear on a key term you'll
    see used throughout the book—the agent. An agent, as it relates to AI, is our
    artificially intelligent entity. When we talk about our AI, we're not specifically
    referring to a character, but an entity that displays complex behavior patterns,
    which we can refer to as non-random, or in other words, intelligent. This entity
    can be a character, creature, vehicle, or anything else. The agent is the autonomous
    entity, executing the patterns and behaviors we'll be covering. With that out
    of the way, let's jump in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨第一种技术之前，我们应该清楚了解本书中会多次使用的关键术语——代理。在AI的背景下，代理是我们的人工智能实体。当我们谈论我们的AI时，我们并不是特指一个角色，而是一个表现出复杂行为模式、可以被称为非随机或换句话说，智能的实体。这个实体可以是角色、生物、车辆或其他任何东西。代理是自主实体，执行我们将要讨论的模式和行为。现在我们已经明确了这一点，让我们开始吧。
- en: Finite State Machines
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限状态机
- en: '**Finite** **State Machines** (**FSM**) can be considered one of the simplest
    AI models, and they are commonly used in games. A state machine basically consists
    of a set number of states that are connected in a graph by the transitions between
    them. A game entity starts with an initial state and then looks out for the events
    and rules that will trigger a transition to another state. A game entity can only
    be in exactly one state at any given time.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限状态机（FSM**）可以被认为是 simplest 的AI模型之一，并且它们在游戏中被广泛使用。状态机基本上由一组通过它们之间的转换连接在一起的状态组成。游戏实体从一个初始状态开始，然后寻找将触发转换到另一个状态的事件和规则。游戏实体在任何给定时间只能处于确切的一个状态。'
- en: 'For example, let''s take a look at an AI guard character in a typical shooting
    game. Its states could be as simple as patrolling, chasing, and shooting:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看一个典型射击游戏中的AI守卫角色。其状态可能非常简单，如巡逻、追逐和射击：
- en: '![](img/5bfeb73e-bc56-44c1-a102-148c5aef66bb.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bfeb73e-bc56-44c1-a102-148c5aef66bb.png)'
- en: 'There are basically four components in a simple FSM:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的FSM中基本上有四个组件：
- en: '**States**: This component defines a set of distinct states that a game entity
    or an NPC can choose from (patrol, chase, and shoot)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：此组件定义了一组游戏实体或NPC可以选择的不同状态（巡逻、追逐和射击）'
- en: '**Transitions**: This component defines relations between different states'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：此组件定义了不同状态之间的关系'
- en: '**Rules**: This component is used to trigger a state transition (player on
    sight, close enough to attack, and lost/killed player)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则**：此组件用于触发状态转换（玩家被发现、足够近可以攻击，以及失去/被杀的玩家）'
- en: '**Events**: This is the component that will trigger to check the rules (guard''s
    visible area, distance to the player, and so on)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：这是触发以检查规则（守卫的可见区域、与玩家的距离等）的组件'
- en: FSMs are commonly used go-to AI patterns in game development because they are
    relatively easy to implement, visualize, and understand. Using simple if/else
    statements or switch statements, we can easily implement an FSM. It can get messy
    as we start to have more states and more transitions. We'll look at how to manage
    a simple FSM more in depth in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml),
    *Finite State Machines and You*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机（FSMs）在游戏开发中是常用的AI模式，因为它们相对容易实现、可视化和理解。我们可以通过简单的if/else语句或switch语句轻松实现一个状态机。当我们开始有更多状态和更多转换时，事情可能会变得混乱。我们将在[第2章](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)，《有限状态机与您》中更深入地探讨如何管理一个简单的状态机。
- en: Seeing the world through our agent's eyes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过我们的代理的眼睛看世界
- en: 'In order to make our AI convincing, our agent needs to be able to respond to
    the events around him, the environment, the player, and even other agents. Much
    like real living organisms, our agent can rely on sight, sound, and other "physical"
    stimuli. However, we have the advantage of being able to access much more data
    within our game than a real organism can from their surroundings, such as the
    player''s location, regardless of whether or not they are in the vicinity, their
    inventory, the location of items around the world, and any variable you chose
    to expose to that agent in your code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的AI更具说服力，我们的代理需要能够对他周围的事件、环境、玩家，甚至其他代理做出反应。就像真实的生物体一样，我们的代理可以依靠视觉、声音和其他“物理”刺激。然而，我们有优势，能够访问比真实生物从其周围环境获得的数据多得多的数据，例如玩家的位置，无论他们是否在附近，他们的库存，世界上物品的位置，以及你在代码中选择的任何变量，你可以将其暴露给该代理：
- en: '![](img/141f8610-5667-4b83-8533-82ad81d9b0a5.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/141f8610-5667-4b83-8533-82ad81d9b0a5.png)'
- en: 'In the preceding diagram, our agent''s field of vision is represented by the
    cone in front of it, and its hearing range is represented by the grey circle surrounding
    it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们代理的视野由其前面的锥形表示，其听觉范围由围绕它的灰色圆圈表示：
- en: Vision, sound, and other senses can be thought of, at their most essential level,
    as data. Vision is just light particles, sound is just vibrations, and so on.
    While we don't need to replicate the complexity of a constant stream of light
    particles bouncing around and entering our agent's eyes, we can still model the
    data in a way that produces believable results.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉、声音和其他感官在最基本层面上可以被视为数据。视觉只是光粒子，声音只是振动，等等。虽然我们不需要复制光粒子不断弹跳并进入我们代理眼睛的复杂性，但我们仍然可以以产生可信结果的方式对数据进行建模。
- en: As you might imagine, we can similarly model other sensory systems, and not
    just the ones used for biological beings such as sight, sound, or smell, but even
    digital and mechanical systems that can be used by enemy robots or towers, for
    example sonar and radar.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，我们可以以类似的方式模拟其他感官系统，而不仅仅是用于生物体（如视觉、声音或嗅觉）的系统，甚至可以用于敌人机器人或塔等数字和机械系统，例如声纳和雷达。
- en: If you've ever played *Metal Gear Solid, *then you've definitely seen these
    concepts in action—an enemy's field of vision is denoted on the player's mini
    map as cone-shaped fields of view. Enter the cone and an exclamation mark appears
    over the enemy's head, followed by an unmistakable chime, letting the player know
    that they've been spotted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过 *Metal Gear Solid*，那么你肯定在游戏中见过这些概念的实际应用——敌人的视野在玩家的迷你地图上以锥形视野表示。进入锥形视野，敌人的头上会出现一个感叹号，随后是一个清晰的铃声，让玩家知道他们已经被发现了。
- en: Path following and steering
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟随路径和转向
- en: Sometimes, we want our AI characters to roam around in the game world, following
    a roughly-guided or thoroughly-defined path. For example, in a racing game, the
    AI opponents need to navigate the road. In an RTS game, your units need to be
    able to get from wherever they are to the location you tell them navigating through
    the terrain and around each other.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望我们的AI角色在游戏世界中四处游荡，遵循大致引导或详细定义的路径。例如，在赛车游戏中，AI对手需要导航道路。在RTS游戏中，你的单位需要能够从他们所在的位置到达你告诉他们的位置，通过地形和彼此周围导航。
- en: To appear intelligent, our agents need to be able to determine where they are
    going, and if they can reach that point, they should be able to route the most
    efficient path and modify that path if an obstacle appears as they navigate. As
    you'll learn in later chapters, even path following and steering can be represented
    via a finite state machine. You will then see how these systems begin to tie in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显得聪明，我们的智能体需要能够确定它们要去哪里，如果它们能够到达那个点，它们应该能够规划出最有效的路径，并在导航过程中如果出现障碍物时修改该路径。正如你将在后面的章节中了解到的那样，即使是路径跟随和转向也可以通过有限状态机来表示。你将看到这些系统是如何开始相互关联的。
- en: In this book, we will cover the primary methods of pathfinding and navigation,
    starting with our own implementation of an **A* Pathfinding System**, followed
    by an overview of Unity's built-in **Navigation Mesh** (**NavMesh**) feature.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将介绍路径查找和导航的基本方法，从我们自己的**A*路径查找系统**实现开始，接着概述Unity内置的**导航网格**（**NavMesh**）功能。
- en: Dijkstra's algorithm
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dijkstra的算法
- en: While perhaps not quite as popular as A* Pathfinding (which we will cover next),
    it's crucial to understand Dijkstra's algorithm, as it lays the foundation for
    other similar approaches to finding the shortest path between two nodes in a graph.
    The algorithm was published by *Edsger W. Dijkstra* in 1959\. Dijkstra was a computer
    scientist, and though he may be best known for his namesake algorithm, he also
    had a hand in developing other important computing concepts, such as the semaphore*. *It
    might be fair to say Dijkstra probably didn't have *StarCraft* in mind when developing
    his algorithm, but the concepts translate beautifully to game AI programming and
    remain relevant to this day.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能没有A*路径查找（我们将在下一章介绍）那么流行，但理解Dijkstra算法至关重要，因为它为在图中找到两个节点之间最短路径的其他类似方法奠定了基础。该算法由*Edsger
    W. Dijkstra*于1959年发表。Dijkstra是一位计算机科学家，尽管他可能最出名的是以其名字命名的算法，但他也参与了其他重要计算概念的开发，例如**信号量**。*可以说，Dijkstra在开发他的算法时可能并没有考虑到*StarCraft*，但这些概念在游戏人工智能编程中得到了完美的应用，并且至今仍然相关。
- en: So what does the algorithm actually *do?* In a nutshell, it computes the shortest
    path between two nodes along a graph by assigning a value to each connected node
    based on distance. The starting node is given a value of zero. As the algorithm
    traverses through a list of connected nodes that have not been visited, it calculates
    the distance to it and assigns the value to that node. If the node had already
    been assigned a value in a prior iteration of the loop, it keeps the smallest
    value. The algorithm then selects the connected node with the smallest distance
    value, and marks the previously selected node as *visited*, so it will no longer
    be considered. The process repeats until all nodes have been visited. With this
    information, you can then calculate the shortest path.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个算法实际上**做什么**？简而言之，它通过给每个连接节点分配基于距离的值来计算图中两个节点之间的最短路径。起始节点被赋予零值。当算法遍历一个尚未访问的连接节点列表时，它会计算到该节点的距离并分配给该节点一个值。如果节点在循环的前一个迭代中已经被分配了值，它将保持最小的值。然后算法选择具有最小距离值的连接节点，并将之前选择的节点标记为*已访问*，因此它将不再被考虑。这个过程会重复，直到所有节点都被访问。有了这些信息，你就可以计算出最短路径。
- en: Need help wrapping your head around Dijkstra's algorithm? The University of
    San Francisco has created a handy visualization tool:  ;[https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html.](https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 需要帮助理解Dijkstra算法？旧金山大学创建了一个方便的可视化工具：[Dijkstra算法可视化](https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html)。
- en: While Dijkstra's algorithm is perfectly capable, variants of it have been developed
    that can solve the problem more efficiently. A* is one such algorithm, and it's
    one of the most widely used pathfinding algorithms in games, due to its speed
    advantage over Dijkstra's original version.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Dijkstra 算法已经非常完美，但其变体已被开发出来，可以更有效地解决问题。A*就是其中之一，由于它在速度上优于Dijkstra原始版本，因此它是游戏中应用最广泛的路径查找算法之一。
- en: Using A* Pathfinding
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用A*路径查找
- en: 'There are many games in which you can find monsters or enemies that follow
    the player, or go to a particular point while avoiding obstacles. For example,
    let''s take a typical RTS game. You can select a group of units and click on a
    location you want them to move to, or click on the enemy units to attack them.
    Your units then need to find a way to reach the goal without colliding with the
    obstacles or avoid them as intelligently as possible. The enemy units also need
    to be able to do the same. Obstacles could be different for different units, terrain,
    or other in-game entities. For example, an air force unit might be able to pass
    over a mountain, while the ground or artillery units need to find a way around
    it. A* (pronounced "A star") is a pathfinding algorithm that is widely used in
    games because of its performance and accuracy. Let''s take a look at an example
    to see how it works. Let''s say we want our unit to move from point A to point
    B, but there''s a wall in the way and it can''t go straight towards the target.
    So, it needs to find a way to get to point B while avoiding the wall. The following
    figure illustrates this scenario:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏中，你可以找到跟随玩家或避开障碍物到达特定点的怪物或敌人。例如，让我们以一个典型的实时战略（RTS）游戏为例。你可以选择一组单位并点击你希望它们移动到的位置，或者点击敌方单位进行攻击。然后，你的单位需要找到一种方法到达目标，同时不与障碍物碰撞或尽可能智能地避开它们。敌方单位也需要能够做到这一点。障碍物可能因单位、地形或其他游戏实体而异。例如，空军单位可能能够飞越山脉，而地面或炮兵单位则需要找到绕过它的方法。A*（发音为“A
    star”）是一种路径查找算法，由于它的性能和准确性，在游戏中被广泛使用。让我们通过一个例子来看看它是如何工作的。假设我们希望我们的单位从点A移动到点B，但中间有一堵墙阻挡，它不能直接朝向目标前进。因此，它需要找到一种方法到达点B，同时避开墙壁。以下图示说明了这一场景：
- en: '![](img/0a0debb6-1ffb-4e23-b3d2-f40afb0fd851.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a0debb6-1ffb-4e23-b3d2-f40afb0fd851.png)'
- en: 'In order to find the path from point A to point B, we need to know more about
    the map, such as the position of the obstacles. To do this, we can split our whole
    map into small tiles, representing the whole map in a grid format. The tiles can
    also be other shapes such as hexagons and triangles. Representing the whole map
    in a grid makes the search area more simplified, and this is an important step
    in pathfinding. We can now reference our map in a small 2D array:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到从点A到点B的路径，我们需要更多地了解地图，例如障碍物的位置。为此，我们可以将整个地图分成小块瓦片，以网格格式表示整个地图。瓦片也可以是其他形状，如六边形和三角形。以网格形式表示整个地图使搜索区域更加简化，这是路径查找的重要步骤。现在我们可以参考一个小的2D数组来表示我们的地图：
- en: '![](img/e796b480-d9e4-41f5-ba7c-2e5bd14b4092.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e796b480-d9e4-41f5-ba7c-2e5bd14b4092.png)'
- en: 'Once our map is represented by a set of tiles, we can start searching for the
    best path to reach the target by calculating the movement score of each tile adjacent
    to the starting tile, which is a tile on the map not occupied by an obstacle,
    and then choosing the tile with the lowest cost. We''ll dive into the specifics
    of how we assign scores and traverse the grid in [Chapter 3](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*, but this is the concept of A* Pathfinding in a nutshell:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的地图被一组瓦片表示，我们就可以开始通过计算起始瓦片相邻的每个瓦片的移动得分来寻找到达目标的最佳路径，这个瓦片是地图上没有被障碍物占据的瓦片，然后选择成本最低的瓦片。我们将在[第3章](503803fe-f343-4a0c-835f-463c98005182.xhtml)“寻找路径”中深入探讨我们如何分配得分和遍历网格的具体方法，但简而言之，这是A*路径查找的概念：
- en: '![](img/9a130cc6-048c-47ff-bf90-cf6af1334bd2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a130cc6-048c-47ff-bf90-cf6af1334bd2.png)'
- en: A* Pathfinding calculates the cost to move across the tiles
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: A*路径查找计算穿越瓦片的成本
- en: A* is an important pattern to know when it comes to pathfinding, but Unity also
    gives us a couple of features right out of the box, such as automatic Navigation
    Mesh generation and the NavMesh agent, which we'll explore in the next section
    and then in more detail in [Chapter 3](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*. These features make implementing pathfinding in your games
    a walk in the park (no pun intended). Whether you choose to implement your own
    A* solution or simply go with Unity's built-in NavMesh feature will depend on
    your project's needs. Each option has its own pros and cons, but ultimately, knowing
    about both will allow you to make the best possible choice. With that said, let's
    have a quick look at NavMesh.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: A* 是在寻路时需要了解的重要模式，但 Unity 也为我们提供了一些开箱即用的功能，例如自动导航网格生成和 NavMesh 代理，我们将在下一节中探讨这些功能，并在第
    3 章 [Finding Your Way](503803fe-f343-4a0c-835f-463c98005182.xhtml) 中更详细地介绍。这些功能使得在游戏中实现寻路变得非常容易（无意中用了双关语）。无论你选择实现自己的
    A* 解决方案还是简单地使用 Unity 内置的 NavMesh 功能，都将取决于你的项目需求。每个选项都有其优缺点，但最终，了解两者将使你能够做出最佳选择。话虽如此，让我们快速了解一下
    NavMesh。
- en: IDA* Pathfinding
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA* 寻路
- en: IDA* star stands for iterative deepening A*. It is a depth-first permutation
    of A* with a lower overall memory cost, but is generally considered costlier in
    terms of time. Whereas A* keeps multiple nodes in memory at a time, IDA* does
    not since it is a depth-first search. For this reason, IDA* may visit the same
    node multiple times, leading to a higher time cost. Either solution will give
    you the shortest path between two nodes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: IDA* 星号代表迭代加深 A*。它是对 A* 的深度优先排列，具有更低的总体内存成本，但通常在时间成本上更高。A* 在同一时间保持多个节点在内存中，而
    IDA* 由于是深度优先搜索，所以不会这样做。因此，IDA* 可能会多次访问相同的节点，导致更高的时间成本。任何一种解决方案都会给出两个节点之间的最短路径。
- en: In instances where the graph is too big for A* in terms of memory, IDA* is preferable,
    but it is generally accepted that A* is *good enough* for most use cases in games.
    That said, we'll explore both solutions in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*, so you can arrive at your own conclusion and pick the right
    pathfinding algorithm for your game.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在图太大以至于 A* 在内存方面不可行的情况下，IDA* 是首选，但普遍认为 A* 对于游戏中的大多数用例来说已经足够好了。话虽如此，我们将在第 4 章
    [Finding Your Way](503803fe-f343-4a0c-835f-463c98005182.xhtml) 中探讨这两种解决方案，这样你可以得出自己的结论，并为你的游戏选择正确的寻路算法。
- en: Using Navigation Mesh
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导航网格
- en: 'Now that we''ve taken a brief look at A*, let''s look at some possible scenarios
    where we might find NavMesh a fitting approach to calculate the grid. One thing
    that you might notice is that using a simple grid in A* requires quite a number
    of computations to get a path that is the shortest to the target and, at the same
    time, avoids the obstacles. So, to make it cheaper and easier for AI characters
    to find a path, people came up with the idea of using waypoints as a guide to
    move AI characters from the start point to the target point. Let''s say we want
    to move our AI character from point A to point B and we''ve set up three waypoints,
    as shown in the following figure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要地了解了 A*，让我们看看一些可能的情况，在这些情况下，我们可能会发现 NavMesh 是计算网格的一个合适的方法。你可能注意到，在 A*
    中使用简单的网格需要相当多的计算来获得到目标点的最短路径，同时避免障碍物。因此，为了使它更便宜、更容易，AI 角色能够找到路径，人们提出了使用路标点作为指南，将
    AI 角色从起点移动到目标点的想法。假设我们想将我们的 AI 角色从点 A 移动到点 B，并且我们已经设置了三个路标点，如图所示：
- en: '![](img/869a46f4-afd6-47c9-9267-8655110cc5b4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/869a46f4-afd6-47c9-9267-8655110cc5b4.png)'
- en: 'All we have to do now is to pick up the nearest waypoint and then follow its
    connected node leading to the target waypoint. Most games use waypoints for pathfinding
    because they are simple and quite effective in terms of using less computation
    resources. However, they do have some issues. What if we want to update the obstacles
    in our map? We''ll also have to place waypoints for the updated map again, as
    shown in the following figure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要选择最近的路标点，然后跟随其连接的节点到达目标路标点。大多数游戏使用路标点进行寻路，因为它们简单且在减少计算资源方面相当有效。然而，它们确实存在一些问题。如果我们想更新地图中的障碍物怎么办？我们还需要为更新后的地图再次放置路标点，如图所示：
- en: '![](img/0936b209-9f71-4a49-98d1-ba49f7613bc1.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0936b209-9f71-4a49-98d1-ba49f7613bc1.png)'
- en: Having to manually alter waypoints every time the layout of your level changes
    can be cumbersome and very time-consuming. In addition, following each node to
    the target can mean that the AI character moves in a series of straight lines
    from node to node. Look at the preceding figures; it's quite likely that the AI
    character will collide with the wall where the path is close to the wall. If that
    happens, our AI will keep trying to go through the wall to reach the next target,
    but it won't be able to and will get stuck there. Even though we can smooth out
    the path by transforming it to a spline and doing some adjustments to avoid such
    obstacles, the problem is that the waypoints don't give us any information about
    the environment, other than the spline being connected between the two nodes.
    What if our smoothed and adjusted path passes the edge of a cliff or bridge? The
    new path might not be a safe path anymore. So, for our AI entities to be able
    to effectively traverse the whole level, we're going to need a tremendous number
    of waypoints, which will be really hard to implement and manage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你的关卡布局发生变化时，必须手动更改航点可能会很麻烦，并且非常耗时。此外，跟随每个节点到目标意味着AI角色会从节点到节点移动一系列的直线。看看前面的图；AI角色很可能会在路径靠近墙壁的地方撞到墙上。如果发生这种情况，我们的AI会不断尝试穿过墙壁以到达下一个目标，但它无法做到，并且会卡在那里。尽管我们可以通过将其转换为样条曲线并进行一些调整来平滑路径，以避免此类障碍，但问题在于航点没有给我们提供任何关于环境的信息，除了样条曲线在两个节点之间连接。如果我们的平滑和调整后的路径通过了悬崖或桥梁的边缘呢？新的路径可能不再是安全的路径。因此，为了使我们的AI实体能够有效地穿越整个关卡，我们需要大量的航点，这将非常难以实现和管理。
- en: 'This is a situation where a NavMesh makes the most sense. NavMesh is another
    graph structure that can be used to represent our world, similar to the way we
    did with our square tile-based grid or waypoints graph, as shown in the following
    diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个NavMesh最有意义的场景。NavMesh是一种可以用来表示我们世界的另一种图结构，类似于我们用正方形瓦片网格或航点图所做的方式，如下面的图所示：
- en: '![](img/f7f4adb3-28f7-49e3-a64b-8f0368e2bb1a.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7f4adb3-28f7-49e3-a64b-8f0368e2bb1a.png)'
- en: A Navigation Mesh uses convex polygons to represent the areas in the map that
    an AI entity can travel to. The most important benefit of using a Navigation Mesh
    is that it gives a lot more information about the environment than a waypoint
    system. Now we can adjust our path safely because we know the safe region in which
    our AI entities can travel. Another advantage of using a Navigation Mesh is that
    we can use the same mesh for different types of AI entities. Different AI entities
    can have different properties such as size, speed, and movement abilities. A set
    of waypoints is tailored for humans; AI may not work nicely for flying creatures
    or AI-controlled vehicles. These might need different sets of waypoints. Using
    a Navigation Mesh can save a lot of time in such cases.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格使用凸多边形来表示地图上AI实体可以到达的区域。使用导航网格最重要的好处是它比航点系统提供了更多关于环境的信息。现在我们可以安全地调整路径，因为我们知道我们的AI实体可以旅行的安全区域。使用导航网格的另一个优点是我们可以为不同类型的AI实体使用相同的网格。不同的AI实体可以有不同的属性，如大小、速度和移动能力。一组航点是为人类量身定制的；AI可能不适合飞行生物或AI控制的车辆。这些可能需要不同的航点集。在这种情况下，使用导航网格可以节省大量时间。
- en: Generating a Navigation Mesh programmatically based on a scene can be a somewhat
    complicated process. Fortunately, Unity 3.5 introduced a built-in Navigation Mesh
    generator as a pro-only feature, but is now included for free from the Unity 5
    personal edition onwards. Unity's implementation provides a lot of additional
    functionality out of the box. Not just the generation of the NavMesh itself, but
    agent collision and pathfinding on the generated graph (via A*, of course) as
    well. [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml), *Finding Your Way*,
    will look at some of the useful and interesting ways we can use Unity's NavMesh
    feature in our games, and will explore the additions and improvements that came
    with Unity 2017.1.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据场景程序生成导航网格可能是一个相对复杂的过程。幸运的是，Unity 3.5引入了一个内置的导航网格生成器作为专业版功能，但自Unity 5个人版开始，它现在是免费的。Unity的实现提供了一箱额外的功能。不仅包括生成NavMesh本身，还包括在生成的图上（当然是通过A*）进行代理碰撞和路径查找。第4章“找到你的路”，将探讨我们可以使用Unity的NavMesh功能的一些有用和有趣的方法，并探讨Unity
    2017.1带来的新增功能和改进。
- en: Flocking and crowd dynamics
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群体和人群动态
- en: In nature, we can observe what we refer to as flocking behavior in several species.
    Flocking simply refers to a group moving in unison. Schools of fish, flocks of
    sheep, and cicada swarms are fantastic examples of this behavior. Modeling this
    behavior using manual means, such as animation, can be very time-consuming and
    is not very dynamic. In [Chapter 5](22a4fafd-cfde-4766-85d5-82df3593d83b.xhtml), *Flocks
    and Crowds*, we'll explore a dynamic and programmatic approach to modeling this
    behavior in a believable way, using a simple set of rules that will drive the
    behavior of the group and each individual in a group relative to its surroundings.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然界中，我们可以观察到我们所说的群聚行为，这在几种物种中都可以观察到。群聚简单地说就是一群动物一起移动。鱼群、羊群和蝉群都是这种行为的绝佳例子。使用手动方式，如动画，来模拟这种行为可能会非常耗时，并且不够动态。在第5章“群聚与群体”中，我们将探讨一种动态和程序化的方法来以可信的方式模拟这种行为，使用一组简单的规则来驱动群体及其成员相对于其周围环境的行为。
- en: Similarly, crowds of humans, be it on foot or in vehicles, can be modeled by
    representing the entire crowd as an entity rather than trying to model each individual
    as its own agent. Each individual in the group only really needs to know where
    the group is heading and what their nearest neighbor is up to in order to function
    as part of the system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，无论是步行还是乘坐车辆的人类群体，都可以通过将整个群体表示为一个实体来建模，而不是试图将每个个体作为其自己的代理来建模。群体中的每个个体实际上只需要知道群体将前往何方以及他们的最近邻在做什么，以便作为系统的一部分发挥作用。
- en: Behavior trees
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树
- en: The behavior tree is another pattern used to represent and control the logic
    behind AI agents. Behavior trees have become popular for applications in AAA games
    such as *Halo* and *Spore*. Previously, we briefly covered FSMs. They provide
    a very simple yet efficient way to define the possible behaviors of an agent,
    based on the different states and transitions between them. However, FSMs are
    considered difficult to scale as they can get unwieldy fairly quickly and require
    a fair amount of manual setup. We need to add many states and hardwire many transitions
    in order to support all the scenarios we want our agent to consider. So, we need
    a more scalable approach when dealing with large problems. This is where behavior
    trees come in.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树是另一种用于表示和控制人工智能代理背后逻辑的模型。行为树在AAA游戏如*光环*和*孢子*等应用中变得非常流行。之前，我们简要介绍了有限状态机（FSM）。它们提供了一种非常简单但高效的方法来定义代理的可能行为，基于不同的状态及其之间的转换。然而，FSMs被认为难以扩展，因为它们可以很快变得难以控制，并且需要相当多的手动设置。我们需要添加许多状态并硬编码许多转换，以便支持我们希望代理考虑的所有场景。因此，当我们处理大型问题时，我们需要一个更可扩展的方法。这就是行为树发挥作用的地方。
- en: Behavior trees are a collection of nodes organized in a hierarchical order,
    in which nodes are connected to parents rather than states connected to each other,
    resembling branches on a tree, hence the name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树是一组按层次顺序组织的节点，其中节点连接到父节点，而不是状态相互连接，类似于树上的分支，因此得名。
- en: 'The basic elements of behavior trees are task nodes, whereas states are the
    main elements for FSMs. There are a few different tasks such as Sequence, Selector,
    and Parallel Decorator. It can be a bit daunting to track what they all do. The
    best way to understand this is to look at an example. Let''s break the following
    transitions and states down into tasks, as shown in the following figure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树的基本元素是任务节点，而状态是FSM的主要元素。有几个不同的任务，如序列（Sequence）、选择器（Selector）和平行装饰器（Parallel
    Decorator）。跟踪它们所有的作用可能会有些令人畏惧。理解这些的最佳方式是查看一个示例。让我们将以下转换和状态分解为任务，如图所示：
- en: '![](img/6fdfc1db-50f8-42f9-b391-e59bbddd18e5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fdfc1db-50f8-42f9-b391-e59bbddd18e5.jpg)'
- en: 'Let''s look at a Selector task for this behavior tree. Selector tasks are represented
    by a circle with a question mark inside. The selector will evaluate each child
    in order, from left to right. First, it''ll choose to attack the player; if the
    **Attack** task returns a success, the Selector task is done and will go back
    to the parent node, if there is one. If the **Attack** task fails, it''ll try
    the **Chase** task. If the **Chase** task fails, it''ll try the **Patrol** task.
    The following figure shows the basic structure of this tree concept:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个行为树中的一个选择器任务。选择器任务由一个带有问号的圆圈表示。选择器将按顺序评估每个子节点，从左到右。首先，它将选择攻击玩家；如果**攻击**任务返回成功，选择器任务就完成了，并将返回到父节点（如果有的话）。如果**攻击**任务失败，它将尝试**追逐**任务。如果**追逐**任务失败，它将尝试**巡逻**任务。以下图显示了此树概念的基本结构：
- en: '![](img/e06b978b-6bd4-4e8d-a7f0-116d5b468523.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e06b978b-6bd4-4e8d-a7f0-116d5b468523.png)'
- en: 'Test is one of the tasks in the behavior tree. The following diagram shows
    the use of Sequence tasks, denoted by a rectangle with an arrow inside it. The
    root selector may choose the first Sequence action. This Sequence action''s first
    task is to check whether the player character is close enough to attack. If this
    task succeeds, it''ll proceed with the next task, which is to attack the player.
    If the **Attack** task also returns successfully, the whole sequence will return
    as a success, and the selector will be done with this behavior and will not continue
    with other Sequence tasks. If the proximity check task fails, the Sequence action
    will not proceed to the **Attack** task, and will return a failed status to the
    parent selector task. Then the selector will choose the next task in the sequence,
    **Lost or Killed Player?** The following figure demonstrates this sequence:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是行为树中的任务之一。以下图表显示了序列任务的用法，用内部带有箭头的矩形表示。根选择器可以选择第一个序列动作。这个序列动作的第一个任务是检查玩家角色是否足够接近可以攻击。如果这个任务成功，它将继续执行下一个任务，即攻击玩家。如果**攻击**任务也成功返回，整个序列将返回成功，选择器将完成这个行为，并且不会继续执行其他序列任务。如果接近检查任务失败，序列动作将不会继续执行**攻击**任务，并将返回失败状态给父选择器任务。然后选择器将选择序列中的下一个任务，**玩家是否已失踪或死亡？**以下图表展示了这个序列：
- en: '![](img/acea0fee-0483-4312-ab24-0c48d1c7143e.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acea0fee-0483-4312-ab24-0c48d1c7143e.jpg)'
- en: The other two common components are parallel tasks and decorators. A parallel
    task will execute all of its child tasks at the same time, while the Sequence
    and Selector tasks only execute their child tasks one by one. Decorator is another
    type of task that has only one child. It can change the behavior of its own child's
    tasks including whether to run its child's task or not, how many times it should
    run, and so on. We'll study how to implement a basic behavior tree system in Unity
    in [Chapter 6](8db41b31-be4b-432f-a68e-ef13e1f7e03b.xhtml), *Behavior Trees*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个常见的组件是并行任务和装饰器。并行任务将同时执行其所有子任务，而序列和选择器任务则逐个执行其子任务。装饰器是另一种只有单个子任务的任务类型。它可以改变其子任务的行为，包括是否运行其子任务、应该运行多少次等。我们将在第6章中学习如何在Unity中实现基本的行为树系统，*行为树*。
- en: Thinking with fuzzy logic
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模糊逻辑思考
- en: Finally, we arrive at fuzzy logic. Put simply, fuzzy logic refers to approximating
    outcomes as opposed to arriving at binary conclusions. We can use fuzzy logic
    and reasoning to add yet another layer of authenticity to our AI.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了模糊逻辑。简单来说，模糊逻辑是指对结果进行近似，而不是得出二进制结论。我们可以使用模糊逻辑和推理为我们的AI增加另一层真实性。
- en: Let's use a generic bad guy soldier in a first person shooter as our agent to
    illustrate this basic concept. Whether we are using a finite state machine or
    a behavior tree, our agent needs to make decisions. Should I move to state x,
    y, or z? Will this task return true or false? Without fuzzy logic, we'd look at
    a binary value (true or false, or 0 or 1) to determine the answers to those questions.
    For example, can our soldier see the player? That's a yes/no binary condition.
    However, if we abstract the decision-making process even further, we can make
    our soldier behave in much more interesting ways. Once we've determined that our
    soldier can see the player, the soldier can then "ask" itself whether it has enough
    ammo to kill the player, or enough health to survive being shot at, or whether
    there are other allies around it to assist in taking the player down. Suddenly,
    our AI becomes much more interesting, unpredictable, and more believable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一款第一人称射击游戏中的通用坏蛋士兵作为我们的代理来阐述这个基本概念。无论我们使用有限状态机还是行为树，我们的代理都需要做出决策。我应该移动到状态x、y还是z？这个任务会返回真还是假？如果没有模糊逻辑，我们会查看二进制值（真或假，或0或1）来确定这些问题的答案。例如，我们的士兵能否看到玩家？这是一个是/否的二进制条件。然而，如果我们进一步抽象决策过程，我们可以让我们的士兵表现出更有趣的行为。一旦我们确定我们的士兵可以看到玩家，士兵就可以“询问”自己是否有足够的弹药杀死玩家，或者是否有足够的健康值来抵御射击，或者是否有其他盟友在其周围协助击倒玩家。突然间，我们的AI变得更加有趣、不可预测，并且更可信。
- en: This added layer of decision making is achieved by using fuzzy logic, which
    in the simplest terms, boils down to seemingly arbitrary or vague terminology
    that our wonderfully complex brains can easily assign meaning to, such as "hot"
    versus "warm" or "cool" versus "cold," converting this to a set of values that
    a computer can easily understand. In [Chapter 7](4dbbb008-faf0-41a9-87d5-391ac3af5781.xhtml),
    *Using Fuzzy Logic to Make Your AI Seem Alive*, we'll dive deeper into how you
    can use fuzzy logic in your game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层额外的决策是通过使用模糊逻辑实现的，从最简单的术语来说，它归结为看似任意或模糊的术语，我们复杂的大脑可以轻松地赋予其意义，例如“热”与“温暖”，“冷”与“凉爽”，将这些转化为计算机可以轻松理解的值集。在[第7章](4dbbb008-faf0-41a9-87d5-391ac3af5781.xhtml)，“使用模糊逻辑使您的AI看起来更有生命力”中，我们将更深入地探讨如何在游戏中使用模糊逻辑。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Game AI and academic AI have different objectives. Academic AI researchers try
    to solve real-world problems and prove a theory without much limitation in terms
    of resources. Game AI focuses on building NPCs within limited resources that seem
    to be intelligent to the player. The objective of AI in games is to provide a
    challenging opponent that makes the game more fun to play.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏人工智能和学术人工智能有不同的目标。学术人工智能研究人员试图解决现实世界的问题，并证明一个理论，在资源方面没有太多限制。游戏人工智能专注于在有限的资源内构建NPC，使其对玩家看起来很智能。游戏人工智能的目标是提供一个具有挑战性的对手，使游戏更具趣味性。
- en: We learned briefly about the different AI techniques that are widely used in
    games such as FSMs, sensor and input systems, flocking and crowd behaviors, path
    following and steering behaviors, AI path finding, Navigation Meshes, behavior
    trees, and fuzzy logic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地了解了在游戏中广泛使用的不同人工智能技术，例如有限状态机、传感器和输入系统、群体和人群行为、路径跟随和转向行为、人工智能路径查找、导航网格、行为树和模糊逻辑。
- en: In the following chapters, we'll look at fun and relevant ways you can apply
    these concepts to make your game more fun. We'll start off right away in [Chapter
    2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml), *Finite State Machines and You*,
    with our own implementation of an FSM, and we'll dive into the concepts of agents
    and states and how they are applied to games.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨一些有趣且相关的方法，帮助您将这些概念应用到游戏中，使游戏更加有趣。我们将从[第2章](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)，“有限状态机与您”，以及我们自己的有限状态机实现开始，深入探讨代理和状态的概念以及它们在游戏中的应用。
