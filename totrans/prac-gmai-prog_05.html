<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Animation Behaviors</h1>
                </header>
            
            <article>
                
<p>When we think about AI, usually we imagine smart robots, mechanical objects that perfectly perform a vast array of actions, and the same thought happens with video game AI. We tend to think about opponents or allies that act, react, think, or do a lot of things with smart decisions, and that's correct, but one more important aspect is usually left behind, the animations. In order to create believable and realistic AI characters, the animation is one of the most important aspects. Animations define the visual interaction, that is, what it looks like when the character is doing something. It's very important to have the animations working as well as the functional mechanics in order for the character to be believable. In this chapter, we'll be looking at some useful techniques and solutions to use, re-use, and create animations that smoothly fit the characters' behaviors. The way we create and use animations are the same for the player as for the AI characters, but we'll be focusing on how to integrate animations with the techniques that we have already learned about to create AI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">2D animation versus 3D animation</h1>
                </header>
            
            <article>
                
<p>Video game animation can be put into two genres, 2D and 3D animation. Both have distinct features, and we need to take that into consideration and use them to our advantage when developing a game. Let's take a look at some of the main differences between the two.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">2D animation - sprites</h1>
                </header>
            
            <article>
                
<p>As soon as consoles and computers allowed developers to integrate animation into the video games that they were making, games became much richer, relying on good-looking visuals to express the movement and actions of the characters. It also opened many doors to create new game genres or update older genres, making them more appealing, and since then, almost every game has started to implement animations.</p>
<p>The process of 2D animation used on video games is similar to what Disney use to use create their movies. They would draw and paint every frame of the movie, and every second would have around 12 frames. Games couldn't use real-life drawings at the time, but they could use coordinates to paint every bit of the game to make it look like a person or an animal if they wanted. The rest of the process is about the same. They needed to use that in order to create every frame of the animation, but because it was a hard and long process, they had a lot less detail and complexity. Now that they have all the frames needed to animate a character, it is necessary to program the machine to read the frames in a specific order, only using the ones that belong <span class="diff-chunk diff-chunk-equal">to the action that</span> <span class="diff-chunk diff-chunk-inserted">the character is doing.</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="274" width="305" class=" image-border" src="assets/dc4281f2-250e-460f-82d4-a5089e7580c7.png"/></div>
<p>In the preceding figure, we can see an example of the 8-bit era that shows every animation of the <em>Super Mario Bros</em> character called Mario. As we can see, there is the run animation, jump, swim, die, stop, and crouch, some of which are just a single frame. Smooth transitions didn't appear right away, and the animations were combined into the gameplay. So, if we wanted to include more animations in the game, it would be necessary to create more frames. The same goes for the complexity of the animation; if we wanted the animation to include more detail, it would be necessary to create more frames and transitional frames. This makes the process of creating animations very long, but with the evolution of hardware capabilities, this process has started to take less time to implement, and the results are famous.</p>
<p>One example of the 2D animation capabilities on video games is <em>Prince of Persia</em>, released in 1989 (the following sprite sheet shows the character's animations in <em>Prince of Persia</em>). By using real-world references of a person doing the movements of the game, the quality, detail, and smooth transitions were stupendous, raising the bar even higher for the next generation of games. So at this time, game developers started to worry about transitions, smooth animations, and how to create a lot of actions without it being necessary to add more frames to the sprite sheet:</p>
<div class="CDPAlignCenter CDPAlign"><img height="544" width="213" class=" image-border" src="assets/f6095ca7-4462-49e7-8103-41047405e0fd.png"/></div>
<p>Today, we still use the same process on 2D games, we have a sprite sheet with all the animations that we want, then we code to animate them at the same time the character is performing an action. Working with sprite sheets is not as flexible as working with 3D animations that use bone structures, but there are some useful tips that we can use to create smooth transitions and separate the code animation from the gameplay code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">3D animation - bone structure</h1>
                </header>
            
            <article>
                
<p>Using 3D models and 3D animations to create games is a very popular choice at the moment, and one of the main reasons is related to the time that it takes to create them. We only need to create the 3D model once, and then we can implement a bone structure to animate it as we want. We can also use the same bone structure and skin it to another 3D model and it will get the same animations as the previous one. Using 3D animations is obviously convenient for larger projects, saving hours of hard work and allowing us to update the character without the need to create it all over again. This is due to the bone structure of the character, which helps us improve the quality of the animations, saving time and resources. Because of this, we can decide to animate just one specific area and leave the rest of the body completely still or doing some other animation. It is very useful to smoothly change from one animation to another, or to have two animations playing at the same time:</p>
<div class="CDPAlignCenter CDPAlign"><img height="293" width="599" class=" image-border" src="assets/7a321cc7-92a4-41ae-9b8a-e7d9eaaa4320.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main differences</h1>
                </header>
            
            <article>
                
<p>Sprite sheets versus bones structure are the two main differences between the two types of animation that will change the way we integrate the animations with the gameplay. Using sprites, we stick to how many images we have available and we cannot change the way they look in the code, whereas with the bone structure, we can define which portion of the character we want to animate and we can use physics to shape the animation according to the situation.</p>
<p>Recently, there are some new options that allow us to implement a similar technique as bone structure in the 2D models, but it's still a very limited option compared to what we can do in 3D.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Animation state machines</h1>
                </header>
            
            <article>
                
<p>We have already talked about behavior states, where we define the possible actions of a character and how to link them. Animation state machines is a very similar process, but instead of defining the actions, we define the animations of a character. While developing the character and creating the behavior states, we could assign the animations in the action code, defining at which point the character starts to run, and once that happens, the walk animation stops and the run animation starts playing. This way of integrating the animations with the gameplay code looks like an easier approach to do it, but it's not the best way and it gets complicated if we want to update the code later on.</p>
<p>The solution to this problem is to create a separate state machine just for the animations. This will allow us to have better control of the animations without worrying about changing our character's code. It is a good method to use between programmer and animator as well, because the animator can add more animations to the animation state machine without interfering with the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="165" width="282" class=" image-border" src="assets/a9638f99-2309-4e98-bad8-a1c9ff4ce29f.jpg"/></div>
<p>In the preceding diagram, we can see a simple example of a behavior state machine, where the character can stay still, move, jump, and use a ladder. Once we have this part completed, we can start designing and implementing an animation state machine to work according to the behavior state machine principles:</p>
<div class="CDPAlignCenter CDPAlign"><img height="255" width="436" class=" image-border" src="assets/a12f1f19-bb2c-43f8-943f-649a360ac069.jpg"/></div>
<p>As we can see, there are more animation states than behavior states, which is why the best method to integrate the animations into our characters is to separate the gameplay from the animation. When developing our game, we use statements and values, so the only difference between walk and run is the number that defines how fast our character is moving. That is why we need to use the animation states to convert this information into visual output, where the character is animated according to the gameplay states. Using this method does not necessarily mean that we cannot use the animations to interfere with the gameplay, because we can also do it by simply reporting that information back to our gameplay code and changing the gameplay if we want to.</p>
<p>This can be used both for 2D and 3D animations. The process is exactly the same, and can be used with the most popular game engines, such as CryENGINE, Unity, and Unreal Development Kit. To make it work, we need to import all of the animations into our game and then we assign the animations into the animation state section:</p>
<div class="CDPAlignCenter CDPAlign"><img height="524" width="809" class=" image-border" src="assets/a4708052-d88d-4e33-8342-3d70f5cadff6.jpg"/></div>
<p>Now that, we have imported the animations into the animation state section, we need to configure when the animations will be played according to the values that we used in our code. The values or statements that we can use are integers, floats, Booleans, and triggers. With these, we can define when each animation will be played. When linking the animations, we'll be using the values to determine when to change from one animation state to another:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="334" width="663" class=" image-border" src="assets/6e067c49-a586-4e77-9c1a-438724a447e9.png"/></div>
<p>This is where we define the difference between walking and running. If the movement speed of our character reaches a certain value, it will start playing the run animation, and once that value decreases it will play the walk animation again.</p>
<p>We can have as many animations states as we want, regardless of the gameplay states. Let's take a look at the locomotion example. We can define that if the character is moving really slowly, it would animate like he is sneaking; a little bit faster and it starts walking; even faster and the characters starts running; and ultimately, if the movement speed is really high, he can grow a pair of wings to give the impression that he is flying. As we can see, it is more convenient to separate the animations from the gameplay, because that way we can change the animations, remove them, or add new ones, without modifying our code.</p>
<p>Now let's move on to the example. Using all the topics that we have explored in the previous chapters, we'll configure our character to animate according to the gameplay behavior and the environment. We start by importing the model and all the animations into our game. Then we create a new animation state machine; in this case it's called <strong>animator</strong>. After that, we just need to assign that animation state machine to our character:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="323" width="573" class=" image-border" src="assets/26ed83f9-a35d-4aad-8b06-18ce0af9f883.png"/></div>
<p><span>The model that we import into the game ideally should be in a neutral pose, such as the T-pose (demonstrated on the preceding screenshot). Then we import the animations and add them into the <span class="packt_screen">Animator Controller</span>.</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="433" width="360" class=" image-border" src="assets/81f8c5dd-647c-4b2c-bf5a-9f521dd988cf.jpg"/></div>
<p>Now, if we click on the <span class="packt_screen">character</span> and open the animation state machine that we created, it will be empty. That is normal, because we need to manually add the animations that we want to use:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="480" width="662" class=" image-border" src="assets/709a2da2-427f-470a-9436-e99365bd914f.png"/></div>
<p>Once we have done this, we'll need to organize everything to make it easy to link the animations:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="570" width="830" class=" image-border" src="assets/a6942f34-594c-4492-89e3-2a88042a3bc4.png"/></div>
<p>So, we have separated the different animations taking in consideration gameplay states such as <strong>IDLE</strong>, <strong>ATTACK</strong>, <strong>JUMP</strong>, <strong>LOCOMOTION</strong>, and <strong>DAMAGE</strong>, as shown in preceding diagram. We have two distinct animations for the <strong>IDLE</strong> state and another two for <strong>ATTACK</strong>. We want them to play in a random order, and separate from the gameplay code, so we can add as many animations we want there to add more diversity. Inside of the locomotion state, we have two separate groups, walking <strong>STRAIGHT</strong> and <strong>CROUCH</strong>. We have chosen to include both groups in the locomotion state because they will animate according to the position of the movement joystick.</p>
<p>Now, we can start linking the animations, and at this point we can forget about how the animations will be activated and focus only on the play order:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="544" width="792" class=" image-border" src="assets/3a7c0757-d99f-4811-9e41-0f3e7f230ee3.png"/></div>
<p>Once we have all the animations linked in the desired order, we can start defining how they will be played. At this point, we need to take a look at the character code and use the variables to change the animations. In our code, we have variables that accesses the animation state machine. In this case, they are the <kbd>Animator</kbd>, <kbd>Health</kbd> and <kbd>Stamina</kbd> integer values, <kbd>movementSpeed</kbd>, <kbd>rotationSpeed</kbd>, <kbd>maxSpeed</kbd>, <kbd>jumpHeight</kbd>, <kbd>jumpSpeed</kbd> and <kbd>currentSpeed</kbd> as float values, and finally a Boolean variable to check whether the player is alive:</p>
<pre>     public Animator characterAnimator;<br/>     public int Health;<br/>     public int Stamina;<br/>     public float movementSpeed;<br/>     public float rotationSpeed;<br/>     public float maxSpeed;<br/>     public float jumpHeight;<br/>     public float jumpSpeed;<br/><br/>     private float currentSpeed;<br/>     private bool Dead;<br/><br/>     void Start () {<br/><br/>     }<br/><br/>     void Update () {<br/><br/>         // USING XBOX CONTROLLER<br/>         transform.Rotate(0,Time.deltaTime * (rotationSpeed *<br/>         Input.GetAxis ("xboxlefth")), 0);<br/><br/>         if(Input.GetAxis ("xboxleft") &gt; 0){<br/>             transform.position += transform.forward * Time.deltaTime *<br/>             currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis<br/>             ("xboxleft") * movementSpeed);<br/>         }<br/><br/>         else{<br/>             transform.position += transform.forward * Time.deltaTime *<br/>             currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis<br/>             ("xboxleft") * movementSpeed/3);<br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Health &lt;= 0){<br/>             Dead = true;<br/>         }<br/>     } </pre>
<p>Let's start passing these values into the animation state machine. The movement and the <kbd>currentSpeed</kbd> value of the character are controlled by the left analog joystick, so if we push the joystick just a little bit, the character should play the walk animation. If we push it all the way it should play the run animation.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="92" width="348" class=" image-border" src="assets/6bb4d0fe-d1bb-4a3d-a98d-2280d370d7bb.png"/></div>
<p>In the <kbd>Animator</kbd> section, we can choose between four parameters, and for the locomotion of the character we have chosen <span class="packt_screen">Float</span>. We now need to link this value with the <kbd>currentSpeed</kbd> variable that we have in our code. We will assign this at the beginning of the <kbd>Update</kbd> function:</p>
<pre>     public Animator characterAnimator;<br/>     public int Health;<br/>     public int Stamina;<br/>     public float movementSpeed;<br/>     public float rotationSpeed;<br/>     public float maxSpeed;<br/>     public float jumpHeight;<br/>     public float jumpSpeed;<br/><br/>     private float currentSpeed;<br/>     private bool Dead;<br/><br/>     void Start () {<br/><br/>     }<br/><br/>     void Update () {<br/><br/>         // Sets the movement speed of the animator, to change from <br/>        idle to walk and walk to run<br/>         characterAnimator.SetFloat("currentSpeed",currentSpeed);<br/><br/>         // USING XBOX CONTROLLER<br/>         transform.Rotate(0,Time.deltaTime * (rotationSpeed *<br/>         Input.GetAxis ("xboxlefth")), 0);<br/><br/>         if(Input.GetAxis ("xboxleft") &gt; 0){<br/>             transform.position += transform.forward * Time.deltaTime *<br/>             currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis<br/>             ("xboxleft") * movementSpeed);<br/>         }<br/><br/>         else{<br/>             transform.position += transform.forward * Time.deltaTime *<br/>             currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis<br/>             ("xboxleft") * movementSpeed/3);<br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Health &lt;= 0){<br/>             Dead = true;<br/>         }<br/>     } </pre>
<p class="packt_figure">We've already connected the two parameters. This way, the animation state machine can use the same value of the <kbd>currentSpeed</kbd> found in the code. We gave it exactly the same name in the <kbd>Animator</kbd> section that we have in the code. It's not necessary, but it makes it easier to understand which values they represent.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/5945cefe-5158-4784-941a-4c55f7860aa7.png"/></div>
<p>So at this point, we can start defining the values of the links that connect the locomotion animations of the character. In this case, we can click on the link and a new window will open so we can add the values that will change the animations from one state to another:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="523" width="291" class=" image-border" src="assets/aa9cf293-f4c1-403d-8fda-122949bba915.png"/></div>
<p>We can also click on the animation that we want to configure, such as the IDLE animation, and then a new window opens with all the animations connected to this one. We can select the link that we want to allow the next animation to play. This is demonstrated in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="602" width="282" class=" image-border" src="assets/d2ecbeab-b937-432f-9252-67166d777375.png"/></div>
<p>We have clicked on <span><span class="packt_screen">idle</span></span> to <span class="packt_screen">walk</span> and added the condition that we previously created, <span class="packt_screen">currentSpeed</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="245" width="335" class=" image-border" src="assets/f3e5ba32-2566-41cc-8420-8b06b3e71d27.png"/></div>
<p>Here, we can choose if the value needs to be <span class="packt_screen">Greater</span> or <span class="packt_screen">Less</span> than the desired value that will start playing the next animation. For this example, we have set the value to be greater than <span class="packt_screen">0.1</span>, so as soon as the character starts moving, it will stop the IDLE animation and play the WALK animation. We don't need to write anything inside the code because the animation state machine acts independently to the code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="256" width="367" class=" image-border" src="assets/59b0b0bb-806c-496d-8d25-7570894e4c5b.png"/></div>
<p>However, because we have another animation playing after the WALK animation, we need to set a limit value for the WALK animation. In this case, let's assume that our character starts running when the <kbd>currentSpeed</kbd> is at <span class="packt_screen">5</span>; this means that our character stops walking at <span class="packt_screen">4.9</span>. So, we are going to add another condition here that tells to our character that he stops walking once his <kbd>currentSpeed</kbd> reaches <span class="packt_screen">4.9</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="263" width="414" class=" image-border" src="assets/7a31ce54-7bdc-4e3b-9a08-f119fb075541.png"/></div>
<p>Now that we have defined when the character starts walking, we also need to do the inverse, to define when it's time to stop walking and play the IDLE animation. We need to remember that this does not affect the gameplay, so it means that if we start the game at this point, the character will start playing the WALK animation because we have already set that to happen. But even if we hadn't, the character would move in the environment even without the animation. We are simply using the values that are stored in our code to connect with the animation states, and we need to define what animation will be played at a certain value. If we forget to set that value to all animations, the character will still perform the behavior, but without the correct animation. So with that said, we need to check if all the links have conditions assigned to them.</p>
<p>Now to make the character go back to the IDLE animation once he stops moving, we click on the link that goes from the WALK to IDLE, and we add a new condition that expresses if the currentSpeed is Less than 0.1, he stops playing the WALK animation and starts playing the IDLE animation:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="193" width="340" class=" image-border" src="assets/b616d689-ac68-4d6b-8d6b-a95a5045fca4.png"/></div>
<p>Now we can do this for the rest of the animations that use the <kbd>currentSpeed</kbd> value and finish the <kbd>Locomotion</kbd> states. Once we have all of that ready, we can move on to the <span class="packt_screen">Crouch</span> animations. They use the <span class="packt_screen">currentSpeed</span> value as well, but we need to have an additional value that invalidates the WALK animation and enables the <span class="packt_screen">Crouch</span> animation. There are two ways of doing this: by pressing a <span class="packt_screen">Crouch</span> button at the same time that we move forward, or to define zones on the map where the character goes directly to CROUCH mode. For this example, and because we are working on an AI character, we'll be using the second option and define zones on the map that will make the character enter CROUCH mode:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="221" width="392" class=" image-border" src="assets/25e33e17-2dde-4d84-b33c-0e1e0a868250.png"/></div>
<p>In this example, let's assume that the character shouldn't be walking on the grass, and for that reason he tries to hide by crouching. We could also choose a small location that is impossible to enter if he was walking upright, and for that reason the character automatically starts to walk in the crouch position.</p>
<p>So, to do this we need to create trigger positions on our map that change the animations according to the position that the character is currently in. In the code, we create a new Boolean variable and call it <kbd>steppingGrass</kbd>, right after the line where we connect the <kbd>currentSpeed</kbd> value with the animation state machine. We are going to add a new line that connects this Boolean to a new parameter that we are going to create on the animation state machine as well. We can start by creating the new parameter:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="93" width="344" class=" image-border" src="assets/e68f302d-152b-457f-99f2-163237e928a2.png"/></div>
<p>In our code, we are going to add collision detection that will turn on this value once our character is on the grass, and turn it off soon as he leaves that area:</p>
<pre>     public Animator characterAnimator;<br/>     public int Health;<br/>     public int Stamina;<br/>     public float movementSpeed;<br/>     public float rotationSpeed;<br/>     public float maxSpeed;<br/>     public float jumpHeight;<br/>     public float jumpSpeed;<br/><br/>     private float currentSpeed;<br/>     private bool Dead;<br/>     private bool steppingGrass;<br/><br/>     void Start () {<br/><br/>     }<br/><br/>     void Update () {<br/><br/>         // Sets the movement speed of the animator, to change from<br/>         idle to walk and walk to run<br/>         characterAnimator.SetFloat("currentSpeed",currentSpeed);<br/><br/>         // Sets the stepping grass Boolean to the animator value<br/>         characterAnimator.SetBool("steppingGrass",steppingGrass);<br/><br/>         // USING XBOX CONTROLLER<br/>         transform.Rotate(0,Time.deltaTime * (rotationSpeed *<br/>         Input.GetAxis ("xboxlefth")), 0);<br/><br/>         if(Input.GetAxis ("xboxleft") &gt; 0){<br/>             transform.position += transform.forward * Time.deltaTime *<br/>         currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis<br/>         ("xboxleft") * movementSpeed);<br/>         }<br/><br/>         else{<br/>             transform.position += transform.forward * Time.deltaTime *<br/>             currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis<br/>             ("xboxleft") * movementSpeed/3);<br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Health &lt;= 0){<br/>             Dead = true;<br/>         }<br/>     }<br/><br/>     void OnTriggerEnter(Collider other) {<br/><br/>         if(other.gameObject.tag == "Grass")<br/>         {   <br/>             steppingGrass = true;<br/>         }<br/>     }<br/><br/>     void OnTriggerExit(Collider other) {<br/><br/>         if(other.gameObject.tag == "Grass")<br/>         {   <br/>             steppingGrass = false;<br/>         }<br/>     } </pre>
<p>Now, we can proceed and add this new parameter to the CROUCH animations. We start by choosing the link between the IDLE to CROUCH animation and set the <kbd>currentSpeed</kbd> value and the new <kbd>steppingGrass</kbd> parameter. Because we have a <span class="packt_screen">Crouch Idle</span> animation, even if the character is not moving, it will play that animation instead of the normal IDLE animation:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="232" width="363" class=" image-border" src="assets/259985ef-d40a-4117-a173-12e1bfce82b5.png"/></div>
<p>We have set the <kbd>currentSpeed</kbd> to be less than 0.1, which means that the character is not moving, and the <kbd>steppingGrass</kbd> set to <span class="packt_screen">true</span>, which stops the normal IDLE animation and starts playing the <span class="packt_screen">Crouch Idle</span> animation. The rest of the CROUCH animations follow the same principles as the WALK and RUN animation. Once the character starts to move, that represents the <kbd>currentSpeed</kbd> value, the <span class="packt_screen">Crouch Idle</span> stops and the Crouch Walk plays. At the end, we link <span class="packt_screen">Crouch Idle</span> to IDLE and Crouch Walk to WALK, making sure that if the character is walking away from the grass, the WALK animation doesn't stop and the character keeps walking upright.</p>
<p>Regarding the attacks, we will be using integers to randomize a number between 1 to 10, and if the number is higher than <kbd>5</kbd> it will play the KICK animation. If the number is below <kbd>5</kbd> it will play the PUNCH animation. So, when the character enters fight mode against an opponent, it will play different attacks. Once again, using this method allows us to add more animations in the future, increasing the diversity of attacks.</p>
<p>Once again, we create a new parameter, and for this example we are going to create an integer parameter and call it <kbd>attackRandomNumber</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="79" width="306" class=" image-border" src="assets/f203ad22-22a5-4c93-bd39-4999b6816924.png"/></div>
<p>In our code, we are going to add a new variable and give it the same name (it is not necessary to create it with the same name, but it does make everything organized). Right after the lines with which we previously connected the variables with the animation state machine parameters, we are going to create a new one that connects to the <kbd>attackRandomNumber</kbd> value. Then we create a function that randomizes a number once the character enters fight mode:</p>
<pre>     public Animator characterAnimator;<br/>     public int Health;<br/>     public int Stamina;<br/>     public float movementSpeed;<br/>     public float rotationSpeed;<br/>     public float maxSpeed;<br/>     public float jumpHeight;<br/>     public float jumpSpeed;<br/><br/>     private float currentSpeed;<br/>     private bool Dead;<br/>     private bool steppingGrass;<br/>     private int attackRandomNumber;<br/><br/>     void Start () {<br/><br/>     }<br/><br/>     void Update () {<br/><br/>         // Sets the movement speed of the animator, to change from<br/>         idle to walk and walk to run<br/>         characterAnimator.SetFloat("currentSpeed",currentSpeed);<br/><br/>         // Sets the stepping grass Boolean to the animator value<br/>         characterAnimator.SetBool("steppingGrass",steppingGrass);<br/><br/>         // Sets the attackrandomnumber to the animator value<br/>         characterAnimator.SetInteger("attackRandomNumber",<br/>            attackRandomNumber);<br/><br/>         // USING XBOX CONTROLLER<br/>         transform.Rotate(0,Time.deltaTime * (rotationSpeed *<br/>         Input.GetAxis ("xboxlefth")), 0);<br/><br/>         if(Input.GetAxis ("xboxleft") &gt; 0){<br/>             transform.position += transform.forward * Time.deltaTime *<br/>         currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis <br/>         ("xboxleft") * movementSpeed);<br/>         }<br/><br/>         else{<br/>             transform.position += transform.forward * Time.deltaTime *<br/>         currentSpeed;<br/>             currentSpeed = Time.deltaTime * (Input.GetAxis<br/>         ("xboxleft") * movementSpeed/3);<br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/>             fightMode();<br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 18") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyDown("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Input.GetKeyUp("joystick button 16") &amp;&amp; Dead == false)<br/>         {<br/><br/>         }<br/><br/>         if(Health &lt;= 0){<br/>             Dead = true;<br/>         }<br/>     }<br/><br/>     void OnTriggerEnter(Collider other) {<br/><br/>         if(other.gameObject.tag == "Grass")<br/>         {   <br/>             steppingGrass = true;<br/>         }<br/>     }<br/><br/>     void OnTriggerExit(Collider other) {<br/><br/>         if(other.gameObject.tag == "Grass")<br/>         {   <br/>             steppingGrass = false;<br/>         }<br/>     }<br/><br/>     void fightMode ()<br/>     {<br/>         attackRandomNumber = (Random.Range(1, 10));<br/>     } </pre>
<p>After doing this, we need to assign the values to the animations. The process is the same as the previous animations, only this time we are using a different value. If <kbd>attackRandomNumber</kbd> is higher than 1, it means that he is attacking, and the attack animations should start playing. Because we have two different attacks, we decided to use them randomly, but if it was a player controlling the character, we could manually assign the number inside the code, and when the player pressed a specific button on the gamepad, the character would punch or kick.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Smooth transitions</h1>
                </header>
            
            <article>
                
<p>Another important aspect that is worth mentioning is the smooth transition between animations. It is very important to maintain the integrity of the animations, so that every action performed by the character looks fluid, helping the virtual immersion of the player.</p>
<p>On this subject, 2D and 3D animations have considerable differences. If we are using 2D sprites, we need to draw the necessary frames that will be used for every transition, and every time we want the character to change from one animation to another, the transition animation will be played.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="225" width="333" class=" image-border" src="assets/7ba7418f-25c1-475f-8a03-917cf01aae30.png"/></div>
<p>On the other hand, with 3D characters we can use the bone structure to create the transitions automatically, where the coordinates for each bone will move from the previous animation to the new one. Even if we choose to use the bone structure to help create the transitions, sometimes it might be necessary, or it would be a better option, to manually create new animations that will be used as transitions. This is a common process if the character is using an object or weapon that needs to be saved before playing the next animation.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="211" width="390" class=" image-border" src="assets/7f36b03b-a82f-4294-b741-27a4c9d88161.png"/></div>
<p class="mce-root">To create a smooth transition, we need the first frame of the next animation to be equal to the last frame of the current animation. We need to start the next animation from the same position of the current one. This is crucial to avoid noticing any cut in between the transition. Then we can use the game engine to our advantage and use the transition system for the animations. This will help to create a smoother transition. As we can see on the image above, we can adjust how long the transition will take, we can make a quick transition or a longer one, always experimenting with what looks better for the results that we want.</p>
<p class="mce-root"><br/>
Sometimes we would need to sacrifice a smoother transition in order to have a better gameplay experience. One example of this is during a fighting game, where it's more important to have quick transitions rather than smooth ones, and for that reason we need to take in consideration the time that it takes for the character to change from one state to another.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter has described how to use 2D or 3D animations to complement the actions of a character. Animations play an important part in the development of a believable AI character, and by using them correctly, the character can transmit to the player a real sensation that the character is alive and that they react autonomously. Even if the character has limited actions, we can use animations to fake or hide some of them, giving the impression that it is reacting that way because it thinks for itself.</p>
<p>In the next chapter, we'll be talking about navigation behavior and pathfinding, that is how to program the AI character to walk towards the desired position and choose the best route.</p>


            </article>

            
        </section>
    </body></html>