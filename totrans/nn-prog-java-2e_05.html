<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 5. Forecasting Weather"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch05" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 5. Forecasting Weather</h1></div></div></div><p class="calibre11">This chapter presents one well-known application in daily life to which neural networks can perfectly be applied: forecasting weather. We are going to walk through the entire process of designing a neural network solution to this problem: how to choose the neural architecture and the number of neurons, as well as selecting and preprocessing data. Then the reader will be presented with techniques to handle time series datasets, from which our neural network is going to make predictions on weather variables using the Java programming language. The topics covered in this chapter are as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Neural networks for regression problems</li><li class="listitem">Loading/selecting data</li><li class="listitem">Input/output variables</li><li class="listitem">Choosing inputs</li><li class="listitem">Preprocessing</li><li class="listitem">Normalization</li><li class="listitem">Empirical design of neural networks</li></ul></div><div class="calibre2" title="Neural networks for regression problems"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch05lvl1sec36" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Neural networks for regression problems</h1></div></div></div><p class="calibre11">So far, the <a id="id324" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>reader has been presented with a <a id="id325" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>number of neural network implementations and architectures, so now it is time to get into more complex cases. The power of neural networks in predictions is really astonishing since they can perform <span class="strong1"><em class="calibre16">learning</em></span> from historical data in such a way that neural connections are adapted to produce the same results according to some input data. For example, for a given situation (cause), there is a consequence (result) and this is represented as data; neural networks are capable of learning the nonlinear function that maps the situation to the consequence (or the cause to the result).</p><p class="calibre11">Prediction and regression problems are an interesting category to apply neural networks to. Let's take a look at a sample table containing weather data:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Date</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Avg. Temperature</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Pressure</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Humidity</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Precipitation</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Wind Speed</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">July 31st</p>
</td><td class="calibre29">
<p class="calibre26">23 ºC</p>
</td><td class="calibre29">
<p class="calibre26">880 mbar</p>
</td><td class="calibre29">
<p class="calibre26">66%</p>
</td><td class="calibre29">
<p class="calibre26">16 mm</p>
</td><td class="calibre29">
<p class="calibre26">5 m/s</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">August 1st</p>
</td><td class="calibre29">
<p class="calibre26">22 ºC</p>
</td><td class="calibre29">
<p class="calibre26">881 mbar</p>
</td><td class="calibre29">
<p class="calibre26">78%</p>
</td><td class="calibre29">
<p class="calibre26">3 mm</p>
</td><td class="calibre29">
<p class="calibre26">3 m/s</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">August 2nd</p>
</td><td class="calibre29">
<p class="calibre26">25 ºC</p>
</td><td class="calibre29">
<p class="calibre26">884 mbar</p>
</td><td class="calibre29">
<p class="calibre26">65%</p>
</td><td class="calibre29">
<p class="calibre26">0 mm</p>
</td><td class="calibre29">
<p class="calibre26">4 m/s</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">August 3rd</p>
</td><td class="calibre29">
<p class="calibre26">27 ºC</p>
</td><td class="calibre29">
<p class="calibre26">882 mbar</p>
</td><td class="calibre29">
<p class="calibre26">53%</p>
</td><td class="calibre29">
<p class="calibre26">0 mm</p>
</td><td class="calibre29">
<p class="calibre26">3 m/s</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">…</p>
</td><td class="calibre29"> </td><td class="calibre29"> </td><td class="calibre29"> </td><td class="calibre29"> </td><td class="calibre29"> </td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">December 11th</p>
</td><td class="calibre29">
<p class="calibre26">32 ºC</p>
</td><td class="calibre29">
<p class="calibre26">890 mbar</p>
</td><td class="calibre29">
<p class="calibre26">64%</p>
</td><td class="calibre29">
<p class="calibre26">0 mm</p>
</td><td class="calibre29">
<p class="calibre26">2 m/s</p>
</td></tr></tbody></table></div><p class="calibre11">The table above depicts five variables containing hypothetical values of weather data collected from a<a id="id326" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> hypothetical city, only for the<a id="id327" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> purpose of this example. Now let's suppose that each of the variables contains a list of values sequentially taken over time. We can think of each list as a time series. On a time series chart, one can see how they evolve with time:</p><div class="mediaobject"><img src="Images/B05964_05_01.jpg" alt="Neural networks for regression problems" class="calibre155"/></div><p class="calibre11">The relationship between these time series denotes a dynamic representation of weather in a certain city, as depicted in the chart above. We want the neural network to learn this dynamic representation; however, we need to structure this data the in a way neural networks can process, that is, identifying which data series (variables) are the cause and which are the effect. Dynamic systems have variables whose value depends on past values, so neural network applications can rely not only on the present situation, but also on the past. This is very important because historical events influence the present and future.</p><p class="calibre11">Only after structuring data can we structure the neural network, that is, the number of inputs, outputs, and hidden nodes. However, there are many other architectures that may be suitable for prediction problems, such as radial basis functions and feedback networks, among others. In <a id="id328" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>this chapter, we are dealing<a id="id329" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> with a feedforward multilayer perceptron with the Backpropagation learning algorithm, to demonstrate how this architecture can be simply exploited to predict weather variables; also, this architecture presents very good generalized results with good selected data and there is little complexity involved in the design process.</p><p class="calibre11">The overall process for designing neural networks for prediction processes is depicted in the figure below:</p><div class="mediaobject"><img src="Images/B05964_05_02.jpg" alt="Neural networks for regression problems" class="calibre156"/></div><p class="calibre11">If the neural network fails to be validated (<span class="strong1"><strong class="calibre12">step 5</strong></span>), usually a new structure (<span class="strong1"><strong class="calibre12">step 3</strong></span>) is defined, although sometimes <span class="strong1"><strong class="calibre12">steps 1</strong></span> and <span class="strong1"><strong class="calibre12">step 2</strong></span> may be repeated. Each of the steps in the figure will be addressed in the next sections in this chapter.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Loading/selecting data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch05lvl1sec37" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Loading/selecting data</h1></div></div></div><p class="calibre11">First we <a id="id330" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>need to load raw data into our Java environment. Data <a id="id331" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>can be stored in a variety of data sources, from text files to structured database systems. One basic and simple type used is <span class="strong1"><strong class="calibre12">CSV</strong></span> (<span class="strong1"><strong class="calibre12">Comma-Separated Values</strong></span>), which is simple and in general use. In addition, we'll <a id="id332" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>need to transform this data and perform selection before presenting it to the neural network.</p><div class="calibre2" title="Building auxiliary classes"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec62" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Building auxiliary classes</h2></div></div></div><p class="calibre11">To deal <a id="id333" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>with these tasks, we need some auxiliary classes in the package <code class="literal">edu.packt.neuralnet.data</code>. The first will be <code class="literal">LoadCsv</code> to read CSV files:</p><div class="calibre2"><pre class="programlisting">public class LoadCsv {
   //Path and file name separated for compatibility
  private String PATH; 
  private String FILE_NAME;
  private double[][] dataMatrix; 
  private boolean columnsInFirstRow=false;
  private String separator = ",";
  private String fullFilePath;
  private String[] columnNames;
  final double missingValue=Double.NaN;

  //Constructors
  public LoadCsv(String path,String fileName)
  //…
  public LoadCsv(String fileName,boolean _columnsInFirstRow,String _separator)
  //…

  //Method to load data from file returning a matrix
  public double[][] getDataMatrix(String fullPath,boolean _columnsInFirstRow,String _separator)
  //…
  
  //Static method for calls without instantiating LoadCsv object
  public static double[][] getData(String fullPath,boolean _columnsInFirstRow,String _separator)
  //…

  Method for saving data into csv file
  public void save()
  //…

  //…
}</pre></div><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip14" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">To save space here, we are not showing the full code. For more details and the full list of methods, please refer to the code and documentation in <span class="strong1"><em class="calibre16">Appendix C</em></span>.</p></div></div><p class="calibre11">We are <a id="id334" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>also creating a class to store the raw data loaded from CSV into a structure containing not only the data but the information on this data, such as column names. This class will be called <span class="strong1"><strong class="calibre12">DataSet</strong></span>, inside <a id="id335" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the same package:</p><div class="calibre2"><pre class="programlisting">public class DataSet {
  //column names list
  public ArrayList&lt;String&gt; columns;
  //data matrix 
  public ArrayList&lt;ArrayList&lt;Double&gt;&gt; data;
  
  public int numberOfColumns;
  public int numberOfRecords;

  //creating from Java matrix
  public DataSet(double[][] _data,String[] _columns){
    numberOfRecords=_data.length;
    numberOfColumns=_data[0].length;
    columns = new ArrayList&lt;&gt;();
    for(int i=0;i&lt;numberOfColumns;i++){
      //…
      columns.add(_columns[i]);
      //…
    }
    data = new ArrayList&lt;&gt;();
    for(int i=0;i&lt;numberOfRecords;i++){
      data.add(new ArrayList&lt;Double&gt;());
      for(int j=0;j&lt;numberOfColumns;j++){
        data.get(i).add(_data[i][j]);
      }
    }        
  }
  
  //creating from csv file  
  public DataSet(String filename,boolean columnsInFirstRow,String separator){
    LoadCsv lcsv = new LoadCsv(filename,columnsInFirstRow,separator);
    double[][] _data= lcsv.getDataMatrix(filename, columnsInFirstRow, separator);
    numberOfRecords=_data.length;
    numberOfColumns=_data[0].length;
    columns = new ArrayList&lt;&gt;();
    if(columnsInFirstRow){
       String[] columnNames = lcsv.getColumnNames();
       for(int i=0;i&lt;numberOfColumns;i++){
         columns.add(columnNames[i]);
       }
    }
    else{ //default column names: Column0, Column1, etc.
      for(int i=0;i&lt;numberOfColumns;i++){ 
        columns.add("Column"+String.valueOf(i));
      }
    }
    data = new ArrayList&lt;&gt;();
    for(int i=0;i&lt;numberOfRecords;i++){
      data.add(new ArrayList&lt;Double&gt;());
      for(int j=0;j&lt;numberOfColumns;j++){
        data.get(i).add(_data[i][j]);
      }
    } 
  }
  //…
  //method for adding new column
  public void addColumn(double[] _data,String name)
  //…
  //method for appending new data, number of columns must correspond 
  public void appendData(double[][] _data)
  //…
  //getting all data
  public double[][] getData(){
    return ArrayOperations.arrayListToDoubleMatrix(data);
  }
  //getting data from specific columns 
  public double[][] getData(int[] columns){
    return ArrayOperations.getMultipleColumns(getData(), columns);
  }
  //getting data from one column
  public double[] getData(int col){
    return ArrayOperations.getColumn(getData(), col);
  }
  //method for saving the data in a csv file
  public void save(String filename,String separator)
  //…
}</pre></div><p class="calibre11">In <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch04.xhtml" title="Chapter 4. Self-Organizing Maps">Chapter 4</a>, <span class="strong1"><em class="calibre16">Self-Organizing Maps</em></span>, we've created a class <code class="literal">ArrayOperations</code> in the package <code class="literal">edu.packt.neuralnet.math</code> to handle operations involving arrays of data. This class has a large number of static methods and it would be impractical<a id="id336" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to depict all of them here; however, information can be found in <span class="strong1"><em class="calibre16">Appendix C</em></span>.</p></div><div class="calibre2" title="Getting a dataset from a CSV file"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec63" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Getting a dataset from a CSV file</h2></div></div></div><p class="calibre11">To make <a id="id337" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the task easier, we've implemented a static method in the class <code class="literal">LoadCsv</code> to load a CSV file and automatically convert it into the structure of a <code class="literal">DataSet</code> object:</p><div class="calibre2"><pre class="programlisting">public static DataSet getDataSet(String fullPath,boolean _columnsInFirstRow, String _separator){
  LoadCsv lcsv = new LoadCsv(fullPath,_columnsInFirstRow,_separator);
  lcsv.columnsInFirstRow=_columnsInFirstRow;
  lcsv.separator=_separator;
  try{
    lcsv.dataMatrix=lcsv.csvData2Matrix(fullPath);
    System.out.println("File "+fullPath+" loaded!");
  }
  catch(IOException ioe){
    System.err.println("Error while loading CSV file. Details: " + ioe.getMessage());
  }
  return new DataSet(lcsv.dataMatrix, lcsv.columnNames);
}</pre></div></div><div class="calibre2" title="Building time series"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec64" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Building time series</h2></div></div></div><p class="calibre11">A time series <a id="id338" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>structure is essential for all problems involving time dimensions or domains, such as forecasting and prediction. A class called <code class="literal">TimeSeries</code> implements some time-related attributes such as time column and delay. Let's take a look at the structure of this class:</p><div class="calibre2"><pre class="programlisting">public class TimeSeries extends DataSet {
  //index of the column containing time information
  private int indexTimeColumn;
   
  public TimeSeries(double[][] _data,String[] _columns){
    super(_data,_columns); //just a call to superclass constructor
  }
  public TimeSeries(String path, String filename){
    super(path,filename);
  }
  public TimeSeries(DataSet ds){
    super(ds.getData(),ds.getColumns());
  }
  public void setIndexColumn(int col){
    this.indexTimeColumn=col;
    this.sortBy(indexTimeColumn);
  }
//…
 }</pre></div><p class="calibre11">In time <a id="id339" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>series, one frequent operation is the delay of shift of values. For example, we want to include in the processing not the current but the two past values for the daily temperature. Considering temperature as a time series with a time column (date), we must shift the values in the number of cycles desired (one and two, in this example):</p><div class="mediaobject"><img src="Images/B05964_05_03.jpg" alt="Building time series" class="calibre157"/></div><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip15" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">We have used <span class="strong1"><strong class="calibre12">Microsoft Excel®</strong></span> to convert the <code class="literal">datetime</code> values into real values. Working <a id="id340" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>with numerical values is always preferred to working with structures such as dates or categories. So in this chapter, we are using numerical values to represent date.</p></div></div><p class="calibre11">While working with time series, one should pay attention to two points:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">There may be missing values or no measurements on a specific point of time; this can generate NaNs in the Java matrix.</li><li class="listitem">Shifting a column over one time period, for example, is not the same as getting the value of the previous row. That's why it is important to choose one column to be the time reference.</li></ul></div><p class="calibre11">In the <code class="literal">ArrayOperations</code> class, we implemented a method <code class="literal">shiftColumn</code> to shift the column of a matrix considering a time column for reference. This method is called from another<a id="id341" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> method of the same name in the <code class="literal">TimeSeries</code> class, and then used in the shift method:</p><div class="calibre2"><pre class="programlisting">public double[] shiftColumn(int col,int shift){
  double[][] _data = ArrayOperations.arrayListToDoubleMatrix(data);
  return ArrayOperations.shiftColumn(_data, indexTimeColumn, shift, col);
}
public void shift(int col,int shift){
  String colName = columns.get(col);
  if(shift&gt;0) colName=colName+"_"+String.valueOf(shift);
  else colName=colName+"__"+String.valueOf(-shift);
  addColumn(shiftColumn(col,shift),colName);
}</pre></div></div><div class="calibre2" title="Dropping NaNs"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec65" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Dropping NaNs</h2></div></div></div><p class="calibre11">NaNs are <a id="id342" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>undesired values often present<a id="id343" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> after loading or transforming data. They are undesired because we cannot operate over them. If we feed a NaN value into a neural network, the output will definitely be NaN, just consuming more computational power. That's why it is better to drop them out. In the class <code class="literal">DataSet</code>, we've implemented two methods to drop NaNs: one just substitutes a value for them, and the other drops the entire row if it has at least one missing value, as shown in the following figure:</p><div class="mediaobject"><img src="Images/B05964_05_04.jpg" alt="Dropping NaNs" class="calibre158"/></div><div class="calibre2"><pre class="programlisting">// dropping with a substituting value
public void dropNaN(double substvalue)
//…
// dropping the entire row
public void dropNaN()
//…</pre></div></div><div class="calibre2" title="Getting weather data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec66" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Getting weather data</h2></div></div></div><p class="calibre11">Now that<a id="id344" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> we have the tools to get the data, let's find some datasets on the Internet. In this chapter, we are going to use the data from the Brazilian Institute of Meteorology (INMET: <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.inmet.gov.br/">http://www.inmet.gov.br/</a> in Portuguese), which is freely available on the Internet; we <a id="id345" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>have the rights to use it in this book. However, the reader may use any free weather database on the Internet while developing applications.</p><p class="calibre11">Some examples from English language sources are listed<a id="id346" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> below:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Wunderground (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://wunderground.com/">http://wunderground.com/</a>)</li><li class="listitem">Open Weather Map (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://openweathermap.org/api">http://openweathermap.org/api</a>)</li><li class="listitem">Yahoo weather API (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://developer.yahoo.com/weather/">https://developer.yahoo.com/weather/</a>)</li><li class="listitem">US National Climatic Data Center (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.ncdc.noaa.gov/">http://www.ncdc.noaa.gov/</a>)</li></ul></div></div><div class="calibre2" title="Weather variables"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec67" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Weather variables</h2></div></div></div><p class="calibre11">Any<a id="id347" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> weather database will have almost the same variables:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Temperature (ºC)</li><li class="listitem">Humidity (%)</li><li class="listitem">Pressure (mbar)</li><li class="listitem">Wind speed (m/s)</li><li class="listitem">Wind direction (º )</li><li class="listitem">Precipitation (mm)</li><li class="listitem">Sunny hours (h)</li><li class="listitem">Sun energy (W/m2)</li></ul></div><p class="calibre11">This data is usually collected from meteorological stations, satellites, or radar, on an hourly or daily basis.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip16" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">Depending on the collection frequency, some variables may be summarized with average, minimum, or maximum values.</p><p class="calibre17">Data units may also vary from source to source; that's why units should always be observed.</p></div></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Choosing input and output variables"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch05lvl1sec38" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Choosing input and output variables</h1></div></div></div><p class="calibre11">Selecting the <a id="id348" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>appropriate data<a id="id349" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> that fulfils most of the system's dynamics needs to be carefully done. We want the neural network to forecast future weather based on the current and past weather data, but which variables should we choose? Getting an expert opinion on the subject can be really helpful in understanding the relationship between variables.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="tip17" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">Regarding time series variables, one can derive new variables by applying historical data. That means, given a certain date, one may consider this date's values and the data collected (and/or summarized) from past dates, therefore extending the number of variables.</p></div></div><p class="calibre11">While defining a problem to use neural networks on, there are one or more predefined target variables: predict the temperature, forecast precipitation. measure insolation, and so on. But, in some cases, one wants to model all the variables and therefore to find causal relationships between them. Causal relationships can be identified by statistical tools, of which Pearson cross-correlation is the most used:</p><div class="mediaobject"><img src="Images/B05964_05_05.jpg" alt="Choosing input and output variables" class="calibre159"/></div><p class="calibre11">Here, <span class="strong1"><em class="calibre16">E[X.Y]</em></span> is the mean of the multiplication of variables <span class="strong1"><em class="calibre16">X</em></span> and <span class="strong1"><em class="calibre16">Y</em></span>; <span class="strong1"><em class="calibre16">E[X]</em></span> and <span class="strong1"><em class="calibre16">E[Y]</em></span> are the means of <span class="strong1"><em class="calibre16">X</em></span> and <span class="strong1"><em class="calibre16">Y</em></span> respectively; <span class="strong1"><em class="calibre16">σX</em></span> and <span class="strong1"><em class="calibre16">σY</em></span> are the standard deviation of <span class="strong1"><em class="calibre16">X</em></span> and <span class="strong1"><em class="calibre16">Y</em></span> respectively; and finally <span class="strong1"><em class="calibre16">Cx,y</em></span> is the Pearson coefficient of <span class="strong1"><em class="calibre16">X</em></span> related to <span class="strong1"><em class="calibre16">Y</em></span>, whose values lie between <span class="strong1"><em class="calibre16">-1</em></span> and <span class="strong1"><em class="calibre16">1</em></span>. This coefficient shows how much a variable <span class="strong1"><em class="calibre16">X</em></span> is correlated with a variable <span class="strong1"><em class="calibre16">Y</em></span>. Values near <span class="strong1"><em class="calibre16">0</em></span> denote weak or no correlation at all, while values close to <span class="strong1"><em class="calibre16">-1</em></span> or <span class="strong1"><em class="calibre16">1</em></span> denote negative or positive correlation, respectively. Graphically, it can be seen by a scatter plot, as shown below:</p><div class="mediaobject"><img src="Images/B05964_05_06.jpg" alt="Choosing input and output variables" class="calibre160"/></div><p class="calibre11">In the chart on the left, the correlation between the precipitation of the last day (indicated as [-1]) and the maximum temperature is -0.202, which is a weak value of negative correlation. In the middle chart, the correlation between insolation and maximum temperature is 0.376, which is a fair correlation, yet not very significant; one can see a slight positive trend. An example of strong positive correlation is shown in the chart on the right, which is between the last day's maximum temperature and the maximum temperature of the day. This correlation is 0.793, and we can see a thinner cloud of dots indicating the trend.</p><p class="calibre11">We are going<a id="id350" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to use correlation to choose the <a id="id351" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>most appropriate inputs for our neural network. First, we need to code a method in the class DataSet, called correlation. Please note that operations such as mean and standard deviation are implemented in our class <code class="literal">ArrayOperations</code>:</p><div class="calibre2"><pre class="programlisting">public double correlation(int colx,int coly){
  double[] arrx = ArrayOperations.getColumn(data,colx);
  double[] arry = ArrayOperations.getColumn(data,coly);
  double[] arrxy = ArrayOperations.elementWiseProduct(arrx, arry);
  double meanxy = ArrayOperations.mean(arrxy);
  double meanx = ArrayOperations.mean(arrx);
  double meany = ArrayOperations.mean(arry);
  double stdx = ArrayOperations.stdev(arrx);
  double stdy = ArrayOperations.stdev(arry);
  return (meanxy*meanx*meany)/(stdx*stdy);
}</pre></div><p class="calibre11">We will not delve too deeply into statistics in this book, so we recommend a number of references if the reader is interested in more details on this topic.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Preprocessing"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch05lvl1sec39" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Preprocessing</h1></div></div></div><p class="calibre11">Raw data <a id="id352" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>collected from a data source usually presents different particularities, such as data range, sampling, and category. Some variables result from measurements while others are summarized or even calculated. Preprocessing means to adapt these variable values to a range that neural networks can handle properly.</p><p class="calibre11">Regarding weather variables, let's take a look at their range, sampling, and type:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Variable</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Unit</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Range</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Sampling</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Type</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">Mean temperature</p>
</td><td class="calibre29">
<p class="calibre26">º C</p>
</td><td class="calibre29">
<p class="calibre26">10.86 – 29.25</p>
</td><td class="calibre29">
<p class="calibre26">Hourly</p>
</td><td class="calibre29">
<p class="calibre26">Average of hourly measurements</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">Precipitation</p>
</td><td class="calibre29">
<p class="calibre26">mm</p>
</td><td class="calibre29">
<p class="calibre26">0 – 161.20</p>
</td><td class="calibre29">
<p class="calibre26">Daily</p>
</td><td class="calibre29">
<p class="calibre26">Accumulation of daily rain</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">Insolation</p>
</td><td class="calibre29">
<p class="calibre26">hours</p>
</td><td class="calibre29">
<p class="calibre26">0 – 10.40</p>
</td><td class="calibre29">
<p class="calibre26">Daily</p>
</td><td class="calibre29">
<p class="calibre26">Count of hours receiving sun radiation</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">Mean humidity</p>
</td><td class="calibre29">
<p class="calibre26">%</p>
</td><td class="calibre29">
<p class="calibre26">45.00 – 96.00</p>
</td><td class="calibre29">
<p class="calibre26">Hourly</p>
</td><td class="calibre29">
<p class="calibre26">Average of hourly measurements</p>
</td></tr><tr class="calibre28"><td class="calibre29">
<p class="calibre26">Mean wind speed</p>
</td><td class="calibre29">
<p class="calibre26">km/h</p>
</td><td class="calibre29">
<p class="calibre26">0.00 – 3.27</p>
</td><td class="calibre29">
<p class="calibre26">Hourly</p>
</td><td class="calibre29">
<p class="calibre26">Average of hourly measurements</p>
</td></tr></tbody></table></div><p class="calibre11">Except for insolation and precipitation, the variables are all measured and share the same sampling, but if we wanted, for example, to use an hourly dataset, we would have to preprocess all the variables to use the same sample rate. Three of the variables are summarized, using daily average values, but if we wanted to we could use hourly data measurements. However, the range would certainly be larger.</p><div class="calibre2" title="Normalization"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec68" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Normalization</h2></div></div></div><p class="calibre11">Normalization is<a id="id353" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the process of getting all variables into the same <a id="id354" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>data range, usually with smaller values, between <code class="literal">0</code> and <code class="literal">1</code> or <code class="literal">-1</code> and <code class="literal">1</code>. This helps the neural network to present values within the variable zone in activation functions such as sigmoid or hyperbolic tangent:</p><div class="mediaobject"><img src="Images/B05964_05_07.jpg" alt="Normalization" class="calibre161"/></div><p class="calibre11">Values too high or too<a id="id355" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> low may drive neurons in to producing values too high or too low as well for the activation functions, therefore leading to the derivative<a id="id356" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> for these neurons being too small, near zero. In this book, we implemented two modes of normalization: min-max and z-score.</p><p class="calibre11">The min-max normalization should consider a predefined range of the dataset. It is performed right away:</p><div class="mediaobject"><img src="Images/B05964_05_08.jpg" alt="Normalization" class="calibre162"/></div><p class="calibre11">Here, Nmin and Nmax are the normalized minimum and maximum limits respectively, Xmin and Xmax are the variable X's minimum and maximum limits respectively, <span class="strong1"><em class="calibre16">X</em></span> is the original value, and Xnorm is the normalized value. If we want the normalization to be between 0 and 1, for example, the equation is simplified to the following:</p><div class="mediaobject"><img src="Images/B05964_05_09.jpg" alt="Normalization" class="calibre163"/></div><p class="calibre11">By applying the normalization, a new <span class="strong1"><em class="calibre16">normalized</em></span> dataset is produced and is fed to the neural network. One should also take into account that a neural network fed with normalized values will be trained to produce normalized values on the output, so the inverse (denormalization) process becomes necessary as well:</p><div class="mediaobject"><img src="Images/B05964_05_10.jpg" alt="Normalization" class="calibre164"/></div><p class="calibre11">Or</p><div class="mediaobject"><img src="Images/B05964_05_11.jpg" alt="Normalization" class="calibre165"/></div><p class="calibre11">For the normalization between 0 and 1.</p><p class="calibre11">Another mode<a id="id357" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> of normalization is the z-score, which takes into account<a id="id358" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the mean and standard deviation:</p><div class="mediaobject"><img src="Images/B05964_05_12.jpg" alt="Normalization" class="calibre166"/></div><p class="calibre11">Here, S is a scaling constant, <span class="strong1"><em class="calibre16">E[X]</em></span> is the mean of E, and <span class="strong1"><em class="calibre16">σX</em></span> is the standard deviation of X. The main difference in this normalization mode is that there will be no limit defined for the range of variables; however, the variables will have values on the same range centered on zero with standard deviation equal to the scaling constant S.</p><p class="calibre11">The figure below shows what both normalization modes do with the data:</p><div class="mediaobject"><img src="Images/B05964_05_13.jpg" alt="Normalization" class="calibre167"/></div><p class="calibre11">A class called <code class="literal">DataNormalization</code> is implemented to handle the normalization of data. Since normalization<a id="id359" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> considers the statistical <a id="id360" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>properties of the data, we need to store this statistical information in a <code class="literal">DataNormalization</code> object:</p><div class="calibre2"><pre class="programlisting">public class DataNormalization {
  //ENUM normalization types
  public enum NormalizationTypes { MIN_MAX, ZSCORE }
  // normalization type
  public NormalizationTypes TYPE;
  //statistical properties of the data
  private double[] minValues;
  private double[] maxValues;
  private double[] meanValues;
  private double[] stdValues;
  //normalization properties
  private double scaleNorm=1.0;        
  private double minNorm=-1.0;
//…
  //constructor for min-max norm
  public DataNormalization(double[][] data,double _minNorm, double _maxNorm){
    this.TYPE=NormalizationTypes.MIN_MAX;
    this.minNorm=_minNorm;
    this.scaleNorm=_maxNorm-_minNorm;
    calculateReference(data);
  }
  //constructor for z-score norm        
  public DataNormalization(double[][] data,double _zscale){
    this.TYPE=NormalizationTypes.ZSCORE;
    this.scaleNorm=_zscale;
    calculateReference(data);
  }
  //calculation of statistical properties
  private void calculateReference(double[][] data){
    minValues=ArrayOperations.min(data);
    maxValues=ArrayOperations.max(data);
    meanValues=ArrayOperations.mean(data);
    stdValues=ArrayOperations.stdev(data);
  }
//…
}</pre></div><p class="calibre11">The normalization<a id="id361" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> procedure is performed on a <a id="id362" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>method called <code class="literal">normalize</code>, which has a denormalization counterpart called <span class="strong1"><strong class="calibre12">denormalize</strong></span>:</p><div class="calibre2"><pre class="programlisting">public double[][] normalize( double[][] data ) {
  int rows = data.length;
  int cols = data[0].length;
  //…
  double[][] normalizedData = new double[rows][cols];
  for(int i=0;i&lt;rows;i++){
    for(int j=0;j&lt;cols;j++){
      switch (TYPE){
        case MIN_MAX:
          normalizedData[i][j]=(minNorm) + ((data[i][j] - minValues[j]) / ( maxValues[j] - minValues[j] )) * (scaleNorm);
          break;
        case ZSCORE:
          normalizedData[i][j]=scaleNorm * (data[i][j] - meanValues[j]) / stdValues[j];
          break;
      }
    }
  }
  return normalizedData;
}</pre></div></div><div class="calibre2" title="Adapting NeuralDataSet to handle normalization"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec69" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Adapting NeuralDataSet to handle normalization</h2></div></div></div><p class="calibre11">The already<a id="id363" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> implemented <code class="literal">NeuralDataSet</code>, <code class="literal">NeuralInputData</code>, and <code class="literal">NeuralOutputData</code> will now have <code class="literal">DataNormalization</code> objects to handle normalization operations. In the <code class="literal">NeuralDataSet</code> class, we've added objects for input and output data normalization:</p><div class="calibre2"><pre class="programlisting"> public DataNormalization inputNorm;
 public DataNormalization outputNorm;
 //zscore normalization
 public void setNormalization(double _scaleNorm){
   inputNorm = new DataNormalization(_scaleNorm);
   inputData.setNormalization(inputNorm);
   outputNorm = new DataNormalization(_scaleNorm);
   outputData.setNormalization(outputNorm);
 }
 //min-max normalization
 public void setNormalization(double _minNorm,double _maxNorm){
   inputNorm = new DataNormalization(_minNorm,_maxNorm);
   inputData.setNormalization(inputNorm);
   outputNorm = new DataNormalization(_minNorm,_maxNorm);
   outputData.setNormalization(outputNorm);
 }</pre></div><p class="calibre11">
<code class="literal">NeuralInputData</code> and <code class="literal">NeuralOutputData</code> will now have <code class="literal">normdata</code> properties to store the <a id="id364" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>normalized data. The methods to retrieve data from these classes will have a Boolean parameter, <code class="literal">isNorm</code>, to indicate whether the value to be retrieved should be normalized or not.</p><p class="calibre11">Considering that <code class="literal">NeuralInputData</code> will provide the neural network with input data, this class will only perform normalization before feeding data into the neural network. The method <code class="literal">setNormalization</code> is implemented in this class to that end:</p><div class="calibre2"><pre class="programlisting"> public ArrayList&lt;ArrayList&lt;Double&gt;&gt; normdata;
 public DataNormalization norm; 
 public void setNormalization(DataNormalization dn){
    //getting the original data into java matrix
   double[][] origData = ArrayOperations.arrayListToDoubleMatrix(data);
   //perform normalization
   double[][] normData = dn.normalize(origData);
   normdata=new ArrayList&lt;&gt;();
   //store the normalized values into ArrayList normdata
   for(int i=0;i&lt;normData.length;i++){
     normdata.add(new ArrayList&lt;Double&gt;());
     for(int j=0;j&lt;normData[0].length;j++){
       normdata.get(i).add(normData[i][j]);
     }
  }
}</pre></div><p class="calibre11">In <code class="literal">NeuralOutputData</code>, there are two datasets, one for the target and one for the neural network output. The target dataset is normalized to provide the training algorithm with normalized values. However, the neural output dataset is the output of the neural network, that is, it will be normalized first. We need to perform denormalization after setting the <a id="id365" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>neural network output dataset:</p><div class="calibre2"><pre class="programlisting"> public ArrayList&lt;ArrayList&lt;Double&gt;&gt; normTargetData;
 public ArrayList&lt;ArrayList&lt;Double&gt;&gt; normNeuralData;
 public void setNeuralData(double[][] _data,boolean isNorm){
   if(isNorm){ //if is normalized
     this.normNeuralData=new ArrayList&lt;&gt;();
     for(int i=0;i&lt;numberOfRecords;i++){
       this.normNeuralData.add(new ArrayList&lt;Double&gt;());
       //… save in the normNeuralData
       for(int j=0;j&lt;numberOfOutputs;j++){
         this.normNeuralData.get(i).add(_data[i][j]);
       }
     }
     double[][] deNorm = norm.denormalize(_data);
     for(int i=0;i&lt;numberOfRecords;i++)
       for(int j=0;j&lt;numberOfOutputs;j++) //then in neuralData
          this.neuralData.get(i).set(j,deNorm[i][j]);
   }
   else setNeuralData(_data);
 }</pre></div></div><div class="calibre2" title="Adapting the learning algorithm to normalization"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec70" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Adapting the learning algorithm to normalization</h2></div></div></div><p class="calibre11">Finally, the <code class="literal">LearningAlgorithm</code> class needs to include the normalization property:</p><div class="calibre2"><pre class="programlisting">protected boolean normalization=false;</pre></div><p class="calibre11">Now<a id="id366" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> during the training, on every call to the <code class="literal">NeuralDataSet</code> methods that retrieve or write data, the normalization property should be passed in the parameter <code class="literal">isNorm</code>, as in the method forward of the class Backpropagation:</p><div class="calibre2"><pre class="programlisting">@Override 
public void forward(){
  for(int i=0;i&lt;trainingDataSet.numberOfRecords;i++){
    neuralNet.setInputs(trainingDataSet.
getInputRecord(i,normalization));
    neuralNet.calc();
    trainingDataSet.setNeuralOutput(i, neuralNet.getOutputs(), normalization);
//…
  }
}</pre></div></div><div class="calibre2" title="Java implementation of weather forecasting"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec71" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Java implementation of weather forecasting</h2></div></div></div><p class="calibre11">In <a id="id367" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Java, we are going to use the package <code class="literal">edu.packt.neuralnet.chart</code> to plot some charts and visualize data. We're also downloading historical meteorology data from INMET, the Brazilian Institute of Meteorology. We've downloaded data from several cities, so we could have a variety of climates included in our weather forecasting case.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip18" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">In order to run the training expeditiously, we have selected a small period (5 years), which has more than 2,000 samples.</p></div></div></div><div class="calibre2" title="Collecting weather data"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec72" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Collecting weather data</h2></div></div></div><p class="calibre11">In this<a id="id368" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> example, we wanted to collect a variety of data from different places, to attest to the capacity of the neural network to forecast it. Since we downloaded it from the INMET website, which covers only Brazilian territory, only Brazilian cities are covered. However, it is a very vast territory with a great variety of climates. Below is a list of places we collected data from:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">#</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">City Name</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Latitude</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Longitude</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Altitude</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Climate Type</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">1</p>
</td><td class="calibre29">
<p class="calibre26">Cruzeiro do Sul</p>
</td><td class="calibre29">
<p class="calibre26">7º37'S</p>
</td><td class="calibre29">
<p class="calibre26">72º40'W</p>
</td><td class="calibre29">
<p class="calibre26">170 m</p>
</td><td class="calibre29">
<p class="calibre26">Tropical Rainforest</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">2</p>
</td><td class="calibre29">
<p class="calibre26">Picos</p>
</td><td class="calibre29">
<p class="calibre26">7º04'S</p>
</td><td class="calibre29">
<p class="calibre26">41º28'W</p>
</td><td class="calibre29">
<p class="calibre26">208 m</p>
</td><td class="calibre29">
<p class="calibre26">Semi-arid</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">3</p>
</td><td class="calibre29">
<p class="calibre26">Campos do Jordão</p>
</td><td class="calibre29">
<p class="calibre26">22º45'S</p>
</td><td class="calibre29">
<p class="calibre26">45º36'W</p>
</td><td class="calibre29">
<p class="calibre26">1642 m</p>
</td><td class="calibre29">
<p class="calibre26">Subtropical Highland </p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">4</p>
</td><td class="calibre29">
<p class="calibre26">Porto Alegre</p>
</td><td class="calibre29">
<p class="calibre26">30º01'S</p>
</td><td class="calibre29">
<p class="calibre26">51º13'W</p>
</td><td class="calibre29">
<p class="calibre26">48 m</p>
</td><td class="calibre29">
<p class="calibre26">Subtropical Humid</p>
</td></tr></tbody></table></div><p class="calibre11">The location of these four cities is indicated on the map below:</p><div class="mediaobject"><img src="Images/B05964_05_14.jpg" alt="Collecting weather data" class="calibre168"/><div class="caption"><p class="calibre169">Source: Wikipedia, user NordNordWest using United States National Imagery and Mapping Agency data, World Data Base II data</p></div></div><p class="calibre11">The <a id="id369" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>weather data collected is from January 2010 until November 2016 and is saved in the data folder with the name corresponding to the city.</p><p class="calibre11">The data collected from the INMET website includes these variables:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Precipitation (mm)</li><li class="listitem">Max. temperature (ºC)</li><li class="listitem">Min. temperature (ºC)</li><li class="listitem">Insolation (sunny hours)</li><li class="listitem">Evaporation (mm)</li><li class="listitem">Avg. temperature (ºC)</li><li class="listitem">Avg. humidity (%)</li><li class="listitem">Avg. wind speed (mph)</li><li class="listitem">Date (converted into Excel number format)</li><li class="listitem">Position of the station (latitude, longitude, and altitude)</li></ul></div><p class="calibre11">For each city, we are going to build a neural network to forecast the weather based on the past. But first, we need to point out two important facts:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Cities located in high latitudes experience high weather variations due to the seasons; that is, the weather will be dependent on the date</li><li class="listitem">The weather is a very dynamic system whose variables are influenced by past values</li></ul></div><p class="calibre11">To overcome the first issue, we may derive a new column from the date to indicate the solar<a id="id370" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> noon angle, which is the angle at which the solar rays reach the surface at the city at the highest point in the sky (noon). The greater this angle, the more intense and warm the solar radiation is; on the other hand, when this angle is small, the surface will receive a small fraction of the solar radiation:</p><div class="mediaobject"><img src="Images/B05964_05_15.jpg" alt="Collecting weather data" class="calibre170"/></div><p class="calibre11">The solar noon angle is calculated by the following formula and Java implementation in the class <code class="literal">WeatherExample</code>, which will be used in this chapter:</p><div class="mediaobject"><img src="Images/B05964_05_16.jpg" alt="Collecting weather data" class="calibre171"/></div><div class="calibre2"><pre class="programlisting">public double calcSolarNoonAngle(double date,double latitude){
  return 90-Math.abs(-23.44*Math.cos((2*Math.PI/365.25)*(date+8.5))-latitude);
}
public void addSolarNoonAngle(TimeSeries ts,double latitude){// to add column
  double[] sna = new double[ts.numberOfRecords];
  for(int i=0;i&lt;ts.numberOfRecords;i++)
    sna[i]=calcSolarNoonAngle(
               ts.data.get(i).get(ts.getIndexColumn()), latitude);
  ts.addColumn(sna, "NoonAngle");
}</pre></div></div><div class="calibre2" title="Delaying variables"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec73" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Delaying variables</h2></div></div></div><p class="calibre11">In the class <code class="literal">WeatherExample</code>, let's place a method called <code class="literal">makeDelays</code>, which will later be called from <a id="id371" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the main method. The delays will be made on a given <code class="literal">TimeSeries</code> and up to a given number for all columns of the time series except that of the index column:</p><div class="calibre2"><pre class="programlisting">public void makeDelays(TimeSeries ts,int maxdelays){
  for(int i=0;i&lt;ts.numberOfColumns;i++)
    if(i!=ts.getIndexColumn())
      for(int j=1;j&lt;=maxdelays;j++)
        ts.shift(i, -j);
  }</pre></div><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip19" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">Be careful not to call this method multiple times; it may delay the same column over and over again.</p></div></div></div><div class="calibre2" title="Loading the data and beginning to play!"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec74" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Loading the data and beginning to play!</h2></div></div></div><p class="calibre11">In the <code class="literal">WeatherExample</code> class, we <a id="id372" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>are going to add four <code class="literal">TimeSeries</code> properties<a id="id373" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> and four <code class="literal">NeuralNet</code> properties for each case:</p><div class="calibre2"><pre class="programlisting">public class WeatherExample {

    TimeSeries cruzeirodosul;
    TimeSeries picos;
    TimeSeries camposdojordao;
    TimeSeries portoalegre;
    
    NeuralNet nncruzeirosul;
    NeuralNet nnpicos;
    NeuralNet nncamposjordao;
    NeuralNet nnportoalegre;
//…
}</pre></div><p class="calibre11">In the <code class="literal">main</code> method, we<a id="id374" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> load data to each of them and delay the <a id="id375" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>columns up to three days before:</p><div class="calibre2"><pre class="programlisting">public static void main(String[] args) {
  WeatherExample we = new WeatherExample();
  //load weather data
  we.cruzeirodosul = new TimeSeries(LoadCsv.getDataSet("data", "cruzeirodosul2010daily.txt", true, ";"));
  we.cruzeirodosul.setIndexColumn(0);
  we.makeDelays(we.cruzeirodosul, 3);
        
  we.picos = new TimeSeries(LoadCsv.getDataSet("data", "picos2010daily.txt", true, ";"));
  we.picos.setIndexColumn(0);
  we.makeDelays(we.picos, 3);
       
  we.camposdojordao = new TimeSeries(LoadCsv.getDataSet("data", "camposdojordao2010daily.txt", true, ";"));
  we.camposdojordao.setIndexColumn(0);
  we.makeDelays(we.camposdojordao, 3);
        
  we.portoalegre = new TimeSeries(LoadCsv.getDataSet("data", "portoalegre2010daily.txt", true, ";"));
  we.portoalegre.setIndexColumn(0);
  we.makeDelays(we.portoalegre, 3);
//…</pre></div><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip20" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">This piece of code can take a couple of minutes to execute, given that each file may have more than 2,000 rows.</p></div></div><p class="calibre11">After loading, we need to remove the NaNs, so we call the method <code class="literal">dropNaN</code> from each time series object:</p><div class="calibre2"><pre class="programlisting">  //…
  we.cruzeirodosul.dropNaN();
  we.camposdojordao.dropNaN();
  we.picos.dropNaN();
  we.portoalegre.dropNaN();
  //…</pre></div><p class="calibre11">To save time and effort for future executions, let's save these datasets:</p><div class="calibre2"><pre class="programlisting">we.cruzeirodosul.save("data","cruzeirodosul2010daily_delays_clean.txt",";");
//…
we.portoalegre.save("data","portoalegre2010daily_delays_clean.txt",";");</pre></div><p class="calibre11">Now, for all-time series, each column has three delays, and we want the neural network to forecast the<a id="id376" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> maximum and minimum temperature <a id="id377" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of the next day. We can forecast the future by taking into account only the present and the past, so for inputs we must rely on the delayed data (from -1 to -3 days before), and for outputs we may consider the current temperature values. Each column in the time series dataset is indicated by an index, where zero is the index of the date. Since some of the datasets had missing data on certain columns, the index of a column may vary. However, the index for output variables is the same through all datasets (indexes 2 and 3).</p></div><div class="calibre2" title="Let's perform a correlation analysis"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec75" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Let's perform a correlation analysis</h2></div></div></div><p class="calibre11">We are<a id="id378" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> interested in finding patterns between the delayed data and the current maximum and minimum temperature. So we perform a cross-correlation analysis combining all output and potential input variables, and select the variables that present at least a minimum absolute correlation as a threshold. So we write a method <code class="literal">correlationAnalysis</code> taking the minimum absolute correlation as the argument. To save space, we have trimmed the code here:</p><div class="calibre2"><pre class="programlisting">public void correlationAnalysis(double minAbsCorr){
  //indexes of output variables (max. and min. temperature) 
  int[][] outputs = { 
            {2,3}, //cruzeiro do sul
            {2,3}, //picos
            {2,3}, //campos do jordao
            {2,3}}; //porto alegre
  int[][] potentialInputs = { //indexes of input variables (delayed)
            {10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,38,39,40}, //cruzeiro do sul
            //… and all others
        };
  ArrayList&lt;ArrayList&lt;ArrayList&lt;Double&gt;&gt;&gt; chosenInputs = new ArrayList&lt;&gt;();
  TimeSeries[] tscollect = {this.cruzeirodosul,this.picos,this.camposdojordao,this.portoalegre};
  double[][][] correlation = new double[4][][];
  for(int i=0;i&lt;4;i++){
    chosenInputs.add(new ArrayList&lt;ArrayList&lt;Double&gt;&gt;());
    correlation[i]=new double[outputs[i].length][potentialInputs[i].length];
    for(int j=0;j&lt;outputs[i].length;j++){
      chosenInputs.get(i).add(new ArrayList&lt;Double&gt;());
      for(int k=0;k&lt;potentialInputs[i].length;k++){
        correlation[i][j][k]=tscollect[i].correlation(outputs[i][j], potentialInputs[i][k]);
        //if the absolute correlation is above the threshold
        if(Math.abs(correlation[i][j][k])&gt;minAbsCorr){
          //it is added to the chosen inputs
          chosenInputs.get(i).get(j).add(correlation[i][j][k]);
          //and we see the plot
          tscollect[i].getScatterChart("Correlation "+String.valueOf(correlation[i][j][k]), outputs[i][j], potentialInputs[i][k], Color.BLACK).setVisible(true);
        }
      }
    }
  }
}</pre></div><p class="calibre11">By<a id="id379" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> running this analysis, we receive the following result for Cruzeiro do Sul (the bold columns are chosen as neural network inputs):</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Correlation Analysis for data from Cruzeiro do Sul</p>
</th><th valign="bottom" class="calibre25"> </th></tr></thead><tbody class="calibre27"><tr class="calibre28"><td class="calibre29">
<p class="calibre26">Correlations with the output Variable: MaxTemp</p>
<p class="calibre26">  NoonAngle:0.0312808</p>
<p class="calibre26">  Precipitation__1:-0.115547</p>
<p class="calibre26">  Precipitation__2:-0.038969</p>
<p class="calibre26">  Precipitation__3:-0.062173</p>
<p class="calibre26">  MaxTemp__1:0.497057</p>
<p class="calibre26">  MaxTemp__2:0.252831</p>
<p class="calibre26">  MaxTemp__3:0.159098</p>
<p class="calibre26">  MinTemp__1:-0.033339</p>
<p class="calibre26">  MinTemp__2:-0.123063</p>
<p class="calibre26">  MinTemp__3:-0.125282</p>
<p class="calibre26">  Insolation__1:0.395741</p>
<p class="calibre26">  Insolation__2:0.197949</p>
<p class="calibre26">  Insolation__3:0.134345</p>
<p class="calibre26">  Evaporation__1:0.21548</p>
<p class="calibre26">  Evaporation__2:0.161384</p>
<p class="calibre26">  Evaporation__3:0.199385</p>
<p class="calibre26">  AvgTemp__1:0.432280</p>
<p class="calibre26">  AvgTemp__2:0.152103</p>
<p class="calibre26">  AvgTemp__3:0.060368</p>
<p class="calibre26">  AvgHumidity__1:-0.415812</p>
<p class="calibre26">  AvgHumidity__2:-0.265189</p>
<p class="calibre26">  AvgHumidity__3:-0.214624</p>
<p class="calibre26">  WindSpeed__1:-0.166418</p>
<p class="calibre26">  WindSpeed__2:-0.056825</p>
<p class="calibre26">  WindSpeed__3:-0.001660</p>
<p class="calibre26">  NoonAngle__1:0.0284473</p>
<p class="calibre26">  NoonAngle__2:0.0256710</p>
<p class="calibre26">  NoonAngle__3:0.0227864</p>
</td><td class="calibre29">
<p class="calibre26">Correlations with the output Variable: MinTemp</p>
<p class="calibre26">  NoonAngle:0.346545</p>
<p class="calibre26">  Precipitation__1:0.012696</p>
<p class="calibre26">  Precipitation__2:0.063303</p>
<p class="calibre26">  Precipitation__3:0.112842</p>
<p class="calibre26">  MaxTemp__1:0.311005</p>
<p class="calibre26">  MaxTemp__2:0.244364</p>
<p class="calibre26">  MaxTemp__3:0.123838</p>
<p class="calibre26">  MinTemp__1:0.757647</p>
<p class="calibre26">  MinTemp__2:0.567563</p>
<p class="calibre26">  MinTemp__3:0.429669</p>
<p class="calibre26">  Insolation__1:-0.10192</p>
<p class="calibre26">  Insolation__2:-0.101146</p>
<p class="calibre26">  Insolation__3:-0.151896</p>
<p class="calibre26">  Evaporation__1:-0.115236</p>
<p class="calibre26">  Evaporation__2:-0.160718</p>
<p class="calibre26">  Evaporation__3:-0.160536</p>
<p class="calibre26">  AvgTemp__1:0.633741</p>
<p class="calibre26">  AvgTemp__2:0.487609</p>
<p class="calibre26">  AvgTemp__3:0.312645</p>
<p class="calibre26">  AvgHumidity__1:0.151009</p>
<p class="calibre26">  AvgHumidity__2:0.155019</p>
<p class="calibre26">  AvgHumidity__3:0.177833</p>
<p class="calibre26">  WindSpeed__1:-0.198555</p>
<p class="calibre26">  WindSpeed__2:-0.227227</p>
<p class="calibre26">  WindSpeed__3:-0.185377</p>
<p class="calibre26">  NoonAngle__1:0.353834</p>
<p class="calibre26">  NoonAngle__2:0.360943</p>
<p class="calibre26">  NoonAngle__3:0.367953</p>
</td></tr></tbody></table></div><p class="calibre11">The scatter plots show how this data is related:</p><div class="mediaobject"><img src="Images/B05964_05_17.jpg" alt="Let's perform a correlation analysis" class="calibre172"/></div><p class="calibre11">On the <a id="id380" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>left, there is a fair correlation between the last day's maximum temperature and the current; in the center, a strong correlation between the last day's minimum temperature and the current; and on the right, a weak correlation between <code class="literal">NoonAngle</code> of 3 days before and the current minimum temperature. By running this analysis for all other cities, we determine the inputs for the other neural networks:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Cruzeiro do Sul</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Picos</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Campos do Jordão</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Porto Alegre</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre28"><td class="calibre29">
<p class="calibre26">NoonAngle </p>
<p class="calibre26">MaxTemp__1</p>
<p class="calibre26">MinTemp__1</p>
<p class="calibre26">MinTemp__2</p>
<p class="calibre26">MinTemp__3</p>
<p class="calibre26">Insolation__1</p>
<p class="calibre26">AvgTemp__1</p>
<p class="calibre26">AvgTemp__2</p>
<p class="calibre26">AvgHumidity__1</p>
<p class="calibre26">NoonAngle__1</p>
<p class="calibre26">NoonAngle__2</p>
<p class="calibre26">NoonAngle__3</p>
</td><td class="calibre29">
<p class="calibre26">MaxTemp</p>
<p class="calibre26">MaxTemp__1</p>
<p class="calibre26">MaxTemp__2</p>
<p class="calibre26">MaxTemp__3</p>
<p class="calibre26">MinTemp__1</p>
<p class="calibre26">MinTemp__2</p>
<p class="calibre26">MinTemp__3</p>
<p class="calibre26">Insolation__1</p>
<p class="calibre26">Insolation__2</p>
<p class="calibre26">Evaporation__1</p>
<p class="calibre26">Evaporation__2</p>
<p class="calibre26">Evaporation__3</p>
<p class="calibre26">AvgTemp__1</p>
<p class="calibre26">AvgTemp__2</p>
<p class="calibre26">AvgTemp__3</p>
<p class="calibre26">AvgHumidity__1</p>
<p class="calibre26">AvgHumidity__2</p>
<p class="calibre26">AvgHumidity__3</p>
</td><td class="calibre29">
<p class="calibre26">NoonAngle</p>
<p class="calibre26">MaxTemp__1</p>
<p class="calibre26">MaxTemp__2</p>
<p class="calibre26">MaxTemp__3</p>
<p class="calibre26">MinTemp__1</p>
<p class="calibre26">MinTemp__2</p>
<p class="calibre26">MinTemp__3</p>
<p class="calibre26">Evaporation__1</p>
<p class="calibre26">AvgTemp__1</p>
<p class="calibre26">AvgTemp__2</p>
<p class="calibre26">AvgTemp__3</p>
<p class="calibre26">AvgHumidity__1</p>
<p class="calibre26">NoonAngle__1</p>
<p class="calibre26">NoonAngle__2</p>
<p class="calibre26">NoonAngle__3</p>
</td><td class="calibre29">
<p class="calibre26">MaxTemp</p>
<p class="calibre26">NoonAngle</p>
<p class="calibre26">MaxTemp__1</p>
<p class="calibre26">MaxTemp__2</p>
<p class="calibre26">MaxTemp__3</p>
<p class="calibre26">MinTemp__1</p>
<p class="calibre26">MinTemp__2</p>
<p class="calibre26">MinTemp__3</p>
<p class="calibre26">Insolation__1</p>
<p class="calibre26">Insolation__2</p>
<p class="calibre26">Insolation__3</p>
<p class="calibre26">Evaporation__1</p>
<p class="calibre26">Evaporation__2</p>
<p class="calibre26">Evaporation__3</p>
<p class="calibre26">AvgTemp__1</p>
<p class="calibre26">AvgTemp__2</p>
<p class="calibre26">AvgTemp__3</p>
<p class="calibre26">AvgHumidity__1</p>
<p class="calibre26">AvgHumidity__2</p>
<p class="calibre26">NoonAngle__1</p>
<p class="calibre26">NoonAngle__2</p>
<p class="calibre26">NoonAngle__3</p>
</td></tr></tbody></table></div></div><div class="calibre2" title="Creating neural networks"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec76" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Creating neural networks</h2></div></div></div><p class="calibre11">We are <a id="id381" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>using four neural networks to forecast the minimum and maximum temperature. Initially, they will have two hidden layers with 20 and 10 neurons each and hypertan and sigmoid activation functions. We will apply min-max normalization. The following method in the class <code class="literal">WeatherExample</code> creates the neural networks with this configuration:</p><div class="calibre2"><pre class="programlisting">public void createNNs(){
 //fill a vector with the indexes of input and output columns
 int[] inputColumnsCS = {10,14,17,18,19,20,26,27,29,38,39,40};
 int[] outputColumnsCS = {2,3};
 //this static method hashes the dataset
 NeuralDataSet[] nnttCS = NeuralDataSet.randomSeparateTrainTest(this.cruzeirodosul, inputColumnsCS, outputColumnsCS, 0.7);
 //setting normalization
 DataNormalization.setNormalization(nnttCS, -1.0, 1.0);

 this.trainDataCS = nnttCS[0]; // 70% for training 
 this.testDataCS = nnttCS[1]; // rest for test
        
 //setup neural net parameters:
 this.nncruzeirosul = new NeuralNet( inputColumnsCS.length, outputColumnsCS.length, new int[]{20,10} 
    , new IActivationFunction[] {new HyperTan(1.0),new Sigmoid(1.0)}
    , new Linear()
    , new UniformInitialization(-1.0, 1.0) );
//…
}</pre></div></div><div class="calibre2" title="Training and test"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec77" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Training and test</h2></div></div></div><p class="calibre11">In <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch02.xhtml" title="Chapter 2. Getting Neural Networks to Learn">Chapter 2</a>, <span class="strong1"><em class="calibre16">Getting Neural Networks to Learn</em></span> we have seen that a neural network should be tested to <a id="id382" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>verify its learning, so we divide the dataset into<a id="id383" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> training and testing subsets. Usually about 50-80% of the original filtered dataset is used for training and the remaining fraction is for testing.</p><p class="calibre11">A static method <code class="literal">randomSeparateTrainTest</code> in the class <code class="literal">NeuralDataSet</code> separates the dataset into these two subsets. In order to ensure maximum generalization, the records of this dataset are hashed, as shown in the following figure:</p><div class="mediaobject"><img src="Images/B05964_05_18.jpg" alt="Training and test" class="calibre173"/></div><p class="calibre11">The records may be originally sequential, as in weather time series; if we hash them in random positions, the training and testing sets will contain records from all periods.</p><div class="calibre2" title="Training the neural network"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title7"><a id="ch05lvl3sec01" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Training the neural network</h3></div></div></div><p class="calibre11">The <a id="id384" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>neural network will be trained using the basic backpropagation algorithm. The following is a code sample for the dataset <code class="literal">Cruzeiro do Sul</code>:</p><div class="calibre2"><pre class="programlisting"> Backpropagation bpCS = new Backpropagation(we.nncruzeirosul
                ,we.trainDataCS
                ,LearningAlgorithm.LearningMode.BATCH);
 bpCS.setTestingDataSet(we.testDataCS);
 bpCS.setLearningRate(0.3);
 bpCS.setMaxEpochs(1000);
 bpCS.setMinOverallError(0.01); //normalized error
 bpCS.printTraining = true;
 bpCS.setMomentumRate( 0.3 );
        
 try{
   bpCS.forward();
   bpCS.train();

   System.out.println("Overall Error:"      + String.valueOf(bpCS.getOverallGeneralError()));
   System.out.println("Testing Error:"      + String.valueOf(bpCS.getTestingOverallGeneralError()));
   System.out.println("Min Overall Error:"  + String.valueOf(bpCS.getMinOverallError()));
   System.out.println("Epochs of training:" + String.valueOf(bpCS.getEpoch()));
 }
 catch(NeuralException ne){ }</pre></div></div><div class="calibre2" title="Plotting the error"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title7"><a id="ch05lvl3sec02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Plotting the error</h3></div></div></div><p class="calibre11">Using <a id="id385" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the <code class="literal">JFreeCharts</code> framework, we can plot error evolution for the training and testing datasets. There is a new method in the class <code class="literal">LearningAlogrithm</code> called <code class="literal">showErrorEvolution</code>, which is inherited and overridden by <code class="literal">BackPropagation</code>. To see the chart, just call as in the example:</p><div class="calibre2"><pre class="programlisting">//plot list of errors by epoch 
bpCS.showErrorEvolution();</pre></div><p class="calibre11">This will show a plot like the one shown in the following figure:</p><div class="mediaobject"><img src="Images/B05964_05_19.jpg" alt="Plotting the error" class="calibre174"/></div></div></div><div class="calibre2" title="Viewing the neural network output"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec78" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Viewing the neural network output</h2></div></div></div><p class="calibre11">Using this<a id="id386" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> same facility, it is easy to see and compare the neural network output. First, let's transform the neural network output into vector form and add to our dataset using the method <code class="literal">addColumn</code>. Let's name it <code class="literal">NeuralMinTemp</code> and <code class="literal">NeuralMaxTemp</code>:</p><div class="calibre2"><pre class="programlisting"> String[] neuralOutputs = { "NeuralMaxTemp", "NeuralMinTemp"};
 we.cruzeirodosul.addColumn(we.fullDataCS.getIthNeuralOutput(0), neuralOutputs[0]);
 we.cruzeirodosul.addColumn(we.fullDataCS.getIthNeuralOutput(1), neuralOutputs[1]);
 String[] comparison = {"MaxTemp","NeuralMaxTemp"};
 Paint[] comp_color = {Color.BLUE, Color.RED};
        
 final double minDate = 41200.0;
 final double maxDate = 41300.0;</pre></div><p class="calibre11">The class <code class="literal">TimeSeries</code> has a method called <code class="literal">getTimePlot</code>, which is used to plot variables over a specified range:</p><div class="calibre2"><pre class="programlisting">ChartFrame viewChart = we.cruzeirodosul.getTimePlot("Comparison", comparison, comp_color, minDate, maxDate);</pre></div><div class="mediaobject"><img src="Images/B05964_05_20.jpg" alt="Viewing the neural network output" class="calibre174"/></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Empirical design of neural networks"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch05lvl1sec40" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Empirical design of neural networks</h1></div></div></div><p class="calibre11">While using <a id="id387" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>neural networks in regression problems (that include prediction), there is no fixed number of hidden neurons, so usually the solver chooses an arbitrary number of neurons and then varies it according to the results produced by the networks created. This procedure may be repeated a number of times until a network with a satisfying criterion is found.</p><div class="calibre2" title="Designing experiments"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec79" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Designing experiments</h2></div></div></div><p class="calibre11">Experiments <a id="id388" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>can be made on the same training and test datasets, while varying other network parameters, such as learning rate, normalization, and the number of hidden units. The objective is to choose the neural network that presents the best performance from the experiments. The best performance is assigned to the network that presents a lower MSE error, but an analysis of generalization with test data is also useful.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip21" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">While designing experiments, consider always starting from a lower number of hidden neurons, since it is desirable to have a lower computational processing consumption.</p></div></div><p class="calibre11">The table<a id="id389" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> below shows the experiments have that been run for all cities:</p><div class="mediaobject"><img src="Images/B05964_05_21.jpg" alt="Designing experiments" class="calibre175"/></div></div><div class="calibre2" title="Results and simulations"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title5"><a id="ch05lvl2sec80" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Results and simulations</h2></div></div></div><p class="calibre11">In order to<a id="id390" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> facilitate the execution of experiments, we've<a id="id391" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> designed a Java Swing <span class="strong1"><strong class="calibre12">Graphical User Interface</strong></span> (<span class="strong1"><strong class="calibre12">GUI</strong></span>), with which it is possible to select neural network <a id="id392" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>parameters for training and the dataset.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title6"><a id="tip22" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tip</h3><p class="calibre17">This interface covers only neural networks with just one hidden layer; however, since the code is open, the implementation of a multilayer perceptron with multiple hidden layers is suggested as an exercise, as well as the choice of other algorithms for the training.</p><p class="calibre17">The charts show only the predicted maximum temperature; therefore, implementing an option for displaying the minimum temperature is also suggested.</p></div></div><p class="calibre11">After<a id="id393" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> selecting the parameters, training<a id="id394" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> begins when you click the <span class="strong1"><strong class="calibre12">Start Training</strong></span> button:</p><div class="mediaobject"><img src="Images/B05964_05_22.jpg" alt="Results and simulations" class="calibre176"/></div><p class="calibre11">After running 12 experiments, we found the following MSE training errors for each dataset:</p><div class="informaltable"><table border="1" class="calibre20"><colgroup class="calibre21"><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/><col class="calibre22"/></colgroup><thead class="calibre23"><tr class="calibre24"><th valign="bottom" class="calibre25">
<p class="calibre26">Experiment</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Cruzeiro do Sul</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Picos</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Campos do Jordão</p>
</th><th valign="bottom" class="calibre25">
<p class="calibre26">Porto Alegre</p>
</th></tr></thead><tbody class="calibre27"><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#1</p>
</td><td class="calibre29">
<p class="calibre26">0.130156</p>
</td><td class="calibre29">
<p class="calibre26">0.147111</p>
</td><td class="calibre29">
<p class="calibre26">0.300437</p>
</td><td class="calibre29">
<p class="calibre26">0.323342</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#2</p>
</td><td class="calibre29">
<p class="calibre26">0.512389</p>
</td><td class="calibre29">
<p class="calibre26">0.572588</p>
</td><td class="calibre29">
<p class="calibre26">0.428692</p>
</td><td class="calibre29">
<p class="calibre26">0.478379</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#3</p>
</td><td class="calibre29">
<p class="calibre26">0.08659</p>
</td><td class="calibre29">
<p class="calibre26">0.094822</p>
</td><td class="calibre29">
<p class="calibre26">0.124752</p>
</td><td class="calibre29">
<p class="calibre26">0.114486</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#4</p>
</td><td class="calibre29">
<p class="calibre26">0.360728</p>
</td><td class="calibre29">
<p class="calibre26">0.258596</p>
</td><td class="calibre29">
<p class="calibre26">0.168351</p>
</td><td class="calibre29">
<p class="calibre26">0.192012</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#5</p>
</td><td class="calibre29">
<p class="calibre26">0.076476</p>
</td><td class="calibre29">
<p class="calibre26">0.074777</p>
</td><td class="calibre29">
<p class="calibre26">0.108991</p>
</td><td class="calibre29">
<p class="calibre26">0.085029</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#6</p>
</td><td class="calibre29">
<p class="calibre26">0.328493</p>
</td><td class="calibre29">
<p class="calibre26">0.186793</p>
</td><td class="calibre29">
<p class="calibre26">0.152499</p>
</td><td class="calibre29">
<p class="calibre26">0.151248</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#7</p>
</td><td class="calibre29">
<p class="calibre26">0.146801</p>
</td><td class="calibre29">
<p class="calibre26">0.130004</p>
</td><td class="calibre29">
<p class="calibre26">0.277765</p>
</td><td class="calibre29">
<p class="calibre26">0.19076</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#8</p>
</td><td class="calibre29">
<p class="calibre26">0.431811</p>
</td><td class="calibre29">
<p class="calibre26">0.29629</p>
</td><td class="calibre29">
<p class="calibre26">0.364418</p>
</td><td class="calibre29">
<p class="calibre26">0.278864</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#9</p>
</td><td class="calibre29">
<p class="calibre26">0.071135</p>
</td><td class="calibre29">
<p class="calibre26">0.081159</p>
</td><td class="calibre29">
<p class="calibre26">0.117634</p>
</td><td class="calibre29">
<p class="calibre26">0.091174</p>
</td></tr><tr class="calibre34"><td class="calibre29">
<p class="calibre26">#10</p>
</td><td class="calibre29">
<p class="calibre26">0.332534</p>
</td><td class="calibre29">
<p class="calibre26">0.210107</p>
</td><td class="calibre29">
<p class="calibre26">0.170179</p>
</td><td class="calibre29">
<p class="calibre26">0.164179</p>
</td></tr><tr class="calibre31"><td class="calibre29">
<p class="calibre26">#11</p>
</td><td class="calibre29">
<p class="calibre26">0.07247</p>
</td><td class="calibre29">
<p class="calibre26">0.089069</p>
</td><td class="calibre29">
<p class="calibre26">0.102137</p>
</td><td class="calibre29">
<p class="calibre26">0.076578</p>
</td></tr><tr class="calibre37"><td class="calibre29">
<p class="calibre26">#12</p>
</td><td class="calibre29">
<p class="calibre26">0.33342</p>
</td><td class="calibre29">
<p class="calibre26">0.19835</p>
</td><td class="calibre29">
<p class="calibre26">0.155036</p>
</td><td class="calibre29">
<p class="calibre26">0.145843</p>
</td></tr></tbody></table></div><p class="calibre11">The MSE error<a id="id395" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> information only gives us an idea <a id="id396" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of how much the neural network output could match real data in the overall context. This performance can be verified by viewing the time series comparison and scatter plots:</p><div class="mediaobject"><img src="Images/B05964_05_24.jpg" alt="Results and simulations" class="calibre177"/></div><p class="calibre11">These charts<a id="id397" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> show that, although in many cases<a id="id398" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the temperature cannot be accurately predicted, a trend is being followed. This can be attested to by the correlation visible in the scatter plots. The last row of the table, showing the prediction for Porto Alegre, which has a subtropical climate and high temperature variations, shows a good prediction even for the extreme temperature variations. However, we remind the reader that forecasting weather needs to consider many additional variables, which could not be included in this example due to availability constraints. Anyway, the results show we've made a good start to search for a neural network configuration that can outperform these ones found.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch05lvl1sec41" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Summary</h1></div></div></div><p class="calibre11">In this chapter, we've seen an interesting practical use case for the application of neural networks. Weather forecasting has always been a rich research field, and indeed neural networks are widely used for this purpose. In this chapter, the reader also learned how to prepare similar experiments for prediction problems. The correct application of techniques for data selection and preprocessing can save a lot of time while designing neural networks for prediction. This chapter also served as a foundation for the next ones, since all of them will focus on practical cases; thus, the concepts learned herein will be explored widely in the rest of the book.</p></div></div>



  </body></html>