- en: Pole-Balancing Experiments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about a classic reinforcement learning experiment,
    which is also an established benchmark for testing various implementations of
    the control strategies. In this chapter, we consider three modifications of the
    cart-pole balancing experiment and develop control strategies that can be used
    to stabilize the cart-pole apparatuses of given configurations. You will learn
    how to write accurate simulations of real-life physical systems and how to use
    them for a definition of the objective function for the NEAT algorithm. After
    this chapter, you will be ready to apply the NEAT algorithm to implement controllers
    that can be directly used to control physical appliances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The single-pole balancing problem in reinforcement learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of the simulator of the cart-pole apparatus in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define the objective function of a single-pole balancing controller using
    the simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peculiarities of the double-pole balancing problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of the simulator of the cart-pole apparatus with two poles in
    Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define the objective function for the double-pole balancing controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following technical requirements should be met to execute the experiments
    described in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8/10, macOS 10.13 or newer, modern Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anaconda Distribution version 2019.03 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4)
  prefs: []
  type: TYPE_NORMAL
- en: The single-pole balancing problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The single-pole balancer (or *inverted pendulum*) is an unstable pendulum that
    has its center of mass above its pivot point. It can be stabilized by applying
    external forces under the control of a specialized system that monitors the angle
    of the pole and moves the pivot point horizontally back and forth under the center
    of mass as it starts to fall. The single-pole balancer is a classic problem in
    dynamics and control theory that is used as a benchmark for testing control strategies,
    including strategies based on reinforcement learning methods. We are particularly
    interested in the implementation of the specific control algorithm that uses neuroevolution-based
    methods to stabilize the inverted pendulum for a given amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The experiment described in this chapter considers the simulation of the inverted
    pendulum implemented as a cart that can move horizontally with a pivot point mounted
    on top of it, that is, the cart and pole apparatus. The apparatus is shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04194552-ebae-4b1d-9065-f5b8b24bd0d3.png)'
  prefs: []
  type: TYPE_IMG
- en: The cart and single-pole apparatus
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing the source code of the simulator, we need to determine
    the equation of motion that can be used to estimate the values of the state variables
    of the pole balancer at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: The equations of motion of the single-pole balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the controller is to exert a sequence of forces, ![](img/da59aea6-7aaf-4dcc-b9b9-71b57429240c.png),
    on the center of mass of the cart such that the pole balanced for a specific (or
    infinite) amount of time and the cart stays within the track, that is, doesn't
    hit left or right walls. Taking into account the mechanics described here, we
    can qualify the pole-balancing task as an *avoidance control problem*, because
    the state of the cart-pole apparatus must be maintained to avoid certain regions
    of the state space. No unique solution exists for appropriate state estimation,
    and any solution of equations of motion that enables the avoidance of certain
    regions is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The learning algorithm needs to receive a minimal amount of knowledge about
    the task from the environment to train the pole-balancing controller. Such knowledge
    should reflect how close our controller is to the goal. The goal of the pole-balancing
    problem is to stabilize an inherently unstable system and keep it balanced for
    as long as possible. Thus, the reinforcement signal (![](img/26ea1e55-3d34-4214-8331-06b49b30babf.png))
    received from the environment must reflect the occurrence of a failure. The failure
    can be caused either by the pole falling past a predefined angle or the cart hitting
    the boundaries of the track. The reinforcement signal, ![](img/bd9c30b3-3068-43dd-b7d3-1095f8352daf.png),
    can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d4d96cc-9586-408a-a885-40932a4e22cf.png)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, ![](img/d8e041b6-58a4-4246-a4a9-573157c6ed86.png) is the angle
    between the pole and vertical positive in a clockwise direction, and ![](img/2396aff1-1592-49c4-a48d-8ff923372a48.png)
    is the horizontal position of the cart relative to the track.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reinforcement signal, ![](img/8dab6ab8-0563-45f3-9987-f3b998fd51a9.png),
    doesn't depend on either the angular pole velocity (![](img/3a0f38ae-f21b-4581-98b9-2519f93c205f.png))
    or the horizontal cart speed (![](img/69dc9bb7-9be3-4dc6-b951-1dcc2e2483a8.png)).
    It only provides information on whether the dynamics of the cart-pole system is
    within defined constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The motion-dynamic equations for the cart-pole system, ignoring friction, are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b872602d-f323-45d6-bd34-bf79162e33db.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/569d99aa-eb6f-4478-b2ab-cf9019ff492c.png)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, ![](img/a74032f1-8797-452d-aba9-88d20e0a3138.png) is the angular
    velocity of the pole, and ![](img/a563f582-b8d8-459d-8399-b1d20863f099.png) is
    the angular acceleration of the pole. Furthermore, ![](img/75f31906-f413-4400-9508-27f1c3d199c4.png)
    is the horizontal velocity of the cart and ![](img/f4d891cd-5fec-4d08-b2ab-70bf4e6c49d3.png)
    is the acceleration of the cart along the ![](img/5bc9487f-6bb1-4e33-9c68-c8b5040bf8c5.png)-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our experiment, the following system parameters are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3b5660e-a3be-4e08-9895-3ca305f63b0a.png)  is the mass of the cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6fc8f666-84e7-4697-8c44-6e6e6b42a62d.png)  is the mass of the pole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0c6ee46a-7895-45dd-8f53-a40ee215dfb7.png)  is the distance from the
    center of mass of the pole to the pivot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/766ff045-f59f-45b1-a859-2f2276c99c6d.png) is the acceleration due to
    gravity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State equations and control actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cart-pole system for the experiment is simulated by numerically approximating
    the equations of motion using Euler''s method with a time step of ![](img/15d32731-3561-401b-8c1f-2572a9e32d62.png)
    seconds. Thus, the state equations can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb31ceb3-2e5c-4a37-a79b-7971acad5a74.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/9ab5e970-1363-42a8-a143-6065a69b8222.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/db3b725e-234b-4f0a-810a-614033f041c7.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/9f5d47cd-9318-4420-8c73-3c4928712df9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a small range of pole angles, as used in our experiment, we can use the
    linear approximation of the surface that divides the space of all possible states
    of the system that require different actions (the switching surface). Thus, the
    action space consists of left and right push actions. The cart-pole controller
    that we use in our experiment is not designed to produce a zero force. Instead,
    at each time step, ![](img/a9bcebe7-b837-4fb4-94c3-8321270bb1d5.png), it applies
    a force to the cart''s center of mass with equal amplitude, but in the opposite
    direction. Such a control system has a name (*bang-bang controller*) and can be
    defined with the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0b8468b-d784-4fd5-b5fa-773694a2f120.png)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, ![](img/96c1b1e3-df69-433d-b53c-a747378fe6f6.png) is an action
    signal received from the solver. Given the action value, the bang-bang controller
    applies the force, ![](img/a7c80f82-cb8e-4b5b-b2f0-6902d406c4bb.png), of the same
    magnitude (`10` Newtons) but in the opposite direction, depending on the action
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: The interactions between the solver and the simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solver receives scaled values of the state variables described previously
    at each given time, ![](img/bad9077a-b37c-4c92-ab5e-c3ce78033789.png). These values
    serve as inputs to the ANNs created from the phenotypes of the solver genomes
    and are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27403595-0fc3-41f3-9f56-f017f9ac11d8.png),'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a96e3891-a4dc-45bc-816f-19edc4c593b9.png),'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7aed04f2-fdda-4b48-b276-6f3591bca4c8.png),'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f6d4b84-7103-4c6a-a5b2-eb32f337b7e6.png),'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ec11018-42cc-4fbe-b4f4-3c52ddebbab5.png).'
  prefs: []
  type: TYPE_NORMAL
- en: In the first equation, ![](img/1029b3f4-cc37-405c-8a2e-cb1fcd3e1c8f.png) is
    a constant bias value and ![](img/bed0a79c-afd6-4d3e-954e-bf18119af381.png) correspond
    to the cart's horizontal position, its horizontal speed, the pole angle from vertical,
    and its angular speed, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking into account the system constraints defined previously (see ![](img/5405e25b-263b-4b23-9a7c-bb926b1f6e7f.png)),
    the scaled values of ![](img/0020bc36-496d-45a9-a6cb-e07d173269f6.png) and ![](img/92d3c005-8913-4062-a2cd-0875e6ffcdde.png)
    are guaranteed to be within the `[0,1]` range, while the scaled values of ![](img/88387d60-8a76-48dd-95ac-74cfaf15c01b.png)
    and ![](img/94eef5a7-8b78-44aa-95ce-e3ad28939679.png) mostly fall within the `[0,1]` range,
    but can fall outside these bounds eventually. The state variables are scaled to
    accomplish the two essential goals:'
  prefs: []
  type: TYPE_NORMAL
- en: To remove the learning bias that can arise when terms with predominantly large
    magnitudes have a more significant impact on the learner due to the rounding effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this particular task, since the values of state variables are centered around
    zero, it is possible to find an ANN solver that doesn't need any hidden units.
    However, we are interested in evolving the topology of neural networks with the
    NEAT algorithm. The introduced scaling scheme ensures that the neuroevolution
    process eventually produces phenotypes that encode the hidden units.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pole-balancing controller takes the scaled inputs and produces an output
    that is a binary value determining the action to be applied at time ***t***, as
    discussed earlier. The sampling rate of the state variables of the cart-pole system
    and the rate at which the control force is applied are the same as the simulation
    rate, ![](img/f6062caf-1343-4a5e-ad79-7a21226005d7.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the initial configuration of the controller''s ANN can be depicted as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1664e358-d178-4ce9-8b25-1ff3c52f5243.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial ANN configuration of a single-pole balancing controller
  prefs: []
  type: TYPE_NORMAL
- en: The initial configuration of the single-pole balancing controller's ANN includes
    five input nodes for the horizontal position of the cart (**x1**) and its velocity
    (**x2**), for the vertical angle of the pole (**x3**) and its angular velocity (**x4**),
    and an additional input node for bias (**x0**) (*which can be optional depending
    on the particular NEAT library used*). The output node (**a**) is a binary node
    providing the control signal to the [`0` or `1`] application. The hidden node
    (**h**) is optional and can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Objective function for a single-pole balancing experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our goal is to create a pole balancing controller that''s able to maintain
    a system in a stable state within defined constraints for as long as possible,
    but at least for the expected number of time steps specified in the experiment
    configuration (500,000). Thus, the objective function must optimize the duration
    of stable pole-balancing and can be defined as the logarithmic difference between
    the expected number of steps and the actual number of steps obtained during the
    evaluation of the phenotype ANN. The loss function is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6168406-2921-4200-b53b-075bb365fc0b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this experiment, ![](img/bf1d2e38-3978-46e1-bcca-2642dc98a7fb.png) is the
    expected number of time steps from the configuration of the experiment, and ![](img/4e8600b4-f33e-4657-bc81-b0d5d52cef57.png)
    is the actual number of time steps during which the controller was able to maintain
    a stable pole balancer state within allowed bounds (refer to the reinforcement
    signal definition for details about permissible bounds).
  prefs: []
  type: TYPE_NORMAL
- en: Cart-pole apparatus simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The given definition of the objective function assumes that we can measure the
    number of time steps during which the single-pole balancer was in a stable state.
    To perform such measurements, we need to implement the simulator of the cart-pole
    apparatus, using the equations of motion and data constraints defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter4).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a file called `cart_pole.py` in the `work` directory.
    This file contains the source code of the equations of motion and the function
    for evaluating the fitness of a single-pole balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a definition of the constants describing the physics of the cart-pole
    apparatus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are ready to implement the equations of motion using these constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the `do_step(action, x, x_dot, theta, theta_dot)` function implementation
    in the source code of this chapter for full details.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet uses the current system state (`x, x_dot, theta,
    theta_dot`) along with a control action as input and applies the equations of
    motion described earlier to update the system state for the next time step. The
    updated system state then returns to update the simulator and to check for constraint
    violations. Thus, the simulation cycle is organized, as described in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The simulation cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have fully implemented the equations of motion and the numerical approximation
    of the state variables for one step of the cart-pole apparatus simulation. With
    this, we are ready to start the implementation of a full simulation cycle, which
    uses the ANN of the controller to evaluate the current system state and to select
    the appropriate action (the force to be applied) for the next step. The ANN mentioned
    previously is created for each genome of the population for a particular generation
    of evolution, allowing us to evaluate the performance of all genomes.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the `run_cart_pole_simulation(net, max_bal_steps, random_start=True)`
    function implementation for complete implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refer to the following steps to perform the implementation of a full
    simulation cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to initialize the initial state variables, either with zeros
    or with random values within the constraints described previously and centered
    around zero. The random state values can be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We intentionally reduced the range of all values compared to the corresponding
    scaled constraints to make sure that the algorithm does not start in the critical
    state, that is, when stabilization is no longer possible.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we are ready to start the simulation cycle over the defined number
    of steps, which are specified by the `max_bal_steps` parameter. The following code is
    executed inside the *simulation loop*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The state variables need to be scaled to fit into the `[0,1]` range before
    being loaded as inputs into the ANN of the controller. This procedure has a computational
    and evolutionary advantage, as previously described. The bias value is not explicitly
    provided because the NEAT-Python framework handles it internally, so the inputs
    of the ANN can be defined as follows in the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the scaled inputs can be used to activate the ANN of the phenotype, and
    its output is used to produce a discrete value of the action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the produced value of the action and the current values of the state variables,
    you can run a single step of the cart-pole simulation. After the simulation step,
    the returned state variables are tested against the constraints to check whether
    the state of the system is still within the boundaries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In case of failure, the current number of simulation steps is returned, and
    its value will be used to evaluate the fitness of the phenotype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the controller's ANN was able to maintain a stable state of the cart-pole
    apparatus balancing for all simulation steps, the value with the maximum number
    of simulation steps is returned by the `run_cart_pole_simulation` function.
  prefs: []
  type: TYPE_NORMAL
- en: Genome fitness evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the number of successful simulation steps returned by the `run_cart_pole_simulation`
    function described earlier, we are ready to implement the genome fitness evaluation
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we run the cart-pole simulation loop, which returns the number of successful
    simulation steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are ready to evaluate the fitness score of the particular genome,
    as described previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the `eval_fitness(net, max_bal_steps=500000)` function for more details.
  prefs: []
  type: TYPE_NORMAL
- en: We use a logarithmic scale because most simulation runs fail in about 100 steps,
    but we test against `500000` balancing steps.
  prefs: []
  type: TYPE_NORMAL
- en: The single-pole balancing experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an objective function defined and implemented along with a
    simulation of cart-pole apparatus dynamics, we are ready to start writing the
    source code to run the neuroevolutionary process with the NEAT algorithm. We will
    use the same NEAT-Python library as in the XOR experiment in the previous chapter,
    but with the NEAT hyperparameters adjusted appropriately. The hyperparameters
    are stored in the `single_pole_config.ini`file, which can be found in the source
    code repository related to this chapter. You need to copy this file into your
    local `Chapter4` directory, in which you already should have a Python script with
    the cart-pole simulator we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the NEAT section of the configuration file, we define the population of organisms
    set to ![](img/213bc840-04cb-428f-bd8f-84a908f856ae.png) individuals, and the
    fitness threshold with a value of `1.0` as a termination criterion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fitness_criterion` is set to `max`, which means that the evolutionary
    process terminates when any individual reaches a fitness score equal to the `fitness_threshold` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Also, we significantly decreased the probability of adding the new node to bias
    the evolutionary process into elaborating more on the connectivity patterns with
    a minimal number of ANN nodes in the controller. Thus, we aim to reduce the energy
    consumption of the evolved controller's ANN and to reduce the computational costs
    of training.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding parameters in the configuration file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters describing our initial network configuration by a count of hidden,
    input, and output nodes are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We increased the species' compatibility threshold to bias the evolutionary process
    into producing fewer species. Also, we increased the minimum species' size to
    indicate that we are interested in much more highly populated species that have
    a bigger chance of preserving beneficial mutations. At the same time, we decreased
    the maximal stagnation age to intensify the evolutionary process by heightening
    the early extinction of stagnated species that do not show any fitness improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The related parameters in the configuration file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the `single_pole_config.ini` configuration file for full details.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the configuration parameters, more populated species will be
    used during the evolutionary process; however, the number of unique species will
    be kept low.
  prefs: []
  type: TYPE_NORMAL
- en: Working environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start writing the source code of the experiment runner, you must
    set up a virtual Python environment and install all the necessary dependencies.
    You can do this with Anaconda by executing the following commands in the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, these commands create and activate a `single_pole_neat` virtual environment
    with Python 3.5\. After that, the NEAT-Python library, version 0.92, is installed,
    along with the other dependencies used by our visualization utilities.
  prefs: []
  type: TYPE_NORMAL
- en: The experiment runner implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, you need to create a `single_pole_experiment.py` file in the `Chapter4` directory.
    In that file, the source code of the single-pole balancing experiment will be
    written. Also, you need to copy the `visualize.py` file from the chapter's repository
    into this directory as well. We will use the visualization utilities from this
    file to render the results of the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: The experiment runner script includes two essential functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function to evaluate the fitness of all genomes in the population
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first function evaluates the list of all genomes in the population and
    assigns a fitness score to each of them. This function is passed by reference
    into the neuroevolution runner of the NEAT-Python library. The source code of
    this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are introducing additional simulation runs for the winning genome
    to make sure that its control strategy is stable when starting from a variety
    of random initial states. This additional check guarantees that we have found
    the real winner rather than a special case that's specific to a particular initial
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding function receives the list of all genomes in the population and
    the NEAT configuration parameters. For each specific genome, it creates the phenotype
    ANN and uses it as a controller to run the cart-pole apparatus simulation, as
    defined in the following snippet from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned fitness score is then compared with the fitness threshold value
    we defined in the configuration parameters. If it exceeds the threshold, we can
    assume that a successful controller was found. To further verify the validity
    of the found controller, it will be tested for additional simulation runs and
    a final fitness score will be calculated (as in the following snippet taken from
    the preceding code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The additional simulation steps will use different seeds for a random number
    generator to cover the majority of possible initial configurations of the cart-pole
    apparatus.
  prefs: []
  type: TYPE_NORMAL
- en: The experiment runner function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second function configures, executes, and outputs the results of the neuroevolution
    process. Here, we outline some critical places in the implementation of the experiment
    runner function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function begins with the loading of the hyperparameters from the configuration
    file and spawns the initial population using the loaded configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, it configures statistics'' reporters to collect the statistics regarding
    execution of the evolutionary process. The output reporters are added as well
    in order to output the execution results to the console in real time. The checkpoints
    collector is also configured to save intermediary stages of execution, which can
    be useful if you need to restore the training process later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the evolution process is executed over the specified number of generations,
    and the results are saved in the `output` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the `run_experiment(config_file, n_generations=100)` function for full
    implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: After the best genome has been found during the evolutionary process, it is
    verified whether it actually meets the fitness threshold criteria that we set
    in the configuration file. There may be no working solution found during the process,
    but nevertheless, the NEAT-Python library will return the best fit genome. That
    is why we need this additional check to ensure that the resulting best fit genome
    can actually solve the problem in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Running the single-pole balancing experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to enter the directory containing the `single_pole_experiment.py` file
    and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to activate the appropriate virtual environment with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conda activate single_pole_neat`'
  prefs: []
  type: TYPE_NORMAL
- en: 'During the execution of the Python script, the console will print the following
    output for each generation of the evolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you can see that the average fitness of the population in generation
    `14` is low, but the fitness of the best performing organism (`0.70923`) is already
    close to our completion threshold value (`fitness_threshold = 1.0`), which was
    set in the configuration file. The organism champion encodes the phenotype ANN
    that consists of one non-linear node (output) and only two connections (`size:
    (1, 2)`). Also, it is interesting to note that only one species exists in the
    population.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the winner is found, the console output has the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The best genome that is an evolution winner encodes a phenotype ANN that consists
    of only one non-linear node (output) and three connections from input nodes (`size:
    (1, 3)`). It is interesting to note that evolution was able to produce a solid
    control strategy that completely ignores the linear velocity of the cart and only
    uses the other three inputs: `x`, `θ`, and `θ`. This fact is another sign of the
    correctness of the evolutionary selection because we decided to ignore friction
    of the cart, which effectively excluded the linear velocity of the cart from the
    equations of motion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph with ANN of winning single-pole balancing controller is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94084e5e-4ec0-4bad-89ac-5f47182ac36e.png)'
  prefs: []
  type: TYPE_IMG
- en: The ANN of the single-pole balancing controller found by the NEAT algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot with the changes in fitness value over generations of evolution is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/115564ed-987f-4fac-b451-982f0d357b05.png)'
  prefs: []
  type: TYPE_IMG
- en: The population's average and best fitness in the single-pole experiment
  prefs: []
  type: TYPE_NORMAL
- en: The average fitness of the population in all generations was low, but from the
    very beginning, there was a beneficial mutation that spawned a particular lineage
    of organisms. From generation to generation, gifted individuals from that lineage
    were able not only to preserve their beneficial traits but also to improve them,
    which ultimately led to finding an evolution winner.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to increase the value of the `node_add_prob` parameter and see what happens.
    Does the algorithm produce any number of hidden nodes, and if so, how many?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to decrease/increase the `compatibility_threshold` value. What happens if
    you set it to `2.0` or `6.0`? Can the algorithm find the solution in each case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to set the `elitism` value to zero in the `DefaultReproduction` section.
    See what happens. How long did the evolutionary process take to find an acceptable
    solution in this case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `survival_threshold` value to `0.5` in the `DefaultReproduction` section.
    See how this affects speciation during evolution. Why does it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the `additional_num_runs` and `additional_steps` values in order of
    magnitude to examine further how well the found control strategy is generalized.
    Is the algorithm still able to find a winning solution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last exercise will lead to an increase in the execution time of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The double-pole balancing problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The single-pole balancing problem is easy enough for the NEAT algorithm, which
    can quickly find the optimal control strategy to maintain a stable system state.
    To make the experiment more challenging, we present a more advanced version of
    the cart-pole balancing problem. In this version, the two poles are connected
    to the moving cart by a hinge.
  prefs: []
  type: TYPE_NORMAL
- en: 'A schema of the new cart-poles apparatus is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8951ad6-2e47-4f3b-88d6-11033cf61335.png)'
  prefs: []
  type: TYPE_IMG
- en: The cart-poles apparatus with two poles
  prefs: []
  type: TYPE_NORMAL
- en: Before we move to the implementation details of the experiment, we need to define
    the state variables and equations of motion for the simulation of the double-pole
    balancing system.
  prefs: []
  type: TYPE_NORMAL
- en: The system state and equations of motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the controller is to apply the force to the cart in order to keep
    two poles balanced for as long as possible. At the same time, the cart should
    stay within the defined boundaries. As with the single-pole balancing problem
    discussed previously, the control strategy can be defined as an avoidance control
    problem, which means that the controller must maintain a stable system state,
    avoiding the danger zones when the cart moves outside the track boundaries or
    either of the poles fall beyond the allowed vertical angle. There is no unique
    solution for this problem, but an appropriate control strategy can be found because
    the poles have different lengths and masses. Therefore, they respond differently
    to the control inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current state of the double-pole balancing apparatus can be defined by
    the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Cart position on the track (![](img/58c58c96-ed90-4af9-b600-cc33827280c3.png))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cart velocity (![](img/a8659522-7d44-462f-8108-c6a0764a4b01.png))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First pole's angle from the vertical (![](img/87a960cd-9398-48da-b0d6-fdaa85a4d46c.png))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First pole's angular velocity (![](img/7863f770-1d28-421f-bd4d-1d1924e2af43.png))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second pole's angle from the vertical (![](img/8511a332-e426-417d-8bdb-adce53560d5e.png))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second pole's angular velocity (![](img/c1f55beb-93ff-4611-8935-b99b3b4ea2e7.png))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The equations of motion for two unjoined poles balanced on a single cart that
    ignores friction between cart wheels and the track are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be73a75c-bd3d-4f0e-9094-c0a069e73e8e.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/8968071c-f398-4735-babc-3c6e082107aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this equation, ![](img/ac7d62d9-cc3b-4797-ae79-24f1c86c0bb0.png) is the
    reaction force from the ![](img/2344d1ef-0f0b-41f4-8745-862dae768ce7.png) pole
    on the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c073c61-901d-41af-b765-3975d752f109.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this equation, ![](img/51d64bef-2e18-48a3-b169-ca75ec0813ae.png) is the
    effective mass of the ![](img/c60f03fd-eeb7-4bc9-847b-d502b936cd82.png) pole:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e7d1be9-3acc-4be8-b82f-b46b9a20a454.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following parameters are used for double-pole simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Description** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/c2dae5b9-fe5b-49ad-b531-2c7f56e9e0ba.png) | The position of the cart
    on a track | ![](img/b6112da8-918a-43b3-9c96-208b8a5477b4.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/57f65383-80b5-4e30-874e-d224020a9eac.png) | The angle of a pole from
    the vertical | ![](img/cee7bb3d-eb7b-4dc2-8987-ec1894749e15.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/714d496d-1542-4fee-b132-911103af8029.png) | The control force applied
    to the cart | ![](img/1b8ee74e-42f7-4859-a8a2-c35fcab26cf1.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/1b4458eb-1b1c-45ec-9ecd-726631e96f33.png) | The distance from the
    center of mass of the pole to the pivot | ![](img/29a6b8ac-e763-46a5-9d6a-d2996df44b3d.png)![](img/2ad149c7-6285-439b-8236-364142659995.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/c277bb60-e1e7-40e3-b926-50e557bf2b64.png) | The mass of the cart
    | ![](img/70043e09-5a9d-47ba-844c-b60957781183.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/4eefd5e6-7d13-486a-a5fe-cd5b61f4a5fe.png) | The mass of the ![](img/ec921e39-7533-4f39-aaf4-ec4e2f91e7c1.png)
    pole | ![](img/c3f17eb0-7427-4086-b3e7-b4f233da118b.png)![](img/dd8bd2ca-d758-409e-97c4-02564ce9f3b4.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/6134cc80-b12b-4af1-86cb-891ff6807ffd.png) | The coefficient of friction
    of the **pivot** of the ![](img/32e5ed21-4a64-4fe4-b40b-6b2fcea1c797.png) pole
    | ![](img/3629a999-06c3-4cd7-82d2-ff0e7ac38bab.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/00ccc395-dcb9-451f-90f0-84ac7191b5e6.png) | Acceleration of free
    fall due to gravity | ![](img/9f831f81-d62e-491d-b3b7-15a1e5ba67e7.png) |'
  prefs: []
  type: TYPE_TB
- en: 'The corresponding Python code defines these system parameters as constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the equations of motion in Python is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: More implementation details are available in the `cart_two_pole.py` file in
    the repository associated with `Chapter4` source code files. Refer to the `calc_step(action,
    x, x_dot, theta1, theta1_dot, theta2, theta2_dot)` function.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code receives the current system state (`x, x_dot, theta1, theta1_dot,
    theta2, theta2_dot`) along with the control action and calculates the derivatives
    (cart acceleration and angular acceleration of both poles).
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcement signal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simulation environment must provide minimal information about the system
    state after performing actions in the form of a reinforcement signal (![](img/fc22bec5-3708-414b-b602-27448d4ac84b.png)).
    The reinforcement signal indicates whether a double-pole balancing system violates
    the bounding constraints after applying an action. It can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b788c1c5-bb85-4a4c-b1bb-b85d3861ebd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of the reinforcement signal generation in Python is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The condition checks that the angle of each pole is ![](img/7ec89f5d-74cb-4799-97d2-9e4dc2192645.png) from
    the vertical, and that the position of the cart is ![](img/7d5bde15-10d8-4bd6-9e68-1aa3252ba5e2.png) from
    the center of the track.
  prefs: []
  type: TYPE_NORMAL
- en: Initial conditions and state update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the single-pole balancing experiment, we used random initial state conditions,
    but with the two poles, the initial conditions are a bit more simplified. The
    system starts with all cart and pole velocities set to zero. The initial position
    of the long pole is one degree from the vertical, and the short pole is exactly
    upright.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial conditions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a69cfc8-74b9-4b45-af4f-8f911b37565f.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/667f19c3-c24e-4a7d-89ce-22897e01410b.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/d019620c-0c49-44c5-bb15-3aafe6dd430e.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/3b91fda3-c5e7-44a9-9c00-9e8980bc6b68.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/c8f77873-ac3d-4d28-b103-e8d686bdcd37.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/da16b0a8-cb4e-4b6f-bbb0-542b9f53ef91.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: The state of the cart-pole system is updated at each simulation step by numerical
    approximation of the equations of motion using the Runge-Kutta fourth-order method
    with a time step size of *0.01* seconds. The Runge-Kutta fourth-order approximation
    method allows calculation of the system response given the state variables of
    the current time step. The new control inputs are generated every ![](img/08aa1b9b-c4ac-45e5-90af-ceb2e8acd574.png) seconds.
    Thus, the control frequency is **50 Hz**, and the update frequency of the system
    state is **100 Hz**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Runge-Kutta fourth-order method implementation in Python is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the current cart-pole apparatus state variables to update the intermediate
    state for the next half-time step and do the first simulation step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the intermediate state using the derivatives obtained from the first
    simulation step and perform the second simulation step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the intermediate state using the derivatives from the first and second
    simulation steps and execute the third pole-balancing simulation step using the
    updated state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the derivatives from the first three simulation steps to approximate
    the final state of the cart-pole apparatus that will be used in further simulation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the elements of the preceding equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f` is a control action to apply during simulation (**0 **or **1**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` is a list with the current values of the state variables (![](img/f79951a1-1e41-4e79-aa7f-c1d0026ec371.png)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dydx` is a list with the derivatives of the state variables (![](img/e2d8988c-2ae7-41e1-b34a-f6f52382d77b.png)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tau` is the size of the time step for approximation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more implementation details, refer to the `rk4(f, y, dydx, tau)` function
    in the `cart_two_pole.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation of the Runge-Kutta fourth-order method receives the current
    system state (`x, x_dot, theta1, theta1_dot, theta2, theta2_dot`) along with derivatives
    and approximates the system state at the next time step.
  prefs: []
  type: TYPE_NORMAL
- en: Control actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the single-pole balancing experiment discussed earlier in this chapter,
    the control system for the double-pole balancing experiment generates only two
    control signals: push left and push right with a constant force. Thus, the control
    force at time ![](img/bb496626-827c-48e5-a3b3-bc89636b64ba.png) can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/592640c7-d64b-4179-ad0c-76402aedacca.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding equation, ![](img/829855d2-7f89-434d-9c3b-1db857635745.png)
    is an action signal received from the controller at time ![](img/b234e4ad-b9f4-4830-b99e-4ed4dc1ca359.png).
  prefs: []
  type: TYPE_NORMAL
- en: Interactions between the solver and the simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The state variables are scaled down to fit the `[0,1]` range before they are
    applied as inputs to the controller ANN. Thus, the equations for preprocessing
    of the state input variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36086576-53c2-4337-804e-6749919a2333.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/ef65aaa9-36d9-442e-8d78-a723bbc49afe.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/68e2406f-5a04-4df0-9d6f-248e1c857a87.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/db6d27ef-0051-48a2-a214-2aa9794cca09.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/38cb7007-53ae-47ca-8c80-b7a75f15ea9b.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/1eb1c5c3-59d6-426a-94aa-6b63fb6a6e05.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding equations, ![](img/c44ddf68-8ca2-4a1e-9875-78023cf88b28.png) correspond
    to the cart's horizontal position, its horizontal velocity, the first pole's angle
    from the vertical, its angular velocity, and the second pole's angle and angular
    velocity, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Taking into account the system constraints defined earlier (see ![](img/43575c2d-0f73-48c9-908b-c6c1728f46ce.png)),
    the scaled values of ![](img/49856ea8-0837-4ea2-a4f6-bd79dd87bd32.png), ![](img/77bd9544-f690-443f-8c59-9c6bfce465b0.png),
    and ![](img/776c7abd-c5ad-41cc-a2aa-4eb54b18b5c0.png) are guaranteed to be within
    the `[0,1]` range, while the scaled values of ![](img/47785056-fe6d-4c4c-a2ab-d741a1b5b1f9.png), ![](img/d739616c-3da4-484c-8310-fa542cbc0ebb.png),
    and ![](img/cd31e739-15e7-4671-8e4e-505547b4f2ff.png) mostly fall within the `0...1` range,
    but can fall outside these bounds eventually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding source code for input scaling is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The state list holds the current state variables in the following order: ![](img/a74878d2-4ef8-40a6-be7e-d27af13dadd7.png).
  prefs: []
  type: TYPE_NORMAL
- en: Objective function for a double-pole balancing experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The objective function for this problem is similar to the objective function
    defined earlier for the single-pole balancing problem. It is given by the following
    equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd546863-081e-4289-b3f1-a1c5c99d7156.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/64991d2c-7d00-4676-a9c8-cea273e14412.png)'
  prefs: []
  type: TYPE_IMG
- en: In these equations, ![](img/9bcb9c30-deec-483a-9f71-dca8ab267bd6.png) is the
    expected number of time steps specified in the configuration of the experiment
    (100,000), and ![](img/0d98561b-d894-41dd-bcc9-70cfb2b6eed0.png) is the actual
    number of time steps during which the controller was able to maintain a stable
    state of the pole balancer within the specified limits.
  prefs: []
  type: TYPE_NORMAL
- en: We use logarithmic scales because most of the trials fail in the first several
    100 steps, but we are testing against 100,000 steps. With a logarithmic scale,
    we have a better distribution of fitness scores, even compared with a small number
    of steps in failed trials.
  prefs: []
  type: TYPE_NORMAL
- en: The first of the preceding equations defines the loss, which is in the `[0,1]` range,
    and the second is a fitness score that is complementing the loss value. Thus,
    the fitness score values are in the `[0,1]` range, and the higher the value, the
    better the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python source code is similar to the objective function definition in the
    single-pole balancing experiment, but it uses different simulator calls to get
    a number of balanced steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We use the logarithmic scale here because most of the runs fail too early, within
    100 steps or so, but we are testing against 100,000 steps.
  prefs: []
  type: TYPE_NORMAL
- en: Double-pole balancing experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This experiment uses a version of the double-pole balancing problem that assumes
    full knowledge of the current system state, including the angular velocities of
    the poles and the velocity of the cart. The criteria of success in this experiment
    are to keep both poles balanced for 100,000 steps, or approximately 33 minutes
    of simulated time. The pole is considered balanced when it stays within ![](img/7e187b55-6614-4d0d-a5dd-2d7f77fb5e3a.png) degrees
    of vertical, while the cart remains within ![](img/e10fcf6e-7929-49ab-8962-ee029537efe4.png) meters
    of the track's center.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperparameter selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to the previous experiment described in this chapter, double-pole balancing
    is much harder to solve due to its complex motion dynamics. Thus, the search space
    for a successful control strategy is broader and requires a more diverse population.
    To increase the diversity of the population, we increase its size to become 10
    times bigger than with a single-pole balancing experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fitness termination threshold remains the same as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To intensify evolutionary diversity further, we increase the probabilities
    of adding new nodes and connections, as well as changing the configuration scheme
    of initial connections. Also, the value of the `initial_connection` parameter
    contains the probability of connection creation, which introduces additional non-determinism
    into the process of the production of the connections graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, taking into account the size of a population and the possible size
    of a species, we reduced the fraction of individuals who are allowed to reproduce
    (`survival_threshold`). This tweak limits the search space of the solution by
    enabling only the fittest organisms to participate in the recombination process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The last tweak is controversial and can reduce the performance of the evolutionary
    process in general. But with large populations, it often works well by decreasing
    the number of possible recombinations. Thus, as a rule of thumb, large survival
    thresholds are used for small populations, and small values are used for large
    populations.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the increased complexity of this experiment, the additional hyperparameter
    type becomes extremely important for the final outcome. The neuroevolution process
    is built around the likelihood of mutations occurring, and the probability of
    mutation is tested against the values produced by a random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, in conventional computers, there is no true source of randomness.
    Instead, the randomness is generated by a pseudo-random algorithm that heavily
    depends on the random seed to start the generation of a random number sequence.
    Actually, the random seed value exactly defines a sequence of all pseudo-random
    numbers that will be produced by a given generator.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can consider the random seed number as an essential parameter defining
    the initial conditions. This parameter sets the properties of the random attractor,
    which will amplify the tiny changes in the numerical search space of the algorithm.
    The effect of amplification ultimately determines whether the algorithm will be
    able to find the winner and how long it will take.
  prefs: []
  type: TYPE_NORMAL
- en: 'The random seed value is defined in the `two_pole_markov_experiment.py` file
    around line 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For the complete list of hyperparameters used in the double-pole balancing experiment,
    please refer to the `two_pole_markov_config.ini` file in the source code repository
    associated with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code sets the seed value of the standard random number generator
    supplied with the Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: Working environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The working environment for the double-pole balancing experiment can be set
    up with the following commands entered into your Terminal application of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These commands create and activate a `double_pole_neat` virtual environment
    with Python 3.5\. After that, the NEAT-Python library with version 0.92 is installed,
    along with the other dependencies used by our visualization utilities.
  prefs: []
  type: TYPE_NORMAL
- en: The experiment runner implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code implementing the evaluation of the genome fitness is similar
    to the one used for a single-pole balancing experiment. The main difference is
    that it will refer to another simulation environment to get the number of balanced
    steps. Thus, you can refer to the source code of the `eval_fitness(net, max_bal_steps=100000)` and
    `eval_genomes(genomes, config)` functions in the `two_pole_markov_experiment.py` file for
    implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this experiment, we introduced adaptive learning, which will try to find
    the correct short pole length during the evolution process. The length of the
    short pole changes the motion dynamics of the system. Not all combinations of
    hyperparameters combined with a particular length of the short pole can produce
    a successful control strategy. Thus, we implement a sequential increase of the short
    pole length until the solution is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the `two_pole_markov_experiment.py` file for more implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code runs the simulation using different short pole length values
    until the solution is found.
  prefs: []
  type: TYPE_NORMAL
- en: Running the double-pole balancing experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having implemented the two-pole balancing simulator, genome fitness function
    evaluator, and experiment runner code, we are ready to start experimenting. Enter
    the directory containing the `two_pole_markov_experiment.py` file and execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to activate the appropriate virtual environment with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`conda activate double_pole_neat`**'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will launch the evolutionary process under the control
    of the NEAT algorithm, using the hyperparameters specified in the `two_pole_markov_config.ini` file,
    as well as the simulator of the cart-two-pole apparatus that we already implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'After `96` generations, the winning solution can be found in generation `97`.
    The console output for the last generation looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the console output, we can see that the winning genome has a size `(1, 6)`,
    which means that it has only one non-linear node—the output—and a full set of
    connections from six inputs to the output nodes. Thus, we can assume that the
    minimal possible configuration of the controller ANN was found because it does
    not include any hidden nodes, but instead encodes control behavior with specifically
    explored connection weights. Also, it is interesting to note that the solution
    for the smallest length value among the list of all possible short pole length
    values was found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of the controller''s ANN that''s capable of executing a reliable
    control strategy is shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56f7e312-d4bf-44a8-a2d9-80c6c37e2049.png)'
  prefs: []
  type: TYPE_IMG
- en: The ANN of the double-pole balancing controller
  prefs: []
  type: TYPE_NORMAL
- en: 'The fitness scores vary over generations, as shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2dd4e25-d092-4764-976a-93ddc822f705.png)'
  prefs: []
  type: TYPE_IMG
- en: The fitness scores through generations for a double-pole balancing experiment
  prefs: []
  type: TYPE_NORMAL
- en: The preceding graph is interesting if we want to know how the evolution works.
    You can see that before finding a winner, the fitness score drops sharply. This
    is due to the extinction of stagnated species that have reached a plateau with
    medium-high fitness scores that showed no improvement over the past 15 generations.
    After that, the vacant place is occupied by fresh species endowed with the genetic
    knowledge accumulated by extinct species. This newborn species also introduces
    a beneficial mutation that combines its hereditary knowledge with new tricks and,
    ultimately, produces a winner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this experiment, we decided to intensify the species'' diversity by significantly
    increasing the population size and making other tweaks to the hyperparameters.
    In the following graph, you can see that we have reached our goal, and that the
    neuroevolution process goes through a wide variety of species until a solution
    is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e427f23-b42c-4b61-bfd0-06e9342b2095.png)'
  prefs: []
  type: TYPE_IMG
- en: The speciation by generations for a double-pole balancing experiment
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we would like to learn how a change in the value of the random seed number
    impacts the NEAT algorithm. To begin with, we increased the value of the random
    seed number only by one (everything else has not changed). With this new condition,
    the NEAT algorithm could still find a stable control strategy but created a different,
    bizarre configuration of the controller''s ANN instead of the optimal configuration
    shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0231b73-c676-4c23-ae6e-f9775c7deb11.png)'
  prefs: []
  type: TYPE_IMG
- en: The ANN of a double-pole balancing controller with a random seed number increased
    by one (everything else is unchanged)
  prefs: []
  type: TYPE_NORMAL
- en: When the value of the random seed number increased, for example, by 10, the
    neuroevolution process could not find any solid control strategy at all.
  prefs: []
  type: TYPE_NORMAL
- en: This experiment revealed another vital aspect of methods based on neuroevolution—the
    impact of the initial conditions determined by the value of the random seed number.
    The random seed defines the properties of a random attractor, which amplifies
    the effects of the evolution process, both good or bad. So, with this experiment,
    it is crucial to find a suitable value of the random seed number to bootstrap
    the process of neuroevolution. We will discuss methods for finding appropriate
    values of the random seed numbers at the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try setting the `node_add` parameter value to `0.02` in the configuration file
    and see what happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the seed value of the random number generator and see what happens. Was
    a solution found with a new value? How is it different from what we have presented
    in this chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement control strategies for controllers
    that can maintain a stable state of a cart-pole apparatus with one or two poles
    mounted on top. We improved our Python skills and expanded our knowledge of the
    NEAT-Python library by implementing accurate simulations of physical apparatuses,
    which was used to define the objective functions for the experiments. Besides
    this, we learned about two methods for numerical approximations of differential
    equations, Euler's and Runge-Kutta, and implemented them in Python.
  prefs: []
  type: TYPE_NORMAL
- en: We found that the initial conditions that determine the neuroevolutionary process,
    such as a random seed number, have a significant impact on the performance of
    the algorithm. These values determine the entire sequence of numbers that will
    be generated by a random number generator. They serve as a random attractor that
    can amplify or dampen the effects of evolution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to use neuroevolution to create navigator
    agents that can find their way through a maze. You will learn how to define a
    goal-oriented objective function to solve the maze problem and how to write an
    accurate simulation of a robotic agent that can navigate through the maze. We
    will take a look at two types of maze environments and examine how the goal-oriented
    fitness function can get stuck trying to find a solution in the deceptive environment
    of a hard maze configuration.
  prefs: []
  type: TYPE_NORMAL
