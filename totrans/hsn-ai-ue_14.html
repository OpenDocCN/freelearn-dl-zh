<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Debugging Methods for AI - Logging</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will look at a series of methods that we can use to debug our AI systems. Of course, they can be used in general, and not only for AI. However, since AI can be tricky sometimes, mastering how to do proper logging in Unreal can be a time-saver when you need to find and fix a bug related to AI. In fact, often, due to variables that haven't been properly set, maybe with wrong values, we end up not executing a portion of code, or make a miscalculation.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li class="h2">Console Logging and on-screen messages in Blueprint</li>
<li class="h2">On-screen messages in C++</li>
<li class="h2">Console Logging in C++</li>
<li class="h2">Creating a Custom Logging Category (C++)</li>
</ul>
<p>By mastering the art of logging, you will be able to easily keep track of your values and which part of the code you are executing. Moreover, creating a Custom Logging Category allows you to define different levels of logging, and change the quantity of logging you want to see (even at runtime) based on what you are debugging. Furthermore, it is possible to easily strip away all the debugging code (at compilation time) by changing a variable, so that your shipped game can run as smoothly as possible.</p>
<p>With this being said, let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic Logging</h1>
                </header>
            
            <article>
                
<p>In the previous chapters we already looked at how to make logs. For example, in <a href="94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml">Chapter 5</a>, <em>Agent Awareness</em>, we saw how to print the information we needed both on the Console and on-screen. However, in this section, we will explore those concepts in more detail, and learn how to master logging within Unreal.</p>
<ul>
<li><strong>On-Screen messages</strong>: Often, during the Debugging phase, you and your team will need to be aware of certain variable values while playing the game. Thus, the easiest way to continuously test the value of the variable is by printing its value on the screen. We can achieve this in different ways, both in Blueprint and C++.</li>
</ul>
<ul>
<li><strong>Console Messages</strong>: These are printed on the Console (actually, there is more than one) and into Log files (so that even when the game is not running, you can analyze the log files to understand what happened (or what went wrong)).</li>
</ul>
<p> </p>
<div class="packt_infobox">While in Blueprint we have a unique function to print both on-screen and into the Console, in C++, we have separate functions. In fact, the Logging System in Unreal is very powerful, and C++ unlocks its full power.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Console Logging and on-screen messages in Blueprint</h1>
                </header>
            
            <article>
                
<p>When it comes to Blueprint, we have simple and easy debug nodes that we can use. The most common one is <span class="packt_screen">Print String</span>, but its counterpart, <span class="packt_screen">Print Text</span>, also exists. The following is a screenshot showing <span class="packt_screen">Print String</span> and <span class="packt_screen">Print Text</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1330 image-border" src="assets/ca5d2f4b-756a-4291-b15d-4b3ce18a6d9f.png" style="width:37.67em;height:13.50em;"/></p>
<div class="packt_infobox"><br/>
Both of them are marked as <strong><em>Development Only</em></strong>, which means that they will not working in shipping builds.</div>
<p>Their simple usage is straightforward. You just need to plug a <em>String</em> (or <em>Text</em>) into the homonym variable.</p>
<p>However, if we expand them and look at their more advanced options, we can find a full list of parameters, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1331 image-border" src="assets/aaaf0817-d0e3-40eb-a535-b7d88326aed9.png" style="width:33.83em;height:21.75em;"/></p>
<p>Let's look at them in detail:</p>
<ul>
<li><strong>String / Text</strong>: This is the String or Text that will be displayed on-screen. Thus, any information that needs to be displayed has to be within this String or Text.</li>
<li><strong>Print to Screen</strong>: If true, the node will actually print the message on-screen (by default, it is true).</li>
<li><strong>Print to Console</strong>: If true, the node will print the message in the Console as well (by default, it is true).</li>
<li><strong>Text Color</strong>: This is the color in which the String/Text will be displayed (by default, it is a light blue). This is useful when you need to visually distinguish different information. Colors help a lot in these kinds of situations.</li>
<li><strong>Duration</strong>: This is how long the message will be displayed on the screen. Make sure that you have enough time to read/assimilate the information. Of course, longer messages need a longer duration to be read.</li>
</ul>
<p>This is how they should appear in-game:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1332 image-border" src="assets/7cf50498-61df-4eaa-93c3-a1498dbfcf67.png" style="width:29.33em;height:18.92em;"/></p>
<p>The same log also appears in the console if "<strong><em>Print to Console</em></strong>" is set to true, and looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1333 image-border" src="assets/013b17b6-e8e5-4069-af67-ffceaa419596.png" style="width:58.50em;height:30.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">On-screen messages in C++</h1>
                </header>
            
            <article>
                
<p>In C++, we have an handy function to print messages on-screen. We do this within the <kbd>UEngine</kbd> class. The easiest way to have access to it is by using the <span class="packt_screen">GEngine</span> variable, which is a global variable that's available everywhere and contains the instance of the <em>UEngine</em> class. K<span>eep in mind that this variable might be empty (e.g. the game is running on a shipping build). Thus, it is very good practice to check the variable before you use it, like in the following code snippet:</span></p>
<pre> if (GEngine) {<br/>     //Do stuff with GEngine<br/> }</pre>
<p>Within the <kbd>if</kbd> statement, we can use the <strong>GEngine</strong> variable to call the <kbd>AddOnScreenDebugMessage()</kbd> function. As you would have guessed from the name, it prints a message on-screen. This is its full declaration:</p>
<pre>void AddOnScreenDebugMessage(uint64 Key,float TimeToDisplay,FColor DisplayColor,const FString&amp; DebugMessage, bool bNewerOnTop = true, const FVector2D&amp; TextScale = FVector2D::UnitVector);</pre>
<p>Let's go through the different parameters:</p>
<ul>
<li><strong>Key</strong>: This is a unique key that's given to a "slot" on the screen. When a new message needs to be written, but there is already one with the same key displayed, then the new one will replace the old one. This is particularly useful when you have a variable that updates often and you don't want to flood the screen with a lot of debug messages, especially when only the last one is relevant. Remember to use the same key when you print the same information, just updated.</li>
</ul>
<div class="packt_infobox">In the definition, the Key parameter is a <strong>uint64</strong>. However, there is wrapper that works with <strong>int32</strong>. Don't worry if you define your keys as <strong>int32</strong>, as they will work anyway.</div>
<ul>
<li><strong>TimeToDisplay</strong>: This is the duration, expressed in seconds, of how long the message needs to remain displayed on-screen. Make sure that you have enough time to read/assimilate the information. Of course, longer messages need longer durations to be read.</li>
</ul>
<p class="mce-root"/>
<ul>
<li><strong>DisplayColor</strong>: This is the color in which the debug message will be displayed. This is useful when you need to visually distinguish different information. Colors help a lot in these kinds of situations.</li>
<li><strong>DebugMessage</strong>: This is the string that will be displayed on-screen. Thus, any information that needs to be displayed has to be packed into an <em><strong>FString</strong></em>.</li>
<li><strong>bNewerOnTop</strong>: iThis s a boolean that it is used only when the key is equal to <strong>INDEX_NONE</strong> (which means a value of -1). If true, every new message will be displayed on top of the others. Otherwise, every new message will be placed below the others (like in a normal console). This is an option parameter, which is set to true by default. In fact, unlike a normal console, the text doesn't scroll down, so placing the most recent information on top guarantees that it is always available to developers.</li>
<li><strong>TextScale</strong>: This is the scale of the text, expressed as an <em><strong>FVector2D</strong></em>. This is useful when the text needs to be bigger or smaller than others for visualization reasons. This is an optional parameter, which is set to be the unitary vector (no scaling) by default.</li>
</ul>
<p>Now that we've covered these parameters, its usage is pretty straightforward. You can use the following snippet to quickly print some text:</p>
<pre>if (GEngine) {<br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Turquoise, TEXT("Some text to Display"));<br/>}</pre>
<p>In case you want to check if a <strong>Key</strong> already exists before printing your message (to avoid overriding already displayed information), you can use the <kbd>OnScreenDebugMessageExists()</kbd> function, which takes the Key as a parameter (only <em>uint64</em>, since there's no wrapper for <em>int32</em>) and returns a bool. It will be true if already it exists. Here is an example:</p>
<pre>if (GEngine) {<br/>    bool bExistMessageInSlot2 = GEngine-&gt;OnScreenDebugMessageExists(2);<br/>    // ... continue<br/>}</pre>
<p>If you wish to completely clear the screen of any displayed message, you can do so by using the <kbd>ClearOnScreenDebugMessages()</kbd> function <span>–</span> no parameters, no return value. Here is an example:</p>
<pre>if (GEngine) {<br/>    GEngine-&gt;ClearOnScreenDebugMessages();<br/>}</pre>
<p>In case you want to temporarily suppress any on-screen messages, you can do so by changing the <kbd>bEnableOnScreenDebugMessages</kbd> boolean. The advantage of this variable is that changing its value in real-time allows you to suspend debugging on-screen <em>on-the-fly</em>. Its usage is very simple:</p>
<pre>if (GEngine) {<br/>    //Disable On-Screen Messages<br/>    GEngine-&gt;bEnableOnScreenDebugMessages = false;<br/>}</pre>
<p>To test this code, we can create a new C++ class of type <kbd>Actor</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1334 image-border" src="assets/612d3017-4d97-4102-afde-991c80dbd13f.png" style="width:57.17em;height:46.75em;"/></p>
<p>Then, we can rename it as <strong><em>LoggingActor</em></strong>, and place it within a folder named "<strong><em>Chapter11</em></strong>":</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1335 image-border" src="assets/6f75f663-ccd9-4333-8952-8f0a91c6a500.png" style="width:78.00em;height:33.50em;"/></p>
<p>Next, we need to add the <kbd>BeginPlay()</kbd> function override in the header (<kbd>.h</kbd>) file if it is not already present (depending on which version of the Engine you are using, or if you have created the class in Visual Studio). In case you don't have it, this is the code:</p>
<pre>protected:<br/>  // Called when the game starts or when spawned<br/>  virtual void BeginPlay() override;</pre>
<p>Then, in the implementation (<kbd>.cpp</kbd>) file, we can<span> write the function to log the message on the screen within the</span> <kbd>BeginPlay()</kbd> <span>function:</span></p>
<pre>// Called when the game starts or when spawned<br/>void ALoggingActor::BeginPlay()<br/>{<br/>  Super::BeginPlay();<br/><br/>  if (GEngine) {<br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 8.0f, FColor::Turquoise, TEXT("Some text to Display"));<br/>  }<br/>  <br/>}</pre>
<p>Compile this code and place the actor in the level (remove the blueprint one, in case you already have that, or keep it, if you prefer).</p>
<div class="packt_infobox">Keep in mind that we didn't create a Scene Component for this Actor, since we were focusing on the logic. As a result, you are able to place it in the level, but not in a specific location. For our purposes, this is fine, but remember that when you create a C++ Actor, you might want a Scene Component (at least), or some other component.</div>
<p>Once you hit play, you will be able to see the following message:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1336 image-border" src="assets/137f8632-e0cc-4ceb-bd56-d6ca87db1124.png" style="width:34.83em;height:23.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Console Logging in C++</h1>
                </header>
            
            <article>
                
<p>When it comes to print on the console using C++, the possibilities are much vaster than Blueprint. In fact, logging in Unreal is a complex beast that does many things.</p>
<p>If you are searching just for a quick shortcut to print something into the console using C++, you can just use the following line of code:</p>
<pre>UE_LOG(LogTemp, Warning, TEXT("Message to Display"));</pre>
<p>This is how it appears in the <span class="packt_screen">Output Log</span> (I have place this line of code in the <kbd>LoggingActor</kbd>):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1337 image-border" src="assets/ee6dd748-1a59-46bf-864c-72a54c2f8351.png" style="width:58.25em;height:26.00em;"/></p>
<p>However, if you want to learn about the potential of the <em>Unreal Logging system</em>, than keep reading.</p>
<p>A good logging system doesn't just display information <span>– </span>it needs to display the right information.</p>
<p>So, to get started and look at serious logging in Unreal, we need to understand two concepts: <strong><em>Log Category</em></strong> and <strong><em>Log Verbosity</em></strong>:</p>
<ul>
<li><strong>Log Category</strong>: Log Categories are like labels that are given to the debug messages: they classify the kind of information that these messages convey into a category. For instance, you can have a category for AI, another for UI, and a third for Gameplay. As a result, when a message appears on the console, it is possible to know which category the message belongs to.<br/>
However, the usefulness of category doesn't stop here. Imagine that you are debugging your AI, but when you play the game, you are flooded with Gameplay debugging messages that your teammate (or you, in another time-slice) is using for testing. In this case, it would be nice to have only your debug messages. If all the messages are in different Log Categories, it is possible to filter them. As a result, you can completely suppress debug messages that are coming from a specific Log Category.<br/>
It is possible to go a step further with <strong><em>Log Verbosity</em></strong><span><span>.</span></span></li>
</ul>
<ul>
<li><strong>Log Verbosity</strong>: Log Verbosity is another label that's given to the debug message that indicates how "<em>verbose</em><span>" the message is. In other words, how detailed the debug message is.<br/></span>For example, a message saying "<em>Error occurred in the AI Controller</em><span>" and another saying "</span><em>Error occurred in the AI controller when executing the AttackPlayer Task in the Behavior Tree</em><span>" convey the same error, but the second is more detailed. A Gameplay programmer might need to be aware that there is an error in the AI controller, so if the game doesn't behave as it should, it might not due to his/her code, but rather because of an error in the AI programming. The AI programmer, instead, while trying to fix what might have caused the error, needs to know more details regarding the error.<br/></span>There are seven ordered verbosity levels for logging. Once a verbosity level is selected, then every verbosity level equal or less than the selected one will be displayed/logged into files.</li>
</ul>
<p>These are the different verbosity levels that are available in Unreal. They are ordered from least verbose to the most:</p>
<ul>
<li style="font-weight: 400"><strong>Fatal</strong>: This verbosity level is always printed both to the console and into log files, and it always crashes the system, even if logging is disabled. This means that every time you use this level of logging, it will crash your game/application. You may want to use this in very rare and special cases in which if the runtime execution reaches a "fatal" no-returning point, then it crashes the game by giving some useful information on how to avoid it in the future.</li>
<li style="font-weight: 400"><strong>Error</strong>: This verbosity level is printed both into the console and into log files. They appear in red by default.</li>
<li style="font-weight: 400"><strong>Warning</strong>: This verbosity level is printed both into the console and into log files. They appear in yellow by default.</li>
<li style="font-weight: 400"><strong>Display</strong>: This verbosity level is printed both into the console and into log files.</li>
<li style="font-weight: 400"><strong>Log</strong>: This verbosity level is printed only into log files, not into the console. However, they can still be viewed in the Editor inside the Output Log Window. This is also the most common level to use, since it doesn't spam the console, and you receive all the information in the Output Log Window.</li>
</ul>
<ul>
<li style="font-weight: 400"><strong>Verbose</strong>: This verbosity level is printed only into log files, not in the console. This is usually used for detailed logging, especially when you print the values of many variables..</li>
<li style="font-weight: 400"><strong>VeryVerbose</strong>: This verbosity level is printed only into log files, not in the console. This is the most detailed log level, and it is usually used for very detailed messages, giving the full view of the situation (e.g. every single value of each variable involved in the process). These kind of logs are so detailed that they are almost spam in the output log, and so they are used when such a level of detail is really needed.</li>
</ul>
<p>With the power of the Unreal Logging system, it is possible to decide on the level of verbosity for each logging category. In this way, if you are an AI programmer, you can set your AI logging to <em>VeryVerbose</em>, whereas the other categories (e.g. Gameplay-related stuff) is just set to a <em>Log</em> level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Custom Logging Category (C++)</h1>
                </header>
            
            <article>
                
<p>So far, we have seen how a log category that's been set to a certain verbosity level is able to log the right amount of information regarding a system. However, the true power comes when you are able to create your own Logging Category. The process is quite straightforward, since it relies on the use of a couple of macros.</p>
<p>The best spot to define your category is in the <kbd><em>YOUR_PROJECT_NAME.h</em></kbd> and <span><kbd><em>YOUR_PROJECT_NAME.cpp</em></kbd></span> files, which in my case is in the <kbd>UnrealAIBook.h</kbd> and <kbd>UnrealAIBook.cpp</kbd> files.</p>
<p>In the header (<kbd>.h</kbd>) file, we need to declare the following macro:</p>
<pre>DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity);</pre>
<p class="mceNonEditable"/>
<p>These are the parameters we need to insert:</p>
<ul>
<li style="font-weight: 400"><strong>CategoryName</strong>: This is the name of the new category that you want to define. Try to provide a meaningful name, which is not too long, but descriptive enough. The choice depends on your game/application as well. In fact, if you have just a simple AI system, you can log everything into the same <em>LogAI</em> category. However, if you have a very large and complex AI system that it is composed of many subsystems, then dividing into different log categories might be a winning choice.</li>
<li style="font-weight: 400"><strong>DefaultVerbosity</strong>: This is the default verbosity level that's used if another part of it is not specified (either in a configuration file, or directly from the command line). Everything that it is above this level will not be displayed. For example, if you set this level to be just "<em>Log</em>", then neither Verbose or <em>VeryVerbose</em> will be logged.</li>
<li style="font-weight: 400"><strong>CompileTimeVerbosity</strong>: This is the maximum verbosity level at which the compiler will include the log instruction. Anything that is defined more verbose than this level will not be compiled, which means that it will not be available, not even if the verbosity level is changed. For example, once you have finished working on a system, you probably don't want to keep many log instructions that are <em>VeryVerbose</em> inside a <em>Tick</em> function in your code base. By stripping them away from the compiled code, you can ensure that those instructions will never impact your performance, especially if the system is consolidated and those are logs that will never be read. Another use might be in shipping games, in which you don't want a certain level of verbosity for specific log categories to be present in the game.</li>
</ul>
<p>For example's sake, we can add this to our project:</p>
<pre>DECLARE_LOG_CATEGORY_EXTERN(MyAwesomeAILogCategory, Log, All);</pre>
<p>In the <kbd>.cpp</kbd> file, we need to have the following macro instead:</p>
<pre>DEFINE_LOG_CATEGORY(CategoryName);</pre>
<p>The only parameter that you need to insert is the name of the category, and it must match the name you inserted in the header file.</p>
<p class="mce-root"/>
<p>So, in our case, we can use the following:</p>
<pre>DEFINE_LOG_CATEGORY(MyAwesomeAILogCategory);</pre>
<p>Once you have done this, you are ready to use your brand new logging category so that you can add your C++ code in the following way:</p>
<pre>UE_LOG(MyAwesomeAILogCategory, Log, TEXT("I'm logged from a custom Category!"));</pre>
<div class="packt_infobox">If you get a compile error, it might be due to the fact that the C++ code in which you place the log doesn't have access to the definition of the category. For instance, in my case, I had to include my general project(/module) header file for it to work; I added <kbd>#include "UnrealAIBook.h"</kbd>.</div>
<p>This is how it appears in the <em>Output Log</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1338 image-border" src="assets/7096589b-ca87-4d3d-a99e-ca2921722863.png" style="width:58.25em;height:26.00em;"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored how to log both in C++ and Blueprint. This allows us to easily spot portions of our code that are wrong, or variables that contain wrong values.</p>
<p>It was particularly useful to learn about Custom Categories, since this is a very powerful part of the logging system within Unreal. In fact, it allows us to create a specific category for each part of our game, and increase or decrease the quantity of messages (based on importance) for each category, potentially even at runtime. Furthermore, it allows us to easily strip away debugging code once we need to ship the game, which we can do by simply changing the values of the <kbd>DECLARE_LOG_CATEGORY_EXTERN()</kbd> macro.</p>
<p>In the next chapter, we will explore more specific tools for performing debugging on the AI tools we have encountered during this book, from the <em>Navigation System</em> to <em>EQS</em>. Mastering these is important when it comes to becoming an AI Programmer in Unreal, and they will be very useful when you create complex AI systems.</p>


            </article>

            
        </section>
    </body></html>