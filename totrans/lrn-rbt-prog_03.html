<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer037">
			<h1 id="_idParaDest-33"><em class="italic"><a id="_idTextAnchor033"/>Chapter 2</em>: Exploring Robot Building Blocks – Code and Electronics</h1>
			<p>In this chapter, we'll take a robot apart to see its parts and systems. We'll explore the components of a robot, both the software (code, commands, and libraries) and the hardware, and how they go together. When starting to make a robot, it's valuable to think about the parts you want and how they relate to one another. I recommend sketching a plan of your robot—a block diagram as a guide to the connected code and parts, which we will explore in this chapter as well.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Looking at what's inside a robot</li>
				<li>Exploring types of robot components</li>
				<li>Exploring controllers and I/O </li>
				<li>Planning components and code structure</li>
				<li>Planning the physical robot</li>
			</ul>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>Technical requirements</h1>
			<p>For this chapter, you will require the following:</p>
			<ul>
				<li>Simple drawing materials, such as a pen and paper</li>
				<li>Optional – diagram software such as Draw.io (free at <a href="https://app.diagrams.net">https://app.diagrams.net</a>) or Inkscape (free at <a href="https://inkscape.org">https://inkscape.org</a>)</li>
			</ul>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/>Looking at what's inside a robot</h1>
			<p>We can start by looking at a<a id="_idIndexMarker034"/> robot as a physical system. In <em class="italic">Figure 2.1</em>, we can see a simple hobby robot:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="Images/B15660_02_01.jpg" alt="" width="1175" height="721"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – An assembled hobby robot</p>
			<p><em class="italic">Figure 2.2</em> shows it in its disassembled form:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="Images/B15660_02_02_NEW.jpg" alt="" width="1172" height="1504"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – A hobby robot's components laid out</p>
			<p>The component<a id="_idIndexMarker035"/> groups in <em class="italic">Figure 2.2</em> include nine types of components:</p>
			<ol>
				<li>The chassis or body forms the main structure of the robot; other parts are attached here.</li>
				<li>A castor wheel balances this robot.</li>
				<li>Two drive wheels. Other robots may use more wheels or legs here.</li>
				<li>Motors are essential for the robot to move. </li>
				<li>A motor controller bridges between a controller and connected motors. </li>
				<li>A controller, here a Raspberry Pi, runs instructions, takes information from the sensors, and processes this information to drive outputs, such as motors, through the motor<a id="_idIndexMarker036"/> controller. </li>
				<li>All robots must have power, usually one or more sets of batteries. </li>
				<li>Sensors provide information about the robot's environment or the state of its physical systems.</li>
				<li>Finally, debug devices are outputs that allow the robot to communicate with humans about what its code is doing, and are also useful for looking good.</li>
			</ol>
			<p>We will examine these components in more detail later in this chapter.</p>
			<p>We can visualize a robot as a block diagram (<em class="italic">Figure 2.3</em>) of connected parts. Block diagrams use simple shapes to show a rough idea of how things may be connected:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="Images/B15660_02_03.jpg" alt="" width="940" height="577"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – A robot block diagram</p>
			<p>The block diagram in <em class="italic">Figure 2.3</em> does not use a formal notation. The key I've created is off the top of my<a id="_idIndexMarker037"/> head, but it should identify sensors, outputs, and controllers. It could be as simple as a sketch on some scrap paper. The critical factor is that you can see blocks of functionality in the hardware, with the high-level flow of data between them. </p>
			<p>It is from this diagram that you can develop more detailed plans, plans containing details in terms of electrical connections, power requirements, the hardware, and how much space is needed. Sketching a block diagram about a robot you'd like to create is the first step toward making it.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A block diagram is <em class="italic">not</em> a schematic, nor a scale drawing of a finished robot. It doesn't even try to show the actual electronic connections. The picture ignores small details, such as how to signal an ultrasonic distance sensor before it responds. The connection lines give a general idea of the data flow. A block diagram is the right place to show the type and number of motors and sensors, along with additional controllers they may need. </p>
			<p>This was a very brief overview of robot components, seeing a robot similar to the one you will build, along <a id="_idIndexMarker038"/>with it disassembled into parts. We took a look at a simple robot block diagram and its intent. In the next section, we will take a closer look at each of the robot's components, starting with motors.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Exploring types of robot components</h1>
			<p>Before we look at the <a id="_idIndexMarker039"/>types of motors and sensors, let's get a brief understanding of what each of them is. </p>
			<p>A <em class="italic">motor</em> is an output device that rotates when power is applied. Motors are a subset of a type of machinery called an <em class="italic">actuator</em>. It is an output device that creates motion from electrical power. This power can be modulated with signals to control movement. Examples of actuators are solenoids, valves, and pneumatic rams. </p>
			<p>A <em class="italic">sensor</em> is a device that provides input to a robot, allowing it to sense its environment. There are more sensor types than a single book can list, so we'll keep to the commonly available and fun-to-use ones. Displays and indicators are debug output devices, for giving feedback on the robot's operation to a human user/programmer. A few of these will be covered in this section.</p>
			<p>Now, let's look at them in detail.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Types of motors </h2>
			<p>There are a number <a id="_idIndexMarker040"/>of different kinds of motors that robots commonly use. Let's take a look at what each one does and how we might use them for different types of motion:</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Torque is a rotating/twisting force, for example, the force a motor will need in order to turn a wheel. If the torque increases, a motor will require more power (as current), and will slow down while trying to cope. A motor has a limit, the <strong class="bold">stall torque</strong>, at which point it will stop moving. </p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="Images/B15660_02_04.jpg" alt="" width="723" height="300"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Different motor types – a DC motor, DC gear motor, servo motor, and stepper motor</p>
			<p>To identify what each of these motors do, let's look at them in detail:</p>
			<ol>
				<li value="1"><strong class="bold">DC motor</strong>: This is the <a id="_idIndexMarker041"/>most simple type of motor in<a id="_idIndexMarker042"/> robotics and forms the basis of gear motors. It uses <strong class="bold">Direct Current</strong> (<strong class="bold">DC</strong>) voltage, which<a id="_idIndexMarker043"/> means it can be driven simply by voltage running one way through it. The motor speed is in proportion to the voltage running through it versus the torque required to move. A bare DC motor like the one in <em class="italic">Figure 2.4</em> can spin too fast to be useful. It will not have much torque and stall easily.</li>
				<li><strong class="bold">DC gear motor</strong>: This is a DC motor fitted with a gearbox. This gearbox provides a reduction <a id="_idIndexMarker044"/>in speed and increases the <a id="_idIndexMarker045"/>torque it can handle. This mechanical advantage increases the motor's ability to move a load. Note that this gear motor is missing soldered leads! I recommend these motor types for robot wheels. We will use gear motors such as this on our robot in <a href="B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, <em class="italic">Building Robot Basics – Wheels, Power, and Wiring</em>, and <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>, <em class="italic">Drive and Turn – Moving Motors with Python</em>.</li>
				<li><strong class="bold">Servo motor</strong> (or <strong class="bold">servomechanism</strong>): This type of motor combines a gear motor with a<a id="_idIndexMarker046"/> sensor and a built-in<a id="_idIndexMarker047"/> controller as shown in <em class="italic">Figure 2.5</em>. A signal to a controller states a motor position, and the controller uses feedback from the sensor to try to reach this position. Servo motors are used in pan and tilt mechanisms, along with robot arms and limbs. We will look more closely at, and program, servo motors in <a href="B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Python to Control Servo Motors</em>:<div id="_idContainer024" class="IMG---Figure"><img src="Images/B15660_02_05_NEW.jpg" alt="" width="1096" height="946"/></div><p class="figure-caption">Figure 2.5 – Pictorial diagram of a servo motor mechanism</p></li>
				<li><strong class="bold">Stepper motor</strong>: These <a id="_idIndexMarker048"/>have coils powered in a<a id="_idIndexMarker049"/> sequence to let the motor step a certain number of degrees. Where exact motions are needed, engineers use steppers. Stepper motors tend to be slower and generate a lot of heat compared with DC motors or servo motors. You will find these in fine-control applications, such as 3D printers and high-end robot arms. They are heavier and more expensive than other motors.</li>
				<li><strong class="bold">Brushless motor</strong>: These<a id="_idIndexMarker050"/> are not shown in the<a id="_idIndexMarker051"/> diagram. They are driven with specialized controllers, and can be capable of high speed and torque. They run quieter and are popular in drones. There are no gear motor equivalents, so creation of a gearbox may be necessary.<p class="callout-heading">Important note</p><p class="callout">All but servo motors require hardware for a controller such as the Raspberry Pi to drive them. This hardware allows the Pi to control power-hungry devices without destroying them. Never connect DC motors, stepper motors, or solenoids directly to a Raspberry Pi!</p></li>
			</ol>
			<p>Let's look at some other types of actuators next.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Other types of actuators</h2>
			<p>Linear actuators, like <a id="_idIndexMarker052"/>those shown in <em class="italic">Figure 2.6</em>, are devices that convert electrical signals into motion along a single axis. These can be a stepper motor driving a screw in a fixed enclosure, or use arrays of coils and magnets:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="Images/B15660_02_06.jpg" alt="" width="944" height="360"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Linear actuators: By Rollon91, [Image credit: https://commons.wikimedia.org/wiki/File:Uniline.jpg?uselang=fr [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)]</p>
			<p>A <strong class="bold">solenoid</strong> is a simple linear actuator using an electromagnetic coil with a metal core that is pulled or pushed away when powered. A common use of this type is in hydraulic or pneumatic valves. Hydraulic and pneumatic systems generate powerful motions like those seen in excavators. </p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Status indicators – displays, lights, and sounds</h2>
			<p>Another helpful<a id="_idIndexMarker053"/> output device is a display. A single LED (a small electronic light) can indicate the status of some part of the robot. An array of LEDs could show more information and add color. A graphical display can show some text or pictures, like those found on a mobile phone. We will be connecting a multicolor LED strip to the robot as a display in <a href="B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171"><em class="italic">Chapter 9</em></a>, <em class="italic">Programming RGB Strips in Python</em>.</p>
			<p>Speakers and beepers can be used for a robot to communicate with humans by making sounds. The sound output from these can range from simple noises through to speech or playing music.</p>
			<p>Many robots don't<a id="_idIndexMarker054"/> have any displays and rely on a connected phone or laptop to display their status for them. We will use a phone to control and see the status of our robot in <a href="B15660_17_Final_ASB_ePub.xhtml#_idTextAnchor396"><em class="italic">Chapter 17</em></a>, <em class="italic">Controlling the Robot with a Phone and Python</em>.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Types of sensors</h2>
			<p><em class="italic">Figure 2.7</em> shows a <a id="_idIndexMarker055"/>collection of sensor types used in robotics. They are similar to those that we will explore and use in this book. Let's examine some of them and their uses. Note that these may look different from the same sensor types seen previously – there is a wide variation in sensors that do the same job. When we add them to the robot, we will cover their variants in more detail:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="Images/B15660_02_07.jpg" alt="" width="1462" height="902"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – A selection of sensors from my robots: 1 - A Raspberry Pi camera, 2 - an optical distance sensor, 3 - an ultrasonic distance sensor, 4 - line sensors, 5 - microphones, and 6 - an optical interrupt sensor</p>
			<p>Let's understand each sensor from <em class="italic">Figure 2.7</em> in detail:</p>
			<ol>
				<li value="1"><strong class="bold">Raspberry Pi camera module</strong>: This module connects to a Raspberry Pi to provide it<a id="_idIndexMarker056"/> with imaging capabilities. We'll use it for visual processing programming in <a href="B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283"><em class="italic">Chapter 13</em></a>, <em class="italic">Robot Vision – Using a Pi Camera and OpenCV</em>. This module captures images or video sequences. It can generate a lot of data quickly, which is one of the problems associated with robot vision. It is sensitive to lighting conditions.</li>
				<li><strong class="bold">Optical distance sensor</strong>: The<a id="_idIndexMarker057"/> VL53L0X Time of Flight laser ranging sensor in <em class="italic">Figure 2.7</em> is a distance sensor. It uses an infrared laser to bounce off objects and detect how far away they are. It can be affected by lighting conditions. <p>The VL53L0X sensors use I2C to send a detected range to the Raspberry Pi and can share their two <a id="_idIndexMarker058"/>communication pins with many other devices. I2C is useful when you have many sensors and outputs and are starting to run out of places to connect things. I2C sensors can be a more expensive option.</p></li>
				<li><strong class="bold">Ultrasonic distance sensor</strong>: The HC-SR04 is another distance/ranging sensor that <a id="_idIndexMarker059"/>bounces sound pulses off objects to detect distance. It is affected by the types of material an object is made from and will fail to detect certain surfaces, but is impervious to lighting conditions. Some surfaces, for example, fabrics, absorb the sound too much and never send it back, while other surfaces, such as grids or meshes, do not interact much with sound waves and will be transparent to the sensor. <p>The HC-SR04 requires precise timing in the controller to time the echo, which we will have to manage in code. It has a longer range than the VL53L0X laser sensor, and is cheaper, but is also less sensitive at close distances. We will be programming sound-based range sensors in <a href="B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Programming Distance Sensors with Python</em>.</p></li>
				<li><strong class="bold">Line sensors</strong>: These are <a id="_idIndexMarker060"/>a set of three line-sensors that use light to detect transitions from light to dark. They can be adjusted to sense in different conditions. There are a few variations of these modules. These provide an on or off signal, depending on light or dark areas beneath it. They are the simplest of the sensors.<p><strong class="bold">Microphone</strong>: The fifth sensor <a id="_idIndexMarker061"/>is a pair of microphones. These can connect directly to the PCM pins on a Pi. Some other microphones need to be connected to electronics to process their signal into something the Raspberry Pi uses. We will use microphones for voice processing in <a href="B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344"><em class="italic">Chapter 15</em></a>, <em class="italic">Voice Communication with a Robot Using Mycroft</em>.</p></li>
				<li><strong class="bold">Optical interrupt sensor</strong>: This detects infrared light passing through a gap between two<a id="_idIndexMarker062"/> posts, sensing whether something between the posts is interrupting the beam. These are used with notched wheels to detect rotation and speed by counting notches. When used with wheels, they are also known as encoders. We use encoders in <a href="B15660_11_Final_ASB_ePub.xhtml#_idTextAnchor219"><em class="italic">Chapter 11</em></a>, <em class="italic">Programming Encoders with Python</em>.</li>
			</ol>
			<p>There are many more sensors, including ones to detect positions of limbs, light, smoke, heat sources, and magnetic fields. These can be used to make more advanced robots and add more exciting behavior.</p>
			<p>We have covered<a id="_idIndexMarker063"/> motors, displays, indicators, and sensors, together with examples and some details regarding their types. These are the parts that allow our robot to interact with the world. Now we will move on to the controllers, the parts of a robot that run code and connect sensors and motors together.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/>Exploring controllers and I/O</h1>
			<p>At the center of the<a id="_idIndexMarker064"/> robot block diagram, as in <em class="italic">Figure 2.3</em>, are controllers. Robots usually have a primary controller, a computer of some kind. They may also have some secondary controllers, and some more unusual robots have many controllers. This book keeps things simple, with your code running on a conventional central controller. The controller connects all the other parts together and forms the basis of their interactions.</p>
			<p>Before we look at controllers, we need to get a better understanding of an important component that connects controllers to other components, I/O pins.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>I/O pins</h2>
			<p>I/O pins are used<a id="_idIndexMarker065"/> for input<a id="_idIndexMarker066"/> and output from the controller. They give the controller its ability to connect to real-world sensors and motors. </p>
			<p>The number of I/O pins on the controller is a limiting factor in what you can connect to a robot without using secondary <a id="_idIndexMarker067"/>controllers. You may also see the term <strong class="bold">General Purpose Input Output</strong> (<strong class="bold">GPIO</strong>). Controller I/O pins have different capabilities.</p>
			<p>The simplest I/O pins are only able to output or read an on/off signal, as shown in <em class="italic">Figure 2.8</em>. These are known as digital I/O pins. They can be programmed to perform complicated tasks through signal timing. This is the principle used in the HC-SR04 distance sensor. In <em class="italic">Figure 2.8</em>, this graph represents a voltage level over time. So, as we move along the <em class="italic">x</em> axis, the voltage is on the <em class="italic">y</em> axis. The upper level represents a digital logic high (<strong class="source-inline">1</strong>, <strong class="source-inline">True</strong>, <strong class="source-inline">On</strong>). The lower level represents a digital logic low (<strong class="source-inline">0</strong>, <strong class="source-inline">False</strong>, <strong class="source-inline">Off</strong>). The controller will attempt to interpret any value as high or low:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="Images/B15660_02_08.jpg" alt="" width="1066" height="203"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – A digital signal</p>
			<p>Analog input pins <a id="_idIndexMarker068"/>can <a id="_idIndexMarker069"/>read varying levels, like the signal in <em class="italic">Figure 2.9</em>, which is another voltage-over-time graph. If a sensor produces a changing resistance or continuous scale of values, then an analog pin is suitable. There is a resolution limit to this, for example, an 8 bit analog input will read 256 possible values:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="Images/B15660_02_09.jpg" alt="" width="1325" height="230"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 2.9 – An analog signal</p>
			<p><strong class="bold">Pulse Width Modulation</strong> (<strong class="bold">PWM</strong>) pins <a id="_idIndexMarker070"/>output a cycling digital waveform shown in <em class="italic">Figure 2.10</em>. This diagram also shows voltage over time, although the timing of the pulses represents a continuous level, so the dashed line shows the continuous level produced by the timing. PWM outputs allow the code to select the frequency and how much time they are on for. The length of on-time versus off-time in a cycle changes to vary an output signal. This is often used to control the speed of motors:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="Images/B15660_02_10.jpg" alt="" width="711" height="106"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – A PWM signal in blue, with the dashed line showing its approximate value</p>
			<p>We will spend more time on PWM pins in <a href="B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, <em class="italic">Building Robot Basics – Wheels, Power, and Wiring</em>, and <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>, <em class="italic">Drive and Turn – Moving Motors with Python</em>.</p>
			<p>Some I/O pins can be used to form data transmission lines, such as serial, I2S, I2C, and SPI buses. They are known as data buses. Data buses are used to send data to or from other controllers and intelligent sensors. We'll use an SPI data bus for the RGB LEDs in <a href="B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171"><em class="italic">Chapter 9</em></a>, <em class="italic">Programming RGB Strips in Python</em>. </p>
			<p>Microcontroller pins can be used for digital or analog input and output, or part of a data bus. Many controllers<a id="_idIndexMarker071"/> allow <a id="_idIndexMarker072"/>the usage mode of pins to be configured in the software you run on them, but some capabilities are restricted to specific pins.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>Controllers</h2>
			<p>Although it's possible to<a id="_idIndexMarker073"/> use bare microcontroller chips with the right skills to create<a id="_idIndexMarker074"/> surrounding electronics and your own PCBs, we'll keep things simple in this book by using controller modules. These tend to come in packaged and easy-to-use systems:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="Images/B15660_02_11.jpg" alt="" width="1492" height="394"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – A selection of controller modules: a Raspberry Pi, NodeMCU, Arduino, and micro:bit</p>
			<p><em class="italic">Figure 2.11</em> shows some of my favorite controllers. They can all be powered via a USB connection. All but the Raspberry Pi can also be programmed over a USB. They all have connectors for <a id="_idIndexMarker075"/>easy access to their I/O pins. For each of the controllers, let's see what<a id="_idIndexMarker076"/> they are, along with their pros and cons:</p>
			<ol>
				<li value="1"><strong class="bold">Raspberry Pi</strong>: This is <a id="_idIndexMarker077"/>powerful enough for visual <a id="_idIndexMarker078"/>processing. It tends to consume a little more power and is more expensive, but is similar to a mobile phone in capability. It has the most flexible environment for programming. There are several models to consider. They have many I/O pins, but none are analog input pins.</li>
				<li><strong class="bold">NodeMCU</strong>: This is based <a id="_idIndexMarker079"/>on the ESP8266 controller. This<a id="_idIndexMarker080"/> controller has built-in Wi-Fi and can be programmed with Arduino C++, MicroPython, or Lua. It has plenty of I/O pins, but only one can read analog signals. It supports many data bus types. It is somewhat faster and can hold larger programs than the Arduino. It is the cheapest controller in this lineup.</li>
				<li><strong class="bold">Arduino Leonardo</strong>: This is based on the Atmega 328 chip. Arduino controller modules formed the<a id="_idIndexMarker081"/> basis of most of my robots <a id="_idIndexMarker082"/>around 2010-2012. The Arduino was important for the ease with which it could be connected to a PC via a USB and programmed to immediately interact with devices attached to its I/O pins. <p>The Arduino is mostly programmed in the C++ language. It has the most flexible built-in I/O pins – seven analog pins, many digital pins, PWM output pins, and can be set up to handle most data buses. The Arduino's processor is very simple; it is not capable of visual or speech processing tasks. The Arduino has the lowest power consumption of all the options shown here.</p></li>
				<li><strong class="bold">micro:bit</strong>: This<a id="_idIndexMarker083"/> was <a id="_idIndexMarker084"/>released in 2015 for use in education, and is ideal for children. Its use in robotics requires an additional adapter if you need more than the 3 I/O pins that it ships with, but it is still a pretty <a id="_idIndexMarker085"/>capable robot <a id="_idIndexMarker086"/>controller and comes with a handy built-in LED matrix. This can be programmed in MicroPython, C, JavaScript, and several other languages.</li>
			</ol>
			<p>An honorable mention should go to the PIC microcontroller, not pictured here. These were used for hobby robotics long before any of the others, and have a thriving community.</p>
			<p>Here is a comparison of controllers based on the pros and cons:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="Images/B15660_02_Table_2.1.jpg" alt="" width="1650" height="1012"/>
				</div>
			</div>
			<p>Where the other <a id="_idIndexMarker087"/>controllers may run a simple interpreter or compiled code, the Raspberry Pi runs a complete operating system. Current models have Wi-Fi and Bluetooth capabilities, which we will use to make a robot headless and connect with game controllers. </p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>Choosing a Raspberry Pi</h2>
			<p><em class="italic">Figure 2.12</em> shows a <a id="_idIndexMarker088"/>few current Raspberry Pi models. As new <a id="_idIndexMarker089"/>Raspberry Pis are released, a robot builder may have to adapt this to the latest version. All these models have Wi-Fi and Bluetooth capabilities. The Raspberry Pi I/O pins support many of the data bus types and digital I/O. External controllers are needed for analog <a id="_idIndexMarker090"/>reading and some other I/O functions: </p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="Images/B15660_02_12.jpg" alt="" width="1089" height="502"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – Raspberry Pi models – 4B, 3A+, and Zero W</p>
			<p>Let's look at each of these models in a little detail:</p>
			<ol>
				<li value="1"><strong class="bold">Raspberry Pi 4B</strong>: This is<a id="_idIndexMarker091"/> the latest in the Raspberry Pi line at the time of writing. As the latest model, it is the fastest and most potent in the lineup. It takes up more space, is the most expensive in this group, and uses the most power.</li>
				<li><strong class="bold">Raspberry Pi 3A+</strong>: This is the<a id="_idIndexMarker092"/> controller we will use for our robot. It provides an excellent compromise on size and power. It is fully capable of visual processing through a camera. It's not quite as fast as the 4B+, but definitely quick enough for our purposes.</li>
				<li><strong class="bold">Raspberry Pi Zero W</strong>: This is an inexpensive, lighter alternative to the other Raspberry Pi models. Cameras<a id="_idIndexMarker093"/> and speakers are still supported. The Zero WH model includes headers for I/O too. It performs speech and visual recognition slower than on a Raspberry Pi 3 and 4. Their small size makes them an interesting option for a remote-control pad too.</li>
			</ol>
			<p>Now that we know each of the models, let's compare their pros and cons:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="Images/B15660_02_Table_2.2.jpg" alt="" width="1650" height="1012"/>
				</div>
			</div>
			<p>The Raspberry Pi 4B<a id="_idIndexMarker094"/> may be the most powerful, but the 3A+ is powerful enough to be responsive to all the activities here. </p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Planning components and code structure</h1>
			<p>You've now <a id="_idIndexMarker095"/>briefly seen some components you might use in a<a id="_idIndexMarker096"/> robot, and you've encountered a block diagram to put them together. This is where you may start taking the next step and thinking further about how to connect things, and how the code you write for them will be structured. </p>
			<p>Code is easier to reason about when taken as logical blocks instead of one large lump. Arranging code in ways that are similar to a hardware functionality diagram will help navigate your way around as it becomes more complicated.</p>
			<p>So, let's return to the robot block diagram in <em class="italic">Figure 2.3</em> to think about what we'll need to handle in our code for it. That diagram has three sensors and two outputs. Each component (sensor, output, and controller board) may need some code to deal with it, and then you need some code for the behavior of combined modules.</p>
			<p>Motor controllers come in many flavors. They have different ways to output to motors, and they may have monitoring for battery levels. Some smart motor controllers interface with wheel encoders directly to ensure the wheels have traveled a specified amount. When we<a id="_idIndexMarker097"/> write behavior for a robot, we may not want to <a id="_idIndexMarker098"/>rewrite it if we change the motor controller. Mixing the direct motor controller code with the behavior code also makes it harder to reason about. For this, I recommend creating an interface layer, an <em class="italic">abstraction</em> between the real motor controller code and a standard interface, which will make swapping components possible. We will see this in practice in <a href="B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>, <em class="italic">Drive and Turn – Moving Motors with Python</em>.</p>
			<p>This is similar for each sensor. They will have some code to manage how they get signals and turn them into usable data. All these devices may have setup and teardown code that needs to run when starting or stopping behavior that connects to them. The camera is a sophisticated example of this, requiring processing to get the data values we can use to perform a task:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="Images/B15660_02_13.jpg" alt="" width="1609" height="518"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – A quick software block diagram, in pen on an envelope, and the same diagram using a computer</p>
			<p>Just like the hardware, a simple diagram can represent the software. This can be made in a drawing program or sketched on any paper you have to hand. In <em class="italic">Figure 2.13</em>, I've deliberately chosen a hand-drawn one so you don't feel that you need a drawing tool to do this. This won't<a id="_idIndexMarker099"/> be tidy, but it's quickly redrawn, and can even be <a id="_idIndexMarker100"/>done on the back of receipt paper if an idea comes to you while out dining. What is relevant here is the fact that if you use a pencil, go back over it in a pen or fine liner so that it doesn't fade. To make it clearer to the reader, I have made a computer drawing too, but don't feel you need to do this.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Scan your hand-drawn documents. If you have a scanner, or just a phone, I recommend scanning or getting a photo of your sketches, for later reference. Putting them into software such as Evernote or OneNote as images/PDFs with useful tags lets you look them up quickly later.</p>
			<p>After making a hand-drawn sketch, you can use a software tool. This will take longer than a hand-drawn version, and try not to be distracted by the quirks and styling of a tool. </p>
			<p>In terms of the design itself, this is still a very simplistic view. The <strong class="bold">Wheels</strong> box will be a block of code, dealing with asking<a id="_idIndexMarker101"/> the wheel motor controller to do things. This may sit on top of code written by the motor controller company, or use I/O pins connected to the controller. </p>
			<p><strong class="bold">Distance sensors</strong> are blocks<a id="_idIndexMarker102"/> of code to read distances from the sensors, triggering them when necessary. We will look at two different kinds of sensors and compare them. By having a block of code like this, changing the sensors at this level means the other code won't have to change.</p>
			<p>There is also a block of code for the <strong class="bold">Camera</strong>, doing fiddly stuff like setting it up, resolution, white balancing, and other parts that we will cover. On top of this is a layer that will use the camera images. That layer could get the position of a colored object, returning this position to the layer above.</p>
			<p>Across the motors and distance sensors is a behavior layer that allows the robot to avoid collisions, perhaps when it is below a threshold on one side. This will override other behavior to turn away from that obstacle and drive off a bit.</p>
			<p>The top layer is another behavior that takes positional data from the <strong class="bold">Get Object Position</strong> code. Use this <a id="_idIndexMarker103"/>position to choose a direction, and then <a id="_idIndexMarker104"/>instruct the motors to drive to the object. If this behavior goes through the <strong class="bold">Avoid Collisions</strong> behavior, there could be a complicated interaction that leads the robot to seek the correct object, while avoiding obstacles and going around things. It will also not come close enough to the detected object to collide with it.</p>
			<p>Each module is relatively simple, perhaps with the lower layers that are closer to the hardware being more complex, especially in the case of the camera.</p>
			<p>Breaking the code down into blocks like these means that you can approach a single block at a time, test, and tweak its behavior, and then focus on another one. When you have written blocks like this, you can reuse them. You will likely need the motor code multiple times and now will not need to write it multiple times.</p>
			<p>Using blocks to describe our software lets us implement the blocks and their interactions in different ways. We can consider whether we will use functions, classes, or services for these blocks. I will spend more time on this as we start writing the code for this and show the different approaches.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>Planning the physical robot</h1>
			<p>Let's now put all of this to use and plan the layout of the physical parts of robot that we are making in this<a id="_idIndexMarker105"/> book. While we go through chapters, we will be adding new components each time, and keeping an overall map in our minds as we go helps us to see where we are. It is quite exciting to start to picture all the things a robot will do. Let's start with a list of what our robot will do and be:</p>
			<ul>
				<li>It will have wheels and be able to drive around the floor.</li>
				<li>It will have a Raspberry Pi 3A+ controller.</li>
				<li>It will have a motor controller for the wheels.</li>
				<li>It will be able to indicate its status with a set of multicolored LEDs.</li>
				<li>The robot will use a pair of servo motors for a pan and tilt mechanism.</li>
				<li>It will be able to avoid walls and navigate around obstacles with either ultrasonic or laser distance sensors.</li>
				<li>It will have an encoder per wheel to know how far it has moved.</li>
				<li>The robot will use a camera to sense colored objects or faces.</li>
				<li>It will be able to follow lines with the camera.</li>
				<li>The robot will have a microphone and speaker to work with voice commands.</li>
				<li>It will have a gamepad as a remote control.</li>
				<li>It will need power for all of these things.</li>
			</ul>
			<p>Phew! That is a lot of functionality. Now, we need to draw the hardware blocks. <em class="italic">Figure 2.14</em> shows our block diagram. While done with Draw.io, a simple back-of-an-envelope sketch of a block diagram is an excellent start to robot planning. Most of my robots start off that way:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="Images/B15660_02_14.jpg" alt="" width="1336" height="788"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14 – Block diagram of the robot we will build, created using the draw.io web app</p>
			<p>Although this looks like <a id="_idIndexMarker106"/>a daunting amount of robot, we will be focusing on an area of functionality in each chapter and building it before moving to other areas. The annotation here is not any formal notation, it is just a way of merely visualizing all the parts that will need to be connected. Along with this, I usually sketch roughly where I would physically place sensors and parts with one another: </p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="Images/B15660_02_15.jpg" alt="" width="1140" height="700"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – An overview of how the robot could be physically laid out, created with Draw.io</p>
			<p>The sketch in <em class="italic">Figure 2.15</em> is not exhaustive, accurate, or to scale, but just an idea of where I want the parts <a id="_idIndexMarker107"/>to end up. Note the following things in this diagram:</p>
			<ul>
				<li>Sensors have a clear field of view, and the distance sensors are pointing out to the sides. I'll go into more detail in the relevant sensor chapters on why this is important.</li>
				<li>Encoders are placed over the wheels where they will be used.</li>
				<li>Heavy items, specifically batteries, should be kept low (below the center of gravity) to avoid a robot tipping over.</li>
				<li>Batteries need to be changed, so think about access to them.</li>
				<li>Try to keep components that are directly connected quite close to one another.</li>
				<li>This is a rough plan. It need not be this detailed, and this is <em class="italic">not</em> the test fit. Real dimensions, design compromises, and hitches will mean that this will change. This is just a starting point.</li>
			</ul>
			<p>As we work through the book, we will look at the details in these diagrams, and start to flesh out the real robot, making some of this less fuzzy. Any diagram like this, at the start of a project, should be taken as a bit rough. It is not to scale and should not be followed blindly. It is a<a id="_idIndexMarker108"/> guide, or a quick map from which to start working.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Summary</h1>
			<p>In this chapter, you've been able to see a number of the different component parts that go into a robot, and through a block diagram as a plan, start to visualize how you'd combine those blocks to make a whole robot. You've seen how you can quickly sketch your robot ideas on an envelope, and that drawing tools on a computer can be used for a neater version of the same diagram. You've had a quick tour of motors, sensors, and controllers, along with a few ways, including analog, digital, PWM, and data buses, for controllers to communicate with the other devices connected to them. Following on from this, you've seen a plan of the robot we will build in this book. </p>
			<p>In the next chapter, we will look at Raspbian, the operating system used on the Raspberry Pi in our robot, and start configuring it.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Exercise</h1>
			<ol>
				<li value="1">Try creating a block diagram for a different robot, thinking about inputs, outputs, and controllers.</li>
				<li>Are the Raspberry Pi 4B and 3A+ still the most recent versions? Would you use another model, and what would be the trade-offs? </li>
				<li>What are the drawbacks of the laser ranging sensor versus the ultrasonic distance sensor?</li>
				<li>Try drawing an approximate physical layout diagram for a different type of robot with a different controller.</li>
			</ol>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Further reading</h1>
			<ul>
				<li><em class="italic">Raspberry Pi Sensors</em>, <em class="italic">Rushi Gajjar</em>, <em class="italic">Packt Publishing</em>: Learn to integrate sensors into your Raspberry Pi projects and let your powerful microcomputer interact with the physical world.</li>
				<li><em class="italic">Make Sensors: A Hands-On Primer for Monitoring the Real World with Arduino and Raspberry Pi</em>, <em class="italic">Tero Karvinen</em>, <em class="italic">Kimmo Karvinen</em>, <em class="italic">Ville Valtokari</em>, <em class="italic">Maker Media, Inc.</em>: Learn to use sensors to connect a Raspberry Pi or Arduino controller with the real world.</li>
				<li><em class="italic">Make: Electronics: Learning Through Discovery</em>, <em class="italic">Charles Platt</em>, <em class="italic">Make Community, LLC</em>: This is a useful resource if you want to find out more about electronic components and dive deeper into the individual components.</li>
			</ul>
		</div>
	</div></body></html>