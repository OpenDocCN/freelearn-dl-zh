<html><head></head><body>
		<div><h1 id="_idParaDest-102"><em class="italic"><a id="_idTextAnchor398"/><a id="_idTextAnchor399"/>Chapter 7</em>: A* Pathfinding</h1>
			<p>In this chapter, we will implement the <strong class="bold">A* algorithm</strong> in Unity3D using C#. The A* pathfinding algorithm is widely used in games and interactive applications because of its simplicity and effectiveness. We talked about this algorithm previously in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to AI</em>. However, here, we'll review the algorithm again, this time from an implementation perspective.</p>
			<p>In this chapter, we will look at the following topics:</p>
			<ul>
				<li>Revisiting the A* algorithm </li>
				<li>Implementing the A* algorithm </li>
				<li>Setting up the scene</li>
				<li><a id="_idTextAnchor400"/>Testing the pathfinder</li>
			</ul>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor401"/>Technical requirements</h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <code>Chapter 7</code> folder in the book repository: <a id="_idTextAnchor402"/><a id="_idTextAnchor403"/><a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor404"/>Revisiting the A* algorithm</h1>
			<p>Let's review <a id="_idIndexMarker324"/>the A* algorithm before we proceed to implement it in the next section. The foundation of any pathfinding algorithm is a representation of the world. Pathfinding algorithms cannot search over the noisy structure of polygons in the game map; instead, we need to provide them with a simplified version of the world. Using this simplified structure, we can identify the locations that an agent can traverse, as well as the inaccessible ones.</p>
			<p>There are many ways of doing this; however, for this example, we use one of the most straightforward solutions: a 2D grid. Therefore, we implement the <code>GridManager</code> class to convert the "real" map into a 2D tile representation. The <code>GridManager</code> class keeps a list of <code>Node</code> objects representing a single tile in the 2D grid. First, of course, we need to implement the <code>Node</code> class too: this class stores node information such as its position, whether it's a traversable node or an obstacle, the cost to pass through, and the cost to reach the target node.</p>
			<p>Once we have a world representation, we implement an <code>AStar</code> class for the actual A* pathfinding algorithm. The class is elementary; the <code>FindPath</code> method includes all the work. The class has two variables to keep track of the already visited nodes and the nodes that will be explored. We call these variables the <code>PriorityQueue</code> class because we want to get <code>Node</code> with the lowest score as fast as possible.</p>
			<p>Instead, the closed list wants a data structure that allows us to efficiently check whether it contains a <a id="_idIndexMarker325"/>specific <code>Node</code>: usually, a data structure called a <strong class="bold">set</strong> is a<a id="_idIndexMarker326"/> good choice.</p>
			<p>Finally, the A* pseudocode is outlined here:</p>
			<ol>
				<li>First, the algorithm takes the starting node and puts it in the open list.</li>
				<li>As long as the open list is not empty, the algorithm proceeds to perform the following steps.</li>
				<li>It picks the first node from the open list and defines it as the current node (of course, we are assuming that we are using PriorityQueues for the open list).</li>
				<li>Then, it gets the neighboring nodes of this current node, excluding obstacle types (such as a wall or canyon that can't be passed through). This step is usually called expansion.</li>
				<li>For each neighbor node in step 4, it checks whether it is already in the closed list. If not, it calculates the total cost (<em class="italic">F</em>) for this neighbor node using the following formula:</li>
			</ol>
			<p class="figure-caption"><img src="img/Formula_011.png" alt=""/></p>
			<p>Here, <em class="italic">G</em> is the total cost from the starting node to this node (usually computed by adding the cost of moving from parent to neighbor to the <em class="italic">G</em> value of the parent node), and <em class="italic">H</em> is the estimated total cost from this node to the final target node. We will go over the problem of estimating the cost in later sections.</p>
			<ol>
				<li value="6">The algorithm stores that cost data in the neighbor <code>node</code> object, and it assigns the current node as the neighbor's parent node. Later, we use this parent node data to trace back the starting node from the end node, thus reconstructing the actual path.</li>
				<li>It puts this neighbor node in the open list. The open list is a priority queue ordered by the <em class="italic">F</em> value; therefore, the first node in the open list is always the one with the lowest <em class="italic">F</em> value.</li>
				<li>If there are no <a id="_idIndexMarker327"/>more neighbor nodes to process, the algorithm puts the current node in the closed list and removes it from the open list.</li>
				<li>The algorithm goes back to step 2.</li>
			</ol>
			<p>Once you have completed this algorithm, if there's an obstacle-free path to reach the target node from the start node, your current node is precisely at the target node position. Otherwise, this means that there's no available path to the target node from the current node position.</p>
			<p>When we get a valid path, we have to trace back from the current node using the parent pointer until we reach the start node again. This procedure gives us a path listing all the nodes we chose during our pathfinding process, ordered from the target node to the start node. As a final step, we just reverse this path list and get the path in the proper ord<a id="_idTextAnchor405"/>er.</p>
			<p>Next, we will implement A* in Unity3D using C#. So, let's get start<a id="_idTextAnchor406"/>ed.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor407"/>Implementing the A* algorithm</h1>
			<p>First, we implement<a id="_idIndexMarker328"/> the basic classes that we introduced before, such as the <code>Node</code> class, the <code>GridManager</code> class, and the <code>PriorityQueue</code> class. Then, we use them in the main <code>AStar</code> cl<a id="_idTextAnchor408"/><a id="_idTextAnchor409"/>ass.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor410"/>Node</h2>
			<p>The <code>Node</code> class <a id="_idIndexMarker329"/>represents each tile object in the 2D grid. Its<a id="_idIndexMarker330"/> code is shown in the <code>Node.cs</code> file:</p>
			<pre>using UnityEngine;
using System;
public class Node {
    public float costSoFar;
    public float fScore;
    public bool isObstacle;
    public Node parent;
    public Vector3 position;
    
    public Node(Vector3 pos) {
        fScore = 0.0f;
        costSoFar = 0.0f;
        isObstacle = false;
        parent = null;
        position = pos;
    }
    public void MarkAsObstacle() {
        isObstacle = true;
    }</pre>
			<p>The <code>Node</code> class stores every valuable property we need for finding a path. We are talking about properties such as the cost from the starting point (<code>costSoFar</code>), the total estimated cost from start to end (<code>fScore</code>), a flag to mark whether it is an obstacle, its positions, and its parent node. <code>costSoFar</code> is <em class="italic">G</em>, which is the movement cost value from the starting node to this node so far, and <code>fScore</code> is obviously <em class="italic">F</em>, which is the total estimated cost from the start to the target node. We also have two simple constructor <a id="_idIndexMarker331"/>methods and a wrapper method to set, depending on <a id="_idIndexMarker332"/>whether this node is an obstacle or not. Then, we implement the <code>Equals</code> and <code>GetHashCode</code> methods, as shown in the following code:</p>
			<pre>    public overr<a id="_idTextAnchor411"/><a id="_idTextAnchor412"/>ide bool Equals(object obj) {
        return obj is Node node &amp;&amp;
               position.Equals(node.position);
    }
    public over<a id="_idTextAnchor413"/><a id="_idTextAnchor414"/>ride int GetHashCode() {
        return HashCode.Combine(position);
    }
}</pre>
			<p>These methods are important. In fact, even if the <code>Node</code> class has multiple attributes, two nodes that represent the same position should be considered equal as far as the search algorithm is concerned. The way to do that is to override the default <code>Equals</code> and <code>GetHashCode</code> methods, as in the preceding <a id="_idTextAnchor415"/><a id="_idTextAnchor416"/><a id="_idTextAnchor417"/>example.</p>
			<h2 id="_idParaDest-107">Priorit<a id="_idTextAnchor418"/><a id="_idTextAnchor419"/>yQueue</h2>
			<p>A <strong class="bold">priority queue</strong> is an <a id="_idIndexMarker333"/>ordered data structure designed so<a id="_idIndexMarker334"/> that the first element (the head) of the list is always the smallest or largest element (depending on the implementation). This data structure is the most efficient way to handle the nodes in the open list because, as we will see later, we need to quickly retrieve the node with the lowest <em class="italic">F</em> value.</p>
			<p>Unfortunately, there is no easy out-of-the-box way to have a suitable priority queue (at least, until Unity supports .NET 6). The code we will use for this is shown in the following <code>NodePriorityQueue.cs</code> class:</p>
			<pre>using System.Collections.Generic;
using System.Linq;
pu<a id="_idTextAnchor420"/><a id="_idTextAnchor421"/>blic class NodePriorityQueue {
    private readonly List&lt;Node&gt; nodes = new();
    public int Length {
        get { return nodes.Count; }
    }
    public bool Contains(Node node) {
        return nodes.Contains(node);
    }
    public Node Dequeue() {
        if (nodes.Count &gt; 0) {
            var result = nodes[0];
            nodes.RemoveAt(0);
            return result;
        }
        return null;
    }
    public void Enqueue(Node node) {
        if (nodes.Contains(node)) {
            var oldNode = nodes.First(n =&gt; n.Equals(node));
            if (oldNode.fScore &lt;= node.fScore) {
                return;
            } else {
                nodes.Remove(oldNode);
            }
        }
        nodes.Add(node);
        nodes.Sort((n1, n2) =&gt; n1.fScore &lt; n2.fScore ? -1 :
                   1);
    }
} </pre>
			<p>This<a id="_idIndexMarker335"/> implementation<a id="_idIndexMarker336"/> is not particularly efficient because it relies on the <code>Sort</code> method to reorder the internal list of nodes after each insertion. This means that inserting a node becomes increasingly costly the more nodes we have in the queue. If you need better performance, you can find many priority queue implementations designed for A* and search algorithms (such as the one you can find at <a href="https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp">https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp</a>).</p>
			<p>For now, though, our small <code>NodePriorityQueue</code> class will do its job nicely. The class is self-explanatory. The only thing you need to pay attention to is the <code>Enqueue</code> method. Before adding a new node, we need to check whether there is already a node with the same position but a lower F-score. If there is, we do nothing (we already have a <em class="italic">better</em> node in the queue). If not, this means that the new node we are adding is better than the old <a id="_idIndexMarker337"/>one. Therefore, we can remove the old one to ensure<a id="_idIndexMarker338"/> that we only have the best node possible for <a id="_idTextAnchor422"/><a id="_idTextAnchor423"/>each position.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor424"/>The GridManager class</h2>
			<p>The <code>GridManager</code> class<a id="_idIndexMarker339"/> handles the 2D grid representation for<a id="_idIndexMarker340"/> the world map. We keep it as a singleton instance of the <code>GridManager</code> class, as we only need one object to represent the map. A singleton is a programming pattern that restricts the instantiation of a class to one object and, therefore, it makes the instance easily accessible from any point of the application. The code for setting up <code>GridManager</code> is shown in the <code>GridManager.cs</code> file.</p>
			<ol>
				<li value="1">The first part of the class<a id="_idIndexMarker341"/> implements the <code>GridManager</code> object in the scene and, if we find it, we store it in the <code>staticInstance</code> static variable:<pre>using UnityEngine;
using System.Collections.Generic;
public class GridManager : MonoBehaviour {
    private static GridManager staticInstance = null;
    public static GridManager instance {
        get {
            if (staticInstance == null) {
                staticInstance = FindObjectOfType(
                  typeof(GridManager)) as GridManager;
                if (staticInstance == null)
                    Debug.Log("Could not locate an
                      GridManager object. \n You have
                      to have exactly one GridManager
                      in the scene.");
            }
            return staticInstance;
        }
    }
    // Ensure that the instance is destroyed when the
    // game is stopped in the editor.
    void OnApplicationQuit() {
        staticInstance = null;
    }</pre></li>
				<li>Then, we <a id="_idIndexMarker342"/>declare all the variables that we need <a id="_idIndexMarker343"/>to represent our map. <code>numOfRows</code> and <code>numOfColumns</code> store the number of rows and columns of the grid. <code>gridCellSize</code> represents the size of each grid. <code>obstacleEpsilon</code> is the margin for the system we will use to detect obstacles (more on that later).</li>
				<li>Then we have two Boolean variables to enable or disable the debug visualization of the grid and obstacles. Finally, we have a grid of <code>nodes</code> representing the map itself. We also add two properties to get the grid's origin in world coordinates (<code>Origin</code>) and the cost of moving from one tile to the other (<code>StepCost</code>). The final product is shown in the following code:<pre>    public int numOfRows;
    public int numOfColumns;
    public float gridCellSize;
    public float obstacleEpsilon = 0.2f;
    public bool showGrid = true;
    public bool showObstacleBlocks = true;
    public Node[,] nodes { get; set; }
    public Vector3 Origin {
        get { return transform.position; }
    }
    public float StepCost {
        get { return gr<a id="_idTextAnchor425"/><a id="_idTextAnchor426"/>idCellSize; }
    }</pre></li>
				<li>Now <a id="_idIndexMarker344"/>we<a id="_idIndexMarker345"/> need to build the grid. For this, we use the <code>ComputeGrid</code> method that we call on <code>Awake</code>. The code is shown here:<pre>    void Awake() {
        ComputeGrid();
    }
    void ComputeGrid() {
        //Initialise the nodes
        nodes = new Node[numOfColumns, numOfRows];
        for (int i = 0; i &lt; numOfColumns; i++) {
            for (int j = 0; j &lt; numOfRows; j++) {
                Vector3 cellPos = 
                  GetGridCellCenter(i,j);
                Node node = new(cellPos);
                var collisions = 
    <a id="_idTextAnchor427"/><a id="_idTextAnchor428"/>              Physics.OverlapSphere(cellP<a id="_idTextAnchor429"/><a id="_idTextAnchor430"/>os,
                  gridCellSize / 2 - obstacleEpsilon,
                  1 &lt;&lt; LayerMask.NameToLayer(
                  "Obstacles"));
                if (collisions.Length != 0) {
                    node.MarkAsObstacle();
                }
                nodes[i, j] = node;
            }
        }
    } </pre></li>
				<li>The <code>ComputeGrid</code> function<a id="_idIndexMarker346"/> follows a simple <a id="_idIndexMarker347"/>algorithm. First, we just initialize the <code>nodes</code> grid. Then we start iterating over each square of the grid (represented by the coordinates <code>i</code> and <code>j</code>). For each square, we do as follows:<ol><li>First, we create a new node positioned at the center of the square (in world coordinates).</li><li>Then, we check whether that square is occupied by an obstacle. <a id="_idTextAnchor431"/><a id="_idTextAnchor432"/>We do this by using the <code>OverlapSphere</code> function. This <code>Physics</code> function returns all the colliders inside or intersecting the sphere defined in the parameters. In our case, we center the sphere at the center of the grid's cell (<code>cellPos</code>) and we define the sphere's radius as a bit less than the grid cell size. Note that we are only interested in colliders in the <code>Obstacles</code> layer, therefore we need to add the appropriate layer mask.</li><li>If the <code>OverlapSphere</code> function returns anything, this means that we have an obstacle inside the cell and, therefore, we define the entire cell as an obstacle.</li></ol></li>
			</ol>
			<p><code>GridManager</code> also<a id="_idIndexMarker348"/> has several helper methods to traverse the grid and get the grid cell data. We <a id="_idIndexMarker349"/>show some of them in the following list, with a brief description of what they do. The implementation is simple:</p>
			<ol>
				<li value="1">The <code>GetGridCellCenter</code> method returns the position of the grid cell in world coordinates from the cell coordinates, as shown in the following code:<pre>    public Vector3 GetGridCellCenter(int col, int row)
    {
        Vector3 cellPosition = 
          GetGridCellPosition(col, row);
        cellPosition.x += gridCellSize / 2.0f;
        cellPosition.z += gridCellSize / 2.0f;
        return cellPosition;
    }
    public Vector3 GetGridCellPosition(int col, int 
      row) {
        float xPosInGrid = col * gridCellSize;
        float zPosInGrid = row * gridCellSize;
        return Origin + new Vector3(xPosInGrid, 0.0f,
          zPosInGrid);
    }</pre></li>
				<li>The <code>IsInBounds</code> method<a id="_idIndexMarker350"/> checks whether a<a id="_idIndexMarker351"/> certain position in the game falls inside the grid:<pre>public bool IsInBounds(Vector3 pos) {
    float width = numOfColumns * gridCellSize;
    float height = numOfRows * gridCellSize;
    return (pos.x &gt;= Origin.x &amp;&amp; pos.x &lt;= Origin.x +
      width &amp;&amp; pos.x &lt;= Origin.z + height &amp;&amp; pos.z &gt;= 
      Origin.z);
}</pre></li>
				<li>The <code>IsTraversable</code> method checks whether a grid coordinate is traversable (that is, it is not an obstacle):<pre>    public bool IsTraversable(int col, int row) {
        return col &gt;= 0 &amp;&amp; row &gt;= 0 &amp;&amp; col &lt;
          numOfColumns &amp;&amp; row &lt; numOfRows &amp;&amp; 
          !nodes[col, row].isObstacle;
    }</pre></li>
				<li>Another important method is <code>GetNeighbours</code>, which is used by the <code>AStar</code> class to retrieve the neighboring nodes of a particular node. This is done by obtaining the<a id="_idIndexMarker352"/> grid coordinate of the node and then<a id="_idIndexMarker353"/> checking whether the four neighbors' coordinates (up, down, left, and right) are traversable:<pre>public List&lt;Node&gt; GetNeighbours(Node node) {
        List&lt;Node&gt; result = new();
        var (column, row) =
          GetGridCoordinates(node.position);
        if (IsTraversable(column – 1, row)) {
            result.Add(nodes[column – 1, row]);
        }
        if (IsTraversable(column + 1, row)) {
            result.Add(nodes[column + 1, row]);
        }
        if (IsTraversable(column, row – 1)) {
            result.Add(nodes[column, row – 1]);
        }
        if (IsTraversable(column, row + 1)) {
            result.Add(nodes[column, row + 1]);
        }
        return result;
}</pre></li>
				<li>Finally, we have<a id="_idIndexMarker354"/> debug aid methods used to visualize the grid and <a id="_idIndexMarker355"/>obstacle blocks:<pre>    void OnDrawGizmos() {
        if (showGrid) {
            DebugDrawGrid(Color.blue);
        }
        //Grid Start Position
        Gizmos.DrawSphere(Origin, 0.5f);
        if (nodes == null) return;
        //Draw Obstacle obstruction
        if (showObstacleBlocks) {
            Vector3 cellSize = new Vector3(
              gridCellSize, 1.0f, gridCellSize);
            Gizmos.color = Color.red;
            for (int i = 0; i &lt; numOfColumns; i++) {
                for (int j = 0; j &lt; numOfRows; j++) {
                    if (nodes != null &amp;&amp; nodes[i, 
                        j].isObstacle) {
                        Gizmos.DrawCube(
                          GetGridCellCenter(i,j),
                          cellSize);
                    }
                }
            }
        }
    }
    public void DebugDrawGrid(Color color) {
        float width = (numOfColumns * gridCellSize);
        float height = (numOfRows * gridCellSize);
        // Draw the horizontal grid lines
        for (int i = 0; i &lt; numOfRows + 1; i++) {
            Vector3 startPos = Origin + i *
              gridCellSize * new Vector3(0.0f, 0.0f,
                                         1.0f);
            Vector3 endPos = startPos + width * new
              Vector3(1.0f, 0.0f, 0.0f);
            Debug.DrawLine(startPos, endPos, color);
        }
        // Draw the vertial grid lines
        for (int i = 0; i &lt; numOfColumns + 1; i++) {
            Vector3 startPos = Origin + i *
              gridCellSize * new Vector3(1.0f, 0.0f, 
                                         0.0f);
            Vector3 endPos = startPos + height * new
              Vector3(0.0f, 0.0f, 1.0f);
            Debug.DrawLine(startPos, endPos, color);
        }
}</pre></li>
			</ol>
			<p>Gizmos can be used to draw visual debugging and setup aids inside the editor scene view. <code>OnDrawGizmos</code> is called every frame by the engine. So, if the debug flags, <code>showGrid</code> and <code>showObstacleBlocks</code>, are checked, we just draw the grid with lines and the obstacle cube objects with cubes. We won't go through the <code>DebugDrawGrid</code> method, as<a id="_idIndexMarker356"/> it's<a id="_idIndexMarker357"/> pretty simple.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">You can learn more about gizmos in the following Unity3D reference documentation: <a href="https://docs.unity3d.com/ScriptReference/Gizmos.html">https://docs.unity3d.com/ScriptReference/Gizmos.html</a>.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor435"/>The AStar class</h2>
			<p>The <code>AStar</code> class<a id="_idIndexMarker358"/> implements<a id="_idIndexMarker359"/> the pathfinding algorithm using the classes we have implemented so far. If you want a quick review of the A* algorithm, see the <em class="italic">Revisiting the A* algorithm</em> section earlier in this chapter. The steps for the implementation of <code>AStar</code> are as follows:</p>
			<ol>
				<li value="1">We start by implementing a method called <code>HeuristicEstimateCost</code> to calculate the cost between the two nodes. The calculation is simple. We just find the direction vector between the two by subtracting one position vector from another. The magnitude of this resultant vector gives the straight-line distance from the current node to the target node:<pre>using UnityEngine;
using System.Collections.Generic; 
public class AStar {
    private float HeuristicEstimateCost(Node curNode,
      Node goalNode) {
        return (curNode.position –
                goalNode.position).magnitude;
    }</pre><p class="callout-heading">Info</p><p class="callout">In theory, you can replace this function with any function, returning the distance between <code>curNode</code> and <code>goalNode</code>. However, for A* to return the shortest possible path, this function must be admissible. In short, an admissible heuristic function is a function that never overestimates the actual "real world" cost between <code>curNode</code> and <code>goalNode</code>. As an exercise, you can easily verify that the function we use in this demo is admissible. For more information on the math behind heuristic functions, you can visit <a href="https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html</a>.</p></li>
				<li>Then, we have the main A* algorithm in the <code>FindPath</code> method. In the following <a id="_idIndexMarker360"/>snippet, we initialize the open and closed lists. Starting <a id="_idIndexMarker361"/>with the start node, we put it in our open list. Then, we start processing our open list:<pre>    public List&lt;Node&gt; FindPath(Node start, Node goal) { 
        //Start Finding the path
        NodePriorityQueue openList =
          new NodePriorityQueue();
        openList.Enqueue(start);
        start.costSoFar = 0.0f;
        start.fScore = HeuristicEstimateCost(start,
                                             goal);
        HashSet&lt;Node&gt; closedLi<a id="_idTextAnchor436"/><a id="_idTextAnchor437"/>st = new();
        Node node = null;</pre></li>
				<li>Then, we<a id="_idIndexMarker362"/> proceed with the main algorithm loop:<pre>        while (openList.Length != 0) {
            node = openList.Dequeue();
            if (node.position == goal.position) {
                return CalculatePath(node);
            }
            var neighbours =
              GridManager.instance.GetNeighbours(
              node);
            
            foreach (Node neighbourNode in neighbours)
            {
                if (!closedList.Contains(
                    neighbourNode)) {
                    float totalCost = node.costSoFar +
                      GridManager.instance.StepCost;
                    float heuristicValue =
                      HeuristicEstimateCost(
                      neighbourNode, goal);
                    //Assign neighbour node properties
                    neighbourNode.costSoFar = 
                      totalCost;
                    neighbourNode.parent = node;
                    neighbourNode.fScore = 
                      totalCost + heuristicValue;
                    //Add the neighbour node to the 
                    //queue
                    if (!closedList.Contains(
                        neighbourNode)) {
                               openList.Enqueue(
                                 neighbourNode);
                    }
                    
                }
            }
            closedList.Add(node);
        }</pre><ol><li>The <a id="_idIndexMarker363"/>preceding <a id="_idIndexMarker364"/>code implementation strictly follows the algorithm that we have discussed previously, so you can refer back to it if something is not clear:</li><li>Get the first node from our <code>openList</code>. Remember, <code>openList</code> is always sorted in increasing order. Therefore, the first node is always the node with the lowest <em class="italic">F</em> value.</li><li>Check whether the current node is already at the target node. If so, exit the <code>while</code> loop and build the path array.</li><li>Create an array list to store the neighboring nodes of the current node being processed. Then, use the <code>GetNeighbours</code> method to retrieve the neighbors from the grid.</li><li>For every node in the array of neighbors, we check whether it's already in <code>closedList</code>. If not, we calculate the cost values, update the node properties with the new cost values and the parent node data, and put it in <code>openList</code>.</li><li>Push the current node to <code>closedList</code> and remove it from <code>openList</code>. </li><li>Go back to <em class="italic">step I</em>.</li></ol></li>
				<li>If there <a id="_idIndexMarker365"/>are no<a id="_idIndexMarker366"/> more nodes in <code>openList</code>, the current node should be at the target node if there's a valid path available:<pre>        //If finished looping and cannot find the goal
        //then return null
        if (node.position != goal.position) {
            Debug.LogError("Goal Not Found");
            return null;
        }
        //Calculate the path based on the final node
        return CalculatePath(node);</pre></li>
				<li>Finally, we call the <code>CalculatePath</code> method with the current node parameter:<pre>    private List&lt;Node&gt; CalculatePath(Node node) { 
        List&lt;Node&gt; list = new();
        while (node != null) {
            list.Add(node);
            node = node.parent;
        }
        list.Reverse();
        return list;
    }
}</pre></li>
				<li>The <code>CalculatePath</code> method traces through each node's parent <code>node</code> object and builds an array list. Since we want a path array from the start node to the tar<a id="_idTextAnchor438"/>get<a id="_idIndexMarker367"/> node, we <a id="_idIndexMarker368"/>just call the <code>Reverse</code> method.</li>
			</ol>
			<p>Now, we'll write a test <a id="_idTextAnchor439"/>script to test this and set up a demo scene.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor440"/>The TestCode class</h2>
			<p>The <code>TestCode</code> class<a id="_idIndexMarker369"/> uses <a id="_idIndexMarker370"/>the <code>AStar</code> class to find the path from the start node to the target node, as shown in the following code from the <code>TestCode.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
public class TestCode : MonoBehaviour {
    private Transform startPos, endPos;
    public Node startNode { get; set; }
    public Node goalNode { get; set; }
    public List&lt;Node&gt; pathArray;
    GameObject objStartCube, objEndCube;
    private float elapsedTime = 0.0f;
    //Interval time between pathfinding 
    public float intervalTime = 1.0f;</pre>
			<p>In the preceding snippet, we first set up the variables that we need to reference. The <code>pathArray</code> variable stores the nodes array that's returned from the <code>AStar</code> <code>FindPath</code> method.</p>
			<p>In the following code block, we use the <code>Start</code> method to look for objects with the tags <code>Start</code> and <code>End</code> and initialize <code>pathArray</code>. We are trying to find a new path at every interval, specified by the <code>intervalTime</code> property, in case the positions of the start and end <a id="_idIndexMarker371"/>nodes <a id="_idIndexMarker372"/>have changed. Finally, we call the <code>FindPath</code> method:</p>
			<pre>    void Start () {
        objStartCube = 
          GameObject.FindGameObjectWithTag("Start"); 
        objEndCube =
          GameObject.FindGameObjectWithTag("End");
        pathArray = new List&lt;Node&gt;();
        FindPath();
    }
    void Update () {
        elapsedTime += Time.deltaTime;
        if (elapsedTime &gt;= intervalTime) {
            elapsedTime = 0.0f;
            FindPath();
        }
    }</pre>
			<p>Since we implemented our pathfinding algorithm in the <code>AStar</code> class, finding a path is much simpler. In the following snippet, we first take the positions of the start and end game objects. Then, we create new <code>Node</code> objects using the <code>GetGridIndex</code> helper methods in <code>GridManager</code> to calculate their respective row and column index positions inside the grid.</p>
			<p>After that, we call the <code>AStar.FindPath</code> method with the start node and target node, storing the <a id="_idIndexMarker373"/>returned<a id="_idIndexMarker374"/> array list in the local <code>pathArray</code> property. Finally, we implement the <code>OnDrawGizmos</code> method to draw and visualize the resulting path:</p>
			<pre>void FindPath() {
        startPos = objStartCube.transform;
        endPos = objEndCube.transform;
        //Assign StartNode and Goal Node
        var (startColumn, startRow) = 
          GridManager.instance.GetGridCoordinates(
          startPos.position);
        var (goalColumn, goalRow) = 
          GridManager.instance.GetGridCoordinates(
          endPos.position);
        startNode = new Node(
          GridManager.instance.GetGridCellCenter(
          startColumn, startRow));
        goalNode = new Node(
          GridManager.instance.GetGridCellCenter(
          goalColumn, goalRow));
        pathArray = 
          new AStar().FindPath(startNode, goalNode);
}</pre>
			<p>We look through our <code>pathArray</code> and use the <code>Debug.DrawLine</code> method to draw the lines, connecting <a id="_idIndexMarker375"/>the <a id="_idIndexMarker376"/>nodes in <code>pathArray</code>:</p>
			<pre>    void OnDrawGizmos() {
        if (pathArray == null)
            return;
        if (pathArray.Count &gt; 0) {
            int index = 1;
            foreach (Node node in pathArray) {
                if (index &lt; pathArray.Count) {
                    Node nextNode = pathArray[index];
                    Debug.DrawLine(node.position,
                      nextNode.position, Color.green);
                    index++;
                }
            };
        }
    }
}</pre>
			<p>When we<a id="_idIndexMarker377"/> run and test our program, we should see<a id="_idTextAnchor441"/><a id="_idTextAnchor442"/> a green line<a id="_idIndexMarker378"/> connecting the nodes from start to end.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor443"/>Setting up the scene</h1>
			<p>We are going<a id="_idIndexMarker379"/> to set up a scene that looks like the following screenshot:</p>
			<div><div><img src="img/B17984_07_1.jpg" alt="Figure 7.1 – Our sample test scene with obstacles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Our sample test scene with obstacles</p>
			<p>Let's follow a step-by-step procedure to do this:</p>
			<ol>
				<li value="1">We create a directional light, the start and end game object, a few obstacle objects, a plane entity to be used as ground, and two empty game objects in which we put the <code>GridManager</code> and <code>TestAStar</code> scripts. After this step, our scene hierarchy should be like this:</li>
			</ol>
			<p class="figure-caption"><img src="img/B17984_07_2.png" alt="Figure 7.2 – The demo scene hierarchy&#13;&#10;"/></p>
			<p class="figure-caption">Figure 7.2 – The demo scene hierarchy</p>
			<ol>
				<li value="2">We create a<a id="_idIndexMarker380"/> bunch of cube entities and add them to the <code>GridManager</code> looks for objects with this tag when it creates the grid world representation:</li>
			</ol>
			<div><div><img src="img/B17984_07_3.jpg" alt="Figure 7.3 – The Obstacle nodes seen in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – The Obstacle nodes seen in the Inspector</p>
			<ol>
				<li value="3">We then <a id="_idIndexMarker381"/>create a cube entity and tag it as <strong class="bold">Start</strong>:</li>
			</ol>
			<div><div><img src="img/B17984_07_4.jpg" alt="Figure 7.4 – The Start node seen in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – The Start node seen in the Inspector</p>
			<ol>
				<li value="4">Then, we <a id="_idIndexMarker382"/>create another cube entity and tag it as <strong class="bold">End</strong>:</li>
			</ol>
			<div><div><img src="img/B17984_07_5.jpg" alt="Figure 7.5 – The End node seen in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – The End node seen in the Inspector</p>
			<ol>
				<li value="5">We create an empty game object, and we attach the <code>GridManager</code> script to it. We also set the name to <code>GridManager</code> because we use this name to look for the <code>GridManager</code> object from inside the other scripts.</li>
				<li>Then, we set <a id="_idIndexMarker383"/>up the number of rows and columns of the grid and the size of each tile.</li>
			</ol>
			<div><div><img src="img/B17984_07_6.jpg" alt="Figure 7.6 – GridManager script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – GridManager script</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor444"/>Testing the pathfinder</h2>
			<p>Once we <a id="_idIndexMarker384"/>hit <a id="_idIndexMarker385"/>the <strong class="bold">Play</strong> button, we should see the A* pathfinding algorithm in action. By default, once you play the scene, Unity3D switches to the <strong class="bold">Game</strong> view. However, since our pathfinding visualization code draws in the debug editor view, to see the found path, you need to switch back to the <strong class="bold">Scene</strong> view or enable <strong class="bold">Gizmos</strong> visualization:</p>
			<div><div><img src="img/B17984_07_7.jpg" alt="Figure 7.7 – The ﬁrst path found by the algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – The ﬁrst path found by the algorithm</p>
			<p>Now, try to <a id="_idIndexMarker386"/>move <a id="_idIndexMarker387"/>the start or end node around in the scene using the editor's movement gizmo (not in the <strong class="bold">Game</strong> view, but the <strong class="bold">Scene</strong> view):</p>
			<div><div><img src="img/B17984_07_8.jpg" alt="Figure 7.8 – A second path found by the algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – A second path found by the algorithm</p>
			<p>You should <a id="_idIndexMarker388"/>see<a id="_idIndexMarker389"/> that the path is updated dynamically in real time. On the other hand, if there is no available path<a id="_idTextAnchor445"/>, you get an error message in the console window instead.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor446"/>Summary</h1>
			<p>In this chapter, we learned how to implement the A* pathfinding algorithm in Unity3D. First, we implemented our own A* pathfinding class, grid representation class, priority queue class, and node class. Finally, we used debug draw functionalities to visualize the grid and path information.</p>
			<p>In later chapters, we will see that thanks to Unity3D's <strong class="bold">NavMesh</strong> and <strong class="bold">NavAgent</strong> features, it may not be necessary for you to implement a custom pathfinding algorithm on your own.</p>
			<p>Nonetheless, understanding a basic pathfinding algorithm gives you a better foundation for getting to grips with many other advanced pathfinding techniques.</p>
			<p>In the next chapter, we will extend the idea behind the A* algorithm to a more complex world representation: navigation meshes.</p>
		</div>
	</body></html>