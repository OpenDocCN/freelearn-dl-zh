<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-102"><em class="italic"><a id="_idTextAnchor398"/><a id="_idTextAnchor399"/>Chapter 7</em>: A* Pathfinding</h1>
			<p>In this chapter, we will implement the <strong class="bold">A* algorithm</strong> in Unity3D using C#. The A* pathfinding algorithm is widely used in games and interactive applications because of its simplicity and effectiveness. We talked about this algorithm previously in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to AI</em>. However, here, we'll review the algorithm again, this time from an implementation perspective.</p>
			<p>In this chapter, we will look at the following topics:</p>
			<ul>
				<li>Revisiting the A* algorithm </li>
				<li>Implementing the A* algorithm </li>
				<li>Setting up the scene</li>
				<li><a id="_idTextAnchor400"/>Testing the pathfinder</li>
			</ul>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor401"/>Technical requirements</h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <strong class="source-inline">Chapter 7</strong> folder in the book repository: <a id="_idTextAnchor402"/><a id="_idTextAnchor403"/><a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor404"/>Revisiting the A* algorithm</h1>
			<p>Let's review <a id="_idIndexMarker324"/>the A* algorithm before we proceed to implement it in the next section. The foundation of any pathfinding algorithm is a representation of the world. Pathfinding algorithms cannot search over the noisy structure of polygons in the game map; instead, we need to provide them with a simplified version of the world. Using this simplified structure, we can identify the locations that an agent can traverse, as well as the inaccessible ones.</p>
			<p>There are many ways of doing this; however, for this example, we use one of the most straightforward solutions: a 2D grid. Therefore, we implement the <strong class="source-inline">GridManager</strong> class to convert the "real" map into a 2D tile representation. The <strong class="source-inline">GridManager</strong> class keeps a list of <strong class="source-inline">Node</strong> objects representing a single tile in the 2D grid. First, of course, we need to implement the <strong class="source-inline">Node</strong> class too: this class stores node information such as its position, whether it's a traversable node or an obstacle, the cost to pass through, and the cost to reach the target node.</p>
			<p>Once we have a world representation, we implement an <strong class="source-inline">AStar</strong> class for the actual A* pathfinding algorithm. The class is elementary; the <strong class="source-inline">FindPath</strong> method includes all the work. The class has two variables to keep track of the already visited nodes and the nodes that will be explored. We call these variables the <strong class="bold">closed list</strong> and <strong class="bold">open list</strong>, respectively. We implement the open list with a <strong class="source-inline">PriorityQueue</strong> class because we want to get <strong class="source-inline">Node</strong> with the lowest score as fast as possible.</p>
			<p>Instead, the closed list wants a data structure that allows us to efficiently check whether it contains a <a id="_idIndexMarker325"/>specific <strong class="source-inline">Node</strong>: usually, a data structure called a <strong class="bold">set</strong> is a<a id="_idIndexMarker326"/> good choice.</p>
			<p>Finally, the A* pseudocode is outlined here:</p>
			<ol>
				<li>First, the algorithm takes the starting node and puts it in the open list.</li>
				<li>As long as the open list is not empty, the algorithm proceeds to perform the following steps.</li>
				<li>It picks the first node from the open list and defines it as the current node (of course, we are assuming that we are using PriorityQueues for the open list).</li>
				<li>Then, it gets the neighboring nodes of this current node, excluding obstacle types (such as a wall or canyon that can't be passed through). This step is usually called expansion.</li>
				<li>For each neighbor node in step 4, it checks whether it is already in the closed list. If not, it calculates the total cost (<em class="italic">F</em>) for this neighbor node using the following formula:</li>
			</ol>
			<p class="figure-caption"><img src="image/Formula_011.png" alt=""/></p>
			<p>Here, <em class="italic">G</em> is the total cost from the starting node to this node (usually computed by adding the cost of moving from parent to neighbor to the <em class="italic">G</em> value of the parent node), and <em class="italic">H</em> is the estimated total cost from this node to the final target node. We will go over the problem of estimating the cost in later sections.</p>
			<ol>
				<li value="6">The algorithm stores that cost data in the neighbor <strong class="source-inline">node</strong> object, and it assigns the current node as the neighbor's parent node. Later, we use this parent node data to trace back the starting node from the end node, thus reconstructing the actual path.</li>
				<li>It puts this neighbor node in the open list. The open list is a priority queue ordered by the <em class="italic">F</em> value; therefore, the first node in the open list is always the one with the lowest <em class="italic">F</em> value.</li>
				<li>If there are no <a id="_idIndexMarker327"/>more neighbor nodes to process, the algorithm puts the current node in the closed list and removes it from the open list.</li>
				<li>The algorithm goes back to step 2.</li>
			</ol>
			<p>Once you have completed this algorithm, if there's an obstacle-free path to reach the target node from the start node, your current node is precisely at the target node position. Otherwise, this means that there's no available path to the target node from the current node position.</p>
			<p>When we get a valid path, we have to trace back from the current node using the parent pointer until we reach the start node again. This procedure gives us a path listing all the nodes we chose during our pathfinding process, ordered from the target node to the start node. As a final step, we just reverse this path list and get the path in the proper ord<a id="_idTextAnchor405"/>er.</p>
			<p>Next, we will implement A* in Unity3D using C#. So, let's get start<a id="_idTextAnchor406"/>ed.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor407"/>Implementing the A* algorithm</h1>
			<p>First, we implement<a id="_idIndexMarker328"/> the basic classes that we introduced before, such as the <strong class="source-inline">Node</strong> class, the <strong class="source-inline">GridManager</strong> class, and the <strong class="source-inline">PriorityQueue</strong> class. Then, we use them in the main <strong class="source-inline">AStar</strong> cl<a id="_idTextAnchor408"/><a id="_idTextAnchor409"/>ass.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor410"/>Node</h2>
			<p>The <strong class="source-inline">Node</strong> class <a id="_idIndexMarker329"/>represents each tile object in the 2D grid. Its<a id="_idIndexMarker330"/> code is shown in the <strong class="source-inline">Node.cs</strong> file:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System;</p>
			<p class="source-code">public class Node {</p>
			<p class="source-code">    public float costSoFar;</p>
			<p class="source-code">    public float fScore;</p>
			<p class="source-code">    public bool isObstacle;</p>
			<p class="source-code">    public Node parent;</p>
			<p class="source-code">    public Vector3 position;</p>
			<p class="source-code">    </p>
			<p class="source-code">    public Node(Vector3 pos) {</p>
			<p class="source-code">        fScore = 0.0f;</p>
			<p class="source-code">        costSoFar = 0.0f;</p>
			<p class="source-code">        isObstacle = false;</p>
			<p class="source-code">        parent = null;</p>
			<p class="source-code">        position = pos;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void MarkAsObstacle() {</p>
			<p class="source-code">        isObstacle = true;</p>
			<p class="source-code">    }</p>
			<p>The <strong class="source-inline">Node</strong> class stores every valuable property we need for finding a path. We are talking about properties such as the cost from the starting point (<strong class="source-inline">costSoFar</strong>), the total estimated cost from start to end (<strong class="source-inline">fScore</strong>), a flag to mark whether it is an obstacle, its positions, and its parent node. <strong class="source-inline">costSoFar</strong> is <em class="italic">G</em>, which is the movement cost value from the starting node to this node so far, and <strong class="source-inline">fScore</strong> is obviously <em class="italic">F</em>, which is the total estimated cost from the start to the target node. We also have two simple constructor <a id="_idIndexMarker331"/>methods and a wrapper method to set, depending on <a id="_idIndexMarker332"/>whether this node is an obstacle or not. Then, we implement the <strong class="source-inline">Equals</strong> and <strong class="source-inline">GetHashCode</strong> methods, as shown in the following code:</p>
			<p class="source-code">    public overr<a id="_idTextAnchor411"/><a id="_idTextAnchor412"/>ide bool Equals(object obj) {</p>
			<p class="source-code">        return obj is Node node &amp;&amp;</p>
			<p class="source-code">               position.Equals(node.position);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public over<a id="_idTextAnchor413"/><a id="_idTextAnchor414"/>ride int GetHashCode() {</p>
			<p class="source-code">        return HashCode.Combine(position);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>These methods are important. In fact, even if the <strong class="source-inline">Node</strong> class has multiple attributes, two nodes that represent the same position should be considered equal as far as the search algorithm is concerned. The way to do that is to override the default <strong class="source-inline">Equals</strong> and <strong class="source-inline">GetHashCode</strong> methods, as in the preceding <a id="_idTextAnchor415"/><a id="_idTextAnchor416"/><a id="_idTextAnchor417"/>example.</p>
			<h2 id="_idParaDest-107">Priorit<a id="_idTextAnchor418"/><a id="_idTextAnchor419"/>yQueue</h2>
			<p>A <strong class="bold">priority queue</strong> is an <a id="_idIndexMarker333"/>ordered data structure designed so<a id="_idIndexMarker334"/> that the first element (the head) of the list is always the smallest or largest element (depending on the implementation). This data structure is the most efficient way to handle the nodes in the open list because, as we will see later, we need to quickly retrieve the node with the lowest <em class="italic">F</em> value.</p>
			<p>Unfortunately, there is no easy out-of-the-box way to have a suitable priority queue (at least, until Unity supports .NET 6). The code we will use for this is shown in the following <strong class="source-inline">NodePriorityQueue.cs</strong> class:</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using System.Linq;</p>
			<p class="source-code">pu<a id="_idTextAnchor420"/><a id="_idTextAnchor421"/>blic class NodePriorityQueue {</p>
			<p class="source-code">    private readonly List&lt;Node&gt; nodes = new();</p>
			<p class="source-code">    public int Length {</p>
			<p class="source-code">        get { return nodes.Count; }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public bool Contains(Node node) {</p>
			<p class="source-code">        return nodes.Contains(node);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public Node Dequeue() {</p>
			<p class="source-code">        if (nodes.Count &gt; 0) {</p>
			<p class="source-code">            var result = nodes[0];</p>
			<p class="source-code">            nodes.RemoveAt(0);</p>
			<p class="source-code">            return result;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return null;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void Enqueue(Node node) {</p>
			<p class="source-code">        if (nodes.Contains(node)) {</p>
			<p class="source-code">            var oldNode = nodes.First(n =&gt; n.Equals(node));</p>
			<p class="source-code">            if (oldNode.fScore &lt;= node.fScore) {</p>
			<p class="source-code">                return;</p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                nodes.Remove(oldNode);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        nodes.Add(node);</p>
			<p class="source-code">        nodes.Sort((n1, n2) =&gt; n1.fScore &lt; n2.fScore ? -1 :</p>
			<p class="source-code">                   1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">} </p>
			<p>This<a id="_idIndexMarker335"/> implementation<a id="_idIndexMarker336"/> is not particularly efficient because it relies on the <strong class="source-inline">Sort</strong> method to reorder the internal list of nodes after each insertion. This means that inserting a node becomes increasingly costly the more nodes we have in the queue. If you need better performance, you can find many priority queue implementations designed for A* and search algorithms (such as the one you can find at <a href="https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp">https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp</a>).</p>
			<p>For now, though, our small <strong class="source-inline">NodePriorityQueue</strong> class will do its job nicely. The class is self-explanatory. The only thing you need to pay attention to is the <strong class="source-inline">Enqueue</strong> method. Before adding a new node, we need to check whether there is already a node with the same position but a lower F-score. If there is, we do nothing (we already have a <em class="italic">better</em> node in the queue). If not, this means that the new node we are adding is better than the old <a id="_idIndexMarker337"/>one. Therefore, we can remove the old one to ensure<a id="_idIndexMarker338"/> that we only have the best node possible for <a id="_idTextAnchor422"/><a id="_idTextAnchor423"/>each position.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor424"/>The GridManager class</h2>
			<p>The <strong class="source-inline">GridManager</strong> class<a id="_idIndexMarker339"/> handles the 2D grid representation for<a id="_idIndexMarker340"/> the world map. We keep it as a singleton instance of the <strong class="source-inline">GridManager</strong> class, as we only need one object to represent the map. A singleton is a programming pattern that restricts the instantiation of a class to one object and, therefore, it makes the instance easily accessible from any point of the application. The code for setting up <strong class="source-inline">GridManager</strong> is shown in the <strong class="source-inline">GridManager.cs</strong> file.</p>
			<ol>
				<li value="1">The first part of the class<a id="_idIndexMarker341"/> implements the <strong class="bold">singleton pattern</strong>. We look for the <strong class="source-inline">GridManager</strong> object in the scene and, if we find it, we store it in the <strong class="source-inline">staticInstance</strong> static variable:<p class="source-code">using UnityEngine;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">public class GridManager : MonoBehaviour {</p><p class="source-code">    private static GridManager staticInstance = null;</p><p class="source-code">    public static GridManager instance {</p><p class="source-code">        get {</p><p class="source-code">            if (staticInstance == null) {</p><p class="source-code">                staticInstance = FindObjectOfType(</p><p class="source-code">                  typeof(GridManager)) as GridManager;</p><p class="source-code">                if (staticInstance == null)</p><p class="source-code">                    Debug.Log("Could not locate an</p><p class="source-code">                      GridManager object. \n You have</p><p class="source-code">                      to have exactly one GridManager</p><p class="source-code">                      in the scene.");</p><p class="source-code">            }</p><p class="source-code">            return staticInstance;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    // Ensure that the instance is destroyed when the</p><p class="source-code">    // game is stopped in the editor.</p><p class="source-code">    void OnApplicationQuit() {</p><p class="source-code">        staticInstance = null;</p><p class="source-code">    }</p></li>
				<li>Then, we <a id="_idIndexMarker342"/>declare all the variables that we need <a id="_idIndexMarker343"/>to represent our map. <strong class="source-inline">numOfRows</strong> and <strong class="source-inline">numOfColumns</strong> store the number of rows and columns of the grid. <strong class="source-inline">gridCellSize</strong> represents the size of each grid. <strong class="source-inline">obstacleEpsilon</strong> is the margin for the system we will use to detect obstacles (more on that later).</li>
				<li>Then we have two Boolean variables to enable or disable the debug visualization of the grid and obstacles. Finally, we have a grid of <strong class="source-inline">nodes</strong> representing the map itself. We also add two properties to get the grid's origin in world coordinates (<strong class="source-inline">Origin</strong>) and the cost of moving from one tile to the other (<strong class="source-inline">StepCost</strong>). The final product is shown in the following code:<p class="source-code">    public int numOfRows;</p><p class="source-code">    public int numOfColumns;</p><p class="source-code">    public float gridCellSize;</p><p class="source-code">    public float obstacleEpsilon = 0.2f;</p><p class="source-code">    public bool showGrid = true;</p><p class="source-code">    public bool showObstacleBlocks = true;</p><p class="source-code">    public Node[,] nodes { get; set; }</p><p class="source-code">    public Vector3 Origin {</p><p class="source-code">        get { return transform.position; }</p><p class="source-code">    }</p><p class="source-code">    public float StepCost {</p><p class="source-code">        get { return gr<a id="_idTextAnchor425"/><a id="_idTextAnchor426"/>idCellSize; }</p><p class="source-code">    }</p></li>
				<li>Now <a id="_idIndexMarker344"/>we<a id="_idIndexMarker345"/> need to build the grid. For this, we use the <strong class="source-inline">ComputeGrid</strong> method that we call on <strong class="source-inline">Awake</strong>. The code is shown here:<p class="source-code">    void Awake() {</p><p class="source-code">        ComputeGrid();</p><p class="source-code">    }</p><p class="source-code">    void ComputeGrid() {</p><p class="source-code">        //Initialise the nodes</p><p class="source-code">        nodes = new Node[numOfColumns, numOfRows];</p><p class="source-code">        for (int i = 0; i &lt; numOfColumns; i++) {</p><p class="source-code">            for (int j = 0; j &lt; numOfRows; j++) {</p><p class="source-code">                Vector3 cellPos = </p><p class="source-code">                  GetGridCellCenter(i,j);</p><p class="source-code">                Node node = new(cellPos);</p><p class="source-code">                var collisions = </p><p class="source-code">    <a id="_idTextAnchor427"/><a id="_idTextAnchor428"/>              Physics.OverlapSphere(cellP<a id="_idTextAnchor429"/><a id="_idTextAnchor430"/>os,</p><p class="source-code">                  gridCellSize / 2 - obstacleEpsilon,</p><p class="source-code">                  1 &lt;&lt; LayerMask.NameToLayer(</p><p class="source-code">                  "Obstacles"));</p><p class="source-code">                if (collisions.Length != 0) {</p><p class="source-code">                    node.MarkAsObstacle();</p><p class="source-code">                }</p><p class="source-code">                nodes[i, j] = node;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    } </p></li>
				<li>The <strong class="source-inline">ComputeGrid</strong> function<a id="_idIndexMarker346"/> follows a simple <a id="_idIndexMarker347"/>algorithm. First, we just initialize the <strong class="source-inline">nodes</strong> grid. Then we start iterating over each square of the grid (represented by the coordinates <strong class="source-inline">i</strong> and <strong class="source-inline">j</strong>). For each square, we do as follows:<ol><li>First, we create a new node positioned at the center of the square (in world coordinates).</li><li>Then, we check whether that square is occupied by an obstacle. <a id="_idTextAnchor431"/><a id="_idTextAnchor432"/>We do this by using the <strong class="source-inline">OverlapSphere</strong> function. This <strong class="source-inline">Physics</strong> function returns all the colliders inside or intersecting the sphere defined in the parameters. In our case, we center the sphere at the center of the grid's cell (<strong class="source-inline">cellPos</strong>) and we define the sphere's radius as a bit less than the grid cell size. Note that we are only interested in colliders in the <strong class="source-inline">Obstacles</strong> layer, therefore we need to add the appropriate layer mask.</li><li>If the <strong class="source-inline">OverlapSphere</strong> function returns anything, this means that we have an obstacle inside the cell and, therefore, we define the entire cell as an obstacle.</li></ol></li>
			</ol>
			<p><strong class="source-inline">GridManager</strong> also<a id="_idIndexMarker348"/> has several helper methods to traverse the grid and get the grid cell data. We <a id="_idIndexMarker349"/>show some of them in the following list, with a brief description of what they do. The implementation is simple:</p>
			<ol>
				<li value="1">The <strong class="source-inline">GetGridCellCenter</strong> method returns the position of the grid cell in world coordinates from the cell coordinates, as shown in the following code:<p class="source-code">    public Vector3 GetGridCellCenter(int col, int row)</p><p class="source-code">    {</p><p class="source-code">        Vector3 cellPosition = </p><p class="source-code">          GetGridCellPosition(col, row);</p><p class="source-code">        cellPosition.x += gridCellSize / 2.0f;</p><p class="source-code">        cellPosition.z += gridCellSize / 2.0f;</p><p class="source-code">        return cellPosition;</p><p class="source-code">    }</p><p class="source-code">    public Vector3 GetGridCellPosition(int col, int </p><p class="source-code">      row) {</p><p class="source-code">        float xPosInGrid = col * gridCellSize;</p><p class="source-code">        float zPosInGrid = row * gridCellSize;</p><p class="source-code">        return Origin + new Vector3(xPosInGrid, 0.0f,</p><p class="source-code">          zPosInGrid);</p><p class="source-code">    }</p></li>
				<li>The <strong class="source-inline">IsInBounds</strong> method<a id="_idIndexMarker350"/> checks whether a<a id="_idIndexMarker351"/> certain position in the game falls inside the grid:<p class="source-code">public bool IsInBounds(Vector3 pos) {</p><p class="source-code">    float width = numOfColumns * gridCellSize;</p><p class="source-code">    float height = numOfRows * gridCellSize;</p><p class="source-code">    return (pos.x &gt;= Origin.x &amp;&amp; pos.x &lt;= Origin.x +</p><p class="source-code">      width &amp;&amp; pos.x &lt;= Origin.z + height &amp;&amp; pos.z &gt;= </p><p class="source-code">      Origin.z);</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">IsTraversable</strong> method checks whether a grid coordinate is traversable (that is, it is not an obstacle):<p class="source-code">    public bool IsTraversable(int col, int row) {</p><p class="source-code">        return col &gt;= 0 &amp;&amp; row &gt;= 0 &amp;&amp; col &lt;</p><p class="source-code">          numOfColumns &amp;&amp; row &lt; numOfRows &amp;&amp; </p><p class="source-code">          !nodes[col, row].isObstacle;</p><p class="source-code">    }</p></li>
				<li>Another important method is <strong class="source-inline">GetNeighbours</strong>, which is used by the <strong class="source-inline">AStar</strong> class to retrieve the neighboring nodes of a particular node. This is done by obtaining the<a id="_idIndexMarker352"/> grid coordinate of the node and then<a id="_idIndexMarker353"/> checking whether the four neighbors' coordinates (up, down, left, and right) are traversable:<p class="source-code">public List&lt;Node&gt; GetNeighbours(Node node) {</p><p class="source-code">        List&lt;Node&gt; result = new();</p><p class="source-code">        var (column, row) =</p><p class="source-code">          GetGridCoordinates(node.position);</p><p class="source-code">        if (IsTraversable(column – 1, row)) {</p><p class="source-code">            result.Add(nodes[column – 1, row]);</p><p class="source-code">        }</p><p class="source-code">        if (IsTraversable(column + 1, row)) {</p><p class="source-code">            result.Add(nodes[column + 1, row]);</p><p class="source-code">        }</p><p class="source-code">        if (IsTraversable(column, row – 1)) {</p><p class="source-code">            result.Add(nodes[column, row – 1]);</p><p class="source-code">        }</p><p class="source-code">        if (IsTraversable(column, row + 1)) {</p><p class="source-code">            result.Add(nodes[column, row + 1]);</p><p class="source-code">        }</p><p class="source-code">        return result;</p><p class="source-code">}</p></li>
				<li>Finally, we have<a id="_idIndexMarker354"/> debug aid methods used to visualize the grid and <a id="_idIndexMarker355"/>obstacle blocks:<p class="source-code">    void OnDrawGizmos() {</p><p class="source-code">        if (showGrid) {</p><p class="source-code">            DebugDrawGrid(Color.blue);</p><p class="source-code">        }</p><p class="source-code">        //Grid Start Position</p><p class="source-code">        Gizmos.DrawSphere(Origin, 0.5f);</p><p class="source-code">        if (nodes == null) return;</p><p class="source-code">        //Draw Obstacle obstruction</p><p class="source-code">        if (showObstacleBlocks) {</p><p class="source-code">            Vector3 cellSize = new Vector3(</p><p class="source-code">              gridCellSize, 1.0f, gridCellSize);</p><p class="source-code">            Gizmos.color = Color.red;</p><p class="source-code">            for (int i = 0; i &lt; numOfColumns; i++) {</p><p class="source-code">                for (int j = 0; j &lt; numOfRows; j++) {</p><p class="source-code">                    if (nodes != null &amp;&amp; nodes[i, </p><p class="source-code">                        j].isObstacle) {</p><p class="source-code">                        Gizmos.DrawCube(</p><p class="source-code">                          GetGridCellCenter(i,j),</p><p class="source-code">                          cellSize);</p><p class="source-code">                    }</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    public void DebugDrawGrid(Color color) {</p><p class="source-code">        float width = (numOfColumns * gridCellSize);</p><p class="source-code">        float height = (numOfRows * gridCellSize);</p><p class="source-code">        // Draw the horizontal grid lines</p><p class="source-code">        for (int i = 0; i &lt; numOfRows + 1; i++) {</p><p class="source-code">            Vector3 startPos = Origin + i *</p><p class="source-code">              gridCellSize * new Vector3(0.0f, 0.0f,</p><p class="source-code">                                         1.0f);</p><p class="source-code">            Vector3 endPos = startPos + width * new</p><p class="source-code">              Vector3(1.0f, 0.0f, 0.0f);</p><p class="source-code">            Debug.DrawLine(startPos, endPos, color);</p><p class="source-code">        }</p><p class="source-code">        // Draw the vertial grid lines</p><p class="source-code">        for (int i = 0; i &lt; numOfColumns + 1; i++) {</p><p class="source-code">            Vector3 startPos = Origin + i *</p><p class="source-code">              gridCellSize * new Vector3(1.0f, 0.0f, </p><p class="source-code">                                         0.0f);</p><p class="source-code">            Vector3 endPos = startPos + height * new</p><p class="source-code">              Vector3(0.0f, 0.0f, 1.0f);</p><p class="source-code">            Debug.DrawLine(startPos, endPos, color);</p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>Gizmos can be used to draw visual debugging and setup aids inside the editor scene view. <strong class="source-inline">OnDrawGizmos</strong> is called every frame by the engine. So, if the debug flags, <strong class="source-inline">showGrid</strong> and <strong class="source-inline">showObstacleBlocks</strong>, are checked, we just draw the grid with lines and the obstacle cube objects with cubes. We won't go through the <strong class="source-inline">DebugDrawGrid</strong> method, as<a id="_idIndexMarker356"/> it's<a id="_idIndexMarker357"/> pretty simple.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">You can learn more about gizmos in the following Unity3D reference documentation: <a href="https://docs.unity3d.com/ScriptReference/Gizmos.html">https://docs.unity3d<span id="_idTextAnchor433"/><span id="_idTextAnchor434"/>.com/ScriptReference/Gizmos.html</a>.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor435"/>The AStar class</h2>
			<p>The <strong class="source-inline">AStar</strong> class<a id="_idIndexMarker358"/> implements<a id="_idIndexMarker359"/> the pathfinding algorithm using the classes we have implemented so far. If you want a quick review of the A* algorithm, see the <em class="italic">Revisiting the A* algorithm</em> section earlier in this chapter. The steps for the implementation of <strong class="source-inline">AStar</strong> are as follows:</p>
			<ol>
				<li value="1">We start by implementing a method called <strong class="source-inline">HeuristicEstimateCost</strong> to calculate the cost between the two nodes. The calculation is simple. We just find the direction vector between the two by subtracting one position vector from another. The magnitude of this resultant vector gives the straight-line distance from the current node to the target node:<p class="source-code">using UnityEngine;</p><p class="source-code">using System.Collections.Generic; </p><p class="source-code">public class AStar {</p><p class="source-code">    private float HeuristicEstimateCost(Node curNode,</p><p class="source-code">      Node goalNode) {</p><p class="source-code">        return (curNode.position –</p><p class="source-code">                goalNode.position).magnitude;</p><p class="source-code">    }</p><p class="callout-heading">Info</p><p class="callout">In theory, you can replace this function with any function, returning the distance between <strong class="source-inline">curNode</strong> and <strong class="source-inline">goalNode</strong>. However, for A* to return the shortest possible path, this function must be admissible. In short, an admissible heuristic function is a function that never overestimates the actual "real world" cost between <strong class="source-inline">curNode</strong> and <strong class="source-inline">goalNode</strong>. As an exercise, you can easily verify that the function we use in this demo is admissible. For more information on the math behind heuristic functions, you can visit <a href="https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html</a>.</p></li>
				<li>Then, we have the main A* algorithm in the <strong class="source-inline">FindPath</strong> method. In the following <a id="_idIndexMarker360"/>snippet, we initialize the open and closed lists. Starting <a id="_idIndexMarker361"/>with the start node, we put it in our open list. Then, we start processing our open list:<p class="source-code">    public List&lt;Node&gt; FindPath(Node start, Node goal) { </p><p class="source-code">        //Start Finding the path</p><p class="source-code">        NodePriorityQueue openList =</p><p class="source-code">          new NodePriorityQueue();</p><p class="source-code">        openList.Enqueue(start);</p><p class="source-code">        start.costSoFar = 0.0f;</p><p class="source-code">        start.fScore = HeuristicEstimateCost(start,</p><p class="source-code">                                             goal);</p><p class="source-code">        HashSet&lt;Node&gt; closedLi<a id="_idTextAnchor436"/><a id="_idTextAnchor437"/>st = new();</p><p class="source-code">        Node node = null;</p></li>
				<li>Then, we<a id="_idIndexMarker362"/> proceed with the main algorithm loop:<p class="source-code">        while (openList.Length != 0) {</p><p class="source-code">            node = openList.Dequeue();</p><p class="source-code">            if (node.position == goal.position) {</p><p class="source-code">                return CalculatePath(node);</p><p class="source-code">            }</p><p class="source-code">            var neighbours =</p><p class="source-code">              GridManager.instance.GetNeighbours(</p><p class="source-code">              node);</p><p class="source-code">            </p><p class="source-code">            foreach (Node neighbourNode in neighbours)</p><p class="source-code">            {</p><p class="source-code">                if (!closedList.Contains(</p><p class="source-code">                    neighbourNode)) {</p><p class="source-code">                    float totalCost = node.costSoFar +</p><p class="source-code">                      GridManager.instance.StepCost;</p><p class="source-code">                    float heuristicValue =</p><p class="source-code">                      HeuristicEstimateCost(</p><p class="source-code">                      neighbourNode, goal);</p><p class="source-code">                    //Assign neighbour node properties</p><p class="source-code">                    neighbourNode.costSoFar = </p><p class="source-code">                      totalCost;</p><p class="source-code">                    neighbourNode.parent = node;</p><p class="source-code">                    neighbourNode.fScore = </p><p class="source-code">                      totalCost + heuristicValue;</p><p class="source-code">                    //Add the neighbour node to the </p><p class="source-code">                    //queue</p><p class="source-code">                    if (!closedList.Contains(</p><p class="source-code">                        neighbourNode)) {</p><p class="source-code">                               openList.Enqueue(</p><p class="source-code">                                 neighbourNode);</p><p class="source-code">                    }</p><p class="source-code">                    </p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">            closedList.Add(node);</p><p class="source-code">        }</p><ol><li>The <a id="_idIndexMarker363"/>preceding <a id="_idIndexMarker364"/>code implementation strictly follows the algorithm that we have discussed previously, so you can refer back to it if something is not clear:</li><li>Get the first node from our <strong class="source-inline">openList</strong>. Remember, <strong class="source-inline">openList</strong> is always sorted in increasing order. Therefore, the first node is always the node with the lowest <em class="italic">F</em> value.</li><li>Check whether the current node is already at the target node. If so, exit the <strong class="source-inline">while</strong> loop and build the path array.</li><li>Create an array list to store the neighboring nodes of the current node being processed. Then, use the <strong class="source-inline">GetNeighbours</strong> method to retrieve the neighbors from the grid.</li><li>For every node in the array of neighbors, we check whether it's already in <strong class="source-inline">closedList</strong>. If not, we calculate the cost values, update the node properties with the new cost values and the parent node data, and put it in <strong class="source-inline">openList</strong>.</li><li>Push the current node to <strong class="source-inline">closedList</strong> and remove it from <strong class="source-inline">openList</strong>. </li><li>Go back to <em class="italic">step I</em>.</li></ol></li>
				<li>If there <a id="_idIndexMarker365"/>are no<a id="_idIndexMarker366"/> more nodes in <strong class="source-inline">openList</strong>, the current node should be at the target node if there's a valid path available:<p class="source-code">        //If finished looping and cannot find the goal</p><p class="source-code">        //then return null</p><p class="source-code">        if (node.position != goal.position) {</p><p class="source-code">            Debug.LogError("Goal Not Found");</p><p class="source-code">            return null;</p><p class="source-code">        }</p><p class="source-code">        //Calculate the path based on the final node</p><p class="source-code">        return CalculatePath(node);</p></li>
				<li>Finally, we call the <strong class="source-inline">CalculatePath</strong> method with the current node parameter:<p class="source-code">    private List&lt;Node&gt; CalculatePath(Node node) { </p><p class="source-code">        List&lt;Node&gt; list = new();</p><p class="source-code">        while (node != null) {</p><p class="source-code">            list.Add(node);</p><p class="source-code">            node = node.parent;</p><p class="source-code">        }</p><p class="source-code">        list.Reverse();</p><p class="source-code">        return list;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">CalculatePath</strong> method traces through each node's parent <strong class="source-inline">node</strong> object and builds an array list. Since we want a path array from the start node to the tar<a id="_idTextAnchor438"/>get<a id="_idIndexMarker367"/> node, we <a id="_idIndexMarker368"/>just call the <strong class="source-inline">Reverse</strong> method.</li>
			</ol>
			<p>Now, we'll write a test <a id="_idTextAnchor439"/>script to test this and set up a demo scene.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor440"/>The TestCode class</h2>
			<p>The <strong class="source-inline">TestCode</strong> class<a id="_idIndexMarker369"/> uses <a id="_idIndexMarker370"/>the <strong class="source-inline">AStar</strong> class to find the path from the start node to the target node, as shown in the following code from the <strong class="source-inline">TestCode.cs</strong> file:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">public class TestCode : MonoBehaviour {</p>
			<p class="source-code">    private Transform startPos, endPos;</p>
			<p class="source-code">    public Node startNode { get; set; }</p>
			<p class="source-code">    public Node goalNode { get; set; }</p>
			<p class="source-code">    public List&lt;Node&gt; pathArray;</p>
			<p class="source-code">    GameObject objStartCube, objEndCube;</p>
			<p class="source-code">    private float elapsedTime = 0.0f;</p>
			<p class="source-code">    //Interval time between pathfinding </p>
			<p class="source-code">    public float intervalTime = 1.0f;</p>
			<p>In the preceding snippet, we first set up the variables that we need to reference. The <strong class="source-inline">pathArray</strong> variable stores the nodes array that's returned from the <strong class="source-inline">AStar</strong> <strong class="source-inline">FindPath</strong> method.</p>
			<p>In the following code block, we use the <strong class="source-inline">Start</strong> method to look for objects with the tags <strong class="source-inline">Start</strong> and <strong class="source-inline">End</strong> and initialize <strong class="source-inline">pathArray</strong>. We are trying to find a new path at every interval, specified by the <strong class="source-inline">intervalTime</strong> property, in case the positions of the start and end <a id="_idIndexMarker371"/>nodes <a id="_idIndexMarker372"/>have changed. Finally, we call the <strong class="source-inline">FindPath</strong> method:</p>
			<p class="source-code">    void Start () {</p>
			<p class="source-code">        objStartCube = </p>
			<p class="source-code">          GameObject.FindGameObjectWithTag("Start"); </p>
			<p class="source-code">        objEndCube =</p>
			<p class="source-code">          GameObject.FindGameObjectWithTag("End");</p>
			<p class="source-code">        pathArray = new List&lt;Node&gt;();</p>
			<p class="source-code">        FindPath();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Update () {</p>
			<p class="source-code">        elapsedTime += Time.deltaTime;</p>
			<p class="source-code">        if (elapsedTime &gt;= intervalTime) {</p>
			<p class="source-code">            elapsedTime = 0.0f;</p>
			<p class="source-code">            FindPath();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>Since we implemented our pathfinding algorithm in the <strong class="source-inline">AStar</strong> class, finding a path is much simpler. In the following snippet, we first take the positions of the start and end game objects. Then, we create new <strong class="source-inline">Node</strong> objects using the <strong class="source-inline">GetGridIndex</strong> helper methods in <strong class="source-inline">GridManager</strong> to calculate their respective row and column index positions inside the grid.</p>
			<p>After that, we call the <strong class="source-inline">AStar.FindPath</strong> method with the start node and target node, storing the <a id="_idIndexMarker373"/>returned<a id="_idIndexMarker374"/> array list in the local <strong class="source-inline">pathArray</strong> property. Finally, we implement the <strong class="source-inline">OnDrawGizmos</strong> method to draw and visualize the resulting path:</p>
			<p class="source-code">void FindPath() {</p>
			<p class="source-code">        startPos = objStartCube.transform;</p>
			<p class="source-code">        endPos = objEndCube.transform;</p>
			<p class="source-code">        //Assign StartNode and Goal Node</p>
			<p class="source-code">        var (startColumn, startRow) = </p>
			<p class="source-code">          GridManager.instance.GetGridCoordinates(</p>
			<p class="source-code">          startPos.position);</p>
			<p class="source-code">        var (goalColumn, goalRow) = </p>
			<p class="source-code">          GridManager.instance.GetGridCoordinates(</p>
			<p class="source-code">          endPos.position);</p>
			<p class="source-code">        startNode = new Node(</p>
			<p class="source-code">          GridManager.instance.GetGridCellCenter(</p>
			<p class="source-code">          startColumn, startRow));</p>
			<p class="source-code">        goalNode = new Node(</p>
			<p class="source-code">          GridManager.instance.GetGridCellCenter(</p>
			<p class="source-code">          goalColumn, goalRow));</p>
			<p class="source-code">        pathArray = </p>
			<p class="source-code">          new AStar().FindPath(startNode, goalNode);</p>
			<p class="source-code">}</p>
			<p>We look through our <strong class="source-inline">pathArray</strong> and use the <strong class="source-inline">Debug.DrawLine</strong> method to draw the lines, connecting <a id="_idIndexMarker375"/>the <a id="_idIndexMarker376"/>nodes in <strong class="source-inline">pathArray</strong>:</p>
			<p class="source-code">    void OnDrawGizmos() {</p>
			<p class="source-code">        if (pathArray == null)</p>
			<p class="source-code">            return;</p>
			<p class="source-code">        if (pathArray.Count &gt; 0) {</p>
			<p class="source-code">            int index = 1;</p>
			<p class="source-code">            foreach (Node node in pathArray) {</p>
			<p class="source-code">                if (index &lt; pathArray.Count) {</p>
			<p class="source-code">                    Node nextNode = pathArray[index];</p>
			<p class="source-code">                    Debug.DrawLine(node.position,</p>
			<p class="source-code">                      nextNode.position, Color.green);</p>
			<p class="source-code">                    index++;</p>
			<p class="source-code">                }</p>
			<p class="source-code">            };</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When we<a id="_idIndexMarker377"/> run and test our program, we should see<a id="_idTextAnchor441"/><a id="_idTextAnchor442"/> a green line<a id="_idIndexMarker378"/> connecting the nodes from start to end.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor443"/>Setting up the scene</h1>
			<p>We are going<a id="_idIndexMarker379"/> to set up a scene that looks like the following screenshot:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B17984_07_1.jpg" alt="Figure 7.1 – Our sample test scene with obstacles&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Our sample test scene with obstacles</p>
			<p>Let's follow a step-by-step procedure to do this:</p>
			<ol>
				<li value="1">We create a directional light, the start and end game object, a few obstacle objects, a plane entity to be used as ground, and two empty game objects in which we put the <strong class="source-inline">GridManager</strong> and <strong class="source-inline">TestAStar</strong> scripts. After this step, our scene hierarchy should be like this:</li>
			</ol>
			<p class="figure-caption"><img src="image/B17984_07_2.png" alt="Figure 7.2 – The demo scene hierarchy&#13;&#10;"/></p>
			<p class="figure-caption">Figure 7.2 – The demo scene hierarchy</p>
			<ol>
				<li value="2">We create a<a id="_idIndexMarker380"/> bunch of cube entities and add them to the <strong class="bold">Obstacles</strong> layer. <strong class="source-inline">GridManager</strong> looks for objects with this tag when it creates the grid world representation:</li>
			</ol>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B17984_07_3.jpg" alt="Figure 7.3 – The Obstacle nodes seen in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – The Obstacle nodes seen in the Inspector</p>
			<ol>
				<li value="3">We then <a id="_idIndexMarker381"/>create a cube entity and tag it as <strong class="bold">Start</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B17984_07_4.jpg" alt="Figure 7.4 – The Start node seen in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – The Start node seen in the Inspector</p>
			<ol>
				<li value="4">Then, we <a id="_idIndexMarker382"/>create another cube entity and tag it as <strong class="bold">End</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B17984_07_5.jpg" alt="Figure 7.5 – The End node seen in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – The End node seen in the Inspector</p>
			<ol>
				<li value="5">We create an empty game object, and we attach the <strong class="source-inline">GridManager</strong> script to it. We also set the name to <strong class="source-inline">GridManager</strong> because we use this name to look for the <strong class="source-inline">GridManager</strong> object from inside the other scripts.</li>
				<li>Then, we set <a id="_idIndexMarker383"/>up the number of rows and columns of the grid and the size of each tile.</li>
			</ol>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B17984_07_6.jpg" alt="Figure 7.6 – GridManager script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – GridManager script</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor444"/>Testing the pathfinder</h2>
			<p>Once we <a id="_idIndexMarker384"/>hit <a id="_idIndexMarker385"/>the <strong class="bold">Play</strong> button, we should see the A* pathfinding algorithm in action. By default, once you play the scene, Unity3D switches to the <strong class="bold">Game</strong> view. However, since our pathfinding visualization code draws in the debug editor view, to see the found path, you need to switch back to the <strong class="bold">Scene</strong> view or enable <strong class="bold">Gizmos</strong> visualization:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B17984_07_7.jpg" alt="Figure 7.7 – The ﬁrst path found by the algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – The ﬁrst path found by the algorithm</p>
			<p>Now, try to <a id="_idIndexMarker386"/>move <a id="_idIndexMarker387"/>the start or end node around in the scene using the editor's movement gizmo (not in the <strong class="bold">Game</strong> view, but the <strong class="bold">Scene</strong> view):</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B17984_07_8.jpg" alt="Figure 7.8 – A second path found by the algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – A second path found by the algorithm</p>
			<p>You should <a id="_idIndexMarker388"/>see<a id="_idIndexMarker389"/> that the path is updated dynamically in real time. On the other hand, if there is no available path<a id="_idTextAnchor445"/>, you get an error message in the console window instead.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor446"/>Summary</h1>
			<p>In this chapter, we learned how to implement the A* pathfinding algorithm in Unity3D. First, we implemented our own A* pathfinding class, grid representation class, priority queue class, and node class. Finally, we used debug draw functionalities to visualize the grid and path information.</p>
			<p>In later chapters, we will see that thanks to Unity3D's <strong class="bold">NavMesh</strong> and <strong class="bold">NavAgent</strong> features, it may not be necessary for you to implement a custom pathfinding algorithm on your own.</p>
			<p>Nonetheless, understanding a basic pathfinding algorithm gives you a better foundation for getting to grips with many other advanced pathfinding techniques.</p>
			<p>In the next chapter, we will extend the idea behind the A* algorithm to a more complex world representation: navigation meshes.</p>
		</div>
	</body></html>