- en: '*Chapter 8*: Programming Distance Sensors with Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we look at distance sensors and how to use them to avoid objects.
    Avoiding obstacles is a key feature in mobile robots, as bumping into stuff is
    generally not good. It is also a behavior that starts to make a robot appear smart,
    as if it is behaving intelligently.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we find out about the different types of sensors and choose
    a suitable type. We then build a layer in our robot object to access them and,
    in addition to this, we create a behavior to avoid walls and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between optical and ultrasonic sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching and reading an ultrasonic sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding walls – writing a script to avoid obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the hands-on experiments in this chapter, you will require the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi robot and the code from the previous chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two HC-SR04P, RCWL-1601, or Adafruit 4007 ultrasonic sensors. They must have
    a 3.3 V output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22 AWG single-core wire or a pre-cut breadboard jumper wire kit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard-friendly **single pole, double toggle (SPDT**) slide switch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-female jumpers, preferably of the joined-up jumper jerky type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two brackets for the sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crosshead screwdriver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miniature spanners or small pliers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2KfCkZM](https://bit.ly/2KfCkZM)'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between optical and ultrasonic sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to use distance sensors, let's find out what these sensors actually
    are, how they work, and some of the different types available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common ways in which to sense distance are to use ultrasound or light.
    The principle of both of these mechanisms is to fire off a pulse and then sense
    its reflected return, using either its timing or angle to measure a distance,
    as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Using pulse timing in a distance sensor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Using pulse timing in a distance sensor
  prefs: []
  type: TYPE_NORMAL
- en: We focus on the sensors that measure the response time, otherwise known as the
    **time of flight**. *Figure 8.1* shows how these sensors use reflection time.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how sensors work, we'll now take a closer look
    at optical sensors and ultrasonic sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Optical sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Light-based sensors, like the one in *Figure 8.2*, use infrared laser light
    that we cannot see. These devices can be tiny; however, they can suffer in strong
    sunlight and fluorescent light, making them misbehave. Some objects reflect light
    poorly or are transparent and are undetectable by these sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – A VL530LOx on a carrier board'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – A VL530LOx on a carrier board
  prefs: []
  type: TYPE_NORMAL
- en: In competitions where infrared beams detect course times, the beams and these
    sensors can interfere with each other. However, unlike ultrasonic sensors, these
    are unlikely to cause false detections when placed on different sides of a robot.
    Optical distance sensors can have higher accuracy, but over a more limited range.
    They can be expensive, although there are cheaper fixed range types of light sensors
    out there.
  prefs: []
  type: TYPE_NORMAL
- en: Ultrasonic sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many sound-based distance measuring devices use ultrasonic sound with frequencies
    beyond human hearing limits, although they can annoy some animals, including dogs.
    Mobile phone microphones and some cameras pick up their pulses as clicks. Ultrasonic
    devices tend to be larger than optical ones, but cheaper since sound travels slower
    than light and is easier to measure. Soft objects that do not reflect sound, such
    as fabrics, can be harder for these to detect.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.3* shows the HC-SR04, a common and inexpensive sound-based distance
    sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The HC-SR04'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The HC-SR04
  prefs: []
  type: TYPE_NORMAL
- en: They have a range of up to 4 meters from a minimum of about 2 cm.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ultrasonic-based devices, including the common HC-SR04,
    but not all of them are suitable. We'll look at logic levels as this is an important
    factor in choosing which sensor to buy.
  prefs: []
  type: TYPE_NORMAL
- en: Logic levels and shifting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I/O pins on the Raspberry Pi are only suitable for inputs of 3.3 V. Many
    devices in the market have a 5 V logic, either for their inputs when controlling
    them, or from their outputs. Let's dig into what I mean by logic levels, and why
    it is sensible to try and stick to the native voltage level when possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Voltage** is a measure of how much pushing energy there is on an electrical
    flow. Different electronics are built to tolerate or to respond to different voltage
    levels. Putting too high a voltage through a device can damage it. On the other
    hand, putting too low a voltage can cause your sensors or outputs to simply not
    respond or behave strangely. We are dealing with logic devices that output a high
    or low voltage to represent a true/false value. These voltages must be above a
    threshold to be true, and below it to be false. We must be aware of these electrical
    properties, or we will destroy things and fail to get them to communicate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph in *Figure 8.4* shows the effects that different levels have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Voltages and logic levels'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Voltages and logic levels
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.4*, we show a graph. On the *y*-axis (left), it shows voltage labels
    from 0 to 5 V. The *y*-axis shows different operating conditions. There are 4
    dashed lines running through the graph. The lowest dashed line is at 0.8 V; below
    this, an input will consider it as logic 0\. The next line, at around 2.3 V, is
    where many 3.3 V devices consider things at logic 1\. The line at 3.3 V shows
    the expected input and output level for logic 1 on a Raspberry Pi. Above this
    line, damage may occur to a Raspberry Pi. At around 4.2 V is what some 5 V devices
    expect for logic 1 (although some will allow as low as 2 V for this) – the Raspberry
    Pi needs help to talk to those.
  prefs: []
  type: TYPE_NORMAL
- en: Along the graph are 5 bars. The first labeled bar is at 0 – meaning a clear
    logic 0 to all devices. The next bar is a clear logic 1 for the Raspberry Pi at
    3.3 V, but it is also below 4.2 V, so some 5 V devices won't recognize this. The
    bar labelled unclear is at 1.8 V – in this region, between the low and the high
    thresholds, the logic might not be clear, and this should be avoided. The bar
    labeled **Vague logic 1** is above the threshold, but only just, and could be
    misinterpreted or cause odd results on 3.3 V devices. The last bar is at 5 V,
    which 5 V devices output. This must not go to the Raspberry Pi without a level
    shifter or it will destroy that Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: There are bars in *Figure 8.4* at 1.7 V and 2.3 V. These voltages are very close
    to the logic threshold and can result in random data coming from the input. Avoid
    intermediate voltages between the required logic levels. 3 V is OK, but avoid
    1.5 V as this is ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Putting more than 3.3 V into a Raspberry Pi pin damages the Raspberry Pi. Do
    not use 5 V devices without logic level shifters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use devices that are 5 V, you require extra electronics to interface
    them. The electronics come with further wiring and parts, thereby increasing the
    cost, complexity, or size of the robot''s electronics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Wiring the HC-SR04 sensors into the level shifters
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.5* shows a wiring diagram for a robot that uses HC-SR04 5v sensors
    that require logic level shifting. This circuit diagram shows the Raspberry Pi
    GPIO pins at the top. Coming from 3 pins to the left are the 5 V, 3.3 V (written
    as 3v3), and ground (GND) lines. Below the GPIO pins are the 3.3 V and 5 V lines.'
  prefs: []
  type: TYPE_NORMAL
- en: Below the power lines (or rails) are two level shifters. Going into the right
    of the level shifters are connections from the Raspberry Pi GPIO pins 5, 6, 17,
    and 27\. In this style of diagram, a black dot shows a connection, and lines that
    do not connect are shown with a bridge.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of the diagram has a ground line from the ground pin. This is shown
    as it's normal that additional electronics will require access to a ground line.
  prefs: []
  type: TYPE_NORMAL
- en: The left of the diagram has the two distance sensors, with connections to 5
    V and GND. Each sensor has the **trig** and **echo** pins wired to the level shifters.
    It's not hard to see how adding more sensors that also require level shifters
    to this would further increase complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, other options are now available. Where it is possible to use a 3.3
    V native device or a device that uses its supply voltage for logic high, it is
    worth choosing these devices. When buying electronics for a robot, consider carefully
    what voltage the robot's main controller uses (like the Raspberry Pi), and check
    that the electronics work with the controller's voltages.
  prefs: []
  type: TYPE_NORMAL
- en: The HC-SR04 has several replacement parts that have this ability. The HC-SR04P,
    the RCWL-1601, and Adafruit 4007 models output 3.3 V and can connect directly
    to the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Why use two sensors?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having two sensors allows a behavior to detect which side is closer. With this,
    the robot can detect where open spaces are and move toward them. *Figure 8.6*
    shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Using two sensors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Using two sensors
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.6*, the second robot can make more interesting decisions because
    it has more data from the world with which to make those decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Considering all of these options, I recommend you use a 3.3 V variant like the
    HC-SR04P/RCWL-1601 or Adafruit 4007 because they are cheap and because it is easy
    to add two or more of these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen some distance sensor types and discussed the trade-offs and choices
    for this robot. You've learned about voltage levels, and why this is a crucial
    consideration for robot electronics. We've also looked at how many sensors we
    could use and where we could put them. Now let's look at how to add them.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching and reading an ultrasonic sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we should wire in and secure these sensors to the robot. We then write
    some simple test code that we can use to base our behavior code on in the next
    section. After completing this section, the robot block diagram should look like
    *Figure 8.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Robot block diagram with ultrasonic sensors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Robot block diagram with ultrasonic sensors
  prefs: []
  type: TYPE_NORMAL
- en: This diagram builds on the block diagram in *Figure 6.33* from [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096)*,
    Building Robot Basics – Wheels, Power, and Wiring* by adding left and right ultrasonic
    sensors. Both have bi-directional arrows to the Raspberry Pi, since, being an
    active sensor, the Raspberry Pi triggers a sensor measurement and then reads back
    the result. Let's attach the sensors to the robot chassis.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the sensors to the robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Technical requirements* section, I added an HC-SR04 bracket. Although
    it is possible to make a custom bracket with CAD and other part making skills,
    it is more sensible to use one of the stock designs. *Figure 8.8* shows the bracket
    I''m using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Ultrasonic HC-SR04 sensor brackets with the screws and hardware'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Ultrasonic HC-SR04 sensor brackets with the screws and hardware
  prefs: []
  type: TYPE_NORMAL
- en: 'These are easy to attach to your robot, assuming that your chassis is similar
    enough to mine, in that it has mounting holes or a slot to attach this bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Steps for mounting the sensor bracket'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Steps for mounting the sensor bracket
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount the sensor bracket, use *Figure 8.9* as a guide for the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Push the two bolts into the holes on the bracket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the bracket screws through the holes at the front of the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread a nut from underneath the robot on each and tighten. Repeat this for
    the other side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot should look like this with the two brackets mounted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 8.10* shows how to push the sensors into the brackets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Pushing the sensors into the brackets'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15660_08_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.10 – Pushing the sensors into the brackets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Look at the sensor. The two transducer elements, the round cans with a gauze
    on top, will fit well in the holes in the brackets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The distance sensors can simply be pushed into the brackets, since they have
    a friction fit. The electrical connector for the sensor should be facing upward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After putting in both sensors, the robot should look like panel 7 of *Figure
    8.10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've now attached the sensors to the chassis. Before we wire them, we'll take
    a slight detour and add a helpful power switch.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a power switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we turn on the robot again, let''s add a switch for the motor power.
    This switch is more convenient than screwing the ground wire from the battery
    into the terminal repeatedly. We''ll see how to do this in three simple steps.
    Follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have the following equipment ready, as shown in *Figure 8.11*:
    a breadboard, some velcro, a mini breadboard-friendly SPDT switch, and one length
    of single-core 22 AWG wire:![Figure 8.11 – Items needed to add a power switch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15660_08_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.11 – Items needed to add a power switch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now use two strips of Velcro to stick the breadboard on top of the robot''s
    battery, as shown in *Figure 8.12*. The velcro holds firm but is easy to remove
    if you need to disassemble the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Adding velcro strips'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Adding velcro strips
  prefs: []
  type: TYPE_NORMAL
- en: With the breadboard in place, we can now add a switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at *Figure 8.13* for details on how the switch is connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Wiring the switch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Wiring the switch
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.13* shows a circuit diagram, a close-up of a breadboard, and a suggested
    way to wire the physical connections on the robot. Let''s look at this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a circuit diagram showing the batteries, switch, and motor power input
    connectors. At the top is the *motor power in* terminal. From the positive (+)
    side of that terminal, a wire goes down the left to the batteries, shown as alternating
    thick and thin bars. From the batteries, the bottom terminal is their negative
    side. A wire goes from this around to the switch on the right of the diagram.
    The top of the switch is then connected via a wire to the negative (-) side of
    the *motor power in terminal*. This is the important diagram for making the connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we physically wire the switch, it's worth talking about the rows of the
    breadboard. This panel shows a close-up of a breadboard, with 2 of the rows highlighted
    in green lines. The green lines show that the rows are connected in groups of
    5\. The arrangement of a breadboard has two wired groups of 5 holes (tie-points)
    for each of the rows (numbered 1 to 30). It has a groove in the middle separating
    the groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The physical wiring uses the breadboard to make connections from wires to devices.
    It won't match the diagram precisely. The left shows the motor board, with a red
    wire from the batteries, their positive side, going into the positive (+ or VIN)
    terminal on the *motor power in terminal*. The batteries are in the middle. A
    black wire goes from the batteries into the breadboard in row 3, column *d*. In
    column *e*, a switch is plugged into the breadboard going across rows 1, 2, and
    3\. An orange precut 22 AWG wire goes from row 2 to the GND terminal, where it
    is screwed in. Sliding this switch turns on the power to the robot motors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now given our robot a power switch for its motor batteries, so we can
    turn the motor power on without needing a screwdriver. Next, we will use the same
    breadboard to wire up the distance sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the distance sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each ultrasonic sensor has four connections:'
  prefs: []
  type: TYPE_NORMAL
- en: A trigger pin to ask for a reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An echo pin to sense the return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A VCC/voltage pin that should be 3.3 V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GND or ground pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the whole robot is switched off before proceeding any further. The
    trigger and echo pins need to go to GPIO pins on the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.14* shows a close-up of the Raspberry Pi GPIO port to assist in making
    connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Raspberry Pi connections'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Raspberry Pi connections
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.14* is a diagram view of the GPIO connector on the Raspberry Pi.
    This connector is the 40 pins set in two rows at the top of the Pi. Many robots
    and gadgets use them. The pin numbers/names are not printed on the Raspberry Pi,
    but this diagram should assist in finding them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a breadboard for this wiring. *Figure 8.15* shows the connections needed
    for these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Sensor wiring diagram
  prefs: []
  type: TYPE_NORMAL
- en: Wires from the Raspberry Pi to the breadboard, and from the sensor to the breadboard,
    need male-to-female jumper wires. Wires on the breadboard (there are only 4 of
    these) use short pre-cut wires. *Figure 8.15* shows a circuit diagram above, and
    a breadboard wiring suggestion below.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wire the sensors, use *Figure 8.15* as a guide, along with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the power connections. A wire goes from the 3.3 V (often written
    as 3v3 on diagrams) pin on the Raspberry Pi to the top, red-marked rail on the
    breadboard. We can use this red *rail* for other connections needing 3.3 V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wire from one of the GND pins on the Pi goes to the black- or blue-marked
    rail on the breadboard. We can use this blue *rail* for connections requiring
    GND.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull off a strip of 4 from the male-to-female jumper wires for each side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the left-hand sensor, identify the four pins—VCC, trig, echo, and GND. For
    the connection from this to the breadboard, it's useful to keep the 4 wires together.
    Take 4 male-to-female connectors (in a joined strip if possible), from this sensor,
    and plug them into the board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the breadboard, use the precut wires to make a connection from ground to
    the blue rail, and from VCC to the red rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now use some jumper wires to make the signal connections from the trig/echo
    pins to the Raspberry Pi GPIO pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on where you've placed your breadboard, the distance sensor wires
    may not reach. If this is the case, join two male-to-female wires back to back,
    and use some electrical tape to bind them together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For neatness, I like to wrap wires in spiral wrap; this is entirely optional
    but can reduce the clutter on the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Please double-check your connections before you continue. You have now installed
    the distance sensors into your robot's hardware, but in order to test and use
    them, we need to prepare the software components.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python libraries to communicate with the sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with the GPIO sensor, and some other hardware, you need a Python library.
    Let''s use the `GPIOZero` library, designed to help interface with hardware like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the library now installed, we can write our test code.
  prefs: []
  type: TYPE_NORMAL
- en: Reading an ultrasonic distance sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write code for distance sensors, it helps to understand how they work. As
    suggested previously, this system works by bouncing sound pulses off of objects
    and measuring the pulse return times.
  prefs: []
  type: TYPE_NORMAL
- en: The code on the Raspberry Pi sends an electronic pulse to the **trigger** pin
    to ask for a reading. In response to this pulse, the device makes a sound pulse
    and times its return. The **echo** pin responds using a pulse too. The length
    of this pulse corresponds to the sound travel time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph in *Figure 8.16* shows the timing of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Timing of a pulse and the response for an ultrasonic distance
    sensor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Timing of a pulse and the response for an ultrasonic distance
    sensor
  prefs: []
  type: TYPE_NORMAL
- en: The `GPIOZero` library can time this pulse, and convert it into a distance,
    which we can use in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The device might fail to get a return response in time if the sound didn't echo
    back soon enough. Perhaps the object was outside the sensor's range, or something
    dampened the sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with our servo motor control class previously, we should use comments
    and descriptive names to help us explain this part of the code. I''ve called this
    file `test_distance_sensors.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by importing `time` and the `DistanceSensor` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set up the sensors. I''ve used `print` statements to show what is
    going on. In these lines, we create library objects for each distance sensor,
    registering the pins we have connected them on. Try to make sure these match your
    wiring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This test then runs in a loop until we cancel it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then print the distance from our sensors. `.distance` is a property, as
    we saw with the `.count` property on our LED system earlier in the book. The sensors
    are continuously updating it. We multiply it by 100 since `GPIOZero` distance
    is in terms of a meter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A little sleep in the loop stops it flooding the output too much and prevents
    tight looping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can turn on your Raspberry Pi and upload this code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put an object anywhere between 4 centimeters and 1 meter away from the sensor,
    as demonstrated in the following image:![](img/B15660_08_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 8.17 – Distance sensor with object
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 8.17* shows an item roughly 10.5 cm from a sensor. The object is a
    small toolbox. Importantly it is rigid and not fabric.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the code on the Pi with `python3 test_distance_sensors.py`. As you move
    around the object, your Pi should start outputting distances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because it is in a loop, you need to press *Ctrl* + *C* to stop the program
    running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see here that there are many decimal places, which isn''t too helpful
    here. First, the devices are unlikely to be that accurate, and second, our robot
    does not need sub-centimeter accuracy to make decisions. We can modify the print
    statement in the loop to be more helpful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the code with this change gives the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You've demonstrated that the distance sensor is working. Added to this is exploring
    how you can tune the output from a sensor for debugging, something you'll do a
    lot more when making robots. To make sure you're on track, let's troubleshoot
    anything that has gone wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this sensor isn''t working as expected, try the following troubleshooting
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Is anything hot in the wiring? Hold the wires to the sensor between the thumb
    and forefinger. *Nothing should be hot or even warming*! If so, remove the batteries,
    turn off the Raspberry Pi, and thoroughly check all wiring against *Figure 8.12*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are syntax errors, please check the code against the examples. You
    should have installed Python libraries with `pip3` and be running with `python3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are still getting errors, or invalid values, please check the code and
    indentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the values are always `0`, or the sensor isn't returning any values, then
    you may have swapped trigger and echo pins. Try swapping the trigger/echo pin
    numbers in the code and testing it again. *Don't* swap the cables on a live Pi!
    Do this one device at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are still getting no values, ensure you have purchased 3.3 V-compatible
    systems. The HC-SR04 model will not work with the bare Raspberry Pi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If values are way out or drifting, then ensure that the surface you are testing
    on is hard. Soft surfaces, such as clothes, curtains, or your hand, do not respond
    as well as glass, wood, metal, or plastic. A wall works well!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another reason for incorrect values is the surface may be too small. Make sure
    that your surface is quite wide. Anything smaller than about 5 cm square may be
    harder to measure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a last resort, if one sensor seems fine, and the other wrong, it's possible
    that a device is faulty. Try swapping the sensors to check this. If the result
    is different, then a sensor may be wrong. If the result is the same, it is the
    wiring or code that is wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have now troubleshooted your distance sensor and made sure that it works.
    You have seen it output values to show that it is working and tested it with objects
    to see its response. Now, let's step up and write a script to avoid obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding walls – writing a script to avoid obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have tested both sensors, we can integrate them with our robot class
    and make obstacle avoidance behavior for them. This behavior loop reads the sensors
    and then chooses behavior accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the sensors to the robot class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, before we can use the sensors in a behavior, we need to add them to the
    `Robot` class, assigning the correct pin numbers for each side. This way, if pin
    numbers change or even the interface to a sensor changes, behaviors will not need
    to change:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `DistanceSensor` object, we need to import it from `gpiozero`; the
    new code is in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create an instance of one of these `DistanceSensor` objects for each side
    in the robot class. We need to set these up in the constructor for our robot.
    We use the same pin numbers and queue length as in our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding this to our robot layer makes it available to behaviors. When we create
    our robot, the sensors will be sampling distances. Let's make a behavior that
    uses them.
  prefs: []
  type: TYPE_NORMAL
- en: Making the obstacle avoid behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter is all about getting a behavior; how can a robot drive and avoid
    (most) obstacles? The sensor''s specifications limit it, with smaller objects
    or objects with a soft/fuzzy shell, such as upholstered items, not being detected.
    Let''s start by drawing what we mean in *Figure 8.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Obstacle avoidance basics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Obstacle avoidance basics
  prefs: []
  type: TYPE_NORMAL
- en: In our example (*Figure 8.18*), a basic robot detects a wall, turns away, keeps
    driving until another wall is detected, and then turns away from that. We can
    use this to make our first attempt at wall-avoiding behavior.
  prefs: []
  type: TYPE_NORMAL
- en: First attempt at obstacle avoidance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help us understand this task, the following diagram shows a flow diagram
    for the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Obstacle avoidance flowchart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Obstacle avoidance flowchart
  prefs: []
  type: TYPE_NORMAL
- en: The flow diagram in *Figure 8.19* starts at the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram describes a loop that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Start** box goes into a **Get Distances** box, which gets the distances
    from each sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We test whether the left sensor reads less than 20 cm (a reasonable threshold):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) If so, we set the left motor in reverse to turn the robot away from the obstacle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) Otherwise, we drive the left motor forward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now check the right sensor, setting it backward if closer than 20 cm, or
    forward if not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program waits a short time and loops around again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We put this loop in a `run` method. There›s a small bit of setup required in
    relation to this. We need to set the pan and tilt to `0` so that it won''t obstruct
    the sensors. I''ve put this code in `simple_avoid_behavior.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the robot, and `sleep` for timing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following class is the basis of our behavior. There is a robot object stored
    in the behavior. A speed is set, which can be adjusted to make the robot go faster
    or slower. Too fast, and it has less time to react:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now the following method chooses a speed for each motor, depending on the distance
    detected by the sensor. A nearer sensor distance turns away from the obstacle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run` method is the core, since it has the main loop. We put the pan and
    tilt mechanism in the middle so that it doesn''t obstruct the sensors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we start the main loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then print out our readings on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use the distances with our `get_motor_speed` method and send this to
    each motor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this is our main loop, we wait a short while before we loop again. Under
    this is the setup and starting behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code for this behavior is now completed and ready to run. It's time to try
    it out. To test this, set up a test space to be a few square meters wide. Avoid
    obstacles that the sensor misses, such as upholstered furniture or thin obstacles
    such as chair legs. I've used folders and plastic toy boxes to make courses for
    these.
  prefs: []
  type: TYPE_NORMAL
- en: Send the code to the robot and try it out. It drives until it encounters an
    obstacle, and then turns away. This kind of works; you can tweak the speeds and
    thresholds, but the behavior gets stuck in corners and gets confused.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps it's time to consider a better strategy.
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated object avoidance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous behavior can leave the robot stuck. It appears to be indecisive
    with some obstacles and occasionally ends up ramming others. It may not stop in
    time or turn into things. Let's make a better one that drives more smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is our strategy? Well, let''s think in terms of the sensor nearest
    to an obstacle, and the furthest. We can work out the speeds of the motor nearest
    to it, the motor further from it, and a time delay. Our code uses the time delay
    to be decisive about turning away from a wall, with the time factor controlling
    how far we turn. This reduces any jitter. Let''s make some changes to the last
    behavior for this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, copy the `simple_avoid_behavior.py` file into a new file called `avoid_behavior.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We won''t be needing `get_motor_speed`, so remove that. We replace it with
    a function called `get_speeds`. This takes one parameter, `nearest_distance`,
    which should always be the distance sensor with the lower reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These numbers are all for fine-tuning. The essential factor is that depending
    on the distance, we slow down the motor further from the obstacle, and if we get
    too close, it drives away. Based on the time delay, and knowing which motor is
    which, we can drive our robot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Most of the remaining code stays the same. This is the `run` function you''ve
    already seen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It now uses the `get_speeds` method to determine a nearest and furthest distance.
    Notice that we take the `min`, or minimum, of the two distances. We get back the
    speeds for both motors and a delay, and then print out the variables so we can
    see what''s going on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we check which side is nearer, left or right, and set up the correct motors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of sleeping a fixed amount of time, we sleep for the amount of time
    in the `delay` variable. The delay is in milliseconds, so we need to multiply
    it to get seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The rest of the code remains the same. You can find the full code for this file
    at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run this code, you should see smoother avoidance. You may need to tweak
    the timings and values. The bottom two conditions, reversing and reverse turning,
    might need to be tuned. Set the timings higher if the robot isn't quite pulling
    back enough, or lower if it turns away too far.
  prefs: []
  type: TYPE_NORMAL
- en: There are still flaws in this behavior, though. It does not construct a map
    at all and has no reverse sensors, so while avoiding objects in front, it can
    quite quickly reverse into objects behind it. Adding more sensors could resolve
    some of these problems. Still, we cannot construct a map just yet as our robot
    does not have the sensors to determine how far it has turned or traveled accurately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have added sensors to our robot. This is a major step as
    it makes the robot autonomous, behaving on its own and responding in some way
    to its environment. You've learned how to add distance sensing to our robots,
    along with the different kinds of sensors that are available. We've seen code
    to make it work and test these sensors. We then created behaviors to avoid walls
    and looked at how to make a simplified but flawed behavior, and how a more sophisticated
    and smoother behavior would make for a better system.
  prefs: []
  type: TYPE_NORMAL
- en: With this experience, you can consider how other sensors could be interfaced
    with your robot, and some simple code to interact with them. You can output data
    from sensors so you can debug their behavior and create a behavior to make a robot
    perform some simple navigation on its own.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we look further into driving predetermined paths and straight
    lines using an encoder to make sure that the robot moves far more accurately.
    We use an encoder to compare our motor's output with our expected goals and get
    more accurate turns.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some robots get by with just a single sensor. Can you think of a way of avoiding
    obstacles reliably with a single sensor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a pan/tilt mechanism, which we use later for a camera. Consider putting
    a sensor on this, and how to incorporate this into a behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot behavior we created in this chapter can reverse into things. How could
    you remedy this? Perhaps make a plan and try to build it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: The RCWL-1601 is still quite similar to the HC-SR04\. The HC-SR04 data sheet
    has useful information about its range. You can find the data sheet at [https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf](https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ModMyPi has a tutorial with an alternative way to wire the original HC-SR04
    types, and level shift their IO: [https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi](https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi Tutorials also has a breadboard layout and Python script, using
    `RPi.GPIO` instead of `gpiozero`, at [https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/](https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've started to use many pins on the Raspberry Pi. When trying to ascertain
    which pins to use, I highly recommend visiting the Raspberry Pi GPIO at [https://pinout.xyz/](https://pinout.xyz/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We briefly mentioned debug output and refining it. W3schools has an interactive
    guide to Python format strings at [https://www.w3schools.com/python/ref_string_format.asp](https://www.w3schools.com/python/ref_string_format.asp).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many scholarly articles available on more interesting or sophisticated
    object behavior. I recommend reading *Simple, Real-Time Obstacle Avoidance Algorithm*
    ([https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf](https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf))
    for mobile robots for a more in-depth look at these behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
