- en: '*Chapter 8*: Programming Distance Sensors with Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we look at distance sensors and how to use them to avoid objects.
    Avoiding obstacles is a key feature in mobile robots, as bumping into stuff is
    generally not good. It is also a behavior that starts to make a robot appear smart,
    as if it is behaving intelligently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we find out about the different types of sensors and choose
    a suitable type. We then build a layer in our robot object to access them and,
    in addition to this, we create a behavior to avoid walls and objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between optical and ultrasonic sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching and reading an ultrasonic sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding walls – writing a script to avoid obstacles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the hands-on experiments in this chapter, you will require the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi robot and the code from the previous chapters.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two HC-SR04P, RCWL-1601, or Adafruit 4007 ultrasonic sensors. They must have
    a 3.3 V output.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22 AWG single-core wire or a pre-cut breadboard jumper wire kit.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard-friendly **single pole, double toggle (SPDT**) slide switch.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-female jumpers, preferably of the joined-up jumper jerky type.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two brackets for the sensor.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crosshead screwdriver.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miniature spanners or small pliers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2KfCkZM](https://bit.ly/2KfCkZM)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between optical and ultrasonic sensors
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to use distance sensors, let's find out what these sensors actually
    are, how they work, and some of the different types available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common ways in which to sense distance are to use ultrasound or light.
    The principle of both of these mechanisms is to fire off a pulse and then sense
    its reflected return, using either its timing or angle to measure a distance,
    as can be seen in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Using pulse timing in a distance sensor'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Using pulse timing in a distance sensor
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We focus on the sensors that measure the response time, otherwise known as the
    **time of flight**. *Figure 8.1* shows how these sensors use reflection time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how sensors work, we'll now take a closer look
    at optical sensors and ultrasonic sensors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Optical sensors
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Light-based sensors, like the one in *Figure 8.2*, use infrared laser light
    that we cannot see. These devices can be tiny; however, they can suffer in strong
    sunlight and fluorescent light, making them misbehave. Some objects reflect light
    poorly or are transparent and are undetectable by these sensors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – A VL530LOx on a carrier board'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – A VL530LOx on a carrier board
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In competitions where infrared beams detect course times, the beams and these
    sensors can interfere with each other. However, unlike ultrasonic sensors, these
    are unlikely to cause false detections when placed on different sides of a robot.
    Optical distance sensors can have higher accuracy, but over a more limited range.
    They can be expensive, although there are cheaper fixed range types of light sensors
    out there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Ultrasonic sensors
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many sound-based distance measuring devices use ultrasonic sound with frequencies
    beyond human hearing limits, although they can annoy some animals, including dogs.
    Mobile phone microphones and some cameras pick up their pulses as clicks. Ultrasonic
    devices tend to be larger than optical ones, but cheaper since sound travels slower
    than light and is easier to measure. Soft objects that do not reflect sound, such
    as fabrics, can be harder for these to detect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.3* shows the HC-SR04, a common and inexpensive sound-based distance
    sensor:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The HC-SR04'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The HC-SR04
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: They have a range of up to 4 meters from a minimum of about 2 cm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ultrasonic-based devices, including the common HC-SR04,
    but not all of them are suitable. We'll look at logic levels as this is an important
    factor in choosing which sensor to buy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Logic levels and shifting
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I/O pins on the Raspberry Pi are only suitable for inputs of 3.3 V. Many
    devices in the market have a 5 V logic, either for their inputs when controlling
    them, or from their outputs. Let's dig into what I mean by logic levels, and why
    it is sensible to try and stick to the native voltage level when possible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Voltage** is a measure of how much pushing energy there is on an electrical
    flow. Different electronics are built to tolerate or to respond to different voltage
    levels. Putting too high a voltage through a device can damage it. On the other
    hand, putting too low a voltage can cause your sensors or outputs to simply not
    respond or behave strangely. We are dealing with logic devices that output a high
    or low voltage to represent a true/false value. These voltages must be above a
    threshold to be true, and below it to be false. We must be aware of these electrical
    properties, or we will destroy things and fail to get them to communicate.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph in *Figure 8.4* shows the effects that different levels have:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Voltages and logic levels'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Voltages and logic levels
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.4*, we show a graph. On the *y*-axis (left), it shows voltage labels
    from 0 to 5 V. The *y*-axis shows different operating conditions. There are 4
    dashed lines running through the graph. The lowest dashed line is at 0.8 V; below
    this, an input will consider it as logic 0\. The next line, at around 2.3 V, is
    where many 3.3 V devices consider things at logic 1\. The line at 3.3 V shows
    the expected input and output level for logic 1 on a Raspberry Pi. Above this
    line, damage may occur to a Raspberry Pi. At around 4.2 V is what some 5 V devices
    expect for logic 1 (although some will allow as low as 2 V for this) – the Raspberry
    Pi needs help to talk to those.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Along the graph are 5 bars. The first labeled bar is at 0 – meaning a clear
    logic 0 to all devices. The next bar is a clear logic 1 for the Raspberry Pi at
    3.3 V, but it is also below 4.2 V, so some 5 V devices won't recognize this. The
    bar labelled unclear is at 1.8 V – in this region, between the low and the high
    thresholds, the logic might not be clear, and this should be avoided. The bar
    labeled **Vague logic 1** is above the threshold, but only just, and could be
    misinterpreted or cause odd results on 3.3 V devices. The last bar is at 5 V,
    which 5 V devices output. This must not go to the Raspberry Pi without a level
    shifter or it will destroy that Raspberry Pi.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: There are bars in *Figure 8.4* at 1.7 V and 2.3 V. These voltages are very close
    to the logic threshold and can result in random data coming from the input. Avoid
    intermediate voltages between the required logic levels. 3 V is OK, but avoid
    1.5 V as this is ambiguous.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Putting more than 3.3 V into a Raspberry Pi pin damages the Raspberry Pi. Do
    not use 5 V devices without logic level shifters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use devices that are 5 V, you require extra electronics to interface
    them. The electronics come with further wiring and parts, thereby increasing the
    cost, complexity, or size of the robot''s electronics:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_08_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Wiring the HC-SR04 sensors into the level shifters
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.5* shows a wiring diagram for a robot that uses HC-SR04 5v sensors
    that require logic level shifting. This circuit diagram shows the Raspberry Pi
    GPIO pins at the top. Coming from 3 pins to the left are the 5 V, 3.3 V (written
    as 3v3), and ground (GND) lines. Below the GPIO pins are the 3.3 V and 5 V lines.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Below the power lines (or rails) are two level shifters. Going into the right
    of the level shifters are connections from the Raspberry Pi GPIO pins 5, 6, 17,
    and 27\. In this style of diagram, a black dot shows a connection, and lines that
    do not connect are shown with a bridge.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of the diagram has a ground line from the ground pin. This is shown
    as it's normal that additional electronics will require access to a ground line.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The left of the diagram has the two distance sensors, with connections to 5
    V and GND. Each sensor has the **trig** and **echo** pins wired to the level shifters.
    It's not hard to see how adding more sensors that also require level shifters
    to this would further increase complexity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, other options are now available. Where it is possible to use a 3.3
    V native device or a device that uses its supply voltage for logic high, it is
    worth choosing these devices. When buying electronics for a robot, consider carefully
    what voltage the robot's main controller uses (like the Raspberry Pi), and check
    that the electronics work with the controller's voltages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The HC-SR04 has several replacement parts that have this ability. The HC-SR04P,
    the RCWL-1601, and Adafruit 4007 models output 3.3 V and can connect directly
    to the Raspberry Pi.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Why use two sensors?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having two sensors allows a behavior to detect which side is closer. With this,
    the robot can detect where open spaces are and move toward them. *Figure 8.6*
    shows how this works:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Using two sensors'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Using two sensors
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.6*, the second robot can make more interesting decisions because
    it has more data from the world with which to make those decisions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Considering all of these options, I recommend you use a 3.3 V variant like the
    HC-SR04P/RCWL-1601 or Adafruit 4007 because they are cheap and because it is easy
    to add two or more of these sensors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We've seen some distance sensor types and discussed the trade-offs and choices
    for this robot. You've learned about voltage levels, and why this is a crucial
    consideration for robot electronics. We've also looked at how many sensors we
    could use and where we could put them. Now let's look at how to add them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Attaching and reading an ultrasonic sensor
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we should wire in and secure these sensors to the robot. We then write
    some simple test code that we can use to base our behavior code on in the next
    section. After completing this section, the robot block diagram should look like
    *Figure 8.7*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Robot block diagram with ultrasonic sensors'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Robot block diagram with ultrasonic sensors
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: This diagram builds on the block diagram in *Figure 6.33* from [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096)*,
    Building Robot Basics – Wheels, Power, and Wiring* by adding left and right ultrasonic
    sensors. Both have bi-directional arrows to the Raspberry Pi, since, being an
    active sensor, the Raspberry Pi triggers a sensor measurement and then reads back
    the result. Let's attach the sensors to the robot chassis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Securing the sensors to the robot
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Technical requirements* section, I added an HC-SR04 bracket. Although
    it is possible to make a custom bracket with CAD and other part making skills,
    it is more sensible to use one of the stock designs. *Figure 8.8* shows the bracket
    I''m using:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Ultrasonic HC-SR04 sensor brackets with the screws and hardware'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Ultrasonic HC-SR04 sensor brackets with the screws and hardware
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'These are easy to attach to your robot, assuming that your chassis is similar
    enough to mine, in that it has mounting holes or a slot to attach this bracket:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Steps for mounting the sensor bracket'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Steps for mounting the sensor bracket
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount the sensor bracket, use *Figure 8.9* as a guide for the following
    steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Push the two bolts into the holes on the bracket.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the bracket screws through the holes at the front of the robot.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread a nut from underneath the robot on each and tighten. Repeat this for
    the other side.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot should look like this with the two brackets mounted.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 8.10* shows how to push the sensors into the brackets:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Pushing the sensors into the brackets'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15660_08_10.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.10 – Pushing the sensors into the brackets
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Look at the sensor. The two transducer elements, the round cans with a gauze
    on top, will fit well in the holes in the brackets.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The distance sensors can simply be pushed into the brackets, since they have
    a friction fit. The electrical connector for the sensor should be facing upward.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After putting in both sensors, the robot should look like panel 7 of *Figure
    8.10*.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've now attached the sensors to the chassis. Before we wire them, we'll take
    a slight detour and add a helpful power switch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Adding a power switch
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we turn on the robot again, let''s add a switch for the motor power.
    This switch is more convenient than screwing the ground wire from the battery
    into the terminal repeatedly. We''ll see how to do this in three simple steps.
    Follow along:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have the following equipment ready, as shown in *Figure 8.11*:
    a breadboard, some velcro, a mini breadboard-friendly SPDT switch, and one length
    of single-core 22 AWG wire:![Figure 8.11 – Items needed to add a power switch'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15660_08_11.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.11 – Items needed to add a power switch
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now use two strips of Velcro to stick the breadboard on top of the robot''s
    battery, as shown in *Figure 8.12*. The velcro holds firm but is easy to remove
    if you need to disassemble the robot:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Adding velcro strips'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Adding velcro strips
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: With the breadboard in place, we can now add a switch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at *Figure 8.13* for details on how the switch is connected:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Wiring the switch'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Wiring the switch
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.13* shows a circuit diagram, a close-up of a breadboard, and a suggested
    way to wire the physical connections on the robot. Let''s look at this in detail:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: This is a circuit diagram showing the batteries, switch, and motor power input
    connectors. At the top is the *motor power in* terminal. From the positive (+)
    side of that terminal, a wire goes down the left to the batteries, shown as alternating
    thick and thin bars. From the batteries, the bottom terminal is their negative
    side. A wire goes from this around to the switch on the right of the diagram.
    The top of the switch is then connected via a wire to the negative (-) side of
    the *motor power in terminal*. This is the important diagram for making the connections.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we physically wire the switch, it's worth talking about the rows of the
    breadboard. This panel shows a close-up of a breadboard, with 2 of the rows highlighted
    in green lines. The green lines show that the rows are connected in groups of
    5\. The arrangement of a breadboard has two wired groups of 5 holes (tie-points)
    for each of the rows (numbered 1 to 30). It has a groove in the middle separating
    the groups.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The physical wiring uses the breadboard to make connections from wires to devices.
    It won't match the diagram precisely. The left shows the motor board, with a red
    wire from the batteries, their positive side, going into the positive (+ or VIN)
    terminal on the *motor power in terminal*. The batteries are in the middle. A
    black wire goes from the batteries into the breadboard in row 3, column *d*. In
    column *e*, a switch is plugged into the breadboard going across rows 1, 2, and
    3\. An orange precut 22 AWG wire goes from row 2 to the GND terminal, where it
    is screwed in. Sliding this switch turns on the power to the robot motors.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now given our robot a power switch for its motor batteries, so we can
    turn the motor power on without needing a screwdriver. Next, we will use the same
    breadboard to wire up the distance sensors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the distance sensors
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each ultrasonic sensor has four connections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: A trigger pin to ask for a reading
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An echo pin to sense the return
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A VCC/voltage pin that should be 3.3 V
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GND or ground pin
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the whole robot is switched off before proceeding any further. The
    trigger and echo pins need to go to GPIO pins on the Raspberry Pi.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.14* shows a close-up of the Raspberry Pi GPIO port to assist in making
    connections:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Raspberry Pi connections'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Raspberry Pi connections
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.14* is a diagram view of the GPIO connector on the Raspberry Pi.
    This connector is the 40 pins set in two rows at the top of the Pi. Many robots
    and gadgets use them. The pin numbers/names are not printed on the Raspberry Pi,
    but this diagram should assist in finding them.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a breadboard for this wiring. *Figure 8.15* shows the connections needed
    for these:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_08_15.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Sensor wiring diagram
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Wires from the Raspberry Pi to the breadboard, and from the sensor to the breadboard,
    need male-to-female jumper wires. Wires on the breadboard (there are only 4 of
    these) use short pre-cut wires. *Figure 8.15* shows a circuit diagram above, and
    a breadboard wiring suggestion below.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'To wire the sensors, use *Figure 8.15* as a guide, along with these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Start with the power connections. A wire goes from the 3.3 V (often written
    as 3v3 on diagrams) pin on the Raspberry Pi to the top, red-marked rail on the
    breadboard. We can use this red *rail* for other connections needing 3.3 V.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wire from one of the GND pins on the Pi goes to the black- or blue-marked
    rail on the breadboard. We can use this blue *rail* for connections requiring
    GND.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull off a strip of 4 from the male-to-female jumper wires for each side.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the left-hand sensor, identify the four pins—VCC, trig, echo, and GND. For
    the connection from this to the breadboard, it's useful to keep the 4 wires together.
    Take 4 male-to-female connectors (in a joined strip if possible), from this sensor,
    and plug them into the board.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the breadboard, use the precut wires to make a connection from ground to
    the blue rail, and from VCC to the red rail.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now use some jumper wires to make the signal connections from the trig/echo
    pins to the Raspberry Pi GPIO pins.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on where you've placed your breadboard, the distance sensor wires
    may not reach. If this is the case, join two male-to-female wires back to back,
    and use some electrical tape to bind them together.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For neatness, I like to wrap wires in spiral wrap; this is entirely optional
    but can reduce the clutter on the robot.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Please double-check your connections before you continue. You have now installed
    the distance sensors into your robot's hardware, but in order to test and use
    them, we need to prepare the software components.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python libraries to communicate with the sensor
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with the GPIO sensor, and some other hardware, you need a Python library.
    Let''s use the `GPIOZero` library, designed to help interface with hardware like
    this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the library now installed, we can write our test code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Reading an ultrasonic distance sensor
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write code for distance sensors, it helps to understand how they work. As
    suggested previously, this system works by bouncing sound pulses off of objects
    and measuring the pulse return times.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The code on the Raspberry Pi sends an electronic pulse to the **trigger** pin
    to ask for a reading. In response to this pulse, the device makes a sound pulse
    and times its return. The **echo** pin responds using a pulse too. The length
    of this pulse corresponds to the sound travel time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph in *Figure 8.16* shows the timing of these:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Timing of a pulse and the response for an ultrasonic distance
    sensor'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_16.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Timing of a pulse and the response for an ultrasonic distance
    sensor
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The `GPIOZero` library can time this pulse, and convert it into a distance,
    which we can use in our code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The device might fail to get a return response in time if the sound didn't echo
    back soon enough. Perhaps the object was outside the sensor's range, or something
    dampened the sound.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with our servo motor control class previously, we should use comments
    and descriptive names to help us explain this part of the code. I''ve called this
    file `test_distance_sensors.py`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by importing `time` and the `DistanceSensor` library:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we set up the sensors. I''ve used `print` statements to show what is
    going on. In these lines, we create library objects for each distance sensor,
    registering the pins we have connected them on. Try to make sure these match your
    wiring:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This test then runs in a loop until we cancel it:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then print the distance from our sensors. `.distance` is a property, as
    we saw with the `.count` property on our LED system earlier in the book. The sensors
    are continuously updating it. We multiply it by 100 since `GPIOZero` distance
    is in terms of a meter:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A little sleep in the loop stops it flooding the output too much and prevents
    tight looping:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can turn on your Raspberry Pi and upload this code.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put an object anywhere between 4 centimeters and 1 meter away from the sensor,
    as demonstrated in the following image:![](img/B15660_08_17.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 8.17 – Distance sensor with object
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 8.17* shows an item roughly 10.5 cm from a sensor. The object is a
    small toolbox. Importantly it is rigid and not fabric.'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the code on the Pi with `python3 test_distance_sensors.py`. As you move
    around the object, your Pi should start outputting distances:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because it is in a loop, you need to press *Ctrl* + *C* to stop the program
    running.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll see here that there are many decimal places, which isn''t too helpful
    here. First, the devices are unlikely to be that accurate, and second, our robot
    does not need sub-centimeter accuracy to make decisions. We can modify the print
    statement in the loop to be more helpful:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the code with this change gives the following output:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You've demonstrated that the distance sensor is working. Added to this is exploring
    how you can tune the output from a sensor for debugging, something you'll do a
    lot more when making robots. To make sure you're on track, let's troubleshoot
    anything that has gone wrong.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If this sensor isn''t working as expected, try the following troubleshooting
    steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Is anything hot in the wiring? Hold the wires to the sensor between the thumb
    and forefinger. *Nothing should be hot or even warming*! If so, remove the batteries,
    turn off the Raspberry Pi, and thoroughly check all wiring against *Figure 8.12*.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are syntax errors, please check the code against the examples. You
    should have installed Python libraries with `pip3` and be running with `python3`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are still getting errors, or invalid values, please check the code and
    indentation.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the values are always `0`, or the sensor isn't returning any values, then
    you may have swapped trigger and echo pins. Try swapping the trigger/echo pin
    numbers in the code and testing it again. *Don't* swap the cables on a live Pi!
    Do this one device at a time.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are still getting no values, ensure you have purchased 3.3 V-compatible
    systems. The HC-SR04 model will not work with the bare Raspberry Pi.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If values are way out or drifting, then ensure that the surface you are testing
    on is hard. Soft surfaces, such as clothes, curtains, or your hand, do not respond
    as well as glass, wood, metal, or plastic. A wall works well!
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another reason for incorrect values is the surface may be too small. Make sure
    that your surface is quite wide. Anything smaller than about 5 cm square may be
    harder to measure.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a last resort, if one sensor seems fine, and the other wrong, it's possible
    that a device is faulty. Try swapping the sensors to check this. If the result
    is different, then a sensor may be wrong. If the result is the same, it is the
    wiring or code that is wrong.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have now troubleshooted your distance sensor and made sure that it works.
    You have seen it output values to show that it is working and tested it with objects
    to see its response. Now, let's step up and write a script to avoid obstacles.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding walls – writing a script to avoid obstacles
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have tested both sensors, we can integrate them with our robot class
    and make obstacle avoidance behavior for them. This behavior loop reads the sensors
    and then chooses behavior accordingly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Adding the sensors to the robot class
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, before we can use the sensors in a behavior, we need to add them to the
    `Robot` class, assigning the correct pin numbers for each side. This way, if pin
    numbers change or even the interface to a sensor changes, behaviors will not need
    to change:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `DistanceSensor` object, we need to import it from `gpiozero`; the
    new code is in bold:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We create an instance of one of these `DistanceSensor` objects for each side
    in the robot class. We need to set these up in the constructor for our robot.
    We use the same pin numbers and queue length as in our test:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding this to our robot layer makes it available to behaviors. When we create
    our robot, the sensors will be sampling distances. Let's make a behavior that
    uses them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Making the obstacle avoid behaviors
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter is all about getting a behavior; how can a robot drive and avoid
    (most) obstacles? The sensor''s specifications limit it, with smaller objects
    or objects with a soft/fuzzy shell, such as upholstered items, not being detected.
    Let''s start by drawing what we mean in *Figure 8.18*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Obstacle avoidance basics'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_18.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Obstacle avoidance basics
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In our example (*Figure 8.18*), a basic robot detects a wall, turns away, keeps
    driving until another wall is detected, and then turns away from that. We can
    use this to make our first attempt at wall-avoiding behavior.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: First attempt at obstacle avoidance
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help us understand this task, the following diagram shows a flow diagram
    for the behavior:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Obstacle avoidance flowchart'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_08_19.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Obstacle avoidance flowchart
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The flow diagram in *Figure 8.19* starts at the top.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram describes a loop that does the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The **Start** box goes into a **Get Distances** box, which gets the distances
    from each sensor.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We test whether the left sensor reads less than 20 cm (a reasonable threshold):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) If so, we set the left motor in reverse to turn the robot away from the obstacle.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) Otherwise, we drive the left motor forward.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now check the right sensor, setting it backward if closer than 20 cm, or
    forward if not.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program waits a short time and loops around again.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We put this loop in a `run` method. There›s a small bit of setup required in
    relation to this. We need to set the pan and tilt to `0` so that it won''t obstruct
    the sensors. I''ve put this code in `simple_avoid_behavior.py`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the robot, and `sleep` for timing:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following class is the basis of our behavior. There is a robot object stored
    in the behavior. A speed is set, which can be adjusted to make the robot go faster
    or slower. Too fast, and it has less time to react:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now the following method chooses a speed for each motor, depending on the distance
    detected by the sensor. A nearer sensor distance turns away from the obstacle:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `run` method is the core, since it has the main loop. We put the pan and
    tilt mechanism in the middle so that it doesn''t obstruct the sensors:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we start the main loop:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then print out our readings on the console:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we use the distances with our `get_motor_speed` method and send this to
    each motor:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since this is our main loop, we wait a short while before we loop again. Under
    this is the setup and starting behavior:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code for this behavior is now completed and ready to run. It's time to try
    it out. To test this, set up a test space to be a few square meters wide. Avoid
    obstacles that the sensor misses, such as upholstered furniture or thin obstacles
    such as chair legs. I've used folders and plastic toy boxes to make courses for
    these.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Send the code to the robot and try it out. It drives until it encounters an
    obstacle, and then turns away. This kind of works; you can tweak the speeds and
    thresholds, but the behavior gets stuck in corners and gets confused.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps it's time to consider a better strategy.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated object avoidance
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous behavior can leave the robot stuck. It appears to be indecisive
    with some obstacles and occasionally ends up ramming others. It may not stop in
    time or turn into things. Let's make a better one that drives more smoothly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is our strategy? Well, let''s think in terms of the sensor nearest
    to an obstacle, and the furthest. We can work out the speeds of the motor nearest
    to it, the motor further from it, and a time delay. Our code uses the time delay
    to be decisive about turning away from a wall, with the time factor controlling
    how far we turn. This reduces any jitter. Let''s make some changes to the last
    behavior for this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的策略是什么呢？好吧，让我们从最靠近障碍物的传感器和最远的传感器来思考。我们可以计算出最靠近它的电机的速度，远离它的电机的速度，以及一个时间延迟。我们的代码使用时间延迟来决定是否从墙上转向，时间因素控制我们转多远。这减少了任何抖动。让我们对最后的行为做一些修改：
- en: First, copy the `simple_avoid_behavior.py` file into a new file called `avoid_behavior.py`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`simple_avoid_behavior.py`文件复制到一个名为`avoid_behavior.py`的新文件中。
- en: 'We won''t be needing `get_motor_speed`, so remove that. We replace it with
    a function called `get_speeds`. This takes one parameter, `nearest_distance`,
    which should always be the distance sensor with the lower reading:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不再需要`get_motor_speed`，所以将其删除。我们用名为`get_speeds`的函数来替换它。这个函数接受一个参数，`nearest_distance`，它应该是读数较低的距离传感器：
- en: '[PRE19]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These numbers are all for fine-tuning. The essential factor is that depending
    on the distance, we slow down the motor further from the obstacle, and if we get
    too close, it drives away. Based on the time delay, and knowing which motor is
    which, we can drive our robot.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些数字都是为了微调。关键因素是，根据距离，我们让远离障碍物的电机减速，如果我们太靠近，它会驶离。基于时间延迟，并且知道哪个电机是哪个，我们可以控制我们的机器人。
- en: 'Most of the remaining code stays the same. This is the `run` function you''ve
    already seen:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大部分剩余的代码保持不变。这是你之前已经见过的`run`函数：
- en: '[PRE20]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It now uses the `get_speeds` method to determine a nearest and furthest distance.
    Notice that we take the `min`, or minimum, of the two distances. We get back the
    speeds for both motors and a delay, and then print out the variables so we can
    see what''s going on:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它使用`get_speeds`方法来确定最近和最远的距离。注意，我们取两个距离中的`min`，即最小值。我们得到两个电机的速度和一个延迟，然后打印出变量，这样我们就可以看到发生了什么：
- en: '[PRE21]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we check which side is nearer, left or right, and set up the correct motors:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们检查哪一侧更近，左边还是右边，并设置正确的电机：
- en: '[PRE22]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead of sleeping a fixed amount of time, we sleep for the amount of time
    in the `delay` variable. The delay is in milliseconds, so we need to multiply
    it to get seconds:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是固定睡眠一段时间，而是根据`delay`变量中的时间睡眠。延迟是以毫秒为单位的，所以我们需要将其乘以得到秒数：
- en: '[PRE23]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The rest of the code remains the same. You can find the full code for this file
    at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的其他部分保持不变。你可以在[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8)找到这个文件的完整代码。
- en: When you run this code, you should see smoother avoidance. You may need to tweak
    the timings and values. The bottom two conditions, reversing and reverse turning,
    might need to be tuned. Set the timings higher if the robot isn't quite pulling
    back enough, or lower if it turns away too far.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该看到更平滑的避开行为。你可能需要调整时间和值。最后两个条件，反转和反转转向，可能需要调整。如果机器人拉回不够，则将时间设置得更高，如果它转得太远，则设置得更低。
- en: There are still flaws in this behavior, though. It does not construct a map
    at all and has no reverse sensors, so while avoiding objects in front, it can
    quite quickly reverse into objects behind it. Adding more sensors could resolve
    some of these problems. Still, we cannot construct a map just yet as our robot
    does not have the sensors to determine how far it has turned or traveled accurately.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这种行为仍然存在缺陷。它根本不会构建地图，也没有反向传感器，所以当它避开前面的物体时，它可以相当快地反向撞到后面的物体。增加更多的传感器可以解决一些这些问题。然而，我们仍然不能构建地图，因为我们的机器人没有传感器来准确确定它转了多少圈或行驶了多少距离。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have added sensors to our robot. This is a major step as
    it makes the robot autonomous, behaving on its own and responding in some way
    to its environment. You've learned how to add distance sensing to our robots,
    along with the different kinds of sensors that are available. We've seen code
    to make it work and test these sensors. We then created behaviors to avoid walls
    and looked at how to make a simplified but flawed behavior, and how a more sophisticated
    and smoother behavior would make for a better system.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: With this experience, you can consider how other sensors could be interfaced
    with your robot, and some simple code to interact with them. You can output data
    from sensors so you can debug their behavior and create a behavior to make a robot
    perform some simple navigation on its own.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we look further into driving predetermined paths and straight
    lines using an encoder to make sure that the robot moves far more accurately.
    We use an encoder to compare our motor's output with our expected goals and get
    more accurate turns.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some robots get by with just a single sensor. Can you think of a way of avoiding
    obstacles reliably with a single sensor?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a pan/tilt mechanism, which we use later for a camera. Consider putting
    a sensor on this, and how to incorporate this into a behavior.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot behavior we created in this chapter can reverse into things. How could
    you remedy this? Perhaps make a plan and try to build it.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links for more information:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The RCWL-1601 is still quite similar to the HC-SR04\. The HC-SR04 data sheet
    has useful information about its range. You can find the data sheet at [https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf](https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf).
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ModMyPi has a tutorial with an alternative way to wire the original HC-SR04
    types, and level shift their IO: [https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi](https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi Tutorials also has a breadboard layout and Python script, using
    `RPi.GPIO` instead of `gpiozero`, at [https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/](https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've started to use many pins on the Raspberry Pi. When trying to ascertain
    which pins to use, I highly recommend visiting the Raspberry Pi GPIO at [https://pinout.xyz/](https://pinout.xyz/).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We briefly mentioned debug output and refining it. W3schools has an interactive
    guide to Python format strings at [https://www.w3schools.com/python/ref_string_format.asp](https://www.w3schools.com/python/ref_string_format.asp).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many scholarly articles available on more interesting or sophisticated
    object behavior. I recommend reading *Simple, Real-Time Obstacle Avoidance Algorithm*
    ([https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf](https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf))
    for mobile robots for a more in-depth look at these behaviors.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更多有趣或复杂的对象行为方面，有许多学术文章可供参考。我建议阅读*简单、实时障碍物避障算法*([https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf](https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf))，以深入了解这些行为。
