- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multimodal Modular RAG for Drone Technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take generative AI to the next level with modular RAG in this chapter.
    We will build a system that uses different components or modules to handle different
    types of data and tasks. For example, one module processes textual information
    using LLMs, as we have done until the last chapter, while another module manages
    image data, identifying and labeling objects within images. Imagine using this
    technology in drones, which have become crucial across various industries, offering
    enhanced capabilities for aerial photography, efficient agricultural monitoring,
    and effective search and rescue operations. They even use advanced computer vision
    technology and algorithms to analyze images and identify objects like pedestrians,
    cars, trucks, and more. We can then activate an LLM agent to retrieve, augment,
    and respond to a user’s question.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a multimodal modular RAG program to generate
    responses to queries about drone technology using text and image data from multiple
    sources. We will first define the main aspects of modular RAG, multimodal data,
    multisource retrieval, modular generation, and augmented output. We will then
    build a multimodal modular RAG-driven generative AI system in Python applied to
    drone technology with LlamaIndex, Deep Lake, and OpenAI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our system will use two datasets: the first one containing textual information
    about drones that we built in the previous chapter and the second one containing
    drone images and labels from Activeloop. We will use Deep Lake to work with multimodal
    data, LlamaIndex for indexing and retrieval, and generative queries with OpenAI
    LLMs. We will add multimodal augmented outputs with text and images. Finally,
    we will build performance metrics for the text responses and introduce an image
    recognition metric with GPT-4o, OpenAI’s powerful **Multimodal LLM** (**MMLLM**).
    By the end of the chapter, you will know how to build a multimodal modular RAG
    workflow leveraging innovative multimodal and multisource functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Multimodal modular RAG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multisource retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAI LLM-guided multimodal multisource retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep Lake multimodal datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image metadata-based retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmented multimodal output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin by defining multimodal modular RAG.
  prefs: []
  type: TYPE_NORMAL
- en: What is multimodal modular RAG?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multimodal data combines different forms of information, such as text, images,
    audio, and video, to enrich data analysis and interpretation. Meanwhile, a system
    is a modular RAG system when it utilizes distinct modules for handling different
    data types and tasks. Each module is specialized; for example, one module will
    focus on text and another on images, demonstrating a sophisticated integration
    capability that enhances response generation with retrieved multimodal data.
  prefs: []
  type: TYPE_NORMAL
- en: The program in this chapter will also be multisource through the two datasets
    we will use. We will use the LLM dataset on the drone technology built in the
    previous chapter. We will also use the Deep Lake multimodal VisDrone dataset,
    which contains thousands of labeled images captured by drones.
  prefs: []
  type: TYPE_NORMAL
- en: We have selected drones for our example since drones have become crucial across
    various industries, offering enhanced capabilities for aerial photography, efficient
    agricultural monitoring, and effective search and rescue operations. They also
    facilitate wildlife tracking, streamline commercial deliveries, and enable safer
    infrastructure inspections. Additionally, drones support environmental research,
    traffic management, and firefighting. They can enhance surveillance for law enforcement,
    revolutionizing multiple fields by improving accessibility, safety, and cost-efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.1* contains the workflow we will implement in this chapter. It is
    based on the generative RAG ecosystem illustrated in *Figure 1.3* from *Chapter
    1*, *Why Retrieval-Augmented Generation?*. We added embedding and indexing functionality
    in the previous chapters, but this chapter will focus on retrieval and generation.
    The system we will build blurs the lines between retrieval and generation since
    the generator is intensively used for retrieving (seamless scoring and ranking)
    as well as generating in the chapter’s notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a multimodal modular rag system  Description automatically generated](img/B31169_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: A multimodal modular RAG system'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to build an educational modular RAG question-answering system
    focused on drone technology. You can rely on the functionality implemented in
    the notebooks of the preceding chapters, such as Deep Lake for vectors in *Chapter
    2*, *RAG Embedding Vector Stores with Deep Lake and OpenAI*, and indices with
    LlamaIndex in *Chapter 3*, *Building* *Index-based RAG with LlamaIndex, Deep Lake,
    and OpenAI*. If necessary, take your time to go back to the previous chapters
    and have a look.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the multimodal, multisource, modular RAG ecosystem in this
    chapter, represented in *Figure 4.1*. We will use the titles and subsections in
    this chapter represented in italics. Also, each phase is preceded by its location
    in *Figure 4.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '**(D4)** *Loading the LLM dataset* created in *Chapter 3*, which contains textual
    data on drones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(D4)** *Initializing the LLM query engine* with a LlamaIndex vector store
    index using `VectorStoreIndex` and setting the created index for the query engine,
    which overlaps with **(G4)** as both a retriever and a generator with the OpenAI
    GPT model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(G1)** Defining the *user input for multimodal modular RAG* for both the
    LLM query engine (for the textual dataset) and the multimodal query engine (for
    the `VisDrone` dataset).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the textual dataset has been loaded, the query engine has been created,
    and the user input has been defined as a baseline query for the textual dataset
    and the multimodal dataset, the process continues by generating a response for
    the textual dataset created in *Chapter 2*.
  prefs: []
  type: TYPE_NORMAL
- en: While *querying the textual dataset*, **(G1)**, **(G2)**, and **(G4)** overlap
    in the same seamless LlamaIndex process that retrieves data and generates content.
    The response is saved as `llm_response` for the duration of the session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the multimodal `VisDrone` dataset will be loaded into memory and queried:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(D4)** The multimodal process begins by *loading and visualizing the multimodal
    dataset*. The program then continues by *navigating the multimodal dataset structure*,
    *selecting an image*, and *adding bounding boxes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same process as for the textual dataset is then applied to the `VisDrone`
    multimodal dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(D4)** *Building a multimodal query engine* with LlamaIndex by creating a
    vector store index based on `VisDrone` data using `VectorStoreIndex` and setting
    the created index for the query engine, which overlaps with **(G4)** as both a
    retriever and a generator with OpenAI GPT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(G1)** The user input for the multimodal search engine is the same as the
    *user input for multimodal modular RAG* since it is used for both the LLM query
    engine (for the textual dataset) and the multimodal query engine (for the `VisDrone`
    dataset).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The multimodal `VisDrone` dataset will now be loaded and indexed, and the query
    engine is ready. The purpose of **(G1)** user input is for the LlamaIndex query
    engine to retrieve relevant documents from VisDrone using an LLM—in this case,
    an OpenAI model. Then, the retrieval functions will trace the response back to
    its source in the multimodal dataset to find the image of the source nodes. We
    are, in fact, using the query engine to reach an image through its textual response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(G1)**, **(G2)**, and **(G4)** overlap in a seamless LlamaIndex query when
    running a query on the `VisDrone` multimodal dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the response **(G4)** to find the source node and retrieve its image
    leads us back to **(D4)** for image retrieval. This leads to selecting and processing
    the image of the source node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, we now have the textual and the image response. We can then
    build a summary and apply an accuracy performance metric after having visualized
    the time elapsed for each phase as we built the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(G4)** We present a merged output with the LLM response and the augmented
    output with the image of the multimodal response in a *multimodal modular summary*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(E)** Finally, we create an *LLM performance metric* and a *multimodal performance
    metric*. We then sum them up as a *multimodal modular RAG performance metric*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can draw two conclusions from this multimodal modular RAG system:'
  prefs: []
  type: TYPE_NORMAL
- en: The system we are building in this chapter is one of the many ways RAG-driven
    generative AI can be designed in real-life projects. Each project will have its
    specific needs and architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rapid evolution from generative AI to the complexity of RAG-driven generative
    AI requires the corresponding development of seamlessly integrated cross-platform
    components such as LlamaIndex, Deep Lake, and OpenAI in this chapter. These platforms
    are also integrated with many other frameworks, such as Pinecone and LangChain,
    which we will discuss in *Chapter 6*, *Scaling RAG Bank Customer Data with Pinecone*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s dive into Python and build the multimodal modular RAG program.
  prefs: []
  type: TYPE_NORMAL
- en: Building a multimodal modular RAG program for drone technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following sections, we will build a multimodal modular RAG-driven generative
    system from scratch in Python, step by step. We will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: LlamaIndex-managed OpenAI LLMs to process and understand text about drones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep Lake multimodal datasets containing images and labels of drone images taken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions to display images and identify objects within them using bounding
    boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system that can answer questions about drone technology using both text and
    images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance metrics aimed at measuring the accuracy of the modular multimodal
    responses, including image analysis with GPT-4o
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, make sure you have created the LLM dataset in *Chapter 2* since we will
    be loading it in this section. However, you can read this chapter without running
    the notebook since it is self-contained with code and explanations. Now, let’s
    get to work!
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Multimodal_Modular_RAG_Drones.ipynb` notebook in the GitHub repository
    for this chapter at [https://github.com/Denis2054/RAG-Driven-Generative-AI/tree/main/Chapter04](https://github.com/Denis2054/RAG-Driven-Generative-AI/tree/main/Chapter04).
    The packages installed are the same as those listed in the *Installing the environment*
    section of the previous chapter. Each of the following sections will guide you
    through building the multimodal modular notebook, starting with the LLM module.
    Let’s go through each section of the notebook step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the LLM dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the drone dataset created in *Chapter 3*. Make sure to insert
    the path to your dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will confirm that the dataset is loaded and will display the link
    to your dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The program now creates a dictionary to hold the data to load it into a pandas
    DataFrame to visualize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the text dataset with its structure: `embedding` (vectors),
    `id` (unique string identifier), `metadata` (in this case, the source of the data),
    and `text`, which contains the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31169_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Output of the text dataset structure and content'
  prefs: []
  type: TYPE_NORMAL
- en: We will now initialize the LLM query engine.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the LLM query engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As in *Chapter 3*, *Building Indexed-Based RAG with LlamaIndex, Deep Lake,
    and OpenAI*, we will initialize a vector store index from the collection of drone
    documents (`documents_llm`) of the dataset (`ds`). The `GPTVectorStoreIndex.from_documents()`
    method creates an index that increases the retrieval speed of documents based
    on vector similarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `as_query_engine()` method configures this index as a query engine with
    the specific parameters, as in *Chapter 3*, for similarity and retrieval depth,
    allowing the system to answer queries by finding the most relevant documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, the program introduces the user input.
  prefs: []
  type: TYPE_NORMAL
- en: User input for multimodal modular RAG
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The goal of defining the user input in the context of the modular RAG system
    is to formulate a query that will effectively utilize both the text-based and
    image-based capabilities. This allows the system to generate a comprehensive and
    accurate response by leveraging multiple information sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this context, the user input is the *baseline*, the starting point, or a
    standard query used to assess the system’s capabilities. It will establish the
    initial frame of reference for how well the system can handle and respond to queries
    utilizing its available resources (e.g., text and image data from various datasets).
    In this example, the baseline is empirical and will serve to evaluate the system
    from that reference point.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the textual dataset
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will run the vector query engine request as we did in *Chapter 3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution time is satisfactory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output content is also satisfactory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The program now loads the multimodal drone dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and visualizing the multimodal dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the existing pubic VisDrone dataset available on Deep Lake: [https://datasets.activeloop.ai/docs/ml/datasets/visdrone-dataset/](https://datasets.activeloop.ai/docs/ml/datasets/visdrone-dataset/).
    We will *not* create a vector store but simply load the existing dataset in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will display a link to the online dataset that you can explore with
    SQL, or natural language processing commands if you prefer, with the tools provided
    by Deep Lake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s display the summary to explore the dataset in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output provides useful information on the structure of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure contains images, boxes for the boundary boxes of the objects
    in the image, and labels describing the images and boundary boxes. Let’s visualize
    the dataset in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the images and their boundary boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31169_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Output showing boundary boxes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go further and display the content of the dataset in a pandas DataFrame
    to see what the images look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in *Figure 4.4* shows the content of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31169_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Excerpt of the VisDrone dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 6,471 rows of images in the dataset and 3 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: The `image` column contains the image. The format of the image in the dataset,
    as indicated by the byte sequence `b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00...'`,
    is JPEG. The bytes `b'\xff\xd8\xff\xe0'` specifically signify the start of a JPEG
    image file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boxes` column contains the coordinates and dimensions of bounding boxes
    in the image, which are normally in the format `[x, y, width, height]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `labels` column contains the label of each bounding box in the `boxes` column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can display the list of labels for the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output provides the list of labels, which defines the scope of the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have successfully loaded the dataset and will now explore the
    multimodal dataset structure.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the multimodal dataset structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will select an image and display it using the dataset’s
    image column. To this image, we will then add the bounding boxes of a label that
    we will choose. The program first selects an image.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and displaying an image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will select the first image in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s display it with no bounding boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The image displayed contains trucks, pedestrians, and other types of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31169_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Output displaying objects'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the image is displayed, the program will add bounding boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding bounding boxes and saving the image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have displayed the first image. The program will then fetch all the labels
    for the selected image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output displays `value`, which contains the numerical indices of a label,
    and `text`, which contains the corresponding text labels of a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can display the values and the corresponding text in two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output gives us a clear representation of the content of the labels of
    an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can group the class names (labels in plain text) of the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now group and display all the labels that describe the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see all the classes the image contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The number of label classes sometimes exceeds what a human eye can see in an
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add bounding boxes. We first create a function to add the bounding
    boxes, display them, and save the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the bounding boxes for a specific label. In this case, we selected
    the `"truck"` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The image displayed now contains the bounding boxes for trucks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A truck with several trailers  Description automatically generated with medium
    confidence](img/B31169_04_06.png)Figure 4.6: Output displaying bounding boxes'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now activate a query engine to retrieve and obtain a response.
  prefs: []
  type: TYPE_NORMAL
- en: Building a multimodal query engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will query the VisDrone dataset and retrieve an image that
    fits the user input we entered in the *User input for multimodal modular RAG*
    section of this notebook. To achieve this goal, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a vector index for each row of the `df` DataFrame containing the images,
    boxing data, and labels of the VisDrone dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a query engine that will query the text data of the dataset, retrieve
    relevant image information, and provide a text response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the nodes of the response to find the keywords related to the user input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the nodes of the response to find the source image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the bounding boxes of the source image to the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a vector index and query engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code first creates a document that will be processed to create a vector
    store index for the multimodal drone dataset. The `df` DataFrame we created in
    the *Loading and visualizing the multimodal dataset* section of the notebook on
    GitHub does not have unique indices or embeddings. We will create them in memory
    with LlamaIndex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program first assigns a unique ID to the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This line adds a new column to the `df` DataFrame called `doc_id`. It assigns
    unique identifiers to each row by converting the DataFrame’s row indices to strings.
    An empty list named `documents` is initialized, which we will use to create a
    vector index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `iterrows()` method iterates through each row of the DataFrame, generating
    a sequence of index and row pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`documents` is appended with all the records in the dataset, and a DataFrame
    is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The documents are now ready to be indexed with `GPTVectorStoreIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The dataset is then seamlessly equipped with indices that we can visualize
    in the index dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that an index has now been added to the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can now run a query on the multimodal dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Running a query on the VisDrone multimodal dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now set `vector_store_index` as the query engine, as we did in the *Vector
    store index query engine* section in *Chapter 3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also run a query on the dataset of drone images, just as we did in *Chapter
    3* on an LLM dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution time is satisfactory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now examine the text response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the output is logical and therefore satisfactory.
  prefs: []
  type: TYPE_NORMAL
- en: Drones use various sensors such as cameras, LiDAR, and GPS to identify and track
    objects like trucks.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now parse the nodes in the response to find the unique words in the
    response and select one for this notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We found a unique word (`''truck''`) and its unique index, which will lead
    us directly to the image of the source of the node that generated the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We could select more words and design this function in many different ways depending
    on the specifications of each project.
  prefs: []
  type: TYPE_NORMAL
- en: We will now search for the image by going through the source nodes, just as
    we did for an LLM dataset in the *Query response and source* section of the previous
    chapter. Multimodal vector stores and querying frameworks are flexible. Once we
    learn how to perform retrievals on an LLM and a multimodal dataset, we are ready
    for anything that comes up!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s select and process the information related to an image.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and processing the image of the source node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before running the image retrieval and displaying function, let’s first delete
    the image we displayed in the *Adding bounding boxes and saving the image* section
    of this notebook to make sure we are working on a new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to search for the source image, call the bounding box, and
    display and save the function we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The program now goes through the source nodes with the keyword `"truck"` search,
    applies the bounding boxes, and displays and saves the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is satisfactory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An aerial view of a factory  Description automatically generated](img/B31169_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Displayed satisfactory output'
  prefs: []
  type: TYPE_NORMAL
- en: Multimodal modular summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have built a multimodal modular program step by step that we can now assemble
    in a summary. We will create a function to display the source image of the response
    to the user input, then print the user input and the LLM output, and display the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a function to display the source image saved by the multimodal
    retrieval engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can display the user input, the LLM response, and the multimodal response.
    The output first displays the textual responses (user input and LLM response):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the image is displayed with the bounding boxes for trucks in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An aerial view of a factory  Description automatically generated](img/B31169_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Output displaying boundary boxes'
  prefs: []
  type: TYPE_NORMAL
- en: By adding an image to a classical LLM response, we augmented the output. Multimodal
    RAG output augmentation will enrich generative AI by adding information to both
    the input and output. However, as for all AI programs, designing a performance
    metric requires efficient image recognition functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Performance metric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Measuring the performance of a multimodal modular RAG requires two types of
    measurements: text and image. Measuring text is straightforward. However, measuring
    images is quite a challenge. Analyzing the image of a multimodal response is quite
    different. We extracted a keyword from the multimodal query engine. We then parsed
    the response for a source image to display. However, we will need to build an
    innovative approach to evaluate the source image of the response. Let’s begin
    with the LLM performance.'
  prefs: []
  type: TYPE_NORMAL
- en: LLM performance metric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LlamaIndex seamlessly called an OpenAI model through its query engine, such
    as GPT-4, for example, and provided text content in its response. For text responses,
    we will use the same cosine similarity metric as in the *Evaluating the output
    with cosine similarity* section in *Chapter 2*, and the *Vector store index query
    engine* section in *Chapter 3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The evaluation function uses `sklearn` and `sentence_transformers` to evaluate
    the similarity between two texts—in this case, an input and an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now calculate the similarity between our baseline user input and the
    initial LLM response obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output displays the user input, the text response, and the cosine similarity
    between the two texts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The output is satisfactory. But we now need to design a way to measure the multimodal
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Multimodal performance metric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To evaluate the image returned, we cannot simply rely on the labels in the dataset.
    For small datasets, we can manually check the image, but when a system scales,
    automation is required. In this section, we will use the computer vision features
    of GPT-4o to analyze an image, parse it to find the objects we are looking for,
    and provide a description of that image. Then, we will apply cosine similarity
    to the description provided by GPT-4o and the label it is supposed to contain.
    GPT-4o is a multimodal generative AI model.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first encode the image to simplify data transmission to GPT-4o. Base64
    encoding converts binary data (like images) into ASCII characters, which are standard
    text characters. This transformation is crucial because it ensures that the image
    data can be transmitted over protocols (like HTTP) that are designed to handle
    text data smoothly. It also avoids issues related to binary data transmission,
    such as data corruption or interpretation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program encodes the source image using Python’s `base64` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create an OpenAI client and set the model to `gpt-4o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The unique word will be the result of the LLM query to the multimodal dataset
    we obtained by parsing the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now submit the image to OpenAI GPT-4o:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We instructed the `system` and `user` roles to analyze images looking for our
    target label, `u_word`—in this case, `truck`. We then submitted the source node
    image to the model. The output that describes the image is satisfactory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now submit this response to the cosine similarity function by first
    adding an `"s"` to align with multiple trucks in a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output describes the image well but contains many other descriptions beyond
    the word “`truck`,” which limits its similarity to the input requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A human observer might approve the image and the LLM response. However, even
    if the score was very high, the issue would be the same. Complex images are challenging
    to analyze in detail and with precision, although progress is continually made.
    Let’s now calculate the overall performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Multimodal modular RAG performance metric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To obtain the overall performance of the system, we will divide the sum of
    the LLM response and the two multimodal response performances by `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The result shows that although a human who observes the results may be satisfied,
    it remains difficult to automatically assess the relevance of a complex image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The metric can be improved because a human observer sees that the image is relevant.
    This explains why the top AI agents, such as ChatGPT, Gemini, and Bing Copilot,
    always have a feedback process that includes thumbs up and thumbs down.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now sum up the chapter and gear up to explore how RAG can be improved
    even further with human feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to the world of multimodal modular RAG, which uses
    distinct modules for different data types (text and image) and tasks. We leveraged
    the functionality of LlamaIndex, Deep Lake, and OpenAI, which we explored in the
    previous chapters. The Deep Lake VisDrone dataset further introduced us to drone
    technology for analyzing images and identifying objects. The dataset contained
    images, labels, and bounding box information. Working on drone technology involves
    multimodal data, encouraging us to develop skills that we can use across many
    domains, such as wildlife tracking, streamlining commercial deliveries, and making
    safer infrastructure inspections.
  prefs: []
  type: TYPE_NORMAL
- en: We built a multimodal modular RAG-driven generative AI system. The first step
    was to define a baseline user query for both LLM and multimodal queries. We began
    by querying the Deep Lake textual dataset that we implemented in *Chapter 3*.
    LlamaIndex seamlessly ran a query engine to retrieve, augment, and generate a
    response. Then, we loaded the Deep Lake VisDrone dataset and indexed it in memory
    with LlamaIndex to create an indexed vector search retrieval pipeline. We queried
    it through LlamaIndex, which used an OpenAI model such as GPT-4 and parsed the
    text generated for a keyword. Finally, we searched the source nodes of the response
    to find the source image, display it, and merge the LLM and image responses into
    an augmented output. We applied cosine similarity to the text response. Evaluating
    the image was challenging, so we first ran image recognition with GPT-4o on the
    image retrieved to obtain a text to which we applied cosine similarity.
  prefs: []
  type: TYPE_NORMAL
- en: The journey into multimodal modular RAG-driven generative AI took us deep into
    the cutting edge of AI. Building a complex system was good preparation for real-life
    AI projects, which often require implementing multisource, multimodal, and unstructured
    data, leading to modular, complex systems. Thanks to transparent access to the
    source of a response, the complexity of RAG can be harnessed, controlled, and
    improved. We will see how we can leverage the transparency of the sources of a
    response to introduce human feedback to improve AI. The next chapter will take
    us further into transparency and precision in AI.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions with *Yes* or *No*:'
  prefs: []
  type: TYPE_NORMAL
- en: Does multimodal modular RAG handle different types of data, such as text and
    images?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are drones used solely for agricultural monitoring and aerial photography?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the Deep Lake VisDrone dataset used in this chapter for textual data only?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can bounding boxes be added to drone images to identify objects such as trucks
    and pedestrians?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the modular system retrieve both text and image data for query responses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is building a vector index necessary for querying the multimodal VisDrone dataset?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are the retrieved images processed without adding any labels or bounding boxes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the multimodal modular RAG performance metric based only on textual responses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a multimodal system such as the one described in this chapter handle only
    drone-related data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is evaluating images as easy as evaluating text in multimodal RAG?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LlamaIndex: [https://docs.llamaindex.ai/en/stable/](https://docs.llamaindex.ai/en/stable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activeloop Deep Lake: [https://docs.activeloop.ai/](https://docs.activeloop.ai/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenAI: [https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieval-Augmented Multimodal Language Modeling, Yasunaga et al. (2023), [https://arxiv.org/pdf/2211.12561](https://arxiv.org/pdf/2211.12561)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packt.link/rag](https://www.packt.link/rag)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50409000288080484.png)'
  prefs: []
  type: TYPE_IMG
