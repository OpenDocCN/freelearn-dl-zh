<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer032">
			<h1 id="_idParaDest-107" class="chapter-number"><a id="_idTextAnchor106"/>5</h1>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Programming with Planners</h1>
			<p>In the previous chapter, we learned how to chain functions manually to perform complex tasks. In this chapter, we will <a id="_idIndexMarker370"/>learn how to use <strong class="bold">planners</strong> to chain functions automatically. Chaining functions automatically can give your users a lot of flexibility, allowing them to use your application in ways that you don’t have to write <span class="No-Break">code for.</span></p>
			<p>In this chapter, we will learn how planners work, when to use them, and what to be careful about. We will also learn how to write functions and build a kernel that helps planners build <span class="No-Break">good plans.</span></p>
			<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What a planner is and when to <span class="No-Break">use one</span></li>
				<li>Creating and using a planner to run a <span class="No-Break">simple function</span></li>
				<li>Designing functions to help a planner decide the best way to <span class="No-Break">combine them</span></li>
				<li>Using a planner to allow users combine functions in complex ways without having to <span class="No-Break">write code</span></li>
			</ul>
			<p>By the end of the chapter, you will have learned how to empower users by giving them the ability to make requests in natural language, allowing them to solve complex problems that you didn’t have to write <span class="No-Break">code for.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have a recent, supported version of your preferred Python or C# <span class="No-Break">development environment:</span></p>
			<ul>
				<li>For Python, the minimum supported version is Python 3.10, and the recommended version is <span class="No-Break">Python 3.11</span></li>
				<li>For C#, the minimum supported version is .<span class="No-Break">NET 8</span></li>
			</ul>
			<p>In this chapter, we will call OpenAI services. Given the amount that companies spend on training these LLMs, it’s no surprise that using these services is not free. You will need an <strong class="bold">OpenAI API</strong> key, either <a id="_idIndexMarker371"/>directly through <strong class="bold">OpenAI</strong> or <strong class="bold">Microsoft</strong>, via the <strong class="bold">Azure </strong><span class="No-Break"><strong class="bold">OpenAI</strong></span><span class="No-Break"> service.</span></p>
			<p>If you <a id="_idIndexMarker372"/>are using .NET, the <a id="_idIndexMarker373"/>code for this chapter is <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5"><span class="No-Break">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5</span></a><span class="No-Break">.</span></p>
			<p>If you are using Python, the code for this chapter is <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5"><span class="No-Break">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5</span></a><span class="No-Break">.</span></p>
			<p>You can install the required packages by going to the GitHub repository and using the following: <strong class="source-inline">pip install -</strong><span class="No-Break"><strong class="source-inline">r requirements.txt</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>What is a planner?</h1>
			<p>So far, we have been performing complex requests by performing the function calls ourselves. This, however, requires you to restrict the kind of requests that your users can make to what <a id="_idIndexMarker374"/>you can predict and write ahead of time. It also restricts your users to only generating one output at a time. Sometimes, you may want to give them the ability to <span class="No-Break">do more.</span></p>
			<p>For example, if you have a semantic function that allows users to request jokes (as we built in <a href="B21826_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>) and a user requests “<em class="italic">tell me a knock-knock joke</em>,” you can simply call the semantic function that tells knock-knock jokes. But if the user requests three knock-knock jokes, the function wouldn’t know how to <span class="No-Break">handle it.</span></p>
			<p>A planner is a built-in function from Semantic Kernel that receives a user request and then goes through the descriptions of all the functions, parameters, and outputs of the functions you loaded in your kernel and decides the best way to combine them, generating <span class="No-Break">a </span><span class="No-Break"><strong class="bold">plan</strong></span><span class="No-Break">.</span></p>
			<p>At the time <a id="_idIndexMarker375"/>of writing, there are two planners – a <strong class="bold">Handlebars planner</strong> and a <strong class="bold">Function Calling Stepwise planner</strong>, which we will call a Stepwise <a id="_idIndexMarker376"/>planner for short. Both are used in the same way, but internally, they work in different ways. When Semantic Kernel uses the Handlebars planner, it asks the AI service (for example, GPT-3.5 or GPT-4) to write code that will call the functions you loaded into the kernel in a scripting language called Handlebars. The Handlebars planner is very new and still experimental. It is expected to consume fewer tokens than the Stepwise planner, as programming languages can be more efficient in expressing complex ideas such as conditionals and loops. The Stepwise planner generates a plan that is a dialog with a chat service, which can be longer than the plan generated by the Handlebars planner and consume more tokens. Currently, one of the major limitations of the Handlebars planner is that it is only available in C#, although a Python version is likely to be released <span class="No-Break">in 2024.</span></p>
			<p>To understand better how a planner works, assume you have a plugin that generates stories, a plugin that breaks stories into small parts, and a plugin that generates images. You load all these <a id="_idIndexMarker377"/>plugins into the kernel. The user submits <span class="No-Break">a request:</span></p>
			<p>“<em class="italic">Create a two-page story about a data scientist that solves crimes with his faithful canine companion, break it into small parts, and generate an image in the style of Frank Miller for each part</em>.” </p>
			<p>The planner will go through the functions you loaded in the kernel and determine the best order to call them, automatically producing a storyboard without you having to write any additional code other than the <span class="No-Break">initial plugins.</span></p>
			<p>Planners can enable your users to execute complex tasks with minimal effort from your side. Let’s see when to <span class="No-Break">use them.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>When to use a planner</h1>
			<p>Planners can <a id="_idIndexMarker378"/>help you as a developer in <span class="No-Break">two ways:</span></p>
			<ul>
				<li>Users can combine functions of your application in ways that you didn’t think of. If you make the functions of your application available as atomic functions inside plugins and give the users the ability to make requests to a planner, then the planner can combine these atomic functions in workflows without you having to write <span class="No-Break">any code.</span></li>
				<li>As AI models improve, planners get better without you having to write any additional code. When Semantic Kernel was initially designed, the best AI model available was GPT-3.5 Turbo. Since then, we have had the releases of GPT-4 and GPT-4 Turbo, both with more capabilities. An application built with Semantic Kernel that used GPT-3.5 Turbo can now use GPT-4 Turbo with a minor <span class="No-Break">configuration change.</span></li>
			</ul>
			<p>There are, however, some considerations when <span class="No-Break">using planners:</span></p>
			<ul>
				<li><strong class="bold">Performance</strong>: Planners need to read all the functions in your kernel and combine them <a id="_idIndexMarker379"/>with the user request. The richer your kernel is, the more functionality you can give to your users, but it will take longer for the planner to go through all the descriptions and combine them. In addition, newer models such as GPT-4 generate better plans, but they are slower, and future models could be even slower. You need to find a good balance between the number of functions you make available to your users and the models you use. When testing your application, if you find that the planner delay is noticeable, you will also need to incorporate UI cues into your application so that users know that something <span class="No-Break">is happening.</span></li>
				<li><strong class="bold">Cost</strong>: Generating a plan can consume many tokens. If you have lots of functions, and the user request is complex, Semantic Kernel will need to submit a very long prompt to the AI service containing the descriptions of the functions available in your kernel, their inputs, and their outputs to the AI service, in addition to the user request. The generated plan may also be long, and the AI service will bill you for the cost of both the submitted prompt and the output. One way to avoid this is monitoring which requests users create frequently and saving plans for those so that they don’t have to be regenerated every time. Note, however, that if you save plans and there’s an upgrade in the backend model (for example, GPT-5 is launched), you have to remember to re-generate these plans to take advantage of the new <span class="No-Break">model’s capabilities.</span></li>
				<li><strong class="bold">Testing</strong>: Using a planner makes testing your application a lot harder. For example, it’s possible that your kernel has so many functions and that the user requests can be so complex that the planner will exceed the context window of the model you are using. You will need to do something to handle this runtime error, such as <a id="_idIndexMarker380"/>limiting the size of the user requests or the number of functions available in your kernel. In addition, while the planner works most of the time, it’s possible that the planner will occasionally produce faulty plans, such as plans that hallucinate functions. You will need to provide error handling for that. Interestingly, in practice, the simple error-handling technique of just resubmitting the failed plan, telling the AI service that the plan didn’t work, and asking “<em class="italic">can you fix it?</em>” <span class="No-Break">usually works.</span></li>
			</ul>
			<p>With all that in mind, let’s see how to use the planner. The first step is to instantiate <span class="No-Break">a planner.</span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Instantiating a planner</h1>
			<p>Instantiating <a id="_idIndexMarker381"/>and using a planner is straightforward. In C#, we are going to use the Handlebars planner, and in Python, we will use the <span class="No-Break">Stepwise planner.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>C# includes the new <strong class="source-inline">HandlebarsPlanner</strong>, which allows you to create plans that include loops, making them shorter. Before using the Handlebars planner in C#, you need to install it with the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet add package Microsoft.SemanticKernel.Planners.Handlebars –-prerelease</pre>			<p>To configure your Handlebars planner, you will also need to install the OpenAI planner connector with <span class="No-Break">the following:</span></p>
			<pre class="console">
dotnet add package Microsoft.SemanticKernel.Planners.OpenAI --prerelease</pre>			<p>Note that the planner is experimental, and C# will give you an error unless you let it know that you are OK with using experimental code, by adding a <strong class="source-inline">pragma</strong> directive to <span class="No-Break">your code:</span></p>
			<pre class="source-code">
#pragma warning disable SKEXP0060</pre>			<p>To create <a id="_idIndexMarker382"/>a planner, we execute the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
var plannerOptions = new HandlebarsPlannerOptions()
    {
        ExecutionSettings = new OpenAIPromptExecutionSettings()
        {
            Temperature = 0.0,
            TopP = 0.1,
            MaxTokens = 4000
        },
        AllowLoops = true
    };
var planner = new HandlebarsPlanner(plannerOptions);</pre>			<p>Microsoft recommends using a low <strong class="source-inline">Temperature</strong> and <strong class="source-inline">TopP</strong> for your planners, minimizing the chance of the planner creating non-existent functions. Planners may consume lots of tokens; therefore, we usually set <strong class="source-inline">MaxTokens</strong> to a high value to avoid having a <span class="No-Break">runtime error.</span></p>
			<p>Now, let’s see how to create a planner <span class="No-Break">in Python.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>In Python, the Handlebar planner is not available yet, so we need to instantiate the Stepwise planner. Plans created by the Stepwise planner tend to be longer than Handlebars plans. To add the Stepwise planner to your Python project, you need to import the <strong class="source-inline">FunctionCallingStepwisePlanner</strong> and <strong class="source-inline">FunctionCallingStepwisePlannerOptions</strong> classes from the <span class="No-Break"><strong class="source-inline">semantic_kernel.planners</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
from semantic_kernel.planners import FunctionCallingStepwisePlanner, FunctionCallingStepwisePlannerOptions
import semantic_kernel as sk</pre>			<p>It’s usually a <a id="_idIndexMarker383"/>good idea to give planners plenty of tokens. The following is a sample command to create a planner, assuming you loaded a service with <strong class="source-inline">service_id</strong> set to <strong class="source-inline">gpt4</strong> in your <span class="No-Break">semantic kernel:</span></p>
			<pre class="source-code">
planner_options = FunctionCallingStepwisePlannerOptions(
        max_tokens=4000,
    )
planner = FunctionCallingStepwisePlanner(service_id="gpt4", options=planner_options)</pre>			<p>Now, let’s create and run a plan for a <span class="No-Break">user request.</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Creating and running a plan</h1>
			<p>Now that we have a planner, we can use it to create a plan for a user’s request and then invoke the <a id="_idIndexMarker384"/>plan to get a result. In both languages, we use two steps, one to create the plan and another one to <span class="No-Break">execute it.</span></p>
			<p>For the next <a id="_idIndexMarker385"/>two code snippets, assume you have the user’s request loaded into the <strong class="source-inline">ask</strong> string. Let’s see how to call <span class="No-Break">the planner:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
var plan = await planner.CreatePlanAsync(kernel, ask);
var result = await plan.InvokeAsync(kernel);
Console.Write ($"Results: {result}");</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
result = await planner.invoke(kernel, ask)
print(result.final_answer)</pre>			<p>You may <a id="_idIndexMarker386"/>remember from <a href="B21826_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> that in Python, the result variable <a id="_idIndexMarker387"/>contains all the steps to create the plan, so in order to see the plan’s results, you need to print <strong class="source-inline">result.final_answer</strong>. If you print the <strong class="source-inline">result</strong> variable, you’ll get a large <span class="No-Break">JSON object.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>An example of how a planner can help</h2>
			<p>Let’s see a simple example that already shows how a planner can help. Let’s say you create an <a id="_idIndexMarker388"/>application that helps aspiring comedians create jokes. You create and connect it to the <strong class="source-inline">jokes</strong> semantic plugin that we created in <a href="B21826_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. That plugin contains a semantic function that creates <span class="No-Break">knock-knock jokes.</span></p>
			<p>You can create a UI that allows users to enter a theme (say, “<em class="italic">dog</em>”) and call that function to create a knock-knock joke. If the user wants to create 100 jokes, they’ll need to use that UI 100 times. You can work around that problem by creating yet another UI that asks for the number of jokes the user wants to create. However, if the user wants to create multiple jokes for multiple themes, then they must use your two UIs for each theme they want to create a <span class="No-Break">joke for.</span></p>
			<p>Conversely, with just the semantic function and the planner, you can allow your user to describe what they want in natural language, such as <span class="No-Break">the following:</span></p>
			<p>“<em class="italic">Create four knock-knock jokes – two about dogs, one about cats, and one </em><span class="No-Break"><em class="italic">about ducks</em></span><span class="No-Break">.”</span></p>
			<p>The complete code is <span class="No-Break">as follows:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
#pragma warning disable SKEXP0060
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Planning.Handlebars;
using Microsoft.SemanticKernel.Connectors.OpenAI;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.AddOpenAIChatCompletion("gpt-4", apiKey, orgId);
var kernel = builder.Build();
var pluginsDirectory = Path.Combine(System.IO.Directory.GetCurrentDirectory(),
        "..", "..", "..", "plugins", "jokes");
kernel.ImportPluginFromPromptDirectory(pluginsDirectory);
var plannerOptions = new HandlebarsPlannerOptions()
    {
        ExecutionSettings = new OpenAIPromptExecutionSettings()
        {
            Temperature = 0.0,
            TopP = 0.1,
            MaxTokens = 4000
        },
        AllowLoops = true
    };
var planner = new HandlebarsPlanner(plannerOptions);
var ask = "Tell four knock-knock jokes: two about dogs, one about cats and one about ducks";
var plan = await planner.CreatePlanAsync(kernel, ask);
var result = await plan.InvokeAsync(kernel);
Console.Write ($"Results: {result}");</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
from semantic_kernel.planners import FunctionCallingStepwisePlanner, FunctionCallingStepwisePlannerOptions
from semantic_kernel.utils.settings import openai_settings_from_dot_env
import semantic_kernel as sk
from dotenv import load_dotenv
async def main():
    kernel = sk.Kernel()
    api_key, org_id = openai_settings_from_dot_env()
    gpt35 = OpenAIChatCompletion("gpt-3.5-turbo", api_key, org_id, service_id = "gpt35")
    gpt4 = OpenAIChatCompletion("gpt-4", api_key, org_id, service_id = "gpt4")
    kernel.add_service(gpt35)
    kernel.add_service(gpt4)
    kernel.add_plugin(None, plugin_name="jokes", parent_directory="../../plugins/")
    planner_options = FunctionCallingStepwisePlannerOptions(
        max_tokens=4000,
    )
    planner = FunctionCallingStepwisePlanner(service_id="gpt4", options=planner_options)
    prompt = "Create four knock-knock jokes: two about dogs, one about cats and one about ducks"
    result = await planner.invoke(kernel, prompt)
    print(result.final_answer)
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>In the <a id="_idIndexMarker389"/>preceding code, we created our kernel and added our jokes plugin to it. Now, let’s create <span class="No-Break">the planner.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Results</p>
			<p>You will get the following results for both Python <span class="No-Break">and C#:</span></p>
			<pre class="console">
1st Joke: Knock, knock!
Who's there?
Dog!
Dog who?
Dog who hasn't barked yet because he doesn't want to interrupt this hilarious joke!
2nd Joke: Knock, knock!
Who's there?
Dog!
Dog who?
Dog who forgot his keys, let me in!
3rd Joke: Knock, knock!
Who's there?
cat!
cat who?
Cat-ch me if you can, I'm the gingerbread man!
4th Joke: Knock, knock!
Who's there?
Duck!
Duck who?
Duck down, I'm throwing a pie!</pre>			<p>Note that with <a id="_idIndexMarker390"/>a single user request and a single call to <strong class="source-inline">invoke</strong>, Semantic Kernel generated several responses, without you having to write any loop, create any additional UIs, or chain any <span class="No-Break">functions yourself.</span></p>
			<p>Let’s see what happens behind <span class="No-Break">the scenes.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>How do planners work?</h1>
			<p>Behind the scenes, the planner uses an LLM prompt to generate a plan. As an example, you can <a id="_idIndexMarker391"/>see the prompt that is used by <strong class="source-inline">HandlebarsPlanner</strong> by navigating to its prompt file in the Semantic Kernel repository, located <span class="No-Break">at</span><span class="No-Break"> </span><a href="https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars"><span class="No-Break">https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars</span></a><span class="No-Break">.</span></p>
			<p>The last few lines of the prompt are the most important to understand how the <span class="No-Break">planner works:</span></p>
			<pre class="source-code">
## Start
Now take a deep breath and accomplish the task:
1. Keep the template short and sweet. Be as efficient as possible.
2. Do not make up helpers or functions that were not provided to you, and be especially careful to NOT assume or use any helpers or operations that were not explicitly defined already.
3. If you can't fully accomplish the goal with the available helpers, just print "{{insufficientFunctionsErrorMessage}}".
4. Always start by identifying any important values in the goal. Then, use the `\{{set}}` helper to create variables for each of these values.
5. The template should use the \{{json}} helper at least once to output the result of the final step.
6. Don't forget to use the tips and tricks otherwise the template will not work.
7. Don't close the ``` handlebars block until you're done with all the steps.</pre>			<p>The preceding steps define the set of rules that the planner uses to generate a plan <span class="No-Break">using Handlebars.</span></p>
			<p>Also, inside the <a id="_idIndexMarker392"/>prompt is what we call the <strong class="bold">function manual</strong> – that is, the instructions that the LLM will use to convert functions loaded into the kernel into text <a id="_idIndexMarker393"/>descriptions that are suitable for an <span class="No-Break">LLM prompt:</span></p>
			<pre class="source-code">
{{#each functions}}
### `{{doubleOpen}}{{PluginName}}{{../nameDelimiter}}{{Name}}{{doubleClose}}`
Description: {{Description}}
Inputs:
  {{#each Parameters}}
    - {{Name}}:
    {{~#if ParameterType}} {{ParameterType.Name}} -
    {{~else}}
        {{~#if Schema}} {{getSchemaTypeName this}} -{{/if}}
    {{~/if}}
    {{~#if Description}} {{Description}}{{/if}}
    {{~#if IsRequired}} (required){{else}} (optional){{/if}}
  {{/each}}
Output:
{{~#if ReturnParameter}}
  {{~#if ReturnParameter.ParameterType}} {{ReturnParameter.ParameterType.Name}}
  {{~else}}
    {{~#if ReturnParameter.Schema}} {{getSchemaReturnTypeName ReturnParameter}}
    {{else}} string{{/if}}
  {{~/if}}
  {{~#if ReturnParameter.Description}} - {{ReturnParameter.Description}}{{/if}}
{{/if}}
{{/each}}</pre>			<p>In summary, the planner is just a plugin that uses an AI service to translate a user request into a series of callable function steps, and then it generates the code that calls these functions, returning <span class="No-Break">the result.</span></p>
			<p>To decide <a id="_idIndexMarker394"/>which functions to call and how to call them, planners rely on the descriptions you wrote for the plugin. For native functions, the descriptions are in function decorators, while for semantic functions, they are in the <span class="No-Break"><strong class="source-inline">config.json</strong></span><span class="No-Break"> file.</span></p>
			<p>Planners will send your descriptions to an AI service as part of a prompt, with instructions that tell the AI service how to combine your descriptions into a plan. Writing good descriptions can help the AI service to create <span class="No-Break">better plans.</span></p>
			<p>Here are some things you <span class="No-Break">should do:</span></p>
			<ul>
				<li><strong class="bold">State whether inputs are required</strong>: If a function requires an input, you should state that in the input’s description by using <strong class="source-inline">required=true</strong> so that the model knows to provide an input. If you don’t do that, the created plan may not include a required parameter and will fail <span class="No-Break">when executing.</span></li>
				<li><strong class="bold">Provide examples</strong>: Your description can provide examples of how to use the function and what the acceptable inputs and outputs are. For example, if you have a function that turns lights on in a location with the description “<em class="italic">Location where the lights should be turned on</em>,” and the location must be the kitchen or the garage, you can add “<em class="italic">The location must be either ‘kitchen’ or ‘garage’</em>” to the description. With that extra description, the planner will know not to call that function if the user asks to “<em class="italic">turn everything on in </em><span class="No-Break"><em class="italic">the bedroom</em></span><span class="No-Break">.”</span></li>
			</ul>
			<p>Here are some things <span class="No-Break">to avoid:</span></p>
			<ul>
				<li><strong class="bold">Short descriptions</strong>: If your function, inputs, or output descriptions are very short, it’s possible that they are not going to convey enough information to the planner about the context where they would be used. For example, it’s better to say that the output of a function is “<em class="italic">a knock-knock joke that follows a theme</em>” <span class="No-Break">than “</span><span class="No-Break"><em class="italic">joke</em></span><span class="No-Break">.”</span></li>
				<li><strong class="bold">Very long descriptions</strong>: Remember that the descriptions will be submitted as part of a prompt that will incur costs. If your description is very long (for example, you <a id="_idIndexMarker395"/>provide three examples for every function), you will pay for it. Make sure that what you write in the descriptions is close to <span class="No-Break">what’s necessary.</span></li>
				<li><strong class="bold">Conflicting descriptions</strong>: If many of your functions have similar or the same description, the planner can get confused. For example, imagine that you create a jokes plugin that can create different types of jokes (knock-knock jokes, puns, absurdist jokes, etc.) but the description of all the functions is simply “<em class="italic">creates a joke</em>.” The planner will not know which function to call because the description tells it that all functions do the <span class="No-Break">same thing.</span></li>
			</ul>
			<p>If you are not getting the results that you expect when you use the planner, the first place you should look is in the descriptions you wrote for the functions, their inputs, and their outputs. Usually, just improving the descriptions a little helps the planner a lot. Another solution is to use a newer model. For example, if the plans are failing when you use GPT-3.5 and you already checked the descriptions, you may consider testing GPT-4 and seeing whether the results <span class="No-Break">improve substantially.</span></p>
			<p>Let’s see a <span class="No-Break">comprehensive example.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>Controlling home automation with the planner</h1>
			<p>To get a <a id="_idIndexMarker396"/>better idea of what the planner can do, we will <a id="_idIndexMarker397"/>create a home automation application. We will not actually write functions that really control home automation, but assuming those exist, we will write their wrappers as native functions. We will also add a semantic function to our kernel and incorporate it into <span class="No-Break">the planner.</span></p>
			<p>We assume that we have a house with four rooms – a garage, kitchen, living room, and bedroom. We have automations to operate our garage door, operate the lights in all rooms, open the windows in the living room and in the bedroom, and operate <span class="No-Break">the TV.</span></p>
			<p>Since our objective is to learn about Semantic Kernel and not about home automation, these functions will be very simple. We want our user to be able to say something such as “<em class="italic">turn on the lights of the bedroom</em>,” and the result will be that our native function will say “<em class="italic">bedroom lights </em><span class="No-Break"><em class="italic">turned on</em></span><span class="No-Break">.”</span></p>
			<p>The power <a id="_idIndexMarker398"/>of using the planner is shown when a <a id="_idIndexMarker399"/>user makes requests that require multiple steps, such as “<em class="italic">turn off the bedroom light and open the window</em>,” or even something more complex, such as “<em class="italic">turn off the living room lights and put on a highly rated horror movie on </em><span class="No-Break"><em class="italic">the TV</em></span><span class="No-Break">.”</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Creating the native functions</h2>
			<p>We will <a id="_idIndexMarker400"/>start by creating four native functions for home automation, one to operate the lights, one to operate the windows, one to operate the TV, and one to operate the <span class="No-Break">garage door:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using System.ComponentModel;
using Microsoft.SemanticKernel;
public class HomeAutomation
{
    [KernelFunction, Description("Turns the lights of the living room, kitchen, bedroom or garage on or off.")]
    public string OperateLight(
        [Description("Whether to turn the lights on or off. Must be either 'on' or 'off'")] string action,
        [Description("The location where the lights must be turned on or off. Must be 'living room', 'bedroom', 'kitchen' or 'garage'")] string location)
    {
        string[] validLocations = {"kitchen", "living room", "bedroom", "garage" };
        if (validLocations.Contains(location))
        {
            string exAction = $"Changed status of the {location} lights to {action}.";
            Console.WriteLine(exAction);
            return exAction;
        }
        else
        {
            string error = $"Invalid location {location} specified.";
            return error;
        }
    }</pre>			<p>The most important parts of the function are the <strong class="source-inline">Description</strong> decorators for the function <a id="_idIndexMarker401"/>itself and the parameters. They are the ones that the planner will read to learn how to use the function. Note that the descriptions specify what the valid parameters are. This helps the planner decide what to do when it receives an instruction for <span class="No-Break">all locations.</span></p>
			<p>The function just verifies that the location is valid and prints the action that the home automation would have taken if it <span class="No-Break">were real.</span></p>
			<p>The other functions simply repeat the same preceding template for their objects (the window, TV, and <span class="No-Break">garage door);</span></p>
			<pre class="source-code">
    [KernelFunction, Description("Opens or closes the windows of the living room or bedroom.")]
    public string OperateWindow(
        [Description("Whether to open or close the windows. Must be either 'open' or 'close'")] string action,
        [Description("The location where the windows are to be opened or closed. Must be either 'living room' or 'bedroom'")] string location)
    {
        string[] validLocations = {"living room", "bedroom"};
        if (validLocations.Contains(location))
        {
            string exAction = $"Changed status of the {location} windows to {action}.";
            Console.WriteLine(exAction);
            return exAction;
        }
        else
        {
            string error = $"Invalid location {location} specified.";
            return error;
        }
    }
    [KernelFunction, Description("Puts a movie on the TV in the living room or bedroom.")]
    public string OperateTV(
        [Description("The movie to play on the TV.")] string movie,
        [Description("The location where the movie should be played on. Must be 'living room' or 'bedroom'")] string location)
    {
        string[] validLocations = {"living room", "bedroom"};
        if (validLocations.Contains(location))
        {
            string exAction = $"Playing {movie} on the TV in the {location}.";
            Console.WriteLine(exAction);
            return exAction;
        }
        else
        {
            string error = $"Invalid location {location} specified.";
            return error;
        }
    }
    [KernelFunction, Description("Opens or closes the garage door.")]
    public string OperateGarageDoor(
        [Description("The action to perform on the garage door. Must be either 'open' or 'close'")] string action)
    {
        string exAction = $"Changed status of the garage door to {action}.";
        Console.WriteLine(exAction);
        return exAction;
    }
}</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
from typing_extensions import Annotated
from semantic_kernel.functions.kernel_function_decorator import kernel_function
class HomeAutomation:
    def __init__(self):
        pass
    @kernel_function(
        description="Opens or closes the windows of the living room or bedroom.",
        name="OperateWindow",
    )
    def OperateWindow(self,
            location: Annotated[str, "The location where the windows are to be opened or closed. Must be either 'living room' or 'bedroom'"],
            action: Annotated[str, "Whether to open or close the windows. Must be either 'open' or 'close'"]) \
                -&gt; Annotated[str, "The action that was performed on the windows."]:
        if location in ["living room", "bedroom"]:
            action = f"Changed status of the {location} windows to {action}."
            print(action)
            return action
        else:
            error = f"Invalid location {location} specified."
            return error</pre>			<p>The preceding function is straightforward, checking that the location passed as a parameter <a id="_idIndexMarker402"/>is valid and printing what the automation would <span class="No-Break">have done.</span></p>
			<p>The most important parts of the function are the descriptions for inside the <strong class="source-inline">kernel_function</strong> and for each of the <strong class="source-inline">Annotated</strong> parameters, as the descriptions are what the planner will use to decide what <span class="No-Break">to do.</span></p>
			<p>Note that the descriptions specify what the valid parameters are. This helps the planner decide what to do when it receives a request to perform an action for <span class="No-Break">all locations.</span></p>
			<p>Now, let’s create the other functions, following a <span class="No-Break">similar structure:</span></p>
			<pre class="source-code">
    @kernel_function(
        description="Turns the lights of the living room, kitchen, bedroom or garage on or off.",
        name="OperateLight",
    )
    def OperateLight(self,
            location: Annotated[str, "The location where the lights are to be turned on or off. Must be either 'living room', 'kitchen', 'bedroom' or 'garage'"],
            action: Annotated[str, "Whether to turn the lights on or off. Must be either 'on' or 'off'"])\
                -&gt; Annotated[str, "The action that was performed on the lights."]:
        if location in ["kitchen", "living room", "bedroom", "garage"]:
            action = f"Changed status of the {location} lights to {action}."
            print(action)
            return action
        else:
            error = f"Invalid location {location} specified."
            return error
    @kernel_function(
        description="Puts a movie on the TV in the living room or bedroom.",
        name="OperateTV",
    )
    def OperateTV(self,
            movie: Annotated[str, "The movie to play on the TV."],
            location: Annotated[str, "The location where the movie should be played on. Must be 'living room' or 'bedroom'"]
            )\
                -&gt; Annotated[str, "The action that was performed on the TV."]:
        if location in ["living room", "bedroom"]:
            action = f"Playing {movie} on the TV in the {location}."
            print(action)
            return action
        else:
            error = f"Invalid location {location} specified."
            return error
    @kernel_function(
        description="Opens or closes the garage door.",
        name="OperateGarageDoor"
    )
    def OperateGarageDoor(self,
            action: Annotated[str, "The action to perform on the garage door. Must be either 'open' or 'close'"])\
                  -&gt; Annotated[str, "The action that was performed on the garage door."]:
        action = f"Changed the status of the garage door to {action}."
        print(action)
        return action</pre>			<p>Now <a id="_idIndexMarker403"/>that we’re done with native functions, let’s add a <span class="No-Break">semantic function.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Adding a semantic function to suggest movies</h2>
			<p>In addition to creating the preceding native functions that control different components of the house, we are also going to create a semantic function to suggest movies based on what <a id="_idIndexMarker404"/>the user requests. Semantic functions allow the user to make requests that require the use of an AI service – for example, to find the name of a movie based on a description or the name of an actor. You’ll see that planners can seamlessly combine semantic and <span class="No-Break">native functions.</span></p>
			<p>As is always the case, the semantic function is the same for both C# and Python, but we need to carefully configure the <strong class="source-inline">skprompt.txt</strong> and <strong class="source-inline">config.json</strong> files to help the planner find the function and understand how to <span class="No-Break">use it.</span></p>
			<p>We start by creating <span class="No-Break">a prompt:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt</p>
			<p>The prompt is very simple, and it simply asks for a suggestion for a movie. To make things easier for the planner, the prompt specifies that GPT should only respond with the title of the movie, as well as what to do if the user already knows the movie they want <span class="No-Break">to watch:</span></p>
			<pre class="source-code">
Given the request below, suggest exactly one movie that you think the requestor is going to like. If the request is already a movie title, just return that movie title.
Respond only with the title of the movie, nothing else.
Request:
{{ $input }}</pre>			<p>Now, let’s see the <span class="No-Break">configuration file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json</p>
			<p>Here, it’s again very important to fill in the <strong class="source-inline">description</strong> fields with as much detail as possible, as they are what the planner will use to decide which functions <span class="No-Break">to call:</span></p>
			<pre class="source-code">
 {
    "schema": 1,
    "name": "RecommendMovie",
    "type": "completion",
    "execution_settings": {
        "default": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        }
    },
    "input_variables": [
        {
            "name": "input",
            "description": "name or description of a movie that the user wants to see. ",
            "required": true
        }
    ]
}</pre>			<p>Now that <a id="_idIndexMarker405"/>all the native and semantic functions are configured, let’s call the planner and see what it <span class="No-Break">can do.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Invoking the planner</h2>
			<p>Once you <a id="_idIndexMarker406"/>load the kernel with all these functions, all you need to do is invoke the planner and pass the user request <span class="No-Break">to it.</span></p>
			<p>We are going to make four requests to <span class="No-Break">the planner:</span></p>
			<ul>
				<li><em class="italic">Turn on the lights in </em><span class="No-Break"><em class="italic">the kitchen</em></span></li>
				<li><em class="italic">Open the windows of the bedroom, turn the lights off, and put on The Shawshank Redemption on </em><span class="No-Break"><em class="italic">the TV</em></span></li>
				<li><em class="italic">Close the garage door and turn off the lights in all </em><span class="No-Break"><em class="italic">the rooms</em></span></li>
				<li><em class="italic">Turn off the lights in all rooms and play a movie in which Tom Cruise is a lawyer, in the </em><span class="No-Break"><em class="italic">living room</em></span></li>
			</ul>
			<p>Using the existing plugins, the planner will take care of everything that is needed to fulfill these requests. For example, to fulfill the last request, the planner needs to call the <strong class="source-inline">OperateLight</strong> native function for each of the four rooms and ask GPT for a recommendation of a movie in which Tom Cruise is a lawyer, which will likely be <em class="italic">A Few Good Men</em> or <em class="italic">The Firm</em>. The planner will automatically call the functions and simply provide <span class="No-Break">the results.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>The core part of the code is to create and execute the plan, using <strong class="source-inline">create_plan</strong> and <strong class="source-inline">invoke_async</strong>, and then print <span class="No-Break">the results:</span></p>
			<pre class="source-code">
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
from semantic_kernel.planning.stepwise_planner import StepwisePlanner
import semantic_kernel as sk
from HomeAutomation import HomeAutomation
from dotenv import load_dotenv
import asyncio
async def fulfill_request(planner: StepwisePlanner, request):
    print("Fulfilling request: " + request)
    variables = sk.ContextVariables()
    plan = planner.create_plan(request)
    result = await plan.invoke_async(variables)
    print(result)
    print("Request completed.\n\n")</pre>			<p>Then, in the <a id="_idIndexMarker407"/>main function, we load the native functions and the semantic function in the kernel. This will make them available to <span class="No-Break">the planner:</span></p>
			<pre class="source-code">
async def main():
    kernel = sk.Kernel()
    api_key, org_id = sk.openai_settings_from_dot_env()
    gpt4 = OpenAIChatCompletion("gpt-4", api_key, org_id)
    kernel.add_chat_service("gpt4", gpt4)
    planner = StepwisePlanner(kernel)
    kernel.import_skill(HomeAutomation())
kernel.import_semantic_skill_from_directory("../plugins/MovieRecommender", "RecommendMovie")</pre>			<p>After loading the function, we simply call <strong class="source-inline">fulfill_request</strong>, which will create and execute a plan for <span class="No-Break">each </span><span class="No-Break"><strong class="source-inline">ask</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    await fulfill_request(kernel, planner, "Turn on the lights in the kitchen")
    await fulfill_request(kernel, planner, "Open the windows of the bedroom, turn the lights off and put on Shawshank Redemption on the TV.")
    await fulfill_request(kernel, planner, "Close the garage door and turn off the lights in all rooms.")
    await fulfill_request(kernel, planner, "Turn off the lights in all rooms and play a movie in which Tom Cruise is a lawyer in the living room.")
if __name__ == "__main__":
    load_dotenv()
    asyncio.run(main())</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>We start by <a id="_idIndexMarker408"/>creating a kernel and adding all the native functions and the semantic function we created for it. This will make these functions available to <span class="No-Break">the planner:</span></p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Planning.Handlebars;
#pragma warning disable SKEXP0060
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.AddOpenAIChatCompletion("gpt-4", apiKey, orgId);
builder.Plugins.AddFromType&lt;HomeAutomation&gt;();
builder.Plugins.AddFromPromptDirectory("../../../plugins/MovieRecommender");
var kernel = builder.Build();</pre>			<p>We then create a function that receives a <strong class="source-inline">planner</strong> and an <strong class="source-inline">ask</strong>, creating and executing a plan to fulfill <span class="No-Break">that request:</span></p>
			<pre class="source-code">
void FulfillRequest(HandlebarsPlanner planner, string ask)
{
    Console.WriteLine($"Fulfilling request: {ask}");
    var plan = planner.CreatePlanAsync(kernel, ask).Result;
    var result = plan.InvokeAsync(kernel, []).Result;
    Console.WriteLine("Request complete.");
}</pre>			<p>The last step <a id="_idIndexMarker409"/>is to create the planner and call the <strong class="source-inline">FulfillRequest</strong> function we created for <span class="No-Break">each </span><span class="No-Break"><strong class="source-inline">ask</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var plannerOptions = new HandlebarsPlannerOptions()
    {
        ExecutionSettings = new OpenAIPromptExecutionSettings()
        {
            Temperature = 0.0,
            TopP = 0.1,
            MaxTokens = 4000
        },
        AllowLoops = true
    };
var planner = new HandlebarsPlanner(plannerOptions);
FulfillRequest(planner, "Turn on the lights in the kitchen");
FulfillRequest(planner, "Open the windows of the bedroom, turn the lights off and put on Shawshank Redemption on the TV.");
FulfillRequest(planner, "Close the garage door and turn off the lights in all rooms.");
FulfillRequest(planner, "Turn off the lights in all rooms and play a movie in which Tom Cruise is a lawyer in the living room.");</pre>			<p>Note that <a id="_idIndexMarker410"/>the code that uses the planner was very short. Let’s see <span class="No-Break">the results:</span></p>
			<pre class="console">
Fulfilling request: Turn on the lights in the kitchen
Changed status of the kitchen lights to on.
Request complete.
Fulfilling request: Open the windows of the bedroom, turn the lights off and put on Shawshank Redemption on the TV.
Changed status of the bedroom windows to open.
Changed status of the bedroom lights to off.
Playing Shawshank Redemption on the TV in the bedroom.
Request complete.
Fulfilling request: Close the garage door and turn off the lights in all rooms.
Changed status of the garage door to close.
Changed status of the living room lights to off.
Changed status of the bedroom lights to off.
Changed status of the kitchen lights to off.
Changed status of the garage lights to off.
Request complete.
Fulfilling request: Turn off the lights in all rooms and play a movie in which Tom Cruise is a lawyer in the living room.
Changed status of the living room lights to off.
Changed status of the bedroom lights to off.
Changed status of the kitchen lights to off.
Changed status of the garage lights to off.
Playing A Few Good Men on the TV in the living room.
Request complete.</pre>			<p>The planner executed each request flawlessly, and you didn’t have to write any code. When the user asks something such as “<em class="italic">turn off the lights in all rooms</em>,” the planner realizes that it needs to call the function for the kitchen, the bedroom, the living room, and <span class="No-Break">the garage.</span></p>
			<p>When the <a id="_idIndexMarker411"/>user asks for a movie with Tom Cruise as a lawyer, the planner realizes that it needs to call a semantic function to find the name of the movie before calling the <strong class="source-inline">OperateTV</strong> function to put the movie on the TV, again without you having to write code for <span class="No-Break">this explicitly.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Summary</h1>
			<p>In this chapter, we introduced the planner, a powerful function that allows users to execute very complex workflows with minimal effort on the developer’s part. We learned when to use the planner and what the potential issues are. We also learned how to use the planner, as well as how to write descriptions for the functions in our plugins in a way that makes it easier for the planner to combine them. We then saw a longer example of how to use the planner to let a user combine native and <span class="No-Break">semantic functions.</span></p>
			<p>In the next chapter, we will explore ways to make external data available to Semantic Kernel. Later we will pair search with external data to allow models to use large amounts of data that exceed models’ <span class="No-Break">context windows.</span></p>
		</div>
	</div>
</div>
</body></html>