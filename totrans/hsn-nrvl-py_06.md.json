["```py\n GRAVITY = 9.8 # m/s^2\n MASSCART = 1.0 # kg\n MASSPOLE = 0.5 # kg\n TOTAL_MASS = (MASSPOLE + MASSCART)\n # The distance from the center of mass of the pole to the pivot\n # (actually half the pole's length)\n LENGTH = 0.5 # m\n POLEMASS_LENGTH = (MASSPOLE * LENGTH) # kg * m\n FORCE_MAG = 10.0 # N\n FOURTHIRDS = 4.0/3.0\n # the number seconds between state updates \n TAU = 0.02 # sec\n```", "```py\n    force = -FORCE_MAG if action <= 0 else FORCE_MAG\n    cos_theta = math.cos(theta)\n    sin_theta = math.sin(theta)\n    temp = (force + POLEMASS_LENGTH * theta_dot * theta_dot * \\\n           sin_theta) / TOTAL_MASS\n    # The angular acceleration of the pole\n    theta_acc = (GRAVITY * sin_theta - cos_theta * temp) /\\ \n                  (LENGTH * (FOURTHIRDS - MASSPOLE * \\\n                   cos_theta * cos_theta / TOTAL_MASS))\n    # The linear acceleration of the cart\n    x_acc = temp - POLEMASS_LENGTH * theta_acc * \\\n            cos_theta / TOTAL_MASS\n    # Update the four state variables, using Euler's method.\n    x_ret = x + TAU * x_dot\n    x_dot_ret = x_dot + TAU * x_acc\n    theta_ret = theta + TAU * theta_dot\n    theta_dot_ret = theta_dot + TAU * theta_acc\n```", "```py\n    # -1.4 < x < 1.4\n    x = (random.random() * 4.8 - 2.4) / 2.0\n    # -0.375 < x_dot < 0.375\n    x_dot = (random.random() * 3 - 1.5) / 4.0 \n    # -0.105 < theta < 0.105\n    theta = (random.random() * 0.42 - 0.21) / 2.0\n    # -0.5 < theta_dot < 0.5\n    theta_dot = (random.random() * 4 - 2) / 4.0\n```", "```py\n    input[0] = (x + 2.4) / 4.8\n    input[1] = (x_dot + 1.5) / 3\n    input[2] = (theta + 0.21) / .42\n    input[3] = (theta_dot + 2.0) / 4.0\n```", "```py\n    # Activate the NET\n    output = net.activate(input)\n    # Make action values discrete\n    action = 0 if output[0] < 0.5 else 1\n```", "```py\n    # Apply action to the simulated cart-pole\n    x, x_dot, theta, theta_dot = do_step(action = action, \n                      x = x, x_dot = x_dot, \n                      theta = theta, theta_dot = theta_dot )\n\n    # Check for failure due constraints violation. \n    # If so, return number of steps.\n    if x < -2.4 or x > 2.4 or theta < -0.21 or theta > 0.21:\n        return steps\n```", "```py\n    steps = run_cart_pole_simulation(net, max_bal_steps)\n```", "```py\n    log_steps = math.log(steps)\n    log_max_steps = math.log(max_bal_steps)\n    # The loss value is in range [0, 1]\n    error = (log_max_steps - log_steps) / log_max_steps\n    # The fitness value is a complement of the loss value\n    fitness = 1.0 - error\n```", "```py\n[NEAT]\nfitness_criterion   = max\nfitness_threshold   = 1.0\npop_size            = 150\nreset_on_extinction = False\n```", "```py\n# node add/remove rates\nnode_add_prob    = 0.02\nnode_delete_prob = 0.02\n```", "```py\n# network parameters\nnum_hidden = 0\nnum_inputs = 4\nnum_outputs = 1\n```", "```py\n[DefaultSpeciesSet]\ncompatibility_threshold = 4.0\n\n[DefaultStagnation]\nspecies_fitness_func = max\nmax_stagnation = 15\nspecies_elitism = 2\n\n[DefaultReproduction]\nelitism = 2\nsurvival_threshold = 0.2\nmin_species_size = 8\n```", "```py\n$ conda create --name single_pole_neat python=3.5\n$ conda activate single_pole_neat\n$ pip install neat-python==0.92 \n$ conda install matplotlib\n$ conda install graphviz\n$ conda install python-graphviz\n```", "```py\ndef eval_genomes(genomes, config):\n    for genome_id, genome in genomes:\n        genome.fitness = 0.0\n        net = neat.nn.FeedForwardNetwork.create(genome, config)\n        fitness = cart.eval_fitness(net)\n        if fitness >= config.fitness_threshold:\n            # do additional steps of evaluation with random initial states\n            # to make sure that we found stable control strategy rather \n            # than special case for particular initial state\n            success_runs = evaluate_best_net(net, config, \n                                             additional_num_runs)\n            # adjust fitness\n            fitness = 1.0 - (additional_num_runs - success_runs) / \\\n                      additional_num_runs\n\n        genome.fitness = fitness\n```", "```py\nfitness = cart.eval_fitness(net)\n```", "```py\nsuccess_runs = evaluate_best_net(net, config, additional_num_runs)\nfitness = 1.0 - (additional_num_runs - success_runs) / additional_num_runs\n```", "```py\n    # Load configuration.\n    config = neat.Config(neat.DefaultGenome, \n                         neat.DefaultReproduction,\n                         neat.DefaultSpeciesSet, \n                         neat.DefaultStagnation,\n                         config_file)\n\n    # Create the population, which is the top-level object \n    # for a NEAT run.\n    p = neat.Population(config)\n```", "```py\n    # Add a stdout reporter to show progress in the terminal.\n    p.add_reporter(neat.StdOutReporter(True))\n    stats = neat.StatisticsReporter()\n    p.add_reporter(stats)\n    p.add_reporter(neat.Checkpointer(5, \n                 filename_prefix=‘out/spb-neat—checkpoint-'))\n```", "```py\n    # Run for up to N generations.\n    best_genome = p.run(eval_genomes, n=n_generations)\n\n    # Display the best genome among generations.\n    print('\\nBest genome:\\n{!s}'.format(best_genome))\n\n    # Check if the best genome is a winning Single-Pole \n    # balancing controller \n    net = neat.nn.FeedForwardNetwork.create(best_genome, config)\n    best_genome_fitness = cart.eval_fitness(net)\n    if best_genome_fitness >= config.fitness_threshold:\n        print(\"\\n\\nSUCCESS: The Single-Pole balancing controller has been found!!!\")\n    else:\n        print(\"\\n\\nFAILURE: Failed to find Single-Pole balancing controller!!!\")\n```", "```py\n$ python single_pole_experiment.py\n```", "```py\n ****** Running generation 13 ****** \n\nPopulation's average fitness: 0.26673 stdev: 0.12027\nBest fitness: 0.70923 - size: (1, 2) - species 1 - id 2003\nAverage adjusted fitness: 0.161\nMean genetic distance 1.233, standard deviation 0.518\nPopulation of 150 members in 1 species:\n ID age size fitness adj fit stag\n ==== === ==== ======= ======= ====\n 1 13 150 0.7 0.161 7\nTotal extinctions: 0\nGeneration time: 4.635 sec (0.589 average)\n```", "```py\n ****** Running generation 14 ****** \n\nPopulation's average fitness: 0.26776 stdev: 0.13359\nBest fitness: 1.00000 - size: (1, 3) - species 1 - id 2110\n\nBest individual in generation 14 meets fitness threshold - complexity: (1, 3)\n\nBest genome:\nKey: 2110\nFitness: 1.0\nNodes:\n 0 DefaultNodeGene(key=0, bias=-3.328545880116371, response=1.0, activation=sigmoid, aggregation=sum)\nConnections:\n DefaultConnectionGene(key=(-4, 0), weight=2.7587300138861037, enabled=True)\n DefaultConnectionGene(key=(-3, 0), weight=2.951449584136504, enabled=True)\n DefaultConnectionGene(key=(-1, 0), weight=0.9448711043565166, enabled=True)\n\nEvaluating the best genome in random runs\nRuns successful/expected: 100/100\nSUCCESS: The stable Single-Pole balancing controller has been found!!!\n```", "```py\nGRAVITY = -9.8 # m/s^2 - here negative as equations of motion for 2-pole system assume it to be negative\nMASS_CART = 1.0 # kg\nFORCE_MAG = 10.0 # N\n# The first pole\nMASS_POLE_1 = 1.0 # kg\nLENGTH_1 = 0.5 # m - actually half the first pole's length\n# The second pole\nMASS_POLE_2 = 0.1 # kg\nLENGTH_2 = 0.05 # m - actually half the second pole's length\n# The coefficient of friction of pivot of the pole\nMUP = 0.000002\n```", "```py\n# Find the input force direction\nforce = (action - 0.5) * FORCE_MAG * 2.0 # action has binary values\n# Calculate projections of forces for the poles\ncos_theta_1 = math.cos(theta1)\nsin_theta_1 = math.sin(theta1)\ng_sin_theta_1 = GRAVITY * sin_theta_1\ncos_theta_2 = math.cos(theta2)\nsin_theta_2 = math.sin(theta2)\ng_sin_theta_2 = GRAVITY * sin_theta_2\n# Calculate intermediate values\nml_1 = LENGTH_1 * MASS_POLE_1\nml_2 = LENGTH_2 * MASS_POLE_2\ntemp_1 = MUP * theta1_dot / ml_1\ntemp_2 = MUP * theta2_dot / ml_2\nfi_1 = (ml_1 * theta1_dot * theta1_dot * sin_theta_1) + \\\n       (0.75 * MASS_POLE_1 * cos_theta_1 * (temp_1 + g_sin_theta_1))\nfi_2 = (ml_2 * theta2_dot * theta2_dot * sin_theta_2) + \\\n       (0.75 * MASS_POLE_2 * cos_theta_2 * (temp_2 + g_sin_theta_2))\nmi_1 = MASS_POLE_1 * (1 - (0.75 * cos_theta_1 * cos_theta_1))\nmi_2 = MASS_POLE_2 * (1 - (0.75 * cos_theta_2 * cos_theta_2))\n# Calculate the results: cart acceleration and poles angular accelerations\nx_ddot = (force + fi_1 + fi_2) / (mi_1 + mi_2 + MASS_CART)\ntheta_1_ddot = -0.75 * (x_ddot * cos_theta_1 + \\\n                        g_sin_theta_1 + temp_1) / LENGTH_1\ntheta_2_ddot = -0.75 * (x_ddot * cos_theta_2 + \\\n                        g_sin_theta_2 + temp_2) / LENGTH_2\n```", "```py\nres = x < -2.4 or x > 2.4 or \\\n    theta1 < -THIRTY_SIX_DEG_IN_RAD or theta1 > THIRTY_SIX_DEG_IN_RAD or \\\n    theta2 < -THIRTY_SIX_DEG_IN_RAD or theta2 > THIRTY_SIX_DEG_IN_RAD\n```", "```py\nhh = tau / 2.0\nyt = [None] * 6\n\n# update intermediate state\nfor i in range(6):\n    yt[i] = y[i] + hh * dydx[i]\n\n# do simulation step\nx_ddot, theta_1_ddot, theta_2_ddot = calc_step(action = f, yt[0], yt[1], yt[2], yt[3], yt[4], yt[5])\n\n# store derivatives\ndyt = [yt[1], x_ddot, yt[3], theta_1_ddot, yt[5], theta_2_ddot]\n```", "```py\n# update intermediate state \nfor i in range(6):\n    yt[i] = y[i] + hh * dyt[i]\n\n# do one simulation step\nx_ddot, theta_1_ddot, theta_2_ddot = calc_step(action = f, yt[0], yt[1], yt[2], yt[3], yt[4], yt[5])\n\n# store derivatives\ndym = [yt[1], x_ddot, yt[3], theta_1_ddot, yt[5], theta_2_ddot]\n```", "```py\n# update intermediate state\nfor i in range(6):\n    yt[i] = y[i] + tau * dym[i]\n    dym[i] += dyt[i]\n\n# do one simulation step\nx_ddot, theta_1_ddot, theta_2_ddot = calc_step(action = f, yt[0], yt[1], yt[2], yt[3], yt[4], yt[5])\n\n# store derivatives\ndyt = [yt[1], x_ddot, yt[3], theta_1_ddot, yt[5], theta_2_ddot]\n```", "```py\n# find system state after approximation\nyout = [None] * 6 # the approximated system state\nh6 = tau / 6.0\nfor i in range(6):\n    yout[i] = y[i] + h6 * (dydx[i] + dyt[i] + 2.0 * dym[i])\n```", "```py\ninput[0] = (state[0] + 2.4) / 4.8\ninput[1] = (state[1] + 1.5) / 3.0\ninput[2] = (state[2] + THIRTY_SIX_DEG_IN_RAD) / (THIRTY_SIX_DEG_IN_RAD * 2.0)\ninput[3] = (state[3] + 2.0) / 4.0\ninput[4] = (state[4] + THIRTY_SIX_DEG_IN_RAD) / (THIRTY_SIX_DEG_IN_RAD * 2.0)\ninput[5] = (state[5] + 2.0) / 4.0\n```", "```py\n# First we run simulation loop returning number of successful\n# simulation steps\nsteps = cart.run_markov_simulation(net, max_bal_steps)\n\nif steps == max_bal_steps:\n    # the maximal fitness\n    return 1.0\nelif steps == 0: # needed to avoid math error when taking log(0)\n    # the minimal fitness\n    return 0.0\nelse:\n    log_steps = math.log(steps)\n    log_max_steps = math.log(max_bal_steps)\n    # The loss value is in range [0, 1]\n    error = (log_max_steps - log_steps) / log_max_steps\n    # The fitness value is a complement of the loss value\n    return 1.0 - error\n```", "```py\n[NEAT]\nfitness_criterion = max\nfitness_threshold = 1.0\npop_size = 1000\nreset_on_extinction = False\n```", "```py\n# connection add/remove rates\nconn_add_prob = 0.5\nconn_delete_prob = 0.2\n\ninitial_connection = partial_direct 0.5\n\n# node add/remove rates\nnode_add_prob = 0.2\nnode_delete_prob = 0.2\n```", "```py\n[DefaultReproduction]\nelitism = 2\nsurvival_threshold = 0.1\nmin_species_size = 2\n```", "```py\n# set random seed\nseed = 1559231616\nrandom.seed(seed)\n```", "```py\n$ conda create --name double_pole_neat python=3.5\n$ conda activate double_pole_neat\n$ pip install neat-python==0.92 \n$ conda install matplotlib\n$ conda install graphviz\n$ conda install python-graphviz\n```", "```py\n# Run the experiment\npole_length = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]\nnum_runs = len(pole_length)\nfor i in range(num_runs):\n    cart.LENGTH_2 = pole_length[i] / 2.0\n    solved = run_experiment(config_path, n_generations=100, silent=False)\n    print(\"run: %d, solved: %s, length: %f\" % \n                                         (i + 1, solved, cart.LENGTH_2))\n    if solved:\n        print(\"Solution found in: %d run, short pole length: %f\" % \n                                                 (i + 1, cart.LENGTH_2))\n    break\n```", "```py\n$ python two_pole_markov_experiment.py\n```", "```py\n ****** Running generation 97 ****** \n\nPopulation's average fitness: 0.27393 stdev: 0.10514\nBest fitness: 1.00000 - size: (1, 6) - species 26 - id 95605\n\nBest individual in generation 97 meets fitness threshold - complexity: (1, 6)\n\nBest genome:\nKey: 95605\nFitness: 1.0\nNodes:\n 0 DefaultNodeGene(key=0, bias=7.879760594997953, response=1.0, activation=sigmoid, aggregation=sum)\nConnections:\n DefaultConnectionGene(key=(-6, 0), weight=1.9934757746640883, enabled=True)\n DefaultConnectionGene(key=(-5, 0), weight=3.703109977745863, enabled=True)\n DefaultConnectionGene(key=(-4, 0), weight=-11.923951805881497, enabled=True)\n DefaultConnectionGene(key=(-3, 0), weight=-4.152166115226511, enabled=True)\n DefaultConnectionGene(key=(-2, 0), weight=-3.101569479910728, enabled=True)\n DefaultConnectionGene(key=(-1, 0), weight=-1.379602358542496, enabled=True)\n\nEvaluating the best genome in random runs\nRuns successful/expected: 1/1\nSUCCESS: The stable Double-Pole-Markov balancing controller found!!!\nRandom seed: 1559231616\nrun: 1, solved: True, half-length: 0.050000\nSolution found in: 1 run, short pole length: 0.100000\n```"]