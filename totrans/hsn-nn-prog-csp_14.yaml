- en: Finding Optimal Parameters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最优参数
- en: 'In this chapter, we will use the open source package SwarmOps, version 4.0,
    to help you better understand how you can use this tool to find optimal parameters
    for your functions. You can get the latest version of SwarmOps from the following
    location: [https://github.com/mattcolefla/SwarmOps](https://github.com/mattcolefla/SwarmOps).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用开源软件包 SwarmOps，版本 4.0，帮助您更好地理解如何使用此工具为您函数找到最优参数。您可以从以下位置获取 SwarmOps
    的最新版本：[https://github.com/mattcolefla/SwarmOps](https://github.com/mattcolefla/SwarmOps).
- en: Once again, we must spend a little time on theory, where we will take you back
    to your academic days and lay a foundation so that we are all speaking the same
    language. It should be noted that SwarmOps is a highly research-oriented tool
    and should be used as such. We have worked hard to make this product open source,
    and the latest version has over 60 different optimization functions for you to
    use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们必须花一点时间在理论上，我们将带你回到学术时代，打下基础，以便我们都使用相同的语言。需要注意的是，SwarmOps 是一个高度研究导向的工具，应如此使用。我们努力使这个产品开源，最新版本有超过
    60 种不同的优化函数供您使用。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Fitness function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应度函数
- en: Constraints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束条件
- en: Meta-optimization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元优化
- en: Optimization methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化方法
- en: Parallelism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行性
- en: Ready? Here we go!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？我们开始了！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will be required to have a basic knowledge of .NET development using Microsoft
    Visual Studio and C#. You will need to download the code for this chapter from
    the book''s website: SwarmOps ([https://github.com/mattcolefla/SwarmOps](https://github.com/mattcolefla/SwarmOps)).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要具备使用 Microsoft Visual Studio 和 C# 进行 .NET 开发的基本知识。您需要从本书的网站上下载本章的代码：SwarmOps
    ([https://github.com/mattcolefla/SwarmOps](https://github.com/mattcolefla/SwarmOps)).
- en: Check out the following video to see Code in Action: [http://bit.ly/2QPddLO](http://bit.ly/2QPddLO).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[http://bit.ly/2QPddLO](http://bit.ly/2QPddLO).
- en: Optimization
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: Solutions to some problems are not as cut and dry as *correct* or *incorrect*,
    but are rated in terms of quality. Such problems are known as **optimization problems** because
    the goal is to find the candidate solution with the best, that is, *optimal* quality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题的解决方案并不像 *正确* 或 *错误* 那样简单明了，而是根据质量进行评分。这类问题被称为 **优化问题**，因为目标是找到最佳、即 *最优*
    质量的候选解。
- en: What is a fitness function?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应度函数是什么？
- en: 'SwarmOps works for real-valued and single-objective optimization problems,
    that is, optimization problems that map candidate solutions from ![](img/27d5e4e0-0b6f-4c24-a070-c1926d03298c.png)-dimensional
    real-valued spaces to one-dimensional real-valued spaces. Mathematically speaking,
    we consider optimization problems to be functions ![](img/ff972492-0e7b-4a6b-8c36-0f7d57f0b201.png) of
    the following form:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SwarmOps 适用于实值和单目标优化问题，即从 ![](img/27d5e4e0-0b6f-4c24-a070-c1926d03298c.png)-维实值空间映射到一维实值空间的优化问题。从数学的角度讲，我们考虑优化问题为以下形式的函数
    ![](img/ff972492-0e7b-4a6b-8c36-0f7d57f0b201.png)：
- en: '![](img/f66bee59-ca43-4b53-b430-1122beddd22b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f66bee59-ca43-4b53-b430-1122beddd22b.png)'
- en: 'In SwarmOps, it is assumed that ![](img/d71ae3ff-ae43-421d-a951-cb3ba8c1300f.png) is
    a minimization problem, meaning that we are searching for the candidate solution ![](img/03c78311-96e5-484d-8851-42ab9d21e4d1.png)with
    the smallest value ![](img/51747946-9f40-4185-9253-1cddfb223c83.png). Mathematically,
    this may be written as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SwarmOps 中，假设 ![](img/d71ae3ff-ae43-421d-a951-cb3ba8c1300f.png) 是一个最小化问题，这意味着我们正在寻找具有最小值
    ![](img/03c78311-96e5-484d-8851-42ab9d21e4d1.png) 的候选解 ![](img/51747946-9f40-4185-9253-1cddfb223c83.png)。从数学上讲，这可以写成以下形式：
- en: Find ![](img/154be667-72da-4d84-8f6f-cfd2742596be.png), such that ![](img/b9292a90-ca0f-42ca-bc9f-c02828a84941.png).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 ![](img/154be667-72da-4d84-8f6f-cfd2742596be.png)，使得 ![](img/b9292a90-ca0f-42ca-bc9f-c02828a84941.png).
- en: Typically, however, it is not possible to locate the exact optimum; we must
    be satisfied with a candidate solution of sufficient quality that is perhaps not
    quite optimal. In this chapter, we refer to the optimization problem ![](img/2a5bcabc-0829-4cc1-ad19-482a4789e4b3.png) as
    the `fitness` function, but it is can also be known as the cost function, objective
    function, error function, quality measure, and so on. We may also refer to candidate
    solutions as positions, agents, or particles, and to all possible candidate solutions
    as the search-space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，我们无法找到确切的优化最佳点；我们必须满足于一个足够高质量的候选解，可能并非完全最优。在本章中，我们将优化问题![图片](img/2a5bcabc-0829-4cc1-ad19-482a4789e4b3.png)称为“适应度”函数，但它也可以被称为成本函数、目标函数、误差函数、质量度量等等。我们还可以将候选解称为位置、代理或粒子，将所有可能的候选解称为搜索空间。
- en: Maximization
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大化
- en: 'SwarmOps can also be used with maximization problems. If ![](img/be3529dc-49fc-4781-8e46-82823aeddb0b.png) is
    a maximization problem, then the equivalent minimization problem is as follows:
    ![](img/93fe06a1-e72d-413d-b9e4-2036f0e02bcc.png).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SwarmOps也可以用于最大化问题。如果![图片](img/be3529dc-49fc-4781-8e46-82823aeddb0b.png)是一个最大化问题，那么等价的最小化问题如下：![图片](img/93fe06a1-e72d-413d-b9e4-2036f0e02bcc.png)。
- en: Gradient-based optimization
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于梯度的优化
- en: 'The classic way of optimizing a fitness function ![](img/f5b3e719-abbc-4f04-a45a-8b09794acaa6.png) is
    to first deduce its gradient, that is, ![](img/cddb2fb9-9dab-4bfc-a4e3-a6bbdd529ff0.png),
    which consists of the partial differentials of ![](img/5e346118-7080-4de5-afc1-761fde7db44d.png),
    that is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 优化适应度函数![图片](img/f5b3e719-abbc-4f04-a45a-8b09794acaa6.png)的经典方法首先是推导其梯度，即![图片](img/cddb2fb9-9dab-4bfc-a4e3-a6bbdd529ff0.png)，它由![图片](img/5e346118-7080-4de5-afc1-761fde7db44d.png)的偏导数组成，即：
- en: '![](img/e951e83d-2148-426c-89ff-0a6dec619e63.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e951e83d-2148-426c-89ff-0a6dec619e63.png)'
- en: The gradient is then followed iteratively in the direction of the steepest descent;
    a quasi-Newton optimizer can also be used if necessary. This optimizer requires
    that not only for the fitness function ![](img/ddc2311e-3af9-4850-bf5d-4228aea941f6.png) be
    differentiable, but time and patience as well. This is because the gradient can
    be very laborious to derive, and the execution can be very time-consuming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后迭代地沿着最速下降方向跟踪梯度；如果需要，也可以使用准牛顿优化器。这个优化器要求不仅适应度函数![图片](img/ddc2311e-3af9-4850-bf5d-4228aea941f6.png)是可微分的，还需要时间和耐心。这是因为梯度的推导可能非常耗时，执行也可能非常耗时。
- en: Heuristic optimization
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启发式优化
- en: An alternative to gradient-based optimization methods is to let the optimization
    be guided solely by fitness values. This kind of optimization has no explicit
    knowledge of how the fitness landscape looks, but merely considers the fitness
    function to be a black box that takes candidate solutions as input and produces
    a fitness value as output. This is known in this chapter as Derivate-free optimization,
    direct search, heuristic optimization, meta-heuristics, black-box optimization,
    and so on. We will use these terms a lot!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基于梯度的优化方法的替代方案是让优化完全由适应度值引导。这种优化没有关于适应度景观外观的明确知识，而只是将适应度函数视为一个黑盒，它接受候选解作为输入并产生适应度值作为输出。在本章中，这种优化被称为无导数优化、直接搜索、启发式优化、元启发式、黑盒优化等等。我们将大量使用这些术语！
- en: Constraints
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束
- en: Constraints split the search-space into regions of feasible and infeasible candidate
    solutions. For instance, an engineering problem could have a mathematical model
    that should be optimized, but producing the solution in the real world puts some
    constraints on what is feasible. There are different ways of supporting and handling
    constraints in heuristic optimization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 约束将搜索空间分割成可行候选解和不可行候选解的区域。例如，一个工程问题可能有一个需要优化的数学模型，但在现实世界中产生解决方案可能会对可行性施加一些约束。在启发式优化中，有不同方式来支持和处理约束。
- en: Boundaries
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界
- en: 'A simple form of constraint is search-space boundaries. Instead of letting
    ![](img/4b827c98-c3b5-4f2a-a2e3-22a8f3cd3d14.png) map from the entire ![](img/19fe84b2-bee4-4df9-9731-e4c5979c7344.png)-dimensional
    real-valued space, it is often practical to use only a part of this vast search-space.
    The lower and upper boundaries that constitute the search-space are denoted as
    ![](img/fd613b81-7202-46fa-a065-f4a9e7d46c66.png) and ![](img/bc508a18-3f8e-460f-994a-a9a844344e7e.png),
    so the fitness function is of the following form:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 约束的一种简单形式是搜索空间边界。而不是让 ![img/4b827c98-c3b5-4f2a-a2e3-22a8f3cd3d14.png] 从整个 ![img/19fe84b2-bee4-4df9-9731-e4c5979c7344.png]
    维的实值空间映射，通常只使用这个庞大搜索空间的一部分是实用的。构成搜索空间的上下边界表示为 ![img/fd613b81-7202-46fa-a065-f4a9e7d46c66.png]
    和 ![img/bc508a18-3f8e-460f-994a-a9a844344e7e.png]，因此适应性函数的形式如下：
- en: '![](img/a9c3f595-e542-4b73-a111-d269ef1cfee6.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![img/a9c3f595-e542-4b73-a111-d269ef1cfee6.png]'
- en: Such boundaries are typically enforced in optimization methods by moving candidate
    solutions back to the boundary value if they have exceeded the boundaries. This
    is the default type of constraint available in SwarmOps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种边界通常通过将候选解移动回边界值来在优化方法中强制执行，如果它们已经超过了边界。这是SwarmOps中可用的默认约束类型。
- en: Penalty functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惩罚函数
- en: More complicated constraints are supported transparently by any heuristic optimizer
    by penalizing infeasible candidate solutions, that is, by adding a penalty function
    to the fitness function. Examples can be found in the penalized benchmark problems
    section of the SwarmOps source code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 任何启发式优化器通过惩罚不可行的候选解（即在适应性函数中添加惩罚函数）透明地支持更复杂的约束。示例可以在SwarmOps源代码的惩罚基准问题部分找到。
- en: General constraints
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般约束
- en: 'SwarmOps supports general constraints by taking feasibility (constraint satisfaction)
    into account when comparing candidate solutions. Normally, we determine whether
    candidate solution ![](img/b7d1afed-2b91-4ede-92ad-7d844093c95c.png) is better
    than ![](img/6815653e-4aad-427b-bc3c-42cd1411241f.png) by comparing their fitness
    with ![](img/0c872fc8-9935-4e18-bc4e-251e8c91cece.png), but it is also possible
    to take feasibility into account. Feasibility is a Boolean; either a candidate
    solution is feasible or it is infeasible. The comparison operator is as shown
    in the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SwarmOps通过在比较候选解时考虑可行性（约束满足）来支持一般约束。通常，我们通过比较它们的适应性 ![img/0c872fc8-9935-4e18-bc4e-251e8c91cece.png]
    来确定候选解 ![img/b7d1afed-2b91-4ede-92ad-7d844093c95c.png] 是否比 ![img/6815653e-4aad-427b-bc3c-42cd1411241f.png]
    更好，但也可以考虑可行性。可行性是一个布尔值；候选解要么是可行的，要么是不可行的。比较运算符如下图中所示：
- en: '![](img/06b8c937-53e5-41e6-98f1-721e4ec3c124.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![img/06b8c937-53e5-41e6-98f1-721e4ec3c124.png]'
- en: Note in the preceding diagram that the actual implementation of this comparison
    is simplified somewhat. Also note that when ![](img/0dd53fa0-41cc-4d49-bfe8-cb86d4e72111.png) is
    feasible and ![](img/606727bc-e8d5-4fcc-8c0f-e8b40205a94f.png) is infeasible,
    their fitness need not be computed. This is because ![](img/04942206-ca8b-4c51-893f-41b045d9c844.png) is
    worse than ![](img/7dd24064-e485-4ab1-a789-218fe581c80c.png) due to their mutual
    feasibility. This is used in the implementation to avoid fitness computations
    when possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前面的图中，这种比较的实际实现被简化了一些。还请注意，当 ![img/0dd53fa0-41cc-4d49-bfe8-cb86d4e72111.png]
    是可行的而 ![img/606727bc-e8d5-4fcc-8c0f-e8b40205a94f.png] 是不可行的时候，它们的适应性不需要计算。这是因为
    ![img/04942206-ca8b-4c51-893f-41b045d9c844.png] 由于它们的相互可行性而比 ![img/7dd24064-e485-4ab1-a789-218fe581c80c.png]
    更差。这在实现中用于在可能的情况下避免适应性计算。
- en: Constrained optimization phases
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束优化阶段
- en: Using the earlier comparison operator means that optimization has two phases.
    First, the optimizer will likely only find infeasible candidate solutions, so
    it optimizes the fitness of infeasible solutions. Then, at some point, the optimizer
    hopefully discovers a feasible candidate solution; regardless of its fitness,
    it will then become the best-found solution of the optimizer and will form the
    basis of the further search. This is essentially the optimization of a feasible
    solution's fitness.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用早期的比较运算符意味着优化有两个阶段。首先，优化器可能会只找到不可行的候选解，因此它优化不可行解的适应性。然后，在某个时刻，优化器希望发现一个可行的候选解；无论其适应性如何，它将成为优化器找到的最佳解，并成为进一步搜索的基础。这本质上是对可行解适应性的优化。
- en: Constrained optimization difficulties
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束优化困难
- en: While SwarmOps gives you the ability to implement any constraint imaginable,
    constraints themselves will make it increasingly difficult for the optimizer to
    find feasibly optimal solutions because constraints narrow the feasible regions
    of the search-space. You should therefore also narrow the initialization and search-space
    boundaries to be as close to the feasible region as possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SwarmOps允许你实现任何可想象的约束，但约束本身会使优化器越来越难以找到可行的最优解，因为约束缩小了搜索空间的可行区域。因此，你应该也将初始化和搜索空间边界尽可能靠近可行区域。
- en: Implementation
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'There are two methods in the `problem` class where you can implement constraints;
    they are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`problem`类中有两种方法可以用来实现约束；它们如下所示：
- en: '`EnforceConstraints()` allows you to make repairs to a candidate solution before
    its feasibility and fitness are evaluated. For example, when search-space boundaries
    are used as constraints then the repairing would consist of moving candidate solutions
    back between boundaries if they were overstepped. This is done by default.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnforceConstraints()`允许你在评估候选解的可行性和适应度之前对其进行修复。例如，当使用搜索空间边界作为约束时，修复将包括将候选解移动回边界之间，如果它们越界了。这是默认行为。'
- en: '`Feasible()` evaluates and returns the feasibility of a candidate solution
    without altering it.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Feasible()`评估并返回候选解的可行性，而不会改变它。'
- en: Meta-optimization
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元优化
- en: 'Optimization methods usually have several user-defined parameters that govern
    the behavior and efficacy of the optimization method. These are called the optimizer''s
    behavioral or control parameters. Finding a good choice of these behavioral parameters
    has previously been done manually by hand-tuning, and sometimes even by using
    coarse mathematical analysis. It has also become a common belief among researchers
    that behavioral parameters can be adapted during optimization to improve overall
    optimization performance; however, this has been demonstrated to be mostly unlikely.
    Tuning behavioral parameters can be considered an optimization problem and hence
    can be solved by an overlaid optimization method. This is known here as meta-optimization,
    but is also known in the chapter as meta-evolution, super-optimization, parameter
    calibration, and so on. The success of SwarmOps when doing meta-optimization relies
    mainly on the following three factors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 优化方法通常有几个用户定义的参数，这些参数控制着优化方法的行为和有效性。这些被称为优化器的行为参数或控制参数。寻找这些行为参数的良好选择以前是通过手动调整完成的，有时甚至通过粗略的数学分析。研究人员中普遍认为，行为参数可以在优化过程中进行调整以改善整体优化性能；然而，这已被证明大部分情况下不太可能。调整行为参数可以被视为一个优化问题，因此可以通过叠加优化方法来解决。在这里，这被称为元优化，但在本章中也被称为元进化、超级优化、参数校准等等。SwarmOps在元优化中的成功主要依赖于以下三个因素：
- en: SwarmOps features an optimization method that is particularly suitable as the
    overlaid meta-optimizer because it quickly discovers well-performing behavioral
    parameters (this is the LUS method described in this chapter).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SwarmOps具有一种特别适合作为叠加元优化器的优化方法，因为它能快速发现表现良好的行为参数（这是本章中描述的LUS方法）。
- en: SwarmOps employs a simple technique for reducing computational time called pre-emptive
    fitness evaluation.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SwarmOps采用一种简单的技术来减少计算时间，称为抢占性适应度评估。
- en: 'SwarmOps uses the same function-interface for both optimization problems and
    optimization methods. Several scientific publications use SwarmOps for meta-optimization
    and have more elaborate descriptions than those given here, as well as having
    literature surveys and experimental results. The concept of meta-optimization
    can be illustrated schematically as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SwarmOps使用相同的函数接口来处理优化问题和优化方法。有几篇科学出版物使用了SwarmOps进行元优化，并且比这里给出的描述更为详细，包括文献综述和实验结果。元优化的概念可以用以下示意图来表示：
- en: '![](img/728cfbba-e247-40f4-949f-9c6f2ca0b3fe.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/728cfbba-e247-40f4-949f-9c6f2ca0b3fe.png)'
- en: In the preceding diagram, the optimizer whose behavioral parameters are to be
    tuned is taken to the DE method, which we will look at later on in this chapter.
    The SwarmOps framework allows for parameters to be tuned regarding multiple optimization
    problems, which is sometimes necessary to make the performance of the behavioral
    parameters respond better to more general problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，将要调整行为参数的优化器被带到DE方法中，我们将在本章后面讨论。SwarmOps框架允许针对多个优化问题调整参数，这在某些情况下是必要的，以便使行为参数的性能更好地响应更一般的问题。
- en: In the preceding example, the DE parameters are tuned for two specific problems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，DE参数针对两个特定问题进行了调整。
- en: Fitness normalization
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应度归一化
- en: Fitness functions must be non-negative to work properly with meta-optimization
    in SwarmOps. This is because pre-emptive fitness evaluation works by summing fitness
    values for several optimization runs and aborting the summation when the fitness
    sum becomes worse than that needed for the new candidate solution to be considered
    an improvement. This means that fitness values must be non-negative, so the fitness
    sum is only able to grow worse and the evaluation can thus be aborted safely.
    SwarmOps for C# does this normalization automatically, provided you accurately
    implement the **MinFitness** field of the `problem` class. For example, you may
    have a fitness function ![](img/e06c6075-b237-4bd1-9991-78e53f0daf3f.png) which
    maps to, for example, ![](img/6395813e-55ae-4fe8-8fad-868fc3b68984.png). In this
    case, you would have to set **MinFitness** to ![](img/c1279116-97cc-4e9c-b33d-18fd0264cc45.png).
    It is best to make **MinFitness** accurate so that ![](img/b5f6c6b2-1db6-4603-b18f-d789f786eadc.png) for
    the optimum ![](img/4c08bc18-d933-418f-bcfe-9e672b621b2d.png), that is, **MinFitness**
    should be the fitness of the optimum. You should be able to estimate a lower fitness
    boundary for most real-world problems, and if you are unsure what the theoretical
    boundary value is, you may choose some boundary fitness value of ample—but not
    extreme—magnitude.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在SwarmOps中与元优化正常工作，适应度函数必须是非负的。这是因为预防性适应度评估是通过累加多次优化运行的适应度值来工作的，当适应度总和变得比考虑新候选解决方案作为改进所需的适应度总和更差时，就终止累加。这意味着适应度值必须是非负的，因此适应度总和只能变得更差，从而可以安全地终止评估。SwarmOps
    for C#会自动进行这种归一化，前提是你准确实现了`problem`类的**MinFitness**字段。例如，你可能有一个适应度函数![img/e06c6075-b237-4bd1-9991-78e53f0daf3f.png]，它映射到，例如，![img/6395813e-55ae-4fe8-8fad-868fc3b68984.png]。在这种情况下，你必须将**MinFitness**设置为![img/c1279116-97cc-4e9c-b33d-18fd0264cc45.png]。最好使**MinFitness**准确，以便![img/b5f6c6b2-1db6-4603-b18f-d789f786eadc.png]对于最优解![img/4c08bc18-d933-418f-bcfe-9e672b621b2d.png]，也就是说，**MinFitness**应该是最优解的适应度。你应该能够估计大多数现实世界问题的较低适应度边界，如果你不确定理论边界值是多少，你可以选择一些充足但不过分的边界适应度值。
- en: Fitness weights for multiple problems
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个问题的适应度权重
- en: If you are using multiple problems in meta-optimization, you may need to experiment
    with weights on each problem to make their influence on the meta-optimization
    process more equal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在元优化中使用多个问题，你可能需要针对每个问题进行权重实验，以使它们对元优化过程的影响更加均衡。
- en: Advice
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议
- en: The `LUS` method is generally recommended as the overlaid meta-optimizer. The
    tutorial source code contains suggestions for experimental settings that have
    been found to work well. It is best if you perform meta-optimization regarding
    the problems you are ultimately going to use the optimization method for. However,
    if your fitness function is very expensive to evaluate, then you may try and resort
    to using benchmark problems as a temporary replacement when meta-optimizing the
    behavioral parameters of your optimizer—provided you use multiple benchmark problems
    and the optimization settings are the same as those used in a real-world application.
    In other words, you should use benchmark problems of similar dimensionality and
    with a similar number of optimization iterations to what you would use for the
    actual problem you will ultimately optimize.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常推荐使用`LUS`方法作为叠加的元优化器。教程源代码包含了一些实验设置的建议，这些设置已被证明效果良好。最好你在针对你最终将使用优化方法的实际问题进行元优化。然而，如果你的适应度函数评估成本非常高，那么在元优化你的优化器的行为参数时，你可以尝试使用基准问题作为临时的替代——前提是你使用多个基准问题，并且优化设置与实际应用中使用的设置相同。换句话说，你应该使用与实际问题中使用的相似维度和优化迭代次数的基准问题。
- en: Constraints and meta-optimization
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束和元优化
- en: 'Two issues regarding constraints in meta-optimization should be mentioned;
    they are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在元优化中关于约束的两个问题应该被提及；它们如下：
- en: Constraints can be made on an optimizer's control parameters in the same manner
    as for an optimization problem by implementing the `EnforceConstraints()` and
    `Feasible()` methods in the optimizer's class. This means the meta-optimizer will
    search for control parameters that are feasibly optimal, allowing you to search
    for control parameters that meet certain criteria; for example, they have certain
    relationships with each other, such as one parameter being smaller than the other,
    and so on. See the source code of the MOL optimizer for an example of this.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过在优化器的类中实现`EnforceConstraints()`和`Feasible()`方法，以与优化问题相同的方式对优化器的控制参数施加约束。这意味着元优化器将搜索可行最优的控制参数，允许你搜索满足某些标准（例如，它们之间存在某种关系，如一个参数比另一个小等）的控制参数；例如，MOL优化器的源代码就是这样一个例子。
- en: Constraint satisfaction is ignored when determining how well an optimizer performs
    in making up the meta-fitness measure. This is an open research topic, but experiments
    suggest that an optimizer's control parameters should be meta-optimized for unconstrained
    problems. This will also yield good performance on constrained problems.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在确定优化器在构建元适应度度量方面的表现如何时，会忽略约束满足情况。这是一个开放的研究课题，但实验表明，优化器的控制参数应该为无约束问题进行元优化。这也会在约束问题上有良好的性能。
- en: Meta-meta-optimization
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元元优化
- en: When using meta-optimization to find the best performing parameters of an optimizer,
    one may naturally wonder what the best performing parameters for the meta-optimizer
    itself are. It makes good sense to find the best meta-optimizer if one is going
    to use it often. The best parameters for the meta-optimizer can be found by employing
    yet another layer of optimization, which may be termed meta-meta-optimization.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用元优化来寻找优化器的最佳性能参数时，人们自然会想知道元优化器本身的最佳性能参数是什么。如果经常使用它，找到最佳的元优化器是有意义的。元优化器的最佳参数可以通过采用另一层优化来找到，这可以被称为元元优化。
- en: Optimization methods
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化方法
- en: This section will give you a brief description of the optimization methods that
    are supplied with SwarmOps and some recommendations for their use.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要介绍SwarmOps提供的优化方法，以及一些使用建议。
- en: Choosing an optimizer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择优化器
- en: When faced with a new optimization problem, the first optimizer you may want
    to try is the `PS` method, which is often sufficient and has the advantage of
    converging (or stagnating) very quickly. In addition, `PS` does not have any behavioral
    parameters that need tuning, so it either works or it doesn't. If the `PS` method
    fails at optimizing your problem, you may want to try the `LUS` method. You may
    need to run both `PS` and `LUS` several times as they may converge to sub-optimal
    solutions. If `PS` and `LUS` both fail, you may try the `DE`, `MOL`, or `PSO`
    methods and experiment with their behavioral parameters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 面对一个新优化问题时，你可能首先想尝试的是`PS`方法，这通常足够并且具有快速收敛（或停滞）的优势。此外，`PS`没有需要调整的行为参数，所以它要么有效，要么无效。如果`PS`方法在优化你的问题时失败，你可能想尝试`LUS`方法。你可能需要多次运行`PS`和`LUS`，因为它们可能会收敛到次优解。如果`PS`和`LUS`都失败了，你可能想尝试`DE`、`MOL`或`PSO`方法，并实验它们的行为参数。
- en: As a rule of thumb, the `PS` and `LUS` methods stagnate rather quickly, say,
    after ![](img/9467ab0f-45fe-4278-bd10-7cfb6072cdae.png) iterations, where ![](img/47a20a43-ff5e-4135-9011-d2742eb4ef34.png) is
    the dimensionality of the search-space. On the other hand, the `DE`, `MOL`, and
    `PSO` methods require substantially more iterations, say, ![](img/b449793d-94f2-4c94-baea-87d7a69b9c6b.png) or
    ![](img/a0a7fe71-44bf-4320-b818-da90e75e0091.png), and sometimes even more than
    that.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`PS`和`LUS`方法很快就会停滞，比如说在![](img/9467ab0f-45fe-4278-bd10-7cfb6072cdae.png)次迭代后，其中![](img/47a20a43-ff5e-4135-9011-d2742eb4ef34.png)是搜索空间的维度。另一方面，`DE`、`MOL`和`PSO`方法需要更多的迭代，比如说![](img/b449793d-94f2-4c94-baea-87d7a69b9c6b.png)或![](img/a0a7fe71-44bf-4320-b818-da90e75e0091.png)，有时甚至更多。
- en: If these optimizers fail, you either need to tune their behavioral parameters
    using meta-optimization or use another optimizer altogether.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些优化器失败，你可能需要使用元优化来调整它们的行为参数，或者完全使用另一个优化器。
- en: Gradient descent (GD)
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 梯度下降（GD）
- en: 'A classic way of minimizing a fitness function (![](img/94019cf0-3050-4743-9987-820903b35c25.png)) is
    to repeatedly follow the gradient in the direction of steepest descent. The gradient
    function ![](img/6097ce3d-ecec-44d0-88ad-d1a08f6e8028.png) is defined as the vector
    of the partial differentials of ![](img/91947301-c391-4a50-b1b1-d3b790d461f8.png),
    which is denoted as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化适应度函数 (![适应度函数图片](img/94019cf0-3050-4743-9987-820903b35c25.png)) 的经典方法是在最速下降方向上反复跟随梯度。梯度函数
    ![梯度函数图片](img/6097ce3d-ecec-44d0-88ad-d1a08f6e8028.png) 定义为 ![偏导数图片](img/91947301-c391-4a50-b1b1-d3b790d461f8.png)
    的偏导数向量，表示如下：
- en: '![](img/1d146b75-a3cf-410f-98ef-707dab8373d4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![LUS图片](img/1d146b75-a3cf-410f-98ef-707dab8373d4.png)'
- en: How it works
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The position ![](img/a4e702b4-42d1-441f-bb95-a84afbda5653.png) is first chosen
    randomly from the search-space and then updated iteratively according to the following
    formula, regardless of fitness improvement:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 位置 ![位置图片](img/a4e702b4-42d1-441f-bb95-a84afbda5653.png) 首先从搜索空间中随机选择，然后根据以下公式迭代更新，无论是否改善适应度：
- en: '![](img/1f01f96e-a274-489c-90ad-2b3f1e17f5d8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![模式搜索图片](img/1f01f96e-a274-489c-90ad-2b3f1e17f5d8.png)'
- en: As shown in the preceding formula, ![](img/93217723-328b-470a-8e96-76d9ecc19067.png) is
    the step-size. When ![](img/4425b020-40c2-4b94-b042-ffca9b82ce33.png) is a minimization
    problem, the descent direction is followed, that is, we subtract the gradient
    from the current position instead of adding it—as we would have done for ascending
    a maximization problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前公式所示，![步长图片](img/93217723-328b-470a-8e96-76d9ecc19067.png) 是步长。当 ![最小化问题图片](img/4425b020-40c2-4b94-b042-ffca9b82ce33.png)
    是一个最小化问题时，遵循下降方向，即我们从当前位置减去梯度，而不是像最大化问题那样添加它。
- en: Drawbacks
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: The `GD` method has some drawbacks, namely that it requires the gradient ![](img/a272cd38-a583-4582-9587-029852000720.png) to
    be defined. The gradient may also be expensive to compute, and `GD` may approach
    the optimum too slowly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`GD` 方法有一些缺点，即它需要定义梯度 ![梯度图片](img/a272cd38-a583-4582-9587-029852000720.png)。梯度可能也难以计算，并且
    `GD` 可能太慢地接近最优解。'
- en: Pattern Search (PS)
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式搜索（PS）
- en: The optimization method known as **Pattern Search** (**PS**) was originally
    by Fermi and Metropolis, as described in [6], and is a similar method used by
    Hooke and Jeeves [7]. The implementation presented here is the variant from [4].
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 优化方法称为 **模式搜索** (**PS**)，最初由 Fermi 和 Metropolis 提出，如 [6] 中所述，与 Hooke 和 Jeeves
    [7] 使用的方法类似。这里提出的是 [4] 中的变体。
- en: How it works
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: '`PS` uses one agent or position in the search-space that is being moved around.
    Let the position be denoted as ![](img/1c97efff-4502-4505-a525-9ef682e9cf8c.png),
    which is initially picked at random from the entire search-space. The initial
    sampling range is the entire search-space: ![](img/97452731-07d3-4a41-be58-f9e5253e99b4.png).
    The potential new position is denoted as ![](img/383a60a2-670d-4ea2-8a1d-3085a8cbdf0a.png) and
    is sampled as follows.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`PS` 使用一个代理或搜索空间中的位置，该位置正在移动。令位置表示为 ![位置表示图片](img/1c97efff-4502-4505-a525-9ef682e9cf8c.png)，它最初从整个搜索空间中随机选择。初始采样范围是整个搜索空间：![初始采样图片](img/97452731-07d3-4a41-be58-f9e5253e99b4.png)。新的潜在位置表示为
    ![潜在位置图片](img/383a60a2-670d-4ea2-8a1d-3085a8cbdf0a.png) 并按以下方式采样。'
- en: First, pick an index (![](img/1f82aee5-8112-4944-bac9-1ae0cbe6ee1e.png)) at
    random and let ![](img/30e356f6-bda7-42da-84bb-84956944d5ae.png) and ![](img/a629f2c3-776e-4e6c-98a4-0c6093e7f4bf.png) for
    all ![](img/b04cd7cf-0359-4a25-8dae-87061030f16a.png). If ![](img/f2ba7f3f-82db-476d-a385-cca9ae94133e.png) improves
    on the fitness of ![](img/3b3a310c-23de-49fe-8f2d-824b19f06300.png) then move
    to ![](img/9a444349-8dc2-4be1-afc1-15b5c7eb9d11.png). Otherwise, halve and reverse
    the sampling range for the ![](img/75aab672-6214-4521-95a8-92e4894092ff.png) dimension
    with ![](img/3e7a1210-2df4-4af2-ae36-e8886b578f52.png). Repeat this several times.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，随机选择一个索引 ![索引图片](img/1f82aee5-8112-4944-bac9-1ae0cbe6ee1e.png)，并让 ![随机选择图片](img/30e356f6-bda7-42da-84bb-84956944d5ae.png)
    和 ![更新图片](img/a629f2c3-776e-4e6c-98a4-0c6093e7f4bf.png) 对所有 ![所有图片](img/b04cd7cf-0359-4a25-8dae-87061030f16a.png)。如果
    ![改进图片](img/f2ba7f3f-82db-476d-a385-cca9ae94133e.png) 改善了 ![适应度图片](img/3b3a310c-23de-49fe-8f2d-824b19f06300.png)
    的适应度，则移动到 ![移动图片](img/9a444349-8dc2-4be1-afc1-15b5c7eb9d11.png)。否则，将 ![维度图片](img/75aab672-6214-4521-95a8-92e4894092ff.png)
    的采样范围减半并反转，使用 ![反转图片](img/3e7a1210-2df4-4af2-ae36-e8886b578f52.png)。重复此操作几次。
- en: Local Unimodal Sampling (LUS)
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部单峰采样（LUS）
- en: The LUS optimization method performs local sampling by moving a single agent
    around the search-space to decrease the sampling range during optimization. The
    `LUS` method was presented in [4] [8].
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: LUS 优化方法通过在搜索空间中移动单个代理进行局部采样，以在优化过程中减少采样范围。`LUS` 方法在 [4] [8] 中提出。
- en: How it works
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The agent''s current position is denoted as ![](img/3a07dd2f-9346-48e2-aa18-8b07f1c4c4c4.png) and
    is initially picked at random from the entire search-space. The potential new
    position is denoted as ![](img/b60d3ad7-a646-4019-800c-d326b0a99c87.png) and is
    sampled from the neighborhood of ![](img/11ba00fb-61bf-4c7c-a242-8ea43cca6fbf.png) by
    letting ![](img/adb1fcb8-215c-4c9a-8398-9967987c6665.png), where ![](img/44b6af3f-efba-4a88-9092-635930f642b0.png) is
    a random vector picked uniformly from the range ![](img/f6d7b8de-7c30-490c-82e0-fcf9ee1faaa6.png),
    which is initially ![](img/f72307cb-493c-4fa1-97fe-4d16e53a2e6a.png). In other
    words, the full range of the entire search-space is defined by its upper boundaries, ![](img/e9850d5a-6c90-4d4a-ace5-f9ea998266c1.png), and
    its lower boundaries, ![](img/e4df128a-35c5-4686-83be-90ce4e6573b4.png). `LUS`
    moves from position ![](img/48b50b61-ffce-4b26-b429-e92ef7bb129a.png) to position
    ![](img/703decc9-3c80-4ccb-91d7-dae8b3ceff5f.png) in the event of any improvement
    in the fitness. Upon each failure for ![](img/44ccd04b-5c5e-4684-8ba7-aae3fe01ab0f.png) to
    improve on the fitness of ![](img/fd3d5809-f440-46e1-9203-1826d1aa23b2.png), the
    sampling range is decreased by multiplication with a factor of ![](img/b654a3b2-a26e-40b6-b22b-ede4bdbc8741.png),
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的当前位置表示为！[图片](img/3a07dd2f-9346-48e2-aa18-8b07f1c4c4c4.png)，最初是从整个搜索空间中随机选择的。潜在的新的位置表示为！[图片](img/b60d3ad7-a646-4019-800c-d326b0a99c87.png)，通过让！[图片](img/adb1fcb8-215c-4c9a-8398-9967987c6665.png)从！[图片](img/11ba00fb-61bf-4c7c-a242-8ea43cca6fbf.png)的邻域中采样，其中！[图片](img/44b6af3f-efba-4a88-9092-635930f642b0.png)是从范围！[图片](img/f6d7b8de-7c30-490c-82e0-fcf9ee1faaa6.png)中均匀选择的随机向量，该范围最初为！[图片](img/f72307cb-493c-4fa1-97fe-4d16e53a2e6a.png)。换句话说，整个搜索空间的完整范围由其上边界！[图片](img/e9850d5a-6c90-4d4a-ace5-f9ea998266c1.png)和下边界！[图片](img/e4df128a-35c5-4686-83be-90ce4e6573b4.png)定义。`LUS`在任何改进适应度的情况下，从位置！[图片](img/48b50b61-ffce-4b26-b429-e92ef7bb129a.png)移动到位置！[图片](img/703decc9-3c80-4ccb-91d7-dae8b3ceff5f.png]。当！[图片](img/44ccd04b-5c5e-4684-8ba7-aae3fe01ab0f.png)未能改进！[图片](img/fd3d5809-f440-46e1-9203-1826d1aa23b2.png)的适应度时，采样范围通过乘以一个因子！[图片](img/b654a3b2-a26e-40b6-b22b-ede4bdbc8741.png)减少，如下所示：
- en: '![](img/83931e90-c652-4733-804c-0ac21eb7fd09.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83931e90-c652-4733-804c-0ac21eb7fd09.png)'
- en: 'Here, the decrease factor ![](img/c3aede74-9165-4ab2-9e02-3d275b9b7276.png) is
    then defined as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，减少因子！[图片](img/c3aede74-9165-4ab2-9e02-3d275b9b7276.png)定义为以下：
- en: '![](img/b05528ec-893c-422a-88e2-0ac036b8e206.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b05528ec-893c-422a-88e2-0ac036b8e206.png)'
- en: The preceding formula denotes ![](img/2ca25f34-c60d-46ab-9506-6dd0085e3443.png) as
    the dimensionality of the search-space and ![](img/e8595bdc-ea0d-4e6c-a28e-34893412347d.png) as
    a user-defined parameter used to adjust the rate of sampling-range decrease. A
    value of ![](img/77cb6838-49db-4845-8b94-de4dd8e6926d.png) has been found to work
    well for many optimization problems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的公式表示！[图片](img/2ca25f34-c60d-46ab-9506-6dd0085e3443.png)为搜索空间的维度，！[图片](img/e8595bdc-ea0d-4e6c-a28e-34893412347d.png)为一个用户定义的参数，用于调整采样范围减少的速率。研究发现，！[图片](img/77cb6838-49db-4845-8b94-de4dd8e6926d.png)的值对于许多优化问题都表现良好。
- en: Differential Evolution (DE)
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 差分进化 (DE)
- en: The multi-agent optimization method known as **Differential Evolution** (DE)
    was originally devised by Storn and Price [9]. Many DE variants exist and a simple
    one is implemented in the DE class. Several different DE variants are available
    through the DE Suite and JDE classes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 知名的多代理优化方法**差分进化**（DE）最初由Storn和Price [9] 设计。存在许多DE变体，其中简单的一个在DE类中实现。通过DE Suite和JDE类提供了几种不同的DE变体。
- en: How it works
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: '`DE` uses a population of agents. Let ![](img/84c40d14-17d8-4b04-8b86-6b56739a2e33.png) denote
    the position of an agent being updated and which has been picked at random from
    the entire population. Let ![](img/c48c1a1d-9f92-4b3b-ba0e-69da34ad03fa.png) be
    its new potential position computed as follows (this is the so-called **DE/rand/1/bin
    variant**):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`DE`使用一组代理。令！[图片](img/84c40d14-17d8-4b04-8b86-6b56739a2e33.png)表示正在更新的代理的位置，该位置是从整个种群中随机选择的。令！[图片](img/c48c1a1d-9f92-4b3b-ba0e-69da34ad03fa.png)为其新潜在位置，计算如下（这就是所谓的**DE/rand/1/bin**变体）：'
- en: '![](img/6812e471-12ab-4405-98c7-e78ee13f3c5f.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6812e471-12ab-4405-98c7-e78ee13f3c5f.png)'
- en: Here, the vectors ![](img/ae2baaf5-4b25-4f9f-9d02-e386675886bb.png), ![](img/f558b5bd-2d7a-4c81-96eb-ffb62f909916.png),
    and ![](img/a488252c-4041-4699-abc4-82172389fb1e.png) are the positions of distinct
    and randomly-picked agents from the population. The index ![](img/1f764f95-e451-412a-b593-6550ec827609.png) is
    randomly-picked and ![](img/aa14b88e-bc36-43e5-941f-9d007c9b0f12.png) is also
    picked randomly for each dimension, ![](img/804bffd2-51f3-4ecd-b6a9-b3830df85450.png).
    A move is made to the new position ![](img/3bd72ce6-3032-434e-9ad5-c209d3ef88d9.png) if
    it improves on the fitness of ![](img/75b48837-90f8-4865-961c-060377b7e5a8.png).
    The user-defined parameters consist of the differential weight ![](img/836c3c67-bddf-4a17-aab4-b3bceea3bee9.png),
    the crossover probability ![](img/c376bc2b-a065-4165-b678-3ced4ae106bb.png), and
    the population-size ![](img/57e01e44-1266-402d-a06f-0ddf27caddd4.png).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，向量 ![](img/ae2baaf5-4b25-4f9f-9d02-e386675886bb.png)、![](img/f558b5bd-2d7a-4c81-96eb-ffb62f909916.png)
    和 ![](img/a488252c-4041-4699-abc4-82172389fb1e.png) 是从种群中随机选择的独立代理的位置。索引 ![](img/1f764f95-e451-412a-b593-6550ec827609.png)
    是随机选择的，![](img/aa14b88e-bc36-43e5-941f-9d007c9b0f12.png) 对于每个维度也是随机选择的，![](img/804bffd2-51f3-4ecd-b6a9-b3830df85450.png)。如果移动到新位置
    ![](img/3bd72ce6-3032-434e-9ad5-c209d3ef88d9.png) 可以提高 ![](img/75b48837-90f8-4865-961c-060377b7e5a8.png)
    的适应性，则进行移动。用户定义的参数包括微分权重 ![](img/836c3c67-bddf-4a17-aab4-b3bceea3bee9.png)、交叉概率
    ![](img/c376bc2b-a065-4165-b678-3ced4ae106bb.png) 和种群大小 ![](img/57e01e44-1266-402d-a06f-0ddf27caddd4.png)。
- en: Particle Swarm Optimization (PSO)
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子群优化（PSO）
- en: The optimization method known as **Particle Swarm Optimization** (**PSO**) was
    originally devised by Kennedy, Eberhart, and Shi [10] [11]. It works by having
    a swarm of candidate solutions called particles, with each particle having a velocity
    that is updated recurrently and added to the particle's current position to move
    it to a new one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为**粒子群优化**（**PSO**）的优化方法最初由Kennedy、Eberhart和Shi [10] [11] 设计。它通过拥有一群称为粒子的候选解决方案来实现，每个粒子都有一个速度，该速度会反复更新并加到粒子的当前位置上，以将其移动到新的位置。
- en: How it works
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Let ![](img/e5496bcc-ae8f-41b5-aaa1-58182c96dc4e.png) denote the current position
    of a particle from the swarm. The particle''s velocity ![](img/418d63a9-09b6-4d2c-b685-b27fa76ef6ad.png) is
    then updated as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![](img/e5496bcc-ae8f-41b5-aaa1-58182c96dc4e.png) 表示从群体中粒子的当前位置。粒子的速度 ![](img/418d63a9-09b6-4d2c-b685-b27fa76ef6ad.png)
    然后按以下方式更新：
- en: '![](img/6b429bb7-491d-4aac-a063-d2f865b17f73.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b429bb7-491d-4aac-a063-d2f865b17f73.png)'
- en: Here, the user-defined parameter ![](img/d9fc81cb-cc09-4278-862c-a4aa77557643.png) is
    called the inertia weight and the user-defined parameters ![](img/4e2c67e8-3aa3-44c5-8017-65b1661b373b.png) and
    ![](img/5999e90e-9f04-4f64-893f-e8d47324ecbe.png) are weights on the attraction
    toward the particle's own best-known position, ![](img/3f94cc2b-8fe8-4891-8569-23ea42d20bde.png),
    and the swarm's best-known position, ![](img/fd105a0a-c96b-4f8d-9f4d-8ee65e2edfec.png).
    These are also weighted by the random numbers ![](img/7236df76-a421-4502-9307-bb9b42bbb7cd.png).
    In addition to this, the user also determines the swarm-size, ![](img/1ccff208-31e0-4de6-a54d-9d1b8dac1f3d.png).
    In the SwarmOps implementation, the velocity is bounded to the full range of the
    search-space, so an agent cannot move further than one search space boundary to
    the other in a single move.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户定义的参数 ![](img/d9fc81cb-cc09-4278-862c-a4aa77557643.png) 被称为惯性权重，用户定义的参数
    ![](img/4e2c67e8-3aa3-44c5-8017-65b1661b373b.png) 和 ![](img/5999e90e-9f04-4f64-893f-e8d47324ecbe.png)
    是对粒子自身已知最佳位置 ![](img/3f94cc2b-8fe8-4891-8569-23ea42d20bde.png) 和群体已知最佳位置 ![](img/fd105a0a-c96b-4f8d-9f4d-8ee65e2edfec.png)
    的吸引力权重。这些也通过随机数 ![](img/7236df76-a421-4502-9307-bb9b42bbb7cd.png) 加权。此外，用户还确定群体大小，![](img/1ccff208-31e0-4de6-a54d-9d1b8dac1f3d.png)。在SwarmOps实现中，速度被限制在搜索空间的整个范围内，因此一个代理在一次移动中不能移动超过一个搜索空间边界到另一个边界。
- en: 'Once the agent''s velocity has been computed it is added to the agent''s position,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算了代理的速度，就将其加到代理的位置上，如下所示：
- en: '![](img/a0293a8a-57f7-4f10-8f0e-1aad6e37eb51.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0293a8a-57f7-4f10-8f0e-1aad6e37eb51.png)'
- en: Many Optimizing Liaisons (MOL)
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许多优化联络（MOL）
- en: A simplification of PSO is called **Many Optimizing Liaisons** (**MOL**) and
    was originally suggested by Kennedy [12], who called it the *Social Only* PSO.
    The name MOL is used in [5], where more thorough studies were made. MOL differs
    from PSO in that it eliminates the particle's best-known position, ![](img/91413f97-6cc3-4be2-9d50-6f384ac4cfe2.png).
    This has been found to improve performance on some problems and makes it easier
    to tune behavioral parameters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PSO的一种简化称为**许多优化联络**（**MOL**），最初由Kennedy [12]提出，他称之为*仅社交* PSO。MOL这个名字在[5]中使用，那里进行了更深入的研究。MOL与PSO的不同之处在于它消除了粒子的最佳已知位置， ![](img/91413f97-6cc3-4be2-9d50-6f384ac4cfe2.png)。这已被发现可以提高某些问题的性能，并使调整行为参数变得更容易。
- en: Mesh (MESH)
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格（MESH）
- en: Fitness can be computed at regular intervals of the search-space using the `MESH`
    method. For increasing search-space dimensionality, this incurs an exponentially
    increasing number of mesh-points to retain a similar interval size. This phenomenon
    is what is known as the Curse of Dimensionality. The `MESH` method is used as
    any other optimization method in SwarmOps is and will indeed return the mesh-point
    found to have the best fitness as its solution. The quality of this solution will
    depend on how coarse or fine the mesh is. The `MESH` method is mostly used to
    make plots of the fitness landscape for simpler optimization problems, or for
    studying how different choices of behavioral parameters influence an optimization
    method's performance, that is, how the meta-fitness landscape looks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`MESH`方法在搜索空间的常规间隔内计算适应度。对于增加搜索空间维度，这会导致网格点呈指数增长以保持相似的间隔大小。这种现象被称为维度诅咒。`MESH`方法在SwarmOps中用作任何其他优化方法，并且确实会返回找到的最佳适应度的网格点作为其解。这个解的质量将取决于网格的粗细。`MESH`方法主要用于绘制简单优化问题的适应度景观图，或研究不同的行为参数选择如何影响优化方法的表现，即元适应度景观看起来如何。
- en: The `MESH` method is not intended to be used as an optimizer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`MESH`方法不打算用作优化器。'
- en: Parallelism
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行性
- en: Computers with multiple processing units are becoming increasingly popular and
    there are different ways of using this parallelism.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个处理单元的计算机越来越受欢迎，有不同方式来利用这种并行性。
- en: Parallelizing the optimization problem
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化优化问题
- en: Some optimization problems can be parallelized internally. The advantage of
    this is that all optimization methods in SwarmOps can be used without modification.
    The disadvantage is that each optimization problem must be parallelized, and this
    process does not take advantage of the natural parallel structure of population-based
    optimizers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些优化问题可以在内部并行化。这种方法的优点是SwarmOps中的所有优化方法都可以不加修改地使用。缺点是每个优化问题都必须并行化，这个过程没有利用基于群体的优化器的自然并行结构。
- en: Parallel optimization methods
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行优化方法
- en: SwarmOps provides parallelized versions of the `DE`, `PSO`, and `MOL` methods,
    all of which merely assume that the implementation of the fitness function is
    thread-safe. These parallelized optimizers are best suited for fitness functions
    that are time-consuming to compute, otherwise the parallelization overhead cancels
    out the gain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: SwarmOps提供了`DE`、`PSO`和`MOL`方法的并行版本，这些方法仅假设适应度函数的实现是线程安全的。这些并行优化器最适合计算耗时的适应度函数，否则并行化开销会抵消收益。
- en: Necessary parameter tuning
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的参数调整
- en: Parallel optimizer variants are implemented somewhat differently from their
    sequential versions. The typical way of parallelizing a multi-agent optimizer
    is to maintain and update the population of agents on one execution thread and
    then distribute only the computation of the fitness to multiple execution threads.
    This makes it easier to synchronize access to the data. However, this also means
    the entire population must be processed before improvements can become effective
    and be used in the computation of new candidate solutions. This changes the dynamic
    behavior of the optimizer and means it requires different behavioral parameters
    to work well, which may not necessarily work as well as the optimizer's sequential
    version.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 并行优化器的实现方式与其顺序版本略有不同。并行化多智能体优化器的典型方式是在一个执行线程上维护和更新智能体群体，然后将适应度计算仅分配到多个执行线程。这使得同步访问数据变得更容易。然而，这也意味着必须处理整个群体，才能使改进变得有效并用于计算新的候选解。这改变了优化器的动态行为，意味着它需要不同的行为参数才能有效工作，这不一定像优化器的顺序版本那样有效。
- en: And finally, the code
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后，代码
- en: Assuming you have already downloaded the code we described at the beginning
    of the chapter, let's now take a look at what's happening. To start, let's open
    the `TestParallelMetaBenchmarks` project and open the `main.cs` file. This is
    the file we will be working with for the following code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经下载了本章开头描述的代码，现在让我们看看发生了什么。首先，让我们打开 `TestParallelMetaBenchmarks` 项目并打开 `main.cs`
    文件。这是我们将在以下代码中工作的文件。
- en: 'First, we need to create some very important variables which will become settings
    for the optimization layer. We have commented each so that you know what they
    are for, shown as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一些非常重要的变量，这些变量将成为优化层的设置。我们对每个变量都进行了注释，以便你知道它们的作用，如下所示：
- en: '[PRE0]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we are going to create our optimizer. There are several optimizers included
    with SwarmOps, but for our purposes we will use the MOL optimizer. **MOL** stands
    for **Many Optimizing Liaisons**, which is devised as a simplification to the
    original Particle Swarm Optimization method from Eberhart et al [1][2]. The Many
    Optimizing Liaisons method does not have any attraction to the particles' own
    best-known position, and the algorithm also randomly selects which particle to
    update instead of iterating over the entire swarm. It is similar to the Social
    Only Particle Swarm Optimization suggested by Kennedy [3] and was studied more
    thoroughly by Pedersen et al [4], who found that it can outperform the standard
    Particle Swarm Optimization approach and has more easily-tunable control parameters.
    Whew, that was a mouthful, wasn't it?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的优化器。SwarmOps 包含了几个优化器，但为了我们的目的，我们将使用 MOL 优化器。**MOL** 代表 **Many Optimizing
    Liaisons**，它是 Eberhart 等人原始粒子群优化方法的一种简化。Many Optimizing Liaisons 方法不对粒子的已知最佳位置产生吸引力，并且算法还随机选择更新哪个粒子，而不是迭代整个群体。它与
    Kennedy 提出的 Social Only Particle Swarm Optimization 类似，并由 Pedersen 等人进行了更深入的研究
    [3][4]，他们发现它可以优于标准的粒子群优化方法，并且具有更容易调整的控制参数。哇，这听起来是不是有点复杂？
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next is the problem(s) that we want to optimize. You can choose to have one
    or multiple problems solved at the same time, but it is often easier to solve
    one optimization tuning problem at a time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们想要优化的问题（s）。你可以选择同时解决一个或多个问题，但通常一次解决一个优化调整问题更容易。
- en: 'The optimizer is having its control parameters tuned to work well on the included
    problem(s), shown as follows. The numbers are the weights that signify the mutual
    importance of the problems in tuning. The higher the weight, the more important
    it is, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器正在调整其控制参数以在包含的问题（s）上良好工作，如下所示。数字表示在调整中问题之间的相互重要性。权重越高，其重要性越大，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The meta-fitness aspect consists of computing optimization performance for
    the problems we listed over several optimization runs and summing the results.
    For ease of use, we wrap the optimizer in a `MetaFitness` object which takes care
    of this for us, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 元适应度方面包括在多个优化运行中计算我们列出的问题的优化性能，并将结果相加。为了方便使用，我们用 `MetaFitness` 对象包装优化器，如下所示：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we need to create out meta-optimizer object, as shown in the following
    snippet. For this, we will use the **Local Unimodal Sampling** (**LUS**) optimizer
    originally created by Pedersen 1\. This object does local sampling with an exponential
    deduction of the sampling range. It works well for many optimization problems,
    especially when only short runs are used or allowed. It is particularly well-suited
    as the overlaying meta-optimizer when tuning parameters for another optimizer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的元优化器对象，如下面的代码片段所示。为此，我们将使用 Pedersen 原创的 **Local Unimodal Sampling**
    （**LUS**）优化器。该对象使用指数递减的采样范围进行局部采样。它适用于许多优化问题，尤其是在仅使用或允许短运行时效果很好。它特别适合作为调整另一个优化器参数时的叠加元优化器：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we will wrap the meta-optimizer in a `Statistics` object to log our
    results. We then repeat a number of meta-optimization runs using the `MetaRepeat` object,
    shown as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `Statistics` 对象包装元优化器以记录我们的结果。然后，我们使用 `MetaRepeat` 对象重复进行多次元优化运行，如下所示：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Performing meta-optimization
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行元优化
- en: 'If you look at the project, the main method in our optimizer appears to be
    a large method that performs the meta-optimization run, but instead it only takes
    the following line of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看项目，我们的优化器中的主要方法似乎是一个执行元优化运行的大方法，但事实上它只包含以下一行代码：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it! Everything else involves logging and printing results and information
    to the user.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！其余的都涉及到记录和向用户打印结果和信息。
- en: Computing fitness
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算适应度
- en: 'The next block of code that we should look at is how we calculate our solution.
    Our main loop calls our fitness function as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来应该查看的代码块是如何计算我们的解决方案的。我们的主循环如下调用我们的适应度函数：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s dive into the `Fitness` function. For ease, we have placed the entire
    function in the following snippet. We will dissect each line relative to its importance
    in the function. Our ultimate objective here is to compute the meta-fitness measure
    by passing the parameters to our optimizer. We perform optimization runs on the
    array of problem(s) until the fitness exceeds the `fitnessLimit` parameter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解`Fitness`函数。为了方便，我们将整个函数放在以下代码片段中。我们将根据其在函数中的重要性逐行分析。我们在这里的最终目标是通过对我们的优化器传递参数来计算元适应度度量。我们在问题数组上执行优化运行，直到适应度超过`fitnessLimit`参数：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s look at our code in action, as shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的代码在实际中的应用，如下面的截图所示：
- en: '![](img/d0ae8670-c850-492c-95da-bcc2b8167d02.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0ae8670-c850-492c-95da-bcc2b8167d02.png)'
- en: As you can see, the goal of the program is to output the most optimal parameters
    so that you can tune your network using the same function optimization.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序的目标是输出最优化参数，以便您可以使用相同的功能优化来调整您的网络。
- en: 'But what can you do if you have a function that is not one of those included
    in SwarmOps? Luckily, you can define a custom problem of your own and use it.
    Let''s take a look at how that''s used. First, let''s look at the `TestCustomProblem` project,
    as shown in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你有一个不在SwarmOps中包含的函数，你能做什么呢？幸运的是，你可以定义一个自己的自定义问题并使用它。让我们看看它是如何使用的。首先，让我们看看`TestCustomProblem`项目，如下面的截图所示：
- en: '![](img/ad4f4bca-c395-405a-976a-da0b20ccf2b2.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad4f4bca-c395-405a-976a-da0b20ccf2b2.png)'
- en: TestCustomProblem Project
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TestCustomProblem 项目
- en: Testing custom problems
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自定义问题
- en: Before we get into creating and testing our own custom problem, let's talk about
    a more general problem. We have already outlined what we define as a problem earlier
    in this chapter, but now is a good time to show you the code for our base object
    `Problem` before we design our own. So, let's move on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建和测试自己的自定义问题之前，让我们讨论一个更一般的问题。我们已经在本章前面概述了我们将什么定义为问题，但现在是在我们设计自己的基对象`Problem`之前展示代码的好时机。因此，让我们继续前进。
- en: Base problem
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础问题
- en: 'The following is the base class `Problem` that is used in every optimization:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在每次优化中使用的基类`Problem`：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The maximum number of optimization iterations to perform is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行优化的最大迭代次数如下：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following command checks that the solution is feasible (that it satisfies
    constraints):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令检查解决方案是否可行（即它是否满足约束）：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, the name of the optimization problem is returned with the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令返回优化问题的名称：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This includes an array with the names of the parameters, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括一个包含参数名称的数组，如下所示：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To lower the search-space boundary, use the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要降低搜索空间边界，请使用以下命令：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To increase the upper search-space boundary, use the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要增加上界搜索空间边界，请使用以下命令：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The lower initialization boundary, if different from the search-space boundary,
    is denoted as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与搜索空间边界不同，则下界初始化边界如下表示：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The upper initialization boundary, if different from the search-space boundary,
    is denoted as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与搜索空间边界不同，则上界初始化边界如下表示：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following command details the maximum (that is, the worst) fitness possible,
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令详细说明了可能的最大（即最差）适应度，如下所示：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following command details the minimum (that is, the best) fitness possible.
    This is especially important if using meta-optimization where fitness is assumed
    to be non-negative; this should be roughly equivalent among all the problems we
    meta-optimize:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令详细说明了可能的最小（即最佳）适应度。如果使用元优化且假设适应度非负，这在所有我们元优化的问题中应该是大致相当的：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The threshold for an acceptable fitness value is denoted as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可接受的适应度值的阈值如下表示：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To return the dimensionality of the problem, that is, the number of parameters
    in a candidate solution, use the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回问题的维度，即候选解中的参数数量，请使用以下命令：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following line checks if the gradient has been implemented:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行检查梯度是否已实现：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following command computes and returns fitness for the given parameters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令计算并返回给定参数的适应度：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The fitness evaluation is aborted preemptively if the fitness becomes higher
    (that is, worse) than `fitnessLimit()`, or if it is not possible for the fitness
    to improve, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适应度变得高于`fitnessLimit()`（即更差），或者无法提高适应度，则预先终止适应度评估，如下所示：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We compute and return fitness for the given parameters. The fitness evaluation
    is aborted preemptively if feasibility of the new candidate solution is the same
    as or better than that of the old candidate solution—or if the fitness becomes
    higher (that is, worse) than `fitnessLimit()` and it is not possible for the fitness
    to improve, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算并返回给定参数的适应度。如果新候选解的可行性与旧候选解相同或更好，或者如果适应度变得高于`fitnessLimit()`且无法提高适应度，则预先终止适应度评估，如下所示：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compute and return fitness for the given parameters as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式计算并返回给定参数的适应度：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Compute the gradient of the fitness-function with the following command relating
    to the computation time-complexity factor. For example, if fitness takes time
    O(n) to compute and gradient takes time O(n*n) to compute, then `return n. </returns>`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令计算适应度函数的梯度，该命令与计算时间复杂度因子相关。例如，如果适应度计算的时间复杂度为O(n)，则梯度计算的时间复杂度为O(n*n)，则`return
    n.</returns>`：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Enforce constraints and evaluate feasibility with the following command. If
    you do not wish to enforce constraints, you should make the call `Feasible()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令强制约束并评估可行性。如果您不想强制约束，应调用`Feasible()`：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By default, we bound the candidate solution to the search-space boundaries,
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们将候选解限制在搜索空间边界内，如下所示：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we know that the candidate solution is now within bounds and this is all
    that is required for feasibility, we could just return `true` here. As shown in
    the following snippet, `Feasible` is called for educational purposes, as most
    optimizers call `EnforceConstraints()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道候选解现在在范围内，而这正是可行性所需的所有内容，我们在这里可以直接返回`true`。如下所示，`Feasible`是为了教育目的而调用的，因为大多数优化器都会调用`EnforceConstraints()`。
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Evaluate feasibility (constraint satisfaction) with the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码评估可行性（约束满足）：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is called at the beginning of an optimization run:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在优化运行开始时调用的：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is called at the end of an optimization run:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在优化运行结束时调用的：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To return whether optimization is allowed to continue, use the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回是否允许优化继续，请使用以下代码：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating a custom problem
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义问题
- en: Now that we have that out of the way, let's create a custom problem based upon
    our base problem class. The code will look like the following example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这些问题，让我们基于基类创建一个自定义问题。代码将类似于以下示例。
- en: 'The following is the two-dimensional Rosenbrock problem with some example constraints;
    its optimal feasible solution seems to be as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个二维Rosenbrock问题及其示例约束；其最优可行解似乎如下所示：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, the base-class overrides the name of the optimizer, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，基类覆盖了优化器的名称，如下所示：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The dimensionality of the problem is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的维度如下所示：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the lower search-space boundary:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为下界搜索空间边界：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the upper search-space boundary:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为上界搜索空间边界：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The lower initialization boundary is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下界初始化边界如下所示：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The upper initialization boundary is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上界初始化边界如下所示：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The minimum possible fitness for this problem is worked out using the following
    line:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下行计算出此问题的可能最小适应度：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The acceptable fitness threshold is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可接受的适应度阈值如下所示：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The names of the parameters for the problem are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的参数名称如下所示：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To compute and return fitness for the given parameters, use the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算并返回给定参数的适应度，请使用以下代码：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To enforce and evaluate constraints, use the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制和评估约束，请使用以下代码：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our Custom Problem
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的定制问题
- en: 'Now, create an object of the custom problem, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个自定义问题对象，如下所示：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The optimization settings should be as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 优化设置应如下所示：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create the optimizer object as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式创建优化器对象：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The control parameters for the optimizer should be as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器的控制参数应如下所示：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Wrap the optimizer in a logger of result-statistics, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将优化器包装在结果统计日志器中，如下所示：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Wrap it again in the following repeater:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再次用以下重复器包裹：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, initialize the parallel random number generator, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，初始化并行随机数生成器，如下所示：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, set the maximum number of optimization iterations to perform with the
    following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置要执行的优化迭代次数的最大值，如下所示：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a fitness trace for tracing the progress of optimization with the following
    code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个适应度跟踪，以追踪优化的进度：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, assign the fitness trace to the optimizer as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式将适应度跟踪分配给优化器：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Perform the optimizations as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行优化：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Compute the result-statistics with the following line:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下行计算结果统计：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Output the best result, as well as result-statistics, with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码输出最佳结果以及结果统计：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we run our program, it should look like the following screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，它应该看起来像以下截图：
- en: '![](img/d844cd54-286c-4959-b6a8-14ae58f7bd46.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d844cd54-286c-4959-b6a8-14ae58f7bd46.png)'
- en: The output result of our problem
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们问题的输出结果
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use SwarmOps to help us optimize parameters
    for our function optimization. We learned how to use the built-in functions of
    SwarmOps, as well as how to define our own. In the next chapter, we will move
    on to image detection and will use the great open source package, TensorFlowSharp.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 SwarmOps 帮助我们优化函数优化的参数。我们学习了如何使用 SwarmOps 的内置函数，以及如何定义我们自己的函数。在下一章中，我们将继续学习图像检测，并使用伟大的开源包
    TensorFlowSharp。
- en: References
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: J. Kennedy and R. Eberhart. Particle swarm optimization in Proceedings of IEEE
    International Conference on Neural Networks, volume IV, pages 1942-1948, Pert,
    Australia, 1995
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J. Kennedy 和 R. Eberhart. 载于 IEEE 国际神经网络会议论文集，第 IV 卷，第 1942-1948 页，珀特，澳大利亚，1995
    年
- en: Y. Shi and R.C. Eberhart. A modified particle swarm optimizer. In Proceedings
    of the IEEE International Conference on Evolutionary Computation, pages 69-73,
    Anchorage, AK, USA, 1998.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y. Shi 和 R.C. Eberhart. 一种改进的粒子群优化器。载于 IEEE 国际进化计算会议论文集，第 69-73 页，安克雷奇，阿拉斯加，美国，1998
    年。
- en: 'J. Kennedy. The particle swarm: social adaptation of knowledge. In Proceedings
    of the IEEE International Conference on Evolutionary Computation, Indianapolis,
    USA, 1997.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J. Kennedy. 粒子群：知识的社交适应。载于 IEEE 国际进化计算会议论文集，印第安纳波利斯，美国，1997 年。
- en: M.E.H Pederson and A.J. Chipperfield. Simplified particle swarm optimization.
    Applied Soft Computing, 10, P. 618-628, 2010.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M.E.H Pederson 和 A.J. Chipperfield. 简化的粒子群优化。应用软计算，第 10 卷，第 618-628 页，2010 年。
- en: 'Simplifying Particle Swarm Optimization. Pedersen, M.E.H. and Chipperfield, A.J.
    s.l. : Applied Soft Computing, 2010, Vol. 10, pp. 618-628.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '简化粒子群优化。Pedersen, M.E.H. 和 Chipperfield, A.J. s.l. : 应用软计算，2010 年，第 10 卷，第
    618-628 页。'
- en: 'Variable metric method for minimization. Davidon, W.C. 1, s.l. : SIAM Journal
    on Optimization, 1991, Vol. 1, pp. 1-17.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最小化变量的度量方法。Davidon, W.C. 1, s.l. : SIAM 优化杂志，1991 年，第 1 卷，第 1-17 页。'
- en: '"Direct Search" solution for numerical and statistical problems. Hooke, R.
    and Jeeves, T.A. 2, s.l. : Journal of the Association for Computing Machinery
    (ACM), 1961, Vol. 8, pp. 212-229.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '“直接搜索”解决方案用于数值和统计问题。Hooke, R. 和 Jeeves, T.A. 2, s.l. : 计算机协会（ACM）杂志，1961 年，第
    8 卷，第 212-229 页。'
- en: 'Pedersen, M.E.H. and Chipperfield, A.J.Local Unimodal Sampling. s.l. : Hvass
    Laboratories, 2008\. HL0801.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Pedersen, M.E.H. 和 Chipperfield, A.J. 局部单峰采样。s.l. : Hvass 实验室，2008\. HL0801。'
- en: 'Differential evolution - a simple and efficient heuristic for global optimization
    over continuous space. Storn, R. and Price, K. s.l. : Journal of Global Optimization,
    1997, Vol. 11, pp. 341-359.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '差分进化 - 一种在连续空间上全局优化的简单而有效的方法。Storn, R. 和 Price, K. s.l. : 全球优化杂志，1997 年，第 11
    卷，第 341-359 页。'
- en: 'Particle Swarm Optimization. Kennedy, J. and Eberhart, R. Perth, Australia
    : IEEE Internation Conference on Neural Networks, 1995.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '粒子群优化。Kennedy, J. 和 Eberhart, R. 澳大利亚珀斯 : IEEE 国际神经网络会议，1995 年。'
- en: 'A Modified Particle Swarm Optimizer. Shi, Y. and Eberhart, R. Anchorage, AK,
    USA : IEEE International Conference on Evolutionary Computation, 1998.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '改进的粒子群优化器。Shi, Y. 和 Eberhart, R. 安克雷奇，阿拉斯加，美国 : IEEE 国际进化计算会议，1998 年。'
- en: 'The particle swarm: social adaptation of knowledge. Kennedy, J. Indianapolis,
    USA : Proceedings of the IEEE International Conference on Evolutionary Computation,
    1997.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '粒子群：知识的社交适应。Kennedy, J. 印第安纳波利斯，美国 : IEEE 国际进化计算会议论文集，1997 年。'
