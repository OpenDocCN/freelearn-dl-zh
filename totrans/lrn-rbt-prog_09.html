<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer127">
			<h1 id="_idParaDest-137"><em class="italic"><a id="_idTextAnchor131"/>Chapter 7</em>: Drive and Turn – Moving Motors with Python</h1>
			<p>In this chapter, we will take the robot we started building in the last chapter, connect the motors to the Raspberry Pi, and build the Python code to make them move. We will cover programming techniques to create a layer between the physical robot and its behavior code, to reduce the impact of hardware changes. Our code and build will get the robot moving! We finish by programming the robot to drive a small set path. The robot code layer will serve as a foundation for all our robot behaviors, and the set path will demonstrate how to use it.</p>
			<p>We cover the following topics in this chapter: </p>
			<ul>
				<li>Writing code to test your motors</li>
				<li>Steering a robot</li>
				<li>Making a <strong class="source-inline">Robot</strong> object—code for our experiments to talk to the robot</li>
				<li>Writing a script to follow a predetermined path</li>
			</ul>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor132"/>Technical requirements</h1>
			<p>To complete the experiments in this chapter, you will require the following:</p>
			<ul>
				<li>A computer with access to the internet</li>
				<li>The chassis built in the <a href="B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, <em class="italic">Building Robot Basics – Wheels, Power, and Wiring</em></li>
				<li>The motor controller bought in <a href="B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, <em class="italic">Building Robot Basics  – Wheels, Power, and Wiring</em></li>
				<li>A 2-meter by 2-meter flat space for the robot to drive on<p class="callout-heading">Important note</p><p class="callout">Be prepared to stop your robot from driving over the edges if you use a table! It's best to use the floor.</p></li>
			</ul>
			<p>Check out the following video to see the code in action: <a href="https://bit.ly/39sHxWL">https://bit.ly/39sHxWL</a></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor133"/>Writing code to test your motors</h1>
			<p>Before we get stuck <a id="_idIndexMarker312"/>in and do fancy things with the motors, we need to get them set up and test them. This way, we can make sure they work and iron out any problems.</p>
			<p>We need to download the library to work with the motor board we have chosen. Many robot parts, apart from the simplest ones, have an interface library to control the motors and other devices on the board. It's time to log in to your Pi using PuTTY again.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor134"/>Preparing libraries</h2>
			<p>We download this code from<a id="_idIndexMarker313"/> a project on GitHub using Git on the Raspberry Pi. So, we need to install Git on the Pi; we also need I2C (<strong class="source-inline">i2c-tools</strong> and <strong class="source-inline">python3-smbus</strong>) and <strong class="source-inline">pip</strong> to install things into Python. Type the following command:</p>
			<p class="source-code">pi@myrobot:~ $ <strong class="bold">sudo apt-get install -y git python3-pip python3-smbus i2c-tools</strong></p>
			<p>To get the library for the motor board, <strong class="source-inline">Raspi_MotorHAT</strong>, we use Git and download it from GitHub, installing it for use in any of your scripts with the following command:</p>
			<p class="source-code">pi@myrobot:~ $ <strong class="bold">pip3 install git+https://github.com/orionrobots/Raspi_MotorHAT</strong></p>
			<p class="source-code">Collecting git+https://github.com/orionrobots/Raspi_MotorHAT</p>
			<p class="source-code">  Cloning https://github.com/orionrobots/Raspi_MotorHAT to /tmp/pip-c3sFoy-build</p>
			<p class="source-code">Installing collected packages: Raspi-MotorHAT</p>
			<p class="source-code">  Running setup.py install for Raspi-MotorHAT ... done</p>
			<p class="source-code">Successfully installed Raspi-MotorHAT-0.0.2</p>
			<p>We now have the libraries prepared for starting the robot. Documentation for the <strong class="source-inline">Raspi_MotorHAT</strong> library is sparse but is at <a href="https://github.com/orionrobots/Raspi_MotorHAT">https://github.com/orionrobots/Raspi_MotorHAT</a>, along with examples of using it.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor135"/>Test – finding the Motor HAT</h2>
			<p>The Raspberry<a id="_idIndexMarker314"/> Pi uses I2C to connect to this Motor HAT. <strong class="bold">I2C buses</strong> let you send and receive data, and are flexible in that we can connect many devices to the same bus. To enable I2C, use <strong class="source-inline">raspi-config</strong> again. We also enable the <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) while <a id="_idIndexMarker315"/>we are here. We may need this to connect other boards and sensors. Type the following command:</p>
			<p class="source-code">$ <strong class="bold">sudo raspi-config</strong></p>
			<p>Now, we use interfacing settings on this. <em class="italic">Figure 7.1</em> shows how, as follows:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="Images/B15660_07_01.jpg" alt="Figure 7.1 – Using raspi-config to enable SPI and I2C&#13;&#10;" width="1258" height="1124"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Using raspi-config to enable SPI and I2C</p>
			<p>Refer to the<a id="_idIndexMarker316"/> screenshots in <em class="italic">Figure 7.1</em> and perform the following steps:</p>
			<ol>
				<li>First, select <strong class="bold">Interfacing Options</strong>.</li>
				<li>Next, select <strong class="bold">I2C</strong>. </li>
				<li>The Pi asks if you want this interface to be enabled. Select <strong class="bold">&lt;Yes&gt;</strong>. </li>
				<li>You are then taken back to the initial screen and need to navigate again to the <strong class="bold">Interfacing Options</strong> screen. From there, select <strong class="bold">SPI</strong> and <strong class="bold">&lt;Yes&gt;</strong> again.</li>
				<li>A confirmation screen tells you now that SPI is enabled. Select <strong class="bold">&lt;Ok&gt;</strong>.</li>
				<li>Finally, press <em class="italic">Esc</em> twice to finish <strong class="source-inline">raspi-config</strong>. It asks if you want to reboot. Select <strong class="bold">&lt;Yes&gt;</strong>, and then wait for the Pi to reboot and reconnect to the Raspberry Pi. If it doesn't ask, please use <strong class="source-inline">sudo reboot</strong> to reboot it.</li>
			</ol>
			<p>With I2C, we <a id="_idIndexMarker317"/>need a way to choose which device we are talking with. Just as with houses along a road, an address allows us to say which one we specifically want.</p>
			<p>We should check that the Raspberry Pi can see the Motor HAT with <strong class="source-inline">sudo i2cdetect -y 1</strong> by running the following code:</p>
			<p class="source-code">pi@myrobot:~ $ <strong class="bold">sudo i2cdetect -y 1</strong></p>
			<p class="source-code">     0 1 2 3 4 5 6 7 8 9 a b c d e f</p>
			<p class="source-code">00: -- -- -- -- -- -- -- -- -- -- -- -- --</p>
			<p class="source-code">10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</p>
			<p class="source-code">20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</p>
			<p class="source-code">30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</p>
			<p class="source-code">40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</p>
			<p class="source-code">50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</p>
			<p class="source-code">60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 6f</p>
			<p class="source-code">70: 70 -- -- -- -- -- -- --</p>
			<p>This scans the I2C bus <strong class="source-inline">1</strong> for devices attached to our Raspberry Pi. It shows numbers at the addresses if something is found. The device found at addresses <strong class="source-inline">6f</strong> and <strong class="source-inline">70</strong> is our motor controller. If you cannot see this, power down the Raspberry Pi and carefully check that the Motor HAT has been plugged in, then try again.</p>
			<p>The addresses are hexadecimal, where each digit counts to 16, using the digits <strong class="source-inline">0</strong>-<strong class="source-inline">9</strong>, then letters <strong class="source-inline">A</strong>-<strong class="source-inline">F</strong> instead of counting only 10. When used in code, these get a <strong class="source-inline">0x</strong> prefix. This is a <em class="italic">zero</em> and then a lowercase x.</p>
			<p>We have enabled the I2C (and SPI) bus, and we then used the <strong class="source-inline">i2cdetect</strong> tool to find our motor device. This confirms first that it is connected and responding, and secondly that we have the right address—<strong class="source-inline">0x6f</strong>—for it. We can now start to send commands to it.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor136"/>Test – demonstrating that the motors move</h2>
			<p>We need <a id="_idIndexMarker318"/>a test file to demonstrate that the motors work. Carry out the following steps:</p>
			<ol>
				<li value="1">Create the following file, called <strong class="source-inline">test_motors.py</strong>:<p class="source-code"><strong class="bold">from Raspi_MotorHAT import Raspi_MotorHAT</strong></p><p class="source-code"><strong class="bold">import time</strong></p><p class="source-code"><strong class="bold">import atexit</strong></p><p class="source-code"><strong class="bold">mh = Raspi_MotorHAT(addr=0x6f)</strong></p><p class="source-code"><strong class="bold">lm = mh.getMotor(1)</strong></p><p class="source-code"><strong class="bold">rm = mh.getMotor(2)</strong></p><p class="source-code"><strong class="bold">def turn_off_motors():</strong></p><p class="source-code"><strong class="bold">  lm.run(Raspi_MotorHAT.RELEASE)</strong></p><p class="source-code"><strong class="bold">  rm.run(Raspi_MotorHAT.RELEASE)</strong></p><p class="source-code"><strong class="bold">atexit.register(turn_off_motors)</strong></p><p class="source-code"><strong class="bold">lm.setSpeed(150)</strong></p><p class="source-code"><strong class="bold">rm.setSpeed(150)</strong></p><p class="source-code"><strong class="bold">lm.run(Raspi_MotorHAT.FORWARD)</strong></p><p class="source-code"><strong class="bold">rm.run(Raspi_MotorHAT.FORWARD)</strong></p><p class="source-code"><strong class="bold">time.sleep(1)</strong></p></li>
				<li>Upload this file to your Raspberry Pi using the methods found in <a href="B15660_05_Final_ASB_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, <em class="italic">Backing Up the Code with Git and SD Card Copies</em>.<p class="callout-heading">Important note</p><p class="callout">Move your robot from your desk and down to the floor for this next step, as when it moves, it might not go in the direction you expect!</p></li>
				<li>To run this code, through PuTTY on the Pi, type the following:<p class="source-code">pi@myrobot:~ $ <strong class="bold">python3 test_motors.py</strong></p></li>
			</ol>
			<p>Your robot should now drive roughly forward. It may move slightly to the side, but it should not be turning or going backward, and both motors should be moving.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor137"/>Troubleshooting</h2>
			<p>If you see any problems, try this troubleshooting chart<a id="_idIndexMarker319"/> and go back:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="Images/Table7.1(new).jpg" alt="" width="1495" height="1281"/>
				</div>
			</div>
			<p>By this point, you should have a robot that will drive forward, have seen it move, and dealt with the preceding troubleshooting issues.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor138"/>Understanding how the code works</h2>
			<p>Now, our motors are <a id="_idIndexMarker320"/>moving and the robot drives using the <strong class="source-inline">test_motors.py</strong> code. But how does our motor test code really work? In this section, let's take a closer look and understand this.</p>
			<p>The first few lines of code here are imports: </p>
			<p class="source-code">from Raspi_MotorHAT import Raspi_MotorHAT</p>
			<p class="source-code">import time</p>
			<p class="source-code">import atexit</p>
			<p>Imports are how Python code <em class="italic">pulls in</em> other libraries of code to use them. The <strong class="source-inline">Raspi_MotorHAT</strong> library is the one we installed for interacting with our motors. The <strong class="source-inline">time</strong> library allows us to work with time; in this case, we use it for a delay between starting and stopping motors. The <strong class="source-inline">atexit</strong> library allows us to run code when this file exits.</p>
			<p>In the following lines, we connect the library to the Motor HAT and the two motors we have connected:</p>
			<p class="source-code">mh = Raspi_MotorHAT(addr=0x6f)</p>
			<p class="source-code">lm = mh.getMotor(1)</p>
			<p class="source-code">rm = mh.getMotor(2)</p>
			<p>The first line here makes a <strong class="source-inline">Raspi_MotorHAT</strong> object with the I2C address <strong class="source-inline">0x6f</strong> passed in as <strong class="source-inline">addr</strong>, which we saw in the scan. We call the returned object <strong class="source-inline">mh</strong> as an abbreviation for the connected <strong class="source-inline">Raspi_MotorHAT</strong>. </p>
			<p>We then create shortcuts to access the motors: <strong class="source-inline">lm</strong> for the left motor and <strong class="source-inline">rm</strong> for the right motor. We get these motor controls from the <strong class="source-inline">mh</strong> object, using the motor number shown on the board. Motor 1 is left, and motor 2 is right. </p>
			<p>We now define a function, <strong class="source-inline">turn_off_motors</strong>, which runs <strong class="source-inline">Raspi_MotorHAT.RELEASE</strong> on each motor on this board—an instruction to make the motors stop, as illustrated in the following code snippet:</p>
			<p class="source-code">def turn_off_motors():</p>
			<p class="source-code">  lm.run(Raspi_MotorHAT.RELEASE)</p>
			<p class="source-code">  rm.run(Raspi_MotorHAT.RELEASE)</p>
			<p class="source-code">atexit.register(turn_off_motors)</p>
			<p>We pass that into <strong class="source-inline">atexit.register(turn_off_motors)</strong>, a command that runs when this file finishes—when Python exits. <strong class="source-inline">atexit</strong> runs even when there are errors. Without this, the code could break in some interesting way, and the robot keeps driving. Robots without this kind of safeguard have a habit of driving off tables and into walls. If they carry on trying to drive when their motors are stuck, it can damage the motors, motor controllers, and <a id="_idIndexMarker321"/>batteries, so it's better to stop.</p>
			<p>The speed of the motors for this controller/library ranges from <strong class="source-inline">0</strong> to <strong class="source-inline">255</strong>. Our code sets the speed of each motor to just above half speed and then runs the <strong class="source-inline">Raspi_MotorHAT.FORWARD</strong> mode, which makes each motor drive forward, as illustrated in the following snippet:</p>
			<p class="source-code">lm.setSpeed(150)</p>
			<p class="source-code">rm.setSpeed(150)</p>
			<p class="source-code">lm.run(Raspi_MotorHAT.FORWARD)</p>
			<p class="source-code">rm.run(Raspi_MotorHAT.FORWARD)</p>
			<p>Finally, we ask the code to wait for 1 second, as follows:</p>
			<p class="source-code">time.sleep(1)</p>
			<p>The sleep allows the motors to run in their forward-drive mode for 1 second. The program then exits. Since we told it to stop motors when the code exits, the motors stop.</p>
			<p>We've now written and understood the code to test the motors. You've also seen it running. This confirms that you have a viable robot, and you have also started using Python imports. You've learned the <strong class="source-inline">atexit</strong> trick to turn things off and about using a timer so that the robot has some time to run before exiting. Now, we look at how we can steer the robot.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor139"/>Steering a robot</h1>
			<p>Now, we've made <a id="_idIndexMarker322"/>a robot drive forward. But how do we steer it? How does it turn left or right? In order to understand this, we need to first learn about a few significant forms of steering that exist. Let's take a look at some, settle on the one our robot uses, and write some test code to demonstrate it. </p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor140"/>Types of steering</h2>
			<p>The most<a id="_idIndexMarker323"/> common techniques for steering a wheeled vehicle (including a robot) fall into two major categories—steerable wheels and fixed wheels, as discussed in the following subsections. Each of them comes with a couple of slightly unusual variants. </p>
			<h3 id="_idParaDest-147">Steerable wheels</h3>
			<p>In movable wheel designs, one or <a id="_idIndexMarker324"/>more wheels in a robot face in a different direction from the others. When the robot drives, the differently positioned wheel makes the robot turn. There are two common styles of movable wheel steering on a robot, as shown here in <em class="italic">Figure 7.2</em>:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="Images/B15660_07_02.jpg" alt="Figure 7.2 – Steerable wheel types&#13;&#10;" width="700" height="737"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Steerable wheel types</p>
			<p>The green arrows show the direction of movement. The white arrows show changes to the shape of the robot and the angle of the wheels. Going through <em class="italic">Figure 7.2</em>, we can note the following:</p>
			<ol>
				<li value="1">Cars<a id="_idIndexMarker325"/> typically use <strong class="bold">rack and pinion steering</strong>. When straight, the car goes forward.</li>
				<li>When the lower bar is moved, shown by the white arrows, the car turns.</li>
				<li>The other common type is <strong class="bold">wagon-style steering</strong>, used in <a id="_idIndexMarker326"/>homemade racing karts. When straight, it goes forward.</li>
				<li>By turning the front bar, you can steer the vehicle.</li>
			</ol>
			<p>There are also other variants besides<a id="_idIndexMarker327"/> the ones we discussed previously. They include the following:</p>
			<ul>
				<li>Robots with the ability to independently reorient each wheel and drive sideways</li>
				<li>Ackerman steering, where the amount each wheel rotates is different</li>
				<li>Rear steering, where a front set of wheels and a rear set of wheels steer—used in long vehicles</li>
			</ul>
			<p>A good example of wagon-style steering is the<a id="_idIndexMarker328"/> Unotron robot, shown here in <em class="italic">Figure 7.3</em>. This was built by my son from the Unotron chassis by 4tronix, with an Arduino Nano controller:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="Images/B15660_07_03.jpg" alt="Figure 7.3 – Wagon-style steering Unotron robot&#13;&#10;" width="1430" height="404"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Wagon-style steering Unotron robot</p>
			<p>In the Unotron design, there is a single motor-driven wheel at the back (under the motor controller). A servo motor turns the whole front plate, steering the two front wheels. </p>
			<p>The disadvantages of this type of <a id="_idIndexMarker329"/>steering are related to space, weight, and complexity. A chassis set up for movable wheel steering requires more moving parts and space to house them. Unotron is as simple as it gets. There is more complexity in other designs, which can lead to required maintenance.</p>
			<p>The distance needed to make a turn (known as the turning circle) or for robots with steerable wheel systems is longer, as these must drive forward/backward to steer.</p>
			<p>You require one large motor for the fixed axle, as you cannot distribute power across two motors, or you need complex mechanisms to balance the input. If the mechanism does not center after steering, then the robot veers.</p>
			<h3 id="_idParaDest-148">Fixed wheels</h3>
			<p>Fixed-wheel steering<a id="_idIndexMarker330"/> is used frequently in robots, whereby the wheels' axes are fixed in relation to the chassis. The relative speed of each wheel or set of wheels sets the direction of the robot. That is, the wheels do not turn from side to side; however, by one side going faster than the other, the robot can make turns. A typical use of this is known as skid steering, which is illustrated in the following screenshot: </p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="Images/B15660_07_04.jpg" alt="Figure 7.4 – Fixed-wheel steering or skid steering&#13;&#10;" width="901" height="429"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Fixed-wheel steering or skid steering</p>
			<p><em class="italic">Figure 7.4</em> shows this in action. The white arrows show the relative speed of the motors. The green arrows show the direction of the robot. </p>
			<p>In the preceding figure, we can see the following:</p>
			<ol>
				<li value="1">The motors are going at the same speed, so the robot is driving straight forward.</li>
				<li>The motors on the right are going fast; the motors on the left are going slow. This robot is driving forward and left.</li>
			</ol>
			<p>This has several advantages. If you<a id="_idIndexMarker331"/> intend to use tank tracks, you need this type of drive system. It is mechanically simple in that a drive motor per wheel is all that is needed to make turns. Skid steering allows a robot to turn on the spot, doing a full 360 degrees in a turning circle the width of the widest/longest part of the robot. </p>
			<p>There are some disadvantages to using this. When turning, a skid-steer system may drag wheels sideways, causing friction. Also, any minor differences in the motors, their gearing, or the controller output can result in a veer.</p>
			<h3 id="_idParaDest-149">Other steering systems</h3>
			<p>The <a id="_idIndexMarker332"/>controller we are using on our robot allows us to control four motor channels. A builder can use four motors for special wheel types, known as Mecanum wheels. These wheels allow skid-steering style motions along with crabbing motions so that a robot can drive left or right without turning. Technically, this is still fixed-wheel steering. <em class="italic">Figure 7.5</em> here shows a base with Mecanum wheels:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="Images/B15660_07_05.jpg" alt="Figure 7.5 – Mecanum wheels on the Uranus Pod by Gwpcmu [CC BY 3.0 &#13;&#10;(https://creativecommons.org/licenses/by/3.0)]&#13;&#10;" width="640" height="386"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Mecanum wheels on the Uranus Pod by Gwpcmu [CC BY 3.0 (https://creativecommons.org/licenses/by/3.0)]</p>
			<p>These are <a id="_idIndexMarker333"/>amazingly flexible but mechanically complex, high maintenance, heavy, and a bit pricier than normal wheels. They are fun, however.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor141"/>Steering the robot we are building</h2>
			<p>Based on the<a id="_idIndexMarker334"/> three-wheel chassis we have chosen, with one castor wheel and then a driven wheel on each side, independently controlled, we are using skid steering. By varying the speed and direction of these wheels, we steer our robot. We can also spin 360 degrees with it. The castor wheel negates the problem mentioned with the drag seen on four- and six-wheel skid-steer robots.</p>
			<p>We can make the robot spin on the spot with one change to the previous code. Making one motor go back while the other goes forward spins the robot. Let's see how to do this, as follows: </p>
			<ol>
				<li value="1">Find the following lines in <strong class="source-inline">test_motors.py</strong>: <p class="source-code"><strong class="bold">lm.run(Raspi_MotorHAT.FORWARD)</strong></p><p class="source-code"><strong class="bold">rm.run(Raspi_MotorHAT.FORWARD)</strong></p></li>
				<li>Modify this as follows so that one motor goes <strong class="source-inline">BACKWARD</strong>:<p class="source-code"><strong class="bold">lm.run(Raspi_MotorHAT.FORWARD)</strong></p><p class="source-code"><strong class="bold">rm.run(Raspi_MotorHAT.BACKWARD)</strong></p></li>
				<li>Run this on the Pi with <strong class="source-inline">python3 turn_motors.py</strong>, and your robot now spins to the right. Swap them so left (<strong class="source-inline">lm</strong>) is <strong class="source-inline">BACKWARD</strong>, and right (<strong class="source-inline">rm</strong>) is <strong class="source-inline">FORWARD</strong>, and it spins the other way.</li>
				<li>What about less aggressive turns? In the previous code, before the direction lines, we also set the speed of each motor, as follows:<p class="source-code"><strong class="bold">lm.setSpeed(150)</strong></p><p class="source-code"><strong class="bold">rm.setSpeed(150)</strong></p><p class="source-code"><strong class="bold">lm.run(Raspi_MotorHAT.FORWARD)</strong></p><p class="source-code"><strong class="bold">rm.run(Raspi_MotorHAT.FORWARD)</strong></p><p>We can make a gentler turn by setting both <strong class="source-inline">lm</strong> and <strong class="source-inline">rm</strong> modes to <strong class="source-inline">FORWARD</strong>, and then making one of the speeds smaller than the other, like this:</p><p class="source-code"><strong class="bold">lm.setSpeed(100)</strong></p><p class="source-code"><strong class="bold">rm.setSpeed(150)</strong></p><p class="source-code"><strong class="bold">lm.run(Raspi_MotorHAT.FORWARD)</strong></p><p class="source-code"><strong class="bold">rm.run(Raspi_MotorHAT.FORWARD)</strong></p><p>This code makes the<a id="_idIndexMarker335"/> robot drive forward and turn gently to the left.</p></li>
			</ol>
			<p>You've now seen a few ways to steer robots. Based on the design our robot has, you've then put one of them into practice, making a robot spin on the spot, and also drive forward and turn too. In the next section, we'll turn this into a layer for different behaviors to use the robot.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor142"/>Making a Robot object – code for our experiments to talk to the robot</h1>
			<p>Now we<a id="_idIndexMarker336"/> have seen how to move and turn our robot, we come on to a layer of software to group up some of the hardware functions and isolate them from <strong class="bold">behaviors</strong>. By behaviors, I mean code to make a robot behave a certain way, for exampl<a id="_idTextAnchor143"/>e following a<a id="_idIndexMarker337"/> line or avoiding walls. Why would we want that isolation? </p>
			<p>When we chose our motor controller, we made many trade-offs to find what works for our project. Motor controllers can change when the considerations change or when we simply want to build our next robot. Although controlling the speed and direction of two motors is the same kind of operation, each controller does it slightly differently. Creating a layer in front of a controller lets us use the same commands for it, even if it changes. This layer acts as a façade or interface to robot functionality.</p>
			<p>Each controller has quirks. With this one, we set a run mode and speed. Many controllers use 0 to mean stop, but this one uses a <strong class="source-inline">RELEASE</strong> mode, which is slightly different from speed 0, which holds the motors. Controllers often use negative numbers to mean go backward; this one has a <strong class="source-inline">BACKWARD</strong> mode. The speed values on this controller go from 0-255. Some go from -128-128, or 0-10. What we can do is to create an object with an interface to hide quirks specific to this controller.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor144"/>Why make this object?</h2>
			<p>You design an<a id="_idIndexMarker338"/> interface to give you a way to interact with some other code. It can simplify, or make more consistent, different underlying systems to make them behave the same way, as with all the types of motor controller mentioned. It also provides a way to cleanly separate parts of code into layers. Different layers mean that you can change one part of some code without it making considerable changes in another, as illustrated in the following figure:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="Images/B15660_07_06.jpg" alt="Figure 7.6 – Software layers&#13;&#10;" width="281" height="131"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Software layers</p>
			<p>In <em class="italic">Figure 7.6</em>, panel 1 shows a block of code that has different systems mixed. It's hard to change; adding a new behavior or swapping the motor controller in this code would be quite tricky. It's good to avoid mixing responsibilities in this way.</p>
			<p>The code represented by panel 2 shows two separate systems interacting. They have a relationship where the <em class="italic">path-following behavior</em> is in control of the <em class="italic">robot hardware setup and control</em> code.</p>
			<p>Throughout the book we write many behaviors, and we can reuse the hardware control library, perhaps extending it occasionally. After all, who wants to keep writing the same code? When you extend and make new behaviors, you can use this layer again too.</p>
			<p>The robot hardware setup/control block in the second panel of <em class="italic">Figure 7.6</em> is our <strong class="source-inline">Robot </strong>  object. It is an interface to hide the quirks of the <em class="italic">Full Function Stepper HAT</em> board.</p>
			<p>This standard interface means we could make an object that looks the same from the outside on other robots, and our behaviors still work. Some serious robot builders use interfaces to swap real controllers for simulations of robots, to test complex behaviors.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor145"/>What do we put in the robot object?</h2>
			<p>An object is a building block to make interfaces in Python. Objects have methods—things we can call on it to perform tasks. Objects also have members, bits of data, or references to other objects.</p>
			<p>The next section builds code in the <strong class="source-inline">Robot</strong> object to do the following:</p>
			<ul>
				<li>Set up the Motor HAT <a id="_idIndexMarker339"/>and store its motors as members: <strong class="source-inline">left_motor</strong> and <strong class="source-inline">right_motor</strong>.</li>
				<li>Deal with the <strong class="source-inline">exit</strong> state.</li>
				<li>Stop motors with a <strong class="source-inline">stop_motors</strong> method.</li>
				<li>Let us use percentages to mean speeds—values of 0 to 100. We map this to what the controller wants.</li>
				<li>The modes are particular to this controller. Our interface uses negative values to mean going backward.</li>
				<li>At a later stage, the <strong class="source-inline">Robot</strong> object can act as a gatekeeper to data buses that require code to hold exclusive locks on them and some of the hardware.</li>
				<li>Our interface (and therefore our object) does not contain behavior, other than the stopping-on-exit safeguard.</li>
			</ul>
			<p>We put it in a file named <strong class="source-inline">robot.py</strong>, as follows:</p>
			<p class="source-code">from Raspi_MotorHAT import Raspi_MotorHAT</p>
			<p class="source-code">import atexit</p>
			<p class="source-code">class Robot:</p>
			<p class="source-code">    def __init__(self, motorhat_addr=0x6f):</p>
			<p class="source-code">        # Setup the motorhat with the passed in address</p>
			<p class="source-code">        self._mh = Raspi_MotorHAT(addr=motorhat_addr)</p>
			<p class="source-code">        # get local variable for each motor</p>
			<p class="source-code">        self.left_motor = self._mh.getMotor(1)</p>
			<p class="source-code">        self.right_motor  = self._mh.getMotor(2)</p>
			<p class="source-code">        # ensure the motors get stopped when the code exits</p>
			<p class="source-code">        atexit.register(self.stop_motors)</p>
			<p class="source-code">    def stop_motors(self):</p>
			<p class="source-code">        self.left_motor.run(Raspi_MotorHAT.RELEASE)</p>
			<p class="source-code">        self.right_motor.run(Raspi_MotorHAT.RELEASE)</p>
			<p>This <strong class="source-inline">class</strong> has a <strong class="source-inline">__init__</strong> method, a special one that sets this layer up. The <strong class="source-inline">__init__</strong> method stores<a id="_idIndexMarker340"/> the output of the <strong class="source-inline">getMotor</strong> methods from the <strong class="source-inline">Raspi_MotorHat</strong> library in the <strong class="source-inline">left_motor</strong> and <strong class="source-inline">right_motor</strong> members. This method also registers a stop system. I have added some comments to state what the fragments of code do.</p>
			<p>So far, our <strong class="source-inline">Robot</strong> object has set up our Motor HAT and has a way to stop the motors. The code is the same setup code we have seen before but is structured slightly differently. </p>
			<p>We can test this in another file named <strong class="source-inline">behavior_line.py</strong>, as illustrated in the following code snippet:</p>
			<p class="source-code">import robot</p>
			<p class="source-code">from Raspi_MotorHAT import Raspi_MotorHAT</p>
			<p class="source-code">from time import sleep</p>
			<p class="source-code">r = robot.Robot()</p>
			<p class="source-code">r.left_motor.setSpeed(150)</p>
			<p class="source-code">r.right_motor.setSpeed(150)</p>
			<p class="source-code">r.left_motor.run(Raspi_MotorHAT.FORWARD)</p>
			<p class="source-code">r.right_motor.run(Raspi_MotorHAT.FORWARD)</p>
			<p class="source-code">sleep(1)</p>
			<p>This starts by pulling in the <strong class="source-inline">robot.py</strong> file we just created with an import. It goes forward for 1 second and stops. Run with <strong class="source-inline">python3 behavior_line.py</strong>. </p>
			<p>We still have to set speeds specific to this board (not out of 100). Let's fix that in <strong class="source-inline">robot.py</strong> (new code is in bold), as follows:</p>
			<p class="source-code">from Raspi_MotorHAT import Raspi_MotorHAT</p>
			<p class="source-code">import atexit</p>
			<p class="source-code">class Robot(object):</p>
			<p class="source-code">    def __init__(self, motorhat_addr=0x6f):</p>
			<p class="source-code">        self._mh = Raspi_MotorHAT(addr=motorhat_addr)</p>
			<p class="source-code">        self.left_motor = self._mh.getMotor(1)</p>
			<p class="source-code">        self.right_motor  = self._mh.getMotor(2)</p>
			<p class="source-code">        atexit.register(self.stop_motors)</p>
			<p class="source-code"><strong class="bold">    def convert_speed(self, speed):</strong></p>
			<p class="source-code"><strong class="bold">        return (speed * 255) // 100</strong></p>
			<p class="source-code">    def stop_motors(self):</p>
			<p class="source-code">        self.left_motor.run(Raspi_MotorHAT.RELEASE)</p>
			<p class="source-code">        self.right_motor.run(Raspi_MotorHAT.RELEASE)</p>
			<p>We can now<a id="_idIndexMarker341"/> use <strong class="source-inline">convert_speed</strong>, to use speeds from 0 to 100. This returns speeds from 0 to 255 for this Motor HAT. For other motor boards, this returns something else.</p>
			<p>We multiply the speed by 255 and divide that by 100. This formula is a way of turning a percentage into a fraction of 255. We multiply first because we are doing integer (whole number) math, and dividing 80/100 with whole numbers gives 0, but dividing (80*255) by 100 returns 204. </p>
			<p>This code is still unwieldy, though—to use it, we need the following in <strong class="source-inline">behavior_line.py</strong>:</p>
			<p class="source-code">import robot</p>
			<p class="source-code">from Raspi_MotorHAT import Raspi_MotorHAT</p>
			<p class="source-code">from time import sleep</p>
			<p class="source-code">r = robot.Robot()</p>
			<p class="source-code">r.left_motor.setSpeed(<strong class="bold">r.convert_speed(80)</strong>)</p>
			<p class="source-code">r.right_motor.setSpeed(<strong class="bold">r.convert_speed(80)</strong>)</p>
			<p class="source-code">r.left_motor.run(Raspi_MotorHAT.FORWARD)</p>
			<p class="source-code">r.right_motor.run(Raspi_MotorHAT.FORWARD)</p>
			<p class="source-code">sleep(1)</p>
			<p>This still uses the <strong class="source-inline">run</strong> and <strong class="source-inline">setSpeed</strong> methods of the <strong class="source-inline">Raspi_MotorHAT</strong> library, which are specific to this control board. Other boards don't work the same way. We can also collect up the cumbersome conversion a little.</p>
			<p>We start by modifying the <strong class="source-inline">convert_speed</strong> method. It can be convenient for robots to use negative values to mean the motor goes backward. We still need to scale the speed, but we need to determine the run mode too.</p>
			<p>We need to do the<a id="_idIndexMarker342"/> following two things:</p>
			<ul>
				<li>Determine if the speed is above, below, or equal to zero, and set the mode for the <strong class="source-inline">run</strong> function.</li>
				<li>Remove the sign from the speed for <strong class="source-inline">setSpeed</strong>, so it's always a positive value.</li>
			</ul>
			<p>The default mode that we get at speed zero is <strong class="source-inline">RELEASE</strong> or stop. If the speed is above 0, we return the <strong class="source-inline">FORWARD</strong> mode, and if it's below 0, we return <strong class="source-inline">BACKWARD</strong>.</p>
			<p>We can use a simple <strong class="source-inline">if</strong> statement to get the correct <strong class="source-inline">mode</strong>. Let's replace the <strong class="source-inline">convert_speed</strong> method in the class to return the mode and positive value. I've used comments to show the two sections to this function. Modify this in <strong class="source-inline">robot.py</strong>, as follows:</p>
			<p class="source-code">def convert_speed(self, speed):</p>
			<p class="source-code">        # Choose the running mode</p>
			<p class="source-code">        mode = Raspi_MotorHAT.RELEASE</p>
			<p class="source-code">        if speed &gt; 0:</p>
			<p class="source-code">            mode = Raspi_MotorHAT.FORWARD</p>
			<p class="source-code">        elif speed &lt; 0:</p>
			<p class="source-code">            mode = Raspi_MotorHAT.BACKWARD</p>
			<p class="source-code">        # Scale the speed</p>
			<p class="source-code">        output_speed = (abs(speed) * 255) // 100</p>
			<p class="source-code">        return mode, int(output_speed)</p>
			<p>We've added one more operation to our speed calculation: <strong class="source-inline">abs(speed)</strong>. This operation returns the absolute value, which removes the sign from a number. For example, -80 and 80 both come out as 80, which means there is always a positive output from the method.</p>
			<p>Next, we add some methods to directly set the speed and direction of the left and right motors in the robot. These call <strong class="source-inline">convert_speed</strong> and use the mode and output speed from it to make calls to the <strong class="source-inline">Raspi_MotorHAT</strong> functions.</p>
			<p>We then need to change our motor movement methods to use this speed conversion, as follows:</p>
			<p class="source-code">    def set_left(self, speed):</p>
			<p class="source-code">        mode, output_speed = self.convert_speed(speed)</p>
			<p class="source-code">        self.left_motor.setSpeed(output_speed)</p>
			<p class="source-code">        self.left_motor.run(mode)</p>
			<p class="source-code">    def set_right(self, speed):</p>
			<p class="source-code">        mode, output_speed = self.convert_speed(speed)</p>
			<p class="source-code">        self.right_motor.setSpeed(output_speed)</p>
			<p class="source-code">        self.right_motor.run(mode)</p>
			<p>So, for each motor, we get the <a id="_idIndexMarker343"/>mode and output speed from the passed-in speed, then call <strong class="source-inline">setSpeed</strong> and <strong class="source-inline">run</strong>.</p>
			<p>The whole of <strong class="source-inline">robot.py</strong> should now look like the following:</p>
			<p class="source-code">from Raspi_MotorHAT import Raspi_MotorHAT</p>
			<p class="source-code">import atexit</p>
			<p class="source-code">class Robot:</p>
			<p class="source-code">    def __init__(self, motorhat_addr=0x6f):</p>
			<p class="source-code">        # Setup the motorhat with the passed in address</p>
			<p class="source-code">        self._mh = Raspi_MotorHAT(addr=motorhat_addr)</p>
			<p class="source-code">        # get local variable for each motor</p>
			<p class="source-code">        self.left_motor = self._mh.getMotor(1)</p>
			<p class="source-code">        self.right_motor = self._mh.getMotor(2)</p>
			<p class="source-code">        # ensure the motors get stopped when the code exits</p>
			<p class="source-code">        atexit.register(self.stop_motors)</p>
			<p class="source-code">    def convert_speed(self, speed):</p>
			<p class="source-code">        # Choose the running mode</p>
			<p class="source-code">        mode = Raspi_MotorHAT.RELEASE</p>
			<p class="source-code">        if speed &gt; 0:</p>
			<p class="source-code">            mode = Raspi_MotorHAT.FORWARD</p>
			<p class="source-code">        elif speed &lt; 0:</p>
			<p class="source-code">            mode = Raspi_MotorHAT.BACKWARD</p>
			<p class="source-code">        # Scale the speed</p>
			<p class="source-code">        output_speed = (abs(speed) * 255) // 100</p>
			<p class="source-code">        return mode, int(output_speed)</p>
			<p class="source-code">    def set_left(self, speed):</p>
			<p class="source-code">        mode, output_speed = self.convert_speed(speed)</p>
			<p class="source-code">        self.left_motor.setSpeed(output_speed)</p>
			<p class="source-code">        self.left_motor.run(mode)</p>
			<p class="source-code">    def set_right(self, speed):</p>
			<p class="source-code">        mode, output_speed = self.convert_speed(speed)</p>
			<p class="source-code">        self.right_motor.setSpeed(output_speed)</p>
			<p class="source-code">        self.right_motor.run(mode)</p>
			<p class="source-code">        </p>
			<p class="source-code">    def stop_motors(self):</p>
			<p class="source-code">        self.left_motor.run(Raspi_MotorHAT.RELEASE)</p>
			<p class="source-code">        self.right_motor.run(Raspi_MotorHAT.RELEASE)</p>
			<p>Our simple<a id="_idIndexMarker344"/> behavior in <strong class="source-inline">behavior_line.py</strong> is now only a few lines, as can be seen in the following code snippet:</p>
			<p class="source-code">import robot</p>
			<p class="source-code">from time import sleep</p>
			<p class="source-code">r = robot.Robot()</p>
			<p class="source-code">r.set_left(80)</p>
			<p class="source-code">r.set_right(80)</p>
			<p class="source-code">sleep(1)</p>
			<p>This simplification means we can build on this code to create more behaviors. I have a common interface, and versions of the <strong class="source-inline">Robot</strong> object for my other robots. An exciting outcome is I can run this <strong class="source-inline">behavior_lines.py</strong> code on ArmBot (the robot seen at the end of <a href="B15660_01_Final_ASB_ePub.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Robotics</em>) or my other Raspberry Pi robots. They all go forward for 1 second at 80% of their motor speed. </p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor146"/>Writing a script to follow a predetermined path</h1>
			<p>So, we<a id="_idIndexMarker345"/> now get to the first behavior that feels like a robot. Let's make a quick sketch of a path for us to get our robot to follow. For an example, see <em class="italic">Figure 7.7</em> here:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="Images/B15660_07_07.jpg" alt="Figure 7.7 – Path for our robot&#13;&#10;" width="274" height="451"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Path for our robot</p>
			<p>In <em class="italic">Figure 7.7</em>, I've <a id="_idIndexMarker346"/>drawn a path. The straight lines are for driving forward; the <strong class="bold">1</strong>s mean 1 second. We don't yet have a way to consider distance traveled, only time. We may be able to guess at times relative to distances, but this isn't very precise or repeatable. The gentle curves are a turn where we slow one motor down more than the other.</p>
			<p>The final spiral means a victory spin on the spot when the path is complete—we can do this by putting one motor in reverse while the other drives forward. </p>
			<p>Let's write this code. First, we want the imports: <strong class="source-inline">sleep</strong> and <strong class="source-inline">robot</strong>. But before we do anything, let's make some helper functions for this behavior. I called my file <strong class="source-inline">behavior_path.py</strong>, and the code is shown in the following snippet:</p>
			<p class="source-code">import robot</p>
			<p class="source-code">from time import sleep</p>
			<p class="source-code">def straight(bot, seconds):</p>
			<p class="source-code">    bot.set_left(80)</p>
			<p class="source-code">    bot.set_right(80)</p>
			<p class="source-code">    sleep(seconds)</p>
			<p class="source-code">def turn_left(bot, seconds):</p>
			<p class="source-code">    bot.set_left(20)</p>
			<p class="source-code">    bot.set_right(80)</p>
			<p class="source-code">    sleep(seconds)</p>
			<p class="source-code">def turn_right(bot, seconds):</p>
			<p class="source-code">    bot.set_left(80)</p>
			<p class="source-code">    bot.set_right(20)</p>
			<p class="source-code">    sleep(seconds)</p>
			<p class="source-code">def spin_left(bot, seconds):</p>
			<p class="source-code">    bot.set_left(-80)</p>
			<p class="source-code">    bot.set_right(80)</p>
			<p class="source-code">    sleep(seconds)</p>
			<p>The helpers use the same language we used to describe the behavior. We have <strong class="source-inline">straight</strong>, <strong class="source-inline">turn_left</strong>, <strong class="source-inline">turn_right</strong>, and <strong class="source-inline">spin_left</strong>. These are not in the <strong class="source-inline">Robot</strong> object because other behaviors may use more continuous behavior than this. I've called the <strong class="source-inline">Robot</strong> object <strong class="source-inline">bot</strong> now because one-letter variable names such as <strong class="source-inline">r</strong> become less easy to find, read, or reason about when there is more code.</p>
			<p>These helpers <a id="_idIndexMarker347"/>each set the motor speeds, and then sleep for a determined number of seconds. We can then create the <strong class="source-inline">Robot</strong> object and sequence them by adding the following code to <strong class="source-inline">behavior_path.py</strong>:</p>
			<p class="source-code">bot = robot.Robot()</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">turn_right(bot, 1)</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">turn_left(bot, 1)</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">turn_left(bot, 1)</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">spin_left(bot, 1)</p>
			<p>Now, we can upload this to the Raspberry Pi, and run it via PuTTY with the following:</p>
			<p class="source-code">$ <strong class="bold">python3 behavior_path.py</strong></p>
			<p>Now, if your robot is anything like mine, you saw it drive and make turns, but the turns have overshot in some way, and the robot may be veering to one side. We can fix the overshoot here by reducing the amount of time in the turn steps, like this:</p>
			<p class="source-code">bot = robot.Robot()</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">turn_right(bot, 0.6)</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">turn_left(bot, 0.6)</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">turn_left(bot, 0.6)</p>
			<p class="source-code">straight(bot, 1)</p>
			<p class="source-code">spin_left(bot, 1)</p>
			<p>You need to tweak these values to get close to 90-degree turns. This tweaking takes patience: change them and upload them. Tweaking values in code is a crude form of calibration to<a id="_idIndexMarker348"/> match the quirks of our robot. If you move between surfaces (for example, from a wooden floor to a carpet), then the timings will change.</p>
			<p>You may be able to account for some of the veering by tuning one motor to be slower in the <strong class="source-inline">straight</strong> function (adjust for your own robot's veer), like this:</p>
			<p class="source-code">def straight(bot, seconds):</p>
			<p class="source-code">    bot.set_left(80)</p>
			<p class="source-code">    bot.set_right(70)</p>
			<p class="source-code">    sleep(seconds)</p>
			<p>This code holds up for a while but may be hard to fine-tune. Why do we get this veer? </p>
			<p>Motor speeds can vary, even those from the same manufacturer. Other causes of minor variations are wheel diameters, axle positioning, weight distribution, slippery or uneven surfaces, wiring resistance, and motor controller variations. This variation makes it unlikely that you'd get a perfectly straight line from a robot this way. Depending on which sensors we are using, this may or may not be a problem. To account for this problem, we introduce encoders/speed sensors in a later chapter and calibrate those sensors to get a more accurate version of a path behavior.</p>
			<p>Without sensors, a robot is not able to determine where it is or if it has bumped into anything. If the robot ran into a wall, you'd probably have to go and move it to where it had room to move.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor147"/>Summary</h1>
			<p>In this chapter, we've learned how to install the libraries for the motor board and demonstrate that our motors work. We then started building the first layer of code for our behaviors to use, while noting how we could make a layer like that for other robots. We saw our robot move in a path and tuned it, while finding out some of the shortcomings of using motors without any sensors. </p>
			<p>You can now use this when starting any hardware project: get the motors/output devices tested first, then create a layer for a behavior to use them, such that if their hardware later changes, you only need to change the motor code.</p>
			<p>In the following chapters, we start adding sensors and building behaviors using these sensors.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor148"/>Exercises</h1>
			<p>Try these further ideas to enhance your learning from this chapter:</p>
			<ol>
				<li value="1">Sketch out another simple path and write code for the robot to follow it. For example, try to follow a figure-of-8 shape using your experience.</li>
				<li>Which methods would you add to the <strong class="source-inline">Robot</strong> object if you had an additional output to control, perhaps a single <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>)?</li>
				<li>Consider how you would lay out a <strong class="source-inline">Robot</strong> object for a robot with kart-style steering. Which methods would it have? You don't need to write the code yet, but having an interface in mind is a good start. Hint—it probably has one motor speed for the drive and a motor position for the steering.</li>
			</ol>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor149"/>Further reading</h1>
			<p>Please refer to the following for more information:</p>
			<ul>
				<li>For more information on the style used for the <strong class="source-inline">Robot</strong> object, along with the use of similar interfaces and classes, I recommend <em class="italic">Learning Object-Oriented Programming</em>, <em class="italic">Gastón C. Hillar</em>, <em class="italic">Packt Publishing</em>. This book not only works through these concepts in Python but takes them more generally and shows how <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) concepts also apply to the C# and JavaScript languages.</li>
			</ul>
		</div>
	</div></body></html>