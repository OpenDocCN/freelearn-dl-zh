- en: Python Libraries and Environment Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the Python libraries that we can use in order to implement
    the neuroevolution algorithms we described in the previous chapter. We will also
    discuss the strengths and weaknesses of each library that's presented. In addition
    to this, we will provide basic usage examples. Then, we will consider how to set
    up the environment for the experiments that we will perform later in this book
    and examine common ways to do this in the Python ecosystem. Finally, we will demonstrate
    how to set up a working environment using Anaconda Distribution, which is a popular
    tool for managing Python dependencies and virtual environments among data scientists.
    In this chapter, you will learn how to start using Python to experiment with the
    neuroevolution algorithms that will be covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Suitable Python libraries for neuroevolution experiments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable Python libraries for neuroevolution experiments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python programming language is one of the most popular languages for activities
    related to machine learning and research and development in the field of artificial
    intelligence. The most prominent frameworks are either written in Python or provide
    corresponding interfaces. Such popularity can be explained by Python's short learning
    curve and its nature as a scriptable language, which allows experiments to take
    place quickly. Thus, following a general trend in the machine learning community,
    several libraries were written in Python with the support for neuroevolution,
    and the number of libraries continues to grow over time. In this section, we will
    look at the most stable Python libraries for experiments in the field of evolutionary
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: NEAT-Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name suggests, this is the NEAT algorithm's implementation through the
    Python programming language. The NEAT-Python library provides the implementation
    of the standard NEAT methods for the genetic evolution of the genomes of organisms
    in a population. It implements utilities to convert the genotype of the organism
    into its phenotype (an artificial neural network) and provides convenient methods
    to load and save the genome configurations, along with the NEAT parameters. Additionally,
    it implements useful routines so that it can collect statistics about evolutionary
    process execution and a way to save/load intermediate checkpoints. Checkpoints
    allow us to save the state of the evolutionary process periodically and restore
    the process's execution from the saved checkpoint data later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros of the NEAT-Python algorithm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a stable implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is comprehensively documented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is available through the PIP package manager for easy installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a built-in statistics collection and support for storing execution checkpoints,
    as well as restoring execution from a given checkpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides multiple types of activation functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports the continuous-time recurrent neural network phenotypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be easily extended to support various NEAT modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons of the NEAT-Python algorithm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Only the NEAT algorithm is implemented by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is in a maintenance-only state right now and no active development has been
    done recently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NEAT-Python usage example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a general example of how to use the NEAT-Python library, without
    any particular problem in mind. It describes the typical steps to be taken and
    how to obtain the necessary results. We will use this library extensively throughout
    this book. You can skip to the next chapter for the concrete usage example, but
    you should follow through to the end of this chapter to learn more about alternative
    libraries. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the NEAT settings and the initial genome configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `config_file` parameter points to the file that contains the NEAT-Python
    library settings and the default configuration of the initial genome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a population of organisms from the configuration data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the statistics reporter and checkpoints collector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the evolution process over a specific number of generations (`300`, in
    our case):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `eval_genomes` is a function that's used to evaluate the genomes of all
    the organisms in the population against a particular fitness function and `winner`
    is the best performing genotype found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The phenotype ANN can be created from a genome as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the ANN can be queried with input data to calculate the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The library is available at [https://github.com/CodeReclaimers/neat-python](https://github.com/CodeReclaimers/neat-python).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding source code is to give you a feeling of the library. The full
    code examples will be provided in the chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: PyTorch NEAT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This library is built around the NEAT-Python library. It provides easy integration
    for artifacts that have been produced by the NEAT-Python library with the *PyTorch*
    platform. As a result, it becomes possible to convert the NEAT genome into a phenotype
    ANN, which is based on the PyTorch implementation of recurrent neural networks.
    Also, it allows us to represent **Compositional Pattern Producing Networks** (**CPPNs**)
    as PyTorch structures, which are the primary building blocks of the HyperNEAT
    method. The main advantage of integration with PyTorch is that it allows us to
    utilize GPUs for computing, potentially accelerating the evolutionary process
    due to the increased rate of evaluation of the genomes of organisms in the evolving
    population.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros of PyTorch NEAT are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is built around a stable NEAT-Python library, which makes it possible for
    us to use all of its benefits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with the PyTorch framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is GPU accelerated for the evaluation of NEAT genomes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes CPPN implementation, which is a building block of the HyperNEAT
    algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with the OpenAI GYM environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons of PyTorch NEAT are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Only the NEAT algorithm is fully implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides only partial support for the HyperNEAT algorithm's implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details about OpenAI GYM, go to [https://gym.openai.com](https://gym.openai.com).
  prefs: []
  type: TYPE_NORMAL
- en: PyTorch NEAT usage example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example of using the PyTorch NEAT library to implement
    a cartpole balancing controller. This is only being presented as an overview.
    Later in this book, we will dive deeper into the pole balancing problem in more
    detail. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the NEAT settings and seed genome configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `config_file` file stores the NEAT algorithm settings, along with
    the default genome configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a population of organisms from the configuration data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare the multi-environment genome evaluator based on PyTorch and OpenAI GYM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the call to the `gym.make("CartPole-v0")` function is the call to the
    OpenAI GYM framework to create a single-pole balancing environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the statistics and log reporter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the evolution process over a specific number of generations (`100`, in
    our case):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `eval_genomes` is a function for evaluating the genomes of all the organisms
    in a population against a certain fitness function, and the `winner` is the best
    performing genotype found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The phenotype ANN can be created from a genome, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `genome` is the NEAT genome configuration, `config `is an object that
    encapsulates the NEAT settings, and `bs` is a parameter that indicates the desired
    batch size.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the ANN can be queried with the input data to obtain the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `action` is the action specifier to be used in the simulation and `states` is
    the tensor that includes the current state of the environment that was obtained
    from the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: The library's source code is available at [https://github.com/uber-research/PyTorch-NEAT](https://github.com/uber-research/PyTorch-NEAT).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding source code is to give you a feeling of the library. The full
    code examples will be provided in the chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: MultiNEAT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MultiNEAT is the most universal library among the libraries we will discuss in
    this book since it supports the standard NEAT algorithm and two crucial extensions:
    HyperNEAT and ES-HyperNEAT. Also, the MultiNEAT library provides an implementation
    of a Novelty Search optimization method. The library is written in the C++ programming
    language but provides a comprehensive Python interface. The MultiNEAT Python wheel
    is also available through the Anaconda package manager, which makes it easy to
    install and use in any OS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros of the MultiNEAT library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stable implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implements a multitude of algorithms from the NEAT family, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NEAT
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HyperNEAT
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ES-HyperNEAT
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides an implementation of the Novelty Search optimization method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports plastic neural networks through Hebbian learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides visualization of genotypes and phenotypes through OpenCV in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with the OpenAI GYM environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensive documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons of the MultiNEAT library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No GPU support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not support checkpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MultiNEAT usage example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example of using the MultiNEAT library to implement the
    XOR solver using neuroevolution. This is just an overview, without the implementation
    of the XOR fitness score evaluator (`evaluate_xor`), which will be discussed in
    the next chapter. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the NEAT configuration settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a minimal genome configuration and spawn a population of organisms from
    this genome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the evolution process over `1000` generations or until the winner is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the query winner phenotype ANN, along with some inputs to
    get results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can find this library at [https://github.com/peter-ch/MultiNEAT](https://github.com/peter-ch/MultiNEAT).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding source code is to give you a feeling of the library. The full
    code examples will be provided in the chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Deep Neuroevolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deep Neural Networks** (**DNNs**) demonstrate outstanding performance improvements
    in tasks related to pattern recognition and reinforcement learning by utilizing
    the parallel processing capabilities of modern GPUs. In the context of neuroevolution,
    it is particularly interesting to explore how conventional **deep reinforcement
    learning** (**deep RL**) methods can be compared to the ones based on Deep Neuroevolution.
    To answer this question, the research team from UberAI labs created and released
    the corresponding library in the Python programming language, which uses the TensorFlow
    framework to handle computations related to neural network training on GPU devices.'
  prefs: []
  type: TYPE_NORMAL
- en: The library provides an implementation of the simple **genetic algorithm** (**GA**)
    and the Novelty Search optimization method. It also provides an implementation
    of the Evolution Strategies method, which is another kind of evolutionary algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details about the Evolution Strategies method at Hans-Georg
    Beyer, *The Theory of Evolution Strategies.* Springer April 27, 2001.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros of Deep Neuroevolution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stable implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPU-enabled through integration with TensorFlow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to work directly with high-dimensional problems, such as learning
    to act directly from pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides an implementation of the Novelty Search optimization method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradient-free method to optimize DNNs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides visualization of the learning process through the **Visual Inspector
    for Neuroevolution** (**VINE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides integration with the OpenAI GYM environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides integration with the Atari games environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantage of Deep Neuroevolution is that it does not provide an implementation
    of the NEAT family of neuroevolution algorithms, that is, NEAT, HyperNEAT, and
    ES-HyperNEAT.
  prefs: []
  type: TYPE_NORMAL
- en: The genetic algorithm that's implemented in the Deep Neuroevolution library
    controls the evolution of a population of organisms that have genomes encoding
    a vector of learning parameters (connection weights) for a deep neural network.
    At every generation, each genotype is evaluated and produces a fitness score.
    After that, the specific number of organisms are selected uniformly at random
    from the top best-fit individuals to become parents of the next generation. The
    genotype of each selected parent organism is then mutated by adding Gaussian noise.
    Also, the algorithm uses the notion of elitism, in which the specific number of
    best-fit organisms from the previous generation are added to the next without
    any modifications being made. The crossover operator is not applied during the
    evolutionary process to simplify the algorithm. The topology of the DNN that's
    used in this algorithm is fixed and set by experimenters manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s refer to the following simple genetic algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7ca6ede-758b-438f-8ad4-475abc2cbcb6.png)'
  prefs: []
  type: TYPE_IMG
- en: The simple genetic algorithm
  prefs: []
  type: TYPE_NORMAL
- en: More details about the implementation of Deep Neuroevolution is available at
    [https://github.com/uber-research/deep-neuroevolution](https://github.com/uber-research/deep-neuroevolution).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Python neuroevolution libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table provides a quick comparison between the Python libraries
    we''ve discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **NEAT-Python** | **PyTorch NEAT** | **MultiNEAT** | **Deep Neuroevolution**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **NEAT** | Yes | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **HyperNEAT** | No | Partial (CPPN only) | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **ES-HyperNEAT** | No | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Novelty Search** | No | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **OpenAI GYM** | No | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **Visualization** | No | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **GPU support** | No | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **PIP** | Yes | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Anaconda** | No | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Checkpoints** | Yes | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: The NEAT-Python library provides excellent visualization integration and is
    easy to use. However, it has a significant drawback in that it is implemented
    solely in Python and, as a result, has a very slow execution speed. It is only
    suitable for simple problems.
  prefs: []
  type: TYPE_NORMAL
- en: The MultiNEAT Python library has core implemented in C++, which gives it slightly
    better performance compared to the NEAT-Python library. It can be used for solving
    more complex tasks requiring the creation of larger phenotype ANNs. Also, it provides
    the implementation of the HyperNEAT and ES-HyperNEAT methods, which makes it the
    right choice for tasks related to training large-scale ANNs.
  prefs: []
  type: TYPE_NORMAL
- en: The Deep Neuroevolution library is the most advanced neuroevolution implementation
    and allows us to employ the powers of GPUs to handle training tasks with millions
    of trainable parameters. This can be found in the visual imagery processing domain.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, we will get to know each Python library better and put them
    into practice.
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Python libraries, it is essential to set up a working environment
    properly. There are a lot of dependencies, including the Python language version
    and the binaries that are available in the system; all of these must be aligned
    and have compatible versions. As a result of this process, the conflicting configurations
    of libraries and language versions can be easily created, adding to the frustration
    and hours of debugging and bug fixes. To solve this problem, the concept of the
    virtual environment was introduced in the Python programming language. A virtual
    environment allows us to create isolated Python environments that contain all
    the necessary dependencies and executables that are used in a particular Python
    project. Such a virtual environment can be easily created and deleted after it
    is no longer needed, without leaving any remains in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the most popular tools for working with Python virtual environments,
    we can highlight the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pipenv
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtualenv
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anaconda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipenv is a tool that combines package manager with the virtual environments
    manager. The main goal is to make it easy for developers to set up a unique working
    environment for a particular project with all the necessary dependencies included.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be installed with PIP (the package installer for Python) using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs the `pipenv` tool into the user space to prevent
    it from breaking any system-wide packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install all the dependencies and create a new virtual environment (if not
    present) for your project, change into the project''s directory and run the installation
    process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new virtual environment in `my_project_folder` and installs
    `<package>` into it. That's it.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to provide a configuration file (Pipfile) that specifies which
    packages should be installed, as well as other information that's specific to
    the build process. When you run `install` for the first time, the Pipfile will
    be created automatically if it doesn't exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: More details about the tool can be found at  [https://pipenv.kennethreitz.org/en/latest/](https://pipenv.kennethreitz.org/en/latest/)[.](https://docs.pipenv.org/en/latest/)
  prefs: []
  type: TYPE_NORMAL
- en: Virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtualenv is a tool that's used to create isolated Python environments, starting
    from Python v3.3, and is partially integrated into the standard library under
    the `venv` module. The major problem that's addressed by this tool is maintaining
    the unique set of dependencies, versions, and permissions for each Python project
    independently. Virtualenv handles this by creating a separate environment with
    its own installation directories for each project. This prevents us from sharing
    any dependencies and libraries with other projects. Also, it is possible to block
    access to globally installed libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtualenv is a pure virtual environments manager and it doesn''t provide any
    package manager routines. Therefore, it is usually used along with the package
    manager to manage dependencies of your project, such as PIP. Let''s take a look
    at Virtualenv:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Virtualenv with PIP as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Test that the installation was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a virtual environment for your project with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new virtual environment in `my_project_folder`. The fresh
    environment includes a folder with Python executable files inside it, as well
    as a copy of the PIP library, which is a package manager that allows us to install
    other dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start using it, you need to activate the virtual environment with
    the following command, which can be typed into the Terminal application of your
    choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After the preceding command, all the necessary environment variables will be
    set to the correct values that are specific to your project, and the current session
    of the Terminal application will use it for any subsequent commands that are entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional packages can be easily installed into an active environment with
    PIP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs the SQLite package in the currently active environment.
  prefs: []
  type: TYPE_NORMAL
- en: If no package name is provided after the `pip install` command, the pip manager
    will look for a `requirements.txt` file in the current directory for the specification
    of the packages to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details at [https://virtualenv.pypa.io/en/latest/](https://virtualenv.pypa.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Anaconda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anaconda Distribution is a package and a virtual environment manager that is
    popular among data scientists and machine learning professionals because it provides
    easy access to an extensive collection of tailored scientific libraries (over
    1,500+) and useful tools. Apart from this, it allows you to write source code
    and execute scripts in Python and R from one place. With Anaconda, it is possible
    to easily create, save, load, and switch between virtual environments, as well
    as install thousands of packages from the repository that have been reviewed and
    maintained by the Anaconda team into each virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: To install Anaconda, you need to download the installer that's appropriate to
    your operating system from [https://www.anaconda.com/distribution/](https://www.anaconda.com/distribution/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the new environment for your project can be created with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a new virtual environment for your project and
    installs into it the specified package or multiple packages. Additional packages
    can be easily installed into a fresh environment later, after it's been activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the environments that are available in the system can be listed with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Any existing environment can be activated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To deactivate the current active environment, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional libraries can be installed into the current environment either through
    standard PIP or by using the `conda install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After the preceding command, SQLite will be installed into the currently active
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use Anaconda to manage the dependencies and environments
    for most of our projects.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in finding out more, please make yourself familiar with
    all available Anaconda commands at [https://docs.conda.io/projects/conda/en/latest/commands.html](https://docs.conda.io/projects/conda/en/latest/commands.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about four popular Python libraries that we can
    use for experiments in the field of neuroevolution. We discussed the strengths
    and weaknesses of each library that was presented, and reviewed the basic examples
    of using these libraries in Python. After that, we looked at how to set up the
    environment for Python-based experiments to avoid the side effects of having multiple
    versions of the same library in the Python path. We found that the best way to
    do this is to create isolated virtual environments for each Python project, and
    considered several popular solutions created by the open source community to help
    with this task. Finally, we introduced Anaconda Distribution, which includes,
    among other useful things, the package manager and an environment manager. For
    the rest of this book, we will use Anaconda to handle setting up the environment
    in our experiments properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how the NEAT algorithm can be used to solve
    the classic computer science problem. You will write the XOR problem solver using
    the NEAT-Python library we discussed in this chapter. We will also discuss the
    hyperparameters that are used to configure the NEAT algorithm and how they can
    be adjusted to increase the performance of the neuroevolution process.
  prefs: []
  type: TYPE_NORMAL
