<html><head></head><body>
<div><div><div><h1 id="_idParaDest-87" class="chapter-number"><a id="_idTextAnchor086"/>4</h1>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Performing Complex Actions by Chaining Functions</h1>
			<p>In the previous chapter, we learned how to create native plugins, which we used to check the format of Excel and Word documents, and semantic plugins, which we used to verify whether the content of the documents fulfilled our requirements.</p>
			<p>In this chapter, we will start by creating a simple pipeline that generates images. The pipeline will receive a text with clues about an animal and will then generate a text that guesses the animal from the clues, as well as generating a picture of the animal.</p>
			<p>Later in the chapter, we will continue the application of the previous chapter: verifying whether grant requests fulfill some requirements. For that application, a grant request will come with two files inside a folder: a Word document and an Excel spreadsheet.</p>
			<p>Our application checks that the Word document contains a proposal for a vaccination campaign, including the team who will perform it and their experience, and an Excel file that contains its budget.</p>
			<p>This type of scenario is common in enterprises: governments and corporations must prioritize requests for projects, editors must approve or reject book proposals, and lawyers must verify that the documents they are filing in court fulfill legal requirements. It’s not uncommon to have to verify thousands or tens of thousands of documents. This is a kind of job that, until recently, was done manually. We’re going to write a pipeline that automates it.</p>
			<p>In this chapter, we’ll be covering the following topics:</p>
			<ul>
				<li>Creating a native plugin that generates images</li>
				<li>Chaining a semantic plugin that outputs text with the native plugin that generates images</li>
				<li>Running a complex, multistep pipeline</li>
			</ul>
			<p>By the end of the chapter, you will have the tools required to build a kernel that can perform many coordinated functions, and that can be used as a copilot or be integrated into other tools, such as a planner.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have a recent, supported version of your preferred Python or C# development environment:</p>
			<ul>
				<li>For Python, the minimum supported version is Python 3.10, and the recommended version is Python 3.11</li>
				<li>For C#, the minimum supported version is .NET 8</li>
			</ul>
			<p>In this chapter, we will call OpenAI services. Given the amount that companies spend on training these LLMs, it’s no surprise that using these services is not free. You will need an <strong class="bold">OpenAI API</strong> key, either directly through <strong class="bold">OpenAI</strong> or <strong class="bold">Microsoft</strong>, via the <strong class="bold">Azure </strong><strong class="bold">OpenAI</strong> service.</p>
			<p>If you are using .NET, the code for this chapter is at <a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4</a>.</p>
			<p>If you are using Python, the code for this chapter is at <a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4</a>.</p>
			<p>You can install the required packages by going to the GitHub repository and using the following: <code>pip install -</code><code>r requirements.txt</code>.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Creating a native plugin that generates images</h1>
			<p>To learn about the power of chaining functions, we are going to create functions that perform <a id="_idIndexMarker284"/>very different actions. We will start by <a id="_idIndexMarker285"/>creating functions that generate images and putting them in a plugin. Then, we’re going to learn how to incorporate these functions into a more complex chain.</p>
			<p>In some applications, you may want to generate an image with AI. For example, social media posts with images tend to get more engagement, but creating images without AI or finding images can be time-consuming and expensive.</p>
			<p>Compared to market prices of non-AI images, generating images with AI is very cheap. On the other hand, generating images is still one of the most compute-intensive activities that can be done with AI. Recent research from Hugging Face [1] has shown that generating <a id="_idIndexMarker286"/>an image is 2,000 times <a id="_idIndexMarker287"/>more expensive in terms of carbon emissions than generating a text answer. These costs will be passed down to you.</p>
			<p class="callout-heading">Costs of OpenAI image generation</p>
			<p class="callout">If you want to reproduce the content in this section, be aware that image generation is far more costly than text generation. You will need an API key, and each image generation costs $0.04 per image for the following examples, and up to $0.12 per image if you want to create higher-quality images with higher resolutions.</p>
			<p class="callout">Prices change frequently, and you can check the latest prices at <a href="https://openai.com/pricing">https://openai.com/pricing</a>.</p>
			<p>In <em class="italic">Figure 4</em><em class="italic">.1</em>, we show two examples of images generated with AI that I have created to enhance a couple of my social media posts. The first, me as a cowboy, was for a post about billionaires using cowboy hats. The second, with me as a character on the cover of a romantic novel, was for a post about writing fiction. Each image took less than a minute to generate with AI. I ran a test in Threads, Instagram’s new microblogging app where I have over 10,000 followers, and the image posts had multiple times more engagement than posts with the same text but no image.</p>
			<div><div><img src="img/B21826_04_1.jpg" alt="Figure 4.1 – Images generated with AI for social media posts" width="1117" height="557"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Images generated with AI for social media posts</p>
			<p>Image <a id="_idIndexMarker288"/>generation support in Microsoft <a id="_idIndexMarker289"/>Semantic Kernel is not consistent. The C# API has an object called <code>TextToImage</code> that can generate images using DALL-E 2, a model released in November 2022, but that API is not available for Python. That image-generating model is now obsolete, having been superseded by DALL-E 3 in October of 2023; however, at the time of writing, Semantic Kernel does not offer an out-of-the-box way to access DALL-E 3.</p>
			<p>We will create two native plugins, one for C# and one for Python, that allow us to access DALL-E 3 from Semantic Kernel.</p>
			<p class="callout-heading">Adding new models to the kernel</p>
			<p class="callout">Although we are using DALL-E 3, as an interesting and novel model, as the example that we are adding to the kernel, this approach of creating a native plugin wrapper works for any model that has an API, including Claude from Anthropic, Gemini from Google, and hundreds of models from Hugging Face. Any AI service that is made available through a REST API can be added in this way.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Writing a DALL-E 3 wrapper in Python</h2>
			<p>It is easier to write a DALL-E 3 wrapper in Python than in C# because OpenAI offers and supports <a id="_idIndexMarker290"/>a Python package called openai that <a id="_idIndexMarker291"/>allows developers to access any new OpenAI function as soon <a id="_idIndexMarker292"/>as it’s made available. All we must do is create <a id="_idIndexMarker293"/>a native function that uses the OpenAI package and send a request to DALL-E 3:</p>
			<pre class="source-code">
from dotenv import load_dotenv
from openai import OpenAI
import os
from semantic_kernel.skill_definition import kernel_function
class Dalle3:
    @kernel_function(
        description="Generates an with DALL-E 3 model based on a prompt",
        name="ImageFromPrompt",
        input_description="The prompt used to generate the image",
    )
    def ImageFromPrompt(self, input: str) -&gt; str:
        load_dotenv()
        client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))</pre>			<p>As we saw in <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a>, we declare a native function using the <code>kernel_function</code> decorator. We then simply instantiate an OpenAI client object with our API key.</p>
			<p>Now let’s submit the request:</p>
			<pre class="source-code">
        response = client.images.generate(
            model="dall-e-3",
            prompt=input,
            size="1024x1024",
            quality="standard",
            n=1,
        )
        image_url = response.data[0].url
        return image_url</pre>			<p>The <a id="_idIndexMarker294"/>Python OpenAI client contains the <code>images.generate</code> method, which will call DALL-E 3 and return the generated URL. We <a id="_idIndexMarker295"/>simply call it and return the URL.</p>
			<p>Now, we <a id="_idIndexMarker296"/>are going to create a simple script that instantiates the plugin and calls it:</p>
			<pre class="source-code">
import asyncio
import semantic_kernel as sk
from OpenAiPlugins import Dalle3
async def main():
    kernel = sk.Kernel()
    animal_str = "A painting of a cat sitting in a sofa in the impressionist style"
    dalle3 = kernel.import_skill(Dalle3())
    animal_pic_url = await kernel.run_async(
        dalle3['ImageFromPrompt'],
        input_str=animal_str
    )
    print(animal_pic_url)
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>The <a id="_idIndexMarker297"/>preceding code instantiates <a id="_idIndexMarker298"/>the <code>Dalle3</code> native plugin <a id="_idIndexMarker299"/>and calls its <code>ImageFromPrompt</code> function with the <code>"A painting of a cat sitting on a sofa in the impressionist style"</code> input parameter. An example output is in <em class="italic">Figure 4</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21826_04_2.jpg" alt="Figure 4-2 – A cat in the impressionist style generated by DALL-E 3 by Python" width="807" height="807"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – A cat in the impressionist style generated by DALL-E 3 by Python</p>
			<p>Now that we have seen how to do this in Python, let’s see how to do it in C#.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Writing a DALL-E 3 wrapper in C#</h2>
			<p>OpenAI does not provide a supported package for C# that allows users of that language to interact <a id="_idIndexMarker300"/>with its service. The best way of interacting <a id="_idIndexMarker301"/>with the OpenAI service for C# users is <a id="_idIndexMarker302"/>to use Microsoft Semantic Kernel, which has a <code>TextToImage</code> functionality, but at the time of writing, it only provides connectivity to DALL-E 2.</p>
			<p>Most AI services will expose a REST API. Therefore, to connect Microsoft Semantic Kernel to them, one solution is to write a native plugin that wraps the REST API. We show how to do this for DALL-E 3 here:</p>
			<pre class="source-code">
using System.ComponentModel;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using Microsoft.SemanticKernel;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
namespace Plugins;
public class Dalle3
{
    [KernelFunction, Description("Generate an image from a prompt")]
    async public Task&lt;string&gt; ImageFromPrompt([Description("Prompt describing the image you want to generate")] string prompt)
    {</pre>			<p>Making a REST <code>POST</code> request requires several packages, such as <code>System.Text.Json</code> and <code>System.Net</code>. Like what we did in <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a>, we use a decorator, <code>KernelFunction</code>, to signal that the function is accessible to Semantic Kernel, and a <code>Description</code> attribute to describe what our function does.</p>
			<p>We then <a id="_idIndexMarker303"/>create an <code>HttpClient</code> object. This object <a id="_idIndexMarker304"/>will make a REST API call. We need to set it <a id="_idIndexMarker305"/>up with our API key as a <code>Bearer</code> token and set its header as accepting “<code>application/json</code>” because that’s how the OpenAI API will respond:</p>
			<pre class="source-code">
        HttpClient client = new HttpClient
        {
            BaseAddress = new Uri("https://api.openai.com/v1/")
        };
        var (apiKey, orgId) = Settings.LoadFromFile();
        client.DefaultRequestHeaders
            .Accept
            .Add(new MediaTypeWithQualityHeaderValue("application/json"));
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", apiKey);
        client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));</pre>			<p>The next step is to submit the <code>POST</code> request to the API:</p>
			<pre class="source-code">
        var obj = new {
            model = "dall-e-3",
            prompt = prompt,
            n = 1,
            size = "1024x1024"};
        var content = new StringContent(JsonSerializer.Serialize(obj), Encoding.UTF8, "application/json");
        var response  = await client.PostAsync("images/generations", content);</pre>			<p>We created <a id="_idIndexMarker306"/>a JSON object, <code>obj</code>, using the fields that <a id="_idIndexMarker307"/>are required by the OpenAI API. The <code>model</code> field states <a id="_idIndexMarker308"/>what model we’re using, and here we make sure to specify <code>"dall-e-3"</code> to use DALL-E 3. The documentation of all the possible parameters can be found here: <a href="https://platform.openai.com/docs/api-reference/images/create">https://platform.openai.com/docs/api-reference/images/create</a>.</p>
			<p>The final step is to recover the <code>url</code> field from the JSON returned by OpenAI. That <code>url</code> field points to the image:</p>
			<pre class="source-code">
        if (!response.IsSuccessStatusCode)
        {
            return $"Error: {response.StatusCode}";
        }
        string jsonString = await response.Content.ReadAsStringAsync();
        using JsonDocument doc = JsonDocument.Parse(jsonString);
        JsonElement root = doc.RootElement;
        return root.GetProperty("data")[0]!.GetProperty("url")!.GetString()!;
    }
}</pre>			<p>Next, let’s <a id="_idIndexMarker309"/>see how <a id="_idIndexMarker310"/>to call <a id="_idIndexMarker311"/>the plugin:</p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using Plugins;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.Plugins.AddFromType&lt;Dalle3&gt;();
var kernel = builder.Build();
string prompt = "A cat sitting on a couch in the style of Monet";
string? url = await kernel.InvokeAsync&lt;string&gt;(
    "Dalle3", "ImageFromPrompt", new() {{ "prompt", prompt }}
);
Console.Write(url);</pre>			<p>To call <a id="_idIndexMarker312"/>the plugin, we added a reference to the <a id="_idIndexMarker313"/>source file, <code>Plugins</code>, instantiated <a id="_idIndexMarker314"/>the <code>Dalle3</code> plugin with <code>AddFromType</code>, and called its <code>ImageFromPrompt</code> method, passing <code>prompt</code> as a parameter.</p>
			<p>The resulting picture is the following:</p>
			<div><div><img src="img/B21826_04_3.jpg" alt="Figure 4.3 – A cat in the impressionist style generated by the C# native plugin" width="965" height="915"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – A cat in the impressionist style generated by the C# native plugin</p>
			<p>Now that we have created a function that accesses a new service, let’s incorporate it into a solution that uses it.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Using multiple steps to solve a problem</h1>
			<p>Although programming solutions step by step can be very helpful, one of the best abilities that Semantic Kernel gives users is allowing them to make requests using natural language. This will <a id="_idIndexMarker315"/>require using <strong class="bold">planners</strong>, which we will use in <a href="B21826_05.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, to break down a user request into multiple steps and then automatically call each step in the appropriate order.</p>
			<p>In this section, we will <a id="_idIndexMarker316"/>solve problems by telling Semantic Kernel which functions to call. This is helpful for making sure that the solutions we make available to the planner work, and it is also helpful when we want to explicitly control how things are executed.</p>
			<p>To illustrate the manual approach, we will see how to give Semantic Kernel clues about an animal, guess it with a semantic function, and then generate an image of the animal using the native function we created in the previous section.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Generating an image from a clue</h2>
			<p>In the <a id="_idIndexMarker317"/>following code, we have two steps. In the first step, we will use GPT-3.5 to guess an animal from clues. To do that, we will create a semantic plugin called <code>AnimalGuesser</code>.</p>
			<p class="callout-heading">Important: Using OpenAI services is not free</p>
			<p class="callout">The semantic functions will call the OpenAI API. These calls require a paid subscription, and each call will incur a cost. The costs are usually small per request. GPT 3.5 costs $0.0002 per thousand tokens, but they may add up if you make a large number of calls. Prices change frequently, so make sure to check the latest prices on the following websites:</p>
			<p class="callout">OpenAI pricing: <a href="https://openai.com/pricing">https://openai.com/pricing</a></p>
			<p class="callout">Azure OpenAI pricing: <a href="https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/">https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/</a></p>
			<p>The semantic <a id="_idIndexMarker318"/>plugin, as always, consists of two files, <code>config.json</code> and <code>skprompt.txt</code>, listed as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json</p>
			<pre class="source-code">
{
    "schema": 1,
    "name": "GuessAnimal",
    "type": "completion",
    "description": "Given a text with clues, guess the animal",
    "execution_settings": {
        "default": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        }
    },
    "input_variables": [
        {
            "name": "input",
            "description": "CLues about an animal",
            "required": true
        }
    ]
}</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt</p>
			<pre class="source-code">
Below, there's a list of clues about an animal.
{{$input}}
From the clues above, guess what animal it is.
Provide your answer in a single line, containing just the name of the animal.</pre>			<p>As we <a id="_idIndexMarker319"/>always do, we must make sure that the <code>description</code> fields in the <code>config.json</code> files are set correctly. This will not have any effect now, but when we start using the planner or letting Semantic Kernel automatically call functions, the kernel will use the <code>description</code> fields to figure out what each function does and decide which ones to call.</p>
			<p>For now, let’s see how to tell the kernel to call functions in sequence.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Chaining semantic and native functions with C#</h2>
			<p>In C#, you need to use the <code>KernelFunctionCombinators</code> class to create a function <a id="_idIndexMarker320"/>pipeline. The code for the <a id="_idIndexMarker321"/>class is provided in the GitHub repository. </p>
			<p>The code for implementing a function pipeline follows:</p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using Plugins;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.Plugins.AddFromType&lt;Dalle3&gt;();
builder.AddOpenAIChatCompletion("gpt-3.5-turbo", apiKey, orgId);
var kernel = builder.Build();
KernelPlugin animalGuesser = kernel.ImportPluginFromPromptDirectory("../../../plugins/AnimalGuesser");
string clues = "It's a mammal. It's a pet. It meows. It purrs.";</pre>			<p>In the <a id="_idIndexMarker322"/>preceding snippet, we create <a id="_idIndexMarker323"/>our kernel, add an OpenAI service to it, and add the <code>AnimalGuesser</code> and <code>Dalle3</code> plugins to it.</p>
			<p>Next, we assign the functions we want to call, <code>AnimalGuesser.GuessAnimal</code> and <code>Dalle3.ImageFromPrompt</code>, to <code>KernelFunction</code> variables:</p>
			<pre class="source-code">
KernelFunction guessAnimal = animalGuesser["GuessAnimal"];
KernelFunction generateImage = kernel.Plugins["Dalle3"]["ImageFromPrompt"];
KernelFunction pipeline = KernelFunctionCombinators.Pipe(new[] {
    guessAnimal,
    generateImage
}, "pipeline");</pre>			<p>Lastly, we create a <code>KernelArguments</code> object called <code>context</code> and pass it as a parameter to <code>InvokeAsync</code>:</p>
			<pre class="source-code">
KernelArguments context = new() { { "input", clues } };
Console.WriteLine(await pipeline.InvokeAsync(kernel, context));</pre>			<p>The attributes of the <code>context</code> object must match what the first function is expecting. In our <a id="_idIndexMarker324"/>case, the <code>AnimalGuesser.GuessAnimal</code> function expects a parameter named <code>input</code>. From <a id="_idIndexMarker325"/>then on, the pipeline will call each function, get the output as a text string, and pass that text string as the first parameter to the next function. In our case, even though the first parameter of the <code>Dalle3.ImageFromPrompt</code> function is called <code>prompt</code> instead of <code>input</code>, the call is still going to work. You only need to provide the correct name for the parameter used in the first step of the pipeline.</p>
			<p>If you run the preceding program, you will get a picture of a cat:</p>
			<div><div><img src="img/B21826_04_4.jpg" alt="Figure 4.4 – Picture of a cat generated from AI guessing the animal from clues" width="950" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Picture of a cat generated from AI guessing the animal from clues</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Chaining semantic and native functions with Python</h2>
			<p>As we <a id="_idIndexMarker326"/>did in C#, let’s use Python <a id="_idIndexMarker327"/>to create a script that starts from a list of clues, guesses the animal that the clues refer to, and then generates a picture of the animal.</p>
			<p>We will build on the plugins we already have. We will reuse the native plugin that we created to generate images using DALL-E 3.</p>
			<p>One new thing is that we are going to create a function called <code>pipeline</code> that receives a list of functions and an input parameter and then calls each function in the list, passing the output of the call as the input parameter of the next function in the list.</p>
			<p>The definition of the function is as follows:</p>
			<pre class="source-code">
async def pipeline(kernel, function_list, input):
    for function in function_list:
        args = KernelArguments(input=input)
        input = await kernel.invoke(function, args)
    return input</pre>			<p>We start <a id="_idIndexMarker328"/>as we always do, creating <a id="_idIndexMarker329"/>a kernel and adding an AI service to it. Here, we are assigning the plugins to variables, which will enable us to reference functions in the next step:</p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from OpenAiPlugins import Dalle3
async def main():
    kernel = sk.Kernel()
    api_key, org_id = sk.openai_settings_from_dot_env()
    gpt35 = OpenAIChatCompletion("gpt-3.5-turbo", api_key, org_id)
    kernel.add_chat_service("gpt35", gpt35)
    generate_image_plugin = kernel.import_skill(Dalle3())
    animal_guesser = kernel.import_semantic_skill_from_directory("../../plugins", "AnimalGuesser")</pre>			<p>With that, we can now give our model the clues and ask it to guess:</p>
			<pre class="source-code">
    clues = """
    I am thinking of an animal.
    It is a mammal.
    It is a pet.
    It is a carnivore.
    It purrs."""
    function_list = [
        animal_guesser['GuessAnimal'],
        generate_image_plugin['ImageFromPrompt']
    ]
    animal_pic_url = await pipeline(kernel, function_list, clues)
    print(animal_pic_url)
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>As seen <a id="_idIndexMarker330"/>in the preceding <a id="_idIndexMarker331"/>snippet, to run the pipeline, we create the list of functions we want to call in order, adding it to the <code>function_list</code> variable, and then call the <code>pipeline</code> function. The <code>pipeline</code> function will run the first function with the input parameter you passed, then it will use the output of the first function as the parameter of the second function, and so on.</p>
			<p>Like what happened in the C# example, the output will be a URL pointing to a freshly generated picture of a cat (not displayed).</p>
			<p>Now that we’re done with a simple example of a pipeline, let’s go back to the problem we were solving in <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a> and described in the introduction of this chapter: verifying whether a proposal for a vaccination campaign fulfills the basic requirements.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Dealing with larger, more complex chains</h1>
			<p>In the previous chapter, we created three plugins:</p>
			<ul>
				<li><code>CheckSpreadsheet</code>: A native <a id="_idIndexMarker332"/>plugin that checks that the Excel spreadsheet contains the required fields and that they fulfill some rules</li>
				<li><code>ParseWordDocument</code>: A native <a id="_idIndexMarker333"/>plugin that extracts text from a Word document</li>
				<li><code>ProposalChecker</code>: A semantic plugin that checks whether text blocks fulfill some <a id="_idIndexMarker334"/>requirements, such as “<em class="italic">does this text block describe a team that has a Ph.D. and a </em><em class="italic">medical doctor</em>?”</li>
			</ul>
			<p>With these three plugins, you can already solve the business problem of checking proposals by calling each plugin separately and writing the logic to handle whether there was an error. This is likely sufficient for problems that have a small number of steps.</p>
			<p>While we are still going to use a small number of steps and a small number of documents for didactic purposes, the approach to analyzing and making decisions on a large number of documents presented in this chapter excels when there are many steps and many documents to process.</p>
			<p>Let’s see how to implement it.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Preparing our directory structure</h2>
			<p>Before we start, we need <a id="_idIndexMarker335"/>to make sure that we have the data for the proposals loaded in the <code>data/proposals</code> folder. We will also reuse the native plugins by putting them in the same directory as our main program. The semantic plugins will be in the <code>plugins</code> directory.</p>
			<p>We will modify our native and semantic functions slightly from what we did in the previous chapter. The main change is that we will introduce error handling directly into the semantic functions, which will enable us to process many documents with a single call.</p>
			<p>Below is the <a id="_idIndexMarker336"/>directory structure of our solution. Each proposal is represented by a directory in the <code>proposals</code> directory, and each directory should contain exactly two files, one Excel file with the extension <code>.xlsx</code> and one Word file with the extension <code>.docx</code>:</p>
			<pre class="source-code">
└───data
    └───proposals
    |   |───correct
    |   |    ├───correct.docx
    |   |    └───correct.xlsx
    |   ├───incorrect01
    |   |    ├───missing_experience.docx
    |   |    └───incorrect_template.xlsx
    |   ├───incorrect02
    |   |    ├───missing_qualifications.docx
    |   |    └───over_budget.xlsx
    |   └───(...)
    |   ├─── incorrect10
    └───plugins
         └───ProposalCheckerV2
              ├───CheckDatesV2
              |     ├───skprompt.txt
              |     └───config.json
              ├───CheckPreviousProjectV2
              |     ├───skprompt.txt
              |     └───config.json
              └───CheckTeamV2
                    ├───skprompt.txt
                    └───config.json
└───ch4
    └───code
          ├───python
          |    ├───ch4.py
          |    ├───ParseWordDocument.py
          |    └───CheckSpreadsheet.py
          └───dotnet
               ├───Program.cs
               ├───ParseWordDocument.cs
              └───CheckSpreadsheet.cs</pre>			<p>This follows <a id="_idIndexMarker337"/>the same structure we used earlier: a main file containing the code (<code>ch4.py</code> or <code>Program.cs</code>), additional files in the same directory, each containing a native plugin (<code>ParseWordDocument</code> and <code>CheckSpreadsheet</code>), and all the semantic plugins in a dedicated directory, <code>plugins</code>. We separate folders by language because that makes it simpler to manage the virtual environments that hold installed packages by folder. Semantic plugins are language-independent and can have their own directory.</p>
			<p>Now that we have described the expected directory structure, let’s look at the high-level flow of our process.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Understanding the flow of our process</h2>
			<p>We will start by writing a native <a id="_idIndexMarker338"/>plugin called <code>Helpers</code> that contains a native <a id="_idIndexMarker339"/>function called <code>ProcessProposalFolder</code>, which when given a path that represents a folder, checks whether it contains exactly one Excel file and a Word document. If it does, it returns the path of the folder, if not, it returns a string with an error.</p>
			<p>Once we create the <code>Helpers</code> plugin, we will be almost ready to call the functions we developed in <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a>. We will make two modifications to the existing files <code>ParseWordDocument</code> and <code>CheckSpreadsheet</code>.</p>
			<p>One modification we will make to both files will be to check if the input is an error state. If it is, we simply pass the error state forward. If we are not in an error state, we keep passing the folder <a id="_idIndexMarker340"/>path forward. We will need to make these simple modifications to all the native functions and semantic functions.</p>
			<p>The second and last modification will be to the <code>ParseWordDocument</code> native plugin. We will add three separate helper functions, each one parsing one of the three different required sections of the document (<code>Team</code>, <code>Experience</code>, and <code>Implementation </code>details). The new functions will simply call the existing function with a parameter representing one section per function.</p>
			<p>The reason for doing all of this is to only have functions with a single parameter in the pipeline. This enables the return of each function to be passed as a parameter to the next function, which will make things much simpler.</p>
			<p>The full pipeline, with 10 steps, is represented in the next diagram.</p>
			<div><div><img src="img/B21826_04_5.jpg" alt="Figure 4.5 – Visual representation of the pipeline" width="827" height="403"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Visual representation of the pipeline</p>
			<p>In <em class="italic">Figure 4</em><em class="italic">.5</em>, orange boxes represent native functions that deal with the filesystem, green boxes represent native functions that deal with Excel, blue boxes represent native functions that <a id="_idIndexMarker341"/>deal with Word, and purple boxes represent semantic functions.</p>
			<p>Now that we understand all the steps for the pipeline, let’s create the new plugin and function and make the required modifications.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Creating the native function to process a folder</h2>
			<p>To get the pipeline started, we need a plugin that ensures that the folder that we want to process <a id="_idIndexMarker342"/>contains the correct files. Since this is an activity that requires interacting with the operating system, we need to create a native function, which we will host inside a plugin we will call <code>Helpers</code>.</p>
			<p>The code for the plugin is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
public class Helpers
{
    [KernelFunction, Description("Checks that the folder contains one Word and one Excel file")]
    public static string ProcessProposalFolder([Description("Folder potentially containing")] string folderPath)
    {</pre>			<p>As usual, since we <a id="_idIndexMarker343"/>want this function to be available to Semantic Kernel, we use the <code>KernelFunction</code> decorator and the descriuption of what the function does under the <code>Description</code> variable.</p>
			<p>Now, we are simply going to count the number of files available in the folder. Remember that we want exactly one file with the <code>.docx</code> extension and one file with the <code>.</code><code>xlsx</code> extension:</p>
			<pre class="source-code">
        string result = folderPath;
        if (!Directory.Exists(folderPath))
        {
            return "Error: Folder does not exist";
        }
        var files = Directory.GetFiles(folderPath);
        int wordCount = files.Count(f =&gt; Path.GetExtension(f).ToLower() == ".docx");
        int excelCount = files.Count(f =&gt; Path.GetExtension(f).ToLower() == ".xlsx");
        if (wordCount == 1 &amp;&amp; excelCount == 1)
        {
            return result;
        }
        else if (wordCount == 0 &amp;&amp; excelCount == 0)
        {
            return "Error: Folder does not contain one Word and one Excel file";
        }
        else if (wordCount == 0)
        {
            return "Error: Folder missing Word file";
        }
        else if (excelCount == 0)
        {
            return "Error: Folder missing Excel file";
        }
        return "Error: Folder contains more than one Word or Excel file";
    }
}</pre>			<p>The logical part of the function is very simple. It counts the number of files with the <code>.docx</code> and <code>.xlsx</code> extensions in the directory. If the directory has one of each, the call succeeded. We signal success by passing the folder as the return result. In any other situation, we generate a string with an error message. We will use the convention that error messages in this pipeline start with <code>Error</code>.</p>
			<p>Let’s now <a id="_idIndexMarker344"/>check out the code for the plugin in Python:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
from typing_extensions import Annotated
from semantic_kernel.functions.kernel_function_decorator import kernel_function
import os
class Helpers:
    @kernel_function(
        description="Checks that the folder contains the expected files, an Excel spreadsheet and a Word document",
        name="ProcessProposalFolder"
    )
    def ProcessProposalFolder(self, input: Annotated[str, "The file path to the folder containing the proposal files"]) -&gt; str:</pre>			<p>In Python, we use the <code>kernel_function</code> decorator to indicate that this function can be used by Semantic Kernel. We also add an <code>Annotated</code> description to the parameter.</p>
			<p>Then, the function code is very simple. Similar to the C# function above, we count how many files with the <code>.docx</code> and <code>.xlsx</code> extensions are in the directory. If there’s exactly one of each, we indicate success by returning the folder name. Anything else will result in a failure, which will be indicated by a string starting with <code>Error</code>:</p>
			<pre class="source-code">
    def ProcessProposalFolder(self, folder_path: str) -&gt; str:
        xlsx_count = 0
        docx_count = 0
        for file in os.listdir(folder_path):
            if file.endswith(".xlsx"):
                xlsx_count += 1
            elif file.endswith(".docx"):
                docx_count += 1
        if xlsx_count == 1 and docx_count == 1:
            return "Success"
        elif xlsx_count == 0 and docx_count == 0:
            return "Error: No files found"
        elif xlsx_count == 0:
            return "Error: No Excel spreadsheet found"
        elif docx_count == 0:
            return "Error: No Word document found"
        else:
            return "Error: multiple files found"</pre>			<p>Now that <a id="_idIndexMarker345"/>we have the function to kick off the pipeline, let’s see what needs to be done with the plugins we wrote in <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a> to make them usable for this pipeline.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Modifying the Excel native plugin</h2>
			<p>We need <a id="_idIndexMarker346"/>to make a few changes to the Excel plugin we created for <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a>:</p>
			<ul>
				<li>Standardize the error message to always start with <code>Error</code></li>
				<li>Standardize the success message to always return the folder</li>
				<li>At the beginning of every function, if the input starts with <code>Error</code>, do nothing and simply pass the received input forward</li>
			</ul>
			<p>To save space, the following code shows the changes to only one of the functions, <code>CheckTabs</code>. The full modified code is available in the GitHub repository.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
    [KernelFunction, Description("Checks that the spreadsheet contains the correct tabs, 2024 and 2025")]
    public string CheckTabs([Description("The file path to the spreadsheet")] string folderPath)
    {
        if (folderPath.StartsWith("Error"))
        {
            return folderPath;
        }</pre>			<p>The preceding code checks if the input received contains an error. Since this is going to be used in a pipeline, any errors in previous steps will be received here.</p>
			<p>If we get an error, we’re simply going to pass the error forward in the following code:</p>
			<pre class="source-code">
        string filePath = GetExcelFile(folderPath);
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Error: File does not exist.";
            }</pre>			<p>Note that we are ensuring that any error message starts with <code>Error</code>, to make sure they’re easy to detect when they are received by other pipeline functions.</p>
			<p>We now <a id="_idIndexMarker347"/>check how many sheets are in the file:</p>
			<pre class="source-code">
            using (var package = new ExcelPackage(fileInfo))
            {
                ExcelPackage.LicenseContext = OfficeOpenXml.LicenseContext.NonCommercial;
                var workbook = package.Workbook;
                if (workbook.Worksheets.Count != 2)
                {
                    return "Error: Spreadsheet does not contain 2 tabs.";
                }
                if (workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2024") &amp;&amp; workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2025"))
                {
                    return folderPath;
                }</pre>			<p>In the case of success, we simply pass the folder forward.</p>
			<p>Otherwise, the following code passes the error forward:</p>
			<pre class="source-code">
                else
                {
                    return "Error: Spreadsheet does not contain 2024 and 2025 tabs.";
                }
            }
        }
        catch (Exception ex)
        {
            return $"Error: An error occurred: {ex.Message}";
        }
    }</pre>			<p>Let’s see <a id="_idIndexMarker348"/>the changes in Python. To save space, we’re only showing the changes to the <code>CheckTabs</code> function. The full code for all functions is in the GitHub repository.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
        @kernel_function(
        description="Checks that the spreadsheet contains the correct tabs, 2024 and 2025",
        name="CheckTabs",
    )
    def CheckTabs(self,
                  input: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        if path.startswith("Error"):
            return path</pre>			<p>If the <a id="_idIndexMarker349"/>previous function sent us an error, we simply pass it forward.</p>
			<p>Otherwise, we continue:</p>
			<pre class="source-code">
        try:
            filePath = self.GetExcelFile(path)
            workbook = openpyxl.load_workbook(filePath)
            sheet_names = workbook.sheetnames
            if sheet_names == ['2024', '2025']:
                return path</pre>			<p>To indicate success, we simply return the folder we received as input:</p>
			<pre class="source-code">
            else:
                return "Error: the spreadsheet does not contain the correct tabs"
        except Exception as e:
            return f"Error: an exception {e} occurred when trying to open the spreadsheet"</pre>			<p>Now that we have standardized the input and output of the functions, it makes it easier to extend the pipeline, since all the functions expect the same input, a folder, and when the function succeeds, it simply passes the folder to the next function.</p>
			<p>In the case of an error, the string passed as an input will start with <code>Error</code>, and all functions will simply pass it forward. These changes make it easier to change the order of steps and to add or remove steps.</p>
			<p>Now that we’re done with the changes in the Excel plugin, let’s make changes to the <code>ParseWordDocument</code> plugin that extracts text from Word documents.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Modifying the Word native plugin</h2>
			<p>The modifications to the Word native plugin are very simple. In <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a>, when we were <a id="_idIndexMarker350"/>calling the native plugin directly, we created a function called <code>ExtractTextUnderHeading</code> that received two parameters: a path to a file and the heading that we wanted to extract, and we called that function three times so that we could extract the text under the three headings we wanted.</p>
			<p>In pipelines, since we can only have one parameter, we will create three functions named <code>ExtractTeam</code>, <code>ExtractExperience</code>, and <code>ExtractImplementation</code> that receive the folder as a parameter and call the <code>ExtractTextUnderHeading</code> function that we created in <a href="B21826_03.xhtml#_idTextAnchor071"><em class="italic">Chapter 3</em></a> with the appropriate heading parameter, respectively <code>"Team"</code>, <code>"Experience"</code>, and <code>"Implementation"</code>.</p>
			<p>Like we did with the Excel plugin, we will also make the following changes:</p>
			<ul>
				<li>Standardize the error message to always start with <code>Error</code></li>
				<li>Standardize the success message to always return the folder</li>
				<li>At the beginning of every function, if the input starts with <code>Error</code>, do nothing and simply pass the received input forward</li>
			</ul>
			<p>To save space, we only show one of the functions here. The full code, including the modifications in the <code>ExtractTextUnderHeading</code> function, is in the GitHub repository:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
    [KernelFunction, Description("Extracts the text under the Team heading in the Word document")]
    public static string ExtractTeam(string folderPath)
    {
        if (folderPath.Contains("Error"))
        {
            return folderPath;
        }
        string text = ExtractTextUnderHeading(folderPath, "Team");
        return $"FolderPath: {folderPath}\n"  + text;
    }</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
    def ExtractTeam(self, folder_path: str) -&gt; str:
        if folder_path.startswith("Error"):
            return folder_path
        doc_path = self.get_first_docx_file(folder_path)
        text = self.ExtractTextUnderHeading(doc_path, 'Team')
        return f"FolderPath: {folder_path}\n{text}"</pre>			<p>In both cases, in addition <a id="_idIndexMarker351"/>to creating three function wrappers for <code>ExtractTextUnderHeading</code> to extract the text, we also perform two more tasks. The first is to check whether the previous step of the pipeline sent an error message. If it did, we simply pass it on. The second is to prepend the folder path to the text in a line called <code>FolderPath</code>. This will be used in the semantic functions. When the semantic function decides that the text it read fulfills the requirements, it will return the folder path, as is expected by functions in the pipeline.</p>
			<p>Let’s work on the semantic functions.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Modifying the semantic functions</h2>
			<p>The main modification that we need to make to the semantic functions is to ensure they understand <a id="_idIndexMarker352"/>the inputs and provide the appropriate outputs – either the folder in the case of success or an error message in the case of failure.</p>
			<p>One way to do this is to encode the input into tags and then tell the AI service to perform operations on the contents of the tag. There was no need to modify the <code>config.json</code> files, only the <code>skprompt.txt</code> files.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CheckTeamV2: skprompt.txt</p>
			<pre class="source-code">
=====
 {{$input}}
=====
Check the contents of the text between the ===== and =====.
If the contents are an error message, respond with the error message, including the word "Error:" at the beginning.
Otherwise, the first line of the text between the ===== and ===== will contain the FolderPath.
The other lines will contain the team's experience.
We require the team's experience to have at least one person with a Ph.D. and at least one person with a degree in the medical sciences.
Think carefully about the team's experience.
If the team fulfills the requirements, your answer should be the contents of the FolderPath field, nothing more.
If the team does not fulfill the requirements, reply with "Error: Team does not meet requirements."</pre>			<p>In this semantic function, we tell the AI to check the contents of the text between <code>=====</code> for an error <a id="_idIndexMarker353"/>and simply pass it on if it finds one. If the contents between the ===== tags are not an error, they will contain the folder we’re processing in a line starting with <code>FolderPath</code> and the text from the <code>Team</code> heading in the Word document. We tell the AI to return the folder if the team fulfills the requirements we list or to return an error message if they don’t:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CheckDatesV2: skprompt.txt</p>
			<pre class="source-code">
=====
 {{$input}}
=====
Check the contents of the text between the tags ===== and =====.
If the contents are an error message, respond with the error message, including the word "Error:" at the beginning.
Otherwise, the text between the tags ===== and ===== will contain
a line starting with FolderPath and the rest of the field will contain
a description of a timeline for vaccine implementation.
Think carefully about the following question:
Ignoring the FolderPath line, does the timeline contain dates?
If there are no dates listed, say "Error: No dates listed" .
If the dates are outside of the 2024-2025 range, say "Error: dates out of range".
If there are dates between 2024 and 2025, respond only with the contents of the FolderPath field, nothing more.</pre>			<p>We now ask the AI to check the contents between the <code>=====</code> tags for an error. The same as before, we simply pass it on if we find it. We then check whether the dates proposed for <a id="_idIndexMarker354"/>the vaccination campaign are within our expectations. If they are, we return the folder contained in the <code>FolderPath</code> line inside the tag. Otherwise, we return an error message:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CheckPreviousProjectV2: skprompt.txt</p>
			<pre class="source-code">
=====
 {{$input}}
=====
Check the contents of the text between the ===== and =====.
If the contents are an error message, respond with the error message, including the word "Error:" at the beginning.
Otherwise, the text between the ===== and ===== will contain a line starting with FolderPath and the rest of the field will contain a description of the teams experience.
Ignoring the FolderPath line, does the description of the teams experience
indicate they have enough experience to conduct a massive vaccination campaign in a new country?
If they have had a successful experience in Atlantis or another large country, respond only with the
contents of the FolderPath field, nothing more.
Otherwise, respond with "Error: Not enough experience."</pre>			<p>The final <a id="_idIndexMarker355"/>semantic function is very similar to the previous two. We ask the AI to check the contents between the <code>=====</code> tags and return an error message if the team requesting for funding does not have enough experience as demonstrated by a previous project.</p>
			<p>Now that we’re done with all the steps of our process, let’s assemble them into a pipeline and run it.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Creating and calling the pipeline</h1>
			<p>Calling the pipeline requires creating a kernel, loading it with the functions we want, and then calling <a id="_idIndexMarker356"/>them in sequence. Since we’re going to use semantic functions, we also need to add an AI service to the kernel. Evaluating text against requirements <a id="_idIndexMarker357"/>can be a complex task, and therefore we will use GPT-4 to execute it. GPT 3.5 can work if the documents are simple, but some of our documents have more than one page, and that can be too much for GPT 3.5 to handle well.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>In the following code block, we load all the native and semantic plugins into our kernel:</p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using Plugins.ProposalChecker;
using System;
using System.IO;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.AddOpenAIChatCompletion("gpt-4", apiKey, orgId);
builder.Plugins.AddFromPromptDirectory("../../../plugins/ProposalCheckerV2");
builder.Plugins.AddFromType&lt;Helpers&gt;();
builder.Plugins.AddFromType&lt;ParseWordDocument&gt;();
builder.Plugins.AddFromType&lt;CheckSpreadsheet&gt;();
var kernel = builder.Build();</pre>			<p>Then, we create variables for each of the functions:</p>
			<pre class="source-code">
KernelFunction processFolder = kernel.Plugins["Helpers"]["ProcessProposalFolder"];
KernelFunction checkTabs = kernel.Plugins["CheckSpreadsheet"]["CheckTabs"];
KernelFunction checkCells = kernel.Plugins["CheckSpreadsheet"]["CheckCells"];
KernelFunction checkValues = kernel.Plugins["CheckSpreadsheet"]["CheckValues"];
KernelFunction extractTeam = kernel.Plugins["ParseWordDocument"]["ExtractTeam"];
KernelFunction checkTeam = kernel.Plugins["ProposalCheckerV2"]["CheckTeamV2"];
KernelFunction extractExperience = kernel.Plugins["ParseWordDocument"]["ExtractExperience"];
KernelFunction checkExperience = kernel.Plugins["ProposalCheckerV2"]["CheckPreviousProjectV2"];
KernelFunction extractImplementation = kernel.Plugins["ParseWordDocument"]["ExtractImplementation"];
KernelFunction checkDates = kernel.Plugins["ProposalCheckerV2"]["CheckDatesV2"];</pre>			<p>Creating variables <a id="_idIndexMarker358"/>for each of the functions is not strictly necessary – you could <a id="_idIndexMarker359"/>simply put the code on the right-hand side of each of the preceding assignments directly into the pipeline call.</p>
			<p>For example, instead of</p>
			<pre class="source-code">
KernelFunctionCombinators.Pipe(new[] {
    processFolder,
    checkTabs}</pre>			<p>You could write:</p>
			<pre class="source-code">
KernelFunctionCombinators.Pipe(new[] {
kernel.Plugins["ProposalCheckerV2"]["ProcessProposalFolder"]}
    kernel.Plugins["ProposalCheckerV2"]["CheckTabs"]}</pre>			<p>Assigning it to <a id="_idIndexMarker360"/>variables makes the contents of the pipeline call much shorter, and that <a id="_idIndexMarker361"/>can make it easier to maintain.</p>
			<p>Next, we create a pipeline with the <code>Pipe</code> method of <code>KernelFunctionCombinators</code>, simply listing the steps in the order we want them to be called:</p>
			<pre class="source-code">
KernelFunction pipeline = KernelFunctionCombinators.Pipe(new[] {
    processFolder,
    checkTabs,
    checkCells,
    checkValues,
    extractTeam,
    checkTeam,
    extractExperience,
    checkExperience,
    extractImplementation,
    checkDates
}, "pipeline");</pre>			<p>The next <a id="_idIndexMarker362"/>step will <a id="_idIndexMarker363"/>be to call the pipeline:</p>
			<pre class="source-code">
var proposals = Directory.GetDirectories("../../../data/proposals");
// print each directory
foreach (var proposal in proposals)
{
    // convert to absolute path
    string absolutePath = Path.GetFullPath(proposal);
    Console.WriteLine($"Processing {absolutePath}");
    KernelArguments context = new() { { "folderPath", absolutePath } };
    string result = await pipeline.InvokeAsync&lt;string&gt;(kernel, context);
    Console.WriteLine(result);
    if (result == absolutePath)
    {
        Console.WriteLine("Success!");
    }
    Console.WriteLine();
}</pre>			<p>We get the path of the <code>data/proposals</code> folder that contains our proposals. Each proposal is a subfolder of that folder. We iterate over each of the subfolders of the <code>data/proposal</code> folder and call our pipeline. If we don’t find any errors, we print <code>Success</code>. Otherwise, we list the errors we found.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>We start by <a id="_idIndexMarker364"/>creating our kernel, adding the GPT-4 service to it, and adding <a id="_idIndexMarker365"/>all the native and semantic plugins to it:</p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from CheckSpreadsheet import CheckSpreadsheet
from ParseWordDocument import ParseWordDocument
from Helpers import Helpers
import os
async def pipeline(kernel, function_list, input):
    for function in function_list:
        args = KernelArguments(input=input)
        input = await kernel.invoke(function, args)
    return input
async def main():
    kernel = sk.Kernel()
    api_key, org_id = sk.openai_settings_from_dot_env()
    gpt4 = OpenAIChatCompletion("gpt-4", api_key, org_id)
    kernel.add_chat_service("gpt4", gpt4)
    parse_word_document = kernel.import_skill(ParseWordDocument())
    check_spreadsheet = kernel.import_skill(CheckSpreadsheet())
    helpers = kernel.import_skill(Helpers())
    interpret_document = kernel.import_semantic_skill_from_directory("../../plugins", "ProposalCheckerV2")</pre>			<p>Note that <a id="_idIndexMarker366"/>we added the pipeline function that we created in the previous section.</p>
			<p>The final <a id="_idIndexMarker367"/>step is to create a function list and call the pipeline for each document:</p>
			<pre class="source-code">
    data_path = "../../data/proposals/"
    for folder in os.listdir(data_path):
        if not os.path.isdir(os.path.join(data_path, folder)):
            continue
        print(f"\n\nProcessing folder: {folder}")
        function_list = [
            helpers['ProcessProposalFolder'],
            check_spreadsheet['CheckTabs'],
            check_spreadsheet['CheckCells'],
            check_spreadsheet['CheckValues'],
            parse_word_document['ExtractTeam'],
            interpret_document['CheckTeamV2'],
            parse_word_document['ExtractExperience'],
            interpret_document['CheckPreviousProjectV2'],
            parse_word_document['ExtractImplementation'],
            interpret_document['CheckDatesV2']
        ]
        process_result = await pipeline(kernel, function_list, os.path.join(data_path, folder))
        result = (str(process_result))
        if result.startswith("Error"):
            print(result)
            continue
        else:
            print("Success")</pre>			<p>The full pipeline <a id="_idIndexMarker368"/>obtains the expected results, with the proposals that <a id="_idIndexMarker369"/>fulfill all the requirements returning success and the proposals with problems returning an error message describing the problem.</p>
			<p>The results are displayed here:</p>
			<pre class="console">
Processing folder: correct
Success
Processing folder: incorrect01
Error: the spreadsheet does not contain the correct tabs
Processing folder: incorrect02
Error: Sum of values in year 2025 exceeds 1,000,000.
Processing folder: incorrect03
Error: More than 10% growth found from B2 to B3 in sheet 2024.
Processing folder: incorrect04
Error: non-numeric inputs
Processing folder: incorrect05
Error: No Word document found
Processing folder: incorrect06
Error: No Excel spreadsheet found
Processing folder: incorrect07
Error: Not enough experience.
Processing folder: incorrect08
Error: Team does not meet requirements.
Processing folder: incorrect09
Error: dates out of range
Processing folder: incorrect10
Error: multiple files found</pre>			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Summary</h1>
			<p>Before having the help of AI, reading and interpreting a document required using the time of a person, or writing a specialized machine learning model. Semantic Kernel allows you to write code to analyze large and complex documents.</p>
			<p>In our pipeline, the <code>CheckSpreadsheet</code> native plugin does not strictly require Semantic Kernel and could be done in a separate step, since it only runs code that is never read by AI. We added it to the pipeline to make our end-to-end solution more streamlined.</p>
			<p>The <code>ParseWordDocument</code> native plugin, on the other hand, helps Semantic Kernel receive the information in parts. Breaking the document into parts makes the semantic functions simpler: each function can evaluate just a portion of the document. For example, the function that evaluates the <em class="italic">Teams</em> section of the document just needs to check the team qualifications. That makes the function a lot simpler to write than a function that reads the whole document and decides about all sections of the document in a single step.</p>
			<p>The real value that AI adds to this process, therefore, is in the semantic plugin. The tasks of evaluating sections of the document that are implemented by the semantic functions in the <code>ProposalCheckerV2</code> plugin are the ones that would formerly require either a lot of human effort or a specialized machine learning model. This chapter showed how to execute these tasks just by describing what the requirements were in three short <code>skprompt.txt</code> files.</p>
			<p>In this chapter, we created our pipeline manually, explicitly naming the functions that we wanted to call and in which order. In the next chapter, we will learn how to use a planner. The planner will receive the user request and decide which functions to call and in which order.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>References</h1>
			<p class="Bibliography">[1] A. S. Luccioni, Y. Jernite, and E. Strubell, “Power Hungry Processing: Watts Driving the Cost of AI Deployment?” arXiv, Nov. 28, 2023. doi: 10.48550/arXiv.2311.16863.</p>
		</div>
	</div>
</div>
</body></html>