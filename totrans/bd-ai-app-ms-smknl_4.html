<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer031">
			<h1 id="_idParaDest-87" class="chapter-number"><a id="_idTextAnchor086"/>4</h1>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Performing Complex Actions by Chaining Functions</h1>
			<p>In the previous chapter, we learned how to create native plugins, which we used to check the format of Excel and Word documents, and semantic plugins, which we used to verify whether the content of the documents fulfilled <span class="No-Break">our requirements.</span></p>
			<p>In this chapter, we will start by creating a simple pipeline that generates images. The pipeline will receive a text with clues about an animal and will then generate a text that guesses the animal from the clues, as well as generating a picture of <span class="No-Break">the animal.</span></p>
			<p>Later in the chapter, we will continue the application of the previous chapter: verifying whether grant requests fulfill some requirements. For that application, a grant request will come with two files inside a folder: a Word document and an <span class="No-Break">Excel spreadsheet.</span></p>
			<p>Our application checks that the Word document contains a proposal for a vaccination campaign, including the team who will perform it and their experience, and an Excel file that contains <span class="No-Break">its budget.</span></p>
			<p>This type of scenario is common in enterprises: governments and corporations must prioritize requests for projects, editors must approve or reject book proposals, and lawyers must verify that the documents they are filing in court fulfill legal requirements. It’s not uncommon to have to verify thousands or tens of thousands of documents. This is a kind of job that, until recently, was done manually. We’re going to write a pipeline that <span class="No-Break">automates it.</span></p>
			<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating a native plugin that <span class="No-Break">generates images</span></li>
				<li>Chaining a semantic plugin that outputs text with the native plugin that <span class="No-Break">generates images</span></li>
				<li>Running a complex, <span class="No-Break">multistep pipeline</span></li>
			</ul>
			<p>By the end of the chapter, you will have the tools required to build a kernel that can perform many coordinated functions, and that can be used as a copilot or be integrated into other tools, such as <span class="No-Break">a planner.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have a recent, supported version of your preferred Python or C# <span class="No-Break">development environment:</span></p>
			<ul>
				<li>For Python, the minimum supported version is Python 3.10, and the recommended version is <span class="No-Break">Python 3.11</span></li>
				<li>For C#, the minimum supported version is .<span class="No-Break">NET 8</span></li>
			</ul>
			<p>In this chapter, we will call OpenAI services. Given the amount that companies spend on training these LLMs, it’s no surprise that using these services is not free. You will need an <strong class="bold">OpenAI API</strong> key, either directly through <strong class="bold">OpenAI</strong> or <strong class="bold">Microsoft</strong>, via the <strong class="bold">Azure </strong><span class="No-Break"><strong class="bold">OpenAI</strong></span><span class="No-Break"> service.</span></p>
			<p>If you are using .NET, the code for this chapter is <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4"><span class="No-Break">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4</span></a><span class="No-Break">.</span></p>
			<p>If you are using Python, the code for this chapter is <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4"><span class="No-Break">https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4</span></a><span class="No-Break">.</span></p>
			<p>You can install the required packages by going to the GitHub repository and using the following: <strong class="source-inline">pip install -</strong><span class="No-Break"><strong class="source-inline">r requirements.txt</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Creating a native plugin that generates images</h1>
			<p>To learn about the power of chaining functions, we are going to create functions that perform <a id="_idIndexMarker284"/>very different actions. We will start by <a id="_idIndexMarker285"/>creating functions that generate images and putting them in a plugin. Then, we’re going to learn how to incorporate these functions into a more <span class="No-Break">complex chain.</span></p>
			<p>In some applications, you may want to generate an image with AI. For example, social media posts with images tend to get more engagement, but creating images without AI or finding images can be time-consuming <span class="No-Break">and expensive.</span></p>
			<p>Compared to market prices of non-AI images, generating images with AI is very cheap. On the other hand, generating images is still one of the most compute-intensive activities that can be done with AI. Recent research from Hugging Face [1] has shown that generating <a id="_idIndexMarker286"/>an image is 2,000 times <a id="_idIndexMarker287"/>more expensive in terms of carbon emissions than generating a text answer. These costs will be passed down <span class="No-Break">to you.</span></p>
			<p class="callout-heading">Costs of OpenAI image generation</p>
			<p class="callout">If you want to reproduce the content in this section, be aware that image generation is far more costly than text generation. You will need an API key, and each image generation costs $0.04 per image for the following examples, and up to $0.12 per image if you want to create higher-quality images with <span class="No-Break">higher resolutions.</span></p>
			<p class="callout">Prices change frequently, and you can check the latest prices <span class="No-Break">at</span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://openai.com/pricing"><span class="No-Break">https://openai.com/pricing</span></a><span class="No-Break">.</span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>, we show two examples of images generated with AI that I have created to enhance a couple of my social media posts. The first, me as a cowboy, was for a post about billionaires using cowboy hats. The second, with me as a character on the cover of a romantic novel, was for a post about writing fiction. Each image took less than a minute to generate with AI. I ran a test in Threads, Instagram’s new microblogging app where I have over 10,000 followers, and the image posts had multiple times more engagement than posts with the same text but <span class="No-Break">no image.</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B21826_04_1.jpg" alt="Figure 4.1 – Images generated with AI for social media posts" width="1117" height="557"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Images generated with AI for social media posts</p>
			<p>Image <a id="_idIndexMarker288"/>generation support in Microsoft <a id="_idIndexMarker289"/>Semantic Kernel is not consistent. The C# API has an object called <strong class="source-inline">TextToImage</strong> that can generate images using DALL-E 2, a model released in November 2022, but that API is not available for Python. That image-generating model is now obsolete, having been superseded by DALL-E 3 in October of 2023; however, at the time of writing, Semantic Kernel does not offer an out-of-the-box way to access <span class="No-Break">DALL-E 3.</span></p>
			<p>We will create two native plugins, one for C# and one for Python, that allow us to access DALL-E 3 from <span class="No-Break">Semantic Kernel.</span></p>
			<p class="callout-heading">Adding new models to the kernel</p>
			<p class="callout">Although we are using DALL-E 3, as an interesting and novel model, as the example that we are adding to the kernel, this approach of creating a native plugin wrapper works for any model that has an API, including Claude from Anthropic, Gemini from Google, and hundreds of models from Hugging Face. Any AI service that is made available through a REST API can be added in <span class="No-Break">this way.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Writing a DALL-E 3 wrapper in Python</h2>
			<p>It is easier to write a DALL-E 3 wrapper in Python than in C# because OpenAI offers and supports <a id="_idIndexMarker290"/>a Python package called openai that <a id="_idIndexMarker291"/>allows developers to access any new OpenAI function as soon <a id="_idIndexMarker292"/>as it’s made available. All we must do is create <a id="_idIndexMarker293"/>a native function that uses the OpenAI package and send a request to <span class="No-Break">DALL-E 3:</span></p>
			<pre class="source-code">
from dotenv import load_dotenv
from openai import OpenAI
import os
from semantic_kernel.skill_definition import kernel_function
class Dalle3:
    @kernel_function(
        description="Generates an with DALL-E 3 model based on a prompt",
        name="ImageFromPrompt",
        input_description="The prompt used to generate the image",
    )
    def ImageFromPrompt(self, input: str) -&gt; str:
        load_dotenv()
        client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))</pre>			<p>As we saw in <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we declare a native function using the <strong class="source-inline">kernel_function</strong> decorator. We then simply instantiate an OpenAI client object with our <span class="No-Break">API key.</span></p>
			<p>Now let’s submit <span class="No-Break">the request:</span></p>
			<pre class="source-code">
        response = client.images.generate(
            model="dall-e-3",
            prompt=input,
            size="1024x1024",
            quality="standard",
            n=1,
        )
        image_url = response.data[0].url
        return image_url</pre>			<p>The <a id="_idIndexMarker294"/>Python OpenAI client contains the <strong class="source-inline">images.generate</strong> method, which will call DALL-E 3 and return the generated URL. We <a id="_idIndexMarker295"/>simply call it and return <span class="No-Break">the URL.</span></p>
			<p>Now, we <a id="_idIndexMarker296"/>are going to create a simple script that instantiates the plugin and <span class="No-Break">calls it:</span></p>
			<pre class="source-code">
import asyncio
import semantic_kernel as sk
from OpenAiPlugins import Dalle3
async def main():
    kernel = sk.Kernel()
    animal_str = "A painting of a cat sitting in a sofa in the impressionist style"
    dalle3 = kernel.import_skill(Dalle3())
    animal_pic_url = await kernel.run_async(
        dalle3['ImageFromPrompt'],
        input_str=animal_str
    )
    print(animal_pic_url)
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>The <a id="_idIndexMarker297"/>preceding code instantiates <a id="_idIndexMarker298"/>the <strong class="source-inline">Dalle3</strong> native plugin <a id="_idIndexMarker299"/>and calls its <strong class="source-inline">ImageFromPrompt</strong> function with the <strong class="source-inline">"A painting of a cat sitting on a sofa in the impressionist style"</strong> input parameter. An example output is in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B21826_04_2.jpg" alt="Figure 4-2 – A cat in the impressionist style generated by DALL-E 3 by Python" width="807" height="807"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – A cat in the impressionist style generated by DALL-E 3 by Python</p>
			<p>Now that we have seen how to do this in Python, let’s see how to do it <span class="No-Break">in C#.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Writing a DALL-E 3 wrapper in C#</h2>
			<p>OpenAI does not provide a supported package for C# that allows users of that language to interact <a id="_idIndexMarker300"/>with its service. The best way of interacting <a id="_idIndexMarker301"/>with the OpenAI service for C# users is <a id="_idIndexMarker302"/>to use Microsoft Semantic Kernel, which has a <strong class="source-inline">TextToImage</strong> functionality, but at the time of writing, it only provides connectivity to <span class="No-Break">DALL-E 2.</span></p>
			<p>Most AI services will expose a REST API. Therefore, to connect Microsoft Semantic Kernel to them, one solution is to write a native plugin that wraps the REST API. We show how to do this for DALL-E <span class="No-Break">3 here:</span></p>
			<pre class="source-code">
using System.ComponentModel;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using Microsoft.SemanticKernel;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
namespace Plugins;
public class Dalle3
{
    [KernelFunction, Description("Generate an image from a prompt")]
    async public Task&lt;string&gt; ImageFromPrompt([Description("Prompt describing the image you want to generate")] string prompt)
    {</pre>			<p>Making a REST <strong class="source-inline">POST</strong> request requires several packages, such as <strong class="source-inline">System.Text.Json</strong> and <strong class="source-inline">System.Net</strong>. Like what we did in <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we use a decorator, <strong class="source-inline">KernelFunction</strong>, to signal that the function is accessible to Semantic Kernel, and a <strong class="source-inline">Description</strong> attribute to describe what our <span class="No-Break">function does.</span></p>
			<p>We then <a id="_idIndexMarker303"/>create an <strong class="source-inline">HttpClient</strong> object. This object <a id="_idIndexMarker304"/>will make a REST API call. We need to set it <a id="_idIndexMarker305"/>up with our API key as a <strong class="source-inline">Bearer</strong> token and set its header as accepting “<strong class="source-inline">application/json</strong>” because that’s how the OpenAI API <span class="No-Break">will respond:</span></p>
			<pre class="source-code">
        HttpClient client = new HttpClient
        {
            BaseAddress = new Uri("https://api.openai.com/v1/")
        };
        var (apiKey, orgId) = Settings.LoadFromFile();
        client.DefaultRequestHeaders
            .Accept
            .Add(new MediaTypeWithQualityHeaderValue("application/json"));
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", apiKey);
        client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));</pre>			<p>The next step is to submit the <strong class="source-inline">POST</strong> request to <span class="No-Break">the API:</span></p>
			<pre class="source-code">
        var obj = new {
            model = "dall-e-3",
            prompt = prompt,
            n = 1,
            size = "1024x1024"};
        var content = new StringContent(JsonSerializer.Serialize(obj), Encoding.UTF8, "application/json");
        var response  = await client.PostAsync("images/generations", content);</pre>			<p>We created <a id="_idIndexMarker306"/>a JSON object, <strong class="source-inline">obj</strong>, using the fields that <a id="_idIndexMarker307"/>are required by the OpenAI API. The <strong class="source-inline">model</strong> field states <a id="_idIndexMarker308"/>what model we’re using, and here we make sure to specify <strong class="source-inline">"dall-e-3"</strong> to use DALL-E 3. The documentation of all the possible parameters can be found <span class="No-Break">here: </span><a href="https://platform.openai.com/docs/api-reference/images/create"><span class="No-Break">https://platform.openai.com/docs/api-reference/images/create</span></a><span class="No-Break">.</span></p>
			<p>The final step is to recover the <strong class="source-inline">url</strong> field from the JSON returned by OpenAI. That <strong class="source-inline">url</strong> field points to <span class="No-Break">the image:</span></p>
			<pre class="source-code">
        if (!response.IsSuccessStatusCode)
        {
            return $"Error: {response.StatusCode}";
        }
        string jsonString = await response.Content.ReadAsStringAsync();
        using JsonDocument doc = JsonDocument.Parse(jsonString);
        JsonElement root = doc.RootElement;
        return root.GetProperty("data")[0]!.GetProperty("url")!.GetString()!;
    }
}</pre>			<p>Next, let’s <a id="_idIndexMarker309"/>see how <a id="_idIndexMarker310"/>to call <a id="_idIndexMarker311"/><span class="No-Break">the plugin:</span></p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using Plugins;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.Plugins.AddFromType&lt;Dalle3&gt;();
var kernel = builder.Build();
string prompt = "A cat sitting on a couch in the style of Monet";
string? url = await kernel.InvokeAsync&lt;string&gt;(
    "Dalle3", "ImageFromPrompt", new() {{ "prompt", prompt }}
);
Console.Write(url);</pre>			<p>To call <a id="_idIndexMarker312"/>the plugin, we added a reference to the <a id="_idIndexMarker313"/>source file, <strong class="source-inline">Plugins</strong>, instantiated <a id="_idIndexMarker314"/>the <strong class="source-inline">Dalle3</strong> plugin with <strong class="source-inline">AddFromType</strong>, and called its <strong class="source-inline">ImageFromPrompt</strong> method, passing <strong class="source-inline">prompt</strong> as <span class="No-Break">a parameter.</span></p>
			<p>The resulting picture is <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21826_04_3.jpg" alt="Figure 4.3 – A cat in the impressionist style generated by the C# native plugin" width="965" height="915"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – A cat in the impressionist style generated by the C# native plugin</p>
			<p>Now that we have created a function that accesses a new service, let’s incorporate it into a solution that <span class="No-Break">uses it.</span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Using multiple steps to solve a problem</h1>
			<p>Although programming solutions step by step can be very helpful, one of the best abilities that Semantic Kernel gives users is allowing them to make requests using natural language. This will <a id="_idIndexMarker315"/>require using <strong class="bold">planners</strong>, which we will use in <a href="B21826_05.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, to break down a user request into multiple steps and then automatically call each step in the <span class="No-Break">appropriate order.</span></p>
			<p>In this section, we will <a id="_idIndexMarker316"/>solve problems by telling Semantic Kernel which functions to call. This is helpful for making sure that the solutions we make available to the planner work, and it is also helpful when we want to explicitly control how things <span class="No-Break">are executed.</span></p>
			<p>To illustrate the manual approach, we will see how to give Semantic Kernel clues about an animal, guess it with a semantic function, and then generate an image of the animal using the native function we created in the <span class="No-Break">previous section.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Generating an image from a clue</h2>
			<p>In the <a id="_idIndexMarker317"/>following code, we have two steps. In the first step, we will use GPT-3.5 to guess an animal from clues. To do that, we will create a semantic plugin <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">AnimalGuesser</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Important: Using OpenAI services is not free</p>
			<p class="callout">The semantic functions will call the OpenAI API. These calls require a paid subscription, and each call will incur a cost. The costs are usually small per request. GPT 3.5 costs $0.0002 per thousand tokens, but they may add up if you make a large number of calls. Prices change frequently, so make sure to check the latest prices on the <span class="No-Break">following websites:</span></p>
			<p class="callout">OpenAI <span class="No-Break">pricing: </span><a href="https://openai.com/pricing"><span class="No-Break">https://openai.com/pricing</span></a></p>
			<p class="callout">Azure OpenAI <span class="No-Break">pricing: </span><a href="https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/"><span class="No-Break">https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/</span></a></p>
			<p>The semantic <a id="_idIndexMarker318"/>plugin, as always, consists of two files, <strong class="source-inline">config.json</strong> and <strong class="source-inline">skprompt.txt</strong>, listed <span class="No-Break">as follows:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">config.json</p>
			<pre class="source-code">
{
    "schema": 1,
    "name": "GuessAnimal",
    "type": "completion",
    "description": "Given a text with clues, guess the animal",
    "execution_settings": {
        "default": {
            "temperature": 0.8,
            "number_of_responses": 1,
            "top_p": 1,
            "max_tokens": 4000,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0
        }
    },
    "input_variables": [
        {
            "name": "input",
            "description": "CLues about an animal",
            "required": true
        }
    ]
}</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">skprompt.txt</p>
			<pre class="source-code">
Below, there's a list of clues about an animal.
{{$input}}
From the clues above, guess what animal it is.
Provide your answer in a single line, containing just the name of the animal.</pre>			<p>As we <a id="_idIndexMarker319"/>always do, we must make sure that the <strong class="source-inline">description</strong> fields in the <strong class="source-inline">config.json</strong> files are set correctly. This will not have any effect now, but when we start using the planner or letting Semantic Kernel automatically call functions, the kernel will use the <strong class="source-inline">description</strong> fields to figure out what each function does and decide which ones <span class="No-Break">to call.</span></p>
			<p>For now, let’s see how to tell the kernel to call functions <span class="No-Break">in sequence.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Chaining semantic and native functions with C#</h2>
			<p>In C#, you need to use the <strong class="source-inline">KernelFunctionCombinators</strong> class to create a function <a id="_idIndexMarker320"/>pipeline. The code for the <a id="_idIndexMarker321"/>class is provided in the GitHub repository. </p>
			<p>The code for implementing a function <span class="No-Break">pipeline follows:</span></p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using Plugins;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.Plugins.AddFromType&lt;Dalle3&gt;();
builder.AddOpenAIChatCompletion("gpt-3.5-turbo", apiKey, orgId);
var kernel = builder.Build();
KernelPlugin animalGuesser = kernel.ImportPluginFromPromptDirectory("../../../plugins/AnimalGuesser");
string clues = "It's a mammal. It's a pet. It meows. It purrs.";</pre>			<p>In the <a id="_idIndexMarker322"/>preceding snippet, we create <a id="_idIndexMarker323"/>our kernel, add an OpenAI service to it, and add the <strong class="source-inline">AnimalGuesser</strong> and <strong class="source-inline">Dalle3</strong> plugins <span class="No-Break">to it.</span></p>
			<p>Next, we assign the functions we want to call, <strong class="source-inline">AnimalGuesser.GuessAnimal</strong> and <strong class="source-inline">Dalle3.ImageFromPrompt</strong>, to <span class="No-Break"><strong class="source-inline">KernelFunction</strong></span><span class="No-Break"> variables:</span></p>
			<pre class="source-code">
KernelFunction guessAnimal = animalGuesser["GuessAnimal"];
KernelFunction generateImage = kernel.Plugins["Dalle3"]["ImageFromPrompt"];
KernelFunction pipeline = KernelFunctionCombinators.Pipe(new[] {
    guessAnimal,
    generateImage
}, "pipeline");</pre>			<p>Lastly, we create a <strong class="source-inline">KernelArguments</strong> object called <strong class="source-inline">context</strong> and pass it as a parameter <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">InvokeAsync</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
KernelArguments context = new() { { "input", clues } };
Console.WriteLine(await pipeline.InvokeAsync(kernel, context));</pre>			<p>The attributes of the <strong class="source-inline">context</strong> object must match what the first function is expecting. In our <a id="_idIndexMarker324"/>case, the <strong class="source-inline">AnimalGuesser.GuessAnimal</strong> function expects a parameter named <strong class="source-inline">input</strong>. From <a id="_idIndexMarker325"/>then on, the pipeline will call each function, get the output as a text string, and pass that text string as the first parameter to the next function. In our case, even though the first parameter of the <strong class="source-inline">Dalle3.ImageFromPrompt</strong> function is called <strong class="source-inline">prompt</strong> instead of <strong class="source-inline">input</strong>, the call is still going to work. You only need to provide the correct name for the parameter used in the first step of <span class="No-Break">the pipeline.</span></p>
			<p>If you run the preceding program, you will get a picture of <span class="No-Break">a cat:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21826_04_4.jpg" alt="Figure 4.4 – Picture of a cat generated from AI guessing the animal from clues" width="950" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Picture of a cat generated from AI guessing the animal from clues</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Chaining semantic and native functions with Python</h2>
			<p>As we <a id="_idIndexMarker326"/>did in C#, let’s use Python <a id="_idIndexMarker327"/>to create a script that starts from a list of clues, guesses the animal that the clues refer to, and then generates a picture of <span class="No-Break">the animal.</span></p>
			<p>We will build on the plugins we already have. We will reuse the native plugin that we created to generate images using <span class="No-Break">DALL-E 3.</span></p>
			<p>One new thing is that we are going to create a function called <strong class="source-inline">pipeline</strong> that receives a list of functions and an input parameter and then calls each function in the list, passing the output of the call as the input parameter of the next function in <span class="No-Break">the list.</span></p>
			<p>The definition of the function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
async def pipeline(kernel, function_list, input):
    for function in function_list:
        args = KernelArguments(input=input)
        input = await kernel.invoke(function, args)
    return input</pre>			<p>We start <a id="_idIndexMarker328"/>as we always do, creating <a id="_idIndexMarker329"/>a kernel and adding an AI service to it. Here, we are assigning the plugins to variables, which will enable us to reference functions in the <span class="No-Break">next step:</span></p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from OpenAiPlugins import Dalle3
async def main():
    kernel = sk.Kernel()
    api_key, org_id = sk.openai_settings_from_dot_env()
    gpt35 = OpenAIChatCompletion("gpt-3.5-turbo", api_key, org_id)
    kernel.add_chat_service("gpt35", gpt35)
    generate_image_plugin = kernel.import_skill(Dalle3())
    animal_guesser = kernel.import_semantic_skill_from_directory("../../plugins", "AnimalGuesser")</pre>			<p>With that, we can now give our model the clues and ask it <span class="No-Break">to guess:</span></p>
			<pre class="source-code">
    clues = """
    I am thinking of an animal.
    It is a mammal.
    It is a pet.
    It is a carnivore.
    It purrs."""
    function_list = [
        animal_guesser['GuessAnimal'],
        generate_image_plugin['ImageFromPrompt']
    ]
    animal_pic_url = await pipeline(kernel, function_list, clues)
    print(animal_pic_url)
if __name__ == "__main__":
    asyncio.run(main())</pre>			<p>As seen <a id="_idIndexMarker330"/>in the preceding <a id="_idIndexMarker331"/>snippet, to run the pipeline, we create the list of functions we want to call in order, adding it to the <strong class="source-inline">function_list</strong> variable, and then call the <strong class="source-inline">pipeline</strong> function. The <strong class="source-inline">pipeline</strong> function will run the first function with the input parameter you passed, then it will use the output of the first function as the parameter of the second function, and <span class="No-Break">so on.</span></p>
			<p>Like what happened in the C# example, the output will be a URL pointing to a freshly generated picture of a cat (<span class="No-Break">not displayed).</span></p>
			<p>Now that we’re done with a simple example of a pipeline, let’s go back to the problem we were solving in <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> and described in the introduction of this chapter: verifying whether a proposal for a vaccination campaign fulfills the <span class="No-Break">basic requirements.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Dealing with larger, more complex chains</h1>
			<p>In the previous chapter, we created <span class="No-Break">three plugins:</span></p>
			<ul>
				<li><strong class="source-inline">CheckSpreadsheet</strong>: A native <a id="_idIndexMarker332"/>plugin that checks that the Excel spreadsheet contains the required fields and that they fulfill <span class="No-Break">some rules</span></li>
				<li><strong class="source-inline">ParseWordDocument</strong>: A native <a id="_idIndexMarker333"/>plugin that extracts text from a <span class="No-Break">Word document</span></li>
				<li><strong class="source-inline">ProposalChecker</strong>: A semantic plugin that checks whether text blocks fulfill some <a id="_idIndexMarker334"/>requirements, such as “<em class="italic">does this text block describe a team that has a Ph.D. and a </em><span class="No-Break"><em class="italic">medical doctor</em></span><span class="No-Break">?”</span></li>
			</ul>
			<p>With these three plugins, you can already solve the business problem of checking proposals by calling each plugin separately and writing the logic to handle whether there was an error. This is likely sufficient for problems that have a small number <span class="No-Break">of steps.</span></p>
			<p>While we are still going to use a small number of steps and a small number of documents for didactic purposes, the approach to analyzing and making decisions on a large number of documents presented in this chapter excels when there are many steps and many documents <span class="No-Break">to process.</span></p>
			<p>Let’s see how to <span class="No-Break">implement it.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Preparing our directory structure</h2>
			<p>Before we start, we need <a id="_idIndexMarker335"/>to make sure that we have the data for the proposals loaded in the <strong class="source-inline">data/proposals</strong> folder. We will also reuse the native plugins by putting them in the same directory as our main program. The semantic plugins will be in the <span class="No-Break"><strong class="source-inline">plugins</strong></span><span class="No-Break"> directory.</span></p>
			<p>We will modify our native and semantic functions slightly from what we did in the previous chapter. The main change is that we will introduce error handling directly into the semantic functions, which will enable us to process many documents with a <span class="No-Break">single call.</span></p>
			<p>Below is the <a id="_idIndexMarker336"/>directory structure of our solution. Each proposal is represented by a directory in the <strong class="source-inline">proposals</strong> directory, and each directory should contain exactly two files, one Excel file with the extension <strong class="source-inline">.xlsx</strong> and one Word file with the <span class="No-Break">extension </span><span class="No-Break"><strong class="source-inline">.docx</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
└───data
    └───proposals
    |   |───correct
    |   |    ├───correct.docx
    |   |    └───correct.xlsx
    |   ├───incorrect01
    |   |    ├───missing_experience.docx
    |   |    └───incorrect_template.xlsx
    |   ├───incorrect02
    |   |    ├───missing_qualifications.docx
    |   |    └───over_budget.xlsx
    |   └───(...)
    |   ├─── incorrect10
    └───plugins
         └───ProposalCheckerV2
              ├───CheckDatesV2
              |     ├───skprompt.txt
              |     └───config.json
              ├───CheckPreviousProjectV2
              |     ├───skprompt.txt
              |     └───config.json
              └───CheckTeamV2
                    ├───skprompt.txt
                    └───config.json
└───ch4
    └───code
          ├───python
          |    ├───ch4.py
          |    ├───ParseWordDocument.py
          |    └───CheckSpreadsheet.py
          └───dotnet
               ├───Program.cs
               ├───ParseWordDocument.cs
              └───CheckSpreadsheet.cs</pre>			<p>This follows <a id="_idIndexMarker337"/>the same structure we used earlier: a main file containing the code (<strong class="source-inline">ch4.py</strong> or <strong class="source-inline">Program.cs</strong>), additional files in the same directory, each containing a native plugin (<strong class="source-inline">ParseWordDocument</strong> and <strong class="source-inline">CheckSpreadsheet</strong>), and all the semantic plugins in a dedicated directory, <strong class="source-inline">plugins</strong>. We separate folders by language because that makes it simpler to manage the virtual environments that hold installed packages by folder. Semantic plugins are language-independent and can have their <span class="No-Break">own directory.</span></p>
			<p>Now that we have described the expected directory structure, let’s look at the high-level flow of <span class="No-Break">our process.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Understanding the flow of our process</h2>
			<p>We will start by writing a native <a id="_idIndexMarker338"/>plugin called <strong class="source-inline">Helpers</strong> that contains a native <a id="_idIndexMarker339"/>function called <strong class="source-inline">ProcessProposalFolder</strong>, which when given a path that represents a folder, checks whether it contains exactly one Excel file and a Word document. If it does, it returns the path of the folder, if not, it returns a string with <span class="No-Break">an error.</span></p>
			<p>Once we create the <strong class="source-inline">Helpers</strong> plugin, we will be almost ready to call the functions we developed in <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. We will make two modifications to the existing files <strong class="source-inline">ParseWordDocument</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">CheckSpreadsheet</strong></span><span class="No-Break">.</span></p>
			<p>One modification we will make to both files will be to check if the input is an error state. If it is, we simply pass the error state forward. If we are not in an error state, we keep passing the folder <a id="_idIndexMarker340"/>path forward. We will need to make these simple modifications to all the native functions and <span class="No-Break">semantic functions.</span></p>
			<p>The second and last modification will be to the <strong class="source-inline">ParseWordDocument</strong> native plugin. We will add three separate helper functions, each one parsing one of the three different required sections of the document (<strong class="source-inline">Team</strong>, <strong class="source-inline">Experience</strong>, and <strong class="source-inline">Implementation </strong>details). The new functions will simply call the existing function with a parameter representing one section <span class="No-Break">per function.</span></p>
			<p>The reason for doing all of this is to only have functions with a single parameter in the pipeline. This enables the return of each function to be passed as a parameter to the next function, which will make things <span class="No-Break">much simpler.</span></p>
			<p>The full pipeline, with 10 steps, is represented in the <span class="No-Break">next diagram.</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B21826_04_5.jpg" alt="Figure 4.5 – Visual representation of the pipeline" width="827" height="403"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Visual representation of the pipeline</p>
			<p>In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.5</em>, orange boxes represent native functions that deal with the filesystem, green boxes represent native functions that deal with Excel, blue boxes represent native functions that <a id="_idIndexMarker341"/>deal with Word, and purple boxes represent <span class="No-Break">semantic functions.</span></p>
			<p>Now that we understand all the steps for the pipeline, let’s create the new plugin and function and make the <span class="No-Break">required modifications.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Creating the native function to process a folder</h2>
			<p>To get the pipeline started, we need a plugin that ensures that the folder that we want to process <a id="_idIndexMarker342"/>contains the correct files. Since this is an activity that requires interacting with the operating system, we need to create a native function, which we will host inside a plugin we will <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">Helpers</strong></span><span class="No-Break">.</span></p>
			<p>The code for the plugin is <span class="No-Break">as follows:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
public class Helpers
{
    [KernelFunction, Description("Checks that the folder contains one Word and one Excel file")]
    public static string ProcessProposalFolder([Description("Folder potentially containing")] string folderPath)
    {</pre>			<p>As usual, since we <a id="_idIndexMarker343"/>want this function to be available to Semantic Kernel, we use the <strong class="source-inline">KernelFunction</strong> decorator and the descriuption of what the function does under the <span class="No-Break"><strong class="source-inline">Description</strong></span><span class="No-Break"> variable.</span></p>
			<p>Now, we are simply going to count the number of files available in the folder. Remember that we want exactly one file with the <strong class="source-inline">.docx</strong> extension and one file with the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xlsx</strong></span><span class="No-Break"> extension:</span></p>
			<pre class="source-code">
        string result = folderPath;
        if (!Directory.Exists(folderPath))
        {
            return "Error: Folder does not exist";
        }
        var files = Directory.GetFiles(folderPath);
        int wordCount = files.Count(f =&gt; Path.GetExtension(f).ToLower() == ".docx");
        int excelCount = files.Count(f =&gt; Path.GetExtension(f).ToLower() == ".xlsx");
        if (wordCount == 1 &amp;&amp; excelCount == 1)
        {
            return result;
        }
        else if (wordCount == 0 &amp;&amp; excelCount == 0)
        {
            return "Error: Folder does not contain one Word and one Excel file";
        }
        else if (wordCount == 0)
        {
            return "Error: Folder missing Word file";
        }
        else if (excelCount == 0)
        {
            return "Error: Folder missing Excel file";
        }
        return "Error: Folder contains more than one Word or Excel file";
    }
}</pre>			<p>The logical part of the function is very simple. It counts the number of files with the <strong class="source-inline">.docx</strong> and <strong class="source-inline">.xlsx</strong> extensions in the directory. If the directory has one of each, the call succeeded. We signal success by passing the folder as the return result. In any other situation, we generate a string with an error message. We will use the convention that error messages in this pipeline start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Error</strong></span><span class="No-Break">.</span></p>
			<p>Let’s now <a id="_idIndexMarker344"/>check out the code for the plugin <span class="No-Break">in Python:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
from typing_extensions import Annotated
from semantic_kernel.functions.kernel_function_decorator import kernel_function
import os
class Helpers:
    @kernel_function(
        description="Checks that the folder contains the expected files, an Excel spreadsheet and a Word document",
        name="ProcessProposalFolder"
    )
    def ProcessProposalFolder(self, input: Annotated[str, "The file path to the folder containing the proposal files"]) -&gt; str:</pre>			<p>In Python, we use the <strong class="source-inline">kernel_function</strong> decorator to indicate that this function can be used by Semantic Kernel. We also add an <strong class="source-inline">Annotated</strong> description to <span class="No-Break">the parameter.</span></p>
			<p>Then, the function code is very simple. Similar to the C# function above, we count how many files with the <strong class="source-inline">.docx</strong> and <strong class="source-inline">.xlsx</strong> extensions are in the directory. If there’s exactly one of each, we indicate success by returning the folder name. Anything else will result in a failure, which will be indicated by a string starting <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Error</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    def ProcessProposalFolder(self, folder_path: str) -&gt; str:
        xlsx_count = 0
        docx_count = 0
        for file in os.listdir(folder_path):
            if file.endswith(".xlsx"):
                xlsx_count += 1
            elif file.endswith(".docx"):
                docx_count += 1
        if xlsx_count == 1 and docx_count == 1:
            return "Success"
        elif xlsx_count == 0 and docx_count == 0:
            return "Error: No files found"
        elif xlsx_count == 0:
            return "Error: No Excel spreadsheet found"
        elif docx_count == 0:
            return "Error: No Word document found"
        else:
            return "Error: multiple files found"</pre>			<p>Now that <a id="_idIndexMarker345"/>we have the function to kick off the pipeline, let’s see what needs to be done with the plugins we wrote in <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> to make them usable for <span class="No-Break">this pipeline.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Modifying the Excel native plugin</h2>
			<p>We need <a id="_idIndexMarker346"/>to make a few changes to the Excel plugin we created for <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">:</span></p>
			<ul>
				<li>Standardize the error message to always start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Error</strong></span></li>
				<li>Standardize the success message to always return <span class="No-Break">the folder</span></li>
				<li>At the beginning of every function, if the input starts with <strong class="source-inline">Error</strong>, do nothing and simply pass the received <span class="No-Break">input forward</span></li>
			</ul>
			<p>To save space, the following code shows the changes to only one of the functions, <strong class="source-inline">CheckTabs</strong>. The full modified code is available in the <span class="No-Break">GitHub repository.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
    [KernelFunction, Description("Checks that the spreadsheet contains the correct tabs, 2024 and 2025")]
    public string CheckTabs([Description("The file path to the spreadsheet")] string folderPath)
    {
        if (folderPath.StartsWith("Error"))
        {
            return folderPath;
        }</pre>			<p>The preceding code checks if the input received contains an error. Since this is going to be used in a pipeline, any errors in previous steps will be <span class="No-Break">received here.</span></p>
			<p>If we get an error, we’re simply going to pass the error forward in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
        string filePath = GetExcelFile(folderPath);
        try
        {
            FileInfo fileInfo = new FileInfo(filePath);
            if (!fileInfo.Exists)
            {
                return "Error: File does not exist.";
            }</pre>			<p>Note that we are ensuring that any error message starts with <strong class="source-inline">Error</strong>, to make sure they’re easy to detect when they are received by other <span class="No-Break">pipeline functions.</span></p>
			<p>We now <a id="_idIndexMarker347"/>check how many sheets are in <span class="No-Break">the file:</span></p>
			<pre class="source-code">
            using (var package = new ExcelPackage(fileInfo))
            {
                ExcelPackage.LicenseContext = OfficeOpenXml.LicenseContext.NonCommercial;
                var workbook = package.Workbook;
                if (workbook.Worksheets.Count != 2)
                {
                    return "Error: Spreadsheet does not contain 2 tabs.";
                }
                if (workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2024") &amp;&amp; workbook.Worksheets.Any(sheet =&gt; sheet.Name == "2025"))
                {
                    return folderPath;
                }</pre>			<p>In the case of success, we simply pass the <span class="No-Break">folder forward.</span></p>
			<p>Otherwise, the following code passes the <span class="No-Break">error forward:</span></p>
			<pre class="source-code">
                else
                {
                    return "Error: Spreadsheet does not contain 2024 and 2025 tabs.";
                }
            }
        }
        catch (Exception ex)
        {
            return $"Error: An error occurred: {ex.Message}";
        }
    }</pre>			<p>Let’s see <a id="_idIndexMarker348"/>the changes in Python. To save space, we’re only showing the changes to the <strong class="source-inline">CheckTabs</strong> function. The full code for all functions is in the <span class="No-Break">GitHub repository.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
        @kernel_function(
        description="Checks that the spreadsheet contains the correct tabs, 2024 and 2025",
        name="CheckTabs",
    )
    def CheckTabs(self,
                  input: Annotated[str, "The path to the spreadsheet"]) -&gt; Annotated[str, "The result of the check"]:
        if path.startswith("Error"):
            return path</pre>			<p>If the <a id="_idIndexMarker349"/>previous function sent us an error, we simply pass <span class="No-Break">it forward.</span></p>
			<p>Otherwise, <span class="No-Break">we continue:</span></p>
			<pre class="source-code">
        try:
            filePath = self.GetExcelFile(path)
            workbook = openpyxl.load_workbook(filePath)
            sheet_names = workbook.sheetnames
            if sheet_names == ['2024', '2025']:
                return path</pre>			<p>To indicate success, we simply return the folder we received <span class="No-Break">as input:</span></p>
			<pre class="source-code">
            else:
                return "Error: the spreadsheet does not contain the correct tabs"
        except Exception as e:
            return f"Error: an exception {e} occurred when trying to open the spreadsheet"</pre>			<p>Now that we have standardized the input and output of the functions, it makes it easier to extend the pipeline, since all the functions expect the same input, a folder, and when the function succeeds, it simply passes the folder to the <span class="No-Break">next function.</span></p>
			<p>In the case of an error, the string passed as an input will start with <strong class="source-inline">Error</strong>, and all functions will simply pass it forward. These changes make it easier to change the order of steps and to add or <span class="No-Break">remove steps.</span></p>
			<p>Now that we’re done with the changes in the Excel plugin, let’s make changes to the <strong class="source-inline">ParseWordDocument</strong> plugin that extracts text from <span class="No-Break">Word documents.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Modifying the Word native plugin</h2>
			<p>The modifications to the Word native plugin are very simple. In <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, when we were <a id="_idIndexMarker350"/>calling the native plugin directly, we created a function called <strong class="source-inline">ExtractTextUnderHeading</strong> that received two parameters: a path to a file and the heading that we wanted to extract, and we called that function three times so that we could extract the text under the three headings <span class="No-Break">we wanted.</span></p>
			<p>In pipelines, since we can only have one parameter, we will create three functions named <strong class="source-inline">ExtractTeam</strong>, <strong class="source-inline">ExtractExperience</strong>, and <strong class="source-inline">ExtractImplementation</strong> that receive the folder as a parameter and call the <strong class="source-inline">ExtractTextUnderHeading</strong> function that we created in <a href="B21826_03.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> with the appropriate heading parameter, respectively <strong class="source-inline">"Team"</strong>, <strong class="source-inline">"Experience"</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">"Implementation"</strong></span><span class="No-Break">.</span></p>
			<p>Like we did with the Excel plugin, we will also make the <span class="No-Break">following changes:</span></p>
			<ul>
				<li>Standardize the error message to always start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Error</strong></span></li>
				<li>Standardize the success message to always return <span class="No-Break">the folder</span></li>
				<li>At the beginning of every function, if the input starts with <strong class="source-inline">Error</strong>, do nothing and simply pass the received <span class="No-Break">input forward</span></li>
			</ul>
			<p>To save space, we only show one of the functions here. The full code, including the modifications in the <strong class="source-inline">ExtractTextUnderHeading</strong> function, is in the <span class="No-Break">GitHub repository:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<pre class="source-code">
    [KernelFunction, Description("Extracts the text under the Team heading in the Word document")]
    public static string ExtractTeam(string folderPath)
    {
        if (folderPath.Contains("Error"))
        {
            return folderPath;
        }
        string text = ExtractTextUnderHeading(folderPath, "Team");
        return $"FolderPath: {folderPath}\n"  + text;
    }</pre>			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<pre class="source-code">
    def ExtractTeam(self, folder_path: str) -&gt; str:
        if folder_path.startswith("Error"):
            return folder_path
        doc_path = self.get_first_docx_file(folder_path)
        text = self.ExtractTextUnderHeading(doc_path, 'Team')
        return f"FolderPath: {folder_path}\n{text}"</pre>			<p>In both cases, in addition <a id="_idIndexMarker351"/>to creating three function wrappers for <strong class="source-inline">ExtractTextUnderHeading</strong> to extract the text, we also perform two more tasks. The first is to check whether the previous step of the pipeline sent an error message. If it did, we simply pass it on. The second is to prepend the folder path to the text in a line called <strong class="source-inline">FolderPath</strong>. This will be used in the semantic functions. When the semantic function decides that the text it read fulfills the requirements, it will return the folder path, as is expected by functions in <span class="No-Break">the pipeline.</span></p>
			<p>Let’s work on the <span class="No-Break">semantic functions.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Modifying the semantic functions</h2>
			<p>The main modification that we need to make to the semantic functions is to ensure they understand <a id="_idIndexMarker352"/>the inputs and provide the appropriate outputs – either the folder in the case of success or an error message in the case <span class="No-Break">of failure.</span></p>
			<p>One way to do this is to encode the input into tags and then tell the AI service to perform operations on the contents of the tag. There was no need to modify the <strong class="source-inline">config.json</strong> files, only the <span class="No-Break"><strong class="source-inline">skprompt.txt</strong></span><span class="No-Break"> files.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CheckTeamV2: skprompt.txt</p>
			<pre class="source-code">
=====
 {{$input}}
=====
Check the contents of the text between the ===== and =====.
If the contents are an error message, respond with the error message, including the word "Error:" at the beginning.
Otherwise, the first line of the text between the ===== and ===== will contain the FolderPath.
The other lines will contain the team's experience.
We require the team's experience to have at least one person with a Ph.D. and at least one person with a degree in the medical sciences.
Think carefully about the team's experience.
If the team fulfills the requirements, your answer should be the contents of the FolderPath field, nothing more.
If the team does not fulfill the requirements, reply with "Error: Team does not meet requirements."</pre>			<p>In this semantic function, we tell the AI to check the contents of the text between <strong class="source-inline">=====</strong> for an error <a id="_idIndexMarker353"/>and simply pass it on if it finds one. If the contents between the ===== tags are not an error, they will contain the folder we’re processing in a line starting with <strong class="source-inline">FolderPath</strong> and the text from the <strong class="source-inline">Team</strong> heading in the Word document. We tell the AI to return the folder if the team fulfills the requirements we list or to return an error message if <span class="No-Break">they don’t:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CheckDatesV2: skprompt.txt</p>
			<pre class="source-code">
=====
 {{$input}}
=====
Check the contents of the text between the tags ===== and =====.
If the contents are an error message, respond with the error message, including the word "Error:" at the beginning.
Otherwise, the text between the tags ===== and ===== will contain
a line starting with FolderPath and the rest of the field will contain
a description of a timeline for vaccine implementation.
Think carefully about the following question:
Ignoring the FolderPath line, does the timeline contain dates?
If there are no dates listed, say "Error: No dates listed" .
If the dates are outside of the 2024-2025 range, say "Error: dates out of range".
If there are dates between 2024 and 2025, respond only with the contents of the FolderPath field, nothing more.</pre>			<p>We now ask the AI to check the contents between the <strong class="source-inline">=====</strong> tags for an error. The same as before, we simply pass it on if we find it. We then check whether the dates proposed for <a id="_idIndexMarker354"/>the vaccination campaign are within our expectations. If they are, we return the folder contained in the <strong class="source-inline">FolderPath</strong> line inside the tag. Otherwise, we return an <span class="No-Break">error message:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CheckPreviousProjectV2: skprompt.txt</p>
			<pre class="source-code">
=====
 {{$input}}
=====
Check the contents of the text between the ===== and =====.
If the contents are an error message, respond with the error message, including the word "Error:" at the beginning.
Otherwise, the text between the ===== and ===== will contain a line starting with FolderPath and the rest of the field will contain a description of the teams experience.
Ignoring the FolderPath line, does the description of the teams experience
indicate they have enough experience to conduct a massive vaccination campaign in a new country?
If they have had a successful experience in Atlantis or another large country, respond only with the
contents of the FolderPath field, nothing more.
Otherwise, respond with "Error: Not enough experience."</pre>			<p>The final <a id="_idIndexMarker355"/>semantic function is very similar to the previous two. We ask the AI to check the contents between the <strong class="source-inline">=====</strong> tags and return an error message if the team requesting for funding does not have enough experience as demonstrated by a <span class="No-Break">previous project.</span></p>
			<p>Now that we’re done with all the steps of our process, let’s assemble them into a pipeline and <span class="No-Break">run it.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Creating and calling the pipeline</h1>
			<p>Calling the pipeline requires creating a kernel, loading it with the functions we want, and then calling <a id="_idIndexMarker356"/>them in sequence. Since we’re going to use semantic functions, we also need to add an AI service to the kernel. Evaluating text against requirements <a id="_idIndexMarker357"/>can be a complex task, and therefore we will use GPT-4 to execute it. GPT 3.5 can work if the documents are simple, but some of our documents have more than one page, and that can be too much for GPT 3.5 to <span class="No-Break">handle well.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">C#</p>
			<p>In the following code block, we load all the native and semantic plugins into <span class="No-Break">our kernel:</span></p>
			<pre class="source-code">
using Microsoft.SemanticKernel;
using Plugins.ProposalChecker;
using System;
using System.IO;
var (apiKey, orgId) = Settings.LoadFromFile();
var builder = Kernel.CreateBuilder();
builder.AddOpenAIChatCompletion("gpt-4", apiKey, orgId);
builder.Plugins.AddFromPromptDirectory("../../../plugins/ProposalCheckerV2");
builder.Plugins.AddFromType&lt;Helpers&gt;();
builder.Plugins.AddFromType&lt;ParseWordDocument&gt;();
builder.Plugins.AddFromType&lt;CheckSpreadsheet&gt;();
var kernel = builder.Build();</pre>			<p>Then, we create variables for each of <span class="No-Break">the functions:</span></p>
			<pre class="source-code">
KernelFunction processFolder = kernel.Plugins["Helpers"]["ProcessProposalFolder"];
KernelFunction checkTabs = kernel.Plugins["CheckSpreadsheet"]["CheckTabs"];
KernelFunction checkCells = kernel.Plugins["CheckSpreadsheet"]["CheckCells"];
KernelFunction checkValues = kernel.Plugins["CheckSpreadsheet"]["CheckValues"];
KernelFunction extractTeam = kernel.Plugins["ParseWordDocument"]["ExtractTeam"];
KernelFunction checkTeam = kernel.Plugins["ProposalCheckerV2"]["CheckTeamV2"];
KernelFunction extractExperience = kernel.Plugins["ParseWordDocument"]["ExtractExperience"];
KernelFunction checkExperience = kernel.Plugins["ProposalCheckerV2"]["CheckPreviousProjectV2"];
KernelFunction extractImplementation = kernel.Plugins["ParseWordDocument"]["ExtractImplementation"];
KernelFunction checkDates = kernel.Plugins["ProposalCheckerV2"]["CheckDatesV2"];</pre>			<p>Creating variables <a id="_idIndexMarker358"/>for each of the functions is not strictly necessary – you could <a id="_idIndexMarker359"/>simply put the code on the right-hand side of each of the preceding assignments directly into the <span class="No-Break">pipeline call.</span></p>
			<p>For example, <span class="No-Break">instead of</span></p>
			<pre class="source-code">
KernelFunctionCombinators.Pipe(new[] {
    processFolder,
    checkTabs}</pre>			<p>You <span class="No-Break">could write:</span></p>
			<pre class="source-code">
KernelFunctionCombinators.Pipe(new[] {
kernel.Plugins["ProposalCheckerV2"]["ProcessProposalFolder"]}
    kernel.Plugins["ProposalCheckerV2"]["CheckTabs"]}</pre>			<p>Assigning it to <a id="_idIndexMarker360"/>variables makes the contents of the pipeline call much shorter, and that <a id="_idIndexMarker361"/>can make it easier <span class="No-Break">to maintain.</span></p>
			<p>Next, we create a pipeline with the <strong class="source-inline">Pipe</strong> method of <strong class="source-inline">KernelFunctionCombinators</strong>, simply listing the steps in the order we want them to <span class="No-Break">be called:</span></p>
			<pre class="source-code">
KernelFunction pipeline = KernelFunctionCombinators.Pipe(new[] {
    processFolder,
    checkTabs,
    checkCells,
    checkValues,
    extractTeam,
    checkTeam,
    extractExperience,
    checkExperience,
    extractImplementation,
    checkDates
}, "pipeline");</pre>			<p>The next <a id="_idIndexMarker362"/>step will <a id="_idIndexMarker363"/>be to call <span class="No-Break">the pipeline:</span></p>
			<pre class="source-code">
var proposals = Directory.GetDirectories("../../../data/proposals");
// print each directory
foreach (var proposal in proposals)
{
    // convert to absolute path
    string absolutePath = Path.GetFullPath(proposal);
    Console.WriteLine($"Processing {absolutePath}");
    KernelArguments context = new() { { "folderPath", absolutePath } };
    string result = await pipeline.InvokeAsync&lt;string&gt;(kernel, context);
    Console.WriteLine(result);
    if (result == absolutePath)
    {
        Console.WriteLine("Success!");
    }
    Console.WriteLine();
}</pre>			<p>We get the path of the <strong class="source-inline">data/proposals</strong> folder that contains our proposals. Each proposal is a subfolder of that folder. We iterate over each of the subfolders of the <strong class="source-inline">data/proposal</strong> folder and call our pipeline. If we don’t find any errors, we print <strong class="source-inline">Success</strong>. Otherwise, we list the errors <span class="No-Break">we found.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Python</p>
			<p>We start by <a id="_idIndexMarker364"/>creating our kernel, adding the GPT-4 service to it, and adding <a id="_idIndexMarker365"/>all the native and semantic plugins <span class="No-Break">to it:</span></p>
			<pre class="source-code">
import asyncio
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
import semantic_kernel as sk
from CheckSpreadsheet import CheckSpreadsheet
from ParseWordDocument import ParseWordDocument
from Helpers import Helpers
import os
async def pipeline(kernel, function_list, input):
    for function in function_list:
        args = KernelArguments(input=input)
        input = await kernel.invoke(function, args)
    return input
async def main():
    kernel = sk.Kernel()
    api_key, org_id = sk.openai_settings_from_dot_env()
    gpt4 = OpenAIChatCompletion("gpt-4", api_key, org_id)
    kernel.add_chat_service("gpt4", gpt4)
    parse_word_document = kernel.import_skill(ParseWordDocument())
    check_spreadsheet = kernel.import_skill(CheckSpreadsheet())
    helpers = kernel.import_skill(Helpers())
    interpret_document = kernel.import_semantic_skill_from_directory("../../plugins", "ProposalCheckerV2")</pre>			<p>Note that <a id="_idIndexMarker366"/>we added the pipeline function that we created in the <span class="No-Break">previous section.</span></p>
			<p>The final <a id="_idIndexMarker367"/>step is to create a function list and call the pipeline for <span class="No-Break">each document:</span></p>
			<pre class="source-code">
    data_path = "../../data/proposals/"
    for folder in os.listdir(data_path):
        if not os.path.isdir(os.path.join(data_path, folder)):
            continue
        print(f"\n\nProcessing folder: {folder}")
        function_list = [
            helpers['ProcessProposalFolder'],
            check_spreadsheet['CheckTabs'],
            check_spreadsheet['CheckCells'],
            check_spreadsheet['CheckValues'],
            parse_word_document['ExtractTeam'],
            interpret_document['CheckTeamV2'],
            parse_word_document['ExtractExperience'],
            interpret_document['CheckPreviousProjectV2'],
            parse_word_document['ExtractImplementation'],
            interpret_document['CheckDatesV2']
        ]
        process_result = await pipeline(kernel, function_list, os.path.join(data_path, folder))
        result = (str(process_result))
        if result.startswith("Error"):
            print(result)
            continue
        else:
            print("Success")</pre>			<p>The full pipeline <a id="_idIndexMarker368"/>obtains the expected results, with the proposals that <a id="_idIndexMarker369"/>fulfill all the requirements returning success and the proposals with problems returning an error message describing <span class="No-Break">the problem.</span></p>
			<p>The results are <span class="No-Break">displayed here:</span></p>
			<pre class="console">
Processing folder: correct
Success
Processing folder: incorrect01
Error: the spreadsheet does not contain the correct tabs
Processing folder: incorrect02
Error: Sum of values in year 2025 exceeds 1,000,000.
Processing folder: incorrect03
Error: More than 10% growth found from B2 to B3 in sheet 2024.
Processing folder: incorrect04
Error: non-numeric inputs
Processing folder: incorrect05
Error: No Word document found
Processing folder: incorrect06
Error: No Excel spreadsheet found
Processing folder: incorrect07
Error: Not enough experience.
Processing folder: incorrect08
Error: Team does not meet requirements.
Processing folder: incorrect09
Error: dates out of range
Processing folder: incorrect10
Error: multiple files found</pre>			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Summary</h1>
			<p>Before having the help of AI, reading and interpreting a document required using the time of a person, or writing a specialized machine learning model. Semantic Kernel allows you to write code to analyze large and <span class="No-Break">complex documents.</span></p>
			<p>In our pipeline, the <strong class="source-inline">CheckSpreadsheet</strong> native plugin does not strictly require Semantic Kernel and could be done in a separate step, since it only runs code that is never read by AI. We added it to the pipeline to make our end-to-end solution <span class="No-Break">more streamlined.</span></p>
			<p>The <strong class="source-inline">ParseWordDocument</strong> native plugin, on the other hand, helps Semantic Kernel receive the information in parts. Breaking the document into parts makes the semantic functions simpler: each function can evaluate just a portion of the document. For example, the function that evaluates the <em class="italic">Teams</em> section of the document just needs to check the team qualifications. That makes the function a lot simpler to write than a function that reads the whole document and decides about all sections of the document in a <span class="No-Break">single step.</span></p>
			<p>The real value that AI adds to this process, therefore, is in the semantic plugin. The tasks of evaluating sections of the document that are implemented by the semantic functions in the <strong class="source-inline">ProposalCheckerV2</strong> plugin are the ones that would formerly require either a lot of human effort or a specialized machine learning model. This chapter showed how to execute these tasks just by describing what the requirements were in three short <span class="No-Break"><strong class="source-inline">skprompt.txt</strong></span><span class="No-Break"> files.</span></p>
			<p>In this chapter, we created our pipeline manually, explicitly naming the functions that we wanted to call and in which order. In the next chapter, we will learn how to use a planner. The planner will receive the user request and decide which functions to call and in <span class="No-Break">which order.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>References</h1>
			<p class="Bibliography">[1] A. S. Luccioni, Y. Jernite, and E. Strubell, “Power Hungry Processing: Watts Driving the Cost of AI Deployment?” arXiv, Nov. 28, 2023. <span class="No-Break">doi: 10.48550/arXiv.2311.16863.</span></p>
		</div>
	</div>
</div>
</body></html>