- en: '*Chapter 6*: Powering Your API with a No Code Database'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn to work with no code databases for data storage.
    You will learn about no code databases, selecting a database for your project,
    and reading and writing to **Airtable**. You will also learn about some of the
    best practices when working with these databases. The concepts learned in this
    chapter will help you to use a data store for your projects to store user-generated
    data and build a complete product.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about no code databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a database for your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Airtable** for reading and writing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for working with databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing your **application programming interface** (**API**) for production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of technical requirements that you''ll need to prepare before
    continuing with the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You have created an account on **Airtable**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: n8n is running and the Editor **user interface** (**UI**) is open
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about no code databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases often form the backbone of products. Databases are generally systems
    that store large amounts of data. The user can add, delete, or modify data while
    also viewing and performing calculations on that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Databases come in many different forms, such as **Structured Query Language**
    (**SQL**) databases, NoSQL databases, and time series databases. Depending on
    the use cases, it often makes sense to choose one over the other. A lot of these
    databases use query languages to be able to interact with the database to conduct
    basic queries such as inserting, reading, updating, and deleting data. You can
    see some database examples in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Historical trend chart from db-engines.com'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Historical trend chart from db-engines.com
  prefs: []
  type: TYPE_NORMAL
- en: Since we are focusing on building a product with no code tools and we don't
    have the time to learn these query languages quickly, we'll have to look for some
    alternatives. Luckily, there are already a number of great alternatives that we
    can choose from. Two of the most popular ones are **Airtable** and **Google Sheets**.
    These tools are easier to use as compared to traditional databases as they employ
    a familiar spreadsheet-like design that is easier to comprehend than database
    models. Since these tools are rather robust as well, more and more people have
    started using them in their projects.
  prefs: []
  type: TYPE_NORMAL
- en: Both **Airtable** and **Google Sheets** have an n8n node, and we can use these
    nodes to perform **create, read, update, and delete** (**CRUD**) actions to power
    our API and application. Now that we have an idea about what no code databases
    are, let's think about how we can choose one that we can use during the duration
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a database for your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from **Google Sheets** and **Airtable**, there are a number of really
    cool no code databases such as **Baserow**, **Supabase**, **SeaTable**, and **NocoDB**.
    How do we select the right database for our product? There are a couple of questions
    that you can ask yourself that might help in making this decision easier:'
  prefs: []
  type: TYPE_NORMAL
- en: What do I want the database to do for my project?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this tool have an n8n node or at least an API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How active is the community and support ecosystem for this tool?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's the level of maturity of the product? Is it stable? Has it been in the
    market long enough to be battle-tested by users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are educational resources about the tool widely available? What's the learning
    curve like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While choosing the no code database to include in this book, we asked ourselves
    the same questions. We decided to go with **Airtable** because of the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Airtable** has a large community and an incredible support system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Airtable** has a decent API with an easy authentication system. n8n has a
    well-documented **Airtable** node too!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Airtable** has been around for a bit, and a lot of makers use it to build
    their projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Airtable** puts out a lot of educational content regularly and it''s straightforward
    to get started with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot provides an overview of the **Airtable** database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Airtable has a lot of educational resources and a strong community'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Airtable has a lot of educational resources and a strong community
  prefs: []
  type: TYPE_NORMAL
- en: While you are asking yourselves these questions, it is quite possible that your
    answers might be different depending on the project that you are planning to work
    on. That's okay! Each tool has its own niche and superpowers that might make it
    more suitable for a certain type of project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've made sure that **Airtable** is the correct choice for us right
    now, let's take a look at how we can use it from n8n workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Using Airtable for reading and writing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off by creating a new base from scratch in `The n8n book`. Edit
    all the existing fields so that we have the following four fields with the single-line
    text field type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UserID**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First Name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last Name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Email**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is very similar to the table into which data was being inserted in the
    previous chapter. For the sake of brevity, we have taken out the **Password Hash**
    field. Your table should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – This is what your Airtable table should look like'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.03_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – This is what your Airtable table should look like
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have prepared our table, let''s pop over to n8n''s Editor UI and
    follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new workflow and add a **Set** node to it. We'll need the **Set** node
    to make sure that we send well-formatted data to the **Airtable** node.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `String type`. For each of these four values, do the following. In
    the `true` (green). In the **Value** field, enter anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Execute Node** button, and your **Set** node should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Output from the Set node after following the aforementioned
    steps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Output from the Set node after following the aforementioned steps
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have structured the data in a way that would correspond to the
    columns in **Airtable**, let''s add the **Airtable** node and connect it with
    the **Set** node. Here''s what your Editor UI should look like at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The workflow should look like this at this point'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.05_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – The workflow should look like this at this point
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Airtable** node and enter your credentials. You can find the API
    key by following the steps mentioned on this page: [https://docs.n8n.io/credentials/airtable/](https://docs.n8n.io/credentials/airtable/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `Append`, since we want to insert the data from the `Table 1` in
    the **Table** field and click on the **Execute Node** button. It should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Output from the Airtable node after following the aforementioned
    steps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Output from the Airtable node after following the aforementioned
    steps
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back to your **Airtable** base, you''ll notice that the record has
    been added to the table by this n8n workflow. Congratulations—you''ve just added
    your first record to **Airtable** using n8n! Here''s a screenshot that showcases
    how your **Airtable** table should look at this point and how it relates to the
    data that we structured in the **Set** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Record inserted into the Airtable table and how it related to
    the data from the Set node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Record inserted into the Airtable table and how it related to the
    data from the Set node
  prefs: []
  type: TYPE_NORMAL
- en: You can replace the **Start** node with other nodes to source the data that
    you want to add to **Airtable** and make the appropriate changes to the **Set**
    node. You might remember from the last chapter that we got the data from the API
    that we created using the **Webhook** node.
  prefs: []
  type: TYPE_NORMAL
- en: This combination of the **Set** node (to structure the data in a form expected
    by the database) and the **Airtable** node (to insert the data into **Airtable**)
    will remain the same across workflows. In case you want to use another database
    for some other project, you'd replace the **Airtable** node with that node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key things to keep in mind about inserting data into databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Spreadsheets and databases have columns, such as **First Name** and **Last Name**.
    The data you send to a database node needs to match these column names for each
    row of data that you want to insert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of times, you might not get data from APIs in a form that works best for
    you. In those cases, the **Set** node can help you remodel the data that you need
    according to your database's columns and discard the data that you don't need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spreadsheet and database nodes in n8n perform their configured action (such
    as `Append`) on each item of input data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from an `List` as the operation and enter the same credentials
    and **Base ID** value as the previous workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Execute Node** button, and the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Output of the List operation of the Airtable node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Output of the List operation of the Airtable node
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have listing data from `List` operation of the `Update` and `Delete`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this scenario: You need to find a record where the first name is `Nathan`
    and update the last name of the person to `Automaton`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then build a workflow like the one shown in the following screenshot
    to update the particular record in the **Airtable** table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Updating a particular record in Airtable using an n8n workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Updating a particular record in Airtable using an n8n workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `Nathan`. If it isn''t, n8n goes to the `Nathan`, we use a **Set**
    node to add the new value for the **Last Name** field. Here''s what the **Set**
    node looks like after configuration and execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Configuring the Last Name field for updating the record with
    Nathan as the first name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Configuring the Last Name field for updating the record with Nathan
    as the first name
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we have the **Airtable1** node, which will update the record.
    We have used the ID of the record to be updated from the first **Set** node (we
    originally got it from the **Airtable** node) as well as specifying that only
    the **Last Name** field should be updated. You can see the **Airtable1** node
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Configuring the Airtable1 node for updating the Last Name field
    of the record'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B17493.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Configuring the Airtable1 node for updating the Last Name field
    of the record
  prefs: []
  type: TYPE_NORMAL
- en: And voilà! The workflow has updated the **Last Name** column for the specified
    record in **Airtable**. You can use a similar workflow to delete records as well.
  prefs: []
  type: TYPE_NORMAL
- en: When using this workflow as part of an API, you can get values such as the text
    for which to perform a lookup and which column to look in, as well as the updated
    record using the **Webhook** node. You can then use expressions to make sure that
    the API endpoint with this workflow can handle dynamic requests without having
    to create specific workflows for different columns. Now that we know how to work
    with no code databases using n8n, let's learn about some best practices for working
    with databases.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for working with databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of different aspects that go into working with databases that
    you will generally use in an enterprise environment, but things can be a bit different
    with no code databases. Because of how these databases are designed, built, and
    hosted, we need to think a bit differently when we use them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some of the best practices around working with databases
    and how you can use them in a way that is both effective and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing bandwidth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is not always the case, no code databases are generally hosted somewhere
    on the internet. This means that you do not have as much bandwidth available between
    you and the database that you would use if the database were hosted on the same
    network, which is the case for traditional databases.
  prefs: []
  type: TYPE_NORMAL
- en: Because this bandwidth is now at a premium (and, depending upon how your database
    is hosted/priced, you may literally be paying for every byte that you send and/or
    receive from the database), it is very important that you make sure you use it
    wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, the data that is stored in databases is text-based. Text data has a very
    high compression ratio, which reduces how much information needs to be sent or
    received between you and your database.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the ability to compress data between the two systems, this will
    increase the speed of your transactions and reduce your bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: However, keep in mind that this will also increase the **central processing
    unit** (**CPU**) utilization on both n8n and your database as the compression
    needs to be calculated on both sides.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing API calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API calls to your database, such as bandwidth, can be expensive (literally,
    if you are paying per API request). They take up resources, slow down your application
    (as the application needs to wait for the call to complete or time out), and increase
    dependencies on the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you do everything you can to reduce API calls, these issues can be minimized
    or, in some cases, avoided altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing database queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because databases generally work very quickly, it is easy for us as developers
    to become lazy when accessing a database. Why bother modifying the code to write
    three records to the database with a single query when it is easier to write each
    record on its own in three separate queries?
  prefs: []
  type: TYPE_NORMAL
- en: This type of programming may work with large databases that are sitting on the
    same network as you, but when they can be located on the other side of the planet
    over a fluctuating internet connection, these queries must be optimized and minimized.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing database writes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is one thing to read data from a database, it is a completely different
    thing to write data to a database. Write operations tend to consume significantly
    more resources than read operations on a database. Plus, they take longer to execute,
    often because data needs to move around in memory, or even sometimes on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Because the cost of writing to your database is relatively expensive, only write
    data when you absolutely have to and write as much data as possible each time
    you do write. This will give you the most bang for your buck for each database
    write.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling data caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are truly serious about minimizing the amount of data we read and write
    between n8n and the database, a great strategy is to store a copy of select database
    tables locally in n8n, either in memory or in a local **JavaScript Object Notation**
    (**JSON**) file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, each time a request needs to be made to the database, you can first ask
    whether the database has changed since the last time the cache was updated. If
    it has, then n8n should pull down just the changes that were made to the database
    and write those to the cached data. If there were no changes, then updating the
    cache can be skipped and the query can be executed locally.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a significantly more efficient way of looking at the data in a database
    than querying the database each time. It not only speeds up your database lookups
    but also reduces the number of calls to the database in the long run as well.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your database is the core of your application. The database must be available
    as much as possible and, if the database is lost, you have a way to recover it.
  prefs: []
  type: TYPE_NORMAL
- en: Your best line of defense is to back up your database as often as possible.
    This way, you will minimize the amount of data loss and reduce the amount of time
    it takes to recover.
  prefs: []
  type: TYPE_NORMAL
- en: Recording transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to ensure that you can recover from not only data loss but also
    data overwrite is to record every transaction that occurs on the database to a
    separate transaction table. This way, if there is a gap between the time your
    database became unavailable and the time of the last backup, you can recreate
    those transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if your database backup is completely lost, you can still recover from
    the data loss by executing the transactions again. This is significantly slower
    than recovering from backup but infinitely better than losing all of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Using record references and table views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are using data that needs to be entered several times, it is more efficient
    to create a separate record in a different database table with a unique record
    ID rather than repeatedly writing the same data each time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I was creating a database that needed to refer to user information
    such as first name, last name, and address, I could just write all this information
    to the database table each time it was needed. But if we were to write this information
    to a user table, we could then just reference the **UserID** value stored in the
    table and write that rather than the entire record.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to reduce the amount of information that gets transferred and
    minimizes the size of the write.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because these databases are hosted on the internet and can generally be accessed
    from anywhere on the internet, it is extremely important that they be properly
    secured. Ensure that all credentials and API keys are stored securely and are
    not hardcoded into your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Also, make sure all transactions are over an encrypted (**HyperText Transfer
    Protocol Secure**, or **HTTPS** for short) connection and, if possible, only allow
    specific **Internet Protocol** (**IP**) addresses to talk with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Performing calculations on the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your database will most likely be a lot more powerful than the system you are
    using to host n8n. Because of that, if it is possible, get the database to perform
    calculations, especially if the goal is to provide summary statistics of the data
    that is already on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than sending all of the data to n8n for processing, perform the processing
    on the database using query functions such as `COUNT`, `MIN`, and `MAX`. This
    moves the calculations (that is, CPU load) over to the database and reduces the
    amount of information that needs to be transmitted between the database and your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not uncommon for developers to build an application and it runs just fine
    in both development and testing, but once it goes into production, the database
    cannot handle the load due to resource constraints (for example, CPU maxed out;
    storage too slow; bandwidth constraints).
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you have a way of load testing the database before it goes into
    production. This way, you will be able to ensure that the database has all of
    the necessary resources before it becomes a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our database is ready to go, let's take a look at how we can design
    and build the API to provide the best performance to users.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your API for production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your API can be one of the most important parts of your application since it
    is one of the primary ways that your clients read and write data. Because of this
    importance, it is vital that your API is ready for production right from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some of the ways you can make sure your API is production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing database calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very much in line with the best practices for databases, the fewer times you
    need to read and write to the database, the better your application will perform.
    Use many of the strategies mentioned in the previous section to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data before the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have relatively static data behind your API, one of the tricks you can
    use is to put a caching system in front of your API, which will allow you to give
    out the information requested by the users without actually touching the API itself.
    The caching system updates itself with information from the API on a regular basis,
    and if it determines that there has been no change in the data given out by that
    API based on the same call being made to the API, the caching system will just
    send back the data that it has stored locally without bothering the API.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing API calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some APIs require you to have information that is in the database to make another
    query to the database. A good example of this is user accounts. Generally, you
    would use the API to query the user table to find the user that you need. Then,
    you would query the API again, looking for specific information for that user.
  prefs: []
  type: TYPE_NORMAL
- en: What you could do instead is to keep a local copy of the user table in your
    application and use that to look up user IDs. Then, with that information already
    in hand, you can query your API only once to get the information you need.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While there are a lot of open APIs out there on the internet, it is very important
    to require authentication, even if you are giving the API service away for free.
    This increases the level of responsibility that the user has and reduces the likelihood
    that the API will be abused.
  prefs: []
  type: TYPE_NORMAL
- en: In the event that someone is abusing your API, authentication can make it easier
    to track down that individual and resolve the issue with their system or stop
    them from interfering with your API.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting API data on the wire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless your data is encrypted on the wire (that is, when it is being transmitted
    between the application and the database), API keys, credentials, and sensitive
    data are susceptible to being eavesdropped upon.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to secure this data while in transit is to have a **Secure Sockets
    Layer** (**SSL**) certificate installed on the server that is providing the API.
    This encrypts the data and greatly reduces the possibility of someone listening
    to your API's conversations.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking API requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is guaranteed that if you make an API available on the internet, there will
    be someone out there who is looking to abuse that API. This is why it is critical
    to keep a log of all API transactions in the event that you need to deal with
    one of these abusers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure you track, at a minimum, the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will provide you with the base information to perform some analytics on
    the data and determine who the abuser is and where they may be working from.
  prefs: []
  type: TYPE_NORMAL
- en: Tying API users to IP addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In line with the previous item, if you can get your API to only allow a user
    to access it from a specific IP or IP range, this can reduce the likelihood that
    your API will be abused and will allow you to help your users in the event that
    their information has been compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of API calls per user per second
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you put limits on how quickly users can access the API, this will help to
    distribute resources more evenly to all your users, along with reducing the likelihood
    that a user will inadvertently perform a **denial-of-service** (**DoS**) attack
    on your API.
  prefs: []
  type: TYPE_NORMAL
- en: Properly documenting the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have proper API documentation available for your users and developers,
    it will be easier for them to use your API properly and keep your error logs clean.
    This will increase customer satisfaction and reduce the stress on your support
    team, who need to help these people.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about no code databases, choosing a no code database
    for your project, reading and writing to **Airtable**, as well as some best practices
    when it comes to working with databases and optimizing APIs for production. The
    concepts learned in this chapter will help you to use a data store for your projects
    to store user-generated data and build a complete product.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we examine how you can transform your data inside n8n workflows.
    We will do some hands-on exercises on sharing data between different n8n workflows,
    merge datasets from different tables, and also perform some analytics and calculations
    on these datasets.
  prefs: []
  type: TYPE_NORMAL
