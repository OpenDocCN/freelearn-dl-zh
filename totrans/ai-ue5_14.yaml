- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Implementing Interactable Elements with Smart Objects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能对象实现可交互元素
- en: In Unreal Engine, **Smart Objects** represent an advanced system implemented
    to help developers create interactive and context-aware elements within a game.
    Smart Objects are designed to enhance gameplay by allowing characters – be they
    player characters or AI agents – to interact with the environment in a more meaningful
    way through a reservation system. Learning how to use Smart Objects will let you,
    the developer, create dynamic and interactive environments that enhance gameplay
    and improve AI behavior for a more immersive player experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**智能对象**代表一个高级系统，旨在帮助开发者创建游戏中的交互式和上下文感知元素。智能对象旨在通过允许角色（无论是玩家角色还是AI代理）通过预留系统以更有意义的方式与环境交互来增强游戏玩法。学习如何使用智能对象将使你，作为开发者，能够创建动态和交互式环境，从而增强游戏玩法并改善AI行为，以提供更沉浸式的玩家体验。
- en: In this chapter, you will learn the basics of Smart Objects interactivity. We
    will visit a simple example of how to make AI agents interact with a smart object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习智能对象交互的基础知识。我们将参观一个简单的例子，展示如何使AI代理与智能对象交互。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing Smart Objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍智能对象
- en: Creating a Smart Object Definition data asset
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建智能对象定义数据资产
- en: Implementing Smart Object logic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现智能对象逻辑
- en: Interacting with Smart Objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与智能对象交互
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed all
    the chapters from *Part 3* , *Working with Decision Making* , and understood their
    content. In particular, we will be using part of the code implemented up until
    [*Chapter 11*](B31016_11.xhtml#_idTextAnchor218) , *Understanding the Environment*
    *Query System* .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章介绍的主题，你应该已经完成了*第3部分*，*使用决策制作*的所有章节，并理解了它们的内容。特别是，我们将使用直到[*第11章*](B31016_11.xhtml#_idTextAnchor218)
    ，*理解环境* *查询系统*中实现的部分代码。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in the project
    repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望从本书的配套仓库开始编写代码，你可以下载项目仓库中提供的**.zip**项目文件：[https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 11** **-** **End** link.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载最后一章末尾的文件，请点击**Unreal Agility Arena –** **第11章** **-** **末尾**链接。
- en: Introducing Smart Objects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍智能对象
- en: Smart objects are elements placed within a level that can be interacted with
    by both AI agents and players. These objects do not contain any execution logic
    but hold all the necessary information for interactions; additionally, they can
    be queried at runtime with different methods, such as environment queries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 智能对象是在级别内放置的元素，AI代理和玩家都可以与之交互。这些对象不包含任何执行逻辑，但持有所有必要的交互信息；此外，它们可以通过不同的方法在运行时查询，例如环境查询。
- en: Smart objects represent a set of activities within a level that can be accessed
    through a reservation system; if a smart object slot has been claimed by an AI
    agent, no other agent will be able to use it until it is released.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 智能对象代表一个级别内的一组活动，可以通过预留系统访问；如果一个智能对象槽位被AI代理占用，则其他代理将无法使用它，直到它被释放。
- en: Presenting the main elements of the Smart Objects framework
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍智能对象框架的主要元素
- en: Like all Unreal Engine plugins, smart objects are organized into a series of
    elements, each responsible for a specific task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有虚幻引擎插件一样，智能对象被组织成一系列元素，每个元素负责特定任务。
- en: The **SmartObject subsystem** is responsible for monitoring all available smart
    objects within the level and is automatically instantiated in the world when the
    Smart Objects plugin is enabled. Smart objects are automatically registered with
    the subsystem for easy access and tracking.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能对象子系统**负责监控级别内所有可用的智能对象，并在启用智能对象插件时自动在世界上实例化。智能对象会自动注册到子系统中，以便于访问和跟踪。'
- en: A **Smart Object Definition** is a data asset that holds immutable data shared
    among multiple runtime instances of smart objects. It contains filtering information
    such as user-required tags, activity tags, object activation tags, and a default
    set of behavior definitions used to interact with a smart object. Additionally,
    a Smart Object Definition features one or more **slots** that can be claimed by
    players or AI agents to use that specific smart object. Each slot can be positioned
    relative to its parent, allowing you to define different slots in different positions
    for the same actor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能对象定义**是一个数据资产，它持有在多个智能对象运行时实例之间共享的不变数据。它包含过滤信息，例如用户所需的标签、活动标签、对象激活标签以及用于与智能对象交互的默认行为定义集。此外，智能对象定义还包含一个或多个**槽位**，玩家或AI代理可以声明使用该特定智能对象。每个槽位都可以相对于其父对象定位，允许你为同一演员定义不同位置的不同槽位。'
- en: To designate an actor as a smart object, you will be using **SmartObjectComponent**
    ; this component will reference a Smart Object Definition asset.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个演员指定为智能对象，你将使用**SmartObjectComponent**；这个组件将引用一个智能对象定义资产。
- en: Smart Object Definitions can include one or more **activity tags** that describe
    the object. They may also feature a **tag query** , which consists of a list of
    desired tags. This tag query serves as an expression to assess whether the user
    requesting access to the smart object is permitted to interact with it. As an
    example, a Smart Object Definition may require a **charging plug** tag that will
    be usable only by an AI agent that has that exact tag.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 智能对象定义可以包含一个或多个**活动标签**来描述对象。它们还可以具有一个**标签查询**，它由一系列期望的标签组成。这个标签查询作为一个表达式来评估请求访问智能对象的用户是否有权与之交互。例如，一个智能对象定义可能需要一个**充电插头**标签，只有具有该确切标签的AI代理才能使用。
- en: Now that you have a quick introduction to the Smart Objects framework, you’re
    all set to dive into your project and start creating your very own smart object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对智能对象框架有了快速的了解，你就可以开始你的项目，并开始创建你自己的智能对象了。
- en: Starting from the next section, we will be presenting you the basics of using
    Smart Objects inside Unreal Engine; we won’t cover all aspects of the framework
    as it can be used in many different ways – standalone, or with behavior trees,
    state trees, and even with Mass. However, by the end of the chapter, you should
    have a clear understanding of what you can achieve with it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将向您介绍在虚幻引擎中使用智能对象的基础知识；我们不会涵盖框架的所有方面，因为它可以用多种方式使用——独立使用，或与行为树、状态树以及甚至与Mass一起使用。然而，到本章结束时，你应该对你可以用它实现什么有一个清晰的理解。
- en: Time to roll up our sleeves and dive into some code!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候卷起袖子，深入代码了！
- en: Creating a Smart Object Definition data asset
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建智能对象定义数据资产
- en: '*Dr. Markus leaned back in his chair, a satisfied grin spreading across his
    face as he surveyed the cluttered lab. Tools were scattered everywhere, and the
    faint hum of machinery filled the air. Across the room, Professor Viktoria was
    hunched over one of their AI dummy puppets, her brow furrowed in* *deep concentration.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*马克斯博士靠在椅背上，满意地微笑着，环顾着杂乱的实验室。工具散落在各处，机器的微弱嗡嗡声充满了空气。在房间另一边，维克托利亚教授弯腰在一具他们的AI假人木偶上，她的眉头紧锁，全神贯注。*'
- en: '*As the two of them immersed themselves in their work, the idea of upgrading
    the puppets took shape. The goal was clear: to create puppets capable of not only
    performing tasks but also fixing themselves when something went awry. This innovation
    promised to* *be revolutionary.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*随着他们沉浸在工作中，升级木偶的想法逐渐成形。目标是明确的：创建不仅能够执行任务，而且在出现问题时能够自我修复的木偶。这一创新承诺将*革命性*。'
- en: '*With renewed focus, Dr. Markus’s fingers danced over the keyboard, typing
    lines of code that would breathe life into their vision. Each keystroke brought
    them closer to a breakthrough, and Professor Viktoria’s eyes sparkled with excitement
    as they discussed the potential of* *their project.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*马克斯博士重新集中了注意力，手指在键盘上飞舞，输入着将赋予他们愿景生命的代码行。每一次按键都让他们更接近突破，当他们在讨论项目的潜力时，维克托利亚教授的眼睛闪烁着兴奋的光芒。*'
- en: In this section, and in the subsequent ones, you will be creating a gym where
    AI agents will use a smart object when needed; we will be using the **BP_GunnerDummyCharacter**
    Blueprint we implemented in [*Chapter 9*](B31016_09.xhtml#_idTextAnchor170) ,
    *Extending Behavior Trees* , by changing its AI logic. The gunner character will
    walk randomly, shoot around, and, when the gun jams, try to find a workbench in
    the level to fix the gun.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节以及随后的章节中，你将创建一个健身房，其中 AI 代理在需要时将使用智能对象；我们将使用在[*第 9 章*](B31016_09.xhtml#_idTextAnchor170)中实现的**BP_GunnerDummyCharacter**蓝图，通过更改其
    AI 逻辑。枪手角色将随机行走，四处射击，当枪卡住时，将尝试在关卡中找到一个工作台来修复枪支。
- en: To start using the Smart Objects framework, the first thing we need to do is
    enable the plugins.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用智能对象框架，我们首先需要做的是启用插件。
- en: Enabling the plugins
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用插件
- en: To enable the Smart Objects framework, open the **Plugins** window, look for
    **SmartObjects** and **GameplayBehaviorSmartObjects** , and enable both. You will
    get a warning as the second plugin is still marked as experimental; go on and
    restart the Unreal Engine Editor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用智能对象框架，请打开**插件**窗口，查找**SmartObjects**和**GameplayBehaviorSmartObjects**，并启用两者。当第二个插件仍然标记为实验性时，你会收到一个警告；继续并重新启动虚幻引擎编辑器。
- en: Once the plugins are enabled, you will be ready to create your first smart object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件启用，你就可以创建你的第一个智能对象。
- en: Creating the workbench definition asset
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工作台定义资产
- en: 'We will now be creating the Smart Object Definition that, as previously mentioned,
    won’t contain any code logic; it will just serve to define the data that will
    make your soon-to-be-created actor a smart object. To do so, open the **AI** folder
    and do the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建智能对象定义，正如之前提到的，它不会包含任何代码逻辑；它仅用于定义将使你即将创建的演员成为智能对象的数据。为此，打开**AI**文件夹并执行以下步骤：
- en: Right-click and select **Artificial Intelligence** | **SmartObject Definition**
    .
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**人工智能**|**智能对象定义**。
- en: Name the newly created asset **SOD_Workbench** and double-click to open it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产命名为**SOD_Workbench**并双击打开它。
- en: In the **Details** panel, locate the **Default Behavior Definitions** array
    attribute and click the **+** button to add an element.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，找到**默认行为定义**数组属性并单击**+**按钮添加一个元素。
- en: Set the **Index[0]** element to **Gameplay Behavior Smart Object** **Behavior
    Definition** .
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Index[0]**元素设置为**游戏行为智能对象****行为定义**。
- en: '![Figure 14.1 – Smart Object behavior definition](img/Figure_14.1_B31016.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 智能对象行为定义](img/Figure_14.1_B31016.jpg)'
- en: Figure 14.1 – Smart Object behavior definition
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 智能对象行为定义
- en: As previously stated, a Smart Object Definition contains filtering data that
    will be used by the system. As we won’t be implementing anything complex, we don’t
    need a custom definition, and we will just be using the base one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，智能对象定义包含系统将使用的过滤数据。由于我们不会实现任何复杂的功能，我们不需要自定义定义，我们只需使用基本定义。
- en: 'It’s now time to add a slot, so do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是添加插槽的时候了，所以请执行以下操作：
- en: In the **Details** panel, locate the **Slots** section and click the **+** button
    to add a new slot. Expand the newly created slot.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，找到**插槽**部分并单击**+**按钮添加一个新的插槽。展开新创建的插槽。
- en: In the **Name** property, insert **WorkingPlace** .
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**属性中输入**工作区域**。
- en: Set the **Shape** property to **Rectangle** .
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**形状**属性设置为**矩形**。
- en: Set the **Size** property to **120.0** .
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**大小**属性设置为**120.0**。
- en: Set the **Offset** property to **(50.0,** **0.0, 0.0)** .
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**偏移**属性设置为**（50.0，** **0.0，0.0）**。
- en: '![Figure 14.2 – Slot definition](img/Figure_14.2_B31016.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 插槽定义](img/Figure_14.2_B31016.jpg)'
- en: Figure 14.2 – Slot definition
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 插槽定义
- en: 'This slot will be the location that can be claimed by the AI agent to fix the
    gun once it jams and should look like the one in *Figure 14* *.3* :'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此插槽将是 AI 代理可以声称的位置，以便在枪卡住后修复它，并且应该看起来像*图 14* *.3* 中的那样：
- en: '![Figure 14.3 – Slot](img/Figure_14.3_B31016.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 插槽](img/Figure_14.3_B31016.jpg)'
- en: Figure 14.3 – Slot
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 插槽
- en: Keep in mind that you can add as many slots as you deem appropriate. For example,
    a larger workbench may have more working places or even different ones – for instance,
    one for fixing guns and one for recharging batteries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以添加你认为合适的任意数量的插槽。例如，更大的工作台可能有更多的工作区域，甚至可能是不同的区域——例如，一个用于修复枪支，另一个用于充电电池。
- en: In this section, we have created the Smart Object Definition we will be using
    to create a Smart Object actor. As you can see, there’s no logic involved here
    because it’s handled by the Blueprint we’ll be creating in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了我们将要使用的智能对象定义，以创建智能对象演员。正如您所看到的，这里没有涉及任何逻辑，因为它将由我们在下一节中创建的蓝图来处理。
- en: Implementing smart object logic
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现智能对象逻辑
- en: 'We are now ready to create the Blueprint that will contain the Smart Object
    definition, making it a fully functional Smart Object. To do so, follow these
    steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建包含智能对象定义的蓝图，使其成为一个完全功能的智能对象。为此，请按照以下步骤操作：
- en: Open the **Blueprints** folder and create a new Blueprint extending from **Actor**
    . Call it **BP_Workbench** . Double-click on the newly created asset to open it.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**蓝图**文件夹并创建一个新的从**Actor**扩展的蓝图。命名为**BP_Workbench**。双击新创建的资产以打开它。
- en: In the **Components** panel, add a **StaticMesh** component and select it.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中，添加一个**静态网格**组件并选择它。
- en: In the **Details** panel, set the **Rotation** property to **(0.0, 0.0, -90.0)**
    and the **Static Mesh** property to **Workbench_Decorated_Workbench_Decorated**
    .
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，将**旋转**属性设置为**(0.0, 0.0, -90.0)**，将**静态网格**属性设置为**Workbench_Decorated_Workbench_Decorated**。
- en: In the **Components** panel, add a **SmartObject** component and select it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中，添加一个**智能对象**组件并选择它。
- en: 'In the **Details** panel, locate the **Smart Object** category and set the
    **Smart Object Definition** property to **SOD_Workbench** . The viewport should
    now look like the one shown in *Figure 14* *.4* :'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，定位**智能对象**类别并将**智能对象定义**属性设置为**SOD_Workbench**。现在视口应该看起来像*图 14.4*中所示：
- en: '![Figure 14.4 – Viewport](img/Figure_14.4_B31016.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 视口](img/Figure_14.4_B31016.jpg)'
- en: Figure 14.4 – Viewport
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 视口
- en: 'Now, open the **Event Graph** panel and do the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开**事件图**面板并执行以下步骤：
- en: Add an **OnSmartObjectEvent** node.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**OnSmartObjectEvent**节点。
- en: Connect the **Event Data** pin to a **Break** **SmartObjectEventData** node.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**事件数据**引脚连接到**断点** **SmartObjectEventData**节点。
- en: 'Connect the **Reason** pin of the **Break SmartObjectEventData** node to a
    **Switch on ESmartObjectChangeReason** node and click the **Expand** button to
    show all the switch cases. The graph so far should look like *Figure 14* *.5*
    :'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Break SmartObjectEventData**节点的**原因**引脚连接到**根据ESmartObjectChangeReason切换**节点，并点击**展开**按钮以显示所有切换情况。到目前为止，图应该看起来像*图
    14.5*：
- en: '![Figure 14.5 – Starting graph](img/Figure_14.5_B31016.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 开始图](img/Figure_14.5_B31016.jpg)'
- en: Figure 14.5 – Starting graph
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 开始图
- en: What we are doing here is quite simple; every time we get an event from the
    smart object, we check what has caused the event. This will serve us to respond
    to any interaction from the AI agent. Let’s continue the code logic by doing the
    following steps.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是相当简单的；每次我们从智能对象获取事件时，我们都会检查是什么导致了这个事件。这将帮助我们响应来自人工智能代理的任何交互。让我们通过以下步骤继续代码逻辑。
- en: Connect the **Interactor** pin of the **OnSmartObject Event** node to a **Get**
    **AIController** node.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**OnSmartObject Event**节点的**交互者**引脚连接到**获取** **AIController**节点。
- en: Connect **Return Value** of the **Get AIController** node to a **Get** **Blackboard**
    node.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**获取AI控制器**节点的**返回值**连接到**获取** **黑板**节点。
- en: '![Figure 14.6 – Retrieve Blackboard](img/Figure_14.6_B31016.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – 检索黑板](img/Figure_14.6_B31016.jpg)'
- en: Figure 14.6 – Retrieve Blackboard
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 检索黑板
- en: Connect the **Return Value** pin of the **Get Blackboard** node to a **Set Value
    as** **Bool** node.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**获取黑板**节点的**返回值**引脚连接到**设置值作为** **布尔值**节点。
- en: Connect the **On Released** outgoing execution pin of the **Switch on ESmartObjectChangeReason**
    node to the incoming execution pin of the **Set Value as** **Bool** node.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Switch on ESmartObjectChangeReason**节点的**On Released**输出执行引脚连接到**设置值作为**
    **布尔值**节点的输入执行引脚。
- en: 'Click and drag from the **Key Name** pin of the **Set Value as Bool** node.
    Release and, from the pop-up menu, select **Promote to variable** to create a
    new variable. In the **Variables** panel, name the newly created variable **NeedsReloadKeyName**
    , so that the node in the graph will show a **Needs Reloading Key Name** label.
    This part of the graph is shown in *Figure 14* *.7* :'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从**设置值作为布尔值**节点的**键名**引脚处点击并拖动。释放鼠标，然后从弹出菜单中选择**提升为变量**以创建一个新变量。在**变量**面板中，将新创建的变量命名为**NeedsReloadKeyName**，这样图中的节点将显示**需要重新加载键名**标签。此部分图示在*图
    14.7*：
- en: '![Figure 14.7 – Set Blackboard key](img/Figure_14.7_B31016.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 设置黑板键](img/Figure_14.7_B31016.jpg)'
- en: Figure 14.7 – Set Blackboard key
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 设置黑板键
- en: Compile the Blueprint and set the variable **Default Value** property to **WeaponJammed**
    .
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图并将变量**默认值**属性设置为**WeaponJammed**。
- en: In this last part of the graph, we set a Blackboard key value of the AI agent
    that is interacting with the smart object. We are doing this at the **On Released**
    event, that is, when the smart object has been claimed, interacted with, and then
    released to be claimable again. This means we will fix the jammed gun once the
    AI agent has finished interacting with the smart object.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个图的最后部分，我们设置了与智能对象交互的AI代理的黑板键值。我们是在**On Released**事件中这样做，即当智能对象已被声明、交互并随后释放以再次可声明时。这意味着一旦AI代理完成与智能对象的交互，我们将修复卡壳的枪械。
- en: The Blackboard, and consequently, the **WeaponJammed** key, haven’t been implemented
    yet. In the next section, we will be working on the Blackboard itself and its
    related behavior tree in order to implement the AI agent.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板和随之而来的**WeaponJammed**键尚未实现。在下一节中，我们将着手处理黑板本身及其相关的行为树，以便实现AI代理。
- en: Interacting with smart objects
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与智能对象交互
- en: In this section, we will finalize the smart object system by creating an AI
    agent that will make good use of the previously created workbench Blueprint. As
    stated before, the AI agent will move around and shoot at random; from time to
    time, the gun will jam, and so the gunner will need to get to the workbench to
    fix it. The AI behavior will be handled by a behavior tree, and it will be quite
    straightforward, but it will help us understand how to interact with smart objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个将充分利用之前创建的工作台蓝图的人工智能代理来最终确定智能对象系统。如前所述，AI代理将在随机移动和射击；偶尔，枪械会卡壳，因此枪手需要前往工作台进行修理。AI行为将由行为树处理，它将相当直接，但将帮助我们了解如何与智能对象交互。
- en: Let’s start by creating a helpful task we will be using in the behavior tree.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个有用的任务，我们将在行为树中使用它。
- en: Creating the toss coin task
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建抛硬币任务
- en: We are now going to create a task that will simulate the gun jamming. This task
    will be some sort of weighted coin toss and will return a **bool** value – that
    is, a head or tails result. The weight of the toss will help us in defining how
    much the gun is prone to jamming. You should already be familiar with behavior
    tree tasks but, for a quick refresher, you can check [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148)
    , *Setting Up a* *Behavior Tree* .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个模拟枪械卡壳的任务。这个任务将是一种加权硬币抛掷，并返回一个**bool**值——即正面或反面的结果。抛掷的权重将帮助我们定义枪械卡壳的可能性有多大。您应该已经熟悉行为树任务，但为了快速回顾，您可以查看[*第8章*](B31016_08.xhtml#_idTextAnchor148)
    ，*设置行为树*。
- en: 'To implement this task, start by creating a new C++ class extending **BTTaskNode**
    and call it **BTTask_TossCoin** . Then, open the **BTTask_TossCoin.h** file and
    add the following block of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此任务，首先创建一个新的C++类，扩展**BTTaskNode**，并将其命名为**BTTask_TossCoin**。然后，打开**BTTask_TossCoin.h**文件并添加以下代码块：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The only thing worth mentioning here is the **TrueProbability** property, which
    will let us weight the result – in our case, the probability of jamming the gun.
    Now, open the **BTTask_TossCoin.cpp** file and add the following declaration at
    the top of it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得提及的只有**TrueProbability**属性，它将允许我们加权结果——在我们的案例中，是枪械卡壳的概率。现在，打开**BTTask_TossCoin.cpp**文件，并在其顶部添加以下声明：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The constructor is going to be really simple as it will just give a meaningful
    name to the node. Add the following code to your class implementation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将非常简单，因为它只会给节点一个有意义的名称。将以下代码添加到您的类实现中：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All the code logic is going to be placed inside the **ExecuteTask()** function.
    Let’s add this block of code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的代码逻辑都将放置在**ExecuteTask()**函数内部。让我们添加以下代码块：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, once we have retrieved the Blackboard component, we randomize
    a **bool** result and set a key value inside the Blackboard itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦我们检索到黑板组件，我们将随机生成一个**bool**结果，并在黑板本身中设置一个键值。
- en: With this class complete, we can now focus on a couple of environment queries
    that we will need inside the behavior tree.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个类后，我们现在可以专注于在行为树内部需要的一些环境查询。
- en: Creating environment queries
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建环境查询
- en: 'To implement the gunner behavior tree, we will need a couple of environment
    queries: one for generating a random location for the gunner to reach and one
    for finding the workbench smart object. Let’s start with the first one.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现枪手行为树，我们需要一些环境查询：一个用于生成枪手到达的随机位置，另一个用于查找工作台智能对象。让我们从第一个开始。
- en: Creating the FindShootLocation environment query
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建FindShootLocation环境查询
- en: 'This query will be in charge of generating a set of random locations on the
    **Nav Mesh** level; basically, we will create a grid of points and later select
    one of these points as a shooting spot. To do so, open the **AI** folder and create
    an environment query by going to **Artificial Intelligence** | **Environment Query**
    . Name it **EQS_FindShootLocation** . Open it and do the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将负责在**Nav Mesh**级别生成一组随机位置；基本上，我们将创建一个点阵，然后从这些点中选择一个作为射击点。为此，打开**AI**文件夹，通过**Artificial
    Intelligence** | **Environment Query**创建一个环境查询。将其命名为**EQS_FindShootLocation**。打开它并执行以下步骤：
- en: Inside the graph, connect the **ROOT** node to a **Points:** **Grid** node.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中，将**ROOT**节点连接到一个**Points:** **Grid**节点。
- en: Select the newly created node and set the **GridHalfSize** property to **2500.0**
    .
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新创建的节点，并将**GridHalfSize**属性设置为**2500.0**。
- en: Double-check that the **Projection Data** | **Trace Node** is set to **Navigation**
    .
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认**Projection Data** | **Trace Node**设置为**Navigation**。
- en: '![Figure 14.8 – FindShootLocation query](img/Figure_14.8_B31016.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – FindShootLocation查询](img/Figure_14.8_B31016.jpg)'
- en: Figure 14.8 – FindShootLocation query
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – FindShootLocation查询
- en: As you can see, we are using the nav mesh to look for a location; this will
    ensure that our agent will be capable of reaching the selected point.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用导航网格来寻找位置；这将确保我们的代理能够到达所选点。
- en: Creating the FindWorkbenchLocation environment query
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建FindWorkbenchLocation环境查询
- en: 'This second query will be a search for smart objects inside a predefined area.
    Let’s start by creating an environment query ( **Artificial Intelligence** | **Environment
    Query** ) and naming it **EQS_FindWorkbench** . Open it and do the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询将在预定义区域内搜索智能对象。让我们先创建一个环境查询（**Artificial Intelligence** | **Environment
    Query**），并将其命名为**EQS_FindWorkbench**。打开它并执行以下步骤：
- en: Inside the graph, connect the **ROOT** node to a **SmartObjects** node.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中，将**ROOT**节点连接到一个**SmartObjects**节点。
- en: Add an item in the **Behavior Definition Classes** array property by clicking
    the **+** button.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**+**按钮在**Behavior Definition Classes**数组属性中添加一个项。
- en: Set the item at **Index[0]** to **GameplayBehaviorSmartObjectBehaviorDefinition**
    .
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Index[0]**项设置为**GameplayBehaviorSmartObjectBehaviorDefinition**。
- en: Set the **Query Box Extent** to **(5000.0,** **5000.0, 500.0)** .
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Query Box Extent**设置为**(5000.0, 5000.0, 500.0)**。
- en: '![Figure 14.9 – FindWorkbench query](img/Figure_14.9_B31016.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – FindWorkbench查询](img/Figure_14.9_B31016.jpg)'
- en: Figure 14.9 – FindWorkbench query
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – FindWorkbench查询
- en: This query will look for any smart object with a behavior definition set to
    **GameplayBehaviorSmartObjectBehaviorDefinition** ; this is the default definition,
    and it is the one we used inside the **SOD_Workbench** asset. It should be noted
    that, for the sake of simplicity, we kept things at a very basic level here. I
    highly encourage you to try implementing a filtering system by using tag filters
    or by extending your own behavior definition for the workbench or any other smart
    object you will be adding to the level.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将寻找任何设置为**GameplayBehaviorSmartObjectBehaviorDefinition**的行为定义的智能对象；这是默认定义，也是我们在**SOD_Workbench**资产中使用的定义。需要注意的是，为了简化，我们在这里保持了非常基础的级别。我强烈建议您尝试通过使用标签过滤器或扩展您自己的工作台或其他智能对象的行为定义来实现一个过滤系统。
- en: With environment queries finished, we can start implementing the behavior trees,
    starting from the Blackboard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当环境查询完成后，我们可以开始实现行为树，从黑板开始。
- en: Creating the Blackboard
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建黑板
- en: 'The Blackboard for our AI agent will need to store two locations: one for the
    shooting target and another for the workbench. Additionally, there should be a
    flag to indicate whether the gun is jammed. Let’s begin by creating a Blackboard
    and naming it **BB_Tinkerer** to clearly reflect the capabilities of our AI agent.
    Then, add the following keys:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人工智能代理的黑板需要存储两个位置：一个用于射击目标，另一个用于工作台。此外，应该有一个标志来指示枪是否卡住。让我们先创建一个黑板，并将其命名为**BB_Tinkerer**，以清楚地反映我们人工智能代理的能力。然后，添加以下键：
- en: A **Vector** named **WorkbenchLocation**
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为**WorkbenchLocation**的**Vector**
- en: A **Vector** named **ShootLocation**
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为**ShootLocation**的**Vector**
- en: A **Bool** named **WeaponJammed**
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为**WeaponJammed**的**Bool**
- en: With the Blackboard finalized, we are ready to create the behavior tree.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当黑板完成设置后，我们就可以创建行为树了。
- en: Creating the behavior tree
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建行为树
- en: 'The behavior tree is going to have two main subbranches that will handle the
    case when the gun is jammed and when it is not. Let’s start by creating a new
    behavior tree and calling it **BT_Tinkerer** . Open it and set the **Blackboard
    Asset** property to **BB_Tinkerer** . Then, do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树将有两个主要子分支来处理枪支卡住和不卡住的情况。让我们先创建一个新的行为树，命名为 **BT_Tinkerer** 。打开它，并将 **Blackboard
    Asset** 属性设置为 **BB_Tinkerer** 。然后，执行以下操作：
- en: Connect the **ROOT** node to a **Selector** node; call it **Root Selector**
    .
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **ROOT** 节点连接到一个 **Selector** 节点；命名为 **Root Selector** 。
- en: Add two **Sequence** nodes to the **Root Selector** node. Call the left one
    **Shoot Sequence** and the right one **Fix Sequence** .
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Root Selector** 节点添加两个 **Sequence** 节点。左边的命名为 **Shoot Sequence** ，右边的命名为
    **Fix Sequence** 。
- en: Add a **Blackboard Decorator** to the **Shoot Sequence** node and select it.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Shoot Sequence** 节点添加一个 **Blackboard Decorator** 并选择它。
- en: 'In the **Details** panel, do the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Details** 面板中执行以下操作：
- en: Set the **Notify Observer** property to **On** **Value Change**
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Notify Observer** 属性设置为 **On Value Change**
- en: Set the **Key Query** property to **Is** **Not Set**
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Key Query** 属性设置为 **Is Not Set**
- en: Set the **Blackboard Key** to **WeaponJammed**
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Blackboard Key** 设置为 **WeaponJammed**
- en: 'The graph so far should look like the one shown in *Figure 14* *.10* :'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，图表应该看起来像 *图 14.10* 中所示的那样：
- en: '![Figure 14.10 – Sequences](img/Figure_14.10_B31016.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – 序列](img/Figure_14.10_B31016.jpg)'
- en: Figure 14.10 – Sequences
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 序列
- en: 'Let’s now focus on the **Shoot Sequence** section of the graph. Start by doing
    the following steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于图表中的 **Shoot Sequence** 部分。首先执行以下步骤：
- en: Add a **Move To** task, name it **Move to Shoot Location** , and set the **Blackboard
    Key** property to **ShootLocation** .
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **Move To** 任务，命名为 **Move to Shoot Location** ，并将 **Blackboard Key** 属性设置为
    **ShootLocation** 。
- en: Add a **PlayMontage** task to the right of the **Move to Shoot Location** task,
    name it **Play Shoot Montage** , and set the **Anim Montage** property to **AM_1H_Shoot**
    .
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Move to Shoot Location** 任务右侧添加一个 **PlayMontage** 任务，命名为 **Play Shoot Montage**
    ，并将 **Anim Montage** 属性设置为 **AM_1H_Shoot** 。
- en: Add a **Wait** task to the right of the **Play Shoot Montage** task. Set the
    **Wait Time** property to **3.0** and **Random Deviation** to **0.5** .
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Play Shoot Montage** 任务右侧添加一个 **Wait** 任务。将 **Wait Time** 属性设置为 **3.0**
    和 **Random Deviation** 设置为 **0.5** 。
- en: Add a **TossCoin** task to the right of the **Wait** task, name it **Randomize
    Jam** , set the **Blackboard Key** property to **WeaponJammed** , and set the
    **True Probability** property to **0.35** .
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Wait** 任务右侧添加一个 **TossCoin** 任务，命名为 **Randomize Jam** ，将 **Blackboard Key**
    属性设置为 **WeaponJammed** ，并将 **True Probability** 属性设置为 **0.35** 。
- en: 'The **Shoot Sequence** section of the graph should look like the one depicted
    in *Figure 14* *.11* :'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图表的 **Shoot Sequence** 部分应该看起来像 *图 14.11* 中描述的那样：
- en: '![Figure 14.11 – Shoot Sequence](img/Figure_14.11_B31016.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 射击序列](img/Figure_14.11_B31016.jpg)'
- en: Figure 14.11 – Shoot Sequence
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 射击序列
- en: 'This portion of the graph will move the AI agent to a selected location, start
    the shooting sequence, wait a short time, and check whether the gun is jammed.
    However, we need to add a service to make it fully functional. Let’s start by
    selecting **Move to Shoot Location** and adding a **Run EQSQuery** node. Select
    the query service and, in the **Details** panel, do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的这部分将移动 AI 代理到选定的位置，开始射击序列，等待一段时间，并检查枪是否卡住。然而，我们需要添加一个服务使其完全功能化。让我们先选择 **Move
    to Shoot Location** 并添加一个 **Run EQSQuery** 节点。选择查询服务，并在 **Details** 面板中执行以下操作：
- en: Name it **Find** **Shoot Location** .
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为 **Find Shoot Location** 。
- en: Set the **Query Template** property to **EQS_FindShootLocation** .
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Query Template** 属性设置为 **EQS_FindShootLocation** 。
- en: Set **Run Mode** to **Single Random Item from** **Best 25%** .
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Run Mode** 设置为 **从最佳 25% 中随机选择一个项目** 。
- en: 'Set the **Blackboard Key** property to **ShootLocation** . *Figure 14* *.12*
    shows the finalized **Shoot Sequence** section of the graph:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Blackboard Key** 属性设置为 **ShootLocation** 。*图 14.12* 显示了图表中最终的 **Shoot Sequence**
    部分：
- en: '![Figure 14.12 – Finalized ShootSequence](img/Figure_14.12_B31016.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 最终的射击序列](img/Figure_14.12_B31016.jpg)'
- en: Figure 14.12 – Finalized ShootSequence
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 最终的射击序列
- en: This service will execute the environment query that will select one random
    item from the generated locations, assigning it to the **ShootLocation** property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务将执行环境查询，从生成的位置中选择一个随机项目，并将其分配给 **ShootLocation** 属性。
- en: 'With this portion of the behavior tree complete, we can focus on the **Fix
    Sequence** section of the graph. Follow these steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分行为树完成之后，我们可以专注于图表的 **Fix Sequence** 部分。按照以下步骤操作：
- en: Add a **Move To** task, name it **Move to Workbench Location** , and set the
    **Blackboard Key** property to **WorkbenchLocation** .
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**移动到**任务，命名为**移动到工作台位置**，并将**黑板键**属性设置为**WorkbenchLocation**。
- en: Add a **PlayMontage** task to the right of the **Move to Workbench Location**
    task, name it **Play Reload Montage** , and set the **Anim Montage** property
    to **AM_1H_Reload** .
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**移动到工作台位置**任务右侧添加一个**播放剪辑**任务，命名为**播放装弹剪辑**，并将**动画剪辑**属性设置为**AM_1H_Reload**。
- en: Add a **Wait** task to the right of the **Play Shoot Montage** task. Set the
    **Wait Time** property to **3.0** and **Random Deviation** to **0.5** .
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**播放射击剪辑**任务右侧添加一个**等待**任务。将**等待时间**属性设置为**3.0**，并将**随机偏差**设置为**0.5**。
- en: 'Add a **FindAndUseGameplayBehaviorSmartObject** task to the right of the **Wait**
    task, name it **Use Workbench** , set the **Query Template** property to **EQS_FindWorkbench**
    , and set the **RunMode** property to **Single Best Item** . The **Fix Sequence**
    should look like the one depicted in *Figure 14* *.13* :'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**等待**任务右侧添加一个**查找并使用游戏行为智能对象**任务，命名为**使用工作台**，将**查询模板**属性设置为**EQS_FindWorkbench**，并将**运行模式**属性设置为**单次最佳项**。**修复序列**应类似于*图14*
    *.13* 中所示：
- en: '![Figure 14.13 – Fix Sequence](img/Figure_14.13_B31016.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图14.13 – 修复序列](img/Figure_14.13_B31016.jpg)'
- en: Figure 14.13 – Fix Sequence
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 – 修复序列
- en: You are already familiar with most of the graph, but the last task needs some
    explanation as it is the most important one. It will find a suitable smart object,
    claim it, and use it. Then it will release the resource. Although you don’t have
    full control of each of the phases of the smart object as they are executed one
    after the other, it is quite handy when implementing simple behaviors such as
    the one we created.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了大多数图形，但最后一个任务需要一些解释，因为它是最重要的。它将找到一个合适的智能对象，声明它并使用它。然后它将释放资源。尽管你无法完全控制智能对象的每个阶段，因为它们一个接一个地执行，但在实现像我们创建的简单行为时非常方便。
- en: 'The last thing we need to add is a service that will find the workbench in
    the level. To implement this, select the **Move to Workbench Location** task and
    add a **Run EQSQuery** node. Select the query service and, in the **Details**
    panel, do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要添加一个服务来在关卡中查找工作台。为此，选择**移动到工作台位置**任务并添加一个**运行EQS查询**节点。选择查询服务，并在**详细信息**面板中执行以下操作：
- en: Name it **Find** **Workbench Location** .
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为**查找****工作台位置**。
- en: Set the **Query Template** property to **EQS_FindWorkbench** .
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**查询模板**属性设置为**EQS_FindWorkbench**。
- en: Set the **Run Mode** attribute to **Single** **Best Item** .
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**运行模式**属性设置为**单次****最佳项**。
- en: 'Set the **Blackboard Key** property to **WorkbenchLocation** . *Figure 14*
    *.14* shows the finalized **FixSequence** section of the graph:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**黑板键**属性设置为**工作台位置**。*图14* *.14* 显示了图形的最终**修复序列**部分：
- en: '![Figure 14.14 – Finalized FixSequence](img/Figure_14.14_B31016.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图14.14 – 最终修复序列](img/Figure_14.14_B31016.jpg)'
- en: Figure 14.14 – Finalized FixSequence
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 – 最终修复序列
- en: The behavior tree is now complete; we just need to integrate it into an AI agent
    and observe its behavior.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树现在已完成；我们只需将其集成到AI代理中并观察其行为。
- en: Creating the character Blueprints
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建角色蓝图
- en: To finalize our AI agent, we need to create the AI controller and the character
    Blueprints. Luckily, we have already implemented the necessary classes, and we
    just need to extend them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终完成我们的AI代理，我们需要创建AI控制器和角色蓝图。幸运的是，我们已经实现了必要的类，我们只需要扩展它们。
- en: 'Let’s start with the AI controller by doing the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下步骤开始AI控制器：
- en: In the **Blueprints** folder, create a new Blueprint class extending from **BaseDummyAIController**
    .
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**蓝图**文件夹中，创建一个新的蓝图类，从**BaseDummyAIController**扩展。
- en: Name it **AITikererDummyController** and open it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为**AITikererDummyController**并打开它。
- en: Set the **Behavior Tree** property to **BT_Tinkerer** .
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**行为树**属性设置为**BT_Tinkerer**。
- en: 'It’s now time to create the character, so do the following steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建角色的时候了，请按照以下步骤操作：
- en: In the **Blueprints** folder, right-click on **BP_GunnerDummyCharacter** and
    select **Create Child** **Blueprint Class** .
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**蓝图**文件夹中，右键单击**BP_GunnerDummyCharacter**并选择**创建子****蓝图类**。
- en: Name the newly created asset **BP_TinkererDummyCharacter** and open it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的资产命名为**BP_TinkererDummyCharacter**并打开它。
- en: In the **Details** panel, set the **AI Controller Class** property to **AITinkererDummyController**
    .
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，将**AI控制器类**属性设置为**AITinkererDummyController**。
- en: We are now ready to test things out in a gym.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在健身房测试了。
- en: Testing smart objects in a gym
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在健身房测试智能对象
- en: By now, you should be familiar with the process of creating and testing a gym,
    so just create a new level of your choice with a **NavMeshBoundsVolume** actor
    in order to make your AI agent move through the pathfinding system. Then, add
    a **BP_Tinkerer** instance and a **BP_Workbench** instance to the level and start
    the simulation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了创建和测试健身房的过程，所以只需创建一个新的等级，并在其中添加一个**NavMeshBoundsVolume**演员，以便让你的AI代理能够通过寻路系统移动。然后，将一个**BP_Tinkerer**实例和一个**BP_Workbench**实例添加到等级中，并开始模拟。
- en: You should observe the AI agent moving around and shooting. Occasionally, the
    weapon will jam, prompting the agent to search for a workbench to repair it before
    returning to its shooting activities.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会观察到AI代理四处移动和射击。偶尔，武器会卡住，促使代理寻找工作台进行修理，然后再返回射击活动。
- en: '![Figure 14.15 – Finalized fix sequence](img/Figure_14.15_B31016.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.15 – 最终修复序列](img/Figure_14.15_B31016.jpg)'
- en: Figure 14.15 – Finalized fix sequence
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15 – 最终修复序列
- en: In this section, we created an introductory yet fully functional gym that effectively
    uses smart objects. I highly encourage you to experiment with things a bit by
    adjusting the jam probability or adding more workbenches and gunners to observe
    how these changes affect the overall behavior.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个入门级但功能齐全的健身房，有效地使用了智能对象。我强烈鼓励你通过调整卡住概率或添加更多工作台和枪手来尝试一些事情，以观察这些变化如何影响整体行为。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we learned about Smart Objects, an advanced framework
    created to assist developers in building interactive and context-aware elements
    in a game. Smart Objects aim to enrich gameplay by enabling player characters
    and AI agents to engage with the environment more meaningfully through a reservation
    system, as we learned in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们学习了智能对象，这是一个高级框架，旨在帮助开发者构建游戏中的交互式和上下文感知元素。智能对象的目标是通过预订系统使玩家角色和AI代理能够更深入地与环境互动，从而丰富游戏体验，正如我们在本章所学。
- en: As a developer, you will benefit from using Smart Objects by creating more immersive
    and interactive gameplay experiences, as environment objects will enable complex
    behaviors and context-sensitive interactions within the game world. By leveraging
    this technology, your games will become increasingly captivating and engaging
    for your players.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，通过使用智能对象，你可以创建更加沉浸式和互动的游戏体验，因为环境对象将使游戏世界中的对象能够实现复杂的行为和上下文相关的交互。利用这项技术，你的游戏将越来越吸引玩家，并使他们更加投入。
- en: Epilogue
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后记
- en: '*In their secret laboratory, Dr. Markus and Professor Viktoria watched as their
    AI dummy puppets prepared for an epic battle, armed with colorful* *Nerf guns.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*在他们的秘密实验室里，马克斯博士和维克托利亚教授看着他们的AI木偶准备进行一场史诗般的战斗，手持五彩缤纷的* *飞镖枪* *。*'
- en: '*Markus laughed as a bold puppet dashed from behind a lab table, launching
    foam darts. “We’ve created the world’s first AI Nerf combat league!” He* *proudly
    exclaimed.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*马克斯笑着，一个大胆的木偶从实验室桌子后面冲出来，发射泡沫飞镖。“我们创造了世界上第一个AI飞镖战斗联赛！”他* *自豪地宣称* *。'
- en: '*Viktoria grinned, delighted by their creations’ enthusiasm. “Who knew they’d
    embrace battle* *so eagerly?”*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*维克托利亚笑着，对他们的创造物的热情感到高兴。“谁知道他们会如此热情地拥抱战斗* *呢？”*'
- en: '*With the glow of monitors casting light across the lab, Markus suggested,
    “What’s next? A* *championship tournament?”*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*随着显示器发出的光芒照亮整个实验室，马克斯建议，“接下来是什么？一场* *锦标赛？”*'
- en: '*“Absolutely!” Viktoria replied, her* *excitement infectious.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*“绝对！”维克托利亚回答，她的* *兴奋具有传染性* *。'
- en: '*In that hidden haven of innovation, they realized they had built something
    extraordinary – a whimsical world of creativity and friendly competition, bursting
    with* *endless possibilities.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*在那个隐藏的创新天堂中，他们意识到他们已经创造了一些非凡的东西——一个充满创造力和友好竞争的奇妙世界，充满了* *无限的可能性* *。'
- en: So, this is the end of this book; I hope you enjoyed it as much as I enjoyed
    writing it!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这本书到此结束；我希望你和我写作时一样喜欢它！
- en: This is just the start of your exciting journey into the amazing world of artificial
    intelligence development in Unreal Engine! You might be asking yourself, “ *What’s
    next?* ”. I totally understand that it can feel a bit overwhelming with all the
    plugins, frameworks, and technologies I presented. To help you out, I’ve put together
    a fun new task for you! In the project template, you will find a level called
    **CaptureTheFlag** . Feel free to dive in and create your very own *Capture the
    Flag* game featuring the dummy puppets as main characters. Try to combine everything
    you’ve learned so far to develop your own AI agents.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是您进入虚幻引擎中令人兴奋的人工智能开发世界的起点！你可能正在问自己，“下一步是什么？”我完全理解，面对我展示的所有插件、框架和技术，可能会感到有些不知所措。为了帮助您，我已经为您准备了一个有趣的新任务！在项目模板中，您将找到一个名为
    **CaptureTheFlag** 的关卡。请随意深入其中，创建您自己的以木偶为主角的 *Capture the Flag* 游戏。尝试将您迄今为止所学的一切结合起来，开发您自己的
    AI 代理。
- en: Dive into this with all the enthusiasm you can muster and don’t be afraid to
    experiment and play around. Remember, the best experiences often come from letting
    loose and having a great time, so go ahead and make it your own.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以您能聚集的所有热情投身其中，不要害怕实验和玩耍。记住，最好的体验往往来自于放松和享受乐趣，所以请尽情发挥，让它成为你自己的。
- en: Have a blast!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 玩得开心！
- en: Appendix – Understanding C++ in Unreal Engine
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录——理解虚幻引擎中的 C++
- en: This appendix has been written to provide you with additional insights, resources,
    and practical information to enhance your understanding of C++ programming within
    the Unreal Engine framework. This will help you as a refresher or as a reference
    throughout the book, just in case you need some help when following the presented
    code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录旨在为您提供额外的见解、资源和实用信息，以增强您对虚幻引擎框架中 C++ 编程的理解。这将帮助您在阅读本书时作为复习或参考，以防在跟随展示的代码时需要帮助。
- en: This appendix serves as a valuable reference that complements the main content
    of the book, providing you with the tools and information needed to successfully
    navigate the exciting world of C++ in Unreal Engine. Whether you’re a mid-experienced
    developer looking to refine your skills or a proficient C++ programmer with little
    Unreal Engine experience, I hope this appendix will enrich your learning experience!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录作为一本宝贵参考书，补充了本书的主要内容，为您提供在虚幻引擎中成功导航 C++ 世界所需的技术和信息。无论您是经验丰富的开发者，希望提高自己的技能，还是对虚幻引擎经验较少的熟练
    C++ 程序员，我希望这个附录能丰富您的学习体验！
- en: 'We will be covering the following topics:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Introducing basic concepts
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍基本概念
- en: Explaining advanced features
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释高级功能
- en: Exploring core mechanics
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索核心机制
- en: Technical requirements
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have some good knowledge
    about programming, particularly some basic understanding of the C++ language.
    Additionally, you will need a good understanding of the Unreal Engine.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章介绍的主题，您应该对编程有一定的了解，特别是对 C++ 语言的一些基本理解。此外，您还需要对虚幻引擎有良好的理解。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter will provide a gentle introduction to the main topics related to
    using C++ in Unreal Engine. For a more comprehensive exploration of programming
    in C++ with Unreal Engine, I recommend checking out Zhenyu George Li’s book titled
    *Unreal Engine 5 Game Development with C++ Scripting* , published by Packt.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供一个轻松的介绍，涉及在虚幻引擎中使用 C++ 的主要主题。如果您想更全面地探索使用虚幻引擎进行 C++ 编程，我建议您阅读 Zhenyu
    George Li 的书籍，书名为《Unreal Engine 5 Game Development with C++ Scripting》，由 Packt
    出版。
- en: Introducing basic concepts
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍基本概念
- en: If you share my passion for game development and programming, you’ll probably
    agree that writing C++ code in Unreal Engine is both enjoyable and surprisingly
    accessible. Epic Games has done an excellent job of incorporating features that
    simplify C++ usage for nearly every programmer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样热爱游戏开发和编程，你可能会同意在虚幻引擎中编写 C++ 代码既愉快又出人意料地容易。Epic Games 在整合简化 C++ 使用的功能方面做得非常出色，这些功能几乎适用于每一位程序员。
- en: While it is indeed possible to write standard C++ code in Unreal Engine, leveraging
    the engine’s most widely used features – such as the built-in garbage collector
    and reflection system – will help you achieve better performance in your games.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在虚幻引擎中确实可以编写标准的 C++ 代码，但利用引擎最广泛使用的功能——例如内置的垃圾回收器和反射系统——将有助于你在游戏中实现更好的性能。
- en: In this section, I’ll be covering the basic principles behind Unreal Engine
    C++ features.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍Unreal Engine C++特性的基本原理。
- en: Understanding C++ classes
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C++类
- en: Unsurprisingly enough, an Unreal Engine C++ class is essentially a standard
    C++ class! If you already have a solid understanding of object-oriented programming
    in C++, you’ll find the environment quite familiar. The process of creating a
    new C++ class starts by determining the type of object you want to represent,
    such as an actor or a component. After defining the type, you declare variables
    and methods in the **header file** (which uses the **.h** extension) and implement
    the logic in the **source file** (which uses the **.** **cpp** extension).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，Unreal Engine C++类本质上是一个标准的C++类！如果你已经对C++中的面向对象编程有扎实的理解，你会发现这个环境非常熟悉。创建新的C++类的过程首先是通过确定你想要表示的对象类型，例如演员或组件。在定义类型后，你在**头文件**（使用**.h**扩展名）中声明变量和方法，并在**源文件**（使用**.cpp**扩展名）中实现逻辑。
- en: The source file works just like any regular C++ file, but the header file allows
    you to specify additional information for variables and functions that will be
    accessible to Blueprints inheriting from your class. This also simplifies runtime
    memory management, as I will explain later.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件的工作方式与任何常规的C++文件相同，但头文件允许你为将可由继承自你的类的Blueprint访问的变量和函数指定附加信息。这也简化了运行时内存管理，我将在稍后解释。
- en: Let’s start by presenting the base types used by the Unreal Engine framework.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍Unreal Engine框架使用的基类型。
- en: The base types
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本类型
- en: 'In UE, there are three primary class types that you’ll be deriving from during
    development:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE中，开发过程中你将主要从以下三种类类型中进行派生：
- en: '**UObject** : This is the base class of Unreal Engine, providing core features
    such as networking support and reflection of properties and methods'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UObject**：这是Unreal Engine的基类，提供了如网络支持和属性及方法反射的核心功能'
- en: '**AActor** : This is a **UObject** type that can be added to a game level,
    either through the Editor or at runtime'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AActor**：这是一个**UObject**类型，可以通过编辑器或运行时添加到游戏关卡中'
- en: '**UActorComponent** : This is the fundamental class for defining components
    that can be attached to an actor, or another component belonging to the same actor'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UActorComponent**：这是定义可以附加到演员或同一演员的另一个组件的组件的基本类'
- en: 'Additionally, UE provides the following entities:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，UE还提供了以下实体：
- en: '**UStruct** : This is used to create simple data structures'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UStruct**：用于创建简单的数据结构'
- en: '**UEnum** : This is used to represent enumerations of elements'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UEnum**：用于表示元素枚举'
- en: Unreal Engine prefixes
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unreal Engine前缀
- en: 'Unreal Engine class names begin with specific letters; these prefixes are used
    to indicate the class type. The main prefixes used are as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine类名以特定的字母开头；这些前缀用于指示类类型。主要使用的前缀如下：
- en: '**U** : This is used for generic objects that derive from **UObject** , such
    as components. A good example is the **UStaticMeshComponent** class.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**U**：用于从**UObject**派生的泛型对象，例如组件。一个很好的例子是**UStaticMeshComponent**类。'
- en: '**A** : This is used for objects that derive from an actor – that is, the **AActor**
    class – and that can be added to a level.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**：用于从演员（即**AActor**类）派生的对象，并且可以添加到关卡中。'
- en: '**F** : This is used for generic classes and structures, such as the **FColor**
    structure.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F**：用于泛型类和结构，例如**FColor**结构。'
- en: '**T** : This is used for templates, such as **TArray** or **TMap** .'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T**：用于模板，例如**TArray**或**TMap**。'
- en: '**I** : This is used for interfaces, such as **IGameplayTaskOwnerInterface**
    .'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：用于接口，例如**IGameplayTaskOwnerInterface**。'
- en: '**E** : This is used for enums, such as **EActorBeginPlayState** .'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**E**：用于枚举，例如**EActorBeginPlayState**。'
- en: Note that these prefixes are mandatory; if you attempt to name a class that
    derives from **AActor** without the **A** prefix, you will encounter an error
    at compile time. This rule applies exclusively to C++ classes; Blueprints can
    be named without these prefixes. Unreal Engine will hide the C++ prefix once you
    are in the Editor.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些前缀是强制性的；如果你尝试命名一个从**AActor**派生的类而没有**A**前缀，你将在编译时遇到错误。此规则仅适用于C++类；Blueprint可以没有这些前缀命名。一旦你进入编辑器，Unreal
    Engine将隐藏C++前缀。
- en: Properties
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: As you may already know, in programming languages, a **property** refers to
    a variable that is declared within a class. Adding properties to a C++ class requires
    some extra attention – specifically, we need to consider whether the code we write
    should be visible or hidden from the Blueprints that will inherit from our class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道的，在编程语言中，**属性**指的是在类内部声明的变量。向C++类添加属性需要一些额外的注意——具体来说，我们需要考虑我们编写的代码是否应该对从我们的类继承的蓝图可见或隐藏。
- en: Declaring a property
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明属性
- en: 'A property is declared using the standard C++ syntax for variable declaration,
    preceded by the **UPROPERTY()** macro, which specifies various attributes – such
    as visibility in Blueprints – and any relevant metadata. As an example, consider
    the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 属性声明使用标准的C++变量声明语法，在**UPROPERTY()**宏之前，该宏指定了各种属性——例如在蓝图中的可见性——以及任何相关的元数据。以下是一个示例代码：
- en: '[PRE4]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, setting the **Damage** variable as **VisibleAnywhere**
    will make the property visible to a Blueprint, but not modifiable. Additionally,
    it will be logically grouped under the **Damage** category in the **Details**
    panel.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，将**Damage**变量设置为**VisibleAnywhere**将使该属性在蓝图上可见，但不能修改。此外，它将在**Details**面板的**Damage**类别中进行逻辑分组。
- en: Property specifiers
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性指定符
- en: 'As you have already noticed, the **UPROPERTY()** can include a list of parameters,
    called **property specifiers** , that will add additional functionality to a property.
    Some of them are listed here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您已经注意到的，**UPROPERTY()**可以包含一个参数列表，称为**属性指定符**，它将为属性添加额外的功能。其中一些列在这里：
- en: '**VisibleAnywhere** : The property is displayed but cannot be modified in the
    **Details** panel'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VisibleAnywhere**：属性在**Details**面板中显示，但不能修改。'
- en: '**EditAnywhere** : The property can be modified in the **Details** panel for
    both Blueprints and instances placed in the level'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EditAnywhere**：属性可以在**Details**面板中修改，无论是蓝图还是放置在关卡中的实例。'
- en: '**EditDefaultsOnly** : The property can be modified in the **Details** panel
    of the Blueprint but not in instances placed in the level'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EditDefaultsOnly**：属性可以在蓝图的**Details**面板中修改，但不能在放置在关卡中的实例中进行修改。'
- en: '**EditInstanceOnly** : The property can be modified in the **Details** panel
    of instances placed in the level but not in the Blueprint'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EditInstanceOnly**：属性可以在放置在关卡中的实例的**Details**面板中修改，但不能在蓝图中进行修改。'
- en: '**BlueprintReadOnly** : The property can be read within the Blueprint but cannot
    be assigned'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BlueprintReadOnly**：属性可以在蓝图中被读取，但不能被分配。'
- en: '**BlueprintReadWrite** : The property can be both read and assigned within
    the Blueprint'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BlueprintReadWrite**：属性可以在蓝图中被读取和分配。'
- en: Functions
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions work just like regular C++ functions. Additionally, just like properties,
    you can decorate them with a macro – in this case, **UFUNCTION()** – that can
    contain proper specifiers. As an example, consider the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与常规C++函数的工作方式相同。此外，就像属性一样，您可以用宏——在这种情况下，**UFUNCTION()**——对其进行装饰，该宏可以包含适当的指定符。以下是一个示例代码：
- en: '[PRE5]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the function can be called from a child Blueprint, as it has been
    decorated with the **BlueprintCallable** specifier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数可以从子蓝图中调用，因为它已经用**BlueprintCallable**指定符进行了装饰。
- en: 'For a full list of property and function specifiers, visit the official documentation:
    [https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine)
    .'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取属性和函数指定符的完整列表，请访问官方文档：[https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine)。
- en: The C++ Header Preview
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++头文件预览
- en: 'Unreal Engine comes packed with an incredible inspection tool called the **C++
    Header Preview** , which enables you to examine your Blueprint classes as if they
    were written in C++. To activate this tool, simply navigate to the main menu and
    select **Tools** | **C++ Header Preview** , and then choose your desired class.
    For example, *Figure A.1* displays the header file of **BP_Scrambler** from this
    book project:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine内置了一个令人难以置信的检查工具，称为**C++ Header Preview**，它允许您像C++编写的蓝图类一样检查您的蓝图类。要激活此工具，只需导航到主菜单并选择**Tools**
    | **C++ Header Preview**，然后选择您希望查看的类。例如，*图A.1*显示了本书项目中**BP_Scrambler**的头文件：
- en: '![img](img/Figure_A.1_B31016.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Figure_A.1_B31016.jpg)'
- en: Figure A.1 – The C++ Header Preview tool
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1 – C++头文件预览工具
- en: This is an amazing tool if already have some Blueprint knowledge and want to
    be gently introduced to C++ programming.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一些蓝图知识，并希望温和地接触C++编程，这是一个令人惊叹的工具。
- en: In this section, I have introduced you to some of the most basic features of
    C++ in Unreal Engine; in the next section, I will introduce some more advanced
    features that you may already be familiar with in C++ but that are handled somewhat
    differently in Unreal Engine.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我向你介绍了虚幻引擎中C++的一些最基本的功能；在下一节中，我将介绍一些你可能已经在C++中熟悉但虚幻引擎中处理方式略有不同的更高级功能。
- en: Explaining advanced features
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释高级功能
- en: In this section, we are going to explore how Unreal Engine copes with some of
    the common features of C++, such as casting and delegates.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨虚幻引擎如何处理C++的一些常见功能，如类型转换和代表。
- en: Casting
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'In C++ – and other programming languages, **casting** is the process of converting
    a variable from one data type to another. It allows you to treat an object as
    a different type, which can be useful in various situations, such as when working
    with inheritance or interfacing with APIs. To cast in Unreal Engine, you use the
    **Cast<T>()** method. As an example, take a look at the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++（以及其他编程语言）中，**类型转换**是将变量从一种数据类型转换为另一种数据类型的过程。它允许你将对象视为不同类型，这在各种情况下可能很有用，例如在处理继承或与API接口时。要在虚幻引擎中进行类型转换，你使用**Cast<T>()**方法。以下是一个示例代码：
- en: '[PRE6]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we are trying to cast an **Actor** pointer to an **APlayerCharacter**
    type.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在尝试将**Actor**指针转换为**APlayerCharacter**类型。
- en: In Unreal Engine, the **Cast<T>()** function is a safe way to cast pointers
    to a specific class type, as your code will return **nullptr** instead of crashing
    when the cast itself fails.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**Cast<T>()**函数是一个安全地将指针转换为特定类类型的类型转换方法，因为当类型转换失败时，你的代码将返回**nullptr**而不是崩溃。
- en: Casting in Unreal Engine should be approached with caution for several reasons.
    First, it can introduce performance overhead; this can slow down your game if
    used frequently. Additionally, excessive casting can complicate code readability
    and understanding. It may obscure the relationships between classes, making it
    harder for developers to grasp the structure of the code base. One effective way
    to reduce class dependencies is by using interfaces.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中进行类型转换应谨慎对待，有多个原因。首先，它可能会引入性能开销；如果频繁使用，这可能会减慢你的游戏。此外，过多的类型转换可能会使代码可读性和理解性复杂化。它可能会掩盖类之间的关系，使得开发者更难掌握代码库的结构。减少类依赖关系的一个有效方法是通过使用接口。
- en: Interfaces
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: In many programming languages, **interfaces** provide a way to define functions
    for multiple classes without requiring any specific implementation. For example,
    your player character might activate different items in different ways. By defining
    an interface that declares an **Activate()** method, each item implementing the
    interface will define its own personal logic.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，**接口**提供了一种为多个类定义函数的方法，而无需任何特定实现。例如，你的玩家角色可能会以不同的方式激活不同的物品。通过定义一个声明**Activate()**方法的接口，实现该接口的每个物品都将定义它自己的个人逻辑。
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Unreal Engine, interfaces differ from traditional programming interfaces,
    as you are not required to provide an implementation for declared functions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，接口与传统编程接口不同，因为你不需要为声明的函数提供实现。
- en: 'In Unreal Engine, interfaces will need the **UINTERFACE()** macro declaration
    and two class declarations (in the same file), with two different prefixes. As
    an example, an **Activatable** interface, with the **Activate()** function, will
    be written more or less like the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，接口需要**UINTERFACE()**宏声明和两个类声明（在同一文件中），具有两个不同的前缀。以下是一个示例，一个具有**Activate()**函数的**Activatable**接口，其代码大致如下：
- en: '[PRE7]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the **UActivatable** class declaration is a **UObject** class
    that contains all the reflection information related to the interface. Being a
    **UObject** class, it possesses all the features you would normally expect, such
    as having a name, the ability to be serialized, and support for reflection.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**UActivatable**类声明是一个包含与接口相关的所有反射信息的**UObject**类。作为一个**UObject**类，它具有你通常期望的所有功能，例如具有名称、序列化能力和反射支持。
- en: Conversely, the **IActivatable** class declaration is the actual native class
    used by the compiler to inject virtual functions into your class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**IActivatable**类声明是编译器实际用于将虚拟函数注入你的类的原生类。
- en: Delegates
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代表
- en: In C++, a **delegate** is a type that lets you reference a function, enabling
    you to call that function indirectly. Delegates are often used for event handling
    and callback mechanisms, allowing different parts of a program to communicate
    in a decoupled way. In Unreal Engine, delegates are specifically designed for
    use with the engine’s event system. They allow you to bind functions to events
    so that when the event occurs, the bound functions are called automatically.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，**代理** 是一种类型，允许你引用一个函数，从而间接调用该函数。代理通常用于事件处理和回调机制，允许程序的不同部分以解耦的方式通信。在虚幻引擎中，代理专门设计用于与引擎的事件系统一起使用。它们允许你将函数绑定到事件，以便当事件发生时，绑定的函数会自动调用。
- en: 'In Unreal Engine, there are several types of delegates:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，存在几种类型的代理：
- en: '**Single-cast** : These delegates only allow one function to be bound to the
    delegate at a time. They are ideal for scenarios where you want to ensure that
    only one event handler responds to an event.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单播**：这些代理一次只允许将一个函数绑定到代理。它们适用于你想要确保只有一个事件处理器响应事件的场景。'
- en: '**Multicast** : These delegates can have multiple functions bound to them,
    allowing multiple event handlers to respond to the same event. They are suitable
    for scenarios where several components or classes need to listen to the same event
    and respond accordingly.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多播**：这些代理可以绑定多个函数，允许多个事件处理器响应同一事件。它们适用于需要多个组件或类监听同一事件并相应响应的场景。'
- en: '**Dynamic** : These delegates are a type of delegate that can be serialized
    and are compatible with Unreal Engine’s reflection system. They allow you to bind
    and unbind functions at runtime and can be easily exposed to Blueprints, making
    them very versatile.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**：这些代理是一种可以序列化并与虚幻引擎的反射系统兼容的代理类型。它们允许你在运行时绑定和解绑函数，并且可以轻松地暴露给蓝图，使它们非常灵活。'
- en: '**Dynamic multicast** : These delegates combine both dynamic and multicast
    delegates.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态多播**：这些代理结合了动态和多播代理的特性。'
- en: If you work in a hybrid Blueprint/C++ project, chances are that you’ll be mostly
    working with dynamic multicast delegates; this will let you expose delegates to
    Blueprints and bind multiple functions to them. Just keep in mind that, although
    highly flexible and powerful, using them might impact performance due to runtime
    binding.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个混合蓝图/C++项目中工作，那么你很可能会主要使用动态多播代理；这将使你能够将代理暴露给蓝图并将多个函数绑定到它们。只需记住，尽管它们非常灵活且强大，但由于运行时绑定，使用它们可能会影响性能。
- en: Declaring a delegate
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明代理
- en: 'Whenever you declare a delegate, you will use a macro starting with the **DECLARE_**
    prefix. For example, to declare a dynamic multicast delegate with a single parameter,
    you will use the following syntax:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每次声明代理时，你将使用以 **DECLARE_** 前缀开始的宏。例如，要声明一个具有单个参数的动态多播代理，你将使用以下语法：
- en: '[PRE8]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the delegate declaration defines the delegate name, the parameter
    type, and the parameter name.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代理声明定义了代理名称、参数类型和参数名称。
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a full list of the available delegate declarations, check out the official
    documentation: [https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine)
    .'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的代理声明的完整列表，请参阅官方文档：[https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine)
    。
- en: Creating a variable of a delegate type
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建代理类型的变量
- en: 'To create a variable out of a delegate type, you will use the following syntax:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要从代理类型创建变量，你将使用以下语法：
- en: '[PRE9]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the use of the **BlueprintAssignable** specifier that will make this property
    accessible to Blueprints.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用了 **BlueprintAssignable** 指示符，这将使此属性对蓝图可访问。
- en: Subscribing to a delegate
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅代理
- en: 'Subscribing to a delegate varies, depending on whether it is multicast or not,
    as well as whether it is dynamic or non-dynamic. In our example, the delegate
    is dynamic and multicast, so we will use the following syntax:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅代理的方式因是否为多播以及是否为动态或非动态而异。在我们的例子中，代理是动态且多播的，因此我们将使用以下语法：
- en: '[PRE10]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The **HandleDamage()** function will be similar to the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**HandleDamage()** 函数将与以下代码类似：'
- en: '[PRE11]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Calling a delegate
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用代理
- en: 'Calling a delegate is quite straightforward, as you will use the **Broadcast()**
    function for multicast delegates and the **Execute()** function otherwise. Calling
    a delegate from our example will look like the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个委托相当简单，您将使用**Broadcast()**函数来调用多播委托，否则使用**Execute()**函数。从我们的示例中调用委托将类似于以下代码：
- en: '[PRE12]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, **30.f** is the damage taken by the listening object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，**30.f**是监听对象所承受的伤害。
- en: In this section, I have presented some of the key features that distinguish
    Unreal Engine C++ from standard C++ programming. In the next section, we are going
    to delve deep into some of the most important inner features of Unreal Engine.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我介绍了一些区分Unreal Engine C++和标准C++编程的关键特性。在下一节中，我们将深入探讨Unreal Engine的一些最重要的内部特性。
- en: Exploring core mechanics
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索核心机制
- en: In this section, we will delve into more sophisticated features, such as memory
    management and reflection, and explain how Unreal Engine copes with them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解更复杂的功能，例如内存管理和反射，并解释Unreal Engine是如何处理它们的。
- en: Garbage collection
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: As you may already know, **garbage collection** ( **GC** ) is a way to automatically
    manage memory. In a GC-managed system, once an object is no longer used, it will
    be automatically removed from memory to free space. This allows you to create
    a new object and use it, and when you’re finished using it, you will simply be
    good to go. This system is managed by the **garbage collector** , which constantly
    monitors which objects are still in use. When an object is no longer needed, the
    garbage collector automatically frees up the associated memory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，**垃圾回收**（**GC**）是一种自动管理内存的方式。在GC管理的系统中，一旦一个对象不再被使用，它将被自动从内存中移除以释放空间。这允许您创建一个新的对象并使用它，当您完成使用后，您只需简单地继续即可。这个系统由**垃圾回收器**管理，它不断监控哪些对象仍在使用中。当一个对象不再需要时，垃圾回收器会自动释放相关的内存。
- en: While GC is used by many modern programming languages – such as C# and Python
    – lower-level languages such as C and C++ do not include a garbage collector by
    default. As a result, programmers must manually track memory usage and free it
    when it’s no longer needed. This process can be error-prone and more challenging
    for developers to manage. To address this issue, Unreal Engine has implemented
    its own GC system.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多现代编程语言（如C#和Python）都使用GC，但像C和C++这样的底层语言默认不包含垃圾回收器。因此，程序员必须手动跟踪内存使用情况，并在不再需要时释放它。这个过程可能会出错，并且对开发者来说更具挑战性。为了解决这个问题，Unreal
    Engine实现了自己的GC系统。
- en: How is GC used by Unreal Engine?
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际上，Unreal Engine是如何使用GC的？
- en: When an object derived from the **UObject** class is instantiated, it will be
    registered with Unreal Engine’s GC system. This system automatically runs at predefined
    time intervals – about 30 to 60 seconds – to identify and remove any objects that
    are no longer in use.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当从**UObject**类派生的对象被实例化时，它将被注册到Unreal Engine的GC系统中。该系统会自动在预定义的时间间隔内运行——大约30到60秒——以识别和移除任何不再使用的对象。
- en: The GC system keeps a set of root objects that are defined to remain alive indefinitely.
    Additionally, it uses reflection – something that C++ lacks but that Unreal Engine
    has natively – to examine the properties of an object. This allows the GC system
    to follow references to other objects and their properties.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: GC系统保留了一组定义为无限期保持活跃的根对象。此外，它使用反射——这是C++所缺乏的，但Unreal Engine具有原生支持的功能——来检查对象的属性。这允许GC系统跟踪其他对象及其属性的引用。
- en: If an object is discovered while traversing other objects, and one of those
    objects is part of the root set, then the object is deemed reachable and remains
    alive. Once all objects are examined, and if there is no way to reach an object
    in the root set via references, that object is considered unreachable and marked
    to be garbage-collected.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历其他对象时如果发现了一个对象，并且其中之一是根集合的一部分，那么该对象被认为是可到达的并且保持活跃状态。一旦检查完所有对象，如果无法通过引用到达根集中的任何对象，那么该对象被认为是不可到达的，并标记为垃圾回收。
- en: When an object is garbage-collected, the memory it occupies is freed and returned
    to the system; any pointers that referenced this object will be set to **null**
    .
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象被垃圾回收时，它占用的内存被释放并返回给系统；任何引用此对象的指针将被设置为**null**。
- en: Note
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that manual memory management – the one you should be used
    to if you come from a pure C++ background – is still an option in Unreal Engine,
    but it cannot be used on any **UObject** derived classes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，如果你来自纯C++背景，手动内存管理——你应该习惯使用的方法——在Unreal Engine中仍然是一个选项，但不能用于任何从**UObject**派生的类。
- en: Using GC in Unreal Engine
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Unreal Engine中使用GC
- en: If you have a pointer within a function, you don’t need to be concerned about
    the GC, as pointers inside functions behave like standard C/C++ pointers and do
    not require any modifications.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你函数内部有一个指针，你不需要担心GC，因为函数内的指针表现得像标准的C/C++指针，并且不需要任何修改。
- en: Conversely, if you want to have a pointer to an object that you need to persist
    across frames, you will need to add some small additional code; the pointer needs
    to be stored as a member variable in your class, and you must add the **UPROPERTY()**
    macro before it. That’s all you need to do to have the reference that follows
    be considered by the GC system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你需要跨帧持久化对象的指针，你将需要添加一些小的附加代码；该指针需要作为你的类中的一个成员变量存储，并且你必须在它之前添加**UPROPERTY()**宏。这就是你需要做的，以便让后续的引用被GC系统考虑。
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **UPROPERTY()** macro can only be used inside classes that derive from **UObject**
    ; otherwise, you will have to handle memory manually.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**UPROPERTY()**宏只能在从**UObject**派生的类中使用；否则，你将不得不手动处理内存。'
- en: The reflection system
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射系统
- en: The term **reflection** refers to the ability of a program to inspect its own
    structure at runtime; this feature is extremely valuable and one of the core technologies
    used by Unreal Engine, supporting various systems such as the **Detail** panel
    in the Editor, serialization, GC, and communication between Blueprint and C++.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 反射这个术语指的是程序在运行时检查其自身结构的能力；这个特性非常宝贵，并且是Unreal Engine的核心技术之一，支持各种系统，如编辑器中的**Detail**面板、序列化、GC以及蓝图和C++之间的通信。
- en: Since there is no native support for reflection in C++, Epic Games has created
    its own system to gather, examine, and modify data related to C++ classes, structs,
    and more within the engine.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++没有对反射的原生支持，Epic Games创建了自己的系统来收集、检查和修改与C++类、结构体等相关数据，这些数据在引擎内部。
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reflection system also empowers all the Editor’s panels, making Unreal Engine’s
    UI highly customizable.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 反射系统还赋予了所有编辑器面板的能力，使得Unreal Engine的UI高度可定制。
- en: In order to let the system use reflection, you will need to annotate any type
    or property that you want to expose to the system. This annotation will use macros
    such as **UCLASS()** , **UFUNCTION()** , or **UPROPERTY()** . Finally, to enable
    these annotations, you will need to add the **#include "AClassName.generated.h"**
    declaration. This declaration is automatically generated when you create a class
    from the Unreal Engine Editor, so you won’t need to worry about it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让系统使用反射，你需要对任何你想暴露给系统的类型或属性进行注释。这个注释将使用宏，如**UCLASS()**、**UFUNCTION()**或**UPROPERTY()**。最后，为了启用这些注释，你需要添加**#include
    "AClassName.generated.h"**声明。这个声明是在你从Unreal Engine编辑器创建类时自动生成的，所以你不需要担心它。
- en: 'As an example, consider the following block of code from the **BaseSecurityCam.h**
    file you created in this book project:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下从你在本书项目中创建的**BaseSecurityCam.h**文件中的代码块：
- en: '[PRE13]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will have noticed the presence of the **#include "BaseSecurityCam.generated.h"**
    declaration and the use of the **UPROPERTY()** macro for the components’ declarations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了**#include "BaseSecurityCam.generated.h"**声明以及**UPROPERTY()**宏在组件声明中的使用。
- en: 'The following list outlines the fundamental markup elements available within
    the reflection system:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了反射系统内可用的基本标记元素：
- en: '**UCLASS()** : Generates reflection data for a class that derives from **UObject**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UCLASS()**：为从**UObject**派生的类生成反射数据'
- en: '**USTRUCT()** : Generates reflection data for a struct'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USTRUCT()**：为结构体生成反射数据'
- en: '**GENERATED_BODY()** : Will be replaced with all the necessary boilerplate
    code for the class type'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GENERATED_BODY()**：将被替换为类类型所需的所有必要样板代码'
- en: '**UPROPERTY()** : Informs the engine that the associated member variable will
    have additional features, such as Blueprint accessibility'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UPROPERTY()**：通知引擎关联的成员变量将具有额外的功能，例如蓝图可访问性'
- en: '**UFUNCTION()** : Allows, among other things, us to call the decorated function
    from an extending Blueprint class or override the function from the Blueprint
    itself'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UFUNCTION()**：允许我们在扩展蓝图类中调用装饰过的函数或从蓝图本身覆盖该函数'
- en: The reflection system is also used by the garbage collector, so you won’t need
    to worry about memory management, as explained in the GC subsection.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 反射系统也被垃圾回收器使用，所以你不需要担心内存管理，正如GC子节中解释的那样。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this appendix, I provided an overview of how C++ is used within Unreal Engine,
    highlighting its unique features and functionalities. We explored the integration
    of C++ with the engine’s architecture, some of the differences between Unreal
    Engine C++ and standard C++, and the benefits of using C++ inside the engine itself.
    We also discussed key concepts such as delegates and memory management, emphasizing
    their most important peculiarities and features. Additionally, we introduced the
    C++ Header Preview tool; such an instrument is a must-have if you don’t have much
    experience with C++ for Unreal Engine and you want to make the transition from
    Blueprints.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我概述了C++在Unreal Engine中的应用，突出了其独特的特性和功能。我们探讨了C++与引擎架构的集成，Unreal Engine
    C++与标准C++之间的一些差异，以及在内置引擎中使用C++的好处。我们还讨论了诸如委托和内存管理等关键概念，强调了它们最重要的特性和特性。此外，我们介绍了C++头文件预览工具；如果你对Unreal
    Engine的C++经验不多，但又想从蓝图过渡到C++，这样的工具是必不可少的。
