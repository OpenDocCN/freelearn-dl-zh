- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Interactable Elements with Smart Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unreal Engine, **Smart Objects** represent an advanced system implemented
    to help developers create interactive and context-aware elements within a game.
    Smart Objects are designed to enhance gameplay by allowing characters – be they
    player characters or AI agents – to interact with the environment in a more meaningful
    way through a reservation system. Learning how to use Smart Objects will let you,
    the developer, create dynamic and interactive environments that enhance gameplay
    and improve AI behavior for a more immersive player experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn the basics of Smart Objects interactivity. We
    will visit a simple example of how to make AI agents interact with a smart object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Smart Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Smart Object Definition data asset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Smart Object logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Smart Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed all
    the chapters from *Part 3* , *Working with Decision Making* , and understood their
    content. In particular, we will be using part of the code implemented up until
    [*Chapter 11*](B31016_11.xhtml#_idTextAnchor218) , *Understanding the Environment*
    *Query System* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in the project
    repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)'
  prefs: []
  type: TYPE_NORMAL
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 11** **-** **End** link.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Smart Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart objects are elements placed within a level that can be interacted with
    by both AI agents and players. These objects do not contain any execution logic
    but hold all the necessary information for interactions; additionally, they can
    be queried at runtime with different methods, such as environment queries.
  prefs: []
  type: TYPE_NORMAL
- en: Smart objects represent a set of activities within a level that can be accessed
    through a reservation system; if a smart object slot has been claimed by an AI
    agent, no other agent will be able to use it until it is released.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the main elements of the Smart Objects framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like all Unreal Engine plugins, smart objects are organized into a series of
    elements, each responsible for a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: The **SmartObject subsystem** is responsible for monitoring all available smart
    objects within the level and is automatically instantiated in the world when the
    Smart Objects plugin is enabled. Smart objects are automatically registered with
    the subsystem for easy access and tracking.
  prefs: []
  type: TYPE_NORMAL
- en: A **Smart Object Definition** is a data asset that holds immutable data shared
    among multiple runtime instances of smart objects. It contains filtering information
    such as user-required tags, activity tags, object activation tags, and a default
    set of behavior definitions used to interact with a smart object. Additionally,
    a Smart Object Definition features one or more **slots** that can be claimed by
    players or AI agents to use that specific smart object. Each slot can be positioned
    relative to its parent, allowing you to define different slots in different positions
    for the same actor.
  prefs: []
  type: TYPE_NORMAL
- en: To designate an actor as a smart object, you will be using **SmartObjectComponent**
    ; this component will reference a Smart Object Definition asset.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Object Definitions can include one or more **activity tags** that describe
    the object. They may also feature a **tag query** , which consists of a list of
    desired tags. This tag query serves as an expression to assess whether the user
    requesting access to the smart object is permitted to interact with it. As an
    example, a Smart Object Definition may require a **charging plug** tag that will
    be usable only by an AI agent that has that exact tag.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a quick introduction to the Smart Objects framework, you’re
    all set to dive into your project and start creating your very own smart object.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the next section, we will be presenting you the basics of using
    Smart Objects inside Unreal Engine; we won’t cover all aspects of the framework
    as it can be used in many different ways – standalone, or with behavior trees,
    state trees, and even with Mass. However, by the end of the chapter, you should
    have a clear understanding of what you can achieve with it.
  prefs: []
  type: TYPE_NORMAL
- en: Time to roll up our sleeves and dive into some code!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Smart Object Definition data asset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dr. Markus leaned back in his chair, a satisfied grin spreading across his
    face as he surveyed the cluttered lab. Tools were scattered everywhere, and the
    faint hum of machinery filled the air. Across the room, Professor Viktoria was
    hunched over one of their AI dummy puppets, her brow furrowed in* *deep concentration.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*As the two of them immersed themselves in their work, the idea of upgrading
    the puppets took shape. The goal was clear: to create puppets capable of not only
    performing tasks but also fixing themselves when something went awry. This innovation
    promised to* *be revolutionary.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*With renewed focus, Dr. Markus’s fingers danced over the keyboard, typing
    lines of code that would breathe life into their vision. Each keystroke brought
    them closer to a breakthrough, and Professor Viktoria’s eyes sparkled with excitement
    as they discussed the potential of* *their project.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, and in the subsequent ones, you will be creating a gym where
    AI agents will use a smart object when needed; we will be using the **BP_GunnerDummyCharacter**
    Blueprint we implemented in [*Chapter 9*](B31016_09.xhtml#_idTextAnchor170) ,
    *Extending Behavior Trees* , by changing its AI logic. The gunner character will
    walk randomly, shoot around, and, when the gun jams, try to find a workbench in
    the level to fix the gun.
  prefs: []
  type: TYPE_NORMAL
- en: To start using the Smart Objects framework, the first thing we need to do is
    enable the plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable the Smart Objects framework, open the **Plugins** window, look for
    **SmartObjects** and **GameplayBehaviorSmartObjects** , and enable both. You will
    get a warning as the second plugin is still marked as experimental; go on and
    restart the Unreal Engine Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Once the plugins are enabled, you will be ready to create your first smart object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the workbench definition asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now be creating the Smart Object Definition that, as previously mentioned,
    won’t contain any code logic; it will just serve to define the data that will
    make your soon-to-be-created actor a smart object. To do so, open the **AI** folder
    and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and select **Artificial Intelligence** | **SmartObject Definition**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset **SOD_Workbench** and double-click to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, locate the **Default Behavior Definitions** array
    attribute and click the **+** button to add an element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Index[0]** element to **Gameplay Behavior Smart Object** **Behavior
    Definition** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Smart Object behavior definition](img/Figure_14.1_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Smart Object behavior definition
  prefs: []
  type: TYPE_NORMAL
- en: As previously stated, a Smart Object Definition contains filtering data that
    will be used by the system. As we won’t be implementing anything complex, we don’t
    need a custom definition, and we will just be using the base one.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s now time to add a slot, so do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Details** panel, locate the **Slots** section and click the **+** button
    to add a new slot. Expand the newly created slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Name** property, insert **WorkingPlace** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Shape** property to **Rectangle** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Size** property to **120.0** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Offset** property to **(50.0,** **0.0, 0.0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Slot definition](img/Figure_14.2_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Slot definition
  prefs: []
  type: TYPE_NORMAL
- en: 'This slot will be the location that can be claimed by the AI agent to fix the
    gun once it jams and should look like the one in *Figure 14* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Slot](img/Figure_14.3_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Slot
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you can add as many slots as you deem appropriate. For example,
    a larger workbench may have more working places or even different ones – for instance,
    one for fixing guns and one for recharging batteries.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have created the Smart Object Definition we will be using
    to create a Smart Object actor. As you can see, there’s no logic involved here
    because it’s handled by the Blueprint we’ll be creating in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing smart object logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to create the Blueprint that will contain the Smart Object
    definition, making it a fully functional Smart Object. To do so, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Blueprints** folder and create a new Blueprint extending from **Actor**
    . Call it **BP_Workbench** . Double-click on the newly created asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Components** panel, add a **StaticMesh** component and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, set the **Rotation** property to **(0.0, 0.0, -90.0)**
    and the **Static Mesh** property to **Workbench_Decorated_Workbench_Decorated**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Components** panel, add a **SmartObject** component and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Details** panel, locate the **Smart Object** category and set the
    **Smart Object Definition** property to **SOD_Workbench** . The viewport should
    now look like the one shown in *Figure 14* *.4* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Viewport](img/Figure_14.4_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Viewport
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **Event Graph** panel and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an **OnSmartObjectEvent** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Event Data** pin to a **Break** **SmartObjectEventData** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **Reason** pin of the **Break SmartObjectEventData** node to a
    **Switch on ESmartObjectChangeReason** node and click the **Expand** button to
    show all the switch cases. The graph so far should look like *Figure 14* *.5*
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Starting graph](img/Figure_14.5_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Starting graph
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing here is quite simple; every time we get an event from the
    smart object, we check what has caused the event. This will serve us to respond
    to any interaction from the AI agent. Let’s continue the code logic by doing the
    following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **Interactor** pin of the **OnSmartObject Event** node to a **Get**
    **AIController** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect **Return Value** of the **Get AIController** node to a **Get** **Blackboard**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Retrieve Blackboard](img/Figure_14.6_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Retrieve Blackboard
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **Return Value** pin of the **Get Blackboard** node to a **Set Value
    as** **Bool** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **On Released** outgoing execution pin of the **Switch on ESmartObjectChangeReason**
    node to the incoming execution pin of the **Set Value as** **Bool** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click and drag from the **Key Name** pin of the **Set Value as Bool** node.
    Release and, from the pop-up menu, select **Promote to variable** to create a
    new variable. In the **Variables** panel, name the newly created variable **NeedsReloadKeyName**
    , so that the node in the graph will show a **Needs Reloading Key Name** label.
    This part of the graph is shown in *Figure 14* *.7* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Set Blackboard key](img/Figure_14.7_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Set Blackboard key
  prefs: []
  type: TYPE_NORMAL
- en: Compile the Blueprint and set the variable **Default Value** property to **WeaponJammed**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this last part of the graph, we set a Blackboard key value of the AI agent
    that is interacting with the smart object. We are doing this at the **On Released**
    event, that is, when the smart object has been claimed, interacted with, and then
    released to be claimable again. This means we will fix the jammed gun once the
    AI agent has finished interacting with the smart object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Blackboard, and consequently, the **WeaponJammed** key, haven’t been implemented
    yet. In the next section, we will be working on the Blackboard itself and its
    related behavior tree in order to implement the AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with smart objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will finalize the smart object system by creating an AI
    agent that will make good use of the previously created workbench Blueprint. As
    stated before, the AI agent will move around and shoot at random; from time to
    time, the gun will jam, and so the gunner will need to get to the workbench to
    fix it. The AI behavior will be handled by a behavior tree, and it will be quite
    straightforward, but it will help us understand how to interact with smart objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a helpful task we will be using in the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the toss coin task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to create a task that will simulate the gun jamming. This task
    will be some sort of weighted coin toss and will return a **bool** value – that
    is, a head or tails result. The weight of the toss will help us in defining how
    much the gun is prone to jamming. You should already be familiar with behavior
    tree tasks but, for a quick refresher, you can check [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148)
    , *Setting Up a* *Behavior Tree* .
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this task, start by creating a new C++ class extending **BTTaskNode**
    and call it **BTTask_TossCoin** . Then, open the **BTTask_TossCoin.h** file and
    add the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing worth mentioning here is the **TrueProbability** property, which
    will let us weight the result – in our case, the probability of jamming the gun.
    Now, open the **BTTask_TossCoin.cpp** file and add the following declaration at
    the top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is going to be really simple as it will just give a meaningful
    name to the node. Add the following code to your class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code logic is going to be placed inside the **ExecuteTask()** function.
    Let’s add this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, once we have retrieved the Blackboard component, we randomize
    a **bool** result and set a key value inside the Blackboard itself.
  prefs: []
  type: TYPE_NORMAL
- en: With this class complete, we can now focus on a couple of environment queries
    that we will need inside the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating environment queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the gunner behavior tree, we will need a couple of environment
    queries: one for generating a random location for the gunner to reach and one
    for finding the workbench smart object. Let’s start with the first one.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the FindShootLocation environment query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This query will be in charge of generating a set of random locations on the
    **Nav Mesh** level; basically, we will create a grid of points and later select
    one of these points as a shooting spot. To do so, open the **AI** folder and create
    an environment query by going to **Artificial Intelligence** | **Environment Query**
    . Name it **EQS_FindShootLocation** . Open it and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the graph, connect the **ROOT** node to a **Points:** **Grid** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the newly created node and set the **GridHalfSize** property to **2500.0**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-check that the **Projection Data** | **Trace Node** is set to **Navigation**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – FindShootLocation query](img/Figure_14.8_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – FindShootLocation query
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are using the nav mesh to look for a location; this will
    ensure that our agent will be capable of reaching the selected point.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the FindWorkbenchLocation environment query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This second query will be a search for smart objects inside a predefined area.
    Let’s start by creating an environment query ( **Artificial Intelligence** | **Environment
    Query** ) and naming it **EQS_FindWorkbench** . Open it and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the graph, connect the **ROOT** node to a **SmartObjects** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an item in the **Behavior Definition Classes** array property by clicking
    the **+** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the item at **Index[0]** to **GameplayBehaviorSmartObjectBehaviorDefinition**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Query Box Extent** to **(5000.0,** **5000.0, 500.0)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – FindWorkbench query](img/Figure_14.9_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – FindWorkbench query
  prefs: []
  type: TYPE_NORMAL
- en: This query will look for any smart object with a behavior definition set to
    **GameplayBehaviorSmartObjectBehaviorDefinition** ; this is the default definition,
    and it is the one we used inside the **SOD_Workbench** asset. It should be noted
    that, for the sake of simplicity, we kept things at a very basic level here. I
    highly encourage you to try implementing a filtering system by using tag filters
    or by extending your own behavior definition for the workbench or any other smart
    object you will be adding to the level.
  prefs: []
  type: TYPE_NORMAL
- en: With environment queries finished, we can start implementing the behavior trees,
    starting from the Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blackboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Blackboard for our AI agent will need to store two locations: one for the
    shooting target and another for the workbench. Additionally, there should be a
    flag to indicate whether the gun is jammed. Let’s begin by creating a Blackboard
    and naming it **BB_Tinkerer** to clearly reflect the capabilities of our AI agent.
    Then, add the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Vector** named **WorkbenchLocation**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Vector** named **ShootLocation**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Bool** named **WeaponJammed**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the Blackboard finalized, we are ready to create the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the behavior tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The behavior tree is going to have two main subbranches that will handle the
    case when the gun is jammed and when it is not. Let’s start by creating a new
    behavior tree and calling it **BT_Tinkerer** . Open it and set the **Blackboard
    Asset** property to **BB_Tinkerer** . Then, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **ROOT** node to a **Selector** node; call it **Root Selector**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two **Sequence** nodes to the **Root Selector** node. Call the left one
    **Shoot Sequence** and the right one **Fix Sequence** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Blackboard Decorator** to the **Shoot Sequence** node and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Notify Observer** property to **On** **Value Change**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Key Query** property to **Is** **Not Set**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Blackboard Key** to **WeaponJammed**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The graph so far should look like the one shown in *Figure 14* *.10* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Sequences](img/Figure_14.10_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Sequences
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now focus on the **Shoot Sequence** section of the graph. Start by doing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Move To** task, name it **Move to Shoot Location** , and set the **Blackboard
    Key** property to **ShootLocation** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **PlayMontage** task to the right of the **Move to Shoot Location** task,
    name it **Play Shoot Montage** , and set the **Anim Montage** property to **AM_1H_Shoot**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Wait** task to the right of the **Play Shoot Montage** task. Set the
    **Wait Time** property to **3.0** and **Random Deviation** to **0.5** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **TossCoin** task to the right of the **Wait** task, name it **Randomize
    Jam** , set the **Blackboard Key** property to **WeaponJammed** , and set the
    **True Probability** property to **0.35** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Shoot Sequence** section of the graph should look like the one depicted
    in *Figure 14* *.11* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Shoot Sequence](img/Figure_14.11_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – Shoot Sequence
  prefs: []
  type: TYPE_NORMAL
- en: 'This portion of the graph will move the AI agent to a selected location, start
    the shooting sequence, wait a short time, and check whether the gun is jammed.
    However, we need to add a service to make it fully functional. Let’s start by
    selecting **Move to Shoot Location** and adding a **Run EQSQuery** node. Select
    the query service and, in the **Details** panel, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name it **Find** **Shoot Location** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Query Template** property to **EQS_FindShootLocation** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Run Mode** to **Single Random Item from** **Best 25%** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Blackboard Key** property to **ShootLocation** . *Figure 14* *.12*
    shows the finalized **Shoot Sequence** section of the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Finalized ShootSequence](img/Figure_14.12_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – Finalized ShootSequence
  prefs: []
  type: TYPE_NORMAL
- en: This service will execute the environment query that will select one random
    item from the generated locations, assigning it to the **ShootLocation** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this portion of the behavior tree complete, we can focus on the **Fix
    Sequence** section of the graph. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Move To** task, name it **Move to Workbench Location** , and set the
    **Blackboard Key** property to **WorkbenchLocation** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **PlayMontage** task to the right of the **Move to Workbench Location**
    task, name it **Play Reload Montage** , and set the **Anim Montage** property
    to **AM_1H_Reload** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Wait** task to the right of the **Play Shoot Montage** task. Set the
    **Wait Time** property to **3.0** and **Random Deviation** to **0.5** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **FindAndUseGameplayBehaviorSmartObject** task to the right of the **Wait**
    task, name it **Use Workbench** , set the **Query Template** property to **EQS_FindWorkbench**
    , and set the **RunMode** property to **Single Best Item** . The **Fix Sequence**
    should look like the one depicted in *Figure 14* *.13* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.13 – Fix Sequence](img/Figure_14.13_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.13 – Fix Sequence
  prefs: []
  type: TYPE_NORMAL
- en: You are already familiar with most of the graph, but the last task needs some
    explanation as it is the most important one. It will find a suitable smart object,
    claim it, and use it. Then it will release the resource. Although you don’t have
    full control of each of the phases of the smart object as they are executed one
    after the other, it is quite handy when implementing simple behaviors such as
    the one we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to add is a service that will find the workbench in
    the level. To implement this, select the **Move to Workbench Location** task and
    add a **Run EQSQuery** node. Select the query service and, in the **Details**
    panel, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name it **Find** **Workbench Location** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Query Template** property to **EQS_FindWorkbench** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Run Mode** attribute to **Single** **Best Item** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Blackboard Key** property to **WorkbenchLocation** . *Figure 14*
    *.14* shows the finalized **FixSequence** section of the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.14 – Finalized FixSequence](img/Figure_14.14_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.14 – Finalized FixSequence
  prefs: []
  type: TYPE_NORMAL
- en: The behavior tree is now complete; we just need to integrate it into an AI agent
    and observe its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the character Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finalize our AI agent, we need to create the AI controller and the character
    Blueprints. Luckily, we have already implemented the necessary classes, and we
    just need to extend them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the AI controller by doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Blueprints** folder, create a new Blueprint class extending from **BaseDummyAIController**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it **AITikererDummyController** and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Behavior Tree** property to **BT_Tinkerer** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s now time to create the character, so do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Blueprints** folder, right-click on **BP_GunnerDummyCharacter** and
    select **Create Child** **Blueprint Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset **BP_TinkererDummyCharacter** and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, set the **AI Controller Class** property to **AITinkererDummyController**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to test things out in a gym.
  prefs: []
  type: TYPE_NORMAL
- en: Testing smart objects in a gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should be familiar with the process of creating and testing a gym,
    so just create a new level of your choice with a **NavMeshBoundsVolume** actor
    in order to make your AI agent move through the pathfinding system. Then, add
    a **BP_Tinkerer** instance and a **BP_Workbench** instance to the level and start
    the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: You should observe the AI agent moving around and shooting. Occasionally, the
    weapon will jam, prompting the agent to search for a workbench to repair it before
    returning to its shooting activities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15 – Finalized fix sequence](img/Figure_14.15_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.15 – Finalized fix sequence
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created an introductory yet fully functional gym that effectively
    uses smart objects. I highly encourage you to experiment with things a bit by
    adjusting the jam probability or adding more workbenches and gunners to observe
    how these changes affect the overall behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we learned about Smart Objects, an advanced framework
    created to assist developers in building interactive and context-aware elements
    in a game. Smart Objects aim to enrich gameplay by enabling player characters
    and AI agents to engage with the environment more meaningfully through a reservation
    system, as we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you will benefit from using Smart Objects by creating more immersive
    and interactive gameplay experiences, as environment objects will enable complex
    behaviors and context-sensitive interactions within the game world. By leveraging
    this technology, your games will become increasingly captivating and engaging
    for your players.
  prefs: []
  type: TYPE_NORMAL
- en: Epilogue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In their secret laboratory, Dr. Markus and Professor Viktoria watched as their
    AI dummy puppets prepared for an epic battle, armed with colorful* *Nerf guns.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Markus laughed as a bold puppet dashed from behind a lab table, launching
    foam darts. “We’ve created the world’s first AI Nerf combat league!” He* *proudly
    exclaimed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Viktoria grinned, delighted by their creations’ enthusiasm. “Who knew they’d
    embrace battle* *so eagerly?”*'
  prefs: []
  type: TYPE_NORMAL
- en: '*With the glow of monitors casting light across the lab, Markus suggested,
    “What’s next? A* *championship tournament?”*'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Absolutely!” Viktoria replied, her* *excitement infectious.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In that hidden haven of innovation, they realized they had built something
    extraordinary – a whimsical world of creativity and friendly competition, bursting
    with* *endless possibilities.*'
  prefs: []
  type: TYPE_NORMAL
- en: So, this is the end of this book; I hope you enjoyed it as much as I enjoyed
    writing it!
  prefs: []
  type: TYPE_NORMAL
- en: This is just the start of your exciting journey into the amazing world of artificial
    intelligence development in Unreal Engine! You might be asking yourself, “ *What’s
    next?* ”. I totally understand that it can feel a bit overwhelming with all the
    plugins, frameworks, and technologies I presented. To help you out, I’ve put together
    a fun new task for you! In the project template, you will find a level called
    **CaptureTheFlag** . Feel free to dive in and create your very own *Capture the
    Flag* game featuring the dummy puppets as main characters. Try to combine everything
    you’ve learned so far to develop your own AI agents.
  prefs: []
  type: TYPE_NORMAL
- en: Dive into this with all the enthusiasm you can muster and don’t be afraid to
    experiment and play around. Remember, the best experiences often come from letting
    loose and having a great time, so go ahead and make it your own.
  prefs: []
  type: TYPE_NORMAL
- en: Have a blast!
  prefs: []
  type: TYPE_NORMAL
- en: Appendix – Understanding C++ in Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix has been written to provide you with additional insights, resources,
    and practical information to enhance your understanding of C++ programming within
    the Unreal Engine framework. This will help you as a refresher or as a reference
    throughout the book, just in case you need some help when following the presented
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This appendix serves as a valuable reference that complements the main content
    of the book, providing you with the tools and information needed to successfully
    navigate the exciting world of C++ in Unreal Engine. Whether you’re a mid-experienced
    developer looking to refine your skills or a proficient C++ programmer with little
    Unreal Engine experience, I hope this appendix will enrich your learning experience!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing basic concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining advanced features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring core mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have some good knowledge
    about programming, particularly some basic understanding of the C++ language.
    Additionally, you will need a good understanding of the Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will provide a gentle introduction to the main topics related to
    using C++ in Unreal Engine. For a more comprehensive exploration of programming
    in C++ with Unreal Engine, I recommend checking out Zhenyu George Li’s book titled
    *Unreal Engine 5 Game Development with C++ Scripting* , published by Packt.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing basic concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you share my passion for game development and programming, you’ll probably
    agree that writing C++ code in Unreal Engine is both enjoyable and surprisingly
    accessible. Epic Games has done an excellent job of incorporating features that
    simplify C++ usage for nearly every programmer.
  prefs: []
  type: TYPE_NORMAL
- en: While it is indeed possible to write standard C++ code in Unreal Engine, leveraging
    the engine’s most widely used features – such as the built-in garbage collector
    and reflection system – will help you achieve better performance in your games.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll be covering the basic principles behind Unreal Engine
    C++ features.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C++ classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unsurprisingly enough, an Unreal Engine C++ class is essentially a standard
    C++ class! If you already have a solid understanding of object-oriented programming
    in C++, you’ll find the environment quite familiar. The process of creating a
    new C++ class starts by determining the type of object you want to represent,
    such as an actor or a component. After defining the type, you declare variables
    and methods in the **header file** (which uses the **.h** extension) and implement
    the logic in the **source file** (which uses the **.** **cpp** extension).
  prefs: []
  type: TYPE_NORMAL
- en: The source file works just like any regular C++ file, but the header file allows
    you to specify additional information for variables and functions that will be
    accessible to Blueprints inheriting from your class. This also simplifies runtime
    memory management, as I will explain later.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by presenting the base types used by the Unreal Engine framework.
  prefs: []
  type: TYPE_NORMAL
- en: The base types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In UE, there are three primary class types that you’ll be deriving from during
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UObject** : This is the base class of Unreal Engine, providing core features
    such as networking support and reflection of properties and methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AActor** : This is a **UObject** type that can be added to a game level,
    either through the Editor or at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UActorComponent** : This is the fundamental class for defining components
    that can be attached to an actor, or another component belonging to the same actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, UE provides the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UStruct** : This is used to create simple data structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UEnum** : This is used to represent enumerations of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreal Engine prefixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unreal Engine class names begin with specific letters; these prefixes are used
    to indicate the class type. The main prefixes used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**U** : This is used for generic objects that derive from **UObject** , such
    as components. A good example is the **UStaticMeshComponent** class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A** : This is used for objects that derive from an actor – that is, the **AActor**
    class – and that can be added to a level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F** : This is used for generic classes and structures, such as the **FColor**
    structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T** : This is used for templates, such as **TArray** or **TMap** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I** : This is used for interfaces, such as **IGameplayTaskOwnerInterface**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E** : This is used for enums, such as **EActorBeginPlayState** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that these prefixes are mandatory; if you attempt to name a class that
    derives from **AActor** without the **A** prefix, you will encounter an error
    at compile time. This rule applies exclusively to C++ classes; Blueprints can
    be named without these prefixes. Unreal Engine will hide the C++ prefix once you
    are in the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may already know, in programming languages, a **property** refers to
    a variable that is declared within a class. Adding properties to a C++ class requires
    some extra attention – specifically, we need to consider whether the code we write
    should be visible or hidden from the Blueprints that will inherit from our class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A property is declared using the standard C++ syntax for variable declaration,
    preceded by the **UPROPERTY()** macro, which specifies various attributes – such
    as visibility in Blueprints – and any relevant metadata. As an example, consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, setting the **Damage** variable as **VisibleAnywhere**
    will make the property visible to a Blueprint, but not modifiable. Additionally,
    it will be logically grouped under the **Damage** category in the **Details**
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: Property specifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you have already noticed, the **UPROPERTY()** can include a list of parameters,
    called **property specifiers** , that will add additional functionality to a property.
    Some of them are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VisibleAnywhere** : The property is displayed but cannot be modified in the
    **Details** panel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EditAnywhere** : The property can be modified in the **Details** panel for
    both Blueprints and instances placed in the level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EditDefaultsOnly** : The property can be modified in the **Details** panel
    of the Blueprint but not in instances placed in the level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EditInstanceOnly** : The property can be modified in the **Details** panel
    of instances placed in the level but not in the Blueprint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BlueprintReadOnly** : The property can be read within the Blueprint but cannot
    be assigned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BlueprintReadWrite** : The property can be both read and assigned within
    the Blueprint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions work just like regular C++ functions. Additionally, just like properties,
    you can decorate them with a macro – in this case, **UFUNCTION()** – that can
    contain proper specifiers. As an example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the function can be called from a child Blueprint, as it has been
    decorated with the **BlueprintCallable** specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a full list of property and function specifiers, visit the official documentation:
    [https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The C++ Header Preview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unreal Engine comes packed with an incredible inspection tool called the **C++
    Header Preview** , which enables you to examine your Blueprint classes as if they
    were written in C++. To activate this tool, simply navigate to the main menu and
    select **Tools** | **C++ Header Preview** , and then choose your desired class.
    For example, *Figure A.1* displays the header file of **BP_Scrambler** from this
    book project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Figure_A.1_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A.1 – The C++ Header Preview tool
  prefs: []
  type: TYPE_NORMAL
- en: This is an amazing tool if already have some Blueprint knowledge and want to
    be gently introduced to C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I have introduced you to some of the most basic features of
    C++ in Unreal Engine; in the next section, I will introduce some more advanced
    features that you may already be familiar with in C++ but that are handled somewhat
    differently in Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explore how Unreal Engine copes with some of
    the common features of C++, such as casting and delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++ – and other programming languages, **casting** is the process of converting
    a variable from one data type to another. It allows you to treat an object as
    a different type, which can be useful in various situations, such as when working
    with inheritance or interfacing with APIs. To cast in Unreal Engine, you use the
    **Cast<T>()** method. As an example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are trying to cast an **Actor** pointer to an **APlayerCharacter**
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, the **Cast<T>()** function is a safe way to cast pointers
    to a specific class type, as your code will return **nullptr** instead of crashing
    when the cast itself fails.
  prefs: []
  type: TYPE_NORMAL
- en: Casting in Unreal Engine should be approached with caution for several reasons.
    First, it can introduce performance overhead; this can slow down your game if
    used frequently. Additionally, excessive casting can complicate code readability
    and understanding. It may obscure the relationships between classes, making it
    harder for developers to grasp the structure of the code base. One effective way
    to reduce class dependencies is by using interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many programming languages, **interfaces** provide a way to define functions
    for multiple classes without requiring any specific implementation. For example,
    your player character might activate different items in different ways. By defining
    an interface that declares an **Activate()** method, each item implementing the
    interface will define its own personal logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, interfaces differ from traditional programming interfaces,
    as you are not required to provide an implementation for declared functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal Engine, interfaces will need the **UINTERFACE()** macro declaration
    and two class declarations (in the same file), with two different prefixes. As
    an example, an **Activatable** interface, with the **Activate()** function, will
    be written more or less like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **UActivatable** class declaration is a **UObject** class
    that contains all the reflection information related to the interface. Being a
    **UObject** class, it possesses all the features you would normally expect, such
    as having a name, the ability to be serialized, and support for reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the **IActivatable** class declaration is the actual native class
    used by the compiler to inject virtual functions into your class.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, a **delegate** is a type that lets you reference a function, enabling
    you to call that function indirectly. Delegates are often used for event handling
    and callback mechanisms, allowing different parts of a program to communicate
    in a decoupled way. In Unreal Engine, delegates are specifically designed for
    use with the engine’s event system. They allow you to bind functions to events
    so that when the event occurs, the bound functions are called automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal Engine, there are several types of delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-cast** : These delegates only allow one function to be bound to the
    delegate at a time. They are ideal for scenarios where you want to ensure that
    only one event handler responds to an event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multicast** : These delegates can have multiple functions bound to them,
    allowing multiple event handlers to respond to the same event. They are suitable
    for scenarios where several components or classes need to listen to the same event
    and respond accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic** : These delegates are a type of delegate that can be serialized
    and are compatible with Unreal Engine’s reflection system. They allow you to bind
    and unbind functions at runtime and can be easily exposed to Blueprints, making
    them very versatile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic multicast** : These delegates combine both dynamic and multicast
    delegates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you work in a hybrid Blueprint/C++ project, chances are that you’ll be mostly
    working with dynamic multicast delegates; this will let you expose delegates to
    Blueprints and bind multiple functions to them. Just keep in mind that, although
    highly flexible and powerful, using them might impact performance due to runtime
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a delegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever you declare a delegate, you will use a macro starting with the **DECLARE_**
    prefix. For example, to declare a dynamic multicast delegate with a single parameter,
    you will use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the delegate declaration defines the delegate name, the parameter
    type, and the parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For a full list of the available delegate declarations, check out the official
    documentation: [https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/delegates-and-lamba-functions-in-unreal-engine)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a variable of a delegate type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a variable out of a delegate type, you will use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the **BlueprintAssignable** specifier that will make this property
    accessible to Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to a delegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Subscribing to a delegate varies, depending on whether it is multicast or not,
    as well as whether it is dynamic or non-dynamic. In our example, the delegate
    is dynamic and multicast, so we will use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The **HandleDamage()** function will be similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Calling a delegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calling a delegate is quite straightforward, as you will use the **Broadcast()**
    function for multicast delegates and the **Execute()** function otherwise. Calling
    a delegate from our example will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, **30.f** is the damage taken by the listening object.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I have presented some of the key features that distinguish
    Unreal Engine C++ from standard C++ programming. In the next section, we are going
    to delve deep into some of the most important inner features of Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring core mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will delve into more sophisticated features, such as memory
    management and reflection, and explain how Unreal Engine copes with them.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may already know, **garbage collection** ( **GC** ) is a way to automatically
    manage memory. In a GC-managed system, once an object is no longer used, it will
    be automatically removed from memory to free space. This allows you to create
    a new object and use it, and when you’re finished using it, you will simply be
    good to go. This system is managed by the **garbage collector** , which constantly
    monitors which objects are still in use. When an object is no longer needed, the
    garbage collector automatically frees up the associated memory.
  prefs: []
  type: TYPE_NORMAL
- en: While GC is used by many modern programming languages – such as C# and Python
    – lower-level languages such as C and C++ do not include a garbage collector by
    default. As a result, programmers must manually track memory usage and free it
    when it’s no longer needed. This process can be error-prone and more challenging
    for developers to manage. To address this issue, Unreal Engine has implemented
    its own GC system.
  prefs: []
  type: TYPE_NORMAL
- en: How is GC used by Unreal Engine?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an object derived from the **UObject** class is instantiated, it will be
    registered with Unreal Engine’s GC system. This system automatically runs at predefined
    time intervals – about 30 to 60 seconds – to identify and remove any objects that
    are no longer in use.
  prefs: []
  type: TYPE_NORMAL
- en: The GC system keeps a set of root objects that are defined to remain alive indefinitely.
    Additionally, it uses reflection – something that C++ lacks but that Unreal Engine
    has natively – to examine the properties of an object. This allows the GC system
    to follow references to other objects and their properties.
  prefs: []
  type: TYPE_NORMAL
- en: If an object is discovered while traversing other objects, and one of those
    objects is part of the root set, then the object is deemed reachable and remains
    alive. Once all objects are examined, and if there is no way to reach an object
    in the root set via references, that object is considered unreachable and marked
    to be garbage-collected.
  prefs: []
  type: TYPE_NORMAL
- en: When an object is garbage-collected, the memory it occupies is freed and returned
    to the system; any pointers that referenced this object will be set to **null**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that manual memory management – the one you should be used
    to if you come from a pure C++ background – is still an option in Unreal Engine,
    but it cannot be used on any **UObject** derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using GC in Unreal Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a pointer within a function, you don’t need to be concerned about
    the GC, as pointers inside functions behave like standard C/C++ pointers and do
    not require any modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if you want to have a pointer to an object that you need to persist
    across frames, you will need to add some small additional code; the pointer needs
    to be stored as a member variable in your class, and you must add the **UPROPERTY()**
    macro before it. That’s all you need to do to have the reference that follows
    be considered by the GC system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **UPROPERTY()** macro can only be used inside classes that derive from **UObject**
    ; otherwise, you will have to handle memory manually.
  prefs: []
  type: TYPE_NORMAL
- en: The reflection system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **reflection** refers to the ability of a program to inspect its own
    structure at runtime; this feature is extremely valuable and one of the core technologies
    used by Unreal Engine, supporting various systems such as the **Detail** panel
    in the Editor, serialization, GC, and communication between Blueprint and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no native support for reflection in C++, Epic Games has created
    its own system to gather, examine, and modify data related to C++ classes, structs,
    and more within the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reflection system also empowers all the Editor’s panels, making Unreal Engine’s
    UI highly customizable.
  prefs: []
  type: TYPE_NORMAL
- en: In order to let the system use reflection, you will need to annotate any type
    or property that you want to expose to the system. This annotation will use macros
    such as **UCLASS()** , **UFUNCTION()** , or **UPROPERTY()** . Finally, to enable
    these annotations, you will need to add the **#include "AClassName.generated.h"**
    declaration. This declaration is automatically generated when you create a class
    from the Unreal Engine Editor, so you won’t need to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following block of code from the **BaseSecurityCam.h**
    file you created in this book project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You will have noticed the presence of the **#include "BaseSecurityCam.generated.h"**
    declaration and the use of the **UPROPERTY()** macro for the components’ declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list outlines the fundamental markup elements available within
    the reflection system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UCLASS()** : Generates reflection data for a class that derives from **UObject**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USTRUCT()** : Generates reflection data for a struct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GENERATED_BODY()** : Will be replaced with all the necessary boilerplate
    code for the class type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UPROPERTY()** : Informs the engine that the associated member variable will
    have additional features, such as Blueprint accessibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UFUNCTION()** : Allows, among other things, us to call the decorated function
    from an extending Blueprint class or override the function from the Blueprint
    itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reflection system is also used by the garbage collector, so you won’t need
    to worry about memory management, as explained in the GC subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, I provided an overview of how C++ is used within Unreal Engine,
    highlighting its unique features and functionalities. We explored the integration
    of C++ with the engine’s architecture, some of the differences between Unreal
    Engine C++ and standard C++, and the benefits of using C++ inside the engine itself.
    We also discussed key concepts such as delegates and memory management, emphasizing
    their most important peculiarities and features. Additionally, we introduced the
    C++ Header Preview tool; such an instrument is a must-have if you don’t have much
    experience with C++ for Unreal Engine and you want to make the transition from
    Blueprints.
  prefs: []
  type: TYPE_NORMAL
