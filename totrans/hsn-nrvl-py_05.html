<html><head></head><body>
        

                            
                    <h1 class="header-title">Using NEAT for XOR Solver Optimization</h1>
                
            
            
                
<p class="p1">In this chapter, you will learn about one of the classic computer science experiments that demonstrates that the NEAT algorithm works and can create a proper network topology. In this chapter, you will get first-hand experience of writing an objective function to guide the XOR problem solver. You will also learn how to select the correct hyperparameters of the NEAT algorithm to assist with solving the XOR problem. This chapter aims to introduce you to the basic techniques of how to apply the NEAT algorithm to solve classic computer science problems.</p>
<p class="mce-root">After completing the experiment and exercises described in this chapter, you will have a solid understanding of the XOR experiment's particulars and get the practical skills you need to write the relevant Python source code using the NEAT-Python library. You will also gain experience in setting up the hyperparameters of the NEAT-Python library and using visualization utilities to visualize the results of an experiment. After that, you will be ready to begin experimenting with the more complex problems that will be discussed later in this book.</p>
<p class="p1">In this chapter, we will cover the following topics:</p>
<ul class="ul1">
<li class="li1">The XOR problem basics</li>
<li class="li1">How to define the objective function to guide the XOR problem solver</li>
<li class="li1">Hyperparameter selection for the XOR experiment</li>
<li class="li1">Running the XOR experiment</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The following technical requirements should be met to carry out the experiments described in this chapter:</p>
<ul>
<li>Windows 8/10, macOS 10.13 or newer, or modern Linux</li>
<li>Anaconda Distribution version 2019.03 or newer</li>
</ul>
<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter3">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter3</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">XOR problem basics</h1>
                
            
            
                
<p class="p1">The classic <strong>multilayer perceptron</strong> (<strong>MLP</strong>) or <strong>artificial neural network</strong> (<strong>ANN</strong>) without any <em>hidden units</em> in their topology is only capable of solving linearly separable problems correctly. As a result, such ANN configurations cannot be used for pattern recognition or control and <kbd>optxor_experiment.pyimization</kbd> tasks. However, with more complex MLP architectures that include some hidden units with a kind of non-linear activation function (such as sigmoid), it is possible to approximate any function to the given accuracy. Thus, a non-linearly separable problem can be used to study whether a neuroevolution process can grow any number of hidden units in the ANN of the solver phenotype.</p>
<p class="p1">The XOR problem solver is a classic computer science experiment in the field of reinforcement learning that cannot be solved without introducing non-linear execution to the solver algorithm. The solution search space of the problem has a minimum size and can be used to demonstrate that the NEAT algorithm can evolve the topology of the ANN, starting from a very straightforward one and gradually increasing the complexity to finding an appropriate network structure where all the connections are wired correctly. By demonstrating the NEAT algorithm's ability to grow an appropriate topology consistently, the XOR experiment also demonstrates that NEAT can avoid the local maxima of the fitness values landscape. The local maxima is a trap where the solver can get stuck, producing a local champion with the wrong connectivity pattern. After that, a local champion may dominate the population so much that the solver fails to solve a problem.</p>
<p>Here is a table defining the XOR features:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Input 1</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Input 2</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Output</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">1</td>
<td class="CDPAlignCenter CDPAlign">1</td>
<td class="CDPAlignCenter CDPAlign">0</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">1</td>
<td class="CDPAlignCenter CDPAlign">0</td>
<td class="CDPAlignCenter CDPAlign">1</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">0</td>
<td class="CDPAlignCenter CDPAlign">1</td>
<td class="CDPAlignCenter CDPAlign">1</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">0</td>
<td class="CDPAlignCenter CDPAlign">0</td>
<td class="CDPAlignCenter CDPAlign">0</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="p1">XOR is a binary logical operator that only returns true if only one of the two inputs is true. The two input signals must be combined by the non-linear hidden unit to produce the correct output signal. There is no linear function for the combination of XOR inputs that are able to separate them into their correct classes correctly.</p>
<p class="p1">The NEAT algorithm starts with the initial population, which encodes a very simple phenotype, and gradually evolves the topology of the phenotype until an appropriate ANN is created. The initial structure of the phenotype ANN does not include any hidden units and consists of two input units, one output unit, and one bias unit. The two input nodes and the bias node are connected to the output node, that is, the initial genotype has three connection genes and four node genes. The bias unit is a particular type of input that is always initialized to a specific value greater than 0 (usually, it is 1.0 or 0.5). The bias unit is necessary if we wish to set the activation of the neuron unit (output or hidden)—which is calculated by the related activation function that's applied to a sum of inputs and bias—to a specific non zero value if both inputs have a value of 0.</p>
<p>The initial and the smallest possible XOR phenotypes are shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-751 image-border" src="img/86915bea-fd14-4a1b-968f-0196f113782b.png" style="width:27.25em;height:12.67em;"/></p>
<p>Initial and optimal XOR phenotypes</p>
<p>The ANN of the phenotype becomes more and more complex until the final solution is found by including one or more additional hidden nodes. The smallest possible solver includes only one hidden node, and the NEAT method demonstrates its power by finding an optimal solver configuration among the more complex ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The objective function for the XOR experiment</h1>
                
            
            
                
<p class="p1">In the XOR experiment, the fitness of the organism in the population is defined as the squared distance between the correct answer and the sum of the outputs that are generated for all four XOR input patterns. It is computed as follows:</p>
<ol class="ol1">
<li class="li1">The phenotype ANN is activated against all four XOR input patterns.</li>
<li class="li1">The output values are subtracted from the correct answers for each pattern, and the absolute values of the results are then summed.</li>
<li class="li1"> The error value that was found at the previous step is subtracted from the maximal fitness value (<em>4</em>) to calculate organism fitness. The highest fitness value means better solver performance.</li>
<li class="li1">The calculated fitness is then squared to give proportionally more fitness to the organisms, thereby producing solver ANNs that give closer answers to the correct solution. This approach makes the evolutionary pressure more intense.</li>
</ol>
<p class="p1">Thus, the objective function can be defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/5e576dee-454e-4fd3-8690-df4ec58c4f68.png" style="width:20.08em;height:4.08em;"/></p>
<p class="p1">The corresponding Python source code that is based on the NEAT-Python library is as follows:</p>
<pre># XOR inputs and expected output values<br/>xor_inputs = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]<br/>xor_outputs = [ (0.0,), (1.0,), (1.0,), (0.0,)]<br/><br/>def eval_fitness(net):<br/>    error_sum = 0.0<br/>    for xi, xo in zip(xor_inputs, xor_outputs):<br/>        output = net.activate(xi)<br/>        error_sum += abs(output[0] - xo[0])<br/>    # Calculate amplified fitness<br/>    fitness = (4 - error_sum) ** 2<br/>    return fitness</pre>
<p class="p1">Note that there is no need to normalize the fitness value to fit the <kbd>[0,1]</kbd> range (like there is with backpropagation-based methods) because there are no backward gradient calculations involved in the training process. The organisms' fitness scores are compared directly based on their absolute values. Thus, the range of the values doesn't matter.</p>
<p class="p1">You can also try different variations of fitness score calculation methods. For example, you can implement a function resembling mean squared error and compare the performance of the algorithm against the different implementations of the objective function. The only requirement is that the objective function should produce higher fitness scores for better solvers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hyperparameter selection</h1>
                
            
            
                
<p class="p1">The XOR experiment we will discuss in this chapter uses the NEAT-Python library as a framework. The NEAT-Python library defines a set of hyperparameters that are used to control the execution and performance of the NEAT algorithm. The configuration file is stored in a format similar to Windows .INI files; each section starts with a name in square brackets ([<em>section</em>]), followed by key-value pairs that are delimited by an equals sign (<em>=</em>).</p>
<p class="p1">In this section, we will discuss some hyperparameters of the NEAT-Python library that can be found in each section of the configuration file.</p>
<p>A full list of the hyperparameters in the NEAT-Python library can be found at <a href="https://neat-python.readthedocs.io/en/latest/config_file.html">https://neat-python.readthedocs.io/en/latest/config_file.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NEAT section</h1>
                
            
            
                
<p class="p1">This section specifies parameters that are specific to the NEAT algorithm. This section includes the following parameters:</p>
<ul class="ul1">
<li class="li2"><kbd>fitness_criterion</kbd>: The function that computes the termination criterion from a set of fitness values of all the genomes in the population. The parameter values are the names of standard aggregate functions, such as min, max, and mean. The min and max values are used to terminate the evolution process if the minimal or maximal fitness of the population exceeds the given <kbd>fitness_threshold</kbd>. When the value is set to mean, the average fitness of the population is used as a termination criterion.</li>
<li class="li2"><kbd>fitness_threshold</kbd>: The threshold value is compared against the fitness and calculated by the <kbd>fitness_criterion</kbd> function to test whether evolution must be terminated.</li>
<li class="li2"><kbd>no_fitness_termination</kbd>: The flag that disables fitness-based termination of the evolutionary process is defined by the preceding parameters. When it's set to <kbd>True</kbd>, the evolution will be terminated only after the maximum number of generations has been evaluated.</li>
<li class="li2"><kbd>pop_size</kbd>: The number of individual organisms in each generation.</li>
<li class="li2"><kbd>reset_on_extinction</kbd>: A flag that controls whether a new random population should be created when all the species in the current generation become extinct due to stagnation. If <kbd>False</kbd>, <kbd>CompleteExtinctionException</kbd> will be thrown upon complete extinction.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">DefaultStagnation section</h1>
                
            
            
                
<p class="p1">This section defines parameters that are specific to the species stagnation routines, as implemented by the <kbd>DefaultStagnation</kbd> class. This section includes the following parameters:</p>
<ul class="ul1">
<li class="li2"><kbd>species_fitness_func</kbd>: The name of a function that's used to compute species fitness, that is, to calculate the aggregate fitness value of all the organisms belonging to a particular species. The allowed values are max, min, and mean.</li>
<li class="li2"><kbd>max_stagnation</kbd>: The species that have not shown an improvement in the fitness value calculated by <kbd>species_fitness_func</kbd> in more than <kbd>max_stagnation</kbd> number of generations are considered stagnant and are subject to extinction.</li>
<li class="li2"><kbd>species_elitism</kbd>: The number of species to unconditionally protect from stagnation. It is intended to prevent the total extinction of the population before new species arise. The specified number of species with the highest fitness always survive in the population, despite showing no further fitness improvements.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">DefaultReproduction section</h1>
                
            
            
                
<p class="p2">This section provides configuration for the reproduction routines that are implemented by the built-in <kbd>DefaultReproduction</kbd> class. This section includes the following parameters:</p>
<ul class="ul1">
<li class="li3"><kbd>elitism</kbd>: The number of most-fit organisms in each species, which are copied without changes to the next generation. This factor allows us to retain any beneficial mutations that were found in the previous generations.</li>
<li class="li3"><kbd>survival_threshold</kbd>: The fraction of organisms in each species that are allowed to be parents of the next generation, that is, eligible for sexual reproduction (<em>crossover</em>). By adjusting this value, it is possible to define the lowest fitness score of the organism that is allowing it to participate in the reproduction process. This becomes possible because the <kbd>survival_threshold</kbd> fraction is taken from the sorted list of organisms, ordered by fitness in decreasing order.</li>
<li class="li3"><kbd>min_species_size</kbd>: The minimum number of organisms per species to keep after the reproduction cycle.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">DefaultSpeciesSet section</h1>
                
            
            
                
<p class="p1">This section provides the configuration for the speciation process that's implemented by the built-in <kbd>DefaultSpeciesSet</kbd> class and includes the following parameter:</p>
<ul class="ul1">
<li class="li1"><kbd>compatibility_threshold</kbd>: The threshold to control whether organisms belong to the same species (genomic distance is less than this value) or to a different species. Higher values mean the evolutionary process has less speciation power.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">DefaultGenome section</h1>
                
            
            
                
<p class="p2">This section defines the configuration parameters that are used to create and maintain the genome, as implemented by the <kbd>DefaultGenome</kbd> class. This section includes the following parameters:</p>
<ul class="ul1">
<li class="li3"><kbd>activation_default</kbd>: The name of the activation function to use in node genes.</li>
<li class="li3"><kbd>activation_mutate_rate</kbd>: If the genome supports multiple activation functions (such as for the CPPN genome), then this is the probability of the mutation replacing the activation function of the current node with a new one that's been taken from the list of supported functions (see <kbd>activation_options</kbd>).</li>
<li class="li3"><kbd>activation_options</kbd>: A space-separated list of the activation functions that can be used by node genes.</li>
<li class="li3"><kbd>aggregation_default</kbd>: The name of the default aggregate function to be used by a network node to any aggregate input signals that are received from other nodes before activation.</li>
<li class="li3"><kbd>aggregation_mutate_rate</kbd>: If multiple aggregate functions are supported by the genome, then this parameter defines the probability of mutation that replaces the aggregate function of the current node with a new one from the list of aggregate functions (see <kbd>aggregation_options</kbd>).</li>
<li class="li3"><kbd>aggregation_options</kbd>: A space-separated list of the aggregate functions that can be used by node genes. The supported values are sum, min, max, mean, median, and maxabs.</li>
<li class="li3"><kbd>compatibility_threshold</kbd>: The threshold to control whether organisms belong to the same species (genomic distance is less than this value) or to different species. Higher values mean that the evolutionary process has less speciation power.</li>
<li class="li3"><kbd>compatibility_disjoint_coefficient</kbd>: The coefficient that's used during the genomic distance calculation to count how disjoint or excess genes contribute to the calculation result. Higher values of this parameter amplify the significance of the presence of disjoint or excess genes in the genomic distance calculation.</li>
<li class="li3"><kbd>compatibility_weight_coefficient</kbd>: The coefficient that manages how the genomic distance calculation of the difference between the bias and response attributes of the node genes and the weight attributes of the connection genes contribute to the results.</li>
<li class="li3"><kbd>conn_add_prob</kbd>: The probability of a mutation that introduces a new connection gene between existing node genes.</li>
<li class="li3"><kbd>conn_delete_prob</kbd>: The probability of a mutation that removes an existing connection gene from the genome.</li>
<li class="li3"><kbd>enabled_default</kbd>: The default value for the enabled attribute of the newly created connection genes.</li>
<li class="li3"><kbd>enabled_mutate_rate</kbd>: The probability of a mutation that toggles the enabled attribute of the connection gene.</li>
<li class="li3"><kbd>feed_forward</kbd>: Controls the type of phenotype networks to be generated during genesis. If set to <kbd>True</kbd>, then no recurrent connections are allowed.</li>
<li class="li3"><kbd>initial_connection</kbd>: Specifies the initial connectivity pattern for the newly created genomes. The allowed values include <kbd>unconnected</kbd>, <kbd>fs_neat_nohidden</kbd>, <kbd>fs_neat_hidden</kbd>, <kbd>full_direct</kbd>, <kbd>full_nodirect</kbd>, <kbd>partial_direct</kbd>, and <kbd>partial_nodirect</kbd>.</li>
<li class="li3"><kbd>node_add_prob</kbd>: The probability of a mutation that adds a new node gene.</li>
<li class="li3"><kbd>node_delete_prob</kbd>: The probability of a mutation that removes the existing node gene from the genome and all the connections to it.</li>
<li class="li3"><kbd>num_hidden</kbd>, <kbd>num_inputs</kbd>, <kbd>num_outputs</kbd>: The number of hidden, input, and output nodes in the genomes of the initial population.</li>
<li class="li3"><kbd>single_structural_mutation</kbd>: If set to <kbd>True</kbd>, then only the structural mutations are allowed in the evolution process, that is, only the addition or removal of nodes or connections.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">XOR experiment hyperparameters</h1>
                
            
            
                
<p class="p2">The XOR experiment starts with a very straightforward initial genome configuration that has only two input nodes, one output node, and one special input—the bias node. No hidden node is introduced in the initial genome:</p>
<pre>[DefaultGenome]<br/># The network parameters<br/>num_hidden = 0<br/>num_inputs = 2<br/>num_outputs = 1<br/><br/># node bias options<br/>bias_init_mean = 0.0<br/>bias_init_stdev = 1.0</pre>
<p>The activation function of all the network nodes is a sigmoid and the node inputs are aggregated by the <kbd>sum</kbd> function:</p>
<pre class="mce-root">[DefaultGenome]<br/># node activation options<br/>activation_default = sigmoid<br/><br/># node aggregation options<br/>aggregation_default = sum</pre>
<p class="mce-root">The type of the encoded network is feed-forward fully connected:</p>
<pre class="mce-root">[DefaultGenome]<br/>feed_forward = True<br/>initial_connection = full_direct</pre>
<p class="mce-root">During evolution, the new network nodes and connections are added and/or removed with a particular probability:</p>
<pre class="mce-root">[DefaultGenome]<br/># node add/remove rates<br/>node_add_prob = 0.2<br/>node_delete_prob = 0.2<br/><br/># connection add/remove rates<br/>conn_add_prob = 0.5<br/>conn_delete_prob = 0.5</pre>
<p class="mce-root">All the connections are enabled by default, with a very low probability of becoming disabled due to mutation:</p>
<pre class="mce-root">[DefaultGenome]<br/># connection enable options<br/>enabled_default = True<br/>enabled_mutate_rate = 0.01</pre>
<p class="mce-root">The genomic distance is highly influenced by the excess/disjoint parts of the parent genomes to spur the species' diversity:</p>
<pre class="mce-root">[DefaultGenome]<br/># genome compatibility options<br/>compatibility_disjoint_coefficient = 1.0<br/>compatibility_weight_coefficient = 0.5</pre>
<p class="mce-root">Species stagnation is prolonged to <kbd>20</kbd> generations, and unique species are partially prevented from extinction:</p>
<pre class="mce-root">[DefaultStagnation]<br/>species_fitness_func = max<br/>max_stagnation = 20<br/>species_elitism = 2</pre>
<p class="mce-root">The survival threshold of organisms within a species is set to a low value to narrow the evolutionary process, allowing only the fittest organisms to reproduce (the top 20% of the list of organisms, ordered by fitness). At the same time, elitism is also introduced to unconditionally copy the two fittest individuals to the next generation in each species. The minimal species size also influences speciation, and we leave it as the default value: </p>
<pre class="mce-root">[DefaultReproduction]<br/>elitism = 2<br/>survival_threshold = 0.2<br/>min_species_size = 2</pre>
<p class="p1">The species compatibility threshold controls the diversity of species in the population. Higher values of this parameter result in a more diverse population. Species diversity should be balanced to keep the evolutionary process going in the desired direction, avoiding the exploration of too many search vectors, but at the same time permitting the exploration of innovation:</p>
<pre class="p3">[DefaultSpeciesSet]<br/>compatibility_threshold = 3.0</pre>
<p class="p3">The population size is set to <kbd>150</kbd>, which is pretty moderate, but sufficient for such a simple problem as XOR. The termination criterion (<kbd>fitness_threshold</kbd>) is set to <kbd>15.5</kbd> to guarantee that evolution terminates when the solution found is maximally close to the goal (the maximal fitness score is <kbd>16.0</kbd> according to our <kbd>fitness</kbd> function).</p>
<p class="p3">In this task, we are interested in finding the evolution champion that's able to solve the XOR problem, so our termination function (<kbd>fitness_criterion</kbd>) is the <kbd>max</kbd> function, which selects the maximal fitness among all the organisms in a population:</p>
<pre class="mce-root">[NEAT]<br/>fitness_criterion = max<br/>fitness_threshold = 15.5<br/>pop_size = 150<br/>reset_on_extinction = False</pre>
<p>The complete configuration file, <kbd>xor_config.ini</kbd>, is provided in the <kbd>Chapter3</kbd> directory in the source files repository associated with this chapter.</p>
<p class="mce-root">We have only presented the major hyperparameters that have a high impact on the NEAT algorithm's performance. The values of the hyperparameters were tested to produce a working XOR solver, but feel free to play around and see what happens.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the XOR experiment</h1>
                
            
            
                
<p>Before we start working on the XOR experiment, we need to set up our Python environment correctly according to the requirements of the NEAT-Python library, which we chose as the framework for writing our code. The NEAT-Python library is available from PyPI, so we can use the pip command to install it into the virtual environment of the XOR experiment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Environment setup</h1>
                
            
            
                
<p>Before we start writing the code related to the XOR experiment, the appropriate Python environment should be created, and all the dependencies need to be installed into it. Follow these steps to set up the work environment properly:</p>
<ol>
<li>A Python 3.5 virtual environment for the XOR experiment is created using the <kbd>conda</kbd> command from the Anaconda Distribution, as follows:</li>
</ol>
<pre class="p1" style="padding-left: 60px"><strong>$ conda create --name XOR_neat python=3.5</strong></pre>
<p>Make sure that Anaconda Distribution is installed in your system, as described in <a href="c673e180-4440-4eea-98f8-8800c77162c8.xhtml" target="_blank">Chapter 2</a>, <em>Python Libraries and Environment Setup</em>.</p>
<ol start="2">
<li>To use the newly created virtual environment, you must activate it:</li>
</ol>
<pre class="p1" style="padding-left: 60px"><strong>$ conda activate XOR_neat</strong></pre>
<ol start="3">
<li>After that, the NEAT-Python library can be installed into an active environment using the following command:</li>
</ol>
<pre class="p3" style="padding-left: 60px"><strong>$ pip install neat-python==0.92</strong> </pre>
<p>We use the specific version (<kbd>0.92</kbd>) of the NEAT-Python library here, which was the most recent at the time of writing.</p>
<ol start="4">
<li>Finally, we need to install the optional dependencies that are used by the visualization utilities. This can be done with the <kbd>conda</kbd> command, as follows:</li>
</ol>
<pre class="p3" style="padding-left: 60px"><strong>$ conda install matplotlib</strong><br/><strong>$ conda install graphviz</strong><br/><strong>$ conda install python-graphviz</strong></pre>
<p class="p1">Now, we are ready to start writing the source code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">XOR experiment source code</h1>
                
            
            
                
<p class="p1">To start the experiment, we need to create a directory named <kbd>Chapter3</kbd> using the <kbd>mkdir</kbd> command (for Linux and macOS) or <kbd>md</kbd> (for Windows):</p>
<pre class="p3"><strong>$ mkdir Chapter3</strong></pre>
<p>This directory will save all the source files related to the experiment described in this chapter.</p>
<p>Then, we need to copy the <kbd>xor_config.ini</kbd> file from the source code repository associated with this chapter into the newly created directory. This file contains the complete configuration of the hyperparameters for the XOR experiment, as we discussed earlier.</p>
<p class="mce-root">The experiments that will be discussed in this book use various utilities to visualize the results to help us understand the internals of the neuroevolution process. The XOR experiment also depends on the specific visualization utilities that are implemented in the <kbd>visualize.py</kbd> file in this book's source code repository. You need to copy this file into the <kbd>Chapter3</kbd> directory as well.</p>
<p>The Anaconda Distribution installation includes VS Code, which is a free cross-platform code editor. It is reasonably straightforward in terms of functionality but provides excellent support for Python and makes it easy to switch between virtual environments. You can use it to write the source code for the experiments described in this book.<br/></p>
<p>Finally, create <kbd>xor_experiment.py</kbd> in the <kbd>Chapter3</kbd> directory and use your favorite Python source code editor to write the code:</p>
<ol>
<li>First, we need to define the imports that will be used later:</li>
</ol>
<pre style="padding-left: 60px"># The Python standard library import<br/>import os<br/># The NEAT-Python library imports<br/>import neat<br/># The helper used to visualize experiment results<br/>import visualize</pre>
<ol start="2">
<li>Next, we need to write some fitness evaluation code, as we described earlier:</li>
</ol>
<pre style="padding-left: 60px"># The XOR inputs and expected corresponding outputs for <br/># fitness evaluation<br/>xor_inputs = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]<br/>xor_outputs = [ (0.0,), (1.0,), (1.0,), (0.0,)]<br/><br/>def eval_fitness(net):<br/>    """<br/>    Evaluates fitness of the genome that was used to generate <br/>    provided net<br/>    Arguments:<br/>        net: The feed-forward neural network generated from genome<br/>    Returns:<br/>        The fitness score - the higher score the means <br/>        the better fit organism. Maximal score: 16.0<br/>    """<br/>    error_sum = 0.0<br/>    for xi, xo in zip(xor_inputs, xor_outputs):<br/>        output = net.activate(xi)<br/>        error_sum += abs(xo[0] - output[0])<br/>    # Calculate amplified fitness<br/>    fitness = (4 - error_sum) ** 2<br/>    return fitness</pre>
<p>Never miss the opportunity to write comments in the source code that describe the purpose of the function, its input parameters, and the results of execution. It is also advantageous to comment on some interesting/tricky parts of the source code to provide a better understanding of it to the person who will see it later (this could be you!).</p>
<ol start="3">
<li>With the fitness evaluation function, you can write a function to evaluate all the organisms in the current generation and update the fitness of each genome accordingly:</li>
</ol>
<pre style="padding-left: 60px">def eval_genomes(genomes, config):<br/>    """<br/>    The function to evaluate the fitness of each genome in <br/>    the genomes list. <br/>    The provided configuration is used to create feed-forward <br/>    neural network from each genome and after that created<br/>    the neural network evaluated in its ability to solve<br/>    XOR problem. As a result of this function execution, the<br/>    fitness score of each genome updated to the newly<br/>    evaluated one.<br/>    Arguments:<br/>        genomes: The list of genomes from population in the <br/>                current generation<br/>        config: The configuration settings with algorithm<br/>                hyper-parameters<br/>    """<br/>    for genome_id, genome in genomes:<br/>        genome.fitness = 4.0<br/>        net = neat.nn.FeedForwardNetwork.create(genome, config)<br/>        genome.fitness = eval_fitness(net)</pre>
<ol start="4">
<li>Now that we have implemented the function to evaluate the fitness of the individual genome and the objective function has been defined, it is time to implement the function to run the experiment. The <kbd>run_experiment</kbd> function loads the hyperparameter configuration from the configuration file and creates the initial genome population:</li>
</ol>
<pre style="padding-left: 60px">    # Load configuration.<br/>    config = neat.Config(neat.DefaultGenome, <br/>           neat.DefaultReproduction, neat.DefaultSpeciesSet, <br/>           neat.DefaultStagnation, config_file)<br/><br/>    # Create the population, which is the top-level object <br/>    # for a NEAT run.<br/>    p = neat.Population(config)</pre>
<ol start="5">
<li>We are interested in the accumulation of statistics to evaluate the experiment and observe the process in real time. It is also essential to save checkpoints, which allows you to restore the execution from a given checkpoint in the case of failure. Thus, two types of reporters (standard output and statistics collector) and a checkpoint collector can be registered as follows:</li>
</ol>
<pre style="padding-left: 60px">    # Add a stdout reporter to show progress in the terminal.<br/>    p.add_reporter(neat.StdOutReporter(True))<br/>    stats = neat.StatisticsReporter()<br/>    p.add_reporter(stats)<br/>    p.add_reporter(neat.Checkpointer(5, <br/>                   filename_prefix='out/neat-checkpoint-'))</pre>
<ol start="6">
<li>After that, we are ready to run neuroevolution for <kbd>300</kbd> generations by providing the <kbd>eval_genome</kbd> function, which serves to evaluate the fitness scores of each genome in the population of each generation until a solution is found or the process reaches the maximum number of generations:</li>
</ol>
<pre style="padding-left: 60px">    # Run for up to 300 generations.<br/>    best_genome = p.run(eval_genomes, 300)</pre>
<ol start="7">
<li>When the execution of the NEAT algorithm stops due to success or after reaching the maximum number of generations, the most fit genome is returned. It is possible to check whether this genome is a winner, that is, able to solve the XOR problem with a given accuracy:</li>
</ol>
<pre style="padding-left: 60px">    # Check if the best genome is an adequate XOR solver<br/>    best_genome_fitness = eval_fitness(net)<br/>    if best_genome_fitness &gt; config.fitness_threshold:<br/>        print("\n\nSUCCESS: The XOR problem solver found!!!")<br/>    else:<br/>        print("\n\nFAILURE: Failed to find XOR problem solver!!!")</pre>
<ol start="8">
<li>Finally, the collected statistics and the best-fit genome can be visualized to explore the results of the neuroevolution process and to see how it performed from zero to the maximum number of generations:</li>
</ol>
<pre style="padding-left: 60px">    # Visualize the experiment results<br/>    node_names = {-1:'A', -2: 'B', 0:'A XOR B'}<br/>    visualize.draw_net(config, best_genome, True, <br/>       node_names=node_names, directory=out_dir)<br/>    visualize.plot_stats(stats, ylog=False, view=True, <br/>       filename=os.path.join(out_dir, 'avg_fitness.svg'))<br/>    visualize.plot_species(stats, view=True, <br/>       filename=os.path.join(out_dir, 'speciation.svg'))</pre>
<p>The complete source code of the XOR experiment runner can be found in the <kbd>xor_experiment.py</kbd> file at <a href="https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter3/xor_experiment.py">https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter3/xor_experiment.py</a>.</p>
<p>As a result of the preceding code execution, Matplotlib will be used to render graphs with the collected statistics. Also, a network graph of the best-fit genome will be presented.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the experiment and analyzing the results</h1>
                
            
            
                
<p>The following command should be issued in the <kbd>Chapter3</kbd> directory to start the experiment:</p>
<pre class="mce-root"><strong>$ python xor_experiment.py</strong></pre>
<p>Don't forget to activate the <kbd>XOR_neat</kbd> virtual environment with <kbd>$ conda activate XOR_neat</kbd>. Otherwise, errors about missing a <kbd>neat</kbd> package will be raised.</p>
<p class="mce-root">After the preceding command is entered in your Terminal application of choice, the NEAT algorithm starts execution, and the Terminal window starts to show intermediate results in real time. For each generation, the output is as follows:</p>
<pre><strong> ****** Running generation 43 ****** </strong><br/>                    <br/><strong>Population's average fitness: 6.01675 stdev: 2.53269</strong><br/><strong>Best fitness: 14.54383 - size: (4, 7) - species 2 - id 5368</strong><br/><strong>Average adjusted fitness: 0.238</strong><br/><strong>Mean genetic distance 2.482, standard deviation 0.991</strong><br/><strong>Population of 151 members in 5 species:</strong><br/><strong>   ID age size fitness adj fit stag</strong><br/><strong>  ==== === ==== ======= ======= ====</strong><br/><strong>     1  43   28     9.0   0.241    0</strong><br/><strong>     2  33   42    14.5   0.274    7</strong><br/><strong>     3  20   39     9.0   0.306    0</strong><br/><strong>     4   4   34     9.0   0.221    0</strong><br/><strong>     5   1    8     8.4   0.149    0</strong><br/><strong>Total extinctions: 0</strong><br/><strong>Generation time: 0.045 sec (0.038 average)</strong></pre>
<p>The population's average fitness (<kbd>6.01675</kbd>) in generation <kbd>43</kbd>, which is quite low compared to the completion criterion set in the configuration file (<kbd>fitness_threshold =15.5</kbd>). However, it looks like we have some potential champion species (<kbd>ID: 2</kbd>) that are on their way to reaching the target fitness threshold by evolving the champion organism with a fitness score of <kbd>14.54383</kbd>, which encodes an ANN phenotype that consists of four nodes and seven connections (the size is (<kbd>4,7</kbd>)).</p>
<p>The population includes 151 individuals separated into five species with the following properties:</p>
<ul>
<li><kbd>id</kbd> is a species identifier.</li>
<li><kbd>age</kbd> is the age of the species as the number of generations from their creation until now.</li>
<li><kbd>size</kbd> is the number of individuals belonging to this species.</li>
<li><kbd>fitness</kbd> is the species fitness score calculated from its individuals (max, in our case).</li>
<li><kbd>adj fit</kbd> is the fitness of a particular species that's been adjusted to the entire population's fitness scores.</li>
<li><kbd>stag</kbd> is the stagnation age of a particular species as the number of generations since the species' last fitness improvements.</li>
</ul>
<p class="mce-root">When an appropriate XOR solver is found by the NEAT algorithm, the following output is presented in the Terminal window. It starts with general statistics about the final genome population and the winner (the successful XOR solver):</p>
<pre><strong> ****** Running generation 44 ****** </strong><br/><br/><strong>Population's average fitness: 6.04705 stdev: 2.67702</strong><br/><strong>Best fitness: 15.74620 - size: (3, 7) - species 2 - id 6531</strong><br/><br/><strong>Best individual in generation 44 meets fitness threshold - complexity: (3, 7)</strong></pre>
<p>From the preceding output, we can see that, in generation <kbd>44</kbd>, the evolution process creates a genome that encodes a phenotype ANN that can solve an XOR problem with a given accuracy. This genome belongs to the organism from species with <kbd>ID:2</kbd>, and this species has already championed the evolutionary process over the past seven generations. The champion organism (<kbd>ID:6531</kbd>) of generation <kbd>44</kbd> is a mutation of an individual (<kbd>ID:5368</kbd>) in the species with <kbd>ID:2</kbd> from the previous generation that has lost one hidden node and now has three nodes with seven connections (<kbd>size: (3, 7)</kbd>).</p>
<p>Then follows the best genome section:</p>
<pre><strong>Best genome:</strong><br/><strong>Key: 6531</strong><br/><strong>Fitness: 15.74619841601669</strong><br/><strong>Nodes:</strong><br/><strong>  0 DefaultNodeGene(key=0, bias=-3.175506745721987, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>  224 DefaultNodeGene(key=224, bias=-2.5796785460461154, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>  612 DefaultNodeGene(key=612, bias=-1.626648521448398, response=1.0, activation=sigmoid, aggregation=sum)</strong><br/><strong>Connections:</strong><br/><strong>  DefaultConnectionGene(key=(-2, 224), weight=1.9454770276940339, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-2, 612), weight=2.1447044917213383, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-1, 0), weight=-2.048078253002224, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(-1, 224), weight=3.6675667680178328, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(224, 0), weight=6.1133731818187655, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(612, 0), weight=-2.1334321035742474, enabled=True)</strong><br/><strong>  DefaultConnectionGene(key=(612, 224), weight=1.5435290073038443, enabled=True)</strong></pre>
<p>The best genome section represents the performance statistics of a population champion, along with its genome configuration. Input nodes have the IDs <kbd>-1</kbd> and <kbd>-2</kbd> and are not shown because they are relatively simple, providing us with the means to input values into the network graph. The output node and two hidden nodes have the IDs <kbd>0</kbd>, <kbd>224</kbd>, and <kbd>612</kbd>, respectively. Also, <kbd>DefaultNodeGene</kbd> holds the values for bias, the name of the activation function, and the name of the function that's used to aggregate inputs at each node. The connection genes (<kbd>DefaultConnectionGene</kbd>), which will be presented later, provide the IDs of the source and target nodes, along with the associated connection weight.</p>
<p>Finally, let's look at the <kbd>Output</kbd> section:</p>
<pre><strong>Output:</strong><br/><strong>input (0.0, 0.0), expected output (0.0,), got [1.268084297765355e-07]</strong><br/><strong>input (0.0, 1.0), expected output (1.0,), got [0.9855287279878023]</strong><br/><strong>input (1.0, 0.0), expected output (1.0,), got [0.9867962503269723]</strong><br/><strong>input (1.0, 1.0), expected output (0.0,), got [0.004176868376596405]</strong></pre>
<p>The <kbd>Output</kbd> section represents the output values that are produced by the ANN of the phenotype of the population champion when receiving four input data pairs. As we can see, the output is close to the expected values within the specified accuracy.</p>
<p>The <kbd>Output</kbd> directory also contains a diagram of the ANN graph of the successful XOR solver, which is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-752 image-border" src="img/e46d445a-5e77-42fb-98f4-9c630bc3ebcf.png" style="width:11.50em;height:24.17em;"/></p>
<p>The ANN of the XOR winner phenotype</p>
<p>The ANN of the winner phenotype is close to the optimal configuration we described earlier, but it has one additional hidden node (<kbd>ID:612</kbd>). The bias node is not shown in the graph since the NEAT-Python library does not allocate a bias to a separate node; instead, it assigns a bias value to each network node as an attribute, which can be seen in the output listing (each <kbd>DefaultNodeGene</kbd> has a bias attribute).</p>
<p>A plot with the statistics of fitness change over generations of evolution is also saved to the <kbd>Output</kbd> directory:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-753 image-border" src="img/e1a831ca-8acd-4dd7-a27b-7efeaec0d5ee.png" style="width:34.33em;height:27.00em;"/></p>
<p>Population's average and best fitness scores changing over generations</p>
<p>The preceding plot visualizes the changes in the best and average fitness scores of the population over generations of evolution. The average fitness of the population has increased slightly. However, due to the speciation feature that was introduced in the NEAT algorithm, some species have demonstrated outstanding performance from the earliest generations (<kbd>#10</kbd>), and thanks to the preservation of the beneficial mutation, they finally managed to produce a champion organism that solves the XOR problem with a given accuracy.</p>
<p>The <kbd>Output</kbd> directory also contains the speciation graph, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-754 image-border" src="img/34f1a205-b1d0-4253-bba7-28fd754060de.png" style="width:32.42em;height:25.17em;"/></p>
<p>Speciation of the population over generations of evolution</p>
<p>The speciation graph demonstrates how the speciation process has evolved over the generations of the population of organisms. Each separate species is marked with a different color. The evolution began with a single species (<kbd>ID:1</kbd>), which includes the entire population. Then, the second species (<kbd>ID:2</kbd>) sprouted around the 10th generation and eventually produced a champion organism. Also, in the later stages of evolution, the population branched into three more species in generations <kbd>23</kbd>, <kbd>39</kbd>, and <kbd>42</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<p class="p1">Now that we have the source code of the neuroevolutionary-based XOR solver, try to experiment by changing NEAT's hyperparameters, which control the evolutionary process.</p>
<p class="p1">One of the parameters of particular interest is <kbd>compatibility_threshold</kbd>, which can be found in the <kbd>DefaultSpeciesSet</kbd> section of the configuration file:</p>
<ul class="ol1">
<li class="li3">Try to increase its value and monitor the speciation of the population. Compare the performance of the algorithm with the new value against the default one (<kbd>3.0</kbd>). Does it get any better?</li>
<li class="li3">What happens if you decrease the value of this parameter? Compare its performance against the default value.</li>
</ul>
<p class="p1">Another essential parameter that controls the evolutionary process is <kbd>min_species_size</kbd>, which can be found in the <kbd>DefaultReproduction</kbd> section. By changing the values of this parameter, you can directly control the minimum number of individuals per species and implicitly control the species' diversity:</p>
<ol class="ol1">
<li class="li3">Set the <kbd>compatibility_threshold</kbd> parameter value to the default (<kbd>3.0</kbd>) and try to increase the value of the <kbd>min_species_size</kbd> parameter in the range <kbd>[2, 8]</kbd>. Compare the performance of the algorithm against the default value. See how the species' diversity changes over generations. Go through the algorithm's output and check whether any species have stagnated and have been removed from the evolution due to exceeding the stagnation age.</li>
<li class="li3">Set the <kbd>min_species_size</kbd> parameter value to extremely high for our population (32) and look for the explosion of the species diversity near the end of the evolution process on the speciation graph. Why does this happen? Check the graph depicting the configuration of the ANN phenotype in <kbd>Digraph.gv.svg</kbd>. Is this optimal?</li>
</ol>
<p class="p1">Increasing the minimum size of species makes the evolutionary process more elaborate and allows it to keep more beneficial mutations. As a result, we have an increase in the chances of producing the optimal genome that encodes the ANN of the phenotype of the minimal XOR solver.</p>
<p class="p1">The graph of the ANN of the minimal XOR solver is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-755 image-border" src="img/aaac3788-1eff-40bb-bdb8-ea1b6d4dcb2b.png" style="width:11.17em;height:26.75em;"/></p>
<p>The optimal ANN phenotype with an increased minimum species size</p>
<p>As we already mentioned, the ANN of the minimal XOR solver has only one hidden node, as can be seen in the preceding diagram.</p>
<p>Try to implement some modified code to solve a three XOR (A xor B xor C) problem. Can it be solved with the same hyperparameters that we used in the experiment that we described in this chapter?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="p1">In this chapter, we introduced a classic computer science problem related to the creation of the optimal XOR solver. We discussed the basics of the XOR problem and demonstrated its importance as the first experiment with neuroevolution—it allows you to check whether the NEAT algorithm can evolve a more complex ANN topology, starting with the most straightforward ANN configuration. Then, we defined the objective function for the optimal XOR solver and a detailed description of the NEAT hyperparameters. After that, we used the NEAT-Python library to write the source code of the XOR solver using a defined objective function, and then we experimented.</p>
<p class="mce-root">The results of the experiment we carried out allowed us to conclude the relationship between the number of species in the population, the minimum size of each species, and the performance of the algorithm, as well as the produced ANN topologies.</p>
<p>In the next chapter, we will learn about classic reinforcement learning experiments, which are often used as benchmarks for control strategy implementation. You will learn how to write accurate simulations of real-life physical apparatuses and how to use such simulations to define the objective functions for the NEAT algorithm. You will get first-hand experience of writing the control strategies for various cart-pole balancing controllers using the NEAT-Python library.</p>


            

            
        
    </body></html>