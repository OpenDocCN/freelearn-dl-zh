- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Giving the Robot an Artificial Personality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a person thinks of a robot with AI, what many consider AI is a robot that
    has emotions, feelings, a state of mind, and some sort of model or concept of
    how humans think or feel. We can call this form of AI an **artificial personality**.
    While giving a robot feelings is definitely way beyond the scope of this book
    (or current technology), what we can do is create a simulation of a personality
    for the robot using standard computer modeling techniques, such as Monte Carlo
    analysis, and finite state machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an artificial personality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to the (obsolete) Turing test, chatbots, and **generative**
    **AI** (**GenAI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The art and science of simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An emotion state machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing the emotion game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model of human behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the robot emotion engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will not be introducing any new programming libraries in this chapter. We
    will be building on the voice system we constructed previously. All you will need
    is imagination and some writing skills.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the code for this chapter at [https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e](https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e).
  prefs: []
  type: TYPE_NORMAL
- en: What is an artificial personality?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hollywood and the movie industry have turned out some very memorable robots.
    You can think of R2D2 and C3PO, the Laurel and Hardy of science fiction. What
    do you like most about these two? Could it be their personalities? Think about
    this a bit. Even though R2D2 is mostly a wastebasket shape with a dome head and
    no face, he has a definite personality. You’d describe him as *feisty* or *stubborn*.
    The *Robots and Androids* website ([http://www.robots-and-androids.com/R2D2.html](http://www.robots-and-androids.com/R2D2.html))
    described him in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: The droid is shown as being highly courageous, unwavering in loyalty, and a
    little bit stubborn. He never backs down from a mission, even when the odds appear
    to be stacked against him. His personality is often contrasted against that of
    [C3PO], who is fussy and timid.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty impressive for a robot who never says a word and communicates
    with beeps and whistles.
  prefs: []
  type: TYPE_NORMAL
- en: What were other movie robots that made an impression on you? Certainly, WALL-E,
    the lovable trash-compacting robot from the eponymous movie, is a favorite. WALL-E
    also had a small vocabulary, consisting of only his name, much like a Pokemon.
    WALL-E displayed a lot of emotion and even developed hobbies, collecting and repairing
    old trash. You may also remember M-O, the tiny, obsessive cleaning robot that
    gets frustrated with all of the dirt WALL-E brings in.
  prefs: []
  type: TYPE_NORMAL
- en: So, one thing that we might do as robotics creators and designers is to imbue
    our robot with some sort of personality. This has the advantage of letting humans
    relate to the robot better. It also gives the false impression that the robot
    is much smarter and is capable of more than it really is. This does give the advantage
    of the robot being more engaging and interesting.
  prefs: []
  type: TYPE_NORMAL
- en: We can also infer from the examples given to us by R2D2 and WALL-E that less
    can be more when it comes to communication – we need to not just have words but
    also body language and sound.
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do in this section is develop an artificial personality
    for our robots. While it is impossible for us to give a robot actual emotions
    or feelings, however you might define that, we can create a simulation of personality
    that will provide a convincing illusion. I think this is a meaningful exercise
    because the current state of the art in robotics demands some sort of personality
    and consistent demeanor from robotics that interact with humans.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cartoon seen in *Figure 9**.1* expresses how people and robots might interact.
    The robot has had enough with picking up toys and wishes to show its feelings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A person and a robot interacting](img/B19846_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – A person and a robot interacting
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of work going on in this area right now with digital personal
    assistance, such as Apple’s Siri and Amazon’s Alexa. Note that these robots, or
    AIs, have distinct names and voices, but I feel that they are very similar in
    personality and capability. There is some distinction when you ask Siri or Alexa
    a personal question, such as how old they are (Siri is considerably older than
    Alexa).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take tools from the science of simulation –
    specifically, **state machines** and **Monte Carlo analysis** – and use them to
    form a model of a personality for Albert, the robot. We already have a fairly
    powerful tool, in the Mycroft speech system we used to tell knock-knock jokes.
    We will be extending Mycroft with some new skills and capabilities, as well as
    developing cybernetic emotions, both for our robot and for the robot’s opinion
    of what we, the humans, are feeling.
  prefs: []
  type: TYPE_NORMAL
- en: I want to emphasize that we are simulating emotions, not creating an emotional
    robot. Our simulation bears the same resemblance to real emotions as a flight
    simulator bears to the space shuttle – both provide the same information, but
    the space shuttle flies around the Earth in 90 minutes, and the flight simulator
    never moves.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk about what we are trying to accomplish in this section by first talking
    about the famous Turing test – can we create a robot that interacts in a way that's
    indistinguishable from a human being?
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to the (obsolete) Turing test, chatbots, and generative
    AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alan Turing proposed his famous test, which he called *The Imitation Game*,
    in a paper titled *Computing Machinery and Intelligence*, published in 1950 in
    the journal *Mind – A Quarterly Review of Psychology and Philosophy* (see [https://www.abelard.org/turpap/turpap.php#the_imitation_game](https://www.abelard.org/turpap/turpap.php#the_imitation_game)).
    In the original text, Turing imagined a game where a player would have to guess
    the sex – male or female – of a hidden person by typing questions on a teletype.
    Then, he suggested that a truly intelligent machine would be one where you would
    not be able to distinguish if the hidden personality on the other end of the teletype
    was a human or a computer software program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The movie *The Imitation Game* stars Benedict Cumberbatch as Alan Turing and
    features his role in breaking German code in WWII as part of the mathematicians
    of Bletchley Park. The title refers to Turing’s original name of the famous test
    that bears his name.
  prefs: []
  type: TYPE_NORMAL
- en: 'These days, you may talk to computer software many times a day and not realize
    that you are not speaking to a human. Robocalls and chatbots may call you on the
    telephone or engage you in a fake political conversation on Twitter. The Turing
    test has been won by the machines ([https://www.nature.com/articles/d41586-023-02361-7](https://www.nature.com/articles/d41586-023-02361-7)),
    but have we developed intelligence in computers? Not at all – we have just become
    very clever at simulating conversation. Recently, robotics experts have suggested
    replacing the Turing test with a more demanding and difficult assessment of a
    computer’s cognitive skills and self-understanding: [https://techxplore.com/news/2023-11-redefining-quest-artificial-intelligence-turing.html](https://techxplore.com/news/2023-11-redefining-quest-artificial-intelligence-turing.html).'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use another tool that Alan Turing mentioned in his paper – **state
    machines**. We will use state machines to define and model the emotions of our
    robot in the *An emotion state* *machine* section.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now go back to the concept of a **chatbot**. A working definition may
    be a software program designed to engage a human in conversation or to interact
    with a person via voice or text. While most chatbots are up-front about being
    computer generated, there are a lot of chatbots that are not – including Twitter
    chatbots that seek to influence elections or public opinion. Many chatbots are
    gainfully employed answering tech support phone calls, making marketing calls,
    and entertaining users as the dialog of **non-player characters** (**NPCs**) in
    games.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the article *Ultimate Guide to Leveraging NLP and Machine Learning
    for Your Chatbot* by Stefan Kojouharov, published by [chatbotslife.com](http://chatbotslife.com)
    in 2016, chatbots come in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrieval-based**: These chatbots rely on stored phrases and words, and use
    the software decision-making to select which reply is most appropriate. There
    may be some keyword recognition and noun-subject insertion involved, but the main
    action is to select the most appropriate phrase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generative-based**: These chatbots make up new sentences based on **parts
    of speech** (**POS**) and the robot’s divination of your intent. They can be thought
    of as machine translation engines that translate the input (your text or speech)
    into an output (the robot’s reply). As you might imagine, the generative-type
    chatbot is far more difficult to achieve, which is why we will be using a retrieval-based
    approach. Recent developments from projects such as ChatGPT have redefined what
    is possible for chatbots. The term **Generative Pre-trained Transformer** (**GPT**)
    refers to three characteristics of this **neural** **network** (**NN**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generative**: The model is capable of creating new text phrases, rather than
    just repeating or categorizing text'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-trained**: The model is pre-trained on enormous datasets – over a trillion
    examples – to understand language and the relationship between words'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformer**: The NN architecture uses transformers to process an entire
    sentence at a time, learning both the word meanings and relationships in a sentence
    (positions of words in a sentence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the simplest form, the GenAI NN predicts what word is most likely to come
    next in a sentence, based on training on billions of examples.
  prefs: []
  type: TYPE_NORMAL
- en: We will use GenAI to develop some of our text outputs but apply these to a classical
    chatbot, thus having the best of both worlds – not having to generate text ourselves,
    and having a system where we have control over inputs and outputs and can trust
    the system to control a robot.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other details we need to attend to. Chatbots can be designed to
    handle either short conversations or long conversations. The vast majority of
    chatbots – and that includes digital assistants such as Siri, Alexa, and Mycroft
    – are designed for very short conversations. *Siri, what is the weather?* *There
    is a 20% chance of rain.* *The high is 88 degrees.* That’s it – the whole conversation
    in three sentences and two interactions. If you ask another question, it starts
    a new conversation with little reference to the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: A more difficult task is to have a longer conversation with several interactions
    and even a selection of topics. This requires the computer to keep track of context
    or what information has been discussed and might be referred to again.
  prefs: []
  type: TYPE_NORMAL
- en: We will be attempting to teach our robot to be able to have medium-length conversations
    at a 7-year-old level. I’ll define medium length to be between two and six interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we proceed with our robot, let’s quickly discuss some statistical
    distributions because I’ve found the ability to use Monte Carlo analysis – and
    to create custom random number distributions – very useful in robotics.
  prefs: []
  type: TYPE_NORMAL
- en: The art and science of simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is simulation? A **simulator** is a computer model of the physical world.
    You are probably familiar with flight simulators, which provide sensations and
    interactions of flight without leaving the ground. There are also a lot of other
    types of simulations and simulators. We could have a medical simulator that mimics
    diseases or responds to treatments. It could be a financial simulation that models
    profits on the stock market based on trends. There are structural simulations
    that model loads on bridges and buildings to see whether the materials are adequate.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way of creating a simulation is by building a **physics model**
    of the item under test. For a flight simulator, this means plugging in formulas
    for the four forces on an airplane or a helicopter – lift, gravity, thrust, and
    drag. Each factor has parameters that affect its performance – for instance, the
    lift is a function of the speed through the air, the weight of the aircraft, the
    size of the wing, and the angle of attack, or the angle between the wing and the
    wind. Vary any of those, and the lift changes. If the amount of lift exceeds the
    force due to gravity (that is, the weight of the aircraft), then the aircraft
    flies. The simulation sets up a time-step interval, just like our control loop
    for the robot, and computes the forces on the aircraft for each time step. We
    can then apply controls and see how our model performs. Models just like this
    are used to predict performance in advance of building a prototype or test airplane.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of simulation is called a **Monte Carlo model**. The Monte Carlo
    method uses **probability theory** to replace sophisticated physical models with
    a variation of random numbers that approximates the same result. If you wanted
    to create a computer model of flipping a coin, you wouldn’t spend a lot of time
    determining the physical properties of a nickel or modeling the number of flips
    in the air based on force. You would just pick a random number from 1 to 100 and
    say the result is heads if the number drawn is less than 50 and tails if it is
    greater than 50\. That, in essence, is the Monte Carlo method. There are a lot
    of physical processes that can be approximated and studied using this technique,
    where outcomes can be described in terms of probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply Monte Carlo analysis to model people going through security at
    an airport. If you had a copy of a typical schedule for the airlines and the average
    number of passengers per flight, you would know the daily traffic at the airport.
    The difficult bit would be modeling when people would arrive for their flight.
    Let’s imagine that we commissioned a study and determined roughly that 50% of
    people arrive 1 hour early, 25% arrive 2 hours early, and the rest are evenly
    distributed between 2.5 hours and 30 minutes, with 1 passenger out of every 200
    missing their flight by being late. We can approximate the passenger arrival function
    with two standard distributions (bell curves) and two uniform distributions (boxes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – A complex probability distribution function can be approximated
    by the union of simpler distributions](img/B19846_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – A complex probability distribution function can be approximated
    by the union of simpler distributions
  prefs: []
  type: TYPE_NORMAL
- en: This information allows us to create sample sizes of passenger arrivals and
    thus obtain an estimate of the length of lines at security. We would add some
    distribution of values of how long it took to get through security, and we would
    have our model. We have a list of flights, and for each flight, we generate a
    distribution of passenger arrival times based on the study by assigning random
    numbers to each passenger and separating them out into groups based on arrival
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assign random numbers from 1 to 100 to our 212 passengers arriving for
    the 08:00 flight from Dallas to Washington DC. Now, we assign an arrival time
    based on that number – if the number is from *1* to *25*, the passenger arrives
    2 hours earlier than the flight (06:00). If the number is from *26* to *75* (the
    next 50%) then they arrive 1 hour early (07:00). The rest of the passengers, having
    numbers from *76* to *100*, are assigned random times between 2.5 hours early
    to 30 minutes early. And we pick 1 unlucky passenger out of our 212 to miss the
    flight completely by arriving late. Since there is some variability in people
    who intend to arrive exactly 2 hours ahead, but are delayed or advanced slightly,
    we can **dither** or add a small random distribution factor to each arrival time
    of plus or minus 10 minutes. We now have a statistically correct distribution
    of people arriving for a flight. Now, repeat this process for the other 1,849
    flights leaving today from this airport. You can see from this model that we can
    still put a great deal of science into picking random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we make a **probability distribution function** (**PDF**) that looks
    like this (see *Figure 9**.2* top graph)? The answer is we combine several distributions.
    In the lower graph of *Figure 9**.2*, you see two standard distributions (the
    humps in green) and one uniform distribution (the lower green box) that combined
    make our overall correct function.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed from my example, the true secret of making this technique
    work is picking the correct distribution of random numbers. You may think, “Hey,
    random numbers are random numbers, right?” But this is not correct at all. You
    have heard of a **standard distribution** or the **bell-shaped curve**. Most of
    the values are in the center, with fewer and fewer as you go away from the center.
    Many natural processes follow this bell-shaped curve, including grades on a test,
    how tall people are, or how many grapes grow in a bunch. When you do Monte Carlo
    analysis, most often we use some form of normal or standard distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of other types of random numbers? The second most common type
    of random number is a **uniform distribution**. Each number has the exact same
    probability of being selected, which makes for a flat distribution curve. Another
    name for this uniform distribution is **white noise**. Uniform distributions do
    occur in analysis, and if we want to add noise to an image, for example, we will
    use a uniform distribution. But in modeling emotions and people, normal or standard
    distributions are the rule.
  prefs: []
  type: TYPE_NORMAL
- en: You may find that in using Monte Carlo modeling, a standard distribution or
    uniform distribution just won’t work. Then, you can create a custom distribution,
    as I did in the airport example, where we used re-sampling to change a uniform
    distribution to a custom distribution fitting our passenger arrival model.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.3* shows the various shapes of distributions various kinds of random
    number generators produce, along with their commonly used names – the bell curve
    and the flat line. The lognormal graph looks to me like a ski slope – what do
    you think it looks like?'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Various types of random number generators and the distributions
    they produce](img/B19846_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Various types of random number generators and the distributions
    they produce
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to generate a personality simulation for our robot, and we
    will be using Monte Carlo modeling plus a state machine to create a model of our
    robot’s emotions. Let’s first discuss what an emotion state machine is.
  prefs: []
  type: TYPE_NORMAL
- en: An emotion state machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a state machine? We covered state machines in the systems engineering
    section of [*Chapter 2*](B19846_02.xhtml#_idTextAnchor032) – state machines are
    a technique for understanding or modeling automation or computer programs. A **state**
    is a set of conditions that exist at the present. I like to think of a state as
    being a set of functions that are constrained by limits. The machine (our robot)
    changes from state to state based on some event that causes the state to change.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through a quick refresher example. Let’s take a slice of bread. When
    we get it, it is already baked and sliced, so its initial state is as a slice
    of bread. If we subject the bread to infrared radiation (that is, heat), then
    the surface becomes caramelized, and we call that toast. The state of the bread
    has changed, along with its taste and texture, from baked bread to toast. The
    event that caused that transition was the act of heating the bread in a toaster.
    This is pretty simple stuff, and I’m sure you have encountered state machines
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s think about our model of robot emotions. We can start by listing
    what emotions we want our robot to have:'
  prefs: []
  type: TYPE_NORMAL
- en: Happy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcoming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curious
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Energetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we can list the opposites of those emotions:'
  prefs: []
  type: TYPE_NORMAL
- en: Sad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfriendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frustrated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the list of emotions I wanted to simulate in our robot. I looked
    at the different interactions the robot might have and how a human version of
    the robot would react:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Robot emotional state machine model](img/B19846_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Robot emotional state machine model
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we model the overall emotive state of the robot by
    plotting the various emotional components or states on a polar plot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each emotional element has a vector or direction. On the left side of the plot
    are happy, friendly, open feelings, and on the right side are sad, closed, distant
    feelings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance from the center indicates the strength of the emotions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The yellow circles are the robot’s current value on each axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purple line is the vector sum of those emotions, which gives us the overall
    mood of the robot. The arcs show the minimum and maximum magnitude of emotion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We take the area made up of the four components and find the center of that
    area, and that is the overall state of the robot. In this example, the predominant
    emotion is *friendly*. Since the robot’s physical state determines whether it
    feels *tired* or not, that data is computed separately – this lets the robot feel
    tired but friendly, or refreshed but sad.
  prefs: []
  type: TYPE_NORMAL
- en: The robot starts in a state of *happy*, *distant*, *curious*, and *fresh*. That
    is to say, it feels happy, it is not in an interaction, so there is no one to
    be friendly to, and it will be curious about its surroundings. As the environment
    changes, the robot’s state will change. For example, we have about a 2-hour run
    time on Albert’s current battery. It starts off in a *fresh* state and will get
    more and more tired as it approaches the 2-hour mark. We are going to use a simple
    timer to create this state, but you could use the voltage sensor in the robot
    arm to provide information about how fresh the robot’s power supply is. Each emotion
    exists along an axis and all cross a central or neutral point.
  prefs: []
  type: TYPE_NORMAL
- en: We will drive the *happy-sad* axis based on how many conversation points the
    robot is earning. We’ll cover this in detail in the *Playing the emotion game*
    section. We will also be describing an empathy function for our robot that simulates
    the robot sharing feelings with you. The *distant-welcoming* aspect is controlled
    by how the human interacts with the robot. If you are acting friendly to the robot,
    then it will be welcoming. If you are new, the robot will start off cautiously
    in asking questions or interacting. If you are not answering questions, then the
    robot will become more distant. Likewise, the *friend-stranger* aspect is based
    on how much the robot knows about the person it is talking to. Finally, the *curious-frustrated*
    axis is based on how hard the robot has to work to get information or to accomplish
    a task. If it keeps failing at a task or is not getting rewards, it will become
    frustrated in its expressions and vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: How does a robot with no face express emotions? Remember we started talking
    about Hollywood robots, many of whom have distinct personalities without having
    faces or even heads. We will use body language with the robot arm and changes
    in vocabulary to express our simulation of emotions. And we will have the robot
    be open about how it is feeling and why.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal for this part of the robot development is to provide a human interaction
    framework that invites people to talk to the robot and feel welcome or wanted.
    I’m modeling this interaction from watching my grandchildren. I wanted a robot
    that they would enjoy and find interesting. What we want to do is develop the
    ability for the robot to convey intent, or to provide a simulation that the robot
    has needs and desires. We are going to do this by creating a game that the robot
    will play with humans – let’s call this the emotion game.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the emotion game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what exactly is this game? What we want the robot to do is ask questions
    of another person and to use conversation to get personal information out of them
    so that the robot then can use that information in replies. In this game, the
    robot will be trying to score points by getting the human to interact socially.
    The robot will gain points by getting information from the person so that it can
    *get to know them better*. The trick for us is we need the robot to keep this
    information and remember it. We will be saving all this information and using
    it to modify the actual code the robot is running, thus implementing **machine
    learning** (**ML**) into the conversation. The robot will be using the same type
    of point-reward system we used in training the robot arm back in a previous chapter.
    Once the robot has scored by learning a fact, it will no longer get rewarded for
    that fact and will go on to get other facts. Once it has learned all the facts,
    it will end the conversation. In practice, I think most users will want fairly
    short conversations, so we are setting our goal to have between two and six interactions
    per conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly summarize how the game will be played:'
  prefs: []
  type: TYPE_NORMAL
- en: The user will always initiate a conversation by saying the robot’s wake phrase,
    which right now is *Hey, Albert*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot will respond using the Mycroft speech engine with a beep.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user will initiate a conversation using a wake word, which is some version
    of *Hello, robot*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot will then try to earn rewards by getting points, which it does by
    asking questions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The emotion engine will respond to the human answers by modifying the robot’s
    emotions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will rank questions by importance – let’s say the robot gets 10 points for
    learning your name, 9 points for learning your age, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a fact is learned, no more points are earned, so the robot won’t repeat
    the questions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The facts we want the robot to know about each person are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Your name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are you feeling today?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is your favorite food?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is your favorite book?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you go to school?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, what is your favorite subject?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is your birthday?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is your favorite song?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you like the color pink/singing/dancing/dinosaurs/race cars/building things/robots/airplanes/spaceships?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you brush your teeth?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you like knock-knock jokes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the learning game for the robot, we will adjust the robot’s emotions
    as it learns and interacts, by adjusting the levels of the eight emotions (or
    four emotion types) we provided to the robot. We will particularly pay attention
    to the place where the eight emotions balance – are they on the *happy*/*friendly*/*curious*
    side of the graph, or more on the *sad*/*frustrated*/*distant* side?
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are trying to get some personal information about people talking to
    the robot, they may want to find out more about the robot too. So, to respond,
    our robot will also have a backstory or a biography that it will use to answer
    questions about itself. We’ll give the robot a little narrative:'
  prefs: []
  type: TYPE_NORMAL
- en: His name is Albert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: His full name is Albert Robot the Second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He is 8 months old.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He was made by Grandad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He was born on January 28, 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He likes the color green.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: His favorite food is electricity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: His favorite author is Isaac Asimov.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He does not go to school but loves to learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: His job, his hobby, and his passion is picking up toys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you ask him how he feels, he will tell you which emotional state is highest,
    plus how fresh or tired his battery is. We want him to occasionally interject
    how he is feeling into the conversation without being asked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been addressing this robot as *he* and *him* all through the book. This
    is just an anthropomorphic projection on my part and is implying features that
    a robot just does not have. The primary reason for Albert’s identity is his voice
    – I used a male voice for his synthesizer, mostly because I wanted it to stand
    out from all the female GPS and personal assistant computer voices around. Please
    feel free to create any voice you like – there are a lot of female voices available,
    and you can create whatever persona you like in your robot and give them any form
    of address. It is interesting that we tend to do this even with non-humanoid robots.
  prefs: []
  type: TYPE_NORMAL
- en: According to Colin Angle, CEO of iRobot, over 80% of Roomba owners have given
    their robot a name, including him ([https://slate.com/technology/2014/03/roomba-vacuum-cleaners-have-names-irobot-ceo-on-peoples-ties-to-robots.html](https://slate.com/technology/2014/03/roomba-vacuum-cleaners-have-names-irobot-ceo-on-peoples-ties-to-robots.html)).
    You don’t see people naming their toaster ovens or stand mixers, no matter how
    attached they are to them. Albert the robot may very well be getting a sex-change
    operation, or get a sister, as my granddaughter gets a bit older.
  prefs: []
  type: TYPE_NORMAL
- en: We will also be using the emotional state to set the robot’s body language,
    which is primarily how he is carrying his robot arm. If he is happy, the arm will
    be extended with the hand pointed upward. If he is sad, the arm will be close
    to his body and his hand will point down. We will store all this information to
    give the robot a consistent set of answers to personal questions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model of human behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the robot to support conducting a conversation, we must also have a model
    of how the human it is talking to is feeling. You may have had a friend or relation
    who went on talking about themselves and were oblivious to how you were feeling
    or reacting to their conversation. We don’t want that type of robot personality.
    Therefore, the robot has to have some internal representation of how it thinks
    you are feeling. We will not be using vision for this function, so the only way
    the robot knows how you are doing is by asking questions and evaluating the use
    of language.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will give the robot a human model similar to our state machine but with
    just four emotions on two axes: *happy*/*sad* and *friendly*/*distant*. The robot
    will assume that everyone is somewhere in the middle when the conversation begins.
    The robot can use clues in language to understand how you might be feeling, so
    we will assign *colors* or shades of emotions to words to help drive the robot’s
    human model. This can be illustrated by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – A simplified emotional continuum](img/B19846_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – A simplified emotional continuum
  prefs: []
  type: TYPE_NORMAL
- en: Different emotions from the person will drive different responses from the robot.
    We particularly want the robot to pay attention to clues that the human is becoming
    frustrated due to the robot not understanding or responding in the way the person
    wants. This brings us to actually selecting and designing an artificial personality
    for our robot.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating an artificial personality into our robot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to set some guidelines and parameters that will determine what kind
    of personality the robot has. We can start by listing some types of personalities
    that a robot might have and what kind of role they might be playing. This is particularly
    important because this robot will primarily be interacting with children. Let’s
    try a few out and see what fits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Teacher/professor**: The robot is attempting to convey information and to
    teach or cause the person to change behavior in some way. The robot presents itself
    as an authority and provides facts and information about itself, such as “I’m
    a robot. Do you know what a robot is?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyper-friendly**: The robot is playful and excited about talking with humans,
    aggressively engages people in conversation, and asks lots of questions. The robot
    expresses a lot of enthusiasm and encouragement. “I love my job. Don’t you love
    your job? It’s so great! I just love talking to people! Do you want to hear a
    joke?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chummy and friendly**: The robot is trying to make friends and be helpful.
    “Hi! Nice to see you! What is your name?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friendly but neutral**: The robot is not quick to share information but does
    want to talk to you. “Hello, I am Albert. How are you today?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feisty**: The robot is supportive, friendly, and wants interaction. It keeps
    prompting for more information. It will repeat questions if necessary. “Hi! Nice
    to meet you. What is your name? How old are you?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Somber and staid**: The robot is stuffy and authoritative. Think of having
    a conversation with a British butler. The robot uses formal English. (This is
    apparently the default non-personality of many digital assistants.) “Greetings.
    How may I help you? May I ask you your name?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Very neutral or robotic**: The robot expresses no opinions and gives no information
    about itself. It expresses no emotions or interjections. “Hello. I am a robot.
    State a command.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Annoyed and grumpy**: The robot is not very happy about having to pick up
    toys and does not mind saying so clearly and distinctly. This personality is aiming
    for comedy, not anger. “So, you are back again. I guess this means more toys to
    pick up.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see from this list the sort of gamut of personalities we can choose for
    simulation. I’m going to choose the *chummy and friendly* type of personality
    since that is what I feel will go over best with my grandchildren. You, of course,
    may choose any of these you please or add some more. Now, let’s see how we can
    proceed with this.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a personality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a quick review, what parts do we have so far for our robot with an artificial
    personality?
  prefs: []
  type: TYPE_NORMAL
- en: We have simulation tools to model emotions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a state machine with six types of emotions that we can mix together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a backstory or biography of the robot’s personal information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have picked a personality to emulate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the concept of a game engine where the robot is trying to score points
    for collecting information by engaging in small talk or **phatic communication**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot will change emotions based on conversations. Emotions will be expressed
    either by asking the robot how he is feeling or by the body language of the robot’s
    arm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we need some sort of framework to put all of these pieces together that
    can roughly carry on a conversation we can adjust and manipulate. For that, we
    are going to revisit an old, old friend. Let’s talk, once again, about **ELIZA**.
  prefs: []
  type: TYPE_NORMAL
- en: ELIZA is probably the original conversation engine software program. It was
    invented back in 1964 by Joseph Weizenbaum, professor at MIT, a Jewish German
    refugee from WWII, and considered one of the fathers of AI. ELIZA was named after
    Eliza Doolittle, the main character in George Bernard Shaw’s book *Pygmalion*.
    In Greek mythology, Pygmalion was a sculptor who fell in love with one of his
    statues. He prayed to Aphrodite, who granted his wish for the statue to come to
    life. This is very apt for what we are doing – bringing our robot to simulated
    life via this weird chain of events, titles, and Greek mythology.
  prefs: []
  type: TYPE_NORMAL
- en: 'ELIZA was a simulation of a Rogerian therapist. What is a Rogerian therapist?
    According to *Psychology Today* ([https://www.psychologytoday.com/us/blog/what-doesnt-kill-us/201210/unconditional-positive-regard](https://www.psychologytoday.com/us/blog/what-doesnt-kill-us/201210/unconditional-positive-regard)),
    Carl Rogers (1902-1987) is the founder of `>` prompt. By the way, I love cats
    – this is just an example. Please don’t tell my cat about this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, you can see that ELIZA repeats back phrases to the user, reflecting what
    the user is talking about. When I said, “I am afraid of cats,” the program replied,
    “How long have you been afraid of cats?”
  prefs: []
  type: TYPE_NORMAL
- en: 'ELIZA goes through several steps in recognizing and responding to sentences.
    Most of the program is not hardcoded, and it works from a series of scripts that
    you can edit and replace to basically reprogram the personality of the program
    – which is why we are talking about ELIZA right now:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to divide the sentence into words separated by spaces. The
    program also replaces all capital letters with lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program replaces words with several versions with a standard word. For example,
    the program replaces *cant* with *can’t* in case you left out the apostrophe.
    This is called **preprocessing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program looks for **keywords** that it knows about. A simple keyword is
    *sorry*. Any sentence with *sorry* gets a response such as *please don’t apologize*.
    Keywords are collected and prioritized by the order they appear in the script
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program looks for *decomposition* patterns for that keyword. This collects
    sentences into common groups. For example, one pattern is: `* i was *`, which
    can be read `any word phrase` – `I was - any` `word phrase`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ELIZA picks a `* I was *` pattern, one response is “Perhaps I already know you
    were (2).” The number *(2)* in parentheses tells the program to substitute the
    word phrase that comes after `I was` in the sentence. If you typed in, “Then I
    was left at a bus station,” the reply in this pattern could be, “Perhaps I already
    know you were left at a bus station.” You might also get a more pragmatic, “Oh,
    really.” It is important to know that ELIZA has no idea about the contents of
    phrases – it is just manipulating words to create sentences based on patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ELIZA performs **postprocessing** substitutions of words. For example, it replaces
    the word *I* with *you*. If you type “I went to sleep,” the program replies with,
    “You say you went to sleep?”, which is the final reply rule after all the others
    are exhausted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data that controls ELIZA’s personality is called a **script**. This gives
    the program all of the rules for forming replies. The script for the Rogerian
    therapist is called the **DOCTOR** script. It contains some greeting words, some
    final words when the program exits, a list of pre-substitution rules, a list of
    postprocessing substitution words, a list of synonyms, and a list of keywords
    with decomposition and reassembly rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample rule for the `I` `am` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The program selects a random phrase out of the four provided. If I said, “I
    am afraid of cats,” then this rule would be triggered, and one of these four phrases
    would be generated. It might say, “Do you enjoy being afraid of cats?” or “How
    long have you been afraid of cats?”
  prefs: []
  type: TYPE_NORMAL
- en: Almost all of the dialog created by ELIZA comes from the script file, making
    ELIZA a form of rule-based expert system, and also gives an open framework for
    creating new applications of conversational engines.
  prefs: []
  type: TYPE_NORMAL
- en: As all computer programs do, ELIZA’s concepts for generating conversation were
    extended and amplified into a general purpose (that is, not just a therapist)
    software program called **ALICE**, which is a retronym for **Artificial Linguist
    Internet Computer Entity**. The simple script data file used by ELIZA became the
    **Artificial Intelligence Markup Language** (**AIML**). ALICE was extended to
    be far more useful than ELIZA ever was and to cover far more subjects and capabilities.
    However, ALICE retains the same concepts of pre- and post-substitution, keywords,
    and response patterns. There is a Mycroft plugin engine that allows Mycroft to
    use AIML files to design conversations ([https://github.com/forslund/fallback-aiml](https://github.com/forslund/fallback-aiml)).
    This tool makes a great alternative construction kit for your robot personality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ve included an example of what AIML looks like ([http://www.digitalanywhere.com/projects/dany/index.html](http://www.digitalanywhere.com/projects/dany/index.html)).
    You will see blocks with categories of statements, and then a pattern of what
    that category looks like. The next tag, `<template>`, describes the response that
    the robot will make when this category is triggered. For example, the first category
    is about playing musical instruments. If you say to the robot “I play guitar,”
    then the response will be, “Is guitar a game or a musical instrument?” We can
    create our simple sentence patterns this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: ALICE is **open source software** (**OSS**) released under the GNU public license.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how we can add some context to our robot’s conversations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important shortcomings of ELIZA is a total lack of memory. ELIZA
    only remembers the previous statement. You can’t talk about your father and then
    say, “He was a good man.” ELIZA will have no idea whom you are talking about.
    ELIZA has no concept of context beyond the previous sentence.
  prefs: []
  type: TYPE_NORMAL
- en: What is **context**? In the course of a conversation, we often shorten nouns
    into pronouns. We might say, “I like my dog,” and in the next sentence say, “She
    is well behaved.” Who does *she* refer to? We know it is the dog, but how does
    the computer know? We are going to add some ability to reason from context to
    our program.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a storage object we will call the **context memory**.
    In that object, we will be able to keep up with several parts of our conversation,
    including the person we are talking to currently, the last subject we talked about,
    if we had asked any questions we still don’t have the answer to, and the answers
    to any previous questions, in case we need them again. The computer will assume
    that a pronoun other than *I* will refer to the last subject, whatever that was.
    If I was talking about a dog, and then said, “She is so cute,” then the robot
    would assume I meant the dog.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we discussed playing a game to get information from a person. The
    robot will be collecting and remembering this information, even after it is turned
    off, so that the next time that person is talking to the robot, it remembers the
    information it learned the last time – just as you do with a new friend. If you
    want to continue to expand this AI chatbot concept, you can use this information
    to create additional conversations. For example, if the human says they like baseball,
    the robot could ask what their favorite team is and then look up on the internet
    when the next baseball game is scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: That is the end of our list of parts we are going to use to build our robot
    personality. We can now dive in and use our personality construction kit. I’m
    going to use the bones of the ELIZA Python open source program from Wade Brainerd
    to build Albert the robot’s personality.
  prefs: []
  type: TYPE_NORMAL
- en: In the interest of time and space, I’m only going to put the parts here that
    I added to the base program. The entire code will be in the GitHub repository.
    You can get the original program at [https://github.com/wadetb/eliza](https://github.com/wadetb/eliza)
    if you want to follow along beyond what’s in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Under construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s review all the parts we have to put together to make our robot personality:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monte Carlo (stochastic, or random-based) modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our robot emotion state machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perception of human emotion state machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our robot biography (list of internal facts about the robot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A conversation engine framework called ELIZA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context or the ability to remember and return facts and “fill in the blanks”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this and the next few sections, I will be presenting the code that I added
    to Albert to facilitate his artificial personality. A lot of it will be contained
    in script files that provide rules and patterns for Albert’s speech. There will
    also be code functions for his emotion engine, human emotion model, and game engine.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: I needed to add some new functions to the script language used by ELIZA. First,
    I added the context of our robot, who takes the place of ELIZA, the therapist.
    First, we have the opening words when we initiate the interactive conversation
    mode of Albert by saying “Hey, Albert” (or whatever you decided to call it), the
    wake word for Mycroft, and then just “Hello.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The robot responds with the `initial` phrase, as noted by the tag before the
    colon. We also have our closing phrase here. You can actually put as many phrases
    as you like, and the computer will randomly choose one. These rules go into the
    file I named `AlbertPersonality.txt`, which started as a copy of the original
    `doctor.txt` script file that came with ELIZA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I added some word substitutes in case the user calls the robot by name rather
    than *you*. This just substitutes *you* for anything you might call the robot.
    I also set synonyms for various versions of the robot’s name, so you can call
    it *robot* or *bot*, as well as *Albert*, *Bert*, or even *Bertie*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A rule with `pre:` in front of it is substituted before any other processing
    takes place. From the first rule, if the word *robot* appears in a sentence, as
    in “Robot, how old are you?”, the program removes *robot* and substitutes *you*
    to make the parsing consistent. We also change all uppercase letters to lowercase,
    so there are no capital letters in the rules. The `synon:` rule (synonym) replaces
    any of the listed words with the first word given:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing we needed was to create questions that we wanted the robot to
    ask in order to gain information. The program will automatically *harvest* this
    data in any of the keywords we define to appear in a sentence. Here is the definition
    for rules about asking questions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new flag for questions to add to our script file. Each line represents
    one question, but we can ask it in different ways or forms. The program will select
    one version at random and decide which question to ask based on the relative priority
    we will set on the questions. The `assert` keyword with the `<>` symbols around
    it is another new flag I added to cue the context memory that we have created
    a context of asking some question, and the next statement is probably an answer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I created a new data structure I called `datum`, the singular of *data*. This
    represents some information we want the robot to ask about. We give the datum
    a title – `name` in this case, as we want the robot to ask the name of who it
    is talking to. The `decomp` (for decomposition) tags are the patterns of sentences
    where the user might say their name. `*` represents any phrase. So, if the human
    says “Hello. My name is Fred Rodgers,” then the robot will call them Fred Rodgers
    from then on. If the human says, “Call me Ishmael” for some unknown reason, then
    the robot will use that. We must reassemble the response phrase with the `reasmb`
    rules. `(1)` refers to the first `*` phrase that appears. If the user says, “I
    am John,” then when we use the reassemble rules, `(1)` will be replaced by `John`.
    The robot will pick one of the phrases provided at random, such as: “Your name
    is John, right?”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I added another new tag to allow the robot to use the context memory area to
    perform two functions. We can declare a context subject when we ask a question,
    which we will do in a later section. For example, when we ask the user, “What
    is your name?”, then we want the robot to know that the next answer will be in
    the context of that question. It’s perfectly reasonable for the robot to say “Who
    are you?” and the user to immediately answer “Julia” with no other words in that
    sentence. How is the program to know what to do with *Julia*? The answer is the
    context flag, noted by being bracketed by `<>`. We read the `decomp <name> *`
    decomposition rule as if you are in the context of asking for a name, and you
    get a reply with no keywords, so take whatever you get as the answer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Emotion tags are noted by a bracket, such as `[happy]` or `[sad]`. This will
    move either the robot’s emotions or the robot’s perception of human emotions,
    depending on whether it is a statement received from a human or a sentence uttered
    by the robot. There can be more than one emotion tag associated with a statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are the rules for listening for the answer to the `age` question:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the final line, `store:` is the command to tell the computer that this is
    the answer to the question and to store that away in the dictionary with the title
    provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use an example of an interaction with some emotions tied to it
    so that we can see how we will use the emotion engine to control what the robot
    says. This set of rules is enacted when the user says “How are you?” to the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be putting the robot’s emotions into the context memory so that the
    script processing program can have access to it. We treat an emotion – for dialog
    purposes – as part of the context that we are speaking about, which I think is
    a reasonable approach to working with emotions. Each emotion has a tag or name
    in the context memory dictionary. If the predominant emotion in the robot is happy,
    then the robot sets the `happy` context in the context memory. Then, the rule
    base will use the context tag to determine which phrase to use to reply to “How
    are you feeling?” We can also ask a follow-up question. Look at the rule for `<happy>`.
    The robot replies, “I’m doing well. How are you?” and then sets the `feeling`
    context to let the engine know that we asked a question about feeling. Finally,
    the last line relates to the `tired` emotion. If the robot is feeling tired, then
    we jump to a separate section for the robot to talk about being tired. We make
    it a separate routine because we need to call it from several places, which illustrates
    the utility of this rule-based approach to speech. I don’t want to imagine how
    many C or C++ source lines of code it would take to create all of these rules
    for each line of dialog. We continue to modify the scripts using these guidelines
    until we have completed all our questions and have patterns for all of the answers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we are going to switch back to Python code for the rest of this example.
    Our next section describes how we are going to simulate emotions.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the robot emotion engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are going to put together the robot’s emotion model. This is the heart
    of the artificial personality as it computes, updates, and remembers the emotional
    state of the robot. The robot starts in a generally neutral state and performs
    updates based on the combination of eight emotional traits: *happy*/*sad*, *welcoming*/*distant*,
    *friendly*/ *stranger*, *curious*/*frustrated*, and *fresh*/*tired*. As events
    happen in the experience of the robot, it gets cues that cause its emotional state
    to change. For example, if the user said “That is stupid” to something the robot
    said, then the robot would add to the `sad` axis of its emotion.'
  prefs: []
  type: TYPE_NORMAL
- en: We compute the overall emotional state using polar coordinates, just like you
    saw in the diagram we drew earlier in this chapter (*Figure 9**.4*). The current
    emotional state is determined by computing the center of mass of the other emotions.
    If the emotions are more or less balanced, the center of mass of the emotions,
    as plotted on our polar chart, would be near the center. If the robot is mostly
    happy and friendly, then the mass moves more over to that side of the graph. We
    pick the single emotional state that is closest to the center of the mass. This
    is intended to be the basis of creating a complex emotional character for the
    robot. The attribute of *fresh*/*tired* is unique, in that the value for that
    emotion is based on the elapsed runtime of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: The primary expressions of emotion for the robot will be the position of the
    robot arm – happier robots carry their arms higher and more forward – and the
    choice of vocabulary in conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code creates data entries for the emotion engine in
    the format required by our conversation engine. We are creating a Python interface
    to the rule-based format so that we can connect it to the rest of the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the `update` function; this function checks to see if we’ve had
    a change in our emotional state, and if so, we change our current emotion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The robot also needs a model of the human it is talking to so that it can make
    different responses based on how the human is interacting. In the next section,
    we are going to create a smaller version of the emotion model we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a human emotion model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We model four emotions for our human interactions for the robot to use in formulating
    responses: *happy*/*sad* and *welcoming*/*distant*. We can put emotion tags into
    our patterns in the script file with `[happy]`, `[sad]`, `[welcome]`, or `[distant]`
    to mark the emotions of responses. For example, if we are not getting answers
    to our questions, we can mark that response with `[distant]` to note that our
    subject is not being cooperative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Simplified human emotional model showing the axes between happy
    and sad emotions: robot point of view](img/B19846_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6 – Simplified human emotional model showing the axes between happy
    and sad emotions: robot point of view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our human emotion model makes use of a Python dictionary data structure to
    hold our model. Let’s take a closer look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two axes: the *happy*/*sad* axis and the *welcoming*/*distant* axis.
    We move the *happy*/*s**ad* index up or down based on responses. If we think a
    response expresses happy thoughts (“Do you like school?” “Yes”), the program moves
    up the emotion index in the *happy* direction. We use the intersection of these
    to set the current emotional index. If the human is near the center, we note this
    as neutral, our starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at the `change` function. If `happy` goes up, `sad` goes down, so
    we balance this automatically when emotions change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `update` function gets the current emotional balance of the human model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the emotional state is near the middle, we call that `neutral`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This next section discusses where we are going to store the information we are
    collecting from humans.
  prefs: []
  type: TYPE_NORMAL
- en: Creating human information storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This data structure stores the information we have collected about the human
    user and lets the robot know what questions have yet to be answered. We use a
    Python dictionary to hold the data. Let’s make a freeform version of a database-like
    table. I add values to the dictionary as we go to make extension easier. I put
    a list of miscellaneous questions called `stuff` to throw some spice into the
    robot’s information gathering so that the questions don’t seem too monotonous.
    The robot will ask if you like the color pink, singing, dancing, robots, airplanes,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We put the list in priority order by copying the dictionary and replacing the
    data fields with relative point values from 20 to 0\. `name` is first with 20
    points, `age` is second with 18, and so on. As each question is answered, we set
    this point value to zero. For example, if we get an answer for “What is your favorite
    food?” as “apple,” we set `self.info["food"] = apple`, and set `self.points["food"]
    = 0`. I also added some extra questions for things that my grandchildren like,
    with the points set very low so that the conversation is more varied. I ask about
    princesses, airplanes, dinosaurs, singing, and building things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the next section, we’ll create a memory for our robot so that the robot
    can remember what it has already learned. We need a place to put the answers we
    receive.
  prefs: []
  type: TYPE_NORMAL
- en: Context memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This block of code constructs the robot’s context memory. You can think of this
    as a pool of information that the robot can remember. We set up the robot’s emotion
    and the model of human emotion to both be neutral. I created some data structure
    so that we can refer to multiple human users by pointing `self.currentHuman` to
    the `HumanInformation` data object we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we have the robot remember what emotional state it is in, along
    with what the software perceives as the human’s emotional state so that the robot
    doesn’t suddenly forget the decisions it has already made. In the following code
    snippet, we define `self.emotion`, which is the robot’s internal state, and `humanEmotion`
    for the person we are interacting with. Then, we use these structures to create
    a file we write to disk so the robot’s personality persists if you turn it off.
    We use the `inContext` function to retrieve data from the context pool. If no
    data is available, we return an integer of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In these sections, we created a place for the robot to store information about
    how it currently feels, what emotional state the robot is in, and what it has
    learned about the human it is talking to. We also have a structure to add new
    humans to our database for when we meet someone new.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a very busy chapter. We created an emotional engine for our robot and
    created a conversational interface so that it can interact with people. We introduced
    simulation concepts, as we were creating a simulation of emotion for our robot.
    We can’t create real, biologically motivated emotions, so we simulated emotions
    via playing a game. In this game, we tried to get humans to provide information
    about themselves, which is what we humans call *small talk*. We assigned point
    values for emotions and created an emotional state machine both for the robot’s
    internal *feelings* and a representation of how the robot perceives your emotions
    via interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In our final chapter, we will talk about your robotics educational journey,
    give some guidance on careers in robotics, and talk about the future, which is
    always a perilous topic.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is your favorite movie robot? How would you describe its personality?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What techniques did the movie-makers use to express that robot’s personality
    (body language, sounds, and so on)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two types of chatbots? List some of the strengths and weaknesses
    of each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the diagram of modeling custom distributions (the airport example), the bottom
    image shows two standard distributions and two uniform distributions. Why don’t
    the curves go all the way to the top of the graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design your own robot emotions. Pick six contrasting emotions that can express
    the entire range of your robot’s personality. Why did you pick those?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Affective Computing* by Rosalind Picard: [https://direct.mit.edu/books/book/4296/Affective-Computing](https://direct.mit.edu/books/book/4296/Affective-Computing).
    This book is a foundational text in the field of affective computing, which is
    directly relevant to simulating emotions in AI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Emotion Modelling for Social Robots* by Ana Paiva, Iolanda Leite, and Tiago
    Ribeiro: [https://people.ict.usc.edu/~gratch/CSCI534/Readings/ACII-Handbook-Robots.pdf](https://people.ict.usc.edu/~gratch/CSCI534/Readings/ACII-Handbook-Robots.pdf).
    This book includes research papers and studies focused on implementing emotional
    responses in robots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Designing Sociable Robots* by Cynthia Breazeal: [https://direct.mit.edu/books/book/2309/Designing-Sociable-Robots](https://direct.mit.edu/books/book/2309/Designing-Sociable-Robots).
    A key resource for understanding the integration of emotional and social dynamics
    in robots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
