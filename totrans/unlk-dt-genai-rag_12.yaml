- en: <st c="0">12</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Combining RAG with the Power of AI Agents and LangGraph</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="59">One call to an</st> **<st c="75">large language model</st>** <st
    c="95">(</st>**<st c="97">LLM</st>**<st c="100">) can be powerful, but put your
    logic in a loop with a goal toward achieving a more sophisticated task and you
    can take your</st> **<st c="226">retrieval-augmented generation</st>** <st c="256">(</st>**<st
    c="258">RAG</st>**<st c="261">) development to a whole new level.</st> <st c="298">That
    is the concept behind</st> **<st c="325">agents</st>**<st c="331">. The past year
    of development for LangChain has focused significant energy on improving support
    for</st> *<st c="432">agentic</st>* <st c="439">workflows, adding functionality
    that enables more precise control over agent behavior and capabilities.</st> <st
    c="544">Part of this progress has been in the emergence of</st> **<st c="595">LangGraph</st>**<st
    c="604">, another relatively new part of LangChain.</st> <st c="648">Together,
    agents and LangGraph pair well as a powerful approach to improving</st> <st c="725">RAG
    applications.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <st c="742">In this chapter, we will focus on gaining a deeper understanding
    of the elements of agents that can be utilized in RAG and then tie them back to
    your RAG efforts, covering topics such as</st> <st c="930">the following:</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: <st c="944">Fundamentals of AI agents and</st> <st c="975">RAG integration</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="990">Graphs, AI agents,</st> <st c="1010">and LangGraph</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1023">Adding a LangGraph retrieval agent to your</st> <st c="1067">RAG
    application</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1082">Tools</st> <st c="1089">and toolkits</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1101">Agent state</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1113">Core concepts of</st> <st c="1131">graph theory</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1143">By the end of this chapter, you will have a solid grasp of how
    AI agents and LangGraph can enhance your RAG applications.</st> <st c="1266">In
    the next section, we will dive into the fundamentals of AI agents and RAG integration,
    setting the stage for the concepts and code lab</st> <st c="1404">that follow.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1416">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1439">The code for this chapter is placed in the following GitHub</st>
    <st c="1500">repository:</st> [<st c="1512">https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_12</st>](https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_12)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1609">Fundamentals of AI agents and RAG integration</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1655">When talking with new developers in generative AI, we have been
    told that the concept of an AI agent often tends to be one of the more challenging
    concepts to grasp.</st> <st c="1822">When experts talk about agents, they often
    talk about them in very abstract terms, focusing on all the things AI agents can
    be responsible for in a RAG application, but failing to really explain thoroughly
    what an AI agent is and how</st> <st c="2056">it works.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2065">I find that it is easiest to dispel the mystery of the AI</st>
    <st c="2123">agent by explaining what it really is, which is actually a very simple
    concept.</st> <st c="2204">To build an AI agent in its most basic form, you are
    simply taking the same LLM concept you have already been working with throughout
    these chapters and adding a loop that terminates when the intended task is done.</st>
    <st c="2419">That’s it!</st> <st c="2430">It’s just a</st> <st c="2442">loop folks!</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="2453">Figure 12</st>**<st c="2463">.1</st>* <st c="2465">represents
    the</st> **<st c="2481">RAG agent loop</st>** <st c="2495">you will be working</st>
    <st c="2515">with in the code lab that you are about to</st> <st c="2559">dive
    into:</st>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Graph of the agent’s control flow](img/B22475_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: <st c="2598">Figure 12.1 – Graph of the agent’s control flow</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2645">This represents a relatively simple set of logic steps that loop
    through until the agent decides it has successfully completed the task you have
    given it.</st> <st c="2801">The oval</st> <st c="2809">boxes, such as</st> *<st
    c="2825">agent</st>* <st c="2830">and</st> *<st c="2835">retrieve</st>*<st c="2843">,
    are called</st> **<st c="2856">nodes</st>** <st c="2861">and the lines are</st>
    <st c="2879">called</st> **<st c="2887">edges</st>**<st c="2892">. The dotted
    lines are also edges, but they are a specific type called</st> **<st c="2963">conditional
    edges</st>**<st c="2980">, which are edges</st> <st c="2997">that are also</st>
    <st c="3012">decision points.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3028">Despite the simplicity, the concept of adding a loop to your LLM
    calls does make it much more powerful than just using LLMs directly, because it
    takes more advantage of the LLM’s ability to reason and break tasks down into
    simpler tasks.</st> <st c="3267">This improves the chances of success in whatever
    task you are pursuing and will come in especially handy with more complex multi-step</st>
    <st c="3401">RAG tasks.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3411">While your LLM is looping through agent tasks, you also provide
    functions called</st> *<st c="3493">tools</st>* <st c="3498">to the agent, and
    the LLM will use its reasoning capabilities to determine which tool to use, how
    to use that tool, and what data to feed it.</st> <st c="3641">This is where it
    can get really complex very quickly.</st> <st c="3695">You can have multiple agents,
    numerous tools, integrated knowledge graphs that help guide your agents down a
    specific path, numerous frameworks that offer different</st> *<st c="3860">flavors</st>*
    <st c="3867">of agents, numerous approaches to agent architecture, and much more.</st>
    <st c="3937">But in this chapter, we are going to focus specifically on how an
    AI agent can help improve RAG applications.</st> <st c="4047">Once you see the
    power of using an AI agent though, I have no doubt you will want to use it in
    other generative AI applications, and</st> <st c="4180">you should!</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4191">Living in an AI agent world</st>
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4219">With all the excitement</st> <st c="4243">around agents, you might
    think LLMs are already going obsolete.</st> <st c="4308">But that couldn’t be
    further from the truth.</st> <st c="4353">With AI agents, you are really tapping
    into an even more powerful version of an LLM, a version where the LLM serves as
    the “brain” of the agent, letting it reason and come up with multi-step solutions
    well beyond the one-off chat questions most people are using them for.</st> <st
    c="4625">The agent just provides a layer between the user and the LLM and pushes
    the LLM to accomplish a task that may take multiple queries of the LLM but will
    eventually, in theory, end up with a much</st> <st c="4819">better result.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4833">If you think about it, this matches up more with how problems are
    solved in the real world, where even simple decisions can be complex.</st> <st
    c="4970">Most tasks we do are based on a long chain of observations, reasoning,
    and adjustments to new experiences.</st> <st c="5077">Very rarely do we interact
    with people, tasks, and things in the real world in the same way we interact with
    LLMs online.</st> <st c="5199">There is often this building of understanding,
    knowledge, and context that takes place and helps us find the best solutions.</st>
    <st c="5324">AI agents are better able to handle this type of approach</st> <st
    c="5382">to problem-solving.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5401">Agents can make a big difference to your RAG efforts, but what
    about this concept of the LLMs being their brains?</st> <st c="5516">Let’s dive
    into the</st> <st c="5536">concept further.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5552">LLMs as the agents’ brains</st>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5579">If you consider the LLM</st> <st c="5603">as the brain of your
    AI agent, the next logical step is that you likely want the</st> *<st c="5685">smartest</st>*
    <st c="5693">LLM you can find to be that brain.</st> <st c="5729">The capabilities
    of the LLM are going to affect your AI agent’s ability to reason and make decisions,
    which will certainly impact the results of the queries to your</st> <st c="5894">RAG
    application.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5910">There is one major</st> <st c="5929">way this metaphor of an LLM
    brain breaks down though, but in a very good way.</st> <st c="6008">Unlike agents
    in the real world, the AI agent can always swap out their LLM brain for another
    LLM brain.</st> <st c="6113">We could even give it multiple LLM brains that can
    serve to check each other and make sure things are proceeding as planned.</st>
    <st c="6238">This gives us greater flexibility that will help us continually improve
    the capabilities of</st> <st c="6330">our agents.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6341">So, how does LangGraph, or graphs in general, relate to AI agents?</st>
    <st c="6409">We will discuss</st> <st c="6425">that next.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6435">Graphs, AI agents, and LangGraph</st>
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="6468">LangChain introduced</st> <st c="6489">LangGraph in</st> <st c="6502">2024,
    so it is still relatively new.</st> <st c="6540">It is an extension built on top
    of</st> `<st c="6863">AgentExecutor</st>` <st c="6876">class, still exists, LangGraph
    is now the</st> *<st c="6919">recommended</st>* <st c="6930">way to build agents</st>
    <st c="6951">in LangChain.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6964">LangGraph adds two important components</st> <st c="7004">for</st>
    <st c="7009">supporting agents:</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7027">The ability to easily define cycles (</st><st c="7065">cyclical
    graphs)</st>
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="7082">Built-in memory</st>
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="7098">It provides a pre-built object equivalent to</st> `<st c="7144">AgentExecutor</st>`<st
    c="7157">, allowing developers to orchestrate agents using a</st> <st c="7209">graph-based
    approach.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7230">Over the past couple of years, numerous papers, concepts, and approaches
    have emerged for building agents into RAG applications, such as orchestration
    agents, ReAct agents, self-refine agents, and multi-agent frameworks.</st> <st
    c="7452">A common theme among these approaches is the concept of a cyclical graph
    that represents the agent’s control flow.</st> <st c="7567">While many of these
    approaches, from an implementation standpoint, are going obsolete, their concepts
    are still highly useful and are captured in the graph-based environment</st> <st
    c="7741">of LangGraph.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7754">LangGraph</st>** <st c="7764">has become</st> <st c="7775">a
    powerful tool for supporting agents and managing their flow and process in RAG
    applications.</st> <st c="7871">It enables developers to describe and represent
    single and multi-agent flows as graphs, providing extremely controlled</st> *<st
    c="7990">flows</st>*<st c="7995">. This controllability is crucial for avoiding
    the pitfalls encountered by developers when creating agents</st> <st c="8102">early
    on.</st>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8111">As an example, the popular ReAct approach was an early paradigm
    for building agents.</st> **<st c="8197">ReAct</st>** <st c="8202">stands for</st>
    **<st c="8214">reason + act</st>**<st c="8226">. In this pattern, an LLM</st>
    <st c="8251">first thinks about what to do and then decides an action to take.</st>
    <st c="8318">That action is then executed in an environment and an observation
    is returned.</st> <st c="8397">With that observation, the LLM then repeats this
    process.</st> <st c="8455">It uses reasoning to think about what to do next, decides
    another action to take, and continues until it has been determined that the goal
    has been met.</st> <st c="8608">If you map this process out, it may look something
    like what you see here in</st> *<st c="8685">Figure 12</st>**<st c="8694">.2</st>*<st
    c="8696">:</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – ReAct cyclical graph representation](img/B22475_12_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: <st c="8721">Figure 12.2 – ReAct cyclical graph representation</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8770">The set of loops in</st> *<st c="8791">Figure 12</st>**<st c="8800">.2</st>*
    <st c="8802">can be represented</st> <st c="8821">by cyclical graphs in LangGraph,
    with each step represented by nodes and edges.</st> <st c="8902">Using this graphing
    paradigm, you can see how a tool such as LangGraph, a tool for building graphs
    in LangChain, can form the backbone of your agent framework.</st> <st c="9062">As
    we build our agent framework, we can represent these agent loops using LangGraph,
    which helps you describe and orchestrate the control flow.</st> <st c="9206">This
    focus on the control flow is critical to addressing some of the early challenges
    with agents, where a lack of control leads to rogue agents that can’t complete
    their loops or focus on the</st> <st c="9399">wrong task.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9410">Another key element that LangGraph has built into it is persistence.</st>
    <st c="9480">Persistence can be used to maintain the memory of the agent, giving
    it the information it needs to reflect on all of its actions so far, and representing
    the</st> *<st c="9638">OBSERVE</st>* <st c="9645">component presented in</st>
    *<st c="9669">Figure 12</st>**<st c="9678">.2</st>*<st c="9680">. This is really
    helpful for having multiple conversations at the same time or remembering previous
    iterations and actions.</st> <st c="9804">This persistence also enables human-in-the-loop
    features that give you better control over what the agent is doing at key intervals
    during</st> <st c="9943">its actions.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9955">The paper that introduced the ReAct approach to agent building
    can be found</st> <st c="10032">here:</st> [<st c="10038">https://arxiv.org/abs/2210.03629</st>](https://arxiv.org/abs/2210.03629)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10070">Let’s dive right into the code lab for building our agent and
    walk through more key individual concepts as we encounter them in</st> <st c="10199">the
    code.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10208">Code lab 12.1 – adding a LangGraph agent to RAG</st>
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="10256">In this code lab, we will add an agent</st> <st c="10295">to our
    existing RAG pipeline that can make decisions about whether to retrieve from an
    index or use a web search.</st> <st c="10410">We will show the inner thoughts
    of the agent as it processes data that it retrieves toward the goal of providing
    you with a more thorough response to your question.</st> <st c="10575">As we add
    the code for our agent, we will see new components, such as tools, toolkits, graphs,
    nodes, edges, and, of course, the agent itself.</st> <st c="10718">For each component,
    we will go more in-depth into how that component interacts and supports your RAG
    application.</st> <st c="10832">We will also add code so that this functions more
    like a chat session, rather than a</st> <st c="10917">Q&A session:</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10929">First, we will install some new packages to support our</st> <st
    c="10986">agent development:</st>
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="11262">Next, we add a new LLM definition and update our</st> <st c="11312">existing
    one:</st>
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="11479">The new</st> `<st c="11488">agent_llm</st>` <st c="11497">LLM
    instance will serve as our agent’s brain, handling reasoning and execution of
    the agent tasks, whereas the original</st> `<st c="11618">llm</st>` <st c="11621">instance
    will still be present in our general LLM to do the same LLM tasks we have used
    it for in the past.</st> <st c="11730">While the two LLMs are defined with the
    same model and parameters in our example, you could and should experiment with
    using different LLMs for these different tasks, to see if there is a combination
    that works better for your RAG applications.</st> <st c="11975">You could even
    add additional LLMs to handle specific tasks, such as the</st> `<st c="12048">improve</st>`
    <st c="12055">or</st> `<st c="12059">score_documents</st>` <st c="12074">functions
    in this code, if you find an LLM better at those tasks or have trained or fine-tuned
    your own for these particular actions.</st> <st c="12209">For example, It is common
    for simple tasks to be handled by faster, lower-cost LLMs as long as they can
    perform the task successfully.</st> <st c="12344">There is a lot of flexibility
    built into this code that you can take advantage of!</st> <st c="12427">Also,
    note that we add</st> `<st c="12450">streaming=True</st>` <st c="12464">to the
    LLM definition.</st> <st c="12488">This turns on streaming data from the LLM,
    which is more conducive to an agent that may make several calls, sometimes in
    parallel, constantly interacting with</st> <st c="12647">the LLM.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12655">Now, we are going to skip down to after the retriever definitions
    (</st>`<st c="12723">dense_retriever</st>`<st c="12739">,</st> `<st c="12741">sparse_retriever</st>`<st
    c="12757">, and</st> `<st c="12763">ensemble_retriever</st>`<st c="12781">) and
    add our first tool.</st> <st c="12808">A</st> **<st c="12810">tool</st>** <st
    c="12814">has a very specific and important meaning when it comes to agents; so,
    let’s talk about</st> <st c="12903">that now.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12912">Tools and toolkits</st>
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="12931">In the following code, we are going to add</st> <st c="12974">a</st>
    **<st c="12977">web</st>** **<st c="12981">search</st>** <st c="12987">tool:</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="13297">You will need to get another API key and add it to the</st> `<st
    c="13353">env.txt</st>` <st c="13360">file we have used in the past for the OpenAI
    and Together APIs.</st> <st c="13425">Just like with those APIs, you will need
    to go to that website, set up your API key, and then copy that into your</st>
    `<st c="13539">env.txt</st>` <st c="13546">file.</st> <st c="13553">The Tavily
    website can be found at this</st> <st c="13593">URL:</st> [<st c="13598">https://tavily.com/</st>](https://tavily.com/)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13617">We run</st> <st c="13624">the code again that loads the data from
    the</st> `<st c="13669">env.txt</st>` <st c="13676">file and then we set up the</st>
    `<st c="13705">TavilySearchResults</st>` <st c="13724">object with</st> `<st c="13737">max_results</st>`
    <st c="13748">of</st> `<st c="13752">4</st>`<st c="13753">, meaning when we run
    it for search, we only want four search results maximum.</st> <st c="13832">We
    then assign the</st> `<st c="13851">web_search.name</st>` <st c="13866">variable
    to a variable called</st> `<st c="13897">web_search_name</st>` <st c="13912">so
    that we have that available later when we want to tell the agent about it.</st>
    <st c="13991">You can run this tool directly using</st> <st c="14028">this code:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="14068">Running this tool code with</st> `<st c="14097">user_query</st>`
    <st c="14107">will give you a result like this (truncated</st> <st c="14152">for
    brevity):</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="14856">We truncated this so we take up less space in the book, but try
    this in the code and you will see four results, as we asked for, and they all
    seem to be highly related to the topic</st> `<st c="15038">user_query</st>` <st
    c="15048">is asking about.</st> <st c="15066">Note that you will not need to run
    this tool directly in your code like we</st> <st c="15141">just did.</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15150">At this point, you have just established your first agent tool!</st>
    <st c="15215">This is a search engine tool that your agent can use to retrieve
    more information from the internet to help it achieve its goal of answering the
    question your user poses</st> <st c="15385">to it.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="15391">The</st> *<st c="15396">tool</st>* <st c="15400">concept in LangChain</st>
    <st c="15421">and when building agents comes from the idea that you want to make
    actions available to your agent so that it can carry out its tasks.</st> <st c="15557">Tools
    are the mechanism that allows this to happen.</st> <st c="15609">You define a
    tool like we just did for the web search, and then you later add it to a list
    of tools that the agent can use to accomplish its tasks.</st> <st c="15757">Before
    we set up that list though, we want to create another tool that is central for
    a RAG application: a</st> <st c="15864">retriever tool:</st>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="16164">Note that with the web search</st> <st c="16194">tool, we imported
    it from</st> `<st c="16221">langchain_community.tools.tavily_search</st>`<st c="16260">,
    whereas with this tool, we use</st> `<st c="16293">langchain.tools.retriever</st>`<st
    c="16318">. This reflects the fact that Tavily is a third-party tool, whereas
    the retriever tool we create here is part of the core LangChain functionality.</st>
    <st c="16465">After importing the</st> `<st c="16485">create_retriever_tool</st>`
    <st c="16506">function, we use it to create the</st> `<st c="16541">retriever_tool</st>`
    <st c="16555">tool for our agent.</st> <st c="16576">Again, like with</st> `<st
    c="16593">web_search_name</st>`<st c="16608">, we pull out the</st> `<st c="16626">retriever_tool.name</st>`
    <st c="16645">variable we can reference later when we want to refer to it for
    the agent.</st> <st c="16721">You may notice the name of the actual retriever
    this tool will use, the</st> `<st c="16793">ensemble_retriever</st>` <st c="16811">retriever,
    which we created in</st> [*<st c="16843">Chapter 8</st>*](B22475_08.xhtml#_idTextAnchor152)<st
    c="16852">’s</st> *<st c="16856">8.3</st>* *<st c="16860">code lab</st>*<st c="16868">!</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16869">You should also note that the name that we are giving this tool,
    as far as the agent is concerned, is found in the second field, and we are calling
    it</st> `<st c="17020">retrieve_google_environmental_question_answers</st>`<st
    c="17066">. When we name variables in code, we normally try to keep them smaller,
    but for tools that agents will use, it is helpful to provide more verbose names
    that will help the agent understand what can be</st> <st c="17266">used fully.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17277">We now have two tools for our agent!</st> <st c="17315">However,
    we still need to tell the agent about them eventually; so, we package them up
    into a list that we can later share with</st> <st c="17443">the agent:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="17490">You see here the two tools we created previously, the</st> `<st
    c="17545">web_search</st>` <st c="17555">tool and the</st> `<st c="17569">retriever_tool</st>`
    <st c="17583">tool, getting added to the tools list.</st> <st c="17623">If we
    had other tools we wanted to make available to the agent, we could add those to
    the list as well.</st> <st c="17727">In the LangChain</st> <st c="17743">ecosystem,
    there are hundreds of tools</st> <st c="17783">available:</st> [<st c="17794">https://python.langchain.com/v0.2/docs/integrations/tools/</st>](https://python.langchain.com/v0.2/docs/integrations/tools/)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17852">You will want to make sure the LLM you are using is “good” at
    reasoning and using tools.</st> <st c="17942">In general, chat models tend to
    have been fine-tuned for tool calling and will be better at using tools.</st>
    <st c="18047">Non-chat-fine-tuned models may not be able to use tools, especially
    if the tools are complex or require multiple calls.</st> <st c="18167">Using well-written
    names and descriptions can play an important role in setting your agent LLM up
    for success</st> <st c="18277">as well.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18285">In the agent we are building, we have all the tools we need, but
    you will also want to look at the toolkits, which are convenient groups of tools.</st>
    <st c="18433">LangChain provides a list of the current toolkits</st> <st c="18482">available
    on their</st> <st c="18502">website:</st> [<st c="18511">https://python.langchain.com/v0.2/docs/integrations/toolkits/</st>](https://python.langchain.com/v0.2/docs/integrations/toolkits/)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="18572">For example, if you have a data infrastructure that uses pandas
    DataFrames, you could use the pandas DataFrame toolkit to offer your agent various
    tools to access those DataFrames in different ways.</st> <st c="18772">Drawing
    straight from the LangChain website, toolkits are described as</st> <st c="18843">follows:
    (</st>[<st c="18853">https://python.langchain.com/v0.1/docs/modules/agents/concepts/#toolkits</st>](https://python.langchain.com/v0.1/docs/modules/agents/concepts/#toolkits)<st
    c="18926">)</st>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18928">For many common tasks, an agent will need a set of related tools.</st>
    <st c="18994">For this LangChain provides the concept of toolkits - groups of
    around 3-5 tools needed to accomplish specific objectives.</st> <st c="19117">For
    example, the GitHub toolkit has a tool for searching through GitHub issues, a
    tool for reading a file, a tool for commenting, etc.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19251">So, basically, if you are focusing on a set of common tasks for
    your agent or a popular integration partner with LangChain (such as a Salesforce
    integration), there is likely a toolkit that will give you access to all the tools
    you need all</st> <st c="19493">at once.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19501">Now that we have the tools established, let’s start building the
    components of our agent, starting with the</st> <st c="19610">agent state.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19622">Agent state</st>
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="19634">The</st> `<st c="19740">AgentState</st>` <st c="19750">class that
    establishes the “state” for your agent and tracks it over time.</st> <st c="19826">This
    state is a local mechanism to the agent that you make available to all parts of
    the graph and can be stored in a</st> <st c="19944">persistence layer.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19962">Here, we set up this state for our</st> <st c="19998">RAG agent:</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="20250">This imports relevant packages for setting up</st> `<st c="20297">AgentState</st>`<st
    c="20307">. For example,</st> `<st c="20322">BaseMessage</st>` <st c="20333">is
    a base class for representing messages in the conversation between the user and
    the AI agent.</st> <st c="20431">It will be used to define the structure and properties
    of messages in the state of the conversation.</st> <st c="20532">It then defines
    a graph and a</st> `<st c="20562">"state"</st>` <st c="20569">object that it passes
    around to each node.</st> <st c="20613">You can set the state to be a variety
    of types of objects that you can store different types of data, but for our RAG
    agent, we set up our state to be a list</st> <st c="20771">of</st> `<st c="20774">"messages"</st>`<st
    c="20784">.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20785">We then need to import another round of packages to set up other
    parts of</st> <st c="20860">our agent:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="21022">In this code, we start with importing</st> `<st c="21061">HumanMessage</st>`<st
    c="21073">.</st> `<st c="21075">HumanMessage</st>` <st c="21087">is a specific
    type of message that represents a message sent by the human user.</st> <st c="21168">It
    will used when constructing the prompt for the agent to generate a response.</st>
    <st c="21248">We also import</st> `<st c="21263">BaseModel</st>` <st c="21272">and</st>
    `<st c="21277">Field</st>`<st c="21282">.</st> `<st c="21284">BaseModel</st>`
    <st c="21293">is a class from the</st> `<st c="21314">Pydantic</st>` <st c="21322">library
    that is used to define data models and validate data.</st> `<st c="21385">Field</st>`
    <st c="21390">is a class from</st> `<st c="21407">Pydantic</st>` <st c="21415">that
    is used to define the properties and validation rules for fields in a data model.</st>
    <st c="21503">Last, we import</st> `<st c="21519">tools_condition</st>`<st c="21534">.
    The</st> `<st c="21540">tools_condition</st>` <st c="21555">function is a pre-built
    function provided by the</st> `<st c="21605">LangGraph</st>` <st c="21614">library.</st>
    <st c="21624">It is used to assess the agent’s decision on whether to use specific
    tools based on the current state of</st> <st c="21729">the conversation.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21746">These imported classes and</st> <st c="21774">functions are used
    throughout the code to define the structure of messages, validate data, and control
    the flow of the conversation based on the agent’s decisions.</st> <st c="21938">They
    provide the necessary building blocks and utilities for constructing the language
    model application using the</st> `<st c="22053">LangGraph</st>` <st c="22062">library.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22071">We then define our primary prompt (representing what the user
    would input)</st> <st c="22147">like this:</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="22550">This is a replacement for the code that we were using in the past</st>
    <st c="22617">code labs:</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="22670">We alter the name to</st> `<st c="22692">generation_prompt</st>`
    <st c="22709">to make this prompt’s use</st> <st c="22736">more clear.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22747">Our graph usage is about to pick up in our code, but first, we
    need to cover some basic graph</st> <st c="22842">theory concepts.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22858">Core concepts of graph theory</st>
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="22888">To better understand how we are going to use LangGraph in the
    next few blocks of code, it is helpful to review some key concepts</st> <st c="23017">in</st>
    **<st c="23021">graph theory</st>**<st c="23033">.</st> **<st c="23035">Graphs</st>**
    <st c="23041">are mathematical</st> <st c="23058">structures that can be used
    to represent relationships between different objects.</st> <st c="23141">The objects
    are</st> <st c="23156">called</st> **<st c="23164">nodes</st>** <st c="23169">and
    the relationships between them, typically drawn</st> <st c="23221">with a line,
    are called</st> **<st c="23246">edges</st>**<st c="23251">. You have already seen
    these concepts in</st> *<st c="23293">Figure 12</st>**<st c="23302">.1</st>*<st
    c="23304">, but it is important to understand how they relate to any graph and
    how that is used</st> <st c="23390">in LangGraph.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23403">With LangGraph, there are also specific types of edges representing
    different types of these relationships.</st> <st c="23512">The “conditional edge”
    that we mentioned along with</st> *<st c="23564">Figure 12</st>**<st c="23573">.1</st>*<st
    c="23575">, for example, represents when you need to make a decision about which
    node you should go to next; so, they represent the decisions.</st> <st c="23708">When
    talking about the ReAct paradigm, this has also been called</st> <st c="23772">the</st>
    **<st c="23777">action edge</st>**<st c="23788">, as it is where the action takes
    place, relating to the</st> *<st c="23845">reason + action</st>* <st c="23860">approach
    of ReAct.</st> *<st c="23880">Figure 12</st>**<st c="23889">.3</st>* <st c="23891">shows
    a basic graph consisting of nodes</st> <st c="23932">and edges:</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Basic graph representing our RAG application](img/B22475_12_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: <st c="23955">Figure 12.3 – Basic graph representing our RAG application</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24013">In this cyclical graph shown in</st> *<st c="24046">Figure 12</st>**<st
    c="24055">.3</st>*<st c="24057">, you see nodes representing the start, agent,
    retrieve tool, generation, observation, and end.</st> <st c="24153">The key edges
    are where the LLM makes the decision of what tool to use (retrieve is the only
    one available here), observes if what is retrieved is sufficient, and then pushes
    to generation.</st> <st c="24343">If it is decided that the retrieved data is
    not sufficient, there is an edge that sends the observation back to the agent
    to decide if it wants to try again.</st> <st c="24501">These decision points are
    the</st> *<st c="24531">conditional edges</st>* <st c="24548">we discussed.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24562">Nodes and edges in our agent</st>
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="24591">OK, so let’s</st> <st c="24604">review.</st> <st c="24613">We’ve
    mentioned that an agentic RAG graph has three key components: the</st> *<st c="24685">state</st>*
    <st c="24690">that we already talked about, the</st> *<st c="24725">nodes</st>*
    <st c="24730">that append to or update the</st> <st c="24760">state, and the</st>
    *<st c="24775">conditional edges</st>* <st c="24792">that decide which node to
    visit next.</st> <st c="24831">We are now to the point where we can step through
    each of these in code blocks, seeing how the three components interact with</st>
    <st c="24957">each other.</st>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24968">Given this background, the first thing we will add to the code
    is the conditional edge, where the decisions are made.</st> <st c="25087">In this
    case, we are going to define an edge that determines if the retrieved documents
    are relevant to the question.</st> <st c="25205">This is the function that will
    decide whether to move on to the generation stage or to go back and</st> <st c="25304">try
    again:</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25314">We will step through this code in multiple steps, but keep in
    mind that this is one large function, starting with</st> <st c="25429">the definition:</st>
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="25507">This code starts by defining a function called</st> `<st c="25555">score_documents</st>`
    <st c="25570">that determines whether the retrieved documents are relevant to
    the given question.</st> <st c="25655">The function takes the state we’ve been
    discussing as a parameter, which is a set of messages that have been collected.</st>
    <st c="25775">This is how we make the state</st> `<st c="25805">available</st>`
    <st c="25814">to this conditional</st> <st c="25835">edge function.</st>
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25849">Now, we build the</st> <st c="25868">data model:</st>
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="25977">This defines a data model class called</st> `<st c="26017">scoring</st>`
    <st c="26024">using</st> `<st c="26031">Pydantic</st>`<st c="26039">’s</st> `<st
    c="26043">BaseModel</st>`<st c="26052">. The</st> `<st c="26058">scoring</st>`
    <st c="26065">class has a single field called</st> `<st c="26098">binary_score</st>`<st
    c="26110">, which is a string representing the relevance score as either</st>
    `<st c="26173">yes</st>` <st c="26176">or</st> `<st c="26180">no</st>`<st c="26182">.</st>
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26183">Next, we add the LLM that will make</st> <st c="26220">this decision:</st>
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="26287">This creates an instance of</st> `<st c="26316">llm_with_tool</st>`
    <st c="26329">by calling</st> `<st c="26341">llm.with_structured_output(scoring)</st>`<st
    c="26376">, combining the LLM with the scoring data model for structured</st>
    <st c="26439">output validation.</st>
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26457">As we have</st> <st c="26468">seen in the past, we need to set
    up a</st> `<st c="26507">PromptTemplate</st>` <st c="26521">class to pass to the</st>
    <st c="26543">LLM.</st> <st c="26548">Here is</st> <st c="26556">that prompt:</st>
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="27034">This defines a prompt using the</st> `<st c="27066">PromptTemplate</st>`
    <st c="27080">class, providing instructions to the LLM for applying a binary score
    for the relevance of the retrieved document based on the</st> <st c="27207">given
    question.</st>
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27222">We can then use LCEL to build the chain that combines the prompt
    with the</st> `<st c="27297">llm_with_tool</st>` <st c="27310">tool we just</st>
    <st c="27324">set up:</st>
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="27362">This chain represents the pipeline for scoring the documents.</st>
    <st c="27425">This defines the chain, but we haven’t invoked</st> <st c="27472">it
    yet.</st>
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27479">First, we want to</st> <st c="27498">pull in the state.</st> <st
    c="27517">Next, we pull the state (</st>`<st c="27542">"messages"</st>`<st c="27553">)
    into the</st> <st c="27564">function so that we can use it, and we take the</st>
    <st c="27613">last message:</st>
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="27742">This extracts the necessary information from the</st> `<st c="27792">"state"</st>`
    <st c="27799">parameter and then preps the state/message as the context we are
    going to pass to our agent brain (LLM).</st> <st c="27905">The specific components
    extracted here include</st> <st c="27952">the following:</st>
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="27966">messages</st>`<st c="27975">: The list of messages in</st> <st
    c="28002">the conversation</st>'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="28018">last_message</st>`<st c="28031">: The last message in</st> <st
    c="28054">the conversation</st>'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="28070">question</st>`<st c="28079">: The content of the first message,
    which is assumed to be the</st> <st c="28143">user’s question</st>'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="28158">docs</st>`<st c="28163">: The content of the last message, which
    is assumed to be the</st> <st c="28226">retrieved documents</st>'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="28245">Then, finally, we invoke the chain with the prompt filled (if
    you remember, we call this</st> `<st c="28362">question</st>` <st c="28370">and
    context</st> `<st c="28383">docs</st>` <st c="28387">to get the</st> <st c="28399">scored
    result:</st>
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="28518">This extracts</st> <st c="28532">the</st> `<st c="28537">binary_score</st>`
    <st c="28549">variable from the</st> `<st c="28568">scored_result</st>` <st c="28581">object
    and assigns it to the</st> `<st c="28611">score</st>` <st c="28616">variable.</st>
    <st c="28627">The</st> `<st c="28631">llm_with_tool</st>` <st c="28644">step,
    which</st> <st c="28656">is the last step in the LangChain chain, aptly called</st>
    `<st c="28711">chain</st>`<st c="28716">, is going to return a string-based binary
    result based on the response from the</st> <st c="28797">scoring function:</st>
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="28969">This checks the value of the score.</st> <st c="29006">If the</st>
    `<st c="29013">score</st>` <st c="29018">value is</st> `<st c="29028">yes</st>`<st
    c="29031">, it prints a message indicating that the documents are relevant and
    returns</st> `<st c="29108">generate</st>` <st c="29116">as the final output from
    the</st> `<st c="29146">score_documents</st>` <st c="29161">function, suggesting
    that the next step is to generate a response.</st> <st c="29229">If the</st> `<st
    c="29236">score</st>` <st c="29241">value is</st> `<st c="29251">no</st>`<st c="29253">,
    or, technically, anything other than</st> `<st c="29292">yes</st>`<st c="29295">,
    it prints messages indicating that the documents are not relevant and returns</st>
    `<st c="29375">improve</st>`<st c="29382">, suggesting that the next step is to
    improve the query from</st> <st c="29443">the user.</st>
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29452">Overall, this function acts as a decision point in the workflow,
    determining whether the retrieved documents are relevant to the question and directing
    the flow to either generate a response or rewrite the question based on the</st>
    <st c="29681">relevance score.</st>
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29697">Now that we</st> <st c="29709">have our conditional edge defined,
    we are going to move on to</st> <st c="29772">defining our nodes, starting with</st>
    <st c="29806">the agent:</st>
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="29981">This function represents the agent node on our graph and invokes
    the agent model to generate a response based on the current state.</st> <st c="30114">The</st>
    `<st c="30118">agent</st>` <st c="30123">function takes the current state (</st>`<st
    c="30158">"state"</st>`<st c="30166">) as input, which contains the messages in
    the conversation, prints a message indicating that it is calling the agent, extracts
    the messages from the state dictionary, uses the</st> `<st c="30344">agent_llm</st>`
    <st c="30353">instance of the</st> `<st c="30370">ChatOpenAI</st>` <st c="30380">class
    we defined earlier, representing the agent</st> *<st c="30430">brain</st>*<st
    c="30435">, and then binds the tools to the model using the</st> `<st c="30485">bind_tools</st>`
    <st c="30495">method.</st> <st c="30504">We then invoke the agent’s</st> `<st
    c="30531">llm</st>` <st c="30534">instance with the messages and assign the result
    to the</st> `<st c="30591">response</st>` <st c="30599">variable.</st>
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30609">Our next node,</st> `<st c="30625">improve</st>`<st c="30632">,
    is responsible for transforming</st> `<st c="30666">user_query</st>` <st c="30676">to
    produce a better question if the agent determines this</st> <st c="30735">is needed:</st>
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <st c="31148">This function, like all</st> <st c="31173">of our node and edge-related
    functions, takes the</st> <st c="31222">current state (</st>`<st c="31238">"state"</st>`<st
    c="31246">) as input.</st> <st c="31259">The function returns a dictionary with
    the response appended to the messages list.</st> <st c="31342">The function prints
    a message indicating that it is transforming the query, extracts the messages
    from the state dictionary, retrieves the content of the first message (</st>`<st
    c="31511">messages[0].content</st>`<st c="31531">), which is assumed to be the
    initial question, and assigns it to the</st> `<st c="31602">question</st>` <st
    c="31610">variable.</st> <st c="31621">We then set up a message using the</st>
    `<st c="31656">HumanMessage</st>` <st c="31668">class, indicating that we want
    the</st> `<st c="31704">llm</st>` <st c="31707">instance to reason about the underlying
    semantic intent of the question and formulate an improved question.</st> <st c="31816">The
    result from the</st> `<st c="31836">llm</st>` <st c="31839">instance is assigned
    to the</st> `<st c="31868">response</st>` <st c="31876">variable.</st> <st c="31887">Finally,
    it returns a dictionary with the response appended to the</st> <st c="31954">messages
    list.</st>
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31968">Our next node function is the</st> `<st c="31999">generate</st>`
    <st c="32007">function:</st>
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <st c="32366">This function is</st> <st c="32384">similar to our generation
    step in the previous chapter’s code</st> <st c="32446">labs but simplified to
    provide just the response.</st> <st c="32496">It generates an answer based on
    the retrieved documents and the question.</st> <st c="32570">The function takes
    the current state (</st>`<st c="32608">"state"</st>`<st c="32616">) as input,
    which contains the messages in the conversation, prints a message indicating that
    it is generating an answer, extracts the messages from the state dictionary, retrieves
    the content of the first message (</st>`<st c="32832">messages[0].content</st>`<st
    c="32852">), which is assumed to be the question, and assigns it to the</st> `<st
    c="32915">question</st>` <st c="32923">variable.</st>
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32933">The function then retrieves the last message (</st>`<st c="32980">messages[-1]</st>`<st
    c="32993">) and assigns it to the</st> `<st c="33018">last_message</st>` <st c="33030">variable.</st>
    <st c="33041">The</st> `<st c="33045">docs</st>` <st c="33049">variable is assigned
    the content of</st> `<st c="33086">last_message</st>`<st c="33098">, which is
    assumed to be the retrieved documents.</st> <st c="33148">At this point, we create
    a chain called</st> `<st c="33188">rag_chain</st>` <st c="33197">by combining
    the</st> `<st c="33215">generation_prompt</st>`<st c="33232">,</st> `<st c="33234">llm</st>`<st
    c="33237">, and</st> `<st c="33243">str_output_parser</st>` <st c="33260">variables
    using the</st> `<st c="33281">|</st>` <st c="33282">operator.</st> <st c="33293">As
    with other LLM prompting, we hydrate the predefined</st> `<st c="33348">generation_prompt</st>`
    <st c="33365">as the prompt for generating the answer, which returns a</st> <st
    c="33422">dictionary</st> <st c="33434">with the</st> `<st c="33443">response</st>`
    <st c="33451">variable appended to the</st> `<st c="33477">messages</st>` <st
    c="33485">list.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33491">Next, we want to set up our cyclical graphs using LangGraph and
    assign our nodes and edges</st> <st c="33583">to them.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33591">Cyclical graph setup</st>
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="33612">The next</st> <st c="33622">big step in our code</st> <st c="33643">is
    setting up our graphs</st> <st c="33668">using LangGraph:</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33684">First, we import some important packages to get</st> <st c="33733">us
    started:</st>
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: <st c="33828">This code imports the following necessary classes and functions
    from the</st> `<st c="33902">langgraph</st>` <st c="33911">library:</st>
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="33920">END</st>`<st c="33924">: A special node representing the end
    of</st> <st c="33966">the workflow</st>'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="33978">StateGraph</st>`<st c="33989">: A class for defining the state
    graph of</st> <st c="34032">the workflow</st>'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="34044">ToolNode</st>`<st c="34053">: A class for defining a node that
    represents a tool</st> <st c="34107">or action</st>'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34116">We then pass</st> `<st c="34130">AgentState</st>` <st c="34140">as
    an argument to the</st> `<st c="34163">StateGraph</st>` <st c="34173">class we
    just imported for defining the state graph of</st> <st c="34229">the workflow:</st>
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <st c="34276">This creates a new instance of</st> `<st c="34308">StateGraph</st>`
    <st c="34318">called</st> `<st c="34326">workflow</st>` <st c="34334">and defines
    a new graph for that</st> `<st c="34368">workflow</st>` `<st c="34376">StateGraph</st>`
    <st c="34387">instance.</st>
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34397">Next, we define the nodes we will cycle between and assign our
    node functions</st> <st c="34476">to them:</st>
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: <st c="34820">This code adds</st> <st c="34836">multiple nodes to the</st> `<st
    c="34858">workflow</st>` <st c="34866">instance</st> <st c="34876">using the</st>
    `<st c="34886">add_node</st>` <st c="34894">method:</st>
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="34902">"agent"</st>`<st c="34910">: This node represents the agent
    node, which invokes the</st> <st c="34968">agent function.</st>'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="34983">"retrieve"</st>`<st c="34994">: This node represents the retrieval
    node, which is a special</st> `<st c="35057">ToolNode</st>` <st c="35065">containing
    the tools list we defined early with the</st> `<st c="35118">web_search</st>`
    <st c="35128">and</st> `<st c="35133">retriever_tool</st>` <st c="35147">tools.</st>
    <st c="35155">In this code, to aid in readability, we explicitly break out the</st>
    `<st c="35220">ToolNode</st>` <st c="35228">class instance and define the</st>
    `<st c="35259">retrieve</st>` <st c="35267">variable with it, which indicates
    the “retrieve” focus of this node more explicitly.</st> <st c="35353">We then
    pass that</st> `<st c="35371">retrieve</st>` <st c="35379">variable into the</st>
    `<st c="35398">add_node</st>` <st c="35406">function.</st>'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="35416">"improve"</st>`<st c="35426">: This node represents the node
    for improving the question, which invokes the</st> `<st c="35505">improve</st>`
    <st c="35512">function.</st>'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="35522">"generate"</st>`<st c="35533">: This node represents the node
    for generating a response, which invokes the</st> `<st c="35611">generate</st>`
    <st c="35619">function.</st>'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35629">Next, we need to define our starting point for</st> <st c="35677">our
    workflow:</st>
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: <st c="35724">This sets the entry point of the</st> `<st c="35758">workflow</st>`
    <st c="35766">instance to the</st> `<st c="35783">"agent"</st>` <st c="35790">node</st>
    <st c="35796">using</st> `<st c="35802">workflow.set_entry_point("agent")</st>`<st
    c="35835">.</st>
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35836">Next, we call the</st> `<st c="35855">"agent"</st>` <st c="35862">node
    to decide whether to retrieve</st> <st c="35898">or not:</st>
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '<st c="36000">In this code,</st> `<st c="36014">tools_condition</st>` <st c="36029">is
    used as a conditional edge in the workflow graph.</st> <st c="36083">It determines
    whether the agent should proceed to the retrieval step (</st>`<st c="36153">"tools":
    "retrieve"</st>`<st c="36173">) or end the conversation (</st>`<st c="36201">END:
    END</st>`<st c="36210">) based on the agent’s decision.</st> <st c="36244">The
    retrieval step represents both of the tools that we made available for the agent
    to use where needed, and the other option, to end the conversation simply ends</st>
    <st c="36408">the workflow.</st>'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36421">Here, we add more</st> <st c="36440">edges, which are used</st>
    <st c="36462">after the</st> `<st c="36472">"action"</st>` <st c="36480">node</st>
    <st c="36486">is called:</st>
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: <st c="36629">After the</st> `<st c="36640">"retrieve"</st>` <st c="36650">node
    is called, it adds conditional edges using</st> `<st c="36699">workflow.add_conditional_edges("retrieve",
    score_documents)</st>`<st c="36758">. This assesses the retrieved documents using
    the</st> `<st c="36808">score_documents</st>` <st c="36823">function and determines
    the next node based on the score.</st> <st c="36882">This also adds an edge from
    the</st> `<st c="36914">"generate"</st>` <st c="36924">node to the</st> `<st c="36937">END</st>`
    <st c="36940">node using</st> `<st c="36952">workflow.add_edge("generate", END)</st>`<st
    c="36986">. This indicates that, after generating a response, the workflow ends.</st>
    <st c="37057">Last, this adds an edge from the</st> `<st c="37090">"improve"</st>`
    <st c="37099">node back to the</st> `<st c="37117">"agent"</st>` <st c="37124">node
    using</st> `<st c="37136">workflow.add_edge("improve", "agent")</st>`<st c="37173">.
    This creates a loop where the improved question is sent back to the agent for</st>
    <st c="37253">further processing.</st>
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37272">We are now ready to compile</st> <st c="37301">the graph:</st>
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: <st c="37338">This line compiles the workflow graph using</st> `<st c="37383">workflow.compile</st>`
    <st c="37399">and assigns the compiled graph to the</st> `<st c="37438">graph</st>`
    <st c="37443">variable, which now represents a compiled version of the</st> `<st
    c="37501">StateGraph</st>` <st c="37511">graph instance we</st> <st c="37530">started
    with.</st>
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37543">We have already shown you the visualization of what this graph
    looks like earlier in this chapter in</st> *<st c="37645">Figure 12</st>**<st
    c="37654">.1</st>*<st c="37656">, but if you want to run the visualization yourself,
    you</st> <st c="37713">can use</st> <st c="37721">this code:</st>
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: <st c="37855">We can use</st> `<st c="37867">IPython</st>` <st c="37874">to
    generate</st> <st c="37887">this visualization.</st>
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37906">Last, we are going to finally put our agent</st> <st c="37951">to
    work:</st>
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: <st c="38024">This imports the</st> `<st c="38041">pprint</st>` <st c="38047">module,
    which provides a pretty-print function for formatting and printing data structures,
    allowing us to see a more human-readable version of our agent output.</st> <st
    c="38210">We then define a dictionary called</st> `<st c="38245">inputs</st>`
    <st c="38251">that represents the initial input to the workflow graph.</st> <st
    c="38309">The inputs dictionary contains a</st> `<st c="38342">"messages"</st>`
    <st c="38352">key with a list of tuples.</st> <st c="38380">In this case, it has
    a single tuple,</st> `<st c="38417">("user", user_query)</st>`<st c="38437">,
    where the</st> `<st c="38449">"user"</st>` <st c="38455">string represents the
    role of the message sender (</st>`<st c="38506">user</st>`<st c="38511">) and</st>
    `<st c="38518">user_query</st>` <st c="38528">is the user’s query</st> <st c="38549">or
    question.</st>
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38561">We then initialize an empty string variable called</st> `<st c="38613">final_answer</st>`
    <st c="38625">to store the final answer generated by</st> <st c="38665">the workflow:</st>
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: <st c="38696">We then start our agent</st> <st c="38721">loop using the graph
    instance</st> <st c="38751">as</st> <st c="38754">the basis:</st>
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: <st c="38973">This starts a double loop using the output in</st> `<st c="39020">graph.stream(inputs)</st>`<st
    c="39040">. This iterates over the outputs generated by the</st> `<st c="39090">graph</st>`
    <st c="39095">instance as it processes the inputs.</st> <st c="39133">The</st>
    `<st c="39137">graph.stream(inputs)</st>` <st c="39157">method streams the outputs
    from the</st> `<st c="39194">graph</st>` <st c="39199">instance execution.</st>
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39219">Inside the outer loop, it starts another loop for two variables,</st>
    `<st c="39285">key</st>` <st c="39288">and</st> `<st c="39293">value</st>`<st
    c="39298">, representing the key-value pairs in the</st> `<st c="39340">output.items</st>`
    <st c="39352">variable.</st> <st c="39363">This iterates over each of those key-value
    pairs, where the</st> `<st c="39423">key</st>` <st c="39426">variable represents
    the node name and the</st> `<st c="39469">value</st>` <st c="39474">variable represents
    the output generated by that node.</st> <st c="39530">This will print the node
    name using</st> `<st c="39566">pprint.pprint(f"Output from node '{key}':")</st>`
    <st c="39609">to indicate which node generated</st> <st c="39643">the output.</st>
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39654">The code pretty-prints the value (output) using</st> `<st c="39703">pprint.pprint(value,
    indent=2, width=80, depth=None)</st>`<st c="39755">. The</st> `<st c="39761">indent</st>`
    <st c="39767">parameter specifies the indentation level,</st> `<st c="39811">width</st>`
    <st c="39816">specifies the maximum width of the output, and</st> `<st c="39864">depth</st>`
    <st c="39869">specifies the maximum depth of nested data structures to print (</st>`<st
    c="39934">None</st>` <st c="39939">means</st> <st c="39946">no limit).</st>
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39956">It assigns the value (output) to the</st> `<st c="39994">final_answer</st>`
    <st c="40006">variable, overwriting it in each iteration.</st> <st c="40051">After
    the loop ends,</st> `<st c="40072">final_answer</st>` <st c="40084">will contain
    the output generated by the last node in</st> <st c="40139">the workflow.</st>
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40152">A nice</st> <st c="40160">feature of this code is that it allows
    you to see the</st> <st c="40213">intermediate outputs generated by each node
    in the graph and track the progress of the query processing.</st> <st c="40319">These
    print outputs represent the agent’s “thoughts” as it makes decisions within the
    loop.</st> <st c="40411">The pretty-printing helps in formatting the outputs for</st>
    <st c="40467">better readability.</st>
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40486">When we start the agent and start seeing the output, we can see
    that a lot is</st> <st c="40565">going on!</st>
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40574">I will truncate a lot of the printout, but this will give you
    an idea of what</st> <st c="40653">is provided:</st>
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: <st c="41280">This is the first part of our printout.</st> <st c="41321">Here,
    we see the agent is deciding to use the</st> `<st c="41367">retrieve_google_environmental_question_answers</st>`
    <st c="41413">tool.</st> <st c="41420">If you will recall, that is the text-based
    name we gave to the retriever tool when defining it.</st> <st c="41516">Good choice!</st>
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41528">Next, the agent is going to determine if it thinks the documents
    retrieved</st> <st c="41604">are relevant:</st>
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: <st c="41669">The decision is that they are.</st> <st c="41701">Again, smart
    thinking,</st> <st c="41724">Mr.</st> <st c="41728">Agent.</st>
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41734">Last, we see the</st> <st c="41751">output of what the agent is
    looking at, retrieved from</st> <st c="41806">the PDF document and the ensemble
    retriever we have been using (there was a lot of retrieved data here, so I truncated
    most of the</st> <st c="41938">actual content):</st>
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: <st c="42326">When you look at the actual printout for this portion, you see
    that the retrieved data is concatenated together and provides substantial and
    in-depth data for our agent to</st> <st c="42499">work with.</st>
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42509">At this point, just like our original RAG application was doing,
    the agent takes the question, retrieved data, and formulates a response based
    on the generation</st> <st c="42671">prompt we</st> <st c="42681">gave it:</st>
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: <st c="43146">We included a mechanism here to print out the final message separately</st>
    <st c="43218">for readability:</st>
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: <st c="43262">This will print</st> <st c="43279">this out:</st>
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: <st c="44089">That is the full output of</st> <st c="44117">our agent!</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44127">Summary</st>
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="44135">In this chapter, we explored how AI agents and LangGraph can be
    combined to create more powerful and sophisticated RAG applications.</st> <st
    c="44269">We learned that an AI agent is essentially an LLM with a loop that allows
    it to reason and break tasks down into simpler steps, improving the chances of
    success in complex RAG tasks.</st> <st c="44452">LangGraph, an extension built
    on top of LCEL, provides support for building composable and customizable agentic
    workloads, enabling developers to orchestrate agents using a</st> <st c="44625">graph-based
    approach.</st>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44646">We dove into the fundamentals of AI agents and RAG integration,
    discussing the concept of tools that agents can use to carry out tasks, and how
    LangGraph’s</st> `<st c="44803">AgentState</st>` <st c="44813">class tracks the
    state of the agent over time.</st> <st c="44861">We also covered the core concepts
    of graph theory, including nodes, edges, and conditional edges, which are crucial
    for understanding how</st> <st c="44999">LangGraph works.</st>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45015">In the code lab, we built a LangGraph retrieval agent for our
    RAG application, demonstrating how to create tools, define the agent state, set
    up prompts, and establish the cyclical graphs using LangGraph.</st> <st c="45221">We
    saw how the agent uses its reasoning capabilities to determine which tools to
    use, how to use them, and what data to feed them, ultimately providing a more
    thorough response to the</st> <st c="45405">user’s question.</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码实验室中，我们为我们的RAG应用构建了一个LangGraph检索代理，展示了如何创建工具、定义代理状态、设置提示以及使用LangGraph建立循环图。<st
    c="45221">我们看到了代理如何利用其推理能力来确定使用哪些工具、如何使用它们以及提供什么数据，最终为</st> <st c="45405">用户的问题提供更全面的回答。</st>
- en: <st c="45421">Looking ahead, the next chapter will focus on how prompt engineering
    can be used to improve</st> <st c="45514">RAG applications.</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一章将重点介绍如何使用提示工程来改进<st c="45421">RAG应用</st>。
