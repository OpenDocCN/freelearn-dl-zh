<html><head></head><body>
  <div id="_idContainer062">
   <h1 class="chapter-number" id="_idParaDest-105">
    <a id="_idTextAnchor114">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-106">
    <a id="_idTextAnchor115">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Enabling Tool Use and Planning in Agents
    </span>
   </h1>
   <p>
    <a id="_idTextAnchor116">
    </a>
    <span class="koboSpan" id="kobo.3.1">
     In the previous chapter, we looked into the intricate concepts of reflection and introspection in intelligent agents.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     These capabilities empower agents to reason about their own cognitive processes, learn from experiences, and dynamically modify
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      their behaviors.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     A significant step forward in AI agents comes from combining how agents plan and use tools.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     This chapter looks at how tools work, different planning algorithms, how they fit together, and real examples showing how useful they are in practice.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     We will explore the concept of tool use by intelligent agents that extend their capabilities beyond decision-making and problem-solving.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     We will look at different types of tools that agents can utilize, such as APIs, databases, and software functions.
    </span>
    <span class="koboSpan" id="kobo.5.5">
     We will then delve into planning algorithms essential for agents, including state-space search, reinforcement learning, and hierarchical task network planning.
    </span>
    <span class="koboSpan" id="kobo.5.6">
     We will discuss integrating tool use and planning by reasoning about available tools, assessing their suitability based on goals, selecting appropriate tools, and generating efficient action sequences that leverage
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      those tools.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     This chapter is divided into the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      main sections:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Understanding the concept of tool use
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       in agents
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Planning algorithms
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       for agents
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      Integrating tool use
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       and planning
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      Exploring
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       practical implementations
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.17.1">
     By the end of this chapter, you will know what tools are, how they can be used to power your agentic systems, and how they work in conjunction with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.18.1">
      planning algorithms.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-107">
    <a id="_idTextAnchor117">
    </a>
    <span class="koboSpan" id="kobo.19.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     You can find the code file for this chapter on GitHub at
    </span>
    <a href="https://github.com/PacktPublishing/Building-Agentic-AI-Systems">
     <span class="koboSpan" id="kobo.21.1">
      https://github.com/PacktPublishing/Building-Agentic-AI-Systems
     </span>
    </a>
    <span class="koboSpan" id="kobo.22.1">
     .
    </span>
    <span class="koboSpan" id="kobo.22.2">
     In this chapter, we will also use agentic Python frameworks such as CrewAI, AutoGen, and LangChain to demonstrate the various aspects of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.23.1">
      AI agents.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-108">
    <a id="_idTextAnchor118">
    </a>
    <span class="koboSpan" id="kobo.24.1">
     Understanding the concept of tool use in agents
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.25.1">
     At its core, tool usage by an intelligent agent refers to the LLM agent’s capability of leveraging external resources or instrumentation to augment the agent’s inherent functionality
    </span>
    <a id="_idIndexMarker346">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     and decision-making processes.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     This concept extends beyond the traditional notion of an agent as a self-contained (isolated) entity, relying solely on its internal knowledge (training data) and algorithms.
    </span>
    <span class="koboSpan" id="kobo.26.3">
     Instead, it acknowledges the potential for agents to transcend their intrinsic limitations by strategically harnessing the power of external tools
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      and systems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     For example, when you send a query (“
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.29.1">
      What’s the weather?
     </span>
    </em>
    <span class="koboSpan" id="kobo.30.1">
     ”) to an agent in isolation, the model is free to either respond with any made-up answer or it may respond that it doesn’t know how to find the weather.
    </span>
    <span class="koboSpan" id="kobo.30.2">
     In this case, the agent will rely on the LLM’s training data, which will not have up-to-date information about real-time weather data.
    </span>
    <span class="koboSpan" id="kobo.30.3">
     On the other hand, if the LLM agent has access to a real-time weather lookup tool, it may be able to answer the question accurately.
    </span>
    <span class="koboSpan" id="kobo.30.4">
     Tool usage enables agents to access real-time data, execute specialized tasks, and manage complex workflows that go beyond their built-in knowledge and algorithms.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.31.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.32.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.33.1">
     shows this isolated versus
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.34.1">
      tool-powered behavior:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer055">
     <span class="koboSpan" id="kobo.35.1">
      <img alt="img" role="presentation" src="image/B31483_05_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.36.1">
     Figure 5.1 – Agent behavior in isolation versus with access to a tool
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     The significance of tool use lies in its ability to broaden the scope of an agent’s (and, in turn, the LLM that powers the agent’s) competencies, enabling it to tackle complex, real-world
    </span>
    <a id="_idIndexMarker347">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     challenges that may be beyond the reach of its native problem-solving capabilities.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     By integrating and orchestrating the use of various tools, an agent can effectively offload specific tasks or access supplementary data and functionalities, thereby enhancing its overall performance and expanding its scope of achievable objectives.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     Before we go into the details of tools, let’s first understand how LLM tool
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      calling works.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor119">
    </a>
    <span class="koboSpan" id="kobo.40.1">
     Tool and function calling
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     While
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.42.1">
      tool calling
     </span>
    </em>
    <span class="koboSpan" id="kobo.43.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.44.1">
      function calling
     </span>
    </em>
    <span class="koboSpan" id="kobo.45.1">
     are often
    </span>
    <a id="_idIndexMarker348">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     used interchangeably
    </span>
    <a id="_idIndexMarker349">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     in the context of LLMs, they have distinct technical differences.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.48.1">
      Function calling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     refers to an LLM generating structured calls to predefined
    </span>
    <a id="_idIndexMarker350">
    </a>
    <span class="koboSpan" id="kobo.50.1">
     functions within the same runtime, typically executing internal tasks such as database lookups or calculations.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.51.1">
      Tool calling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.52.1">
     , on the
    </span>
    <a id="_idIndexMarker351">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     other hand, enables LLMs to interact with external APIs, services, or systems, allowing them to access real-time data and perform specialized tasks beyond their intrinsic capabilities.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     For example, an LLM using function calling might retrieve a user’s profile from a local database, while tool calling would involve querying a weather API for live updates.
    </span>
    <span class="koboSpan" id="kobo.53.3">
     Understanding this distinction is crucial for designing AI agents that seamlessly integrate internal logic with external systems to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      enhance functionality.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     When an LLM invokes a tool or function, it doesn’t actually execute any code.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     Instead, it generates a structured response indicating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.57.1">
      Which tool/function it wants
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.58.1">
       to use
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.59.1">
      What parameters should be passed to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.60.1">
       that tool/function
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.61.1">
      How those parameters should
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.62.1">
       be formatted
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.63.1">
     Think of it like writing a detailed instruction rather than performing the action itself.
    </span>
    <span class="koboSpan" id="kobo.63.2">
     The LLM acts as a
    </span>
    <a id="_idIndexMarker352">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     sophisticated dispatcher, determining what needs to
    </span>
    <a id="_idIndexMarker353">
    </a>
    <span class="koboSpan" id="kobo.65.1">
     be done and how, but the actual execution of the tool or
    </span>
    <a id="_idIndexMarker354">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     function must be handled by an external runtime environment
    </span>
    <a id="_idIndexMarker355">
    </a>
    <span class="koboSpan" id="kobo.67.1">
     or an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.68.1">
      Agent Controller
     </span>
    </em>
    <span class="koboSpan" id="kobo.69.1">
     .
    </span>
    <span class="koboSpan" id="kobo.69.2">
     For example, when asked about the weather in Boston, an LLM might recognize the need for the weather lookup function and respond with a structured call such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.71.1">
{
    "function": "weather_lookup",
    "parameters": {
        "location": "Boston",
        "date": "10/01/2024"
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     This structured response is then interpreted and executed by the Agent Controller that actually
    </span>
    <a id="_idIndexMarker356">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     has the capability to run the specified function with the provided parameters.
    </span>
    <span class="koboSpan" id="kobo.73.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.74.1">
      weather_lookup
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     tool (or function) may look something
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.77.1">
1 import requests
2
3 def weather_lookup(location: str, date: str) -&gt; dict:
4    """A function to lookup weather data that takes location and date
     as input"""
5    API_KEY = "api_key"
6    base_url = "&lt;api URL&gt;"
7
8    params = {
9        "q": location,
10        "appid": API_KEY,
11       "units": "imperial"  # For Fahrenheit
12  }
13  response = requests.get(base_url, params=params)
14  if response.status_code == 200:
15      data = response.json()
16      return data</span></pre>
   <p>
    <span class="koboSpan" id="kobo.78.1">
     At the
    </span>
    <a id="_idIndexMarker357">
    </a>
    <span class="koboSpan" id="kobo.79.1">
     minimum, the LLM agent requires the tool’s description
    </span>
    <a id="_idIndexMarker358">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     of what the tool does and what input it expects.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     You
    </span>
    <a id="_idIndexMarker359">
    </a>
    <span class="koboSpan" id="kobo.81.1">
     can also specify which parameters (in this case,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      location
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.84.1">
      date
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     ) are
    </span>
    <a id="_idIndexMarker360">
    </a>
    <span class="koboSpan" id="kobo.86.1">
     mandatory and which ones are optional.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.87.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.88.1">
      .2
     </span>
    </em>
    <span class="koboSpan" id="kobo.89.1">
     demonstrates the flow between an LLM agent, tool, and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      Agent Controller:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer056">
     <span class="koboSpan" id="kobo.91.1">
      <img alt="img" role="presentation" src="image/B31483_05_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.92.1">
     Figure 5.2 – LLM agent tool calling and tool execution by the Agent Controller
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.93.1">
     It is worth
    </span>
    <a id="_idIndexMarker361">
    </a>
    <span class="koboSpan" id="kobo.94.1">
     noting that not all LLMs are capable or efficient (or rather accurate) in tool/function
    </span>
    <a id="_idIndexMarker362">
    </a>
    <span class="koboSpan" id="kobo.95.1">
     calling.
    </span>
    <span class="koboSpan" id="kobo.95.2">
     While larger models are more capable
    </span>
    <a id="_idIndexMarker363">
    </a>
    <span class="koboSpan" id="kobo.96.1">
     of tool calling, some larger models (such as OpenAI’s
    </span>
    <a id="_idIndexMarker364">
    </a>
    <span class="koboSpan" id="kobo.97.1">
     GPT-4 and -4o, Anthropic’s Claude Sonnet, Haiku, Opus, and Meta’s Llama 3 models) are explicitly trained for tool calling behavior.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     While other models are not explicitly trained on tool calling, they may still be able to achieve similar functionality with aggressive prompt engineering, but with varying degrees
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      of success.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-110">
    <a id="_idTextAnchor120">
    </a>
    <span class="koboSpan" id="kobo.99.1">
     Defining tools for agents
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.100.1">
     Tools are
    </span>
    <a id="_idIndexMarker365">
    </a>
    <span class="koboSpan" id="kobo.101.1">
     defined with clear descriptions, typically using
    </span>
    <a id="_idIndexMarker366">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     docstrings or a JSON schema, to communicate their purpose, required inputs, and expected outputs to the agent.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     There are two main approaches to defining tools, depending on whether you’re using a framework or working directly with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      LLM APIs.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.104.1">
     Framework approach – using docstrings
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     In frameworks such as CrewAI or LangGraph, tools are defined using docstrings – descriptive
    </span>
    <a id="_idIndexMarker367">
    </a>
    <span class="koboSpan" id="kobo.106.1">
     text that appears at the beginning of
    </span>
    <a id="_idIndexMarker368">
    </a>
    <span class="koboSpan" id="kobo.107.1">
     a function.
    </span>
    <span class="koboSpan" id="kobo.107.2">
     Here’s an example of a weather
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      lookup tool:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.109.1">
1 def weather_lookup(location: str, date: str = None):
2     """
3     A tool that can lookup real-time weather data.
</span><span class="koboSpan" id="kobo.109.2">4     Arguments:
5       location (str): The location to lookup weather for
6       date (str) Optional: The date in MM/DD/YYYY format
7     """
8    # function code and logic</span></pre>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     The docstring, enclosed within triple quotes (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      """
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     ), provides crucial information about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.114.1">
      The
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.115.1">
       tool’s purpose
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.116.1">
      Required and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.117.1">
       optional arguments
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.118.1">
      Expected
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.119.1">
       return values
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.120.1">
     This approach makes tool creation intuitive for developers, as it uses standard programming practices.
    </span>
    <span class="koboSpan" id="kobo.120.2">
     While Python uses triple quotes for docstrings, other programming languages may have different conventions for defining
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.121.1">
      such documentation.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.122.1">
     Direct LLM integration
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.123.1">
     When working
    </span>
    <a id="_idIndexMarker369">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     directly with LLM APIs (such as Anthropic’s Claude or OpenAI’s GPT) without a framework, tools must be defined using a specific JSON
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      schema format:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.126.1">
{
  "name": "weather_lookup",
  "description": "A tool that can lookup real-time weather data",
  "input_schema": {
     "type": "object",
     "properties": {
        "location": {
          "type": "string",
          "description": "The city and state, e.g. </span><span class="koboSpan" id="kobo.126.2">San Francisco, CA"
         }
       },
       "required": ["location"]
   }
 }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     Multiple tools
    </span>
    <a id="_idIndexMarker370">
    </a>
    <span class="koboSpan" id="kobo.128.1">
     can be used as a list (or array) of JSON schema objects with the tool definition when invoking the model, such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.130.1">
tools = [
 { "name": "weather_lookup",
   "description": "A tool that can check weather data",
   … },
 {
  "name": "flight_booking",
  "description": "A tool that can book flights",
   … },
 …
]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.131.1">
     Note that this is model-dependent, so you must refer to the model’s documentation to learn more about how its APIs require you to specify tools.
    </span>
    <span class="koboSpan" id="kobo.131.2">
     If your project uses multiple models that have different ways of defining tools, then it can quickly become cumbersome
    </span>
    <a id="_idIndexMarker371">
    </a>
    <span class="koboSpan" id="kobo.132.1">
     to define, manage, and maintain tool definitions.
    </span>
    <span class="koboSpan" id="kobo.132.2">
     This is one of the reasons why there is an increase in affinity toward using libraries or frameworks such as CrewAI, LangGraph, and AutoGen, which provide a simplified way of defining tools regardless of the LLM being used for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.133.1">
      the agents.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-111">
    <a id="_idTextAnchor121">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     Types of tools
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.135.1">
     LLM agents
    </span>
    <a id="_idIndexMarker372">
    </a>
    <span class="koboSpan" id="kobo.136.1">
     can leverage various types of toolkits to enhance
    </span>
    <a id="_idIndexMarker373">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     their capabilities and perform complex tasks.
    </span>
    <span class="koboSpan" id="kobo.137.2">
     Here are the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      main categories:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.139.1">
       Application programming interfaces
      </span>
     </strong>
     <span class="koboSpan" id="kobo.140.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.141.1">
       APIs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.142.1">
      ): APIs serve as the primary gateway
     </span>
     <a id="_idIndexMarker374">
     </a>
     <span class="koboSpan" id="kobo.143.1">
      for agents to
     </span>
     <a id="_idIndexMarker375">
     </a>
     <span class="koboSpan" id="kobo.144.1">
      access external services and data in real time.
     </span>
     <span class="koboSpan" id="kobo.144.2">
      They provide standardized methods for interacting with third-party systems, enabling agents to seamlessly integrate with various services.
     </span>
     <span class="koboSpan" id="kobo.144.3">
      For instance, in a travel planning context, APIs allow agents to access weather services, payment processing systems, navigation and mapping services, and flight and hotel booking systems.
     </span>
     <span class="koboSpan" id="kobo.144.4">
      This real-time connectivity ensures agents can provide up-to-date information and services
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.145.1">
       to users.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.146.1">
       Database tools
      </span>
     </strong>
     <span class="koboSpan" id="kobo.147.1">
      : Database
     </span>
     <a id="_idIndexMarker376">
     </a>
     <span class="koboSpan" id="kobo.148.1">
      tools enable agents to
     </span>
     <a id="_idIndexMarker377">
     </a>
     <span class="koboSpan" id="kobo.149.1">
      store, retrieve, and manage structured (or semi-structured) data efficiently.
     </span>
     <span class="koboSpan" id="kobo.149.2">
      These tools support both reading and writing operations, allowing agents to maintain persistent information across sessions.
     </span>
     <span class="koboSpan" id="kobo.149.3">
      Agents commonly use databases to store customer profiles and preferences, maintain historical transaction records, manage product catalogs, and access domain-specific knowledge bases.
     </span>
     <span class="koboSpan" id="kobo.149.4">
      This persistent storage capability enables agents to learn from past interactions and provide
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.150.1">
       personalized services.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.151.1">
       Utility functions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.152.1">
      : Utility functions are custom software components designed for specialized
     </span>
     <a id="_idIndexMarker378">
     </a>
     <span class="koboSpan" id="kobo.153.1">
      tasks that run locally within the agent’s
     </span>
     <a id="_idIndexMarker379">
     </a>
     <span class="koboSpan" id="kobo.154.1">
      environment.
     </span>
     <span class="koboSpan" id="kobo.154.2">
      These functions handle essential operations such as data processing and analysis, format conversion, mathematical calculations, and natural language processing tasks.
     </span>
     <span class="koboSpan" id="kobo.154.3">
      They serve as the building blocks for more complex operations and help agents process information efficiently.
     </span>
     <span class="koboSpan" id="kobo.154.4">
      Utility functions are particularly valuable for tasks that require consistent,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.155.1">
       repeatable operations.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.156.1">
       Integration tools
      </span>
     </strong>
     <span class="koboSpan" id="kobo.157.1">
      : Integration
     </span>
     <a id="_idIndexMarker380">
     </a>
     <span class="koboSpan" id="kobo.158.1">
      tools specialize
     </span>
     <a id="_idIndexMarker381">
     </a>
     <span class="koboSpan" id="kobo.159.1">
      in connecting different systems and services, enabling seamless workflow automation.
     </span>
     <span class="koboSpan" id="kobo.159.2">
      These tools handle crucial tasks such as calendar synchronization, document processing, file management, and communication systems integration.
     </span>
     <span class="koboSpan" id="kobo.159.3">
      They act as bridges between different platforms and services, allowing agents to orchestrate complex workflows that span multiple systems and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.160.1">
       data sources.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.161.1">
       Hardware interface tools
      </span>
     </strong>
     <span class="koboSpan" id="kobo.162.1">
      : Hardware interface tools enable agents to interact with
     </span>
     <a id="_idIndexMarker382">
     </a>
     <span class="koboSpan" id="kobo.163.1">
      physical devices and systems, bridging the
     </span>
     <a id="_idIndexMarker383">
     </a>
     <span class="koboSpan" id="kobo.164.1">
      gap between digital and physical worlds.
     </span>
     <span class="koboSpan" id="kobo.164.2">
      These tools are essential for controlling IoT devices, integrating with robotics systems, processing sensor data, and managing physical automation systems.
     </span>
     <span class="koboSpan" id="kobo.164.3">
      Through hardware interface tools, agents can extend their influence beyond digital interactions to affect real-world changes and monitor
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.165.1">
       physical environments.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.166.1">
     Each tool type
    </span>
    <a id="_idIndexMarker384">
    </a>
    <span class="koboSpan" id="kobo.167.1">
     serves specific purposes and can be combined
    </span>
    <a id="_idIndexMarker385">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     to create powerful agent capabilities.
    </span>
    <span class="koboSpan" id="kobo.168.2">
     The choice of tools depends on the agent’s role, requirements, and the complexity of tasks it needs
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      to perform.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.170.1">
     Understanding how agents work with these tools involves the following several key considerations that affect their effectiveness and reliability.
    </span>
    <span class="koboSpan" id="kobo.170.2">
     These aspects are crucial for developing robust agent systems that can handle complex real-world tasks while maintaining security, handling errors gracefully, and adapting to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      changing requirements:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.172.1">
       Tool composition and chaining
      </span>
     </strong>
     <span class="koboSpan" id="kobo.173.1">
      : Agents often need to combine multiple tools
     </span>
     <a id="_idIndexMarker386">
     </a>
     <span class="koboSpan" id="kobo.174.1">
      to accomplish complex tasks.
     </span>
     <span class="koboSpan" id="kobo.174.2">
      Tool composition allows agents to create sophisticated workflows by chaining tools together.
     </span>
     <span class="koboSpan" id="kobo.174.3">
      For example, a travel planning agent might first use an API to check flight availability, then a database tool to retrieve user preferences, and, finally, a utility function to calculate optimal itineraries.
     </span>
     <span class="koboSpan" id="kobo.174.4">
      This chaining capability significantly extends what agents can accomplish beyond using tools
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.175.1">
       in isolation.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.176.1">
       Tool selection and decision-making
      </span>
     </strong>
     <span class="koboSpan" id="kobo.177.1">
      : One of the most critical aspects of tool
     </span>
     <a id="_idIndexMarker387">
     </a>
     <span class="koboSpan" id="kobo.178.1">
      usage is the agent’s ability to select the appropriate tool for a given task.
     </span>
     <span class="koboSpan" id="kobo.178.2">
      Agents must evaluate the context, understand the requirements, and choose the most suitable tool or combination of tools.
     </span>
     <span class="koboSpan" id="kobo.178.3">
      This involves considering factors such as tool capabilities, reliability, performance, and cost.
     </span>
     <span class="koboSpan" id="kobo.178.4">
      The agent must also handle cases where multiple tools could solve the same problem, selecting the most
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.179.1">
       efficient option.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.180.1">
       Error handling and fallbacks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.181.1">
      : When working with tools, agents must be prepared
     </span>
     <a id="_idIndexMarker388">
     </a>
     <span class="koboSpan" id="kobo.182.1">
      for potential failures and have strategies to handle them.
     </span>
     <span class="koboSpan" id="kobo.182.2">
      This includes detecting failed API calls, managing database connection issues, or handling incorrect function outputs.
     </span>
     <span class="koboSpan" id="kobo.182.3">
      Robust error handling often involves implementing fallback mechanisms, where agents can switch to alternative tools or approaches if the primary
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.183.1">
       method fails.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.184.1">
       Tool state management
      </span>
     </strong>
     <span class="koboSpan" id="kobo.185.1">
      : Many tools maintain state or require specific initialization
     </span>
     <a id="_idIndexMarker389">
     </a>
     <span class="koboSpan" id="kobo.186.1">
      and cleanup procedures.
     </span>
     <span class="koboSpan" id="kobo.186.2">
      Agents need to manage these tool states effectively, ensuring proper resource allocation and release.
     </span>
     <span class="koboSpan" id="kobo.186.3">
      This includes managing database connections, maintaining API authentication tokens, and handling session states for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.187.1">
       various services.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.188.1">
       Tool updates and versioning
      </span>
     </strong>
     <span class="koboSpan" id="kobo.189.1">
      : Tools evolve over time with new versions and capabilities.
     </span>
     <span class="koboSpan" id="kobo.189.2">
      Agents
     </span>
     <a id="_idIndexMarker390">
     </a>
     <span class="koboSpan" id="kobo.190.1">
      need strategies to handle tool updates, version compatibility, and deprecated features.
     </span>
     <span class="koboSpan" id="kobo.190.2">
      This might involve maintaining compatibility with multiple versions of a tool, gracefully handling deprecated features, and adapting to new
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.191.1">
       tool interfaces.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.192.1">
       Tool security and access control
      </span>
     </strong>
     <span class="koboSpan" id="kobo.193.1">
      : Security considerations are crucial when agents
     </span>
     <a id="_idIndexMarker391">
     </a>
     <span class="koboSpan" id="kobo.194.1">
      interact with tools, especially those accessing sensitive data or critical systems.
     </span>
     <span class="koboSpan" id="kobo.194.2">
      This includes managing authentication credentials, implementing proper authorization checks, and ensuring secure communication channels.
     </span>
     <span class="koboSpan" id="kobo.194.3">
      Agents must also respect rate limits and usage quotas imposed by
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.195.1">
       various tools.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.196.1">
     Consider a
    </span>
    <a id="_idIndexMarker392">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     practical example of interaction between a user and
    </span>
    <a id="_idIndexMarker393">
    </a>
    <span class="koboSpan" id="kobo.198.1">
     our AI travel agent using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.199.1">
      tools effectively.
     </span>
    </span>
   </p>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.200.1">
      User
     </span>
    </em>
    <span class="koboSpan" id="kobo.201.1">
     : “I need flight and hotel options for Rome for 2 adults, June 15–22, 2024, with a total budget
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.202.1">
      of $3,000.”
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.203.1">
     Using the CrewAI framework in the following code snippet, we will demonstrate how agents use tools in this focused travel
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      planning scenario:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.205.1">
1 class TravelTools:
2   def search_flights(self, ...) 6 -&gt; dict:
     """Basic flight search simulation"""
3    return {
4     "flights": [ {"airline": "Alitalian airlines",
5                   "price": 800, "duration": "9h"}]
6      }
7
8  def check_hotels(self, ...) -&gt; dict:
9      """Basic hotel search simulation"""
10      return {
11          "hotels": [ {"name": "Roma Inn",
12                       "price": 150, "rating": 4.0}]
13      }
14
15 travel_agent = Agent(
16    role='Travel Agent',
17    goal='Find suitable flight and hotel options within
            budget',
18  tools=[TravelTools().search_flights,
19         TravelTools().check_hotels]
20  )
21
22 search_task = Task(
23    description="Find flights and hotels for 2 adults to
                  Rome, June 15-22, budget $3000",
24    agent=travel_agent )
25
26 crew = Crew(agents=[travel_agent], tasks=[search_task])
27 result = crew.kickoff()</span></pre>
   <p>
    <span class="koboSpan" id="kobo.206.1">
     In this example, we can see several key concepts
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      in action:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.208.1">
       Tool definition
      </span>
     </strong>
     <span class="koboSpan" id="kobo.209.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.210.1">
       TravelTools
      </span>
     </strong>
     <span class="koboSpan" id="kobo.211.1">
      class
     </span>
     <a id="_idIndexMarker394">
     </a>
     <span class="koboSpan" id="kobo.212.1">
      implements focused tools for specific
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.213.1">
       travel-related tasks
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.214.1">
       Agent configuration
      </span>
     </strong>
     <span class="koboSpan" id="kobo.215.1">
      : The
     </span>
     <a id="_idIndexMarker395">
     </a>
     <span class="koboSpan" id="kobo.216.1">
      travel agent is configured with appropriate tools and a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.217.1">
       clear goal
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.218.1">
       Task specification
      </span>
     </strong>
     <span class="koboSpan" id="kobo.219.1">
      : The
     </span>
     <a id="_idIndexMarker396">
     </a>
     <span class="koboSpan" id="kobo.220.1">
      task is defined with precise parameters for the agent to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.221.1">
       work with
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.222.1">
       Tool integration
      </span>
     </strong>
     <span class="koboSpan" id="kobo.223.1">
      : The
     </span>
     <a id="_idIndexMarker397">
     </a>
     <span class="koboSpan" id="kobo.224.1">
      agent seamlessly integrates multiple tools (flight and hotel search) to accomplish
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.225.1">
       its task
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.226.1">
       Execution flow
      </span>
     </strong>
     <span class="koboSpan" id="kobo.227.1">
      : The
     </span>
     <a id="_idIndexMarker398">
     </a>
     <span class="koboSpan" id="kobo.228.1">
      CrewAI framework manages the overall execution and coordination of the agent and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.229.1">
       its tools
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.230.1">
     This streamlined implementation demonstrates how agents can effectively use tools while maintaining clarity and purpose in their operations.
    </span>
    <span class="koboSpan" id="kobo.230.2">
     In our example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      TravelTools
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     class uses simplified JSON responses for clarity.
    </span>
    <span class="koboSpan" id="kobo.232.2">
     However, in a real-world implementation, these tools would interact with actual external services and handle much more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      complex data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     Note that
    </span>
    <a id="_idIndexMarker399">
    </a>
    <span class="koboSpan" id="kobo.235.1">
     this is a rather simple implementation, and the actual implementation would involve integrating with various APIs, databases, and software tools specific
    </span>
    <a id="_idIndexMarker400">
    </a>
    <span class="koboSpan" id="kobo.236.1">
     to the travel domain.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     Additionally, advanced AI planning algorithms could be employed to optimize the itinerary construction and activity planning steps.
    </span>
    <span class="koboSpan" id="kobo.236.3">
     This comprehensive tool usage allows the AI travel agent to provide a seamless, end-to-end, trip-planning experience far beyond just searching flights and hotels.
    </span>
    <span class="koboSpan" id="kobo.236.4">
     You can find the full code in the Python notebook (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.237.1">
      Chapter_05.ipynb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.238.1">
     ) in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-112">
    <a id="_idTextAnchor122">
    </a>
    <span class="koboSpan" id="kobo.240.1">
     The significance of tools in agentic systems
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     The paradigm shift toward tool use is driven by the recognition that many complex problems
    </span>
    <a id="_idIndexMarker401">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     demand a diverse array of specialized tools and resources, each contributing a unique set of capabilities.
    </span>
    <span class="koboSpan" id="kobo.242.2">
     Rather than attempting to encapsulate all requisite knowledge and functionalities within the agent itself, a more efficient and scalable approach involves intelligently leveraging the appropriate tools
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.243.1">
      as needed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.244.1">
     For instance, an agent tasked with providing personalized healthcare recommendations could exploit tools such as medical databases, clinical decision support systems, and advanced diagnostic algorithms.
    </span>
    <span class="koboSpan" id="kobo.244.2">
     By judiciously combining these external resources with its own reasoning capabilities, the agent can deliver more accurate and comprehensive guidance, tailored to individual patient profiles
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      and conditions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.246.1">
     The concept of tool use in intelligent agents is not limited to software-based tools alone.
    </span>
    <span class="koboSpan" id="kobo.246.2">
     In certain domains, such as robotics and automation, agents may interact with physical tools, machinery, or specialized equipment to extend their capabilities into the physical realm.
    </span>
    <span class="koboSpan" id="kobo.246.3">
     For example, a robotic agent in a manufacturing plant could leverage various tools and machinery to perform intricate assembly tasks, quality inspections, or material
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      handling operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.248.1">
     Ultimately, the ability to effectively utilize external tools and resources is a hallmark of truly intelligent agents, capable of adapting and thriving in dynamic, complex environments.
    </span>
    <span class="koboSpan" id="kobo.248.2">
     By going beyond the limitations of their native capabilities, these agents can continually evolve, leveraging the collective power of diverse tools and systems to achieve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      ambitious objectives.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.250.1">
     Another good
    </span>
    <a id="_idIndexMarker402">
    </a>
    <span class="koboSpan" id="kobo.251.1">
     example is that of a virtual travel agent that has the capability to access multiple APIs, databases, and software tools to plan and book complete travel itineraries for users.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     Such a travel agent could leverage APIs from airlines, hotels, rental car companies, and travel review sites to gather real-time data on flight schedules, availability, pricing, and customer ratings.
    </span>
    <span class="koboSpan" id="kobo.251.3">
     It could also tap into databases of travel advisories, travel document requirements, and destination information.
    </span>
    <span class="koboSpan" id="kobo.251.4">
     By integrating and reasoning over all this data from various tools, the agent can provide personalized recommendations, make intelligent trade-offs, and seamlessly book and coordinate all aspects of a trip tailored to the user’s preferences and constraints.
    </span>
    <span class="koboSpan" id="kobo.251.5">
     Naturally, the set of tools used in such a case is diverse and they all operate in their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      unique ways.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     We’ve looked at what tools are and how they work.
    </span>
    <span class="koboSpan" id="kobo.253.2">
     Next, we will explore another critical aspect of agentic systems – planning – and some of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      planning algorithms.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-113">
    <a id="_idTextAnchor123">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     Planning algorithms for agents
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     Planning is a fundamental capability of intelligent agents, enabling them to reason about their actions
    </span>
    <a id="_idIndexMarker403">
    </a>
    <span class="koboSpan" id="kobo.257.1">
     and devise strategies to achieve their objectives effectively.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     Planning algorithms form the backbone of how LLM agents determine and sequence their actions.
    </span>
    <span class="koboSpan" id="kobo.257.3">
     An algorithm is a step-by-step set of instructions or rules designed to solve a specific problem or complete a task.
    </span>
    <span class="koboSpan" id="kobo.257.4">
     It is a sequence of unambiguous and finite steps that takes inputs and produces an expected output in a finite amount
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      of time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     There are several planning algorithms in AI, each with its own strengths and approaches.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     However, when working with LLM agents, we need to consider their practicality in handling natural language, uncertainty, and large state spaces (all possible situations or configurations that an agent might encounter during its task).
    </span>
    <span class="koboSpan" id="kobo.259.3">
     For example, in a simple robot navigation task, state spaces might include all possible positions and orientations, but in
    </span>
    <a id="_idIndexMarker404">
    </a>
    <span class="koboSpan" id="kobo.260.1">
     LLM agents, state spaces
    </span>
    <a id="_idIndexMarker405">
    </a>
    <span class="koboSpan" id="kobo.261.1">
     become vastly more complex as they include
    </span>
    <a id="_idIndexMarker406">
    </a>
    <span class="koboSpan" id="kobo.262.1">
     all possible conversation states, knowledge
    </span>
    <a id="_idIndexMarker407">
    </a>
    <span class="koboSpan" id="kobo.263.1">
     contexts, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      potential responses.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     Among
    </span>
    <a id="_idIndexMarker408">
    </a>
    <span class="koboSpan" id="kobo.266.1">
     the known planning algorithms –
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.267.1">
      Stanford Research Institute Problem Solver
     </span>
    </strong>
    <span class="koboSpan" id="kobo.268.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.269.1">
      STRIPS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.270.1">
     ),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.271.1">
      hierarchical task network
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.273.1">
      HTN
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     ),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.275.1">
      A* planning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.277.1">
      Monte Carlo Tree Search
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.279.1">
      MCTS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     ),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.281.1">
      GraphPlan
     </span>
    </strong>
    <span class="koboSpan" id="kobo.282.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.283.1">
      Fast Forward
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.285.1">
      FF
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     ), and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.287.1">
      LLM-based planning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     – they
    </span>
    <a id="_idIndexMarker409">
    </a>
    <span class="koboSpan" id="kobo.289.1">
     can be categorized by their
    </span>
    <a id="_idIndexMarker410">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     practicality for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.291.1">
      LLM agents.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.292.1">
     STRIPS, A* planning, GraphPlan, and MCTS, while powerful in traditional AI, are less practical for LLM
    </span>
    <a id="_idIndexMarker411">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     agents due to their rigid structure and difficulty handling natural language.
    </span>
    <span class="koboSpan" id="kobo.293.2">
     FF shows moderate potential but requires significant adaptation.
    </span>
    <span class="koboSpan" id="kobo.293.3">
     The most practical approaches are LLM-based planning and HTN, as they naturally align with how language models process and decompose tasks.
    </span>
    <span class="koboSpan" id="kobo.293.4">
     Let’s discuss them
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      in detail.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-114">
    <a id="_idTextAnchor124">
    </a>
    <span class="koboSpan" id="kobo.295.1">
     Less practical planning algorithms
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.296.1">
     As
    </span>
    <a id="_idIndexMarker412">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     mentioned earlier, less practical
    </span>
    <a id="_idIndexMarker413">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     planning algorithms include STRIPS, A* planning, GraphPlan, and MCTS.
    </span>
    <span class="koboSpan" id="kobo.298.2">
     Here’s a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      detailed overview.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.300.1">
     STRIPS
    </span>
   </h3>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.301.1">
      STRIPS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.302.1">
     works with
    </span>
    <a id="_idIndexMarker414">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     states and actions defined by
    </span>
    <a id="_idIndexMarker415">
    </a>
    <span class="koboSpan" id="kobo.304.1">
     logical predicates, making it effective for clear, binary conditions.
    </span>
    <span class="koboSpan" id="kobo.304.2">
     However, it’s unsuitable for LLM agents because natural language interactions can’t be effectively reduced to simple
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.305.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.307.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     conditions.
    </span>
    <span class="koboSpan" id="kobo.308.2">
     For example, while STRIPS can easily model
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.309.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     states, it struggles with nuanced language states such as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.313.1">
      partially understanding a concept
     </span>
    </em>
    <span class="koboSpan" id="kobo.314.1">
     or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.315.1">
      somewhat satisfied with a response
     </span>
    </em>
    <span class="koboSpan" id="kobo.316.1">
     , making it too rigid for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      language-based planning.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.318.1">
     A* planning
    </span>
   </h3>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.319.1">
      A* planning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.320.1">
     , while
    </span>
    <a id="_idIndexMarker416">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     powerful for pathfinding
    </span>
    <a id="_idIndexMarker417">
    </a>
    <span class="koboSpan" id="kobo.322.1">
     problems, faces fundamental challenges with LLM agents.
    </span>
    <span class="koboSpan" id="kobo.322.2">
     The algorithm requires a clear way to calculate both the cost of actions taken and a heuristic estimate of the remaining cost to reach a goal.
    </span>
    <span class="koboSpan" id="kobo.322.3">
     In language-based interactions, defining these costs becomes highly problematic – how do you quantify the “distance” between different conversation states or estimate the “cost” of reaching a particular understanding?
    </span>
    <span class="koboSpan" id="kobo.322.4">
     These mathematical requirements make A* impractical for natural
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      language planning.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.324.1">
     GraphPlan
    </span>
   </h3>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.325.1">
      GraphPlan
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     builds a
    </span>
    <a id="_idIndexMarker418">
    </a>
    <span class="koboSpan" id="kobo.327.1">
     layered graph structure
    </span>
    <a id="_idIndexMarker419">
    </a>
    <span class="koboSpan" id="kobo.328.1">
     representing possible actions and their effects at each time step.
    </span>
    <span class="koboSpan" id="kobo.328.2">
     When applied to LLM agents, this approach breaks down because language interactions don’t fit neatly into discrete layers with clear cause-and-effect relationships.
    </span>
    <span class="koboSpan" id="kobo.328.3">
     The combinatorial explosion of possible language states and the difficulty in determining mutual exclusion relationships between different conversational actions make GraphPlan computationally intractable for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      language-based planning.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.330.1">
     MCTS
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     For LLM
    </span>
    <a id="_idIndexMarker420">
    </a>
    <span class="koboSpan" id="kobo.332.1">
     agents,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.333.1">
      MCTS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.334.1">
     becomes impractical
    </span>
    <a id="_idIndexMarker421">
    </a>
    <span class="koboSpan" id="kobo.335.1">
     for two main reasons.
    </span>
    <span class="koboSpan" id="kobo.335.2">
     First, each “simulation” would require actual LLM calls, making it prohibitively expensive in terms of computation and cost; second, the vast space of possible language interactions makes random sampling inefficient for finding meaningful patterns or strategies.
    </span>
    <span class="koboSpan" id="kobo.335.3">
     The algorithm’s strength in game-like scenarios becomes a weakness in open-ended
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.336.1">
      language interactions.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-115">
    <a id="_idTextAnchor125">
    </a>
    <span class="koboSpan" id="kobo.337.1">
     Moderately practical planning algorithm – FF
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.338.1">
      FF
     </span>
    </strong>
    <span class="koboSpan" id="kobo.339.1">
     planning
    </span>
    <a id="_idIndexMarker422">
    </a>
    <span class="koboSpan" id="kobo.340.1">
     is considered to be a moderately
    </span>
    <a id="_idIndexMarker423">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     practical planning algorithm that can be used in LLM agents.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     It uses a heuristic search with a simplified version of the planning problem to guide its search.
    </span>
    <span class="koboSpan" id="kobo.341.3">
     Its focus on goal-oriented planning could be adapted for LLM agents, though it would require modifications to handle natural language effectively.
    </span>
    <span class="koboSpan" id="kobo.341.4">
     FF planning uses heuristic search with a simplified version of the planning problem to guide
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      its search.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     For LLM
    </span>
    <a id="_idIndexMarker424">
    </a>
    <span class="koboSpan" id="kobo.344.1">
     agents, FF planning offers several compelling advantages that make it worth considering.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     Its goal-oriented approach naturally aligns with how LLMs handle task completion, while its relaxed planning mechanism provides useful approximations for complex language tasks.
    </span>
    <span class="koboSpan" id="kobo.344.3">
     The heuristic guidance helps manage the
    </span>
    <a id="_idIndexMarker425">
    </a>
    <span class="koboSpan" id="kobo.345.1">
     vast search space inherent in language-based planning, and its flexibility allows modification to work
    </span>
    <a id="_idIndexMarker426">
    </a>
    <span class="koboSpan" id="kobo.346.1">
     with partial state descriptions, which is particularly valuable in natural
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      language contexts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     However, FF planning also faces significant challenges when applied to LLM agents.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     The original numeric heuristics that make FF effective in traditional planning don’t translate smoothly to language states, and relaxed plans risk oversimplifying the rich context present in language interactions.
    </span>
    <span class="koboSpan" id="kobo.348.3">
     There’s also considerable difficulty in defining clear delete effects – what aspects of a conversation state are removed or changed by an action – in language-based planning.
    </span>
    <span class="koboSpan" id="kobo.348.4">
     Perhaps most challengingly, the fundamental state representation requires substantial adaptation to work effectively with natural language.
    </span>
    <span class="koboSpan" id="kobo.348.5">
     In practice, FF could be adapted for LLM agents
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.350.1">
1 class LLMFastForward:
2    def create_relaxed_plan(self,
3                            current_state: str,
4                            goal: str) -&gt; list:
5     """Create a simplified plan ignoring complexities"""
6     # Use LLM to generate a high-level plan
7     prompt = f"Given current state: {current_state}\nAnd
               goal: {goal}\n"
8     prompt += "Generate a simplified step-by-stepplan"
9        return self.llm.generate_plan(prompt)
10
11   def select_next_action(self, relaxed_plan: list):
12      """Choose next action based on the relaxed plan"""
13      # Implement action selection logic
14      return relaxed_plan[0]  # Simplified selection</span></pre>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     This
    </span>
    <a id="_idIndexMarker427">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     code demonstrates a simplified adaptation
    </span>
    <a id="_idIndexMarker428">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     of FF planning for LLM agents.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     Let me explain its key components.
    </span>
    <span class="koboSpan" id="kobo.353.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.354.1">
      LLMFastForward
     </span>
    </strong>
    <span class="koboSpan" id="kobo.355.1">
     class has two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.356.1">
      main methods:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.357.1">
       create_relaxed_plan
      </span>
     </strong>
     <span class="koboSpan" id="kobo.358.1">
      : This method takes the current state and goal as text strings
     </span>
     <a id="_idIndexMarker429">
     </a>
     <span class="koboSpan" id="kobo.359.1">
      and uses an LLM to generate a simplified plan.
     </span>
     <span class="koboSpan" id="kobo.359.2">
      Think of it as asking the LLM, “
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.360.1">
       Given where we are now, and where we want to go, what are the main steps we should take?
      </span>
     </em>
     <span class="koboSpan" id="kobo.361.1">
      ”.
     </span>
     <span class="koboSpan" id="kobo.361.2">
      It ignores many complexities, similar to how traditional FF planning ignores
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.362.1">
       delete effects.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.363.1">
       select_next_action
      </span>
     </strong>
     <span class="koboSpan" id="kobo.364.1">
      : This method chooses the next action from the relaxed
     </span>
     <a id="_idIndexMarker430">
     </a>
     <span class="koboSpan" id="kobo.365.1">
      plan.
     </span>
     <span class="koboSpan" id="kobo.365.2">
      In this simplified version, it just takes the first action from the plan (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.366.1">
       relaxed_plan[0]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.367.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.367.2">
      In a more sophisticated implementation, it would use additional logic to select the most appropriate
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.368.1">
       next action.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.369.1">
     In essence, this code shows how FF planning’s core concept of using simplified plans to guide decision-making can be adapted to work with language models, even though it’s a significant simplification of both FF planning and LLM capabilities.
    </span>
    <span class="koboSpan" id="kobo.369.2">
     While this adaptation shows potential, implementing FF for LLM agents requires careful consideration of how to represent states, actions, and relaxed problems in a language-model context.
    </span>
    <span class="koboSpan" id="kobo.369.3">
     This makes it moderately practical – possible but requiring significant modifications from its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      original form.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-116">
    <a id="_idTextAnchor126">
    </a>
    <span class="koboSpan" id="kobo.371.1">
     Most practical planning algorithms
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.372.1">
     When
    </span>
    <a id="_idIndexMarker431">
    </a>
    <span class="koboSpan" id="kobo.373.1">
     it comes to planning
    </span>
    <a id="_idIndexMarker432">
    </a>
    <span class="koboSpan" id="kobo.374.1">
     algorithms for LLM agents, two approaches stand out as particularly effective: LLM-based planning and HTN planning.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     These algorithms have proven especially suitable for language models because they naturally align with how LLMs process information and handle complex tasks.
    </span>
    <span class="koboSpan" id="kobo.374.3">
     While traditional planning algorithms often struggle with the ambiguity and complexity of natural
    </span>
    <a id="_idIndexMarker433">
    </a>
    <span class="koboSpan" id="kobo.375.1">
     language, these approaches embrace the fluid, contextual nature of language-based planning.
    </span>
    <span class="koboSpan" id="kobo.375.2">
     Let’s explore each of these algorithms
    </span>
    <a id="_idIndexMarker434">
    </a>
    <span class="koboSpan" id="kobo.376.1">
     and understand why they’ve become the preferred choices for modern AI
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.377.1">
      agent frameworks.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.378.1">
     LLM-based planning
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.379.1">
     Modern approaches leverage LLMs to generate plans in a more flexible and natural way.
    </span>
    <span class="koboSpan" id="kobo.379.2">
     This
    </span>
    <a id="_idIndexMarker435">
    </a>
    <span class="koboSpan" id="kobo.380.1">
     approach can handle complex, real-world scenarios and understand context better than traditional planning
    </span>
    <a id="_idIndexMarker436">
    </a>
    <span class="koboSpan" id="kobo.381.1">
     algorithms.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     LLM-based planning operates on the principle that language models can understand complex goals, generate appropriate steps to achieve them, and adapt these steps based on changing contexts.
    </span>
    <span class="koboSpan" id="kobo.381.3">
     Unlike traditional planners that require explicit state representations, LLM planners work with natural language descriptions of states and actions, making them inherently more flexible and expressive.
    </span>
    <span class="koboSpan" id="kobo.381.4">
     Let’s visualize the planning process using
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.382.1">
       Figure 5
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.383.1">
       .3
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.384.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer057">
     <span class="koboSpan" id="kobo.385.1">
      <img alt="img" role="presentation" src="image/B31483_05_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.386.1">
     Figure 5.3 – LLM-based planning algorithm flow
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.387.1">
     Let’s examine
    </span>
    <a id="_idIndexMarker437">
    </a>
    <span class="koboSpan" id="kobo.388.1">
     a practical implementation using CrewAI that demonstrates this planning approach.
    </span>
    <span class="koboSpan" id="kobo.388.2">
     In this example, we’ll create a travel planning system
    </span>
    <a id="_idIndexMarker438">
    </a>
    <span class="koboSpan" id="kobo.389.1">
     with two specialized agents: a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.390.1">
      Travel Planning Strategist
     </span>
    </em>
    <span class="koboSpan" id="kobo.391.1">
     who breaks down travel requests into manageable steps, and a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.392.1">
      Travel Researcher
     </span>
    </em>
    <span class="koboSpan" id="kobo.393.1">
     who validates and finds specific options.
    </span>
    <span class="koboSpan" id="kobo.393.2">
     The system processes natural language travel requests and generates comprehensive travel plans through collaborative agent interaction.
    </span>
    <span class="koboSpan" id="kobo.393.3">
     Here’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      the implementation:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.395.1">
1 class TravelPlanner:
2    def __init__(self):
3        self.planner = Agent(
4            role='Travel Planning Strategist',
5            goal='Create comprehensive, personalized travel plans',
6            ... </span><span class="koboSpan" id="kobo.395.2"># Other parameters
7        )
8        self.researcher = Agent(
9            role='Travel Researcher',
10           goal='Find and validate travel options and opportunities',
11           ... </span><span class="koboSpan" id="kobo.395.3"># Other parameters
12       )
13
14   def create_travel_plan(self, request: str) -&gt; Dict:
15       planning_task = Task(
16           description=f"""
17           Analyze the following travel request and
18           create a detailed plan:
19           {request}
20           Break this down into actionable steps by:
21           1. </span><span class="koboSpan" id="kobo.395.4">Understanding client requirements
22           3. </span><span class="koboSpan" id="kobo.395.5">Specific booking requirements
23           4. </span><span class="koboSpan" id="kobo.395.6">Required validations
24           """, agent=self.planner )
25
26       research_task = Task(
27           description="""
28           Based on the initial plan, research and
29           validate: Flight availability, hotel options,
30           and local transportation
31           """, agent=self.researcher)
32
33       crew = Crew(
34           agents=[self.planner, self.researcher],
35           tasks=[planning_task, research_task],
36           process=Process.sequential )
37       return crew.kickoff(inputs={"request": request})</span></pre>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     This implementation demonstrates several key advantages of LLM-based planning.
    </span>
    <span class="koboSpan" id="kobo.396.2">
     The planner can
    </span>
    <a id="_idIndexMarker439">
    </a>
    <span class="koboSpan" id="kobo.397.1">
     understand complex
    </span>
    <a id="_idIndexMarker440">
    </a>
    <span class="koboSpan" id="kobo.398.1">
     natural language requests, dynamically generate appropriate steps, and adapt to different types of travel planning scenarios.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     The agents can work together, sharing context and building upon each other’s outputs.
    </span>
    <span class="koboSpan" id="kobo.398.3">
     The system’s sophistication comes from its ability to handle nuanced requirements.
    </span>
    <span class="koboSpan" id="kobo.398.4">
     For instance, when a user requests “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.399.1">
      a relaxing beach vacation with some cultural activities
     </span>
    </em>
    <span class="koboSpan" id="kobo.400.1">
     ,” the planner understands these abstract concepts and can translate them into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      concrete recommendations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     However, developers should be mindful of certain caveats.
    </span>
    <span class="koboSpan" id="kobo.402.2">
     LLM-based planning systems can sometimes generate overly optimistic or impractical plans if not properly constrained.
    </span>
    <span class="koboSpan" id="kobo.402.3">
     They may also struggle with highly specific numerical constraints or strict timing requirements unless these are explicitly handled in the implementation.
    </span>
    <span class="koboSpan" id="kobo.402.4">
     A significant advantage of LLM-based planning over traditional algorithms lies in the system’s adaptability.
    </span>
    <span class="koboSpan" id="kobo.402.5">
     While STRIPS or A* planning would require explicit state representations for every possible travel scenario, LLM-based planning can handle novel situations by leveraging its understanding of language and context.
    </span>
    <span class="koboSpan" id="kobo.402.6">
     This makes it particularly suitable for domains where requirements are often ambiguous or evolving.
    </span>
    <span class="koboSpan" id="kobo.402.7">
     This planning approach also excels at handling uncertainty and partial information, something traditional planners struggle with.
    </span>
    <span class="koboSpan" id="kobo.402.8">
     When information is missing or ambiguous, the system can generate reasonable assumptions and include contingency steps in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      its plans.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.404.1">
     HTN
    </span>
   </h3>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.405.1">
      HTN
     </span>
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     planning breaks
    </span>
    <a id="_idIndexMarker441">
    </a>
    <span class="koboSpan" id="kobo.407.1">
     down complex tasks into simpler subtasks, creating a hierarchy of actions.
    </span>
    <span class="koboSpan" id="kobo.407.2">
     Unlike STRIPS, which works with primitive actions, HTN can work with abstract tasks and decompose them into more concrete steps.
    </span>
    <span class="koboSpan" id="kobo.407.3">
     This makes it particularly well-suited for real-world planning problems where
    </span>
    <a id="_idIndexMarker442">
    </a>
    <span class="koboSpan" id="kobo.408.1">
     tasks naturally decompose into subtasks.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     HTN planning works by breaking down high-level tasks into progressively smaller subtasks.
    </span>
    <span class="koboSpan" id="kobo.408.3">
     Consider the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      example code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.410.1">
1 def buy_groceries_task():
2    return [
3        ('go_to_store', []),
4        ('select_items', []),
5        ('checkout', []),
6        ('return_home', [])
7    ]
8
9 def select_items_task():
10   return [
11       ('check_list', []),
12       ('find_item', []),
13       ('add_to_cart', [])
14   ]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.411.1">
     HTN planning operates on the principle of task decomposition, where high-level tasks (compound tasks) are broken down into smaller, more manageable subtasks until reaching primitive tasks that can be directly executed.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     This hierarchical structure allows for intuitive problem representation and efficient solution finding.
    </span>
    <span class="koboSpan" id="kobo.411.3">
     In our example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.412.1">
      buy_groceries_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.413.1">
     is a high-level task broken down into four subtasks.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     One of these subtasks,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.414.1">
      select_items
     </span>
    </strong>
    <span class="koboSpan" id="kobo.415.1">
     , is further decomposed into three more specific actions, and so on.
    </span>
    <span class="koboSpan" id="kobo.415.2">
     In the context of our travel agent example, we can use a similar hierarchical breakdown of complex tasks decomposed into smaller tasks.
    </span>
    <span class="koboSpan" id="kobo.415.3">
     Visually,
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.416.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.417.1">
      .4
     </span>
    </em>
    <span class="koboSpan" id="kobo.418.1">
     shows how this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      may look:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer058">
     <span class="koboSpan" id="kobo.420.1">
      <img alt="img" role="presentation" src="image/B31483_05_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.421.1">
     Figure 5.4 – HTN decomposition
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.422.1">
     To implement this with CrewAI, we can use CrewAI’s
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.423.1">
      hierarchical
     </span>
    </em>
    <span class="koboSpan" id="kobo.424.1">
     processing, where tasks
    </span>
    <a id="_idIndexMarker443">
    </a>
    <span class="koboSpan" id="kobo.425.1">
     are broken down into a hierarchical manner as
    </span>
    <a id="_idIndexMarker444">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     explained using the HTN planning algorithm.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     With the CrewAI framework, the hierarchical method requires a m
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.427.1">
      anager
     </span>
    </strong>
    <span class="koboSpan" id="kobo.428.1">
     unit, which would be responsible for breaking down the tasks and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.429.1">
      delegating
     </span>
    </em>
    <span class="koboSpan" id="kobo.430.1">
     individual tasks to the agents.
    </span>
    <span class="koboSpan" id="kobo.430.2">
     The Manager can either be an agent or it can be the LLM itself.
    </span>
    <span class="koboSpan" id="kobo.430.3">
     If the Manager is an agent, then you can control how the manager breaks down the tasks to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.431.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.432.1">
     -level tasks as per the workflow’s needs.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     If the Manager is an LLM, then it will use the arbitrary plan generated by the LLM itself based on the user’s query.
    </span>
    <span class="koboSpan" id="kobo.432.3">
     With a Manager LLM, you may be able to control how the task breakdown works and how the delegation works using some prompt engineering; however, it is generally less flexible and is meant for simpler workflows.
    </span>
    <span class="koboSpan" id="kobo.432.4">
     Here’s a sample code for an HTN-like workflow for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      travel planner:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.434.1">
1 flight_specialist = Agent(
2     role='Flight Planning Specialist',
3     goal='Handle all aspects of flight arrangements',
4     backstory='Expert in airline bookings and flight
                logistics.')
5
6 accommodation_specialist = Agent(
7    role='Accommodation Specialist',
8    goal='Manage all accommodation-related planning',
9    backstory='Expert in hotel and accommodation booking')
10
11 activity_specialist = Agent(
12    role='Vacation Activity Specialist',
13    goal='Manage all activity-related planning',
14    backstory="Expert in recreational activity
                 arrangements.",)
15
16 manager_llm = ChatOpenAI(model="gpt-4o-mini")
17 travel_planning_task = Task(
18    description=f"""
19      Plan a comprehensive flight itinerary based on the
20      following request:
21      {request}
22      The plan should include: Flight arrangements,
23      Accommodation bookings, other relevant travel
24        components
25      """,
26      expected_output="A detailed flight itinerary
        covering all requested aspects.",
27      agent=None) #No agent; the manager will delegate
                    subtasks
28
29 crew = Crew(
30           agents=[self.flight_specialist,
31                   self.accommodation_specialist,
32                   self.activity_specialist],
33           tasks=[travel_planning_task],
34           process=Process.hierarchical,
35           manager_llm=self.manager_llm,)
36      return crew.kickoff()</span></pre>
   <p>
    <span class="koboSpan" id="kobo.435.1">
     The
    </span>
    <a id="_idIndexMarker445">
    </a>
    <span class="koboSpan" id="kobo.436.1">
     output of this
    </span>
    <a id="_idIndexMarker446">
    </a>
    <span class="koboSpan" id="kobo.437.1">
     execution may look as shown (output has been trimmed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      for brevity):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.439.1">
Final Travel Plan:
Here's the complete travel itinerary for a 5-day trip to Paris from New York for two adults:
---
Travel Itinerary for Paris Trip
From New York (JFK) to Paris (CDG)
Travelers: 2 Adults , Duration: 5 Days
---
</span><strong class="bold"><span class="koboSpan" id="kobo.440.1">1. </span><span class="koboSpan" id="kobo.440.2">Flights</span></strong><span class="koboSpan" id="kobo.441.1">:
- Departure Flight: ...
</span><span class="koboSpan" id="kobo.441.2">- Total Flight Cost: $2,960
---
</span><strong class="bold"><span class="koboSpan" id="kobo.442.1">2. </span><span class="koboSpan" id="kobo.442.2">Hotel Accommodations:</span></strong><span class="koboSpan" id="kobo.443.1">
- Hotel: ...
</span><span class="koboSpan" id="kobo.443.2">- Estimated Total = €800.
</span><span class="koboSpan" id="kobo.443.3">---
</span><strong class="bold"><span class="koboSpan" id="kobo.444.1">3. </span><span class="koboSpan" id="kobo.444.2">Airport Transfers:</span></strong><span class="koboSpan" id="kobo.445.1">
- Option 1: ...
</span><span class="koboSpan" id="kobo.445.2">- Option 2: ...
</span><span class="koboSpan" id="kobo.445.3">---
</span><strong class="bold"><span class="koboSpan" id="kobo.446.1">4. </span><span class="koboSpan" id="kobo.446.2">Day Trip to Versailles:</span></strong><span class="koboSpan" id="kobo.447.1">
- Transportation: Round-trip via RER C train from …
   - Cost: Approximately …
   - Departure Time: 9:00 AM from …
   - Return Time: 5:00 PM from Versailles.
</span><span class="koboSpan" id="kobo.447.2">   ...
</span><span class="koboSpan" id="kobo.447.3">   - Overall Total for Day Trip: Approximately €364.20.
</span><span class="koboSpan" id="kobo.447.4">---
</span><strong class="bold"><span class="koboSpan" id="kobo.448.1">Grand Total Estimated Cost:</span></strong><span class="koboSpan" id="kobo.449.1">
- Flights: $2,960
- Accommodation: €800 (with Le Fabe Hotel)
- Airport Transfers: €100 (may vary)
- Day Trip to Versailles: Approximately €364.20
- Convert Total Costs as Necessary to USD.
</span><span class="koboSpan" id="kobo.449.2">...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     Note that, in this case, the agentic system has no access to external tools or lookup, so whatever response it generates is going to be completely fictional and non-factual.
    </span>
    <span class="koboSpan" id="kobo.450.2">
     This underscores the importance of tools, which we will look at in the next section.
    </span>
    <span class="koboSpan" id="kobo.450.3">
     For now, the previous example shows how you can use the framework for task breakdown and have a Manager manage several agents to perform decomposed simplified tasks from a user’s request.
    </span>
    <span class="koboSpan" id="kobo.450.4">
     You can see the full code in the Python notebook (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.451.1">
      Chapter_05.ipynb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.452.1">
     ) in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.453.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.454.1">
     HTN planning offers several significant advantages that make it particularly effective for complex planning scenarios.
    </span>
    <span class="koboSpan" id="kobo.454.2">
     Its natural problem representation mirrors human thinking patterns, making it intuitive to understand and maintain.
    </span>
    <span class="koboSpan" id="kobo.454.3">
     The hierarchical approach enables
    </span>
    <a id="_idIndexMarker447">
    </a>
    <span class="koboSpan" id="kobo.455.1">
     better scalability by breaking down complex problems into manageable subtasks, effectively reducing the search space.
    </span>
    <span class="koboSpan" id="kobo.455.2">
     HTN’s
    </span>
    <a id="_idIndexMarker448">
    </a>
    <span class="koboSpan" id="kobo.456.1">
     structure excels at encoding expert knowledge through its task hierarchies, allowing for reusable patterns across similar problems.
    </span>
    <span class="koboSpan" id="kobo.456.2">
     Additionally, its flexibility in handling both abstract and primitive tasks makes it adaptable to various planning situations, enabling planners to work at different levels of abstraction
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      as needed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.458.1">
     So far, we’ve learned about tools and several planning algorithms, but together they can enable LLM agents to perform more complex, multi-step tasks by combining strategic planning with effective tool use.
    </span>
    <span class="koboSpan" id="kobo.458.2">
     Let’s further explore how we can effectively integrate tool use with planning within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.459.1">
      agentic systems.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-117">
    <a id="_idTextAnchor127">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     Integrating tool use and planning
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.461.1">
     Most of the earlier work in AI planning and tool usage was done in isolation, focusing on either planning
    </span>
    <a id="_idIndexMarker449">
    </a>
    <span class="koboSpan" id="kobo.462.1">
     algorithms or tool capabilities separately.
    </span>
    <span class="koboSpan" id="kobo.462.2">
     However, to achieve truly intelligent agents, there is a need to integrate tool use with planning effectively.
    </span>
    <span class="koboSpan" id="kobo.462.3">
     As we already saw in the previous section, our travel planner gave us a detailed travel plan but none of the details were factual – that is, it contained information that the LLM simply made up.
    </span>
    <span class="koboSpan" id="kobo.462.4">
     In order to infuse our system with actual flight, hotel, and activity data so that the travel plan is grounded in facts, we will need to utilize tools along with the planning algorithm.
    </span>
    <span class="koboSpan" id="kobo.462.5">
     This section will discuss how to combine these two aspects to generate relevant responses and complete
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.463.1">
      tasks accurately.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-118">
    <a id="_idTextAnchor128">
    </a>
    <span class="koboSpan" id="kobo.464.1">
     Reasoning about tools
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.465.1">
     Agents need the ability to reason about the available tools at their disposal, understanding the functionality, capabilities, and limitations of each tool, as well as the contexts and
    </span>
    <a id="_idIndexMarker450">
    </a>
    <span class="koboSpan" id="kobo.466.1">
     conditions under which they can be applied effectively.
    </span>
    <span class="koboSpan" id="kobo.466.2">
     The reasoning process involves assessing the available tools based on the current goals and objectives, and then choosing the most appropriate ones that can be utilized in the given situation or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.467.1">
      problem domain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.468.1">
     For example, in the case of our travel planner, the agent will have access to various tools such as flight booking APIs, hotel reservation systems, and activity planning software.
    </span>
    <span class="koboSpan" id="kobo.468.2">
     The agent needs to reason about the capabilities of each tool, such as which tools can be used for booking flights or book hotels, and which ones can provide information about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.469.1">
      local attractions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.470.1">
     When working with LLM agents, reasoning about tools is largely handled by the language model’s inherent capabilities.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     Modern LLMs are trained to understand tool descriptions, purposes, and appropriate usage contexts.
    </span>
    <span class="koboSpan" id="kobo.470.3">
     This means we don’t need to explicitly program complex reasoning mechanisms – instead, we provide clear tool descriptions and let the LLM determine when and how to use them.
    </span>
    <span class="koboSpan" id="kobo.470.4">
     For example, let’s look at our travel planner
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.471.1">
      agent scenario:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.472.1">
1 from crewai import Agent
2
3 travel_agent = Agent(
4   role='Travel Planner',
5   goal='Plan comprehensive travel itineraries',
6   tools=[
7       flight_search_tool,    # Tool for finding and booking flights
8       hotel_booking_tool,    # Tool for hotel reservations
9       activity_planner_tool  # Tool for local activities and
                                 attractions
10    ])</span></pre>
   <p>
    <span class="koboSpan" id="kobo.473.1">
     The LLM agent can naturally understand
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.474.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.475.1">
      Which tool to use for each task (for example,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.476.1">
       flight_search_tool
      </span>
     </strong>
     <span class="koboSpan" id="kobo.477.1">
      for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.478.1">
       air travel)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.479.1">
      When to use tools in combination (for example, coordinating flight and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.480.1">
       hotel dates)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.481.1">
      How to adapt tool usage based on user requirements (for example,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.482.1">
       budget constraints)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     This built-in reasoning capability means we can focus on providing well-defined tools with clear descriptions, rather than implementing complex reasoning mechanisms.
    </span>
    <span class="koboSpan" id="kobo.483.2">
     The LLM will handle
    </span>
    <a id="_idIndexMarker451">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     the decision-making process of tool selection and application based on the context and requirements of each situation.
    </span>
    <span class="koboSpan" id="kobo.484.2">
     However, not all language models are equally capable of effective tool reasoning.
    </span>
    <span class="koboSpan" id="kobo.484.3">
     This capability typically requires models that have been specifically trained or fine-tuned for tool use and function calling.
    </span>
    <span class="koboSpan" id="kobo.484.4">
     Smaller models or those without tool-use training may have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.485.1">
      following issues:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.486.1">
      Failing to understand when a tool
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.487.1">
       is needed
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.488.1">
      Making incorrect assumptions about
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.489.1">
       tool capabilities
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.490.1">
      Using tools in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.491.1">
       wrong sequences
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.492.1">
      Missing opportunities to use
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.493.1">
       available tools
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.494.1">
      Ignoring tool constraints
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.495.1">
       or requirements
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.496.1">
     Even capable models can face limitations such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.497.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.498.1">
      Difficulty with complex tool combinations requiring
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.499.1">
       many steps
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.500.1">
      Inconsistency in tool selection across
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.501.1">
       similar scenarios
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.502.1">
      Challenges with tools that have subtle differences
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.503.1">
       in functionality
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.504.1">
      Struggles with error recovery when
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.505.1">
       tools fail
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.506.1">
     This is why frameworks such as CrewAI, LangGraph, and AutoGen often work best with more advanced models that have demonstrated strong tool reasoning capabilities, and why it’s important to test your agent’s tool usage patterns
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.507.1">
      before deployment.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-119">
    <a id="_idTextAnchor129">
    </a>
    <span class="koboSpan" id="kobo.508.1">
     Planning for tool use
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.509.1">
     The planning process in modern AI agents is fundamentally driven by LLM capabilities, building upon
    </span>
    <a id="_idIndexMarker452">
    </a>
    <span class="koboSpan" id="kobo.510.1">
     the principles we discussed in LLM-based planning and HTN approaches.
    </span>
    <span class="koboSpan" id="kobo.510.2">
     Rather than following rigid planning algorithms, agents leverage their language model’s understanding to create flexible, context-aware plans for tool usage.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.511.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.512.1">
      .5
     </span>
    </em>
    <span class="koboSpan" id="kobo.513.1">
     depicts
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      this process:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer059">
     <span class="koboSpan" id="kobo.515.1">
      <img alt="img" role="presentation" src="image/B31483_05_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.516.1">
     Figure 5.5 – Tool planning flow
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.517.1">
     When an agent receives a request, it first understands the goals through natural language processing.
    </span>
    <span class="koboSpan" id="kobo.517.2">
     For a travel agent, this might mean comprehending that a family vacation request requires not just flight bookings but also family-friendly accommodation and activities.
    </span>
    <span class="koboSpan" id="kobo.517.3">
     This goal-understanding phase draws directly from the LLM’s trained
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.518.1">
      comprehension abilities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.519.1">
     The planning process then shifts to identifying which tools are needed and in what sequence they should be used.
    </span>
    <span class="koboSpan" id="kobo.519.2">
     This mirrors the hierarchical decomposition we saw in HTN planning but with the flexibility of LLM-based decision-making.
    </span>
    <span class="koboSpan" id="kobo.519.3">
     The agent doesn’t just follow predefined decomposition rules; it adapts its planning based on the specific context and requirements of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.520.1">
      each request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.521.1">
     Tool integration into the plan happens naturally as part of this process.
    </span>
    <span class="koboSpan" id="kobo.521.2">
     The agent understands tool capabilities through their descriptions and can sequence them appropriately.
    </span>
    <span class="koboSpan" id="kobo.521.3">
     For instance, when planning a vacation, the agent knows that flight dates need to be confirmed before booking hotels, and that activity planning should consider the location and timing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.522.1">
      of both.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     This planning approach combines the structured nature of traditional planning algorithms
    </span>
    <a id="_idIndexMarker453">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     with the adaptability of language models.
    </span>
    <span class="koboSpan" id="kobo.524.2">
     The agent can adjust its plans based on new information or changing circumstances, much like a human travel agent would modify their approach based on client feedback or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.525.1">
      availability changes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.526.1">
     The success of this planning process relies heavily on the LLM’s ability to understand context and generate appropriate sequences of actions.
    </span>
    <span class="koboSpan" id="kobo.526.2">
     This is why frameworks such as CrewAI often implement this type of planning, allowing agents to leverage their language understanding capabilities while maintaining the systematic approach needed for complex
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      task completion.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-120">
    <a id="_idTextAnchor130">
    </a>
    <span class="koboSpan" id="kobo.528.1">
     Exploring practical implementations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.529.1">
     To demonstrate how various AI/ML frameworks can be used to create intelligent agents capable of executing complex tasks through tool use and planning, let’s explore examples using CrewAI, AutoGen, and LangGraph (the agentic framework of LangChain).
    </span>
    <span class="koboSpan" id="kobo.529.2">
     You can find the full code for each of the framework examples in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      Chapter_05.ipynb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     Python notebook in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.532.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-121">
    <a id="_idTextAnchor131">
    </a>
    <span class="koboSpan" id="kobo.533.1">
     CrewAI example
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.534.1">
     Let’s examine
    </span>
    <a id="_idIndexMarker454">
    </a>
    <span class="koboSpan" id="kobo.535.1">
     how CrewAI implements tool-based reasoning through a practical travel planning example.
    </span>
    <span class="koboSpan" id="kobo.535.2">
     The framework’s Python library provides a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      @tool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     decorator that allows us to define tools with clear descriptions and documentation.
    </span>
    <span class="koboSpan" id="kobo.537.2">
     Here’s how we can create a set of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.538.1">
      travel-related tools:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.539.1">
1 </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">@tool</span></strong><span class="koboSpan" id="kobo.541.1">("Search for available flights between cities")
2 def search_flights(...) -&gt; dict:
3    """Search for available flights between cities."""
</span><span class="koboSpan" id="kobo.541.2">4    # Call flight API and other tool logic
5
6 </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">@tool</span></strong><span class="koboSpan" id="kobo.543.1">("Find available hotels in a location")
7 def find_hotels(...) -&gt; dict:
8   """Search for available hotels in a location."""
</span><span class="koboSpan" id="kobo.543.2">9   # Call hotels API and other tool logic
10
11 </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">@tool</span></strong><span class="koboSpan" id="kobo.545.1">("Find available activities in a location")
12 def find_activities(...) -&gt; dict:
13   """Find available activities in a location."""
</span><span class="koboSpan" id="kobo.545.2">14  # Call activities API and other tool logic</span></pre>
   <p>
    <span class="koboSpan" id="kobo.546.1">
     The tools are
    </span>
    <a id="_idIndexMarker455">
    </a>
    <span class="koboSpan" id="kobo.547.1">
     then assigned to an agent that understands how to use them in context.
    </span>
    <span class="koboSpan" id="kobo.547.2">
     The agent is created with a specific role, goal, and backstory that helps guide
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.548.1">
      its decision-making:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.549.1">
1 Agent(
2    role='An expert travel concierge',
3    goal='Handle all aspects of travel planning',
4    backstory="Expert in airline bookings and flight
          logistics, hotel bookings, and booking vacation
          activities.",
5    tools=[search_flights, find_hotels, find_activities],
6    verbose=False
7 )</span></pre>
   <p>
    <span class="koboSpan" id="kobo.550.1">
     When given a task, the agent uses these tools based on the context
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      and requirements:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.552.1">
1 travel_planning_task = Task(
2    description=f"""
3    Plan a comprehensive travel and leisure itinerary
4    based on the following request:
5    {request}
6    The plan should include:
7    - Flight arrangements
8    - Accommodation bookings
9    - Any other relevant travel components
10   """,
11   expected_output="A detailed travel itinerary covering
         all requested aspects.",
12   agent=self.travel_specialist )</span></pre>
   <p>
    <span class="koboSpan" id="kobo.553.1">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.554.1">
      crew.kickoff()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.555.1">
     is called, CrewAI
    </span>
    <a id="_idIndexMarker456">
    </a>
    <span class="koboSpan" id="kobo.556.1">
     orchestrates the tool usage in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.557.1">
      following ways:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.558.1">
      Understanding the task requirements through the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.559.1">
       task description
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.560.1">
      Identifying which tools are needed based on the agent’s role and the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.561.1">
       task goals
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.562.1">
      Using the tools in a logical sequence to build the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.563.1">
       travel plan
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.564.1">
      Processing tool outputs and incorporating them into the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.565.1">
       final response
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.566.1">
     This implementation demonstrates how CrewAI combines tool definitions, agent capabilities, and task specifications to create a coherent planning system.
    </span>
    <span class="koboSpan" id="kobo.566.2">
     The framework handles the complexity of tool reasoning while allowing developers to focus on defining clear tool interfaces and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.567.1">
      agent behaviors.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-122">
    <a id="_idTextAnchor132">
    </a>
    <span class="koboSpan" id="kobo.568.1">
     AutoGen example
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.569.1">
     AutoGen provides a platform for developing AI agents that can engage in conversations and, through
    </span>
    <a id="_idIndexMarker457">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     these interactions, arrive at solutions for given tasks.
    </span>
    <span class="koboSpan" id="kobo.570.2">
     AutoGen approaches multi-agent collaboration through a RoundRobinGroupChat system where specialized agents interact to create a comprehensive travel plan.
    </span>
    <span class="koboSpan" id="kobo.570.3">
     The implementation defines four key agents: a flight planner, a hotel planner, an activities planner, and a summary agent, each with specific responsibilities
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.571.1">
      and tools.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.572.1">
     Each agent is initialized with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.573.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.574.1">
      A name
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.575.1">
       and description
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.576.1">
      A model client (in this case,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.577.1">
       OpenAI’s GPT-4o-mini)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.578.1">
      Specific tools they
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.579.1">
       can access
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.580.1">
      A system message defining their role
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.581.1">
       and responsibilities
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.582.1">
     The key differentiators from CrewAI lie in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.583.1">
      execution model:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.584.1">
       Agent communication
      </span>
     </strong>
     <span class="koboSpan" id="kobo.585.1">
      : While CrewAI uses a hierarchical task-based approach, AutoGen implements a round-robin group chat where agents take turns contributing to the solution.
     </span>
     <span class="koboSpan" id="kobo.585.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.586.1">
       RoundRobinGroupChat
      </span>
     </strong>
     <span class="koboSpan" id="kobo.587.1">
      class orchestrates this conversation flow, allowing agents to build upon each
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.588.1">
       other’s suggestions.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.589.1">
       Termination handling
      </span>
     </strong>
     <span class="koboSpan" id="kobo.590.1">
      : AutoGen uses an explicit termination condition through the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.591.1">
       TextMentionTermination
      </span>
     </strong>
     <span class="koboSpan" id="kobo.592.1">
      class.
     </span>
     <span class="koboSpan" id="kobo.592.2">
      The travel summary agent can end the conversation by mentioning
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.593.1">
       "TERMINATE"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.594.1">
      when a complete plan is ready.
     </span>
     <span class="koboSpan" id="kobo.594.2">
      This differs from CrewAI’s task-completion-based termination.
     </span>
     <span class="koboSpan" id="kobo.594.3">
      Here are the parameters
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.595.1">
       of
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.596.1">
        TextMentionTermination
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.597.1">
       :
      </span>
     </span>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.598.1">
         mention_text(str)
        </span>
       </strong>
       <span class="koboSpan" id="kobo.599.1">
        : The keyword or phrase that triggers termination (
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.600.1">
         e.g.,
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.601.1">
          "TERMINATE"
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.602.1">
         )
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.603.1">
         case_sensitive (bool, optional)
        </span>
       </strong>
       <span class="koboSpan" id="kobo.604.1">
        : Whether the keyword matching should
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.605.1">
         be case-sensitive
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.606.1">
         strip_whitespace (bool, optional)
        </span>
       </strong>
       <span class="koboSpan" id="kobo.607.1">
        : Whether to ignore leading/trailing spaces in the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.608.1">
         detected text
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.609.1">
         regex_match (bool, optional)
        </span>
       </strong>
       <span class="koboSpan" id="kobo.610.1">
        : Allows for using regular expressions for more flexible
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.611.1">
         termination triggers
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.612.1">
       Tool integration
      </span>
     </strong>
     <span class="koboSpan" id="kobo.613.1">
      : Instead of CrewAI’s decorator-based tool definition, AutoGen associates tools directly with agents during initialization.
     </span>
     <span class="koboSpan" id="kobo.613.2">
      Each agent has access to specific tools relevant to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.614.1">
       their role.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.615.1">
       Coordination pattern
      </span>
     </strong>
     <span class="koboSpan" id="kobo.616.1">
      : While CrewAI often uses a manager-worker pattern, AutoGen’s round-robin approach creates a more collaborative environment where agents contribute equally to the solution, with the summary agent responsible for creating the final
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.617.1">
       integrated plan.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.618.1">
     This implementation
    </span>
    <a id="_idIndexMarker458">
    </a>
    <span class="koboSpan" id="kobo.619.1">
     showcases AutoGen’s strength in handling complex multi-agent conversations while maintaining clear role separation and specialized tool usage for each agent.
    </span>
    <span class="koboSpan" id="kobo.619.2">
     The following is how you define agents
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.620.1">
      with AutoGen:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.621.1">
1 flight_agent = AssistantAgent(
2    name="flight_planner",
3    model_client=model_client,
4    tools=[travel_tools.search_flights],
5    description="A helpful assistant that can plan flights
                 itinerary for vacation trips.",
6    system_message="You are a helpful assistant that can
           plan flight itinerary for a travel plan for a
           user based on their request." </span><span class="koboSpan" id="kobo.621.2">)
7
8 hotel_agent = AssistantAgent(
9    name="hotel_planner",
10    model_client=model_client,
11    tools=[travel_tools.search_flights],
12    description="...", system_message="..." </span><span class="koboSpan" id="kobo.621.3">)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.622.1">
     Once agents
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.623.1">
     are defined, a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.624.1">
      RoundRobinGroupChat
     </span>
    </strong>
    <span class="koboSpan" id="kobo.625.1">
     class can be defined using the agents and a conversation with the multi-agent system can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.626.1">
      be invoked:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.627.1">
2 group_chat = RoundRobinGroupChat(
3     [flight_agent, hotel_agent],
4     termination_condition=termination)
6  await Console(group_chat.run_stream(task="I need to plan
               a trip to Paris from New York for 5 days."))</span></pre>
   <h2 id="_idParaDest-123">
    <a id="_idTextAnchor133">
    </a>
    <span class="koboSpan" id="kobo.628.1">
     LangGraph example
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.629.1">
     LangChain provides a framework for developing applications that can leverage LLMs alongside other
    </span>
    <a id="_idIndexMarker460">
    </a>
    <span class="koboSpan" id="kobo.630.1">
     tools and data sources.
    </span>
    <span class="koboSpan" id="kobo.630.2">
     In the context of agentic systems, LangChain provides a sub-framework known as LangGraph that is used to build powerful LLM agent-based workflows.
    </span>
    <span class="koboSpan" id="kobo.630.3">
     LangGraph approaches agent-based travel planning through a workflow graph system, offering a different paradigm from both CrewAI and AutoGen.
    </span>
    <span class="koboSpan" id="kobo.630.4">
     Let’s examine how this implementation works and its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      distinguishing characteristics.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.632.1">
     LangGraph uses a state machine approach where the workflow is defined as a graph with nodes and edges.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     The implementation centers around two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      main nodes:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.634.1">
      An agent node that processes messages and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.635.1">
       makes decisions
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.636.1">
      A tool node that executes the requested tools (flight search, hotel booking, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.637.1">
       activity planning)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.638.1">
     The workflow follows a cycle where the agent node evaluates the current state and either makes tool calls or provides a final response.
    </span>
    <span class="koboSpan" id="kobo.638.2">
     This is controlled through a function that interprets the model’s next move (that is, call a tool or end the response), which determines whether to route to the tools node or end the conversation.
    </span>
    <span class="koboSpan" id="kobo.638.3">
     Just like CrewAI, LangGraph also uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.639.1">
      @tool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.640.1">
     decorator (for Python) with which the tool functions can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.641.1">
      be defined:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.642.1">
1 @tool
2 def search_flights(...) -&gt; dict:
3    """Search for available flights between cities."""
</span><span class="koboSpan" id="kobo.642.2">4   # Emulate JSON data from an API
5   return data</span></pre>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     Once nodes are defined with or without tools, they can be connected to each other to build a full graph structure of the workflow.
    </span>
    <span class="koboSpan" id="kobo.643.2">
     For example, in our case, the following code defines a state graph-based workflow using LangGraph, where a task cycles between two nodes: agent and tools.
    </span>
    <span class="koboSpan" id="kobo.643.3">
     The graph starts at the agent node (defined as the entry point), which calls a function (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.644.1">
      call_model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.645.1">
     ) to process input.
    </span>
    <span class="koboSpan" id="kobo.645.2">
     After the agent runs, a conditional function (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.646.1">
      should_continue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.647.1">
     ) determines the next node – either looping back to the tools node or ending the workflow.
    </span>
    <span class="koboSpan" id="kobo.647.2">
     The tools node (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.648.1">
      tool_node
     </span>
    </strong>
    <span class="koboSpan" id="kobo.649.1">
     ) processes intermediate
    </span>
    <a id="_idIndexMarker461">
    </a>
    <span class="koboSpan" id="kobo.650.1">
     tasks and always transitions back to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.651.1">
      agent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.652.1">
     node, creating a repetitive cycle until the conditional function decides to stop.
    </span>
    <span class="koboSpan" id="kobo.652.2">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.653.1">
      MemorySaver
     </span>
    </strong>
    <span class="koboSpan" id="kobo.654.1">
     checkpoint is used to persist the state across runs, and the graph is compiled into a LangChain-compatible runnable.
    </span>
    <span class="koboSpan" id="kobo.654.2">
     Finally, the workflow is invoked with an initial input message about planning a trip, and the final message content is printed after the graph
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.655.1">
      execution concludes:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.656.1">
1 workflow = StateGraph(MessagesState)
2 workflow.add_node("agent", call_model)
3 workflow.add_node("tools", tool_node)
4 workflow.add_edge(START, "agent")
5 workflow.add_conditional_edges("agent",should_continue)
6 workflow.add_edge("tools", 'agent')
7 checkpointer = MemorySaver()
8 app = workflow.compile(checkpointer=checkpointer)
9 final_state = app.invoke(
10   {"messages": [HumanMessage(content="I need to plan a
               trip to Paris from New York for 5 days")]},
11    config={"configurable": {"thread_id": 42}})</span></pre>
   <p>
    <span class="koboSpan" id="kobo.657.1">
     LangGraph’s approach offers several notable advantages.
    </span>
    <span class="koboSpan" id="kobo.657.2">
     For example, its graph structure provides explicit flow control, making workflows easy to visualize and understand, while built-in state management with checkpointing capabilities ensures robust handling of the application state.
    </span>
    <span class="koboSpan" id="kobo.657.3">
     However, these benefits come with certain trade-offs.
    </span>
    <span class="koboSpan" id="kobo.657.4">
     The framework requires a solid understanding of graph-based programming concepts, and its initial
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.658.1">
     setup involves more overhead compared to CrewAI’s more straightforward agent definition.
    </span>
    <span class="koboSpan" id="kobo.658.2">
     The full code implementation can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.659.1">
      Chapter_05.ipynb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.660.1">
     Python notebook in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.661.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.662.1">
      Table 5.1
     </span>
    </em>
    <span class="koboSpan" id="kobo.663.1">
     illustrates some key differences between LangGraph, CrewAI,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.664.1">
      and AutoGen:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.665.1">
           LangGraph
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.666.1">
           CrewAI
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.667.1">
           AutoGen
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.668.1">
          State management
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.669.1">
         Uses
        </span>
        <a id="_idIndexMarker463">
        </a>
        <span class="koboSpan" id="kobo.670.1">
         explicit
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.671.1">
          state management
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.672.1">
         Manages
        </span>
        <a id="_idIndexMarker464">
        </a>
        <span class="koboSpan" id="kobo.673.1">
         state through agent instances and their
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.674.1">
          task context
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.675.1">
         Handles
        </span>
        <a id="_idIndexMarker465">
        </a>
        <span class="koboSpan" id="kobo.676.1">
         state through group chat
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.677.1">
          message history
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.678.1">
          Tool integration
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.679.1">
         Tools
        </span>
        <a id="_idIndexMarker466">
        </a>
        <span class="koboSpan" id="kobo.680.1">
         are managed through a dedicated
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.681.1">
          tool node
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.682.1">
         Uses a
        </span>
        <a id="_idIndexMarker467">
        </a>
        <span class="koboSpan" id="kobo.683.1">
         decorator-based tool definition with direct
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.684.1">
          agent association
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.685.1">
         Associates
        </span>
        <a id="_idIndexMarker468">
        </a>
        <span class="koboSpan" id="kobo.686.1">
         tools directly with
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.687.1">
          specific agents
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.688.1">
          Flow control
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.689.1">
         Uses a
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.690.1">
          graph-based workflow
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.691.1">
         Uses hierarchical task decomposition or
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.692.1">
          sequential flow
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.693.1">
         Implements round-robin turn-taking
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.694.1">
          between agents
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.695.1">
     Table 5.1 – Comparison of LangGraph, CrewAI, and AutoGen implementation approaches
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.696.1">
     The preceding table shows the differences between LangGraph, CrewAI, and AutoGen based on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.697.1">
      our implementation.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-124">
    <a id="_idTextAnchor134">
    </a>
    <span class="koboSpan" id="kobo.698.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.699.1">
     In this chapter, we learned about the crucial role of tools and planning in AI agent systems.
    </span>
    <span class="koboSpan" id="kobo.699.2">
     We discussed what tool/function calling is and how LLM agents exhibit this property.
    </span>
    <span class="koboSpan" id="kobo.699.3">
     We also learned about various tool types and saw examples of how to use tools with frameworks or natively with an LLM.
    </span>
    <span class="koboSpan" id="kobo.699.4">
     Subsequently, we explored various planning algorithms, from traditional approaches such as STRIPS and HTN to modern LLM-based planning methods, understanding their relative practicality in the context of language models.
    </span>
    <span class="koboSpan" id="kobo.699.5">
     Through a practical travel planning example, we saw how tools can be defined, integrated, and utilized within each framework to create sophisticated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.700.1">
      planning systems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.701.1">
     We learned how integrating tool calling with planning can supercharge agentic systems by making them more capable of handling complex tasks.
    </span>
    <span class="koboSpan" id="kobo.701.2">
     We also reviewed the implementation patterns across three frameworks (CrewAI, AutoGen, and LangGraph), which revealed distinct approaches to agent coordination and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.702.1">
      tool usage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.703.1">
     In the next chapter, we will dive into the concepts of the coordinator, worker, and delegator approach in agentic systems, and learn how they can help with completing complex
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.704.1">
      real-world tasks.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-125">
    <a id="_idTextAnchor135">
    </a>
    <span class="koboSpan" id="kobo.705.1">
     Questions
    </span>
   </h1>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.706.1">
      What is the purpose of tools in AI agents, and how do docstrings help in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.707.1">
       tool definition?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.708.1">
      Explain the difference between traditional planning algorithms (such as STRIPS) and modern LLM-based planning.
     </span>
     <span class="koboSpan" id="kobo.708.2">
      Why are traditional algorithms less practical for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.709.1">
       LLM agents?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.710.1">
      How does HTN planning work, and why is it considered one of the more practical approaches for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.711.1">
       LLM agents?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.712.1">
      What role does reasoning play in tool selection for LLM agents, and what are
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.713.1">
       its limitations?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.714.1">
      When comparing frameworks (CrewAI, AutoGen, and LangGraph), what are the key factors to consider for an AI
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.715.1">
       agent implementation?
      </span>
     </span>
    </li>
   </ol>
   <h1 id="_idParaDest-126">
    <a id="_idTextAnchor136">
    </a>
    <span class="koboSpan" id="kobo.716.1">
     Answers
    </span>
   </h1>
   <ol>
    <li value="1">
     <span class="koboSpan" id="kobo.717.1">
      Tools in AI agents are functions that enable agents to perform specific tasks or access external services.
     </span>
     <span class="koboSpan" id="kobo.717.2">
      Docstrings provide crucial information about the tool’s purpose, expected parameters, and return values, helping the LLM understand when and how to use each tool effectively.
     </span>
     <span class="koboSpan" id="kobo.717.3">
      This documentation serves as the context that guides the model’s
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.718.1">
       decision-making process.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.719.1">
      Traditional planning algorithms such as STRIPS rely on explicit state representations and predefined action sets, working with binary conditions and clear state transitions.
     </span>
     <span class="koboSpan" id="kobo.719.2">
      LLM-based planning, however, operates with natural language understanding and can handle ambiguous states and actions.
     </span>
     <span class="koboSpan" id="kobo.719.3">
      Traditional algorithms struggle with LLMs because they can’t effectively represent the nuanced, contextual nature of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.720.1">
       language-based tasks.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.721.1">
      HTN planning works by breaking down complex tasks into progressively simpler subtasks in a hierarchical structure.
     </span>
     <span class="koboSpan" id="kobo.721.2">
      It’s practical for LLM agents because this hierarchical decomposition mirrors how language models naturally process and understand tasks.
     </span>
     <span class="koboSpan" id="kobo.721.3">
      The approach allows for both structured planning and the flexibility needed for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.722.1">
       language-based interactions.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.723.1">
      Reasoning in LLM agents is largely handled by the model’s built-in capabilities to understand context and make decisions.
     </span>
     <span class="koboSpan" id="kobo.723.2">
      While this makes tool selection more natural, not all models are equally capable.
     </span>
     <span class="koboSpan" id="kobo.723.3">
      Limitations include potential inconsistencies in tool selection, difficulties with complex tool combinations, and challenges in error recovery when
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.724.1">
       tools fail.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.725.1">
      Key factors for framework selection include the complexity of the workflow (structured versus conversational), the need for state management, multi-agent collaboration requirements, and development complexity.
     </span>
     <span class="koboSpan" id="kobo.725.2">
      CrewAI offers straightforward implementation, AutoGen excels at multi-agent interaction, and LangGraph provides robust workflow control but requires
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.726.1">
       more setup.
      </span>
     </span>
    </li>
   </ol>
   <h1 id="_idParaDest-127">
    <a id="_idTextAnchor137">
    </a>
    <span class="koboSpan" id="kobo.727.1">
     Join our communities on Discord and Reddit
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.728.1">
     Have questions about the book or want to contribute to discussions on Generative AI and LLMs?
    </span>
    <span class="koboSpan" id="kobo.728.2">
     Join our Discord server at
    </span>
    <a href="https://packt.link/I1tSU">
     <span class="koboSpan" id="kobo.729.1">
      https://packt.link/I1tSU
     </span>
    </a>
    <span class="koboSpan" id="kobo.730.1">
     and our Reddit channel at
    </span>
    <a href="https://packt.link/ugMW0">
     <span class="koboSpan" id="kobo.731.1">
      https://packt.link/ugMW0
     </span>
    </a>
    <span class="koboSpan" id="kobo.732.1">
     to connect, share, and collaborate with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.733.1">
      like-minded enthusiasts.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer060">
     <span class="koboSpan" id="kobo.734.1">
      <img alt="img" role="presentation" src="image/B31483_Discord_QR_new.jpg"/>
     </span>
    </div>
   </div>
   <p>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer061">
     <span class="koboSpan" id="kobo.735.1">
      <img alt="img" role="presentation" src="image/qrcode_Reddit_Channel.jpg"/>
     </span>
    </div>
   </div>
  </div>
 </body></html>