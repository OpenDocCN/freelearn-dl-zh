["```py\n    def __init__(self, big_pos, small_pos, field_size):\n        self.big_pos = big_pos\n        self.small_pos = small_pos\n        self.field_size = field_size\n        self.data = np.zeros((field_size, field_size))\n\n        # store small object position\n        self._set_point(small_pos[0], small_pos[1])\n\n        # store big object points\n        offsets = [-1, 0, 1]\n        for xo in offsets:\n            for yo in offsets:\n                self._set_point(big_pos[0] + xo, big_pos[1] + yo)\n```", "```py\n        offsets = [-1, 0, 1]\n        for xo in offsets:\n            for yo in offsets:\n                self._set_point(big_pos[0] + xo, big_pos[1] + yo)\n```", "```py\n    def _set_point(self, x, y):\n        px, py = x, y\n        if px < 0:\n            px = self.field_size + px\n        elif px >= self.field_size:\n            px = px - self.field_size\n\n        if py < 0:\n            py = self.field_size + py\n        elif py >= self.field_size:\n            py = py - self.field_size\n\n        self.data[py, px] = 1 # in Numpy index is: [row, col]\n```", "```py\n        if px < 0:\n            px = self.field_size + px\n        elif px >= self.field_size:\n            px = px - self.field_size\n```", "```py\n    def __init__(self, small_object_positions, big_object_offset, \n                 field_size):\n        self.s_object_pos = small_object_positions\n        self.data_set = []\n        self.b_object_offset = big_object_offset\n        self.field_size = field_size\n\n        self.max_dist = self._distance((0, 0), \n                             (field_size - 1, field_size - 1))\n\n        # create test data set\n        self._create_data_set()\n```", "```py\nself.max_dist = self._distance((0, 0), \n                     (field_size - 1, field_size - 1))\n```", "```py\n    def _create_data_set(self):\n        for x in self.s_object_pos:\n            for y in self.s_object_pos:\n                # diagonal\n                vf = self._create_visual_field(x, y, \n                                  x_off=self.b_object_offset, \n                                  y_off=self.b_object_offset)\n                self.data_set.append(vf)\n                # right\n                vf = self._create_visual_field(x, y, \n                                  x_off=self.b_object_offset,\n                                  y_off=0)\n                self.data_set.append(vf)\n                # down\n                vf = self._create_visual_field(x, y, \n                                  x_off=0, \n                                  y_off=self.b_object_offset)\n                self.data_set.append(vf)\n```", "```py\n    def _create_visual_field(self, sx, sy, x_off, y_off):\n        bx = (sx + x_off) % self.field_size # wrap by X coordinate\n        by = (sy + y_off) % self.field_size # wrap by Y coordinate\n\n        # create visual field\n        return VisualField(big_pos=(bx, by), small_pos=(sx, sy), \n                           field_size=self.field_size)\n```", "```py\n        if bx >= self.field_size:\n            bx = bx - self.field_size # wrap\n```", "```py\n    def evaluate_net(self, net):\n        avg_dist = 0\n\n        # evaluate predicted positions\n        for ds in self.data_set:\n            # evaluate and get outputs\n            outputs, x, y = self.evaluate_net_vf(net, ds)\n\n            # find the distance to the big object\n            dist = self._distance((x, y), ds.big_pos)\n            avg_dist = avg_dist + dist\n\n        avg_dist /= float(len(self.data_set))\n\n        # normalized position error\n        error = avg_dist / self.max_dist\n        # fitness\n        fitness = 1.0 - error\n\n        return fitness, avg_dist\n```", "```py\n        for ds in self.data_set:\n            # evaluate and get outputs\n            _, x, y = self.evaluate_net_vf(net, ds)\n\n            # find the distance to the big object\n            dist = self._distance((x, y), ds.big_pos)\n            avg_dist = avg_dist + dist\n\n        avg_dist /= float(len(self.data_set))\n```", "```py\n        # normalized detection error\n        error = avg_dist / self.max_dist\n```", "```py\n        # fitness\n        fitness = 1.0 - error\n```", "```py\n   def evaluate_net_vf(self, net, vf):\n        depth = 1 # we just have 2 layers\n\n        net.Flush()\n        # prepare input\n        inputs = vf.get_data()\n        net.Input(inputs)\n        # activate\n        [net.Activate() for _ in range(depth)]\n\n        # get outputs\n        outputs = net.Output()\n        # find coordinates of big object\n        x, y = self._big_object_coordinates(outputs)\n\n        return outputs, x, y\n```", "```py\n        inputs = vf.get_data()\n        net.Input(inputs)\n```", "```py\n    def _big_object_coordinates(self, outputs):\n        max_activation = -100.0\n        max_index = -1\n        for i, out in enumerate(outputs):\n            if out > max_activation:\n                max_activation = out\n                max_index = i\n\n        # estimate the maximal activation's coordinates\n        x = max_index % self.field_size\n        y = int(max_index / self.field_size)\n\n        return (x, y)\n```", "```py\n        max_activation = -100.0\n        max_index = -1\n        for i, out in enumerate(outputs):\n            if out > max_activation:\n                max_activation = out\n                max_index = I\n```", "```py\n        x = max_index % self.field_size\n        y = int(max_index / self.field_size)\n```", "```py\n    # random seed\n    seed = int(time.time())\n    # Create substrate\n    substrate = create_substrate(num_dimensions)\n    # Create CPPN genome and population\n    g = NEAT.Genome(0,\n                    substrate.GetMinCPPNInputs(),\n                    0,\n                    substrate.GetMinCPPNOutputs(),\n                    False,\n                    NEAT.ActivationFunction.UNSIGNED_SIGMOID,\n                    NEAT.ActivationFunction.UNSIGNED_SIGMOID,\n                    0,\n                    params, 0)\n    pop = NEAT.Population(g, params, True, 1.0, seed)\n    pop.RNG.Seed(seed)\n```", "```py\n    start_time = time.time()\n    best_genome_ser = None\n    best_ever_goal_fitness = 0\n    best_id = -1\n    solution_found = False\n\n    stats = Statistics()\n    for generation in range(n_generations):\n```", "```py\n        genomes = NEAT.GetGenomeList(pop)\n        # evaluate genomes\n        genome, fitness, distances = eval_genomes(genomes, \n                                      vd_environment=vd_environment, \n                                      substrate=substrate, \n                                      generation=generation)\n        stats.post_evaluate(max_fitness=fitness, distances=distances)\n        solution_found = fitness >= FITNESS_THRESHOLD\n```", "```py\n        if solution_found or best_ever_goal_fitness < fitness:\n            best_genome_ser = pickle.dumps(genome)\n            best_ever_goal_fitness = fitness\n            best_id = genome.GetID()\n```", "```py\n        if solution_found:\n            print('Solution found at generation: %d, best fitness: %f, species count: %d' % (generation, fitness, len(pop.Species)))\n            break\n```", "```py\n        # advance to the next generation\n        pop.Epoch()\n        # print statistics\n        gen_elapsed_time = time.time() - gen_time\n        print(\"Best fitness: %f, genome ID: %d\" % (fitness, best_id))\n        print(\"Species count: %d\" % len(pop.Species))\n        print(\"Generation elapsed time: %.3f sec\" % (gen_elapsed_time))\n        print(\"Best fitness ever: %f, genome ID: %d\" \n               % (best_ever_goal_fitness, best_id))\n```", "```py\n    print(\"\\nBest ever fitness: %f, genome ID: %d\" \n          % (best_ever_goal_fitness, best_id))\n    print(\"\\nTrial elapsed time: %.3f sec\" % (elapsed_time))\n    print(\"Random seed:\", seed)\n```", "```py\n    # Visualize the experiment results\n    show_results = not silent\n    if save_results or show_results:\n        net = NEAT.NeuralNetwork()\n        best_genome.BuildPhenotype(net)\n        visualize.draw_net(net, view=show_results, node_names=None, \n                           directory=trial_out_dir, fmt='svg')\n```", "```py\n\n        # Visualize activations from the best genome\n        net = NEAT.NeuralNetwork()\n        best_genome.BuildHyperNEATPhenotype(net, substrate)\n        # select random visual field\n        index = random.randint(0, len(vd_environment.data_set) - 1)\n        vf = vd_environment.data_set[index]\n        # draw activations\n        outputs, x, y = vd_environment.evaluate_net_vf(net, vf)\n        visualize.draw_activations(outputs, found_object=(x, y), vf=vf,\n                  dimns=num_dimensions, view=show_results, \n                  filename=os.path.join(trial_out_dir, \n                                        \"best_activations.svg\"))\n```", "```py\n        # Visualize statistics\n        visualize.plot_stats(stats, ylog=False, view=show_results, \n                  filename=os.path.join(trial_out_dir, 'avg_fitness.svg'))\n```", "```py\ndef create_substrate(dim):\n    # Building sheet configurations of inputs and outputs\n    inputs = create_sheet_space(-1, 1, dim, -1)\n    outputs = create_sheet_space(-1, 1, dim, 0)\n    substrate = NEAT.Substrate( inputs, [], # hidden outputs)\n    substrate.m_allow_input_output_links = True\n    ...\n    substrate.m_hidden_nodes_activation = \\\n                  NEAT.ActivationFunction.SIGNED_SIGMOID\n    substrate.m_output_nodes_activation = \\\n                  NEAT.ActivationFunction.UNSIGNED_SIGMOID\n    substrate.m_with_distance = True\n    substrate.m_max_weight_and_bias = 3.0\n    return substrate\n```", "```py\n    inputs = create_sheet_space(-1, 1, dim, -1)\n    outputs = create_sheet_space(-1, 1, dim, 0)\n    substrate = NEAT.Substrate( inputs, [], # hidden outputs)\n```", "```py\ndef create_sheet_space(start, stop, dim, z):\n    lin_sp = np.linspace(start, stop, num=dim)\n    space = []\n    for x in range(dim):\n        for y in range(dim):\n            space.append((lin_sp[x], lin_sp[y], z))\n\n    return space\n```", "```py\n    lin_sp = np.linspace(start, stop, num=dim)\n```", "```py\n    space = []\n    for x in range(dim):\n        for y in range(dim):\n            space.append((lin_sp[x], lin_sp[y], z))\n```", "```py\ndef eval_genomes(genomes, substrate, vd_environment, generation):\n    best_genome = None\n    max_fitness = 0\n    distances = []\n    for genome in genomes:\n        fitness, dist = eval_individual(genome, substrate, \n                                        vd_environment)\n        genome.SetFitness(fitness)\n        distances.append(dist)\n\n        if fitness > max_fitness:\n            max_fitness = fitness\n            best_genome = genome\n\n    return best_genome, max_fitness, distances\n```", "```py\n    best_genome = None\n    max_fitness = 0\n    distances = []\n```", "```py\n    for genome in genomes:\n        fitness, dist = eval_individual(genome, substrate, \n                                        vd_environment)\n        genome.SetFitness(fitness)\n        distances.append(dist)\n\n        if fitness > max_fitness:\n            max_fitness = fitness\n            best_genome = genome\n```", "```py\ndef eval_individual(genome, substrate, vd_environment):\n    # Create ANN from provided CPPN genome and substrate\n    net = NEAT.NeuralNetwork()\n    genome.BuildHyperNEATPhenotype(net, substrate)\n\n    fitness, dist = vd_environment.evaluate_net(net)\n    return fitness, dist\n```", "```py\n    params = NEAT.Parameters()\n```", "```py\n    params.PopulationSize = 150\n```", "```py\n    params.MutateAddLinkProb = 0.1\n    params.MutateAddNeuronProb = 0.03\n```", "```py\n    params.MutateNeuronActivationTypeProb = 0.3\n    params.ActivationFunction_SignedGauss_Prob = 1.0\n    params.ActivationFunction_SignedSigmoid_Prob = 1.0\n    params.ActivationFunction_SignedSine_Prob = 1.0\n    params.ActivationFunction_Linear_Prob = 1.0\n```", "```py\n    params.SpeciesMaxStagnation = 100\n    params.MinSpecies = 5\n    params.MaxSpecies = 10\n```", "```py\n$ conda create --name vd_multineat python=3.5\n$ conda activate vd_multineat\n$ conda install -c conda-forge multineat \n$ conda install matplotlib\n$ conda install -c anaconda seaborn\n$ conda install graphviz\n$ conda install python-graphviz\n```", "```py\n$ python vd_experiment_multineat.py\n```", "```py\n****** Generation: 16 ******\n\nBest fitness: 0.995286, genome ID: 2410\nSpecies count: 11\nGeneration elapsed time: 3.328 sec\nBest fitness ever: 0.995286, genome ID: 2410\n\n****** Generation: 17 ******\n\nSolution found at generation: 17, best fitness: 1.000000, species count: 11\n\nBest ever fitness: 1.000000, genome ID: 2565\n\nTrial elapsed time: 57.753 sec\nRandom seed: 1568629572\n\nCPPN nodes: 10, connections: 16\n\nRunning test evaluation against random visual field: 41\nSubstrate nodes: 242, connections: 14641\nfound (5, 1)\ntarget (5, 1)\n```"]