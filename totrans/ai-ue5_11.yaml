- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the Environment Query System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Environment Query System** ( **EQS** ) in Unreal Engine is a powerful
    feature within the AI framework that allows developers to collect data about the
    virtual environment by letting AI agents query the environment and make informed
    decisions based on the returned results. In this chapter, you will learn how to
    properly set up an environment query and how to integrate it inside the behavior
    tree of an AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: By mastering the EQS, you’ll gain the power to create intelligent AI systems
    that can make informed decisions based on their surroundings. Whether it’s finding
    the best vantage point, locating crucial resources, or strategizing for optimal
    gameplay, the EQS opens a world of possibilities. While still an experimental
    feature, learning about the EQS will let you create intelligent and dynamic AI
    systems in Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Environment Query System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an environment query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling environment queries within a behavior tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying EQS information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in this book’s
    companion project repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 10** **-** **End** link.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Environment Query System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, it seems Dr. Markus is making some progress in his secret lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Deep within the hidden confines of their secret laboratory, Dr. Markus and
    Professor Viktoria toiled tirelessly on their latest endeavor; they were determined
    to revolutionize their AI dummy puppets by granting them the ability to analyze
    and probe their environment in* *unprecedented ways.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*With their minds brimming with excitement, Dr. Markus and Professor Viktoria
    meticulously crafted intricate algorithms as they imbued their creations with
    an insatiable hunger for knowledge, equipping them with experimental methods to
    observe and interact with the world around them. As the AI dummy puppets awakened,
    their eyes flickered with a newfound spark of intelligence, each one exploring
    its surroundings and analyzing* *the environment.*'
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine’s EQS is a powerful tool that allows developers to define complex
    queries to gather information about the game world. The EQS enables developers
    to create AI behaviors that can dynamically adapt to changing environmental conditions.
    By using the EQS, NPCs or other game entities can make intelligent decisions based
    on their surroundings. With its flexibility and ease of use, the EQS is a valuable
    feature in Unreal Engine for creating immersive and interactive gameplay experiences.
  prefs: []
  type: TYPE_NORMAL
- en: With the EQS, you can inquire about gathered data using a set of **tests** that
    will generate elements that align most closely with the nature of the query posed.
  prefs: []
  type: TYPE_NORMAL
- en: An **EQS query** can be triggered inside a behavior tree – or, alternatively,
    through scripting – to guide decisions based on the result of tests. These queries
    mainly consist of **generators** (elements that determine the locations or actors
    to be tested and weighted) and **contexts** (elements that provide a reference
    frame for tests or generators). EQS queries empower AI characters to locate optimal
    positions for tasks such as attacking a player with a line of sight, retrieving
    health or ammo pickups, or seeking the nearest cover point, among other options.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by examining all these elements in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A generator creates the locations or actors – known as **items** – that will
    undergo testing and weighting; the result will be returned to the behavior tree
    to which the query belongs. Generators that are available out of the box are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actors of Class** : This will find all actors of a given class returning
    them as items for tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite** : This will let you create an array of generators and use them
    for tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current Location** : This will let you get the location of a specified context
    and use it to validate tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Points** : Generators can be used to create shape-based traces – **Circle**
    , **Cone** , **Donut** , **Grid** , and **Pathing Grid** – around a predefined
    location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s more, you may implement your own by extending the **EnvQueryGenerator**
    class (if developing in C++) or **EnvQueryGenerator_BlueprintBase** (if developing
    with Blueprints).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Generators created in C++ typically run faster than those developed in Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A context supplies a point of reference for the different tests and generators
    and can range from the **querier** – the pawn currently possessed by the AI controller
    executing the behavior tree – to more complex scenarios involving all actors of
    a certain type. A generator, such as **Points: Circle** , can use a context that
    will provide multiple locations or actors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Available **Context** classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EnvQueryContext_Item** : This represents either a location – as a vector
    – or an actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EnvQueryContext_Querier** : This represents the querier executing the behavior
    tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have guessed, you may implement your own context by extending the
    **EnvQueryContext** class if developing in C++ or **EnvQueryContext_BlueprintBase**
    if developing with Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A test determines the criteria used by the **environment query** – the actual
    request to the environment – to select the optimal Item from the generator, given
    a context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the out-of-the-box available tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance** : This will return the distance between the item location and
    another location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overlap: Box** : This can be used to check whether an item is within the
    bounds defined by the test itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PathExists: from Querier** : This can be used to check whether a path to
    the context exists and will return some useful information about it, such as how
    long the path is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may implement your own tests by extending the **EnvQueryTest** class both
    in C++ and Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have acquired a basic understanding of the main EQS elements, it
    is time to delve deeper and begin implementing a fully working and effective AI
    agent with it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an environment query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll be learning how to add a query to a behavior tree; in
    particular, we will be tweaking the dummy gunner AI brain in order to let it shoot
    at a target achieved by an environment query.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, the EQS is still an experimental feature, so you should
    use caution if you want to develop a game using it. At the time of writing this
    book, the EQS is enabled by default by using the **Environment Query** **Editor**
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a first step, we are going to create a proper gym, so start by doing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a level of your choice, starting from the Level Instances and Packed
    Level Actors, which I provided in the project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **BP_GunnerDummyCharacter** instance; just remember to check **Use Controller
    Rotation Yaw** so it will be able to rotate and point to the target when prompted
    to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or more **BP_Target** instances so that your AI character will have
    a line of sight to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some obstacles that will block the line of sight with the AI agent. The
    final gym should look similar to the one depicted in *Figure 11* *.1* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Finished gym](img/Figure_11.1_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Finished gym
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to set up the AI controller for the AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AI controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second step is to create a dedicated behavior tree and an AI controller,
    so do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **AI** folder, create a new behavior tree and call it **BT_EQSGunnerDummy**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Blueprints** folder, create a new Blueprint class extending from **BaseDummyAIController**
    , name it **AIEQSGunnerDummyController** , and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, look for the **Dummy AI Controller** category and
    set the **Behavior Tree** attribute to **BT_EQSGunnerDummy** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the gunner dummy in the level and set its **AI Controller Class** attribute
    to **AIEQSGunnerDummyController** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the AI controller and its controller character are properly set, it’s
    time to set up an environment query that we will be using in the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an environment query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to create an environment query that will look for a viable
    target in the level. This is going to be pretty similar to the **FindAvailableTarget**
    task we implemented in [*Chapter 9*](B31016_09.xhtml#_idTextAnchor170) , *Extending
    Behavior Trees* , with a couple of differences; we will be searching for instances
    of a particular class and the target will need to be in line of sight with the
    gunner. Additionally, we won’t be writing a single line of code. So, let’s start
    by doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **AI** folder, right-right click and select **Artificial Intelligence**
    | **Environment Query** to create one such asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset **EQS_FindTarget** and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be presented with a graph named **Query Graph** (pretty similar to
    the behavior tree one) that will let you implement your own query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click and drag from the **ROOT** node and add an **Actors of Class** generator
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the newly created node and, in the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Searched Actor Class** attribute to **BP_Target**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Search Radius** attribute to **3000.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click on the **ActorsOfClass** node and select **Add Test** | **Trace**
    ; a test will be added inside the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the test and, in the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Test Purpose** attribute to **Filter Only**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Item Height Offset** attribute to **50.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Context Height Offset** attribute to **50.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncheck the **Bool** **Match** attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete graph for the environment query is depicted in *Figure 11* *.2*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Finished environment query](img/Figure_11.2_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Finished environment query
  prefs: []
  type: TYPE_NORMAL
- en: What we have done here obviously needs some explanation; we have added a generator
    that will look for all actors of a certain class – **BP_Target** – that are near
    the querier (the AI agent executing this environment query). Only the items that
    are in line of sight with the queries will pass the trace test and so they will
    be the only ones that will be considered for selecting a viable target. **Test
    Purpose** has been set to **Filter Only** because we only need to have a list
    of Items and are not interested in their importance – or **score** – in the search.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the environment query has been defined, we can start implementing the
    behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Handling environment queries within a behavior tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to implement the behavior tree, which, as you will see, shows
    some similarities with the **BT_GunnerDummy** asset; the only difference is the
    way we get possible targets. For this reason, we will be using the same Blackboard
    as **BT_GunnerDummy** . So, without further ado, open **BT_EQSGunnerDummy** and,
    in the **Details** panel, set the **Blackboard Asset** attribute to **BB_GunnerDummy**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, focus on the behavior tree graph and do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Selector** node to the **ROOT** node and name it **Root Selector** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Sequence** node to the **Root Selector** node and name it **Shoot Sequence**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Blackboard** decorator to the **Shoot Sequence** node and name it **Has
    Ammo?** . In the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Notify Observers** attribute to **On** **Value Change**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Key Query** attribute to **Is** **Not Set**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Blackboard Key** attribute to **NeedsReload**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The graph so far should look like the one shown in *Figure 11* *.3* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Starting graph](img/Figure_11.3_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Starting graph
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s connect the environment query to the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Run EQSQuery** task to **Shoot Sequence** and name it **Find** **Visible
    Target** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the task selected, do the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Query Template** attribute to **EQS_FindTarget** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Run Mode** attribute to **Single Random Item from** **Best 25%** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Blackboard Key** attribute to **TargetActor** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What we are doing here is executing the environment query and, once the resulting
    items are returned, we select a random one and assign it to the **TargetActor**
    key of the Blackboard so it will be available to the behavior tree. Now, let’s
    continue our AI logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add **RotateToFaceBBEntry** to **Shoot Sequence** at the right of the **Find
    Visible Target** node and name it **Rotate** **Towards Target** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the newly created node and set the **Blackboard Key** attribute to **TargetActor**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be already familiar with this portion of the graph; we are simply
    rotating the AI agent toward the target, in order to be ready to shoot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s go on with the graph.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a **Play Montage** node to the **Shoot Sequence** node, at the right of
    the **Rotate Towards Target** node and name it **Shoot Montage** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Anim Montage** property to **AM_1H_Shoot** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Set Ammo** service to the node and name it **Deplete Ammo** . In the
    **Details** panel, do the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Needs Reload** property to **NeedsReload**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the **Key** **Value** property
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This will start the shooting animation montage and, subsequently, will spawn
    a projectile.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a **Wait** task to **Shoot Sequence** at the right of the **Shoot Montage**
    node, setting the **Wait Time** attribute to **2.0** and the **Random Deviation**
    attribute to **0.5** . This portion of the graph should look like the one depicted
    in *Figure 11* *.4* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Shoot sequence](img/Figure_11.4_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Shoot sequence
  prefs: []
  type: TYPE_NORMAL
- en: We now need to create the reload sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Sequence** node to **Root Selector** at the right of **Shoot Sequence**
    and name it **Reload Sequence** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Play Montage** node to the **Reload Sequence** node and name it **Reload
    Montage** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Anim Montage** property to **AM_1H_Reload** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Set Ammo** service to the node and name it **Refill Ammo** . In the
    **Details** panel, do the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Needs Reload** property to **NeedsReload**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the **Key Value** property unchecked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a **Wait** task to **Reload Sequence** at the right of the **Reload Montage**
    node, setting the **Wait Time** attribute to **2.0** and the **Random Deviation**
    attribute to **0.5** . This portion of the graph is depicted in *Figure 11* *.5*
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Reload sequence](img/Figure_11.5_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Reload sequence
  prefs: []
  type: TYPE_NORMAL
- en: The behavior tree is now finished and ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we showed how to integrate an environment query inside a behavior
    tree; in the next section, we will be testing its functionality, and I will show
    you how to use the debugging tools with it.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying EQS information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test your gym, just start the simulation; you should notice the following
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: The AI agent will shoot at a target and then reload the weapon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AI agent will avoid shooting at targets that are not in the line of sight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This behavior should go on indefinitely; that’s perfectly fine as the gunner
    is looking for targets by searching for the **BP_Target** class. To improve the
    gym, you may wish to implement some extra logic, such as a destroy system for
    targets that have been hit or a points counter for each target that has been hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show on the screen what’s happening, you will need to enable the debugging
    tools, as explained in [*Chapter 6*](B31016_06.xhtml#_idTextAnchor116) , *Optimizing
    the Navigation System* . Once the debugging tools are enabled, you will just need
    to hit the *3* key on your numpad to show the EQS information and then select
    the AI agent; in our case, you should see a set of information similar to the
    one depicted in *Figure 11* *.6* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – EQS debugging](img/Figure_11.6_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – EQS debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, each environment query will have its own information. In this example,
    you will notice that each target will show some data and a red wireframe, and
    the selected target will be marked as a **Winner** , as shown in *Figure 11* *.7*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Selected target](img/Figure_11.7_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Selected target
  prefs: []
  type: TYPE_NORMAL
- en: 'Targets that won’t be in the line of sight with the querier will be labeled
    as **Trace(0)** to show that the trace failed, as shown in *Figure 11* *.8* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Target not in the line of sight](img/Figure_11.8_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Target not in the line of sight
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more detailed information for each item in the query, as shown
    in *Figure 11* *.9* , you may want to hit the divide key ( */* ) from the numpad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Detailed information](img/Figure_11.9_B31016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Detailed information
  prefs: []
  type: TYPE_NORMAL
- en: I highly encourage you to create your own queries and test them in the level.
    Using the debugging tools can be a significant time-saver during the development
    of your project. Take full advantage of these tools to streamline your workflow
    and enhance efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw a new way – although experimental – to let your AI agents
    probe the level and gather information in order to make meaningful decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with a bit of theory, we created an environment query, developed a
    fully operational behavior tree utilizing environment queries effectively, and
    tested it in a gym setting. Furthermore, we explored the use of debugging tools
    to analyze the activities within the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes *Part 3* of this book. In the upcoming chapters, we will delve
    into new features within the AI framework, beginning with a glimpse at an alternative
    method of implementing AI agents: hierarchical state machines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Exploring Advanced Topics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the fourth part of this book, you will be presented with some cutting-edge
    and experimental AI features within the Unreal Engine ecosystem. Additionally,
    you will gain knowledge on how to integrate these features within your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B31016_12.xhtml#_idTextAnchor233) , *Using Hierarchical State
    Machines with State Trees*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B31016_13.xhtml#_idTextAnchor251) , *Implementing Data-Oriented
    Calculations with Mass*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B31016_14.xhtml#_idTextAnchor270) , *Implementing Interactable
    Elements with Smart Objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
