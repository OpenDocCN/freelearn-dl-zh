- en: '*Chapter 9*: Behavior Trees'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：行为树'
- en: 'In a preceding chapter, we saw a basic but effective way to implement and manage
    character states and behaviors: **finite state machines** (**FSMs**). FSMs are
    simple to implement and intuitive, but they have a fatal flaw: it is tough to
    make them scale once there are many states and transitions. For example, imagine
    a character that behaves differently depending on its health and mana (high, medium,
    or low). We have a state in which both health and mana are high, one in which
    health is medium and mana is high, one in which they are both medium, and so on.
    In total, we have nine states just for those. If we add other conditions (such
    as player proximity, time of day, equipment, player''s score, or whatever you
    may imagine), the number of states grows exponentially.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了实现和管理角色状态和行为的基本但有效的方法：**有限状态机**（**FSMs**）。FSMs易于实现且直观，但它们有一个致命的缺陷：一旦有多个状态和转换，就很难进行扩展。例如，想象一个根据其健康和魔法值（高、中、低）表现不同的角色。我们有一个状态，其中健康和魔法值都高，一个状态是健康中等而魔法值高，一个状态是两者都中等，以此类推。仅这些状态就有九种。如果我们添加其他条件（如玩家接近度、一天中的时间、装备、玩家的得分或你可以想象的其他任何条件），状态的数量将以指数级增长。
- en: 'Luckily, we have a solution: **behavior trees** (**BTs**). In essence, BTs
    are just another way to visualize complex FSMs, but they are fast, provide reusability,
    and are easy to maintain. After their introduction in 2004 with *Halo 2*, they
    quickly became the preferred decision-making technique in games.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一个解决方案：**行为树**（**BTs**）。本质上，BTs只是另一种可视化复杂FSMs的方法，但它们速度快，提供可重用性，且易于维护。自2004年随着*Halo
    2*的引入，它们迅速成为游戏中的首选决策技术。
- en: 'In this chapter, we will be doing the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将做以下工作：
- en: Exploring the basic principles of BTs, knowledge that you will be able to transfer
    to any BT plugin available for Unity (or other game engines)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索BTs的基本原理，这些知识你可以将其转移到任何适用于Unity（或其他游戏引擎）的BT插件
- en: 'Implementing a small demo based on a popular free Unity plugin for BTs: **Behavior
    Bricks**'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于流行的免费Unity插件BTs（行为砖块）实现一个小型演示：**行为砖块**
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you need Unity3D 2022 and the free plugin for Unity, *Behavior
    Bricks*. Don''t worry, we will see how to install this plugin together. You can
    find the example project described in this chapter in the `Chapter 9` folder in
    the book repository here: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter09).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Unity3D 2022和免费的Unity插件，*行为砖块*。不用担心，我们将一起看看如何安装这个插件。你可以在本书仓库中的`第9章`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter09)。
- en: Introduction to BTs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BTs简介
- en: A BT is a hierarchical tree of nodes that controls the AI character's behavior
    flow. It can also be used to coordinate groups of characters (for example, to
    model the attack pattern of a small platoon), or even disembodied agents such
    as an AI story director.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: BT（行为树）是一个控制AI角色行为流程的节点层次树。它也可以用来协调角色组（例如，模拟小部队的攻击模式），甚至无形的代理，如AI故事导演。
- en: 'When we execute a BT''s node, the node can return three states: **success**,
    **failure**, or **running** (if the node''s execution is spread over multiple
    frames, for instance, if it plays an animation). When the BT executor runs a tree,
    it starts from the root and executes every node in order, according to rules written
    in the nodes themselves.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行BT的节点时，节点可以返回三种状态：**成功**、**失败**或**运行中**（如果节点的执行跨越多个帧，例如，如果它在播放动画）。当BT执行器运行树时，它从根节点开始，按照节点本身写入的规则顺序执行每个节点。
- en: 'A node can be of three types:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以是三种类型之一：
- en: A **task** (a node without children), also called a **leaf**.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**（无子节点的节点），也称为**叶节点**。'
- en: A **decorator** (a node with a single child)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**（具有单个子节点的节点）'
- en: A **composite** (a node with multiple children)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**（具有多个子节点的节点）'
- en: In general, leaves represent the *Action* that the characters can do or know
    (that is why they are commonly called an **Action** or **Task**); they may be
    actions such as **GoToTarget**, **OpenDoor**, **Jump**, or **TakeCover**, but
    also things like **IsObjectNear?** or **IsHealthLow?**. These actions depend on
    the character, the game, and the general game implementation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，叶子代表角色可以执行或知道的操作（这就是为什么它们通常被称为**动作**或**任务**）；它们可能是**GoToTarget**、**OpenDoor**、**Jump**或**TakeCover**等动作，也可能是**IsObjectNear?**或**IsHealthLow?**等事物。这些操作取决于角色、游戏以及一般的游戏实现。
- en: A **decorator** is a node that modifies (decorates) the sub-tree under it (therefore,
    it can decorate both composite and task nodes). For example, a standard decorator
    is the **Negate** node. The node inverts the return value of the sub-tree; for
    instance, if the sub-tree returns *Success*, the decorator returns *Failure* and
    vice versa (of course, if the sub-tree returns *Running*, the decorator returns
    *Running* as well). Another everyday decorator is **Repeat**, a node that repeats
    its sub-tree a certain number of times.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器**是一个修改（装饰）其下子树的节点（因此，它可以装饰复合节点和任务节点）。例如，一个标准的装饰器是**否定**节点。该节点反转子树的返回值；例如，如果子树返回**成功**，则装饰器返回**失败**，反之亦然（当然，如果子树返回**运行中**，则装饰器也返回**运行中**）。另一个常见的装饰器是**重复**，它重复其子树一定次数。'
- en: 'Instead, a **composite** node represents a node with multiple children, and
    it is the most interesting case. There are two common composite nodes: **Sequence**,
    which runs all its children in order and returns *Success* if—and only if—all
    its children return *Success*, and **Selector**, which tries to execute all its
    children in order but returns *Success* as soon as one of its children returns
    *Success*. However, many BT implementations contain many more composite nodes
    (such as nodes that run their children in parallel or according to some dynamic
    priority value; we will see an example of such a node in the demo).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个**复合**节点代表一个具有多个子节点的节点，这是最有趣的情况。有两种常见的复合节点：**序列**，它按顺序运行其所有子节点，并且只有当所有子节点都返回**成功**时才返回**成功**，以及**选择器**，它尝试按顺序执行其所有子节点，但只要其子节点之一返回**成功**，就返回**成功**。然而，许多BT实现包含许多更多的复合节点（例如，并行运行其子节点或根据某些动态优先级值运行的节点；我们将在演示中看到一个这样的节点的例子）。
- en: Of course, this tree structure is not enough. Nodes need to exchange information
    with each other or with the game world. For instance, a **GoToTarget** node needs
    to know the target and its location; an **IsObjectClose?** node needs to know
    which object we are referring to and what distance we consider close. Naturally,
    we could write a **GoToX** node for each object in the game (such as **GoToTree01**
    and **GoToDoor23**), but you can easily imagine that this becomes messy very quickly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种树结构还不够。节点需要相互交换信息或与游戏世界交换信息。例如，**GoToTarget**节点需要知道目标及其位置；**IsObjectClose?**节点需要知道我们指的是哪个对象以及我们认为多近的距离是接近的。自然地，我们可以为游戏中的每个对象编写一个**GoToX**节点（例如**GoToTree01**和**GoToDoor23**），但你很容易想象这会很快变得混乱。
- en: For this reason, all the BT implementations contain a data structure called
    **Blackboard**. As in a real-life physical blackboard, every node can write and
    read data into it; we just need to specify where to look for each node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有BT实现都包含一个称为**黑板**的数据结构。就像现实生活中的物理黑板一样，每个节点都可以将其数据写入其中并从中读取；我们只需指定每个节点查找的位置。
- en: A simple example – a patrolling robot
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的例子 - 巡逻机器人
- en: 'Let''s look at this example (which we will later implement in Unity). Imagine
    a patrolling robot that shoots anything that gets near it but works only during
    the daytime. We show the possible BT for this kind of agent in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子（我们将在Unity中稍后实现）。想象一个巡逻机器人，它会射击靠近它的任何东西，但只在白天工作。我们在以下图中展示了这种代理的可能BT：
- en: '![Figure 9.1 – Example BT for a simplified day-only patrolling robot'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 - 简化日间巡逻机器人的示例BT'
- en: '](img/B17984_09_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_1.jpg]'
- en: Figure 9.1 – Example BT for a simplified day-only patrolling robot
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 - 简化日间巡逻机器人的示例BT
- en: 'Let''s run this BT, assuming that the target is close and it is not night:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个BT，假设目标很近，而且不是夜晚：
- en: The first node is a **Repeat** decorator; it does nothing but cycle the BTs,
    therefore, we can ignore it for now.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个节点是一个**重复**装饰器；它什么都不做，只是循环BT，因此现在我们可以忽略它。
- en: The **SELECTOR** node starts executing its first child; we go down to the left.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择器**节点开始执行其第一个子节点；我们向左下移动。'
- en: We are now at the first **Sequence** node; again, we execute the first node.
    **IsNight?** returns *Failure* (because it is not night!). Whenever one node returns
    *Failure*, the whole **Sequence** node returns *Failure*.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在位于第一个**Sequence**节点；再次，我们执行第一个节点。**IsNight?**返回*失败*（因为现在不是夜晚！）。每当一个节点返回*失败*时，整个**Sequence**节点也会返回*失败*。
- en: We traverse back up the tree to the **SELECTOR** node; now, we go to the second
    branch.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们回到树的**SELECTOR**节点；现在，我们进入第二个分支。
- en: Again, we execute **Sequence**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们执行**Sequence**。
- en: This time, however, **IsTargetClose?** returns *Success*, so we can proceed
    to the next node, **Shoot**, which runs a game function spawning an in-game projectile.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这次**IsTargetClose?**返回*成功*，因此我们可以继续到下一个节点，**Shoot**，它运行一个游戏函数生成游戏中的投射物。
- en: 'The pattern of **Sequence** | **Condition** | **Action** is equivalent to if
    *Condition* is *Success* then *Action*. This pattern is so common that many BT
    implementations allow you to stack the *Condition* and the *Action* together.
    Therefore, we can rewrite the tree as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sequence** | **Condition** | **Action**的模式等同于如果*Condition*是*成功*，则*Action*。这种模式非常常见，许多BT实现都允许你将*Condition*和*Action*一起堆叠。因此，我们可以将树重写如下：'
- en: '![Figure 9.2 – A simplified BT'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.2 – 简化的BT'
- en: '](img/B17984_09_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_2.jpg]'
- en: Figure 9.2 – A simplified BT
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.2 – 简化的BT
- en: This tree is the same as the previous one but with a simplified Sequence pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个树与上一个相同，但有一个简化的Sequence模式。
- en: Implementing a BT in Unity with Behavior Bricks
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Behavior Bricks在Unity中实现BT
- en: '**Behavior Bricks** is a robust but free BT implementation for Unity developed
    by the Complutense University of Madrid in Spain. Using Behavior Bricks, you can
    start using BTs in your projects without implementing BTs from scratch. It also
    has a visual editor where you can drop and connect nodes without any additional
    code.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Behavior Bricks**是西班牙马德里康普顿塞大学开发的一个强大但免费的Unity BT实现。使用Behavior Bricks，你可以在项目中开始使用BT，而无需从头开始实现BT。它还包含一个可视化编辑器，你可以在这里拖放并连接节点，而无需任何额外的代码。'
- en: 'Follow these steps to install Behavior Bricks:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装Behavior Bricks：
- en: We need to go to the *Unity Asset Store* by going on the website https://assetstore.unity.com/.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要通过访问网站https://assetstore.unity.com/来进入*Unity资产商店*。
- en: Search for `Behavior Bricks`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`Behavior Bricks`。
- en: Click on **Add to My Assets**. Once it's done, we can import it into our project.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加到我的资产**。一旦完成，我们就可以将其导入到我们的项目中。
- en: '![Figure 9.3 – Behavior Bricks Asset Store main page'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.3 – Behavior Bricks 资产商店主页'
- en: '](img/B17984_09_3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_3.jpg]'
- en: Figure 9.3 – Behavior Bricks Asset Store main page
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.3 – Behavior Bricks 资产商店主页
- en: Go to **Package Manager** (**Window** | **Package Manager**).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**包管理器**（**窗口** | **包管理器**）。
- en: Go to **My Assets**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**我的资产**。
- en: '![Figure 9.4 – The Package Manager window'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.4 – 包管理器窗口'
- en: '](img/B17984_09_4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_4.jpg]'
- en: Figure 9.4 – The Package Manager window
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.4 – 包管理器窗口
- en: Import the **Behavior Bricks** package by clicking on the **Import** button.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**导入**按钮导入**Behavior Bricks**包。
- en: '![Figure 9.5 – Behavior Bricks in Package Manager'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.5 – Behavior Bricks 在包管理器中'
- en: '](img/B17984_09_5.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_5.jpg]'
- en: Figure 9.5 – Behavior Bricks in Package Manager
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.5 – Behavior Bricks 在包管理器中
- en: 'At this point, Behavior Bricks is ready to go, and we can proceed with our
    demo. The following steps give you a brief idea of the steps to follow:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Behavior Bricks已经准备就绪，我们可以继续我们的演示。以下步骤为您提供了遵循的步骤的简要概述：
- en: Set up the scene.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置场景。
- en: Implement a day/night cycle.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现日夜循环。
- en: Design the enemy behavior.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计敌人行为。
- en: Implement the nodes.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现节点。
- en: Build the tree.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建树。
- en: Attach the BT to the enemy.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BT附加到敌人上。
- en: Now, let's take a look at each of these steps individually.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个查看这些步骤。
- en: Set up the scene
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'Let''s follow a step-by-step process to do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤一步步进行：
- en: We start by adding the game objects to the scene. We add a big plane to the
    scene, we add a `Box Collider` that encloses the entire plane, and we call it
    `Floor` (you may also add a texture if you like; be creative as it helps to have
    fun with these simple demos).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将游戏对象添加到场景中。我们在场景中添加了一个大平面，添加了一个包围整个平面的`Box Collider`，并将其命名为`Floor`（如果你喜欢，也可以添加纹理；发挥创意，这有助于在简单的演示中享受乐趣）。
- en: '![Figure 9.6 – Example of the Floor Box Collider'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.6 – 地板盒碰撞体的示例'
- en: '](img/B17984_09_6.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_6.jpg]'
- en: Figure 9.6 – Example of the Floor Box Collider
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.6 – 地板盒碰撞体的示例
- en: We add a sphere and a cube; we call the sphere *Player* and the cube *Enemy*.
    In the *Enemy*, we add another empty object and move it just outside the cube.
    We call it `shootPoint`, and it represents the placeholder for where the enemy
    shoots.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个球体和一个立方体；我们将球体称为 *Player*，将立方体称为 *Enemy*。在 *Enemy* 中，我们添加了另一个空对象并将其移动到立方体外部。我们称它为
    `shootPoint`，它代表敌人射击的占位符。
- en: 'Then, place all these objects on the floor; you should have something similar
    to the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将这些所有对象放置在地板上；你应该有类似以下的内容：
- en: '![Figure 9.7 – The scene of our demo'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 我们演示的场景](img/B17984_09_7.jpg)'
- en: '](img/B17984_09_7.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_7.jpg](img/B17984_09_7.jpg)'
- en: Figure 9.7 – The scene of our demo
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 我们演示的场景
- en: Now, because we want the player and the enemy to move around, we need to create
    a NavMesh as described in [*Chapter 8*](B17984_08_Epub.xhtml#_idTextAnchor447),
    *Navigation Mesh*. Remember to add the **NavMesh Agent** component to both *Player*
    and *Enemy*!
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，因为我们想让玩家和敌人四处移动，我们需要创建一个NavMesh，如[*第8章*](B17984_08_Epub.xhtml#_idTextAnchor447)，*导航网格*中所述。请记住将
    **NavMesh Agent** 组件添加到 *Player* 和 *Enemy* 上！
- en: Finally, if it is not present, add the **MainLight** tag to the *Direct Light*
    object.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果它不存在，请将 **MainLight** 标签添加到 *Direct Light* 对象上。
- en: Implement a day/night cycle
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现昼夜循环
- en: 'In this demo, we want to implement a basic day/night cycle. To do that, we
    attach the script `DayNightCycle.cs` to the *Direct Light* object. As with many
    scripts in this demo, we adapt the code from the *Quick Start Guide* provided
    by Behavior Bricks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们想要实现一个基本的昼夜循环。为了做到这一点，我们将脚本 `DayNightCycle.cs`附加到 *Direct Light* 对象上。就像这个演示中的许多脚本一样，我们从
    Behavior Bricks提供的 *快速入门指南* 中改编了代码：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This script implements a typical day/night cycle. The way it works is quite
    intuitive. Let''s have a look:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本实现了一个典型的昼夜循环。它的工作方式相当直观。让我们看看：
- en: At each `Update` step, we update the `lightIntensity` variable according to
    a sinusoidal wave.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个 `Update` 步骤中，我们根据正弦波更新 `lightIntensity` 变量。
- en: The variable cycles from `0` to `1` and, when the value is smaller than `0.3`,
    we decide that it is nighttime.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量从 `0` 到 `1` 循环，当值小于 `0.3` 时，我们决定它是夜晚。
- en: Finally, we update the light color according to the `lightIntensity` value,
    interpolating the day and night colors.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们根据 `lightIntensity` 值更新灯光颜色，插值白天和夜晚的颜色。
- en: Note the `onChanged` event. We call it every time we switch from daytime to
    nighttime, and from nighttime to daytime. Later, we use this event to create an
    **IsNight** node in the BT.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意 `onChanged` 事件。我们每次从白天切换到夜晚，以及从夜晚切换到白天时都会调用它。稍后，我们使用此事件在BT中创建一个 **IsNight**
    节点。
- en: Design the enemy behavior
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计敌人行为
- en: 'Now, it is time to design the enemy behavior. We need to do this before writing
    a single line of code. For this demo, we will adapt the code and assets provided
    by the example project in the Behavior Bricks *Quick Start Guide*. For more information,
    you can refer to it at this URL: [http://bb.padaonegames.com/doku.php?id=quick:program](http://bb.padaonegames.com/doku.php?id=quick:program).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候设计敌人行为。在编写任何代码之前，我们需要这样做。对于这个演示，我们将改编 Behavior Bricks *快速入门指南* 中提供的示例项目中的代码和资源。有关更多信息，您可以参考此URL：[http://bb.padaonegames.com/doku.php?id=quick:program](http://bb.padaonegames.com/doku.php?id=quick:program)。
- en: '![Figure 9.8 – The target BT we want to implement'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – 我们要实现的BT目标](img/B17984_09_8.jpg)'
- en: '](img/B17984_09_8.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_09_8.jpg](img/B17984_09_8.jpg)'
- en: Figure 9.8 – The target BT we want to implement
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 我们要实现的BT目标
- en: 'The BT in *Figure 9.8* describes the following behavior:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.8* 中的BT描述了以下行为：'
- en: If it is night, the enemy is deactivated.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是夜晚，敌人将被禁用。
- en: If the target is very close, the enemy shoots at the target.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标非常近，敌人就会射击目标。
- en: If the target is further away, the enemy chases the target.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标更远，敌人会追逐目标。
- en: Otherwise, the enemy just wanders around.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，敌人只是在四处游荡。
- en: 'There are two important things to note:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点需要注意：
- en: First, the two **IsTargetClose?** nodes differ in the value we consider close.
    In particular, we want to shoot the target only if we are close to it; otherwise,
    we just start chasing it.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，两个 **IsTargetClose?** 节点在我们认为接近的值上有所不同。特别是，我们只有在接近目标时才射击目标；否则，我们只是开始追逐它。
- en: Second, and most importantly, the order of the nodes matters. Because the **Selector**
    works from left to right and stops at the first *Success*, we cannot put **ChaseTarget**
    before **Shoot**. Otherwise, the enemy will never shoot!
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点，也是最重要的一点，节点的顺序很重要。因为 **Selector** 从左到右工作，并在第一个 *Success* 处停止，所以我们不能在 **Shoot**
    之前放置 **ChaseTarget**。否则，敌人将永远不会射击！
- en: As a rule of thumb, we need to order conditions from the highest to the lowest
    priority. In fact, in the example, we put at the very end the action to execute
    when everything else fails (**AlwaysTrue** is a condition that always succeeds
    and works like the *else* branch of an *if* condition).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，我们需要按从高到低的优先级顺序排列条件。实际上，在示例中，我们将执行当所有其他操作都失败时的动作（**AlwaysTrue**是一个总是成功的条件，它就像一个if条件中的else分支）放在最后。
- en: Note that **Wander** is in a different color because it is not a node but another
    BT. The lovely property of BTs is that you can reuse common BTs as nodes inside
    more complex BTs. The Wander BT simply makes the enemy move randomly on the map;
    fortunately, Behavior Bricks already includes it, so we don't need to implement
    it!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**Wander**以不同的颜色显示，因为它不是一个节点，而是一个BT。BT的可爱特性之一是你可以将常见的BT作为节点重用于更复杂的BT中。Wander
    BT简单地让敌人随机在地图上移动；幸运的是，行为砖块已经包含了它，所以我们不需要实现它！
- en: Implementing the nodes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现节点
- en: After we have made a plan for our BT, the next step is to check whether our
    BT implementation of choice (in our case, Behavior Bricks) already includes some
    of the nodes we need. Of course, we want to reuse as many pre-made nodes as possible.
    Reading the Behavior Bricks documentation, we can see that it already includes
    nodes such as **IsTargetClose**, **MoveToGameObject**, **Wander**, and **AlwaysTrue**,
    plus, of course, **Repeat** and **Selector**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为我们的BT（行为树）制定计划之后，下一步是检查我们选择的BT实现（在我们的案例中，是行为砖块）是否已经包含我们需要的节点。当然，我们希望尽可能多地重用预制的节点。阅读行为砖块的文档，我们可以看到它已经包含了诸如**IsTargetClose**、**MoveToGameObject**、**Wander**和**AlwaysTrue**等节点，当然，还有**Repeat**和**Selector**。
- en: 'Therefore, we need to write all the other tasks. Note that Behavior Bricks
    tasks are not MonoBehaviors; therefore, we do not need to attach them to some
    object in the scene. We only need to put the scripts in any folder in our project''s
    assets, and we are good. Let''s look at a step-by-step process to do this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要编写所有其他任务。请注意，行为砖块的任务不是MonoBehaviors；因此，我们不需要将它们附加到场景中的某个对象上。我们只需要将脚本放在我们项目资源中的任何文件夹中，就可以了。让我们一步一步地看看如何做：
- en: 'Let''s start with the `ShootOnce.cs` file in the project assets. First, we
    create a simple `Action` attribute called `ShootOnce` that, as the name says,
    shoots a single bullet:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从项目资源中的`ShootOnce.cs`文件开始。首先，我们创建一个简单的`Action`属性，命名为`ShootOnce`，正如其名，它发射一颗子弹：
- en: '[PRE1]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the beginning, we import Behavior Bricks modules. Then, we create the `ShootOnce`
    class by extending the generic `GOAction` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们导入行为砖块模块。然后，我们通过扩展通用的`GOAction`类来创建`ShootOnce`类。
- en: Note the class attributes; Behavior Bricks uses them to populate the BT visual
    editor. In the `Action` attribute, we specify that `Action` is an action, and
    we put it in the `Chapter09` collection with the name `ShootOnce`. The `Help`
    attribute is just a documentation string describing the action's purpose.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类属性；行为砖块使用它们来填充BT可视化编辑器。在`Action`属性中，我们指定`Action`是一个动作，并将其放入`Chapter09`集合中，命名为`ShootOnce`。`Help`属性只是一个描述动作目的的文档字符串。
- en: 'We describe the class attributes as usual. The only difference is that we decorate
    each attribute with the `InParam` attribute, which specifies that the BT executor
    needs to retrieve the following value from the blackboard:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样描述类属性。唯一的区别是，我们用`InParam`属性装饰每个属性，该属性指定BT执行器需要从黑板中检索以下值：
- en: '[PRE2]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For this action, we need a `Bullet` prefab, a place to instantiate the bullet
    (`shootPoint`) and the bullet velocity. Later, we will see how to set them up
    from the visual interface.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个动作，我们需要一个`Bullet`预制体，一个实例化子弹的位置（`shootPoint`）以及子弹的速度。稍后，我们将看到如何从可视化界面设置它们。
- en: 'Now, it is time to write the real meat:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编写真正的核心内容了：
- en: '[PRE3]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Every Behavior Bricks node contains some default method called during the BT
    execution. We can overwrite them in our custom implementations. In this example,
    we see two of them: `OnStart` and `OnUpdate`. They are used very similarly to
    how we use `Start` and `Update` in `MonoBehavior`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个行为砖块节点都包含一些在BT执行期间调用的默认方法。我们可以在自定义实现中覆盖它们。在这个例子中，我们看到两个：`OnStart`和`OnUpdate`。它们的使用方式与我们在`MonoBehavior`中使用`Start`和`Update`非常相似：
- en: The BT executor calls `OnStart` when the game creates the BT. In it, we initialize
    all the references we need. In this case, we get a reference to the `shootPoint`
    object. Note also that we must call `base.Onstart()` to initialize the base class.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BT执行器在游戏创建BT时调用`OnStart`。在其中，我们初始化所有需要的引用。在这种情况下，我们获取到`shootPoint`对象的引用。注意，我们还必须调用`base.Onstart()`来初始化基类。
- en: 'In `OnUpdate`, we write the intended action for the node, that is, what we
    want this node to do when the BT executor invokes it. In this case, the code is
    self-explanatory: we create a bullet and shoot it at the velocity stored in the
    settings.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`OnUpdate`中，我们为节点编写预期的动作，即当BT执行器调用它时，我们希望这个节点做什么。在这种情况下，代码是自解释的：我们创建一颗子弹，并以设置中存储的速度射击它。
- en: If there is no problem, we mark the node as complete (so that the BT knows that
    it is a *Success*); otherwise (for example, if there is no `shootPoint` value),
    we mark the node as *Failed*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有问题，我们将节点标记为完成（这样BT就知道它是一个*成功*），否则（例如，如果没有`shootPoint`值），我们将节点标记为*失败*。
- en: 'Now that we have a base class for shooting once, we can create a new `Action`
    attribute for shooting continuously. Let''s create a `Shoot.cs` file with the
    following content:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有一个射击一次的基类，我们可以创建一个新的用于连续射击的`Action`属性。让我们创建一个包含以下内容的`Shoot.cs`文件：
- en: '[PRE4]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class simply extends the `ShootOnce` class, adds a `delay` attribute (the
    time between consecutive shots), and then continuously reruns its parent class
    (`ShootOnce`). Note that this `Action` always returns `RUNNING`, meaning that
    it never completes as long as the BT selects it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类简单地扩展了`ShootOnce`类，添加了一个`delay`属性（连续射击之间的时间），然后连续重新运行其父类（`ShootOnce`）。注意，这个`Action`始终返回`RUNNING`，这意味着只要BT选择它，它就永远不会完成。
- en: 'In the same way, we can create the remaining `Action` attribute. For instance,
    the `SleepForever` action is very straightforward: it just does nothing and suspends
    the execution of the BTs. Note that the class extends `BasePrimitiveAction`, which
    is the most basic form of `Action` in Behavior Bricks:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们可以创建剩余的`Action`属性。例如，`SleepForever`动作非常简单：它只是什么也不做，并暂停BT的执行。注意，该类扩展了`BasePrimitiveAction`，这是Behavior
    Bricks中`Action`的最基本形式：
- en: '[PRE5]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we need to implement `IsNightCondition`. We show the `IsNightCondition`
    code in the following listing:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要实现`IsNightCondition`。我们在下面的列表中展示了`IsNightCondition`的代码：
- en: '[PRE6]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This class is more complex than the others, so let''s go slow. First of all,
    `IsNightCondition` extends `ConditionBase`, which is a basic condition template
    in Behavior Bricks. This class does a simple job: on start, it searches for a
    light with the `MainLight` tag. If that exists, it takes its `DayNightCycle` reference,
    stores it in the `light` variable, and registers with the `OnChanged` event. Then,
    every time we ask for this condition, we check whether the `isNight` variable
    in `light` is `true` or `false` (see the `Check` method).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比其他类更复杂，所以让我们慢慢来。首先，`IsNightCondition`扩展了`ConditionBase`，这是Behavior Bricks中的一个基本条件模板。这个类做一件简单的工作：在开始时，它搜索带有`MainLight`标签的光源。如果存在，它获取其`DayNightCycle`引用，将其存储在`light`变量中，并注册到`OnChanged`事件。然后，每次我们请求这个条件时，我们检查`light`中的`isNight`变量是`true`还是`false`（见`Check`方法）。
- en: 'However, checking this every time would be very inefficient, in general. So,
    the `BaseCondition` class contains two helpful functions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次都检查这会很低效，通常情况下。因此，`BaseCondition`类包含两个有用的函数：
- en: '`MonitorCompleteWhenTrue` is a function that is called by the BT executor when
    the last returned value is `false` and, in practice, sets up a system that suspends
    BT execution until the variable becomes `true` again.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonitorCompleteWhenTrue`是一个函数，当BT执行器返回最后一个值是`false`时被调用，实际上，它设置了一个系统，在变量再次变为`true`之前暂停BT执行。'
- en: '`MonitorFailWhenFalse` is a dual function: it is called when the monitored
    value is `true` and suspends BT execution until the variable switches to `false`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonitorFailWhenFalse`是一个双重功能：当被监控的值为`true`时被调用，并暂停BT执行，直到变量切换到`false`。'
- en: 'For instance, let''s look at `MonitorCompleteWhenTrue`. If `Check` is `true`
    (so it is night), we simply return `Complete`; otherwise, we register the `OnSunset`
    function with the `OnChanged` event. When the day/night cycle switches from day
    to night, `OnSunset` is called and, in turn, `EndMonitorWithSuccess` is called.
    `MonitorFailWhenFalse` works in the same way but in the opposite direction (monitoring
    when we pass from night to day):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看 `MonitorCompleteWhenTrue`。如果 `Check` 是 `true`（因此是夜晚），我们只需简单地返回 `Complete`；否则，我们将
    `OnSunset` 函数与 `OnChanged` 事件注册。当昼夜循环从白天切换到夜晚时，调用 `OnSunset`，然后调用 `EndMonitorWithSuccess`。`MonitorFailWhenFalse`
    以相同的方式工作，但方向相反（监控我们从夜晚过渡到白天）：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code block, there are the two `OnSunset` and `OnSunrise` event
    handlers included in the class. As usual, you can find the complete commented
    code in the book's repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，包含了类中包含的两个 `OnSunset` 和 `OnSunrise` 事件处理器。像往常一样，您可以在本书的仓库中找到完整的带注释的代码。
- en: Building the tree
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建树
- en: 'Now that we have our nodes, we need to assemble the tree. To do that, follow
    these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的节点，我们需要组装树。为此，请按照以下步骤操作：
- en: Right-click in the **Inspector** and go to the **Create** sub-menu.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 中右键单击，然后转到 **创建** 子菜单。
- en: Then, select **Behavior Tree**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 **行为树**。
- en: Choose a location and save.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个位置并保存。
- en: An empty editor window should show onscreen; this is the tree editor.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在屏幕上显示一个空白的编辑器窗口；这是树编辑器。
- en: You can right-click anywhere and start adding and connecting nodes.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在任何位置右键单击并开始添加和连接节点。
- en: 'To implement our tree, you need to recreate the tree shown in the following
    screenshot:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现我们的树，您需要重新创建以下截图所示的树：
- en: '![Figure 9.9 – The enemy BT in the Behavior Bricks editor'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 在行为砖块编辑器中的敌人 BT'
- en: '](img/B17984_09_9.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_09_9.jpg)'
- en: Figure 9.9 – The enemy BT in the Behavior Bricks editor
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 在行为砖块编辑器中的敌人 BT
- en: Select all the nodes, one at a time, and look for the input parameters; these
    are the parameters we specified in our classes. These parameters may be **CONSTANT**,
    meaning that we directly write a value for them, or a **BLACKBOARD** reference.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个选择所有节点，查找输入参数；这些是我们类中指定的参数。这些参数可能是 **CONSTANT**，意味着我们直接为它们写入一个值，或者是一个 **BLACKBOARD**
    引用。
- en: 'We need to set up the parameters with the following values:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置以下值的参数：
- en: In the first `IsTargetClose`, we specify the blackboard player as `target` and
    the constant `7` as `closeDistance` (if the player is not listed, click on `IsTargetClose`,
    we specify the blackboard player as `target` and the constant `20` as `closeDistance`.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个 `IsTargetClose` 中，我们将黑板玩家指定为 `target`，将常数 `7` 指定为 `closeDistance`（如果玩家未列出，请单击
    `IsTargetClose`，我们将黑板玩家指定为 `target`，将常数 `20` 指定为 `closeDistance`）。
- en: In `Shoot`, we need to set `30` as the delay, the blackboard `shootPoint` as
    `shootPoint` (you probably need to create it with `bullet` prefab, and the constant
    `30` as velocity.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Shoot` 中，我们需要将延迟设置为 `30`，将黑板 `shootPoint` 设置为 `shootPoint`（您可能需要使用 `bullet`
    预制件创建它，并将常数 `30` 设置为速度。
- en: In `MoveToGameObject`, the target is the player value in the blackboard.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `MoveToGameObject` 中，目标是黑板中的玩家值。
- en: In `Wander`, we set a new blackboard parameter (`floor`) as `wanderArea`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Wander` 中，我们将一个新的黑板参数（`floor`）设置为 `wanderArea`。
- en: Attach the BT to the enemy
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 BT 附接到敌人上
- en: 'Now, it is time to attach this BT to the enemy''s BT executor. For that, follow
    these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将此 BT 附接到敌人的 BT 执行器上了。为此，请按照以下步骤操作：
- en: Select the **Enemy** game object and add the **Behavior Executor** component
    to it.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **敌人** 游戏对象，并向其添加 **行为执行器** 组件。
- en: In the **Behavior** field, drag and drop the BT we created before.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **行为** 字段中，拖放我们之前创建的 BT。
- en: In `player`, `floor`, the enemy `shootPoint` firing location, and `bullet`)
    should appear.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `player`、`floor`、敌人的 `shootPoint` 射击位置和 `bullet`）应该出现。
- en: 'Fill them with the appropriate objects, as shown in *Figure 9.10*:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如图 *图 9.10* 所示填充适当的对象：
- en: '![Figure 9.10 – The behavior executor component'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 行为执行器组件'
- en: '](img/B17984_09_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_09_10.jpg)'
- en: Figure 9.10 – The behavior executor component
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 行为执行器组件
- en: At this point, the enemy should be ready to go. Click **Play** and you should
    see the enemy wandering around and, when close enough to the player, start chasing
    and shooting at it. Note that we did not implement a controller for the player,
    therefore, to change its position you need to edit the player in the Scene view
    (or attach one of the control scripts we developed in the previous chapters).
    For more details, look at the code included in this book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，敌人应该已经准备好了。点击**播放**，你应该看到敌人四处游荡，当接近玩家时，开始追逐并射击。请注意，我们没有为玩家实现控制器，因此，要改变其位置，您需要编辑场景视图中的玩家（或附加我们在前几章中开发的控制脚本之一）。有关更多详细信息，请参阅本书中包含的代码。
- en: Now that we have completed our first BT, what if we want to replicate with Behavior
    Bricks the same AI that we developed in [*Chapter 2*](B17984_02_Epub.xhtml#_idTextAnchor100),
    *Finite State Machines*, using an FSM? Try that as an exercise.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了第一个行为树（BT），如果我们想使用有限状态机（FSM）来复制在[*第2章*](B17984_02_Epub.xhtml#_idTextAnchor100)中开发的相同AI，使用行为砖块（Behavior
    Bricks）应该怎么做？把这作为一个练习尝试一下。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored the general background behind any BT implementation.
    We saw what a BT is, what its basic components are, and how can we use a BT to
    describe game character behavior. Then, we implemented a demo using a free plugin
    called Behavior Bricks. In the demo, we created the behavior for a simple scenario:
    the player and a patrolling robot. We also implemented a day/night cycle to spice
    up the scenario.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了任何BT实现背后的通用背景。我们看到了BT是什么，它的基本组件是什么，以及我们如何使用BT来描述游戏角色的行为。然后，我们使用一个名为行为砖块（Behavior
    Bricks）的免费插件实现了演示。在演示中，我们为简单场景创建了行为：玩家和巡逻机器人。我们还实现了一个日夜循环来增加场景的趣味性。
- en: BTs are the cornerstones of modern AI for game characters. Implementation details
    and deeper examples would require a full book to explain them fully. Luckily,
    the web is full of resources for the curious reader.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: BT是现代游戏角色AI的基石。实现细节和更深入的例子需要一本书来完全解释。幸运的是，网络上有许多资源供好奇的读者参考。
- en: Now, we will take a break from AI character design by looking at a different
    application of AI in games. In the next chapter, we will look at the fascinating
    field of procedural content generation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从AI角色设计转向AI在游戏中的不同应用。在下一章中，我们将探讨程序内容生成的迷人领域。
- en: Further reading
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official Behavior Bricks project page from the Complutense University of
    Madrid in Spain: [http://gaia.fdi.ucm.es/research/bb/](http://gaia.fdi.ucm.es/research/bb/).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 西班牙马德里康普鲁滕塞大学官方的行为砖块项目页面：[http://gaia.fdi.ucm.es/research/bb/](http://gaia.fdi.ucm.es/research/bb/)。
- en: 'Behavior Bricks official documentation: [http://bb.padaonegames.com/doku.php](http://bb.padaonegames.com/doku.php).'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为砖块官方文档：[http://bb.padaonegames.com/doku.php](http://bb.padaonegames.com/doku.php)。
- en: 'Chris Simpson (the developer of *Project Zomboid*) wrote a nice explanation
    of BTs on Gamasutra: [https://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php](https://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chris Simpson（*Project Zomboid*的开发者）在Gamasutra上对BT进行了很好的解释：[https://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php](https://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php)。
- en: '[*Chapter 6*](B17984_06_Epub.xhtml#_idTextAnchor375) of *GameAI Pro*, which
    explores many implementation details of BTs (in C++), is free and available at
    the following link: [https://www.gameaipro.com/GameAIPro/GameAIPro_Chapter06_The_Behavior_Tree_Starter_Kit.pdf](https://www.gameaipro.com/GameAIPro/GameAIPro_Chapter06_The_Behavior_Tree_Starter_Kit.pdf).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GameAI Pro*的[*第6章*](B17984_06_Epub.xhtml#_idTextAnchor375)，探讨了行为树（BT）的许多实现细节（在C++中），免费并提供以下链接：[https://www.gameaipro.com/GameAIPro/GameAIPro_Chapter06_The_Behavior_Tree_Starter_Kit.pdf](https://www.gameaipro.com/GameAIPro/GameAIPro_Chapter06_The_Behavior_Tree_Starter_Kit.pdf)。'
