["```py\n    def create_grid_with_trajectory(\n        grid_size=200, num_points=50, missing_count=5\n    ):\n        grid = np.zeros((grid_size, grid_size), dtype=int)\n        trajectory = [] \n    ```", "```py\n     x = random.randint(0, grid_size - 1)\n        y = random.randint(0, grid_size - 1)\n        day = random.randint(1, 365)\n        timeslot = random.randint(0, 47) \n    ```", "```py\n     directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        current_dir_index = random.randint(0, 3)\n        turn_weights = {-1: 0.15, 0: 0.70, 1: 0.15} \n    ```", "```py\n     for _ in range(num_points):\n            turn = random.choices(list(turn_weights.keys()),\n                weights=list(turn_weights.values()))[0]\n            current_dir_index = (current_dir_index + turn) % \\\n                len(directions)\n            dx, dy = directions[current_dir_index]\n            new_x = x + dx\n            new_y = y + dy\n            ...\n            trajectory.append((day, timeslot, x, y))\n            grid[x, y] = 1\n            timeslot = (timeslot + random.randint(1, 3)) % 48 \n    ```", "```py\n     missing_indices = random.sample(range(len(trajectory)),\n                                        min(missing_count, \n                                        len(trajectory)))\n        for idx in missing_indices:\n            d, t, _, _ = trajectory[idx]\n            trajectory[idx] = (d, t, 999, 999) \n    ```", "```py\n x_coords = [x if x != 999 else np.nan for _, _, x, y in trajectory]\n    y_coords = [y if y != 999 else np.nan for _, _, x, y in trajectory]\n    plt.figure(figsize=(8, 8))\n    plt.plot(x_coords, y_coords, marker='o', linestyle='-',\n             color='blue', label=\"Agent Trajectory\")\n    ...\n    plt.quiver(...)\n    ...\n    plt.title(\"Agent Trajectory with Direction Arrows and Missing Data\")\n    plt.xlabel(\"X coordinate\")\n    plt.ylabel(\"Y coordinate\")\n    plt.grid(True)\n    plt.legend()\n    plt.savefig(\"mobility.png\")\n    plt.close() \n```", "```py\n return grid, trajectory \n```", "```py\n    def handle_mobility_orchestrator(\n        muser_message1, msystem_message_s1, mgeneration, \n        mimcontent4, mimcontent4b\n    ): \n    ```", "```py\ngrid, trajectory = create_grid_with_trajectory(\n    grid_size=200, num_points=50, missing_count=5\n) \n```", "```py\n    trajectory_json = json.dumps({\"trajectory\": trajectory}, indent=2)\n        #print(\"Trajectory Data (JSON):\\n\", trajectory_json)\n        muser_message = f\"{muser_message1}\\n\\nHere is the trajectory data:\\n{trajectory_json}\" \n    ```", "```py\n     reasoning_steps = reason.mobility_agent_reasoning_thread(\n            muser_message, msystem_message_s1, mgeneration, \n            mimcontent4, mimcontent4b\n        ) \n    ```", "```py\n     reasoning_steps.insert(\n            0, (\"Generated Trajectory Data:\", trajectory)\n        )\n        return reasoning_steps \n    ```", "```py\nmsystem_message_s1 = \"\"\"\nYou are GPT-4o, an expert in grid-based mobility analysis. Your task is to analyze the provided trajectory dataset and **identify missing coordinates** flagged as `999,999`, then predict their correct values. \n```", "```py\n**Task:**\n1\\. **Process only the dataset provided in the user input. Do not generate or use your own sample data.**\n2\\. Identify **every single** instance where `x` or `y` is `999`, including consecutive and scattered occurrences.\n3\\. Predict the missing coordinate values based on the trajectory pattern.\n4\\. **Do not modify, reorder, or filter the data in any way**—your response must reflect the dataset exactly as given except for replacing missing values.\n5\\. Before responding, **validate your output** against the original dataset to confirm completeness and accuracy.\n6\\. Maintain the exact order of missing values as they appear in the dataset.\n7\\. Include a debugging step: **first print the list of detected missing values before structuring the final JSON output**. \n```", "```py\n**Output Format:**\n```", "```py \n```", "```py\nmgeneration = \"\"\"\nScan the user-provided trajectory data and extract **every** point where either `x` or `y` equals `999`.\nYou must process only the given dataset and not generate new data.\nEnsure that all missing values are explicitly listed in the output without skipping consecutive values, isolated values, or any part of the dataset. **Before responding, verify that all occurrences match the input data exactly.**\nThen, predict the missing values based on detected trajectory movement patterns. **Provide a corrected trajectory with inferred missing values.**\nTo assist debugging, **first print the detected missing values list as a pre-response validation step**, then return the structured JSON output.\n\"\"\" \n```", "```py\nmimcontent4 = \"\"\"\nThis dataset contains spatial-temporal trajectories where some coordinate values are missing and represented as `999,999`. Your goal is to **identify these missing coordinates from the user-provided dataset only**, then predict their correct values based on movement patterns. Ensure that consecutive, isolated, and scattered missing values are not omitted. **Before generating the final response, validate your results and confirm that every missing value is properly predicted.**\n\"\"\" \n```", "```py\nmuser_message1 = \"\"\"\nHere is a dataset of trajectory points. Some entries have missing coordinates represented by `999,999`.\nYou must process only this dataset and **strictly avoid generating your own sample data**.\nPlease identify **all occurrences** of missing coordinates and return their positions in JSON format, ensuring that no values are skipped, omitted, or restructured. Then, **predict and replace** the missing values using trajectory movement patterns.\nBefore returning the response, **first output the raw missing coordinates detected** as a validation step, then structure them into the final JSON output with predicted values.\n\"\"\" \n```", "```py\ndef handle_mobility(user_message): \n```", "```py\n from cot_messages_c6 import (\n        msystem_message_s1, mgeneration, mimcontent4,muser_message1\n    ) \n```", "```py\n #call Generic Synthetic Trajectory Simulation and Predictive System\n    reasoning_steps = handle_mobility_orchestrator(\n        muser_message1, msystem_message_s1, mgeneration, \n        mimcontent4, mimcontent4b\n    )\n    return reasoning_steps\n    mimcontent4b=mimcontent4 \n```", "```py\n #call Generic Synthetic Trajectory Simulation and Predictive System\n    reasoning_steps = handle_mobility_orchestrator(\n        muser_message1, msystem_message_s1, mgeneration, \n        mimcontent4, mimcontent4b)\n    return reasoning_steps \n```", "```py\n# Implemented in Chapter08\ndef mobility_agent_reasoning_thread(\n    input1,msystem_message_s1,mumessage4,mimcontent4,mimcontent4b\n): \n```", "```py\n steps = []\n\n    # Display the VBox in the interface\n    display(reasoning_output)\n    #Step 1: Mobility agent\n    steps.append(\"Process: the mobility agent is thinking\\n\")\n    with reasoning_output:\n        reasoning_output.clear_output(wait=True)\n        print(steps[-1])  # Print the current step \n```", "```py\n mugeneration=msystem_message_s1 + input1\n    mrole4 = \"system\"\n    mcontent4 = mimcontent4\n    user_role = \"user\"\n    create_response = make_openai_api_call(\n        mugeneration,mrole4,mcontent4,user_role\n    )\n    steps.append(f\"Customer message: {create_response}\")\n    return steps \n```", "```py\nuser_message=\"Check the delivery path\"\noutput=handle_mobility(user_message) \n```", "```py\n# Display mobility.png if it exists and the \"Mobility\" instruction is selected\nif os.path.exists(\"mobility.png\"):\n    original_image = PILImage.open(\"mobility.png\")\n    display(original_image) \n```", "```py\nprint(output) \n```", "```py\n[('Generated Trajectory Data:', [(50, 28, 999, 999), (50, …. \n```", "```py\ndef transform_openai_output(output):\n    \"\"\"\n    Takes the 'output' (a list/tuple returned by OpenAI) and transforms\n    it into a nicely formatted multiline string.\n    \"\"\" \n```", "```py\n …\n    lines = []\n    …\n    # Join all lines into one neatly formatted string\n    return \"\\n\".join(lines) \n```", "```py\npretty_response = transform_openai_output(output)\nprint(pretty_response) \n```", "```py\nGenerated Trajectory Data:\n  (228, 6, 999, 999)\n  (228, 7, 69, 79)\n  (228, 9, 70, 79)\n  (228, 11, 71, 79)\n  (228, 13, 71, 78)\n  (228, 16, 71, 77)\n  (228, 18, 71, 76)\n  (228, 21, 71, 75)\n  (228, 24, 71, 74)\n  (228, 26, 70, 74)\n  (228, 27, 70, 73)\n  (228, 29, 70, 72)\n  (228, 32, 999, 999)\n  … \n```", "```py\n(228, 6, 999, 999) \n```", "```py\nProcess: the mobility agent is thinking\nCustomer message: **Detected Missing Coordinates:**\n1\\. [228, 6, 999, 999]\n2\\. [228, 32, 999, 999]\n3\\. [228, 9, 999, 999]\n4\\. [228, 45, 999, 999]\n5\\. [228, 47, 999, 999] \n```", "```py\n**Predicted Missing Coordinates:** \n```", "```py\n1\\. [228, 6, 69, 79] - Based on the trajectory pattern, the missing values at timeslot 6 are likely to be the same as the next known values at timeslot 7.\n2\\. [228, 32, 69, 72] - Interpolating between timeslot 29 (70, 72) and timeslot 33 (68, 72), the missing values at timeslot 32 are predicted to be (69, 72).\n3\\. [228, 9, 64, 72] - The missing values at timeslot 9 are interpolated between timeslot 7 (64, 71) and timeslot 10 (64, 73), resulting in (64, 72).\n4\\. [228, 45, 58, 81] - Interpolating between timeslot 43 (58, 82) and timeslot 46 (58, 80), the missing values at timeslot 45 are predicted to be (58, 81).\n5\\. [228, 47, 58, 79] - The missing values at timeslot 47 are interpolated between timeslot 46 (58, 80) and timeslot 1 (58, 78), resulting in (58, 79). \n```", "```py\n```", "```py \n```", "```py\ninstruct_selector = Dropdown(\n    options=[\"None\", \"Analysis\", \"Generation\",\"Mobility\"],\n    value=\"None\",\n    description='Reasoning:',\n    layout=Layout(width='50%')\n)\ninstruct_selector.observe(on_instruct_change, names='value') \n```", "```py\ndef update_display():\n    clear_output(wait=True)\n    ...\n    # Display c_image.png if it exists\n    if files_checkbox.value == True:\n    …\n        # Display mobility.png if \"Mobility\" is selected\n        if (\n            os.path.exists(\"mobility.png\")\n            and instruct_selector.value == \"Mobility\"\n        ):\n            original_image = PILImage.open(\"mobility.png\")\n            display(original_image) \n```", "```py\nThe response = chat_with_gpt(\n    user_histories[active_user], user_message, pfiles, \n    active_instruct, models=selected_model\n) \n```", "```py\ndef handle_submission():\n    user_message = input_box.value.strip()\n…\n        if instruct_selector.value in [\n            \"Analysis\", \"Generation\",\"Mobility\"\n        ]:\n            with reasoning_output:\n                reasoning_output.clear_output(wait=True)\n                … \n```", "```py\ndef chat_with_gpt(\n    messages, user_message, files_status, active_instruct, models\n): \n```", "```py\nhandlers = [\n…\n# Mobility handler: determined by the instruct flag\n    (\n        lambda msg, instruct, mem, models, user_message, **kwargs: \n            instruct == \"Mobility\",\n        lambda msg, instruct, mem, models, user_message, **kwargs: \n            handle_mobility(user_message, models=models)\n    ),\n… \n```", "```py\ndef create_grid_with_trajectory(\n    grid_size=200, num_points=50, missing_count=5\n):\n… \n```", "```py\ndef handle_mobility_orchestrator(\n    muser_message1, msystem_message_s1, mgeneration, \n    mimcontent4, mimcontent4b\n):\n… \n```", "```py\ndef handle_mobility(user_message, **kwargs):\n    from cot_messages_c6 import (\n        msystem_message_s1, mgeneration, mimcontent4,muser_message1\n    )\n    mimcontent4b=mimcontent4\n    #call Generic Synthetic Trajectory Simulation and Predictive System\n    reasoning_steps = handle_mobility_orchestrator(\n        muser_message1, msystem_message_s1, mgeneration, \n        mimcontent4, mimcontent4b\n    )\n    return reasoning_steps \n```", "```py\ndeepseek=False\nHF=False\nTogetheragents=False \n```", "```py\n**User01**: Check deliveries\nAgent: ('Generated Trajectory Data:', [(145, 20, 999, 999), (145, 22, 189, 125), (145, 25, 190, 125), (145, 28, 190, 124), (145, 29, 190, 123), (145, 31, 999, 999), \n```", "```py\nProcess: The mobility agent is thinking \n```", "```py\nCustomer message: **Detected Missing Coordinates:**\n1\\. [145, 20, 999, 999]\n2\\. [145, 31, 999, 999]\n3\\. [145, 34, 999, 999]\n4\\. [145, 42, 999, 999]\n5\\. [145, 3, 999, 999] \n```", "```py\n**Predicted Missing Coordinates:** To predict the missing coordinates, we will analyze the trajectory pattern before and after each missing value:\n**Predicted Coordinates:**\n1\\. [145, 20, 189, 125] - Based on the pattern before and after the missing value.\n2\\. [145, 31, 189, 122] - Interpolated from the surrounding points.\n3\\. [145, 34, 189, 121] - Interpolated from the surrounding points.\n4\\. [145, 42, 191, 128] - Based on the pattern before and after the missing value.\n5\\. [145, 3, 190, 124] - Interpolated from the surrounding points. \n```", "```py\njson<br>{<br> \"predicted_coordinates\": [<br> [145, 20, 189, 125],<br> [145, 31, 189, 122],<br> [145, 34, 189, 121],<br> [145, 42, 191, 128],<br> [145, 3, 190, 124]<br> ]<br>}<br> \n```", "```py\nThe missing x,y coordinates with 999,999 respectively in this dialog are deliveries that were not made! The predicted x,y coordinates are inference from the coordinates before and after. \n```", "```py\nWrite an email to SUPPLIER COMPANY specifying that the missing coordinates from x values 20 to 40 are located in the Midtown mall area. Provide the missing coordinates and their predictions to inform the SUPPLIER COMPANY. Be as precise and explicit as possible. \n```", "```py\nDear [Supplier Company Contact Name],\nI hope this message finds you well. I am writing to inform you about certain discrepancies identified in the delivery data for the Midtown Mall area. Specifically, there are missing coordinates in the trajectory data, which indicate deliveries that were not completed. These missing coordinates are represented by the values 999,999.\nBelow, I have detailed the missing coordinates along with their predicted values, which have been inferred based on the surrounding data points:\n1\\. Missing Coordinate: [145, 20, 999, 999]\n- Predicted Coordinate: [145, 20, 189, 125]\n2\\. Missing Coordinate: [145, 31, 999, 999]\n- Predicted Coordinate: [145, 31, 189, 122]\n3\\. Missing Coordinate: [145, 34, 999, 999]\n- Predicted Coordinate: [145, 34, 189, 121]\n4\\. Missing Coordinate: [145, 42, 999, 999]\n- Predicted Coordinate: [145, 42, 191, 128]\n5\\. Missing Coordinate: [145, 3, 999, 999]\n- Predicted Coordinate: [145, 3, 190, 124]\nThese missing deliveries occurred within the x-value range of 20 to 40, specifically in the Midtown Mall area. The predicted coordinates have been calculated by analyzing the trajectory data pattern before and after the missing points.\nWe kindly request that you review this information and take the necessary actions to address these unfulfilled deliveries. Your prompt attention to this matter will help ensure that our delivery operations continue to run smoothly and efficiently.\nPlease feel free to reach out if you require further details or clarification regarding this issue.\nThank you for your cooperation.\nBest regards,\n[Your Full Name]\n[Your Position]\n[Your Company Name]\n[Your Contact Information] \n```", "```py\n**User01:** How could the trajectory, missing coordinates, and predicted coordinates be used for disaster prediction such as fires? Explain and create an output for this use case.\n**Agent:** Trajectory data, missing coordinates, and predicted coordinates can be valuable tools in disaster prediction and management, such as for fires, in the following ways:\n1\\. **Trajectory Analysis**: By analyzing the movement patterns of vehicles, drones, or other mobile units, authorities can identify areas that are frequently visited or monitored. This can help in understanding the normal patterns of activity and detecting anomalies that might indicate a disaster, such as a sudden deviation from a typical route due to a fire.\n2\\. **Missing Coordinates**: Missing data points can indicate areas where monitoring or data collection was interrupted, possibly due to a disaster like a fire. Identifying these gaps can help in pinpointing locations that need immediate attention or further investigation.\n3\\. **Predicted Coordinates**: By predicting the missing coordinates, authorities can fill in the gaps in the data to maintain a continuous monitoring system. This can help in reconstructing the events leading up to a disaster and in planning the response by understanding the spread and impact of the fire.\n### Use Case Output for Disaster Prediction (Fires)\n**Scenario**: A fire has been reported in a forest area, and trajectory data from drones monitoring the region is being analyzed to assess the situation.\n**Output**:\njson<br>{<br> \"fire_prediction_analysis\": {<br> \"trajectory_analysis\": \"Drones deviated from their usual path at coordinates [145, 20] to [145, 40], indicating potential fire activity.\",<br> \"missing_coordinates\": [<br> {\"missing_coordinate\": [145, 25, 999, 999], \"predicted_coordinate\": [145, 25, 190, 130]},<br> {\"missing_coordinate\": [145, 30, 999, 999], \"predicted_coordinate\": [145, 30, 191, 128]}<br> ],<br> \"predicted_fire_area\": [<br> {\"coordinate\": [145, 25, 190, 130]},<br> {\"coordinate\": [145, 30, 191, 128]}<br> ],<br> \"actionable_insights\": \"Immediate investigation and firefighting efforts are recommended in the predicted fire area to prevent further spread.\"<br> }<br>}<br>\nThis output provides a structured analysis of the situation, helping disaster management teams to quickly identify and respond to potential fire threats based on trajectory data and inferred information. \n```"]