<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-97">
    <a id="_idTextAnchor099">
    </a>
    
     5
    
   </h1>
   <h1 id="_idParaDest-98">
    <a id="_idTextAnchor100">
    </a>
    
     Improving Agent Navigation
    
   </h1>
   <p>
    
     Now that you have a strong grip on the basics of the Unreal Engine pathfinding system, it’s time to get deeper and start delving into the intricate workings of enhancing the agent
    
    
     
      Navigation System.
     
    
   </p>
   <p>
    
     In this chapter, you will discover how to improve your nav mesh generation and agent movement: starting from dynamically generated meshes, going through querying the environment, up until avoiding other
    
    
     
      agents efficiently.
     
    
   </p>
   <p>
    
     By the end of this chapter, you will have some brand-new skills to make your levels more engaging and interesting.
    
    
     This knowledge will serve as a fundamental building block in guiding your path toward creating sophisticated games, ultimately enhancing your skills as an AI
    
    
     
      game programmer.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Generating navigation meshes
     
     
      
       at runtime
      
     
    </li>
    <li>
     
      Influencing navigation with
     
     
      
       query filters
      
     
    </li>
    <li>
     
      Implementing
     
     
      
       agent avoidance
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-99">
    <a id="_idTextAnchor101">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow the topics presented in this chapter, you should have completed the previous ones and understood
    
    
     
      their content.
     
    
   </p>
   <p>
    
     Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the
    
    <strong class="source-inline">
     
      .zip
     
    </strong>
    
     project files provided in this book’s companion project repository
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5">
     
      
       https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     You can download the files corresponding to the end of the last chapter by clicking on the
    
    <strong class="source-inline">
     
      Unreal Agility Arena –
     
    </strong>
    
     <strong class="source-inline">
      
       Chapter 04
      
     </strong>
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     <strong class="source-inline">
      
       End
      
     </strong>
    
    
     
      link.
     
    
   </p>
   <h1 id="_idParaDest-100">
    <a id="_idTextAnchor102">
    </a>
    
     Generating navigation meshes at runtime
    
   </h1>
   <p>
    
     Let’s continue our short novel started in
    
    <a href="B31016_04.xhtml#_idTextAnchor073">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a
     
    </em>
    
     <em class="italic">
      
       Navigation Mesh
      
     </em>
    
    
     
      :
     
    
   </p>
   <p>
    <em class="italic">
     
      In the secret research laboratory, a groundbreaking experiment was underway.
     
     
      The artificial intelligence dummy puppets, developed by Dr.
     
     
      Markus and Professor Viktoria, were primed for a quest: equipped with advanced pathfinding systems, the puppets were cleverly placed in the lab’s complex network of corridors and
     
    </em>
    
     <em class="italic">
      
       interconnected rooms.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      They faced simulated construction zones, unexpected barriers, and even simulated distractions that obstructed their path.
     
     
      However, armed with their state-of-the-art AI capabilities, the puppets swiftly adapted to the changing circumstances, employing their ingenuity to find alternative routes and skillfully navigate through the intricate layout of
     
    </em>
    
     <em class="italic">
      
       the laboratory.
      
     </em>
    
   </p>
   <p>
    
     If you are
    
    <a id="_idIndexMarker204">
    </a>
    
     working with nav meshes, chances are you will sooner or later have objects that will be moving around and will cause the agent’s path to the target
    
    
     
      to change.
     
    
   </p>
   <p>
    
     This is why having a static nav mesh generation will become useless; you will need some kind of system that will update the nav mesh at runtime.
    
    
     This is why Unreal Engine provides more than one method for generating
    
    
     
      such meshes.
     
    
   </p>
   <p>
    
     As explained in
    
    <a href="B31016_03.xhtml#_idTextAnchor058">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Presenting the Unreal Engine Navigation System
     
    </em>
    
     , the generation method can be changed from
    
    <strong class="bold">
     
      Project Settings
     
    </strong>
    
     or the
    
    <strong class="bold">
     
      Recast Nav Mesh
     
    </strong>
    
     actor in a level; as we need to change the nav mesh generation just for this level, we will be selecting the
    
    
     
      second option.
     
    
   </p>
   <p>
    
     But first, we need to create a level for our puppet agent to
    
    
     
      walk on!
     
    
   </p>
   <h2 id="_idParaDest-101">
    <a id="_idTextAnchor103">
    </a>
    
     Creating the level
    
   </h2>
   <p>
    
     To create
    
    <a id="_idIndexMarker205">
    </a>
    
     this gym, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      From the main menu, select
     
     <strong class="bold">
      
       File
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        New Level
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Maps/LevelInstances
      
     </strong>
     
      folder and drag an instance of
     
     <strong class="bold">
      
       LI_Lighting
      
     </strong>
     
      inside your level; set its transform
     
     <strong class="bold">
      
       Location
      
     </strong>
     
      value to
     
     <strong class="source-inline">
      
       (0,
      
     </strong>
     
      <strong class="source-inline">
       
        0, 0)
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Maps/PackedLevelActors
      
     </strong>
     
      folder and drag an instance of
     
     <strong class="bold">
      
       PLA_Lab_02
      
     </strong>
     
      inside your level; set its transform
     
     <strong class="bold">
      
       Location
      
     </strong>
     
      value to
     
     <strong class="source-inline">
      
       (0,
      
     </strong>
     
      <strong class="source-inline">
       
        0, 0)
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Save the level in the
     
     <strong class="source-inline">
      
       Maps
      
     </strong>
     
      folder and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        Gym_NavMesh_04
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     This gym has
    
    <a id="_idIndexMarker206">
    </a>
    
     a block of stairs along with a detached platform, as depicted in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .1
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.1 – The gym" src="img/B31016_05_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.1 – The gym
    
   </p>
   <p>
    
     Now, let’s add the nav mesh along with the agent and the
    
    
     
      target point:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Nav Mesh Bounds Volume
      
     </strong>
     
      actor and set its boundaries so it covers the
     
     
      
       whole level.
      
     
    </li>
    <li>
     
      Add the
     
     <strong class="bold">
      
       NS_Target
      
     </strong>
     
      Niagara system at the top of the
     
     
      
       isolated platform.
      
     
    </li>
    <li>
     
      Add the
     
     <strong class="bold">
      
       BP_NavMeshAgent
      
     </strong>
     
      Blueprint on the blue tile and set the
     
     <strong class="bold">
      
       Target Actor
      
     </strong>
     
      property value to
     
     <strong class="source-inline">
      
       NS_Target
      
     </strong>
     
      .
     
     
      The level should now look
     
     
      
       as follows:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.2 – The gym with the nav mesh" src="img/B31016_05_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.2 – The gym with the nav mesh
    
   </p>
   <p>
    
     As we are using a
    
    <a id="_idIndexMarker207">
    </a>
    
     level that is slightly more complex than those presented in the previous chapter, you may experience a mesh generation that is slightly different from the one depicted in my screenshot; the stairs nav mesh may seem detached from the rest, or you may experience some other issue.
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .3
     
    </em>
    
     shows a typical scenario you
    
    
     
      may encounter:
     
    
   </p>
   <div><div><img alt="Figure 5.3 – Broken nav mesh" src="img/B31016_05_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.3 – Broken nav mesh
    
   </p>
   <p>
    
     To solve this type of problem, you will need to tweak the
    
    <strong class="bold">
     
      Recast Nav Mesh
     
    </strong>
    
     actor settings a bit.
    
    
     As an example, you may try to do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Default Cell Height
      
     </strong>
     
      property value
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        40.0
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set
     
     <strong class="bold">
      
       Agent Radius
      
     </strong>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        70.0
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     The first value will make the stairs navigable area connect to the rest of the level, while the second one will add some more padding to the border of the mesh so as to avoid an agent walking too close to the edges.
    
    
     Just play around with the values a bit until you get your
    
    
     
      desired result.
     
    
   </p>
   <p>
    
     If you test the level right now, you will notice that the agent will try to reach the target point but it will get stuck at the base of the detached platform; obviously, there isn’t a route to the destination, and your little agent may not make it all the way there, but it will give its best shot to get as close as
    
    
     
      it can.
     
    
   </p>
   <p>
    
     Now, try to
    
    <a id="_idIndexMarker208">
    </a>
    
     add some obstacles around the level to force your agent to climb the stairs – something like
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .4
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.4 – The gym with some obstacles" src="img/B31016_05_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.4 – The gym with some obstacles
    
   </p>
   <p>
    
     If you test the level, the agent will stop at the very first step of the stairs; this is happening because the step height is too high for the poor fellow!
    
    
     To solve this, open the
    
    <strong class="bold">
     
      BP_NavMeshAgent
     
    </strong>
    
     Blueprint, and in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, look for the
    
    <strong class="bold">
     
      Character Movement: Walking
     
    </strong>
    
     category and set the
    
    <strong class="bold">
     
      Max Step Height
     
    </strong>
    
     value
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       55.0
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This will allow the agent to take higher steps and climb the stairs.
    
    
     Test the level again and you should see the agent climbing the stairs and stopping at the very edge of them.
    
    
     The journey to the ultimate destination appears to be quite a challenge for our
    
    
     
      little friend!
     
    
   </p>
   <p>
    
     Let’s help it out by adding a pathway to the isolated platform, where the target point
    
    
     
      is located.
     
    
   </p>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor104">
    </a>
    
     Adding a moving platform
    
   </h2>
   <p>
    
     To make our agent reach
    
    <a id="_idIndexMarker209">
    </a>
    
     its target point, we are going to add a moving platform; this will allow us to create a dynamically generated
    
    
     
      nav mesh.
     
    
   </p>
   <h3>
    
     Creating the Blueprint
    
   </h3>
   <p>
    
     To do this, we will start with a static mesh and make it
    
    
     
      a Blueprint:
     
    
   </p>
   <ol>
    <li>
     
      In
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      , open the
     
     <strong class="source-inline">
      
       KayKit/ProtorypeBits/Models
      
     </strong>
     
      folder and drag a
     
     <strong class="bold">
      
       Primitive_Cube_Primitive_Cube
      
     </strong>
     
      instance into
     
     
      
       the level.
      
     
    </li>
    <li>
     
      Set its
     
     <strong class="bold">
      
       Location
      
     </strong>
     
      attribute to
     
     <strong class="source-inline">
      
       (380.0, 50.0, 60.0)
      
     </strong>
     
      so that it connects the staircase and the isolated
     
     
      
       yellow platforms.
      
     
    </li>
    <li>
     
      Set
     
     <strong class="bold">
      
       Mobility
      
     </strong>
     
      of this actor
     
     
      
       to
      
     
     
      <strong class="bold">
       
        Movable
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      With this actor selected, convert it into a Blueprint by clicking the
     
     <strong class="bold">
      
       Convert to
      
     </strong>
     
      <strong class="bold">
       
        Blueprint
       
      </strong>
     
     
      
       button.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.5 – The Convert to Blueprint button" src="img/B31016_05_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.5 – The Convert to Blueprint button
    
   </p>
   <ol>
    <li value="5">
     
      Save the Blueprint in the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        BP_MovingPlatform
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open the Blueprint by double-clicking
     
     
      
       the asset.
      
     
    </li>
   </ol>
   <p>
    
     We are now going to add some code logic, in order to make
    
    
     
      it move.
     
    
   </p>
   <h3>
    
     Adding the code
    
   </h3>
   <p>
    
     With the
    
    <strong class="bold">
     
      BP_MovingPlatform
     
    </strong>
    
     Blueprint open, start doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new variable of the
     
     <strong class="source-inline">
      
       Vector
      
     </strong>
     
      type and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        StartLocation
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Create a new variable of the
     
     <strong class="source-inline">
      
       Float
      
     </strong>
     
      type and name it
     
     <strong class="source-inline">
      
       VerticalOffset
      
     </strong>
     
      .
     
     
      From the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, check the
     
     <strong class="bold">
      
       Instance
      
     </strong>
     
      <strong class="bold">
       
        Editable
       
      </strong>
     
     
      
       property.
      
     
     <p class="list-inset">
      
       These two variables will store the initial position of the platform and the vertical distance it will cover while moving, respectively.
      
      
       The second one has also been made editable from
      
      
       
        the level.
       
      
     </p>
     <p class="list-inset">
      
       Now, in
      
      <strong class="bold">
       
        Event Graph
       
      </strong>
      
       , perform the
      
      
       
        following steps:
       
      
     </p>
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Set Start Location
      
     </strong>
     
      node and connect its incoming execution pin to the outgoing execution pin of the
     
     <strong class="bold">
      
       Event Begin
      
     </strong>
     
      <strong class="bold">
       
        Play
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Get Actor Location
      
     </strong>
     
      node and connect its
     
     <strong class="bold">
      
       Return Value
      
     </strong>
     
      outgoing pin to the
     
     <strong class="bold">
      
       Start Location
      
     </strong>
     
      incoming pin of the previously added
     
     
      
       setter node.
      
     
    </li>
    <li>
     
      From the outgoing execution pin of the
     
     <strong class="bold">
      
       Set Start Location
      
     </strong>
     
      node, add a
     
     <strong class="bold">
      
       Timeline
      
     </strong>
     
      node and double-click on it to
     
     
      
       start editing.
      
     
     <p class="list-inset">
      
       This part of the code stores
      
      <a id="_idIndexMarker210">
      </a>
      
       the platform’s initial position and initializes a timeline to set up the platform animation.
      
      
       The code so far is shown in
      
      
       <em class="italic">
        
         Figure 5
        
       </em>
      
      
       <em class="italic">
        
         .6
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 5.6 – The first part of the graph" src="img/B31016_05_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.6 – The first part of the graph
    
   </p>
   <p class="list-inset">
    
     The timeline is going to be a simple sinusoidal curve that will control the vertical offset of the platform.
    
    
     To create the curve, perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="6">
     
      Click the
     
     <strong class="bold">
      
       + Track
      
     </strong>
     
      button and, from the dropdown menu, select
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      <strong class="bold">
       
        Float Track
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the
     
     
      
       track
      
     
     
      <strong class="source-inline">
       
        Alpha
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the
     
     <strong class="bold">
      
       Length
      
     </strong>
     
      value of the curve
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        15.00
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click the
     
     <strong class="bold">
      
       Loop
      
     </strong>
     
      button to make the
     
     <strong class="bold">
      
       Timeline
      
     </strong>
     
      
       repeat indefinitely.
      
     
    </li>
    <li>
     
      In the curve graph, add three keys by right-clicking and selecting the
     
     <strong class="bold">
      
       Add key
      
     </strong>
     
      option.
     
     
      Set the keys’ values, respectively, to
     
     
      
       the following:
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Time
        
       </strong>
       
        to
       
       <strong class="source-inline">
        
         0.0
        
       </strong>
       
        and
       
       <strong class="bold">
        
         Value
        
       </strong>
       
        
         to
        
       
       
        <strong class="source-inline">
         
          0.0
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="bold">
        
         Time
        
       </strong>
       
        to
       
       <strong class="source-inline">
        
         7.5
        
       </strong>
       
        and
       
       <strong class="bold">
        
         Value
        
       </strong>
       
        
         to
        
       
       
        <strong class="source-inline">
         
          1.0
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       <strong class="bold">
        
         Time
        
       </strong>
       
        to
       
       <strong class="source-inline">
        
         15.0
        
       </strong>
       
        and
       
       <strong class="bold">
        
         Value
        
       </strong>
       
        
         to
        
       
       
        <strong class="source-inline">
         
          0.0
         
        </strong>
       
       
        
         .
        
       
      </li>
     </ul>
    </li>
    <li>
     
      Right-click on each key and set the
     
     <strong class="bold">
      
       KEY INTERPOLATION
      
     </strong>
     
      value to
     
     <strong class="bold">
      
       Auto
      
     </strong>
     
      ; this will make the curve sinusoidal and not linear.
     
     
      The resulting curve is shown in
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     
      <em class="italic">
       
        .7
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.7 – Timeline curve" src="img/B31016_05_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.7 – Timeline curve
    
   </p>
   <p class="list-inset">
    
     Get back to
    
    <strong class="bold">
     
      Event Graph
     
    </strong>
    
     and you
    
    <a id="_idIndexMarker211">
    </a>
    
     should notice that the
    
    <strong class="bold">
     
      Timeline
     
    </strong>
    
     node now has an
    
    <strong class="bold">
     
      Alpha
     
    </strong>
    
     outgoing pin; we will use it to control the vertical position of the platform.
    
    
     Start doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="12">
     
      Add a
     
     <strong class="bold">
      
       Get Vertical
      
     </strong>
     
      <strong class="bold">
       
        Offset
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Get Start Location
      
     </strong>
     
      node; right-click on its outgoing pin and select
     
     <strong class="bold">
      
       Split Struct Pin
      
     </strong>
     
      to expose the
     
     <strong class="bold">
      
       X
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       Y
      
     </strong>
     
      , and
     
     <strong class="bold">
      
       Z
      
     </strong>
     
      pins of
     
     
      
       the structure.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Multiply
      
     </strong>
     
      node and connect its two incoming pins to the
     
     <strong class="bold">
      
       Vertical Offset
      
     </strong>
     
      outgoing pin and to the
     
     <strong class="bold">
      
       Alpha
      
     </strong>
     
      outgoing pin
     
     
      
       of
      
     
     
      <strong class="bold">
       
        Timeline
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add an
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      node and connect its two incoming pins to the outgoing pin of the
     
     <strong class="bold">
      
       Multiply
      
     </strong>
     
      node and the outgoing
     
     <strong class="bold">
      
       Start Location Z
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Get Start
      
     </strong>
     
      <strong class="bold">
       
        Location
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Set Actor Location
      
     </strong>
     
      node to the graph, connect its incoming execution pin to the outgoing execution pin of the
     
     <strong class="bold">
      
       Timeline
      
     </strong>
     
      node, and do
     
     
      
       the following:
      
     
     <ol>
      <li class="upper-roman">
       
        Right-click on the
       
       <strong class="bold">
        
         New Location
        
       </strong>
       
        incoming pin and select
       
       <strong class="bold">
        
         Split Struct Pin
        
       </strong>
       
        to expose the
       
       <strong class="bold">
        
         X
        
       </strong>
       
        ,
       
       <strong class="bold">
        
         Y
        
       </strong>
       
        , and
       
       <strong class="bold">
        
         Z
        
       </strong>
       
        pins of
       
       
        
         the structure.
        
       
      </li>
      <li class="upper-roman">
       
        Connect the incoming
       
       <strong class="bold">
        
         New Location X
        
       </strong>
       
        pin to the outgoing
       
       <strong class="bold">
        
         Start Location X
        
       </strong>
       
        pin of the
       
       <strong class="bold">
        
         Get Start
        
       </strong>
       
        <strong class="bold">
         
          Location
         
        </strong>
       
       
        
         node.
        
       
      </li>
      <li class="upper-roman">
       
        Connect the incoming
       
       <strong class="bold">
        
         New Location Y
        
       </strong>
       
        pin to the outgoing
       
       <strong class="bold">
        
         Start Location Y
        
       </strong>
       
        pin of the
       
       <strong class="bold">
        
         Get Start
        
       </strong>
       
        <strong class="bold">
         
          Location
         
        </strong>
       
       
        
         node.
        
       
      </li>
      <li class="upper-roman">
       
        Connect the
       
       <a id="_idIndexMarker212">
       </a>
       
        incoming
       
       <strong class="bold">
        
         New Location Z
        
       </strong>
       
        pin to the outgoing pin of the
       
       <strong class="bold">
        
         Add
        
       </strong>
       
        node.
       
       
        The result of this part of the graph is shown in
       
       
        <em class="italic">
         
          Figure 5
         
        </em>
       
       
        <em class="italic">
         
          .8
         
        </em>
       
       
        
         :
        
       
      </li>
     </ol>
    </li>
   </ol>
   <div><div><img alt="Figure 5.8 – The second part of the graph" src="img/B31016_05_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.8 – The second part of the graph
    
   </p>
   <p>
    
     Although quite lengthy, this code is pretty straightforward; it simply uses the
    
    <strong class="bold">
     
      Timeline
     
    </strong>
    
     node to compute an offset over time and applies it to the platform’s
    
    <strong class="bold">
     
      Z
     
    </strong>
    
     position.
    
    
     At runtime, the platform will keep going up and down, creating a passage to the target point once every 15 seconds – that is, the duration of
    
    
     
      the loop.
     
    
   </p>
   <p>
    
     If you simulate the gym right now – with the nav mesh visible – something weird will happen; although the platform will be moving up and down, the nav mesh will stay as originally generated, leaving a
    
    
     
      floating passage.
     
    
   </p>
   <div><div><img alt="Figure 5.9 – Static generation" src="img/B31016_05_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.9 – Static generation
    
   </p>
   <p>
    
     This issue is happening because the nav mesh is generated statically and won’t be changed at runtime; the poor little fellow will drop off while trying to reach its target point, believing that a
    
    
     
      passage exists!
     
    
   </p>
   <p>
    
     Let’s fix this immediately by making the nav
    
    
     
      mesh dynamic.
     
    
   </p>
   <h2 id="_idParaDest-103">
    <a id="_idTextAnchor105">
    </a>
    
     Making the nav mesh dynamic
    
   </h2>
   <p>
    
     As stated at the beginning
    
    <a id="_idIndexMarker213">
    </a>
    
     of this section, we are going to set the mesh runtime generation active just for this level, so we need to change the
    
    <strong class="bold">
     
      Recast Nav Mesh
     
    </strong>
    
     actor.
    
    
     To do this, select the
    
    <strong class="bold">
     
      Recast Nav Mesh
     
    </strong>
    
     actor and, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, locate the
    
    <strong class="bold">
     
      Runtime
     
    </strong>
    
     category.
    
    
     Set the
    
    <strong class="bold">
     
      Runtime Generation
     
    </strong>
    
     dropdown value
    
    
     
      to
     
    
    
     <strong class="bold">
      
       Dynamic
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     If you test the gym, you will now see the nav mesh updating at regular intervals and the passage will
    
    
     
      be interrupted.
     
    
   </p>
   <div><div><img alt="Figure 5.10 – Dynamic generation" src="img/B31016_05_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.10 – Dynamic generation
    
   </p>
   <p>
    
     You may notice that the
    
    <a id="_idIndexMarker214">
    </a>
    
     agent will stop at the edge of the stairs platform and won’t go on when the moving platform creates the passage.
    
    
     To fix this small issue, do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Open
     
     <strong class="bold">
      
       BP_NavMeshAgent
      
     </strong>
     
      and disconnect the
     
     <strong class="bold">
      
       Event
      
     </strong>
     
      <strong class="bold">
       
        BeginPlay
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       Move to Actor
      
     </strong>
     
      incoming execution pin to the outgoing execution pin of the
     
     <strong class="bold">
      
       Event
      
     </strong>
     
      <strong class="bold">
       
        Tick
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Open the
     
     <strong class="bold">
      
       Class Defaults
      
     </strong>
     
      tab and set the
     
     <strong class="bold">
      
       Tick Interval (secs)
      
     </strong>
     
      attribute to
     
     <strong class="source-inline">
      
       0.5
      
     </strong>
     
      , to make the update a bit sparser.
     
     
      The updated Blueprint is shown in
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     
      <em class="italic">
       
        .11
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.11 – Updated Blueprint" src="img/B31016_05_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.11 – Updated Blueprint
    
   </p>
   <p>
    
     What we have done here is pretty simple; instead of executing the code once at the start of the game, we set it to be executed once every tick – set to half a second – in order to keep on setting the final destination.
    
    
     This may not be the most performance-efficient solution, but it should work well for our
    
    
     
      small prototype.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Keep in mind that updating a nav mesh at runtime is heavy on computation; this means that you should use this feature only when necessary and stick to the static generation most of
    
    
     
      the time.
     
    
   </p>
   <p>
    
     Now that you have mastered creating dynamic nav meshes, your tiny little agent will be in for a challenge as it navigates toward its target point.
    
    
     Life – or rather, artificial life – won’t be as simple for
    
    
     
      it anymore!
     
    
   </p>
   <p>
    
     In the next section, I’m going to introduce you to navigation filters, a feature that will let you change the way an agent behaves on the
    
    
     
      nav mesh.
     
    
   </p>
   <h1 id="_idParaDest-104">
    <a id="_idTextAnchor106">
    </a>
    
     Influencing navigation with query filters
    
   </h1>
   <p>
    
     As already mentioned in
    
    <a href="B31016_03.xhtml#_idTextAnchor058">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Presenting the Unreal Engine Navigation System
     
    </em>
    
     , with query
    
    <a id="_idIndexMarker215">
    </a>
    
     filters, you can custom tailor the navigation paths of AI agents, enabling you to enhance and optimize their movement in
    
    
     
      the environment.
     
    
   </p>
   <p>
    
     You may have noticed that the
    
    <strong class="bold">
     
      Move to Actor
     
    </strong>
    
     method in the previously created graph has an attribute named
    
    <strong class="bold">
     
      Filter Class
     
    </strong>
    
     (see
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    <em class="italic">
     
      .11
     
    </em>
    
     ); this will allow us to customize the way our agent behaves on a
    
    
     
      nav mesh.
     
    
   </p>
   <p>
    
     A filter is created by extending the
    
    <strong class="source-inline">
     
      NavigationQueryFilter
     
    </strong>
    
     class and setting some appropriate values, so let’s start by creating one such class and see how
    
    
     
      it works.
     
    
   </p>
   <h2 id="_idParaDest-105">
    <a id="_idTextAnchor107">
    </a>
    
     Creating the level
    
   </h2>
   <p>
    
     As a first step, we will need a
    
    <a id="_idIndexMarker216">
    </a>
    
     gym for testing filters; in this case, we are going to duplicate a pre-existing one and tweak it
    
    
     
      a bit:
     
    
   </p>
   <ol>
    <li>
     
      Duplicate the
     
     <strong class="bold">
      
       Gym_NavMesh_02
      
     </strong>
     
      map, rename it
     
     <strong class="source-inline">
      
       Gym_NavMesh_05
      
     </strong>
     
      , and
     
     
      
       open it.
      
     
    </li>
    <li>
     
      Remove all the obstacles from the bridge –
     
     
      
       if any.
      
     
    </li>
    <li>
     
      Duplicate the agent and put it at the side of the first one, on the
     
     
      
       blue tile.
      
     
    </li>
    <li>
     
      To make the agents recognizable, you may wish to change the material of the duplicate; in my case, I opted for
     
     <strong class="bold">
      
       MI_Prototype_B
      
     </strong>
     
      .
     
     
      The final level should be like the one depicted in
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     
      <em class="italic">
       
        .12
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.12 – The base gym" src="img/B31016_05_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.12 – The base gym
    
   </p>
   <p>
    
     If you test the level, unsurprisingly, both agents will go toward the bridge, traverse it, and get to the
    
    
     
      target point.
     
    
   </p>
   <p>
    
     Let’s spice things up a bit,
    
    
     
      shall we?
     
    
   </p>
   <h2 id="_idParaDest-106">
    <a id="_idTextAnchor108">
    </a>
    
     Creating the query filter class
    
   </h2>
   <p>
    
     We are now going to
    
    <a id="_idIndexMarker217">
    </a>
    
     create a query filter that will override the way navigation modifiers are considered; we want the mud area to be considered less costly and easily traversable, but just for a single agent.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      and, in the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder, create a new Blueprint class of the
     
     <strong class="bold">
      
       Navigation Query
      
     </strong>
     
      <strong class="bold">
       
        Filter
       
      </strong>
     
     
      
       type.
      
     
    </li>
    <li>
     
      Name the asset
     
     <strong class="source-inline">
      
       NavFilter_MudWalker
      
     </strong>
     
      and double-click on it to
     
     
      
       open it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, you will see an
     
     <strong class="bold">
      
       Areas
      
     </strong>
     
      array attribute; click on the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to add
     
     
      
       an element.
      
     
    </li>
    <li>
     
      Open the element and do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        From the
       
       <strong class="bold">
        
         Area Class
        
       </strong>
       
        dropdown menu,
       
       
        
         select
        
       
       
        <strong class="bold">
         
          NavArea_Mud
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       
        Check the
       
       <strong class="bold">
        
         Travel Cost Override
        
       </strong>
       
        checkbox and set its value
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          1.0
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       
        Check the
       
       <strong class="bold">
        
         Entering Cost Override
        
       </strong>
       
        checkbox and set its value
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          0.0
         
        </strong>
       
       
        
         .
        
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 5.13 – Query filter settings" src="img/B31016_05_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.13 – Query filter settings
    
   </p>
   <p>
    
     We are basically
    
    <a id="_idIndexMarker218">
    </a>
    
     creating a different cost for the muddy area of our level – that is, where the
    
    <strong class="bold">
     
      NavArea_Mud
     
    </strong>
    
     modifiers
    
    
     
      are placed.
     
    
   </p>
   <p>
    
     We now need to modify the AI agent a bit, so it will accept this kind
    
    
     
      of modifier.
     
    
   </p>
   <h2 id="_idParaDest-107">
    <a id="_idTextAnchor109">
    </a>
    
     Modifying the agent
    
   </h2>
   <p>
    
     We need to make a
    
    <a id="_idIndexMarker219">
    </a>
    
     slight modification to the agent, so open the
    
    <strong class="bold">
     
      BP_NavMeshAgent
     
    </strong>
    
     Blueprint class and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      From the
     
     <strong class="bold">
      
       Move to Actor
      
     </strong>
     
      node, click and drag on the
     
     <strong class="bold">
      
       Filter Class
      
     </strong>
     
      incoming pin, and, once released, select
     
     <strong class="bold">
      
       Promote
      
     </strong>
     
      <strong class="bold">
       
        to variable
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the newly created variable
     
     <strong class="source-inline">
      
       FilterClass
      
     </strong>
     
      and make it
     
     <strong class="bold">
      
       Instance Editable
      
     </strong>
     
      by checking the corresponding attribute in the
     
     
      <strong class="bold">
       
        Details
       
      </strong>
     
     
      
       panel.
      
     
    </li>
    <li>
     
      Compile the
     
     <strong class="bold">
      
       Blueprint
      
     </strong>
     
      and double-check in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel that
     
     <strong class="bold">
      
       Default Value
      
     </strong>
     
      is set
     
     
      
       to
      
     
     
      <strong class="bold">
       
        None
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Whenever you tell the agent to move to a target point, it will use the
    
    <strong class="source-inline">
     
      FilterClass
     
    </strong>
    
     variable – if set to any value – to override the nav mesh
    
    
     
      cost rules.
     
    
   </p>
   <p>
    
     Let’s test it out in action.
    
    
     Open your gym and select the second agent; then, from the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, from the
    
    <strong class="bold">
     
      Filter Class
     
    </strong>
    
     dropdown,
    
    
     
      select
     
    
    
     <strong class="bold">
      
       NavFilter_MudWalker
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Test the gym and you will now notice the second agent go straight to the target point, moving through the mud.
    
    
     This cheeky AI agent has gone rogue and decided to play dirty,
    
    
     
      hasn’t it?
     
    
   </p>
   <p>
    
     In this section, you have discovered the ability to override the cost of a nav mesh, which grants you significant power in creating highly customizable AI characters.
    
    
     With this newfound capability, you can make your AI characters behave distinctively and stand out from the rest of the crowd.
    
    
     I am pretty confident you will understand that this opens up a world of possibilities for creating unique and dynamic
    
    
     
      gameplay experiences.
     
    
   </p>
   <p>
    
     In the next section, I will show you another important technique in AI pathfinding, and that’s how to make your AI agents avoid
    
    
     
      each other.
     
    
   </p>
   <h1 id="_idParaDest-108">
    <a id="_idTextAnchor110">
    </a>
    
     Implementing agent avoidance
    
   </h1>
   <p>
    
     It comes as no surprise that, most of the
    
    <a id="_idIndexMarker220">
    </a>
    
     time, you will be working with more than a single agent in a level, and this means there will be a high probability that they will have crossing pathfinding rules; this means that your poor AI entities will be at a significant risk of colliding with each other.
    
    
     As funny as it may be, I guess that’s not the intended behavior in
    
    
     
      your game.
     
    
   </p>
   <p>
    
     That’s why Unreal Engine provides an out-of-the-box – but disabled by default – avoidance system.
    
    
     In this section, we are going to consider how to make AI agents avoid
    
    
     
      each other.
     
    
   </p>
   <p>
    
     As always, we will start with a
    
    
     
      brand-new gym.
     
    
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor111">
    </a>
    
     Creating the level
    
   </h2>
   <p>
    
     As a first step, we will need a gym
    
    <a id="_idIndexMarker221">
    </a>
    
     with some obstacles around.
    
    
     To get started, do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      From the main menu, select
     
     <strong class="bold">
      
       File
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        New Level
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Maps/LevelInstances
      
     </strong>
     
      folder and drag an instance of
     
     <strong class="bold">
      
       LI_Lighting
      
     </strong>
     
      inside your level; set its transform
     
     <strong class="bold">
      
       Location
      
     </strong>
     
      value to
     
     <strong class="source-inline">
      
       (0,
      
     </strong>
     
      <strong class="source-inline">
       
        0, 0)
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Maps/PackedLevelActors
      
     </strong>
     
      folder and drag an instance of
     
     <strong class="bold">
      
       PLA_Lab_05
      
     </strong>
     
      inside your level; set its transform
     
     <strong class="bold">
      
       Location
      
     </strong>
     
      value to
     
     <strong class="source-inline">
      
       (0,
      
     </strong>
     
      <strong class="source-inline">
       
        0, 0)
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Save the level in the
     
     <strong class="source-inline">
      
       Maps
      
     </strong>
     
      folder and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        Gym_NavMesh_06
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     This gym is slightly bigger
    
    <a id="_idIndexMarker222">
    </a>
    
     than the previous ones and has some obstacles to make things more interesting.
    
    
     Additionally, there are eight blue tiles – we’re going to use eight agents – as depicted in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .14
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.14 – The gym" src="img/B31016_05_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.14 – The gym
    
   </p>
   <h2 id="_idParaDest-110">
    <a id="_idTextAnchor112">
    </a>
    
     Adding the agents
    
   </h2>
   <p>
    
     As previously mentioned, we are
    
    <a id="_idIndexMarker223">
    </a>
    
     going to add several agents – eight in total – to check how they behave in a crowded environment.
    
    
     So, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Add eight instances of the
     
     <strong class="bold">
      
       BP_NavMeshAgent
      
     </strong>
     
      Blueprint on the level and put each one in a blue tile in
     
     
      
       the level.
      
     
    </li>
    <li>
     
      Add eight instances of the
     
     <strong class="bold">
      
       NS_Target
      
     </strong>
     
      Niagara system and put them just behind each
     
     
      
       blue tile.
      
     
    </li>
    <li>
     
      For each agent, set the
     
     <strong class="bold">
      
       Target Actor
      
     </strong>
     
      property value to the
     
     <strong class="bold">
      
       NS_Target
      
     </strong>
     
      Niagara system that is on the opposite side of the gym.
     
     
      The level should now look like
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     
      <em class="italic">
       
        .15
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.15 – The finished gym" src="img/B31016_05_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.15 – The finished gym
    
   </p>
   <p>
    
     If you try testing the
    
    <a id="_idIndexMarker224">
    </a>
    
     gym, chances are that some of your agents will collide with some other agent moving in the opposite direction, as depicted in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .16
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.16 – Ouch, this hurts!" src="img/B31016_05_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.16 – Ouch, this hurts!
    
   </p>
   <p>
    
     Luckily, our agents are geared up with safety helmets, unlike the characters in your game who might be cruising without any protection!
    
    
     That’s why we are going to make the agents’ pathfinding
    
    
     
      slightly cleverer.
     
    
   </p>
   <h2 id="_idParaDest-111">
    <a id="_idTextAnchor113">
    </a>
    
     Activating avoidance
    
   </h2>
   <p>
    
     Once you have
    
    <a id="_idIndexMarker225">
    </a>
    
     opened the
    
    <strong class="bold">
     
      BP_NavMeshAgent
     
    </strong>
    
     Blueprint, you are ready to enable the avoidance system.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Character Movement: Avoidance
      
     </strong>
     
      category and check the
     
     <strong class="bold">
      
       Use
      
     </strong>
     
      <strong class="bold">
       
        RVOAvoidance
       
      </strong>
     
     
      
       property.
      
     
    </li>
    <li>
     
      Set
     
     <strong class="bold">
      
       Avoidance Consideration Radius
      
     </strong>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        2000.0
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     As stated in
    
    <a href="B31016_03.xhtml#_idTextAnchor058">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Presenting the Unreal Engine Navigation System
     
    </em>
    
     , RVO refers to a feature that enables AI agents to avoid collisions with
    
    
     
      each other.
     
    
   </p>
   <p>
    
     When the
    
    <strong class="bold">
     
      Use RVOAvoidance
     
    </strong>
    
     property is enabled for a character or agent, it allows them to dynamically adjust their movement to avoid colliding with other agents in the environment.
    
    
     The
    
    <strong class="bold">
     
      Avoidance Consideration Radius
     
    </strong>
    
     property is used to define the radius within which an agent considers other agents for
    
    
     
      collision avoidance.
     
    
   </p>
   <p>
    
     Testing the gym at this point will let you see the avoidance system at work; agents will avoid each other while reaching their
    
    
     
      target point.
     
    
   </p>
   <h2 id="_idParaDest-112">
    <a id="_idTextAnchor114">
    </a>
    
     Testing a worst-case scenario
    
   </h2>
   <p>
    
     Let’s test something
    
    <a id="_idIndexMarker226">
    </a>
    
     different; we will be creating a gym where spaces will be a bit more challenging for the agents.
    
    
     The new gym will be a duplicate of the previous one.
    
    
     Start by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Duplicate the
     
     <strong class="bold">
      
       Gym_NavMesh_06
      
     </strong>
     
      map and call
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        Gym_NavMesh_07
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add some obstacles that will create a narrow path, almost forcing the characters to follow a single, specific route.
     
     
      My gym is shown in
     
     
      <em class="italic">
       
        Figure 5
       
      </em>
     
     
      <em class="italic">
       
        .17
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.17 – Worst-case scenario" src="img/B31016_05_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.17 – Worst-case scenario
    
   </p>
   <p>
    
     Test the game, and you will witness all the agents diligently making efforts to avoid colliding with one another.
    
    
     You can make a countertest and uncheck the
    
    <strong class="bold">
     
      Use RVOAvoidance
     
    </strong>
    
     property; you will notice that all the agents initially cluster together and collide with each
    
    <a id="_idIndexMarker227">
    </a>
    
     other before eventually resolving their paths and reaching their respective
    
    
     
      target points.
     
    
   </p>
   <div><div><img alt="Figure 5.18 – Mass collision" src="img/B31016_05_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.18 – Mass collision
    
   </p>
   <p>
    
     In this section, you have learned how to implement collision avoidance for agents moving on a nav mesh, ensuring that they can successfully navigate while actively avoiding collisions with
    
    
     
      other agents.
     
    
   </p>
   <h1 id="_idParaDest-113">
    <a id="_idTextAnchor115">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we were introduced to some more advanced features of the Unreal Engine pathfinding system.
    
    
     Firstly, we saw how to create a nav mesh that can be updated at runtime.
    
    
     Next, we saw how you can override the way an agent interprets the cost of a nav mesh section.
    
    
     Finally, we saw how to use the built-in avoidance system so that AI agents won’t collide with
    
    
     
      each other.
     
    
   </p>
   <p>
    
     In the upcoming chapter, we will explore the final component of the pathfinding system: debugging and optimization techniques.
    
    
     We will explore ways to identify and resolve any issues that may arise and optimize the system for improved performance.
    
    
     Get ready for an exciting and
    
    
     
      informative session!
     
    
   </p>
  </div>
 </body></html>