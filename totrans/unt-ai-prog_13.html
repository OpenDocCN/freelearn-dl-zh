<html><head></head><body>
		<div><h1 id="_idParaDest-141"><em class="italic"><a id="_idTextAnchor527"/>Chapter 10</em>: Procedural Content Generation</h1>
			<p>Game AI is not only used to tell NPCs where to go or what to do. We can also use game AI to create parts of our games, to generate assets or music, to adapt the game story to the player's actions as a movie director, and even to generate narrative arcs and character backstories entirely. In the general AI world, this is the topic of <strong class="bold">Computational Creativity</strong>, a branch of AI concerned with the design of algorithms to enhance human creativity or completely automate tasks requiring human-level creativity.</p>
			<p>The scope of computational creativity is broad and cutting edge. It started in 1952 with Alan Turing writing the first algorithm capable of generating love letters. Today, it continues with powerful machine-learning-powered algorithms attempting to write poetry, compose symphonies, or produce astounding visual art pieces. </p>
			<p>Luckily for us, in games, we are interested in a more limited subset of this discipline. We are not interested in producing algorithms with human-level creativity (with all the philosophical questions attached to this endeavor). Instead, we only want to write algorithms that can automatically expand the contents of our game, be it by generating thousands of random dungeons, hundreds of new weapons, models of alien flora and animals, or anything else. This is called <strong class="bold">Procedural Content Generation</strong> (<strong class="bold">PCG</strong>), and it is a prominent protagonist of videogame automation.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding the basic concept of PCG in video games</li>
				<li>Dipping our toes into PCG by implementing a random generator for the names of Goblin NPCs</li>
				<li>Implementing a simple cave/dungeon generator</li>
			</ul>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor528"/>Technical requirements</h1>
			<p> For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <code>Chapter 10</code> folder in the book's repository: <a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter10">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter10</a>.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor529"/>Understanding Procedural Content Generation in games</h1>
			<p>As discussed in<a id="_idIndexMarker491"/> the introduction, we are refering to all the<a id="_idIndexMarker492"/> algorithms that can generate game content at runtime with PCG algorithms. A PCG algorithm may create the level design, weapons, graphical assets, musical themes, enemies, NPCs, characters' backstories, and whatever else you set your mind on. If you think about any element in a game, there is a chance that there is at least one game that attempted to generate it procedurally. But why should you?</p>
			<p>Nowadays, PCG has become a synonym of <em class="italic">random</em> for the general public. Many games advertise having <em class="italic">procedurally generated levels</em> as a way of saying that they offer thousands of different levels that change at every playthrough. While PCG <em class="italic">may</em> indicate some process of causality, it is worth noting that that's just part of the PCG landscape (even if, probably, the most marketable). More properly, PCG is the opposite of randomness: it is an algorithm that very deterministically starts from a <em class="italic">seed</em> and produces some content (but, of course, if we use a random seed, we obtain random outputs).</p>
			<p>There are two principal use cases for PCG:</p>
			<ul>
				<li>The first is to <a id="_idIndexMarker493"/>use PCG to generate <em class="italic">persistent content that is impossible to pre-generate during development</em>. If the content is too big to be stored in a file or manual generation requires too much effort, we may have this necessity. For instance, the original space simulation game <em class="italic">Elite</em> (1985) used PCG to store 8 galaxies with a 256-star system each (in addition to the game code) in just 32 KB. With the increase in available disk space, this use case is no longer the biggest. However, it is still possible to find uses. The new version of Elite, called <em class="italic">Elite: Dangerous</em>, released in 2014, used the same approach to represent a real-scale copy of the Milky Way with the astounding number of 400 billion fully explorable star systems. Note that there is no randomness involved: the galaxy is persistent, and all the players share it in the game. It would be simply impossible to store the individual data for each star system on disk.<p class="callout-heading">More Info</p><p class="callout">You can find an inspiring and exciting analysis of the generative algorithm of the original Elite game at this URL: <a href="https://www.gamedeveloper.com/design/algorithms-for-an-infinite-universe">https://www.gamedeveloper.com/design/algorithms-for-an-infinite-universe</a>.</p></li>
				<li>The second is the most common use case: <em class="italic">add variety and replayability to a game by casually generating content at every playthrough</em>. Rogue-like games<a id="_idIndexMarker494"/> popularized this PCG use, but the most successful videogame using PCG to forge a different random world at every new run is, without doubt, Minecraft. With PCG, you do not need to craft every level manually or to design hundreds of different levels: you just need to specify the <em class="italic">rules</em> and let the software automatically generate a wide variety of levels or weapons.</li>
			</ul>
			<p>Now<a id="_idIndexMarker495"/> that<a id="_idIndexMarker496"/> we understand <em class="italic">why</em>, let's explore some different types of PCG algorithms.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor530"/>Kinds of Procedural Content Generation</h2>
			<p>During the<a id="_idIndexMarker497"/> long history of game development, PCG has been used for a wide variety of tasks. As a result, we can identify six applications of PCG:</p>
			<ul>
				<li><strong class="bold">Runtime Content Generation</strong>: This is <a id="_idIndexMarker498"/>the type of PCG we instinctively think about when we hear PCG. It includes the generation at runtime of the game contents. The creation of random worlds in <em class="italic">Minecraft</em> or random maps and weapons in <em class="italic">Diablo</em> are typical examples of this category.</li>
				<li><strong class="bold">Offline Content Generation</strong>: This is the type of PCG we use during development. Even <a id="_idIndexMarker499"/>if we do not plan to give the players the ability to explore a randomly generated world, PCG is still useful for designers and developers. For instance, if we create a forest, we can use PCG to create 3D models of trees with different shapes (<strong class="bold">SpeedTree</strong> is a<a id="_idIndexMarker500"/> standard tool used for this purpose). We can also use PCG to kickstart the manual design of levels. Suppose we want to design an island. We may start by generating a simple random PCG island, then choose the one that most inspires us, and finally apply manual editing and modeling to it to create the final island we will ship in the final game. There are many other applications of PCG for design tools, but they go way out of the scope of this chapter.</li>
				<li><strong class="bold">Player-Mediated Content Generation</strong>: These types of PCG algorithms use the players' input<a id="_idIndexMarker501"/> as a source of <em class="italic">randomness</em>.</li>
				<li><strong class="bold">Dynamic Systems</strong>: This <a id="_idIndexMarker502"/>kind of PCG generates NPCs' behavior and a narrative background by simulating dynamic systems. A notable example is the A-Life system of the game called <em class="italic">S.T.A.L.K.E.R.</em>. In the game, the A-Life system simulates the life cycle of thousands of inhabitants of the game world. Consequently, the <a id="_idIndexMarker503"/>system provides infinite non-scripted characters to interact with and unlimited side-quests.</li>
			</ul>
			<p>But that is enough theory for now. Let's start coding.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor531"/>Implementing a simple goblin name generator</h1>
			<p>In the previous<a id="_idIndexMarker504"/> section, we explained that the primary purpose of PCG is to provide variety while removing from the developer the burden of scripting such variety by hand. So, imagine that we are developing an old-school RPG, and we want the players to be able to interact with the NPC characters of a goblin encampment.</p>
			<p>In the encampment, there are hundreds of goblins, and we really want to avoid coming up with the name and the occupation of every one of them. Not only because it's boring and time-consuming, but if we're going to have random encounters with goblins in the game world, we need to have the ability to create new goblins on the fly.</p>
			<p>Fortunately, we<a id="_idIndexMarker505"/> have a more fun (for us) solution: to write an algorithm generating a huge number of random goblin characters.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor532"/>Generating goblin names</h2>
			<p>In order to<a id="_idIndexMarker506"/> generate something, we need to find some kind of <em class="italic">generative rule</em>. To find such a rule, the best thing is to look at different examples of what we want to generate and try to figure out if some pattern connects them. For example, for goblin names, we can look for insight in a bunch of goblin names from World of Warcraft.</p>
			<p>Let's look at some of them: <em class="italic">Grizzle Gearslip</em>, <em class="italic">Hobart Grapplehammer</em>, and <em class="italic">Helix Blackfuse</em>. Continuing with this list, we may identify a common pattern:</p>
			<ul>
				<li>The names are composed of two or three syllables.</li>
				<li>The syllables have similar sounds, such as <em class="italic">Bax</em>, <em class="italic">Griz</em>, <em class="italic">Hel</em>, <em class="italic">Hob</em>, and so on.</li>
				<li>The surname is always composed of the name of an object or an adjective (gear, grapple, black, bolt) followed by a verb. </li>
				<li>The theme of the surnames is usually related to mechanical engineering.</li>
			</ul>
			<p>That's enough to get started. We create a new scene, and we create a new script called <code>GoblinNameGenerator</code>, and we paste inside the<a id="_idTextAnchor533"/><a id="_idTextAnchor534"/> following code:</p>
			<pre>class GoblinNameGenerator {
    static string[] NameDatabase1 = { "Ba", "Bax", "Dan", 
      "Fi", "Fix", "Fiz", }; //... and more 
    static string[] NameDatabase2 = { "b", "ba", "be",
      "bi", "d", "da", "de","di", }; // ... and more 
    static string[] NameDatabase3 = { "ald", "ard", "art",
      "az", "azy", "bit","bles", "eek", "eka", "et",
      "ex", "ez", "gaz", "geez", "get", "giez",
<a id="_idTextAnchor535"/><a id="_idTextAnchor536"/>      "iek", }; // ... and more
    static string[] SurnameDatabase1 = { "Bolt", "Boom",
      "Bot", "Cog", "Copper","Damp", "Dead", "Far", "Fast",
      "Fiz", "Fizz", "Fizzle", "Fuse", "Gear",
      "Giga", "Gold", "Grapple" }; // ... and more
    static string[] SurnameDatabase2 = { "basher", "blade",
      "blast", "blaster","bolt", "bomb", "boot", "bottom",
      "bub", "button", "buttons", "cash",
      "clamp", };  // ... and more
    private static string RandomInArray(string[] array) {
        return array[Random.Range(0, array.Length)];
    }
    public static string RandomGoblinName() {
        return RandomInArray(NameDatabase1) + 
          RandomInArray(NameDatabase2) +
            RandomInArray(NameDatabase3) + " " +
            RandomInArray(SurnameDatabase1) + 
            RandomInArray(SurnameDatabase2);
    }
}</pre>
			<p>This code straightforwardly converts the rules of goblin names into a procedural algorithm. The <code>NameDatabase1</code>, <code>NameDatabase2</code>, and <code>NameDatabase3</code> arrays contain the first, middle, and last syllables of the first name. Similarly, <code>SurnameDatabase1</code> and <code>SurnameDatabase2</code> have the two parts of a goblin's surname. To <a id="_idIndexMarker507"/>generate the name, we chose a random piece from each list, and we put everything together.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor537"/>Completing the goblin description</h2>
			<p>Now that we <a id="_idIndexMarker508"/>have a name, we need only other small details. So, let's create an empty object and attach to it a new <code>MonoBehavior</code> instance named <code>GoblinWriter</code>.</p>
			<p>This new script contains th<a id="_idTextAnchor538"/><a id="_idTextAnchor539"/><a id="_idTextAnchor540"/>e following code:</p>
			<pre>using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class GoblinWriter : MonoBehaviour {
    public TMPro.TextMeshProUGUI textMesh;
    public List&lt;string&gt; goblinJobs;
    public int goblinMaxAge = 200;
    void Start() {
        UpdateString();
    }
    void Update() {
        if (Input.GetKeyDown(KeyCode.Space)) {
            UpdateString();
        }
    }
    void UpdateString() {
        string goblinName =
          GoblinNameGenerator.RandomGoblinName();
        string goblinAge = Random.Range(20,
          goblinMaxAge).ToString();
        string goblinJob = goblinJobs[Random.Range(0, 
          goblinJobs.Count)];
        textMesh.text = $"{goblinName} is a {goblinAge} 
          years old goblin {goblinJob}.";
    }
}</pre>
			<p>The script has three<a id="_idIndexMarker509"/> exposed properties. The first, <code>textMesh</code>, is a reference to the TextMesh element that will show the text on screen (you can create one by going to <code>goblinJobs</code>, stores a list of jobs we want to give to the goblins. As you can see in <em class="italic">Figure 10.1</em>, I added four jobs: <code>goblinMaxAge</code>, represents the maximum age for my goblins.</p>
			<div><div><img src="img/B17984_10_1.jpg" alt="Figure 10.1 – The Goblin Writer script in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – The Goblin Writer script in the Inspector</p>
			<p>Whenever we call <code>UpdateString</code> (that is, at the start of the game and every time we press <em class="italic">Spacebar</em>), we<a id="_idIndexMarker510"/> simply extract a value from the set of possible values for the age, the job, and the name, and construct a string. Once we have everything set up, we can run the demo, and we should see a new goblin description every time we press <em class="italic">Spacebar</em> (<em class="italic">Figure 10.2</em>).</p>
			<div><div><img src="img/B17984_10_2.jpg" alt="Figure 10.2 – One of the many random goblins we can generate&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – One of the many random goblins we can generate</p>
			<p>The example is simple, but it is an effective way to add variety to any game.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">The Dungeon Master manual of the fifth edition of Dungeon &amp; Dragons contains several examples of this kind of <em class="italic">composition and randomness-driven</em> procedural generation. Inside it, you can find a lot of tables to generate treasures, weapons, side-quests, characters, and so on. Sure, it is designed to be used with pen and dice, but nothing stops you from translating paper algorithms into computer algorithms!</p>
			<p>Now that we <a id="_idIndexMarker511"/>have a taste for procedural generation, let's step up the game. Let's introduce another handy tool for the PCG developer: Perlin noise.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor541"/>Learning how to use Perlin noise</h1>
			<p><strong class="bold">Perlin noise</strong> is an algorithm <a id="_idIndexMarker512"/>to define digital noise developed by Ken Perlin in 1983. It quickly became the de facto algorithm to generate natural-looking patterns in a considerable number of procedural content generation algorithms. For example, Perlin noise is used to create 3D landscapes, 2D textures, procedural animations, and much more.</p>
			<div><div><img src="img/B17984_10_3.jpg" alt="Figure 10.3 – The difference between Perlin noise (left) and white noise (right)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – The difference between Perlin noise (left) and white noise (right)</p>
			<p>But what makes Perlin<a id="_idIndexMarker513"/> noise different from other noises? The short answer is that it looks more <em class="italic">natural</em>. This answer, however, just changes the question into <em class="italic">what does it mean to be more natural?</em> Let's imagine standard non-Perlin noise, for instance, a sequence of random numbers between 0 and 1. The sequence may be something like 0, 0.9, 0.2, 0.3, 0.95, and so on.</p>
			<p>As you can see, the numbers can jump up and down without any criteria. If these numbers represent the position of a character in the game, the character will appear to teleport itself left and right frantically. That is not how things move in real life.</p>
			<p>Perlin noise is different because, in the sequence of numbers, two consecutive numbers will always be close together. For example, after 0.9 we may have 0.91, 0.92, or 0.88 but never 0.1. The effect is like a buoy floating on the sea: it can move unpredictably left and right, up and down, but with a certain smoothness – a certain naturalness.</p>
			<p>This looks perfect. However, how can we use Perlin noise in Unity? Luckily, Unity offers the Perlin noise algorithm as a built-in tool.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor542"/>Built-in Unity Perlin noise</h2>
			<p>Unity offers a<a id="_idIndexMarker514"/> simple function to access Perlin noise:</p>
			<pre>Mathf.PerlinNoise(xCoord, yCoord);</pre>
			<p>Unity implements Perlin noise as an infinite 2D plane that you can randomly sample in code using the <code>Mathf.PerlinNoise</code> function. You can simply sample a random coordinate to get a <em class="italic">random</em> value on the Perlin noise plane.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">Note that Unity only offers you 2D Perlin noise. However, Perlin noise can be easily extended to 3D (for instance, to create volumetric smoke) or even four and more dimensions. If you need 3D Perlin noise, you need to develop the algorithm yourself or look for the many open source implementations you can find online (for instance, <a href="https://gist.github.com/tntmeijs/6a3b4587ff7d38a6fa63e13f9d0ac46d">https://gist.github.com/tntmeijs/6a3b4587ff7d38a6fa63e13f9d0ac46d</a>).</p>
			<p>Imagine you want to create a random 2D texture using Unity's built-in Perlin noise. You can do that by starting at an arbitrary point (<code>xStart</code> and <code>yStart</code>) and then copying every surrounding point's value into the texture as you can see in the following example (the full <code>PerlinTexture.cs</code> file is included in the GitHub repository):</p>
			<pre>    void CalculateNoise() {
        for (float y = 0.0f; y &lt; noiseTex.height; y++) {
            for (float x = 0.0f; x &lt; noiseTex.width; x++) {
                float xCoord = 
                  xOrg + x / noiseTex.width * scale;
                float yCoord = 
                  yOrg + y / noiseTex.height * scale;
                float value = 
                  Mathf.PerlinNoise(xCoord, yCoord);
                pix[(int)y * noiseTex.width + (int)x] = 
                  new Color(value, value, value);
            }
        }
        // Copy the pixel data to the texture and load it 
        // into the GPU.
        noiseTex.SetPixels(pix);
        noiseTex.Apply();
    }</pre>
			<p>However, we can also use 2D Perlin noise to generate 1D Perlin noise. In that case, we fix one coordinate (<code>x</code> or <code>y</code>) and we move the other in a straight line.</p>
			<p>Suppose we want<a id="_idIndexMarker515"/> to animate a bobbing sphere, floating gently up and down like a balloon. We can do that by setting its <em class="italic">y</em> coordinate (canonically representing the up and down direction) to the value of the Perlin noise:</p>
			<pre>using UnityEngine;
public class Bobbling : MonoBehaviour {
    // Range over which height varies.
    public float heightScale = 1.0f;
    // Distance covered per second along X axis of Perlin
    // plane.
    public float xScale = 1.0f;
    void Update() {
        float height = heightScale *
          Mathf.PerlinNoise(Time.time * xScale, 0.0f);
        Vector3 pos = transform.position;
        pos.y = height;
        transform.position = pos;
    }
}  </pre>
			<p>If you attach this small script to any object, you will see the object randomly moving up and down.</p>
			<p>That's just the tip of the iceberg of Perlin noise application, but I hope that it will get you started. However, it<a id="_idIndexMarker516"/> is time for us to continue our journey into PCG. In the next section, we will generate a random cave using a new technique<a id="_idIndexMarker517"/> called <strong class="bold">Cellular Automata</strong>.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor543"/>Generating random maps and caves</h1>
			<p>Another<a id="_idIndexMarker518"/> widespread <a id="_idIndexMarker519"/>application of PCG is the generation of maps and dungeons. For example, in the <em class="italic">roguelike</em> genre (a type of game that takes its name from the 1980s game <em class="italic">Rogue</em>), players face a randomly generated dungeon every time they start a game. Likewise, in <em class="italic">Minecraft</em>, players begin the game by generating a random world to explore and in which they need to survive. The examples are numerous – too many to be listed here.</p>
			<p>There are significant numbers of algorithms to create game worlds. Some use fractal noise to generate random heightmaps. Some others create dungeon-like structures by creating random rooms and connecting them with corridors. Others build maps by randomly arranging manually premade rooms into a myriad of different combinations like in a puzzle (if you have ever played the tabletop game <em class="italic">Carcassonne</em>, you know what I am talking about).</p>
			<p>This demo will explore a simple technique well suited for the generation of caves or natural-looking scenes, called <strong class="bold">Cellular Automata</strong>.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor544"/>Cellular automata</h2>
			<p><strong class="bold">Cellular Automata</strong> (<strong class="bold">CA</strong>) is not <a id="_idIndexMarker520"/>only a PCG algorithm. CA have been studied since 1950 as an abstract computational model. However, their popularity exploded only after the release of <em class="italic">Conway's Game of Life</em> in the 70s.</p>
			<p>The basic idea of CA is to simulate the behavior of <em class="italic">cells</em> in a 2D grid. Each cell in the grid has two states: dead or alive. Each <em class="italic">cell</em> will die or live depending on rules that depend only on their neighbors.</p>
			<div><div><img src="img/B17984_10_4.jpg" alt="Figure 10.4 – A configuration of cells in the Game of Life&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – A configuration of cells in the Game of Life</p>
			<p>The behavior of a CA algorithm depends only on these evolution rules. So, we start from an initial<a id="_idIndexMarker521"/> configuration of alive and dead cells and then let the system evolve independently. In <em class="italic">Game of Life</em>, for example, we have four simple rules:</p>
			<ul>
				<li>Live cells with fewer than two live neighbors are underpopulated, and therefore they die.</li>
				<li>Live cells with two or three live neighbors keep living in the next generation.</li>
				<li>Live cells with more than three live neighbors are overpopulated, and therefore they die.</li>
				<li>Dead cells with exactly three live neighbors become alive again due to <em class="italic">reproduction</em>.</li>
			</ul>
			<p>It turns out that these four simple rules are powerful enough to make the algorithm itself Turing complete. This means that it is possible to write a configuration of live and dead cells that, after applying the above four rules, is able to do any computation like a normal computer, for instance, multiplying numbers or playing chess. If you are interested in this, Paul Rendell has a detailed description of the pattern on his web page (<a href="http://rendell-attic.org/gol/tm.htm">http://rendell-attic.org/gol/tm.htm</a>). </p>
			<p>But let's come back to our goal. Luckily for us, we need to do something much more simple than implementing a CPU with our CA. In PCG, CA are an excellent choice because they <a id="_idIndexMarker522"/>are easy to implement and generate maps that look like natural environments such as deserts, caves, island archipelagos, and so on.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor545"/>Implementing a cave generator</h2>
			<p>To implement our<a id="_idIndexMarker523"/> cave generator, we need two components:</p>
			<ul>
				<li>A component that generates and stores the map abstractly (for example, as an array of integers)</li>
				<li>A component that will render the abstract map in a visible 3D object in the game</li>
			</ul>
			<p>So, let's start by implementing the first component. <a id="_idTextAnchor546"/><a id="_idTextAnchor547"/>We'll <a id="_idIndexMarker524"/>call it <code>CaveGenerator</code>:</p>
			<pre>using UnityEngine;
using System;
public class CaveGenerator : MonoBehaviour {
    [SerializeField]
    private int width;
    [SerializeField]
    private int height;
    [SerializeField]
    private int seed;
    [Ser<a id="_idTextAnchor548"/><a id="_idTextAnchor549"/>ializeField]
    private bool useRandomSeed;
    private int[,] map;
    void Start() {
        In<a id="_idTextAnchor550"/><a id="_idTextAnchor551"/>itializeRandomGrid();
        DrawCaveMesh();
    }
    void Update() {
        if (Input.GetKeyDown(KeyCode.G)) {
            CellularAutomata(false);
            DrawCaveMesh();
        } else if (Input.GetKeyDown(KeyCode.Space)) {
            CellularAutomata(true);
            DrawCaveMesh();
        } else if (Input.GetKeyDown(KeyCode.N)) {
            InitializeRandomGrid();
            DrawCaveMesh();
        }
    }</pre>
			<p>The component exposes four attributes to the Inspector. The first two are simply the <code>weight</code> and <code>height</code> of the map expressed as <em class="italic">number of cells</em>. Then we have the <code>seed</code> of the random generator in case we want to create specific maps (this is especially useful for debugging purposes). In general, though, we want a random map every time we start the game; that's why we have a <code>useRandomSeed</code> property: if it is <code>true</code>, we initialize a random seed. Finally, we have a private bidimensional array to store the <code>map</code> representation.</p>
			<p>After the properties specification, we need to initialize the <code>Start</code> and <code>Update</code> callbacks. These functions will simply call the other functions that we will define next. In <code>Update</code>, we can also see the keys we use to control the demo: every time we press <em class="italic">Spacebar</em>, we run another step of the CA simulation; when we press the <em class="italic">N</em> key, we initialize a new map.</p>
			<p>When we press the <em class="italic">G</em> key, we run a different rule for the CA (more on this when we set up the CA rules).</p>
			<p>We'll now<a id="_idIndexMarker525"/> implement the <code>InitializeRandomGrid</code> function. This function initializes the map with random dead and alive cells. However, there are two additional tips. First, the function creates a border of walls (alive cells) around the map. This is because maps are usually bounded, and we do not want the players to jump off the map. This border of walls will ensure that the final map will not have caves<a id="_idTextAnchor552"/><a id="_idTextAnchor553"/> leading out of the map edges:</p>
			<pre>    void InitializeRandomGrid() {
        map = new int[width, height];
        if (useRandomSeed) {
            seed = (int)DateTime.Now.Ticks;
        }
        System.Random randomGen =
          new System.Random(seed.GetHashCode());
        int mapMiddle = (height / 2);
        for (int c = 0; c &lt; width; c++) {
            for (int r = 0; r &lt; height; r++) {
                if (c == 0 || c == width - 1 || r == 0 || r
                     == height - 1) {
                    map[c, r] = 1;
                } else <a id="_idTextAnchor554"/><a id="_idTextAnchor555"/>{
                    if (c == mapMiddle) {
                        map[c, r] = 0;
                    } else {
                        map[c, r] = (randomGen.Next(0, 100)
                          &lt; 50) ? 1 : 0;
                    }
                }
            }
        }
    }</pre>
			<p>The second trick is to<a id="_idIndexMarker526"/> keep a vertical line of empty spaces (dead cells). That's the purpose of the check on the <code>mapMiddle</code> variable. The motivation for this blank line is simple: it empirically gives better results by generating a main connected cave extending over the entire map. You can remove it to get multiple isolated smaller caves or find a different starting pattern that offers a better outcome according to your tastes and use cases. The <code>InitializeRandomGrid</code> function initializes something like the image in <em class="italic">Figure 10.5</em>.</p>
			<div><div><img src="img/B17984_10_5.jpg" alt="Figure 10.5 – The initial state of the map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – The initial state of the map</p>
			<p>Now, we'll look at a<a id="_idIndexMarker527"/> small utility function that we use to count the walls <a id="_idTextAnchor556"/><a id="_idTextAnchor557"/>arou<a id="_idTextAnchor558"/><a id="_idTextAnchor559"/>nd a specific map cell:</p>
			<pre>    int GetSurroundingWallCount(int c, int r, int size) {
        int wallCount = 0;
        for (int iX = c - size; iX &lt;= c + size; iX ++) {
            for (int iY = r - size; iY &lt;= r + size; iY ++)
            {
                if (iX != c || iY != r) {
                    wallCount += isWall(iX, iY) ? 1 : 0;
                }
            }
        }
        re<a id="_idTextAnchor560"/><a id="_idTextAnchor561"/>turn wallCount;
    }
    bool isWall(int c, int r) {
        if (c &lt; 0 || r &lt; 0) {
            return true;
        }
        if (c &gt; width - 1 || r &gt; height - 1) {
            return true;
        }
        return map[c, r] == 1;
    }</pre>
			<p>The first function is straightforward. It looks at the cells around the target coordinates and counts the number of walls. It also takes a <code>size</code> parameter indicating the <em class="italic">radius</em> around the target coordinate. If <code>size</code> is equal to <code>1</code>, we check the eight cells around the target coordinates (imagine a 3x3 square). If <code>size</code> is equal to <code>2</code>, we also check the neighbors' neighbors (imagine a 5x5 square).</p>
			<p>The <code>isWall</code> function is used to check if a specific coordinate represents a wall. You may ask: why <a id="_idIndexMarker528"/>don't we just check the value of <code>map</code> at <code>(c,r)</code>? Because we may enter coordinates outside the array (for instance, <code>(-1,-1)</code>). In that case, we assume that every cell outside the map is a wall (and it will remain a wall). This simplifies the logic for <code>GetSurroundingWallCount</code>.</p>
			<p>Now it is time to get<a id="_idTextAnchor562"/><a id="_idTextAnchor563"/> to the meat – the CA rules:</p>
			<pre>    void CellularAutomata(bool clean = false) {
        int[,] newmap = new int[width, height];
        for (int c = 0; c &lt; width; c ++) {
            for (int r = 0; r &lt; height; r ++) {
                int numWalls = 
                  GetSurroundingWallCount(c, r, 1);
                int numWalls2 = 
                  GetSurroundingWallCount(c, r, 2);
                if (isWall(c,r)) {
                    if (numWalls &gt; 3) {
                        newmap[c, r] = 1;
                    } else {
                        newmap[c, r] = 0;
                    }
                } else {
                    if (!clean) {
                        if (numWalls &gt;= 5 || numWalls2 &lt;= 
                            2) {
                            newmap[c, r] = 1;
                        } else {
                            newmap[c, r] = 0;
                        }
                    } else {
                        if (numWalls &gt;= 5) {
                            newmap[c, r] = 1;
                        } else {
                            newmap[c, r] = 0;
                        }
                    }
                }
            }
        }
        map = newmap;
    }</pre>
			<p>For the cave generator, we use two sets of rules. The first set (obtained when <code>clean</code> is equal to <code>true</code>) is described as follows:</p>
			<ul>
				<li>If a cell is a wall, it remains a wall as long as it has more than three neighboring walls. Otherwise, it becomes an empty space.</li>
				<li>If a cell is empty, it remains empty as long as it has fewer than five neighboring walls. Otherwise, it becomes a wall.</li>
			</ul>
			<p>The second set of rules is identical to the first, but it also checks the neighbors of radius <code>2</code>. If too many empty spaces surround an empty cell, then it becomes a wall. This optional behavior removes large empty spaces, promoting more narrow passages. However, this can also leave isolated 1x1 walls that look like noise (which is why this set of rules is <a id="_idIndexMarker529"/>enabled with the <code>clean</code> parameter equal to <code>false</code>).</p>
			<p>By running these rules, we get maps such as the one in <em class="italic">Figure 10.6</em>.</p>
			<div><div><img src="img/B17984_10_6.jpg" alt="Figure 10.6 – A random cave generated by our algorithm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – A random cave generated by our algorithm</p>
			<p>We now have a perfectly working algorithm but no way to show it in the game. For this, we hav<a id="_idTextAnchor564"/><a id="_idTextAnchor565"/>e the <code>DrawCaveMesh</code> function:</p>
			<pre>    void DrawCaveMesh() {
        MeshGenerator meshGen =
          GetComponent&lt;MeshGenerator&gt;();
        meshGen.GenerateMesh(map, 1);
    }</pre>
			<p>This function simply<a id="_idIndexMarker530"/> invokes a mesh generator. We will implement <code>MeshGenerator</code> in the next section.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor566"/>Rendering the generated cave</h2>
			<p>Given the abstract <a id="_idIndexMarker531"/>map representation (the bidimensional array stored in <code>map</code>), we need something that converts it into a mesh rendered on screen. We can do this in multiple ways. To allow flexibility, we start <a id="_idTextAnchor567"/><a id="_idTextAnchor568"/>by defining an abstract component:</p>
			<pre>using UnityEngine;
public abstract class MeshGenerator : MonoBe<a id="_idTextAnchor569"/><a id="_idTextAnchor570"/>haviour {
    abstract public void GenerateMesh(int[,] map, float
                                      squareSize);
}</pre>
			<p>This simple abstract class tells Unity that <a id="_idIndexMarker532"/>every valid <code>MeshGenerator</code> should contain a <code>GenerateMesh</code> function. This function takes as input the array map and the size of each cell expressed in Unity units.</p>
			<p>That's cool, but obviously not very useful right now. We still cannot render anything. Do not worry; we will now implement a simple mesh renderer.</p>
			<h3>Basic mesh renderer</h3>
			<p>The idea of this<a id="_idIndexMarker533"/> renderer is to spawn a 1x1 cube for each wall cell. We'<a id="_idTextAnchor571"/><a id="_idTextAnchor572"/>ll call this renderer <code>WallGenerator</code>:</p>
			<pre>public class WallGenerator : MeshGenerator {
    public GameObject<a id="_idTextAnchor573"/><a id="_idTextAnchor574"/> wallCube;
    public override void GenerateMesh(int[,] map, 
      float squareSize) {
        foreach (Transform t in transform) {
            Destroy(t.gameObject);
        }
        int width = map.GetLength(0);
        int height = map.GetLength(1);
        for (int c = 0; c &lt; width; c++) {
            for (int r = 0; r &lt; height; r++) {
                if (map[c, r] == 1) {
                    GameObject obj = Instantiate(wallCube,
                      new Vector3(c * squareSize, 0, r *
                      squareSize), Quaternion.identity);
                    obj.transform.parent = transform;
                }
            }
        }
        transform.position = 
          new Vector3(-width / 2.0f, 0, -height / 2.0f);
        MergeCubes();
    }</pre>
			<p>First of all, note that <a id="_idIndexMarker534"/>this class extends our abstract <code>MeshGenerator</code> class. Second, this component exposes a single parameter called <code>wallCube</code>. This parameter contains a reference to a wall prefab (basically a colored 3D cube).</p>
			<p>Then, we implement the <code>GenerateMesh</code> function. The implementation is once again straightforward:</p>
			<ol>
				<li>We destroy all the existing walls (stored as children).</li>
				<li>Then, we iterate over every cell in the abstract map and spawn a <code>wallCube</code> object in the proper location.</li>
				<li>We shift the map by half the size (for visualization purposes).</li>
			</ol>
			<p>There is a problem, though. Unity is not suitable for spawning thousands of GameObjects. So, if our map is 200x200, this function will potentially spawn 40,000 GameObjects just for rendering the map. The result will be a pretty slow game (and we are not even spawning characters yet).</p>
			<p>Fortun<a id="_idTextAnchor575"/><a id="_idTextAnchor576"/>ately, there<a id="_idIndexMarker535"/> is a quick solution:</p>
			<pre>    private void MergeCubes() {
        transform.GetComponent&lt;MeshFilter&gt;().mesh = 
          new Mesh();
        MeshFilter[] meshFilters =
          GetComponentsInChildren&lt;MeshFilter&gt;();
        CombineInstance[] combine = 
          new CombineInstance[meshFilters.Length];
        int i = 0;
        while (i &lt; meshFilters.Length) {
            combine[i].mesh = meshFilters[i].sharedMesh;
            combine[i].<a id="_idTextAnchor577"/><a id="_idTextAnchor578"/>transform =
<a id="_idTextAnchor579"/><a id="_idTextAnchor580"/>              meshFilters[i].transform.localToWorldMatrix;
            meshFilters[i].gameObject.SetActive(false);
            i++;
        }
        transform.GetComponent&lt;MeshFilter&gt;()<a id="_idTextAnchor581"/><a id="_idTextAnchor582"/>.mesh = 
          new Mesh();
        transform.GetComponent&lt;MeshFilter&gt;()
          .mesh.indexFormat = 
          UnityEngine.Rendering.IndexFormat.UInt32;
        transform.GetComponent&lt;MeshFilter&gt;()
          .mesh.CombineMeshes(combine, true);
        transform.gameObject.SetActive(true);
        foreach (Transform t in ransform) {
            Destroy(t.gameObject);
        }
    }</pre>
			<p>The <code>MergeCubes</code> function <a id="_idIndexMarker536"/>takes all the cubic children we just spawned and combines them in a single game object with a single mesh. We do that by leveraging the built-in <code>CombineMeshes</code> tool.</p>
			<p>As you can see in the preceding code, we first get all the children (all the individual walls). Then, for each one of them, we create <code>CombineInstance</code>. The only tricky thing to remember is to store the coordinates of the mesh in world coordinates (Unity does that by calling <code>.transform.localToWorldMatrix</code>).</p>
			<p>Once we have all the <code>CombineInstance</code> objects, we replace the map's mesh with the mesh obtained by combining all the walls.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">Depending on the size of the map, the default mesh <code>IndexFormat</code> may be unable to contain all the vertices of the combined mesh. We can solve this by using 32-bit indexing with <code>transform.GetComponent&lt;MeshFilter&gt;().mesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;</code>.</p>
			<p>Finally, we destroy all the children.</p>
			<p>Now we can set up the scene. The final outcome is shown in the following screenshot.</p>
			<div><div><img src="img/B17984_10_7.jpg" alt="Figure 10.7 – The CaveGen Hierarchy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – The CaveGen Hierarchy</p>
			<p>First, let's create <a id="_idIndexMarker537"/>a big plane to use for the ground level, and then an object called <code>CaveGen</code>. The <code>CaveGen</code> object contains a <code>MeshRenderer</code> and a <code>MeshFilter</code> component (but no mesh).</p>
			<p>Now attach the <code>CaveGenerator</code> and <code>WallRenderer</code> components to this object and configure them as in the following screenshot.</p>
			<div><div><img src="img/B17984_10_8.jpg" alt="Figure 10.8 – The CaveGenerator and WallGenerator components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – The CaveGenerator and WallGenerator components</p>
			<p>The final touch is <a id="_idIndexMarker538"/>adding a <strong class="bold">Wall</strong> prefab to <strong class="bold">Wall Cube</strong>. Then, finally, we can click <strong class="bold">Play</strong>, and we should see something similar to <em class="italic">Figure 10.9</em>.</p>
			<div><div><img src="img/B17984_10_9.jpg" alt="Figure 10.9 – The initial random configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – The initial random configuration</p>
			<p>We can now continue the map generation by pressing <em class="italic">Spacebar</em> (or <em class="italic">G</em> if we want to apply the second set of CA rules). After some time, you may note that the map stabilizes into a map like the one in <em class="italic">Figure 10.10</em>. At that point, your map is ready (but you can start over by <a id="_idIndexMarker539"/>pressing <em class="italic">N</em>).</p>
			<div><div><img src="img/B17984_10_10.jpg" alt="Figure 10.10 – The completely evolved map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – The completely evolved map</p>
			<p>Not bad for a PCG <a id="_idIndexMarker540"/>algorithm that we wrote in less than 130 lines of code.</p>
			<h3>Advanced mesh renderer</h3>
			<p><code>WallGenerator</code> is <a id="_idIndexMarker541"/>quick and<a id="_idIndexMarker542"/> effective; however, it is not optimal. The final mesh contains a lot of redundant vertices, and we still have this pixelated look. There are many other different algorithms that we can use to generate a mesh. A standard solution is to use<a id="_idIndexMarker543"/> the <strong class="bold">Marching Squares</strong> algorithm (also called <strong class="bold">Marching Cubes</strong> if <a id="_idIndexMarker544"/>applied to 3D).</p>
			<p>This algorithm is a bit complex, and a detailed discussion would go way beyond the scope of this book. However<a id="_idTextAnchor583"/><a id="_idTextAnchor584"/>, in the code of this demo, I've included a <code>MarchingCubesGenerator</code> component for you to use and explore. The algorithm is taken from an official Unity tutorial (<a href="https://www.youtube.com/watch?v=yOgIncKp0BE">https://www.youtube.com/watch?v=yOgIncKp0BE</a>) and I have adapted it for this demo.</p>
			<p>To use it, you just need to replace the <code>WallGenerator</code> component with <code>MarchingCubesGenerator</code>. If you now run the game and run the CA for a couple of generations, you<a id="_idIndexMarker545"/> should see something like <em class="italic">Figure 10.11</em>.</p>
			<div><div><img src="img/B17984_10_11.jpg" alt="Figure 10.11 – The map rendered using MarchingCubesGenerator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – The map rendered using MarchingCubesGenerator</p>
			<p>As you can<a id="_idIndexMarker546"/> see, we get smoother walls and much fewer vertices (with improved performance). If you like this cave generator and want to explore it in depth, I encourage you to go to the official tutorial by navigating to <a href="https://learn.unity.com/tutorial/generating-content">https://learn.unity.com/tutorial/generating-content</a>.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor585"/>Summary</h1>
			<p>In this chapter, we barely scratched the surface of PCG. First, we started with a simple algorithm to create randomized goblin biographies. Then, we unleashed the power of CA to develop an intricate cave system and discovered two techniques to render abstract grids in 3D maps.</p>
			<p>However, as I said, this is just the beginning. PCG represents a massive class of algorithms blending the boundary between programming and art. PCG alone is a programming field worth exploring, and this short chapter's goal was to give you just a tiny taste of it.</p>
			<p>Now, though, we have no more time for PCG. It is time to move on to machine learning in the next chapter.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor586"/>Further reading</h1>
			<p>If you are interested in a deeper exploration of PCG in Unity, Ryan Watkins wrote an entire book on the topic titled <em class="italic">Procedural Content Generation for Unity Game Development</em> for <em class="italic">Packt</em>.</p>
		</div>
	</body></html>